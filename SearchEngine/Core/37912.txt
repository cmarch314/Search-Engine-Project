{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 232D Arrangements Ester Ezra Eyal Flato Dan Halperin Iddo Hanniel Shai Hirsch and Ron Wein 23 1 Introduction Given a collection of possibly intersecting and not necessarily x monotone curves in the plane the planar arrangement of is the subdivision the curves of induce on the plane into zero dimensional one dimensional and two dimensional cells called vertices edges and faces respectively 23 2 Software Design The class Arrangement 2 Dcel Traits Base node is a data structure for maintaining 2D arrangements The data structure maintains a planar map and curve hierarchy trees There is a curve tree for each curve inserted into the arrangement see below The underlying combinatorial structure is determined by the Dcel template parameter which should be a model of the ArrangementDcel 2 concept The family of curves of the arrangement is determined by the Traits template parameter which should be a model of the ArrangementTraits 2 concept The Base node template parameter defines the attributes associated with each tree node of the hierarchy tree The Arrangement package is based on the Planar Map with Intersections package see Chapter That is given a collection we construct a collection in two steps First we decompose each curve in into maximal x monotone curves thus obtaining the collection We then decompose each curve in into maximal connected pieces not intersecting any other curve in This way we obtain the collection of x monotone pairwise interior disjoint curves The arrangement of the curves in C is the planar map see Chapter induced by the curves in C Curve Hierarchy Tree When constructing the arrangement of a collection of curves we decompose each curve c in two steps First we decompose it into maximal x monotone curves thus obtaining a set of curves C We then decompose each curve in C into maximal connected pieces not intersecting any other curve in obtaining the set C We regard these sets C C as levels in a hierarchy of curves where the union of the subcurves in each level is the original curve c We store these sets in a special structure a hierarchy tree This structure usually consists of three levels although in some cases they can consist of less e g when inserting an x monotone curve or more when the users define their own split functions see Section The levels are Curve node level the root of the tree holds the original curve c Subcurve node level inner nodes of the tree hold decomposed subcurves of the original curve In the default mode these are x monotone curves that is these nodes correspond to the sub curves of C Edge node level leaves of the tree hold the curves corresponding to the edges of the planar map induced by the arrangement usually these nodes correspond to the sub curves of C These nodes will be built only in update mode by default the arrangement is in update mode Figure shows an example of a simple arrangement and its corresponding curve hierarchy Figure A simple arrangement of two polylines and its corresponding hierarchy tree the edges of the arrangement are numbered according to their order in the tree The hierarchy tree enables us to intersect the curves without loss of information The original curve and the intermediate subcurves are stored in the tree and the user can traverse them Furthermore users can define their own hierarchy by passing their own intersection sequence This can be of use in some applications For example in an arrangement of spline curves the users might want to intersect a curve in the junction points before making the curve x monotone Degeneracies Like the planar map package see Chapter the arrangement package can deal with x degenerate input including vertical segments However while in the planar map the input curves were assumed to be x monotone and non intersecting in their interiors there are no such assumptions in the arrangement A non x monotone curve is partitioned into x monotone subcurves and curves are intersected in their points of intersection with other points before they are inserted into the map Furthermore overlapping curves are supported If two curves overlap the traits intersection function returns the two endpoints of the common part Circulators of the Overlap circulator type of Arrangement 2 Dcel Traits Base node enables to traverse all overlapping edge nodes that correspond to the same pair of halfedges in the map I O functions I O functions for reading a saved arrangement from the standard input writing it to the standard output or drawing it to a graphic stream are also provided Users of I O functions for the arrangement package are required to define I O operators for the curves defined in their Traits classes Update Mode For some algorithms it is not necessary to build the whole planar map induced by the arrangement For example the lower envelope of an arrangement of x monotone curves that intersect each other at most a fixed constant number of s times can be found in near linear time SA95 Hal97 even if the complexity of the planar map induced by it is quadratic Therefore building the planar map induced by the arrangement is not always desired The users can therefore disable or postpone the building of the planar map This is done by disabling the update mode using the set update bool member function When update mode is set to true the planar map is updated this is the default situation When update mode is set to false the hierarchy tree is built without its Edge level and the curves are not inserted into the planar map 23 3 Segment Arrangements The second template parameter of the arrangement class determines the so called geometry of the arrangement that is the family of curves we want to deal with In order to deal with line segments we simply plug in on of the two segment traits classes supplied The Arr segment traits 2 Kernel class is generic and allows flexibility in determining the kernel which is used It makes intensive use of the kernel since it support almost all the operations needed by the arrangement package The Arr segment cached traits 2 Kernel class stores some additional cached information with each segment curve Choosing to work with this traits class means a little extra memory consumption however it usually speeds up the construction time of the arrangement 23 3 1 Example of an Arrangement of Segments The following example demonstrates the construction of an X shaped arrangement out of two segments After the construction we traverse the edges of the arrangement in the order defined by the original segments The four numbers on each output lines is a representation of a segment The first two numbers are the x and y coordinates of the first endpoint The other two numbers are of the second endpoint The way a curve is printed depends on the the output operator implemented for it file examples Arrangement 2 example1 C include short names h include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Arr 2 default dcel h include CGAL Arr segment traits 2 h include CGAL Arrangement 2 h typedef CGAL Quotient CGAL MP Float NT typedef CGAL Cartesian NT Kernel typedef CGAL Arr segment traits 2 Kernel Traits typedef Traits Point 2 Point 2 typedef Traits Curve 2 Curve 2 typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits Dcel typedef CGAL Arrangement 2 Dcel Traits Arr 2 int main Arr 2 arr insertion of the curves arr insert Curve 2 Point 2 Point 2 1 1 arr insert Curve 2 Point 2 1 Point 2 1 traversal of the curves Arr 2 Curve iterator cit Arr 2 Edge iterator eit for cit arr curve node begin cit arr curve node end cit std cout std endl Curve level std endl cit curve std endl std cout Edge level std endl traversal of the edges of the current curve for eit cit edges begin eit cit edges end eit std cout eit x curve std endl return The output of the program looks like this Curve level 1 1 Edge level 5 5 5 5 1 1 Curve level 1 1 Edge level 1 5 5 5 5 1 23 3 2 Example of Overlapping Segments The following example demonstrates the construction of an arrangement out of two overlapping segments 2 2 and 1 1 3 3 After the insertion of the segments we traverse the halfedges of the arrangement and count the overlapping curves This is done using the overlap edges member function that returns an Overlap circulator With it we can circulate over all the edge nodes that correspond to the halfedge file examples Arrangement 2 example2 C include short names h include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Arr 2 default dcel h include CGAL Arr segment traits 2 h include CGAL Arrangement 2 h include CGAL circulator h typedef CGAL Quotient CGAL MP Float NT typedef CGAL Cartesian NT Kernel typedef CGAL Arr segment traits 2 Kernel Traits typedef Traits Point 2 Point 2 typedef Traits Curve 2 Curve 2 typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits Dcel typedef CGAL Arrangement 2 Dcel Traits Arr 2 int main Arr 2 arr Insertion of the curves arr insert Curve 2 Point 2 Point 2 2 2 arr insert Curve 2 Point 2 1 1 Point 2 3 3 Traversal of the halfedges Arr 2 Halfedge const iterator hit arr halfedges begin hit end arr halfedges end for hit hit end hit hit We skip the adjacent twin halfedge Arr 2 Overlap const circulator occ hit overlap edges occ end occ int count CGAL For all occ occ end count if count 1 std cout Edge occ x curve is covered by a single edge std endl else std cout Edge occ x curve is covered by count edges std endl return The output of the program looks like this Edge 1 1 is covered by a single edge Edge 1 1 2 2 is covered by 2 edges Edge 2 2 3 3 is covered by a single edge 23 4 Polyline Arrangements The Arr polyline traits 2 Segment traits class can be used to handle arrangements of polylines a k a poly segment A polyline can be created from any range of points where the ith and i 1 st points in the range represent the endpoints of the ith segment of the polyline The polyline traits class is templated with another traits class that supports the basic operations on segments 23 4 1 Example of a Polyline Arrangement The following example demonstrates the use of the polyline traits Observe that a polyline curve is constructed from a standard STL vector of points Note that a polyline point is not necessarily a vertex of the arrangement that is of the underlying Planar Map and an edge of the Planar Map need not be a segment The edges are only required to be x monotone and pairwise disjoint In the example below point 15 5 is not a vertex of the planar map The polyline to which it belongs is an edge of the planar map However one might expect the planar map or rather the edge level of the arrangement to be made of segments alone In such cases the user can define additional level of hierarchies as will be shown in the example in Section file examples Arrangement 2 example1 C Define shorter names to please linker g include short names h include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Arr 2 default dcel h include CGAL Arrangement 2 h include CGAL Arr segment traits 2 h include CGAL Arr polyline traits 2 h typedef CGAL Quotient CGAL MP Float NT typedef CGAL Cartesian NT Kernel typedef CGAL Arr segment traits 2 Kernel Seg traits typedef CGAL Arr polyline traits 2 Seg traits Traits typedef Traits Point 2 Point 2 typedef Traits Curve 2 Curve 2 typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits Dcel typedef CGAL Arrangement 2 Dcel Traits Arr 2 int main Arr 2 arr std vector Point 2 pts Curve 1 not x monotone pts push back Point 2 pts push back Point 2 1 1 pts push back Point 2 2 arr insert Curve 2 pts begin pts end Curve 2 x monotone pts clear pts push back Point 2 1 pts push back Point 2 15 5 pts push back Point 2 2 arr insert Curve 2 pts begin pts end Curve 1 is broken into two edges Point 2 1 1 turns into a vertex Arr 2 Locate type lt arr locate Point 2 1 1 lt CGAL assertion lt Arr 2 VERTEX return 23 5 Arrangements of Conic Arcs The Arr conic traits 2 Int kernel Alg kernel class can be used for constructing arrangement of bounded segments of algebraic curves of degree 2 conic curves That is it supports the construction of the arrangement of any collection of elliptic arcs a full ellipse or a circle may also be considered as a conic arc hyperbolic arcs parabolic arcs and also line segments The template has two template parameters The first template parameter Int kernel is a geometric kernel with an unbounded integer number type i e Int kernel FT or CfNT for short should be an unbounded integer that represents the coefficients of the conic curves The kernel Cartesian CORE BigInt is the most suitable choice for this parameter The second parameter Alg kernel is a geometric kernel whose number type Alg kernel FT or CoNT for short supports exact operations In addition to the arithmetic operations it must support the square root operation in an exact manner as well as the extraction of the kth largest root of a given polynomial with integral coefficients CoNT should be constructible from a CfNT and it is used to represent the coordinates of the arrangement vertices which are in general irrational algebraic numbers At current the CORE Expr is the only number type that fills all the requirements above and must be the number type of Alg kernel 23 5 1 Example of an Arrangement of Circular Arcs The following example demonstrates the use of the conic traits for constructing a simple arrangement of two circles The arrangement created by this example is depicted in Figure Note that each circle is divided to an upper half and a lower half both are x monotone The result of ray shooting operation from 1 upward exemplifies this since it returns a circular arcs whose end points are 3 4 and 5 Figure The arrangement generated by the example program file examples Arrangement 2 example3 C include short names h include CGAL basic h ifndef CGAL USE CORE To enable compilation without core int main return else include CGAL Cartesian h include CORE BigInt h include CGAL CORE Expr h include CGAL Arr 2 default dcel h include CGAL Arr conic traits 2 h include CGAL Arrangement 2 h typedef CORE BigInt CfNT typedef CGAL Cartesian CfNT Int kernel typedef Int kernel Point 2 Int point 2 typedef Int kernel Circle 2 Int circle 2 typedef CORE Expr CoNT typedef CGAL Cartesian CoNT Alg kernel typedef CGAL Arr conic traits 2 Int kernel Alg kernel Traits 2 typedef Traits 2 Point 2 Point 2 typedef Traits 2 Curve 2 Curve 2 typedef Traits 2 X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits 2 Dcel typedef CGAL Arrangement 2 Dcel Traits 2 Arr 2 int main Arr 2 arr 2 ccw circles with radius 5 and center and 6 resp Int circle 2 c1 Int point 2 5 5 Int circle 2 c2 Int point 2 6 5 5 Arr 2 Curve iterator cit arr insert Curve 2 c1 cit arr insert Curve 2 c2 upward vertical ray shooting Arr 2 Locate type lt Arr 2 Halfedge handle e arr vertical ray shoot Point 2 1 lt true CGAL assertion e source point Point 2 3 4 CGAL assertion e target point Point 2 5 return endif 23 5 2 Example of an Arrangement of Mixed Conic Arcs The following example demonstrates the construction of an arrangement of various conic arcs of mixed types The input Curve 2 objects are created in a way that makes use of most available constructors for conic arcs The arrangement created by this example is depicted in Figure The program outputs the number of vertices edges and faces in the resulting arrangement and the correctness of these figures can be easily verified by counting them in this figure Notice that arrangement vertices may be original endpoints of the input curves intersection points of two or more curves or points where the tangent to the curve is a vertical line Figure The arrangement of conic arcs generated by the example program The coordinates of the input endpoints are also shown file examples Arrangement 2 example3 C include short names h ifndef CGAL USE CORE To enable compilation without core int main return else include CGAL basic h include CGAL Cartesian h include CORE BigInt h include CGAL CORE Expr h include CGAL Arr 2 bases h include CGAL Arr 2 default dcel h include CGAL Arr conic traits 2 h include CGAL Arrangement 2 h typedef CORE BigInt CfNT typedef CGAL Cartesian CfNT Int kernel typedef Int kernel Point 2 Int point 2 typedef Int kernel Segment 2 Int segment 2 typedef Int kernel Line 2 Int line 2 typedef Int kernel Circle 2 Int circle 2 typedef CORE Expr CoNT typedef CGAL Cartesian CoNT Alg kernel typedef CGAL Arr conic traits 2 Int kernel Alg kernel Traits 2 typedef Traits 2 Point 2 Point 2 typedef Traits 2 Curve 2 Curve 2 typedef Traits 2 X monotone curve 2 X monotone curve 2 typedef CGAL Arr base node Curve 2 X monotone curve 2 Base node typedef CGAL Arr 2 default dcel Traits 2 Dcel typedef CGAL Arrangement 2 Dcel Traits 2 Base node Arr 2 int main Arr 2 arr Insert a hyperbolic arc supported by the hyperbola y 1 x or xy 1 with the end points 25 4 and 2 5 Note that the arc is counterclockwise oriented Point 2 ps1 25 4 Point 2 pt1 2 5 Curve 2 c1 1 1 CGAL COUNTERCLOCKWISE ps1 pt1 arr insert c1 Insert a full ellipse which is x 4 2 y 2 2 rotated by phi 36 87 degree such that sin phi 6 cos phi 8 yielding 58x 2 72y 2 48xy 36 Curve 2 c2 58 72 48 36 arr insert c2 Insert the segment 1 1 3 Int point 2 ps3 1 1 Int point 2 pt3 3 Curve 2 c3 Int segment 2 ps3 pt3 arr insert c3 Insert a circular arc supported by the circle x 2 y 2 5 2 with 3 4 and 4 3 as its endpoints We want the arc to be clockwise oriented so it passes through 5 as well Int point 2 ps4 3 4 Int point 2 pm4 5 Int point 2 pt4 4 3 Curve 2 c4 ps4 pm4 pt4 arr insert c4 Insert a full unit circle that is centered at 4 Int circle 2 circ5 Int point 2 4 CfNT 1 Curve 2 c5 circ5 arr insert c5 Insert a parabolic arc that is supported by a parabola y x 2 or x 2 y and whose end points are sqrt 3 3 1 73 3 and sqrt 2 2 1 41 2 Notice that since the x coordinates of the end points cannot be acccurately represented we specify them as the intersections of the parabola with the lines y 3 and y 2 Note that the arc is clockwise oriented Curve 2 c6 1 1 The parabola CGAL CLOCKWISE Point 2 1 73 3 Approximation of the source 1 3 The line y 3 Point 2 1 41 2 Approximation of the target 1 2 The line y 2 arr insert c6 Print out the number of vertices edges and faces in the arrangement std cout Number of vertices arr number of vertices std endl std cout Number of edges arr number of halfedges 2 std endl std cout Number of faces arr number of faces std endl return endif The output of the program looks like this Number of vertices 19 Number of edges 23 Number of faces 6 advanced 23 6 User defined Hierarchy The default hierarchy structure can be extended to include more levels according to user defined split functions 23 6 1 Example of a User defined Hierarchy The following example demonstrates the construction of an arrangement of two segments using a user defined hierarchy We use a simple split function that splits a segment in its middle point We insert the first segment using the user defined function and the second segment with the regular function file examples Arrangement 2 example4 C include short names h include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Arr 2 default dcel h include CGAL Arr segment traits 2 h include CGAL Arrangement 2 h include vector include list typedef CGAL Quotient CGAL MP Float NT typedef CGAL Cartesian NT Kernel typedef CGAL Arr segment traits 2 Kernel Traits typedef Traits Point 2 Point 2 typedef Traits Curve 2 Curve 2 typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits Dcel typedef CGAL Arrangement 2 Dcel Traits Arr 2 A simple function that splits a segment into 2 void my split f const Curve 2 cv std list Curve 2 l Point 2 s cv source Uses the knowledge of the curve functions Point 2 t cv target Point 2 m1 s t s 2 l push back Curve 2 s m1 l push back Curve 2 m1 t typedef void SPLIT FUNC const Curve 2 cv std list Curve 2 l int main std vector SPLIT FUNC func vec func vec push back my split f Arr 2 arr Insertion with user defined function Arr 2 Curve iterator cit arr insert Curve 2 Point 2 Point 2 6 6 func vec begin func vec end Regular insertion cit arr insert Curve 2 Point 2 4 Point 2 6 4 Traversal of the curves Arr 2 Edge iterator eit for cit arr curve node begin cit arr curve node end cit std cout std endl Curve level std endl cit curve std endl std cout Edge level std endl for eit cit edges begin eit cit edges end eit std cout eit x curve std endl return The output of the program looks like this Curve level 6 6 Edge level 3 3 3 3 4 4 4 4 6 6 Curve level 4 6 4 Edge level 4 4 4 4 4 6 4 advanced advanced 23 6 2 Example of a User defined Hierarchy with Function Objects The following example demonstrates the use of a function object in a user defined hierarchy We define a base class for the function objects with a virtual operator that the function objects override this kind of pattern is sometimes called an Action class see for example Str97 Chapter 25 5 This enables us to use an inner state in our function as is done in the example In the example we define two levels of a hierarchy The first level splits the inserted segment in the middle The second layer splits every curve of the first layer in a ratio of 1 3 2 3 Therefore after an insertion of the segment 6 6 we will have four edges eight halfedges inside the arrangement corresponding to the segments 1 1 1 1 3 3 3 3 4 4 and 4 4 6 6 file examples Arrangement 2 example5 C include short names h include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Arr 2 default dcel h include CGAL Arr segment traits 2 h include CGAL Arrangement 2 h include vector include list typedef CGAL Quotient CGAL MP Float NT typedef CGAL Cartesian NT Kernel typedef CGAL Arr segment traits 2 Kernel Traits typedef Traits Point 2 Point typedef Traits Curve 2 Curve typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits Dcel typedef CGAL Arrangement 2 Dcel Traits Arr 2 A base class for split functors struct Split base virtual void operator const Curve cv std list Curve l A user defined insertion functor struct Split func public Split base Split func double ratio r ratio void operator const Curve cv std list Curve l Point s cv source Uses the knowledge of the curve functions Point t cv target Point m1 s t s r l push back Curve s m1 l push back Curve m1 t virtual Split func private NT r int main Prepare a vector of pointers to the functor base class std vector Split base func vec Create 2 functors Split func Sf1 2 Sf2 3 func vec push back Sf1 func vec push back Sf2 Arr 2 arr Insertion with user defined functor Arr 2 Curve iterator cit arr insert Curve Point Point 6 6 func vec begin func vec end CGAL assertion arr number of halfedges 8 CGAL assertion cit number of sc levels 2 return advanced advanced 23 6 3 I O functions The Arrangement package supports I O functions which include reading an arrangement representation from the standard input or writing it to the standard output and also sending an arrangement to a graphic stream As already mentioned at chapter the motivation for using I O functions is not only to be able to draw the arrangement to a window for instance but also to be capable to save an arrangement in a text file by writing it and reloading it from a text file by reading it Reading an arrangement from the standard input or printing it to the standard output may be done simply with the Extractor and Insertor operators defined for Arrangement 2 respectively include CGAL IO Arr iostream h The ability of sending the Arrangement into a graphic stream as leda window Postscript file or Geomview is also provided users simply have to apply the Insertor operator on the graphic stream and their arrangement instance Users of I O functions for the arrangement package are required to define I O operators for the curves defined in their Traits classes When using Traits classes in which this operators are already defined as Segment Traits the operator definition is not obligated however using Traits classes as the Conic Traits will force the users to define I O operators on their conic curve The Arrangement class data consists of the induced planar map and the obtained hierarchy tree Hence the data sent to the output stream or read from an input stream should contain both parts The format of the planar map part is as specified in the Planar Map reference pages The format of the hierarchy tree is specified below The format of the output file is defined in a way the reading function will construct the arrangement efficiently The induced planar map is constructed efficiently as specified in the Planar Map reference pages and the hierarchy tree is also constructed efficiently by directly accessing its parts and updating them When constructing an arrangement from an input stream no use of its insertion functions is performed Consequently the reading function constructs the arrangement very efficiently and hence users who would like to save their arrangement and reload it have to construct their arrangement by the insertion functions only once After saving the arrangement to a text file it can be reloaded very efficiently when needed instead of constructing it from scratch When users would like to read their arrangement from the standard input or print it into the standard output they may simply use the Extractor and Insertor operators defined for Arrangement respectively If users add attributes to their arrangement components reading resp writing arrangement would be done by inheriting the class Arr file scanner resp Arr file writer and overriding all the relevant function for scanning resp writing the arrangement components After the definition of the inherited class users have to call the function read of Arrangement resp the global function write arr with the inherited class as a parameter The ability of sending the Arrangement into a graphic stream as leda window Postscript file or Geomview is also provided users simply have to use the Insertor operator operated on the graphic stream and their arrangement When users would like to add attributes to their arrangement components and send their arrangement to a graphic stream they have to inherit the class Pm drawer and then call the global function draw pm with this class and their arrangement as parameters The function Pm drawer is used both for Planar map and Arrangement since drawing an arrangement is defined as drawing only its planar map part Format As mentioned above the format of the planar map part is as specified in the Planar Map reference pages Here we are representing the format of the hierarchy tree Generally the format represents the curve nodes list of the arrangement Each component of one curve node is compound from all the subcurves and edge nodes this curve node contains This data is associative with geometric information and some topological information in order to be able to update the hierarchy tree efficiently The format is detailed below The data begins with a line of one integer specifying the number of curve nodes the hierarchy tree has The list of curve nodes each curve node has the following format Its associative curve An integer specifying the number of levels the curve node has The list of all subcurves levels Each described level goes as follows An integer specifying the number of subcurve nodes in the current level List of subcurve nodes belong to the current level Each subcurve consist of the following Pointers to subcurves edge nodes if the next level is the last of lower level which are given as the begin and past end indices of children subcurve nodes edge nodes The curve associative with the subcurve node An integer specifying the number of edge nodes List of edge nodes Each described edge node goes as follows A pointer to an overlapping edge node This pointer is represented by two indices the first is an index to a curve node and the second is an index to an edge node defined in that curve node An index to the associated halfedge The associated curve Other rules concerning the format are detailed in the Planar Map reference pages Example of Usage of the I O Functions The input of the program is a text file presenting the Arrangement Printing Arrangement Printing Planar map Printing number of vertices halfedges and faces in Planar map 5 8 1 5 vertices 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 1 8 halfedges 2 1 1 1 2 1 2 1 1 1 1 2 1 2 1 2 1 2 1 1 1 1 2 1 2 1 2 1 1 1 1 2 1 1 1 1 2 1 2 3 1 1 1 1 2 1 2 2 1 2 1 2 1 1 1 4 1 2 1 2 1 1 1 1 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 8 5 4 2 3 7 6 1 finish writing face End of Planar map Printing curve hierachy number of curves 2 1 th curve 1 1 1 1 1 1 number of levels number of edge nodes 2 Edge nodes childrens pair indices curve node and its edge node for next overlapping edge node Halfedge indices associtaed with edge nodes Edge node curve 1 1 1 2 1 2 pair indices curve node and its edge node for next overlapping edge node 1 Halfedge indices associtaed with edge nodes 2 Edge node curve 1 2 1 2 1 1 1 1 finished current level 2 th curve 1 1 1 1 1 1 number of levels number of edge nodes 2 Edge nodes childrens pair indices curve node and its edge node for next overlapping edge node 1 Halfedge indices associtaed with edge nodes 4 Edge node curve 1 1 1 1 2 1 2 pair indices curve node and its edge node for next overlapping edge node 1 1 Halfedge indices associtaed with edge nodes 7 Edge node curve 1 2 1 2 1 1 1 finished current level End of Arrangement The example above presents an arrangement containing two segments that intersect in their interior The segments are 1 1 and 1 1 The Arrangement instance that was used to produce this example was templated with the Arr segment traits 2 class which was templated with the representation class Cartesian Quotient int The first part of the input represents the planar map our arrangement contains and hence its format is identical with It can be seen that the planar map described here represents all the vertices and halfedges obtained by the disjoint subcurves of the arrangement The next part of the input file presents the hierarchy tree of our arrangement This presentation begins with the number 2 indicating there are two curve nodes in our arrangement The list of curve nodes follows The first curve node begins with its associated curve 1 1 it has levels since it does not contain any subcurve nodes only curve nodes and edge nodes The number of edge nodes the curve 1 1 induces is two and the curves these two edge nodes are associated with are 1 2 1 2 and 1 2 1 2 1 1 respectively The indices of each edge node to an overlapping edge node point to the edge node itself since there are no overlapping in the input file Finally the indices of the halfedge indicates the halfedge our edge node is associated with For example the first edge node induced by the curve 1 1 is associated with the first halfedge presented in the halfedges list The reader may verify that this halfedge holds the same curve the edge node holds The current format may not be comfortable for a user to read because the usage of indices There is a possibility to define a verbose format which contains instead of indices the components themselves and hence the user has the option to have a format which is easy for human to read This format cannot be scanned by the reading functions of Arrangement file examples Arrangement 2 example11 C include short names h include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Arr 2 default dcel h include CGAL Arr segment traits 2 h include CGAL Arrangement 2 h include CGAL IO Arr iostream h include iostream ifdef CGAL USE LEDA include CGAL IO Arr Postscript file stream h endif typedef CGAL Quotient CGAL MP Float NT typedef CGAL Cartesian NT Kernel typedef CGAL Arr segment traits 2 Kernel Traits typedef Traits Curve Curve typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Arr 2 default dcel Traits Dcel typedef CGAL Arrangement 2 Dcel Traits Arr int main Arr arr std cout Demonstrating a trivial use of IO functions std cout std endl std endl std cin arr std cout arr std cout std endl std cout Presenting the use of verbose format std cout std endl std endl CGAL Arr file writer Arr verbose writer std cout arr true CGAL write arr arr verbose writer std cout printing to Postscript file ifdef CGAL USE LEDA CGAL Postscript file stream LPF 5 5 arr ps LPF init 3 3 3 LPF set line width 1 LPF arr endif return The output is the Arrangement written in both formats non verbose and verbose Demonstrating a trivial use of IO functions Printing Arrangement Begin Planar Map Number of vertices halfedges and faces in Planar map 5 8 1 5 vertices 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 1 8 halfedges 2 1 1 1 2 1 2 1 1 1 1 2 1 2 1 2 1 2 1 1 1 1 2 1 2 1 2 1 1 1 1 2 1 1 1 1 2 1 2 3 1 1 1 1 2 1 2 2 1 2 1 2 1 1 1 4 1 2 1 2 1 1 1 1 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 8 5 4 2 3 7 6 1 finish writing face End Planar Map Printing curve hierachy number of curves 2 1 th curve 1 1 1 1 1 1 number of levels number of edge nodes 2 Edge nodes childrens pair indices curve node and its edge node for next overlapping edge node Halfedge indices associated with edge nodes Edge node curve 1 1 1 2 1 2 pair indices curve node and its edge node for next overlapping edge node 1 Halfedge indices associated with edge nodes 2 Edge node curve 1 2 1 2 1 1 1 1 finished current level 2 th curve 1 1 1 1 1 1 number of levels number of edge nodes 2 Edge nodes childrens pair indices curve node and its edge node for next overlapping edge node 1 Halfedge indices associated with edge nodes 4 Edge node curve 1 1 1 1 2 1 2 pair indices curve node and its edge node for next overlapping edge node 1 1 Halfedge indices associated with edge nodes 7 Edge node curve 1 2 1 2 1 1 1 finished current level End of Arrangement Presenting the use of verbose format Printing Arrangement Begin Planar Map Number of vertices halfedges and faces in Planar map 5 8 1 5 vertices 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 1 8 halfedges 1 1 1 2 1 2 towards 1 2 1 2 1 1 1 2 1 2 towards 1 1 1 2 1 2 1 1 1 1 towards 1 1 1 1 1 2 1 2 1 1 1 1 towards 1 2 1 2 1 1 1 1 2 1 2 towards 1 2 1 2 1 1 1 1 2 1 2 towards 1 1 1 1 2 1 2 1 1 1 towards 1 2 1 2 1 2 1 2 1 1 1 towards 1 1 1 1 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 8 1 1 1 2 1 2 towards 1 2 1 2 1 1 1 1 2 1 2 towards 1 1 1 1 1 1 1 2 1 2 towards 1 2 1 2 1 2 1 2 1 1 1 1 towards 1 1 1 1 1 2 1 2 1 1 1 1 towards 1 2 1 2 1 2 1 2 1 1 1 towards 1 1 1 1 2 1 2 1 1 1 towards 1 2 1 2 1 1 1 2 1 2 towards 1 1 finish writing face End Planar Map Printing curve hierachy number of curves 2 1 th curve 1 1 1 1 1 1 number of levels number of edge nodes 2 Edge nodes childrens Halfedge associated with edge nodes 1 1 1 2 1 2 towards 1 2 1 2 Edge node curve 1 1 1 2 1 2 Halfedge associated with edge nodes 1 2 1 2 1 1 1 1 towards 1 1 1 1 Edge node curve 1 2 1 2 1 1 1 1 finished current level 2 th curve 1 1 1 1 1 1 number of levels number of edge nodes 2 Edge nodes childrens Halfedge associated with edge nodes 1 1 1 1 2 1 2 towards 1 2 1 2 Edge node curve 1 1 1 1 2 1 2 Halfedge associated with edge nodes 1 2 1 2 1 1 1 towards 1 1 1 Edge node curve 1 2 1 2 1 1 1 finished current level End of Arrangement For more examples see chapter More details are given in sections Arr file scanner Arrangement Arr file writer Arrangement advanced Next chapter 2D Arrangements Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Arrangement_2/Chapter_main.html", "title": "2d arrangements", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Arrangement_2/main.tex' -->\n<html> <head>  \n<title>2D Arrangements</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_23\"></a>\n  \n<h1>Chapter 23<BR>2D Arrangements</h1>\n \n<A NAME=\"I1_ChapterArrangement_2\"></A>\n<EM>Ester Ezra, Eyal Flato, Dan\n  Halperin, Iddo Hanniel, Shai Hirsch, and Ron Wein</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>23.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nGiven a collection <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH> of (possibly intersecting and not \nnecessarily  <MATH><I>x</I></MATH>-monotone) curves in the plane, the planar arrangement of \n<MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH> is the subdivision the curves of <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH> induce on\nthe plane into zero-dimensional, one-dimensional and two-dimensional cells,\ncalled <I>v</I>ertices, <I>e</I>dges and <I>f</I>aces respectively.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>23.2&nbsp;&nbsp;&nbsp;Software Design</h2>\n<P>\n\nThe class <I><A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>&lt;Dcel,Traits,Base_node&gt;</I> is a data\nstructure for maintaining 2D arrangements. The data structure\nmaintains a planar map and curve hierarchy trees. There is a curve\ntree for each curve inserted into the arrangement (see below). The\nunderlying combinatorial structure is determined by the\n<I>Dcel</I> template parameter, which should be a model of the\n<I><A HREF=\"../Arrangement_2_ref/Concept_ArrangementDcel_2.html#Cross_link_anchor_833\">ArrangementDcel_2</A></I> concept. The family of curves of the\narrangement is determined by the <I>Traits</I> template parameter which\nshould be a model of the <I><A HREF=\"../Arrangement_2_ref/Concept_ArrangementTraits_2.html#Cross_link_anchor_835\">ArrangementTraits_2</A></I> concept. The\n<I>Base_node</I> template parameter defines the attributes associated\nwith each tree node of the hierarchy tree.\n<P>\n\nThe <I>Arrangement</I> package is based on the <I>Planar Map with  Intersections</I> package (see Chapter&nbsp;<A HREF=\"../Pm_with_intersections_2/Chapter_main.html#I1_ChapterPmwx\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). That is, given\na collection <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH>, we construct a collection \n<MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\">''</I></MATH> in two steps: First we decompose each curve in \n<MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH> into maximal <MATH><I>x</I></MATH>-monotone curves, thus obtaining the \ncollection <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\">'</I></MATH>. We then decompose each curve in <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\">'</I></MATH> \ninto maximal connected pieces not intersecting any other curve in \n<MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\">'</I></MATH>. This way we obtain the collection <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\">''</I></MATH> of \n<MATH><I>x</I></MATH>-monotone, pairwise interior-disjoint curves.\nThe <I>arrangement</I> of the curves in <MATH><I>C</I></MATH> is the\n<I>planar map</I> (see Chapter&nbsp;<A HREF=\"../Planar_map/Chapter_main.html#I1_ChapterPlanarMap\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>)\ninduced by the curves in <MATH><I>C''</I></MATH>.\n<P>\n\n<b>Curve Hierarchy Tree:</b>\n When constructing the arrangement of a\ncollection of curves <MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH>, we decompose each curve <MATH><I>c  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> <IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH> in two steps: First we decompose it into maximal <MATH><I>x</I></MATH>-monotone \ncurves, thus obtaining a set of curves <MATH><I>C'</I></MATH>. We then decompose each curve \nin <MATH><I>C'</I></MATH> into maximal connected pieces not intersecting any other curve in \n<MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_C.gif\"></I></MATH>, obtaining the set <MATH><I>C''</I></MATH>.\n<P>\n\nWe regard these sets <MATH><I>C'</I></MATH>, <MATH><I>C''</I></MATH> as levels in a hierarchy of curves where the \nunion of the subcurves in each level is the original curve <MATH><I>c</I></MATH>. We store these\nsets in a special structure  -  a <I>hierarchy tree</I>. This structure \nusually consists of three levels, although in some cases they can consist \nof less (e.g., when inserting an <MATH><I>x</I></MATH>-monotone curve) or more (when the users \ndefine their own <I>split functions</I> see Section&nbsp;<A HREF=\"Chapter_main.html#ssec:example4\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). \nThe levels are:\n<UL>\n<LI>Curve node level: the root of the tree  -  holds the original curve <MATH><I>c</I></MATH>.\n<LI>Subcurve node level: inner nodes of the tree  -  hold decomposed\nsubcurves of the original curve. In the default mode these are <MATH><I>x</I></MATH>-monotone \ncurves (that is, these nodes correspond to the sub-curves of <MATH><I>C'</I></MATH>).\n<LI>Edge node level: leaves of the tree  -  hold the curves corresponding to\nthe edges of the planar map induced by the arrangement (usually these nodes \ncorrespond to the sub-curves of <MATH><I>C''</I></MATH>).<BR>\n\nThese nodes will be built only in <I>update mode</I> (by default the \narrangement is in update mode).\n</UL>\n<P>\n\nFigure&nbsp;<A HREF=\"Chapter_main.html#fig:hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> shows an example of a simple arrangement and its \ncorresponding curve hierarchy.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A simple arrangement of two polylines, and its corresponding\nhierarchy tree (the edges of the arrangement are numbered according to\ntheir order in the tree).<A NAME=\"fig:hierarchy\"></A>\n<P>\n\n<center><img border=0 src=\"./arr_hier.gif\" alt=\" \">\n<!--\n<br>\nA simple arrangement of two polylines, and its corresponding hierarchy tree\n(the edges of the arrangement are numbered according to their order\nin the tree).\n-->\n</center>\n<P>\n\nThe hierarchy tree enables us to intersect the curves without loss of\ninformation. The original curve and the intermediate subcurves are stored\nin the tree and the user can traverse them. Furthermore, users can\ndefine their own hierarchy by passing their own <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> sequence.\nThis can be of use in some applications. For example, in an arrangement\nof spline curves the users might want to intersect a curve in the\njunction points before making the curve <MATH><I>x</I></MATH>-monotone.\n<P>\n\n<b>Degeneracies</b>\n Like the planar map package (see\nChapter&nbsp;<A HREF=\"../Planar_map/Chapter_main.html#I1_ChapterPlanarMap\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>), the arrangement package can deal\nwith <MATH><I>x</I></MATH>-degenerate input (including vertical segments). However,\nwhile in the planar map the input curves were assumed to be\n<MATH><I>x</I></MATH>-monotone and non-intersecting in their interiors, there are no\nsuch assumptions in the arrangement. A non <MATH><I>x</I></MATH>-monotone curve is\npartitioned into <MATH><I>x</I></MATH>-monotone subcurves, and curves are intersected in\ntheir points of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> with other points before they are\ninserted into the map. Furthermore, overlapping curves are\nsupported. If two curves overlap the traits <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> function\nreturns the two endpoints of the common part. Circulators of the\n<I>Overlap_circulator</I> type (of \n<I><A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>&lt;Dcel,Traits,Base_node&gt;</I>) enables to traverse all\noverlapping <I>edge_nodes</I> that correspond to the same pair of\nhalfedges in the map.\n<P>\n\n<b>I/O functions:</b>\n\nI/O functions for reading a saved arrangement from the standard input, \nwriting it to the standard output or drawing it to a graphic stream are \nalso provided.\nUsers of I/O functions for the arrangement package are required to define I/O \noperators for the curves defined in their <I>Traits</I> classes.\n<P>\n\n<b>Update <A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Mode\">Mode</A>:</b>\n For some algorithms, it is not necessary to build\nthe whole planar map induced by the arrangement. For example, the lower\nenvelope of an arrangement of <MATH><I>x</I></MATH>-monotone curves that intersect\neach other at most a fixed constant number of <MATH><I>s</I></MATH> times,\ncan be found in near linear time [<A HREF=\"../biblio.html#Biblio_sa-dsstg-95\">SA95</A>, <A HREF=\"../biblio.html#Biblio_h-a-97\">Hal97</A>]\neven if\nthe complexity of the planar map induced by it is quadratic.\nTherefore, building the planar map induced by the arrangement is not\nalways desired. The users can therefore disable (or postpone) the building\nof the planar map. This is done by disabling the <I>update mode</I>\nusing the <I>set_update(bool)</I> member function. When update mode is\nset to <I>true</I>, the planar map is updated  -  this is the\ndefault situation. \nWhen update mode is set to <I>false</I>, the hierarchy tree is built without\nits <I>Edge_level</I>, and the curves are not inserted into the planar map.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>23.3&nbsp;&nbsp;&nbsp;Segment Arrangements</h2>\n<P>\n\nThe second template parameter of the arrangement class determines the\nso-called geometry of the arrangement, that is the family of curves we\nwant to deal with. In order to deal with line segments we simply plug\nin on of the two segment traits classes supplied.\n<P>\n\nThe <I><A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I> class is generic and allows\nflexibility in determining the kernel which is used. It makes intensive\nuse of the kernel, since it support almost all the operations needed by the\narrangement package. The <I><A HREF=\"../Arrangement_2_ref/Class_Arr_segment_cached_traits_2.html#Cross_link_anchor_839\">Arr_segment_cached_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I> class\nstores some additional cached information with each segment curve. Choosing\nto work with this traits class means a little extra memory consumption, \nhowever it usually speeds up the construction time of the arrangement.\n<P>\n\n<h3>23.3.1&nbsp;&nbsp;&nbsp;Example of an Arrangement of Segments</h3>\n\nThe following example demonstrates the construction of an <MATH><I>X</I></MATH>-shaped\narrangement out of two segments.  After the construction we traverse\nthe edges of the arrangement in the order defined by the original\nsegments.\n<P>\n\nThe four numbers on each output lines is a representation of a segment.\nThe first two numbers are the <MATH><I>x</I></MATH> and <MATH><I>y</I></MATH> coordinates of the first endpoint.\nThe other two numbers are of the second endpoint. The way a curve is\nprinted depends on the the output operator implemented for it.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example1.C\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;                  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_836\">CGAL::Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;              Traits;\n\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                 <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::Curve_2                                 Curve_2;\ntypedef Traits::X_monotone_curve_2                      X_monotone_curve_2;\n\ntypedef CGAL::Arr_2_default_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits&gt;                Arr_2;\n\nint main() \n{\n  Arr_2 arr;\n\n  //insertion of the curves\n  arr.insert(Curve_2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(0, 0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1, 1)));\n  arr.insert(Curve_2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(0, 1), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1, 0))); \n  \n  //traversal of the curves\n  Arr_2::Curve_iterator cit;\n  Arr_2::Edge_iterator eit;\n  for (cit = arr.curve_node_begin(); cit != arr.curve_node_end(); ++cit) \n  {\n    std::cout &lt;&lt; std::endl &lt;&lt; &quot;Curve level:&quot; &lt;&lt; std::endl &lt;&lt; cit-&gt;curve()\n              &lt;&lt; std::endl ;\n    std::cout &lt;&lt; &quot;Edge level:&quot; &lt;&lt; std::endl;\n\n    //traversal of the edges of the current curve\n    for (eit = cit-&gt;edges_begin(); eit != cit-&gt;edges_end(); ++eit) \n    {\n      std::cout &lt;&lt; eit-&gt;x_curve() &lt;&lt; std::endl ;\n    }\n  }\n\n  return 0;\n}\n</pre>\n<P>\n\nThe output of the program looks like this:\n<pre class=\"Verbatim\">\nCurve level:\n0 0 1 1\nEdge level:\n0 0 0.5 0.5\n0.5 0.5 1 1\n\nCurve level:\n0 1 1 0\nEdge level:\n0 1 0.5 0.5\n0.5 0.5 1 0\n</pre>\n<P>\n\n<h3>23.3.2&nbsp;&nbsp;&nbsp;Example of Overlapping Segments</h3>\n\n<A NAME=\"ssec:example2\"></A>\nThe following example demonstrates the construction of an\narrangement out of two overlapping segments  -  <MATH><I>(0,0)-(2,2)</I></MATH>\nand <MATH><I>(1,1)-(3,3)</I></MATH>.\nAfter the insertion of the segments we\ntraverse the halfedges\nof the arrangement and count the overlapping curves.\nThis is done using the <I>overlap_edges()</I> member function that returns an\n<I>Overlap_circulator</I>. With it we can circulate\nover all the edge nodes that correspond to the halfedge.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example2.C\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n#include &lt;CGAL/circulator.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;                  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_836\">CGAL::Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;              Traits;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                 <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::Curve_2                                 Curve_2;\ntypedef Traits::X_monotone_curve_2                      X_monotone_curve_2;\ntypedef CGAL::Arr_2_default_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits&gt;                Arr_2;\n\nint main() \n{\n  Arr_2 arr;\n\n  // Insertion of the curves\n  arr.insert(Curve_2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(0, 0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(2, 2)));\n  arr.insert(Curve_2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1, 1), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(3, 3)));\n\n  // Traversal of the halfedges\n  Arr_2::Halfedge_const_iterator hit = arr.halfedges_begin(),\n      hit_end = arr.halfedges_end();\n\n  for (; hit != hit_end; ++hit, ++hit)\n  {\n    // We skip the adjacent twin halfedge\n    Arr_2::Overlap_const_circulator occ = hit-&gt;overlap_edges(), occ_end = occ;\n    int count = 0;\n    <A HREF=\"../Circulator_ref/Macro_CGAL_For_all.html#Cross_link_anchor_1661\">CGAL_For_all</A>(occ, occ_end) { ++count; }\n\n    if (count == 1) \n      std::cout &lt;&lt; &quot;Edge &quot; &lt;&lt; occ-&gt;x_curve() &lt;&lt; &quot; is covered by a single edge.&quot;\n                &lt;&lt; std::endl;\n    else\n      std::cout &lt;&lt; &quot;Edge &quot; &lt;&lt; occ-&gt;x_curve() &lt;&lt; &quot; is covered by &quot; &lt;&lt; count\n                &lt;&lt; &quot; edges.&quot; &lt;&lt; std::endl;\n  }\n\n  return 0;\n}\n</pre>\n<P>\n\nThe output of the program looks like this:\n<pre class=\"Verbatim\">\nEdge 0 0 1 1 is covered by a single edge.\nEdge 1 1 2 2 is covered by 2 edges.\nEdge 2 2 3 3 is covered by a single edge.\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>23.4&nbsp;&nbsp;&nbsp;Polyline Arrangements</h2>\n<P>\n\nThe <I><A HREF=\"../Arrangement_2_ref/Class_Arr_polyline_traits_2.html#Cross_link_anchor_841\">Arr_polyline_traits_2</A>&lt;Segment_traits&gt;</I> class can be used to \nhandle arrangements of polylines (a.k.a. poly-segment). A polyline can be\ncreated from any range of points, where the <MATH><I>i</I></MATH>th and <MATH><I>(i+1)</I></MATH>st points \nin the range represent the endpoints of the <MATH><I>i</I></MATH>th segment of the polyline.\nThe polyline traits class is templated with another traits class that supports\nthe basic operations on segments.\n<P>\n\n<h3>23.4.1&nbsp;&nbsp;&nbsp;Example of a Polyline Arrangement</h3>\n\n<A NAME=\"ssec:example10\"></A>\nThe following example demonstrates the use of the polyline traits.\nObserve that a polyline curve is constructed from a standard STL vector\nof points.\n<P>\n\nNote that a polyline point is not necessarily a vertex of the arrangement \n(that is, of the underlying Planar Map) and an edge of the Planar Map need \nnot be a segment. The edges are only required to be x-monotone and pairwise \ndisjoint. In the example below point (150, 50) is not a vertex of the planar \nmap. The polyline to which it belongs is an edge of the planar map.\n<P>\n\nHowever, one might expect the planar map (or rather the edge level of the \narrangement) to be made of segments alone. In such cases the user can define \nadditional level of hierarchies, as will be shown in the example in \nSection&nbsp;<A HREF=\"Chapter_main.html#ssec:example4\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example10.C\n\n// Define shorter names to please linker (g++)\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_polyline_traits_2.html#Cross_link_anchor_841\">Arr_polyline_traits_2</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;                  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_836\">CGAL::Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;              Seg_traits;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_polyline_traits_2.html#Cross_link_anchor_840\">CGAL::Arr_polyline_traits_2</A>&lt;Seg_traits&gt;         Traits;\n\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                 <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::Curve_2                                 Curve_2;\ntypedef Traits::X_monotone_curve_2                      X_monotone_curve_2;\n\ntypedef CGAL::Arr_2_default_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits&gt;                Arr_2;\n\nint main()\n{\n  Arr_2                arr;\n  std::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&gt; pts;\n\n  // Curve #1, not x monotone.\n  pts.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(  0,  0));\n  pts.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>( 10, 10));\n  pts.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(  0, 20));\n  arr.insert (Curve_2(pts.begin(), pts.end())); \n  \n  // Curve #2, x monotone.\n  pts.clear();\n  pts.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(100,  0));\n  pts.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(150, 50));\n  pts.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(200,  0));\n  arr.insert (Curve_2(pts.begin(), pts.end()));\n\n  // Curve #1 is broken into two edges. <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> (10,10) turns into a vertex.\n  Arr_2::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> lt;\n  arr.locate(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(10, 10), lt);\n  CGAL_assertion(lt == Arr_2::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">VERTEX</A>);\n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>23.5&nbsp;&nbsp;&nbsp;Arrangements of Conic Arcs</h2>\n<P>\n\nThe <I><A HREF=\"../Arrangement_2_ref/Class_Arr_conic_traits_2.html#Cross_link_anchor_843\">Arr_conic_traits_2</A>&lt;Int_kernel, Alg_kernel&gt;</I> class can be used for\nconstructing arrangement of bounded segments of algebraic curves of degree 2\n(conic curves).\nThat is, it supports the construction of the arrangement of any \ncollection of elliptic arcs (a full ellipse or a circle may also be considered\nas a conic arc), hyperbolic arcs, parabolic arcs and also line segments.\nThe template has two template parameters:\n<UL>\n<LI>The first template parameter, <I>Int_kernel</I>, is a geometric kernel\nwith an unbounded integer number-type (i.e.&nbsp;<I>Int_kernel::FT</I>, or \n<I>CfNT</I> for short, should be an unbounded integer), that represents the\ncoefficients of the conic curves. The kernel <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;CORE::BigInt&gt;</I>\nis the most suitable choice for this parameter.\n<LI>The second parameter, <I>Alg_kernel</I>, is a geometric kernel whose \nnumber type (<I>Alg_kernel::FT</I>, or <I>CoNT</I> for short) supports exact\noperations: In addition to the arithmetic operations, it must support the\n<A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A>-root operation in an exact manner, as well as the extraction of the\n<MATH><I>k</I></MATH>th-largest root of a given polynomial with integral coefficients.\n<I>CoNT</I> should be constructible from a <I>CfNT</I>, and it is used to\nrepresent the coordinates of the arrangement vertices (which are in general\nirrational algebraic numbers). At current, the <I>CORE:Expr</I> is the only\nnumber type that fills all the requirements above and must be the number\ntype of <I>Alg_kernel</I>.\n</UL>\n<P>\n\n<h3>23.5.1&nbsp;&nbsp;&nbsp;Example of an Arrangement of Circular Arcs</h3>\n\n<A NAME=\"ssec:example3\"></A>\nThe following example demonstrates the use of the conic traits for \nconstructing a simple arrangement of two circles. The arrangement created \nby this example is depicted in Figure&nbsp;<A HREF=\"Chapter_main.html#fig:circles\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. Note that each\ncircle is divided to an upper half and a lower half, both are <MATH><I>x</I></MATH>-monotone:\nThe result of ray-shooting operation from <MATH><I>(-1,0)</I></MATH> upward exemplifies this, \nsince it returns a circular arcs whose end-points are <MATH><I>(3,4)</I></MATH> and <MATH><I>(-5,0)</I></MATH>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The arrangement generated by the example program.<A NAME=\"fig:circles\"></A>\n<P>\n\n<center><img border=0 src=\"./arr_circ.gif\" alt=\" \">\n<!-- <br>The arrangement generated by the example program. -->\n</center>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example3.C   \n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/basic.h&gt;\n\n#ifndef CGAL_USE_CORE\n// To enable compilation without core:\nint main ()\n{\n  return (0);\n}\n\n#else\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CORE/BigInt.h&gt;\n#include &lt;CGAL/CORE_Expr.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_conic_traits_2.html#Cross_link_anchor_843\">Arr_conic_traits_2</A>.h&gt; \n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n\ntypedef CORE::BigInt                                CfNT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;CfNT&gt;                       Int_kernel;\ntypedef Int_kernel::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                         Int_point_2;\ntypedef Int_kernel::<A HREF=\"../Kernel_23_ref/Class_Circle_2.html#Cross_link_anchor_44\">Circle_2</A>                        Int_circle_2;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A>                                      CoNT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;CoNT&gt;                           Alg_kernel;\n\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_conic_traits_2.html#Cross_link_anchor_842\">CGAL::Arr_conic_traits_2</A>&lt;Int_kernel,Alg_kernel&gt; Traits_2;\ntypedef Traits_2::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                               <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits_2::Curve_2                               Curve_2;\ntypedef Traits_2::X_monotone_curve_2                    X_monotone_curve_2;\ntypedef CGAL::Arr_2_default_dcel&lt;Traits_2&gt;              Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits_2&gt;              Arr_2;\n\nint main()\n{\n  Arr_2 arr;  \n              \n  // 2 ccw circles with radius 5 and center (0,0) and (6,0) resp.\n  Int_circle_2  c1 (Int_point_2(0,0), 5*5);\n  Int_circle_2  c2 (Int_point_2(6,0), 5*5);\n\n  Arr_2::Curve_iterator cit = arr.insert(Curve_2 (c1));\n  cit = arr.insert(Curve_2 (c2)); \n\n  // upward vertical ray shooting\n  Arr_2::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> lt;\n  Arr_2::Halfedge_handle e = arr.vertical_ray_shoot(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(-1, 0), lt, true);\n\n  CGAL_assertion(e-&gt;source()-&gt;point() == <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(3, 4)); \n  CGAL_assertion(e-&gt;target()-&gt;point() == <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(-5, 0));\n\n  return 0;\n}\n\n#endif\n</pre>\n<P>\n\n<h3>23.5.2&nbsp;&nbsp;&nbsp;Example of an Arrangement of Mixed Conic Arcs</h3>\n\n<A NAME=\"ssec:example13\"></A>\n<P>\n\nThe following example demonstrates the construction of an arrangement\nof various conic arcs of mixed types. The input <I>Curve_2</I> objects are\ncreated in a way that makes use of most available constructors for conic\narcs.\n<P>\n\nThe arrangement created by this example is depicted in \nFigure&nbsp;<A HREF=\"Chapter_main.html#fig:conics\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. The program outputs the number of vertices, edges and\nfaces in the resulting arrangement, and the correctness of these figures can\nbe easily verified by counting them in this figure: Notice that arrangement\nvertices may be original endpoints of the input curves, <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> points\nof two (or more) curves or points where the tangent to the curve is a vertical\nline.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The arrangement of conic arcs generated by the example program.\nThe coordinates of the input endpoints are also shown.\n<A NAME=\"fig:conics\"></A>\n<P>\n\n<center><img border=0 src=\"./arr_conics.gif\" alt=\" \">\n<!-- <br>The arrangement generated of conic arcs by the example program. -->\n</center>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example3.C\n\n#include &quot;short_names.h&quot;\n\n#ifndef CGAL_USE_CORE\n// To enable compilation without core:\nint main ()\n{\n  return (0);\n}\n\n#else\n\n#include &lt;CGAL/basic.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CORE/BigInt.h&gt;\n#include &lt;CGAL/CORE_Expr.h&gt;\n#include &lt;CGAL/Arr_2_bases.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_conic_traits_2.html#Cross_link_anchor_843\">Arr_conic_traits_2</A>.h&gt; \n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n\ntypedef CORE::BigInt                                CfNT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;CfNT&gt;                       Int_kernel;\ntypedef Int_kernel::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                         Int_point_2;\ntypedef Int_kernel::<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>                       Int_segment_2;\ntypedef Int_kernel::<A HREF=\"../Kernel_23_ref/Class_Line_2.html#Cross_link_anchor_50\">Line_2</A>                          Int_line_2;\ntypedef Int_kernel::<A HREF=\"../Kernel_23_ref/Class_Circle_2.html#Cross_link_anchor_44\">Circle_2</A>                        Int_circle_2;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A>                                      CoNT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;CoNT&gt;                           Alg_kernel;\n\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_conic_traits_2.html#Cross_link_anchor_842\">CGAL::Arr_conic_traits_2</A>&lt;Int_kernel,Alg_kernel&gt;  Traits_2;\ntypedef Traits_2::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits_2::Curve_2                                Curve_2;\ntypedef Traits_2::X_monotone_curve_2                     X_monotone_curve_2;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_base_node.html#Cross_link_anchor_823\">CGAL::Arr_base_node</A>&lt;Curve_2, X_monotone_curve_2&gt; Base_node;\ntypedef CGAL::Arr_2_default_dcel&lt;Traits_2&gt;               Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits_2,Base_node&gt;     Arr_2;\n\nint main()\n{\n  Arr_2 arr;  \n             \n  // Insert a hyperbolic arc, supported by the hyperbola y = 1/x\n  // (or: xy - 1 = 0) with the end-points (0.25, 4) and (2, 0.5).\n  // Note that the arc is counterclockwise oriented.\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>   ps1 (0.25, 4);\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>   pt1 (2, 0.5);\n  Curve_2   c1 (0, 0, 1, 0, 0, -1, <A HREF=\"../Kernel_23_ref/Constant_COUNTERCLOCKWISE.html#Cross_link_anchor_122\">CGAL::COUNTERCLOCKWISE</A>, ps1, pt1);\n\n  arr.insert(c1);\n\n  // Insert a full ellipse, which is (x/4)^2 + (y/2)^2 = 0 rotated by\n  // phi=36.87 degree (such that sin(phi) = 0.6, cos(phi) = 0.8),\n  // yielding: 58x^2 + 72y^2 - 48xy - 360 = 0.\n  Curve_2   c2 (58, 72, -48, 0, 0, -360);\n  \n  arr.insert(c2);\n\n  // Insert the segment (1, 1) -- (0, -3).\n  Int_point_2   ps3 (1, 1);\n  Int_point_2   pt3 (0, -3);\n  Curve_2       c3 (Int_segment_2 (ps3, pt3));\n\n  arr.insert(c3);\n\n  // Insert a circular arc supported by the circle x^2 + y^2 = 5^2,\n  // with (-3, 4) and (4, 3) as its endpoints. We want the arc to be\n  // clockwise oriented, so it passes through (0, 5) as well.\n  Int_point_2   ps4 (-3, 4);\n  Int_point_2   pm4 (0, 5);\n  Int_point_2   pt4 (4, 3);\n  Curve_2       c4 (ps4, pm4, pt4);\n\n  arr.insert(c4);\n\n  // Insert a full unit circle that is centered at (0, 4).\n  Int_circle_2  circ5 (Int_point_2(0,4), CfNT(1));\n  Curve_2   c5 (circ5);\n  \n  arr.insert(c5);\n\n  // Insert a parabolic arc that is supported by a parabola y = -x^2\n  // (or: x^2 + y = 0) and whose end-points are (-<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(3), -3) ~ (-1.73, -3)\n  // and (<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(2), -2) ~ (1.41, -2). Notice that since the x-coordinates \n  // of the end-points cannot be acccurately represented, we specify them\n  // as the intersections of the parabola with the lines y = -3 and y = -2.\n  // Note that the arc is clockwise oriented.\n  Curve_2   c6 (1, 0, 0, 0, 1, 0,       // The parabola.\n\t\t<A HREF=\"../Kernel_23_ref/Constant_CLOCKWISE.html#Cross_link_anchor_120\">CGAL::CLOCKWISE</A>,\n\t\t<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> (-1.73, -3),    // Approximation of the source.\n\t\t0, 0, 0, 0, 1, 3,       // The line: y = -3.\n\t\t<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> (1.41, -2),     // Approximation of the target.\n\t\t0, 0, 0, 0, 1, 2);      // The line: y = -2.\n\n  arr.insert(c6);\n\n  // Print out the number of vertices, edges and faces in the arrangement.\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; \n\t    &lt;&lt; arr.number_of_vertices() &lt;&lt; std::endl;\n  \n  std::cout &lt;&lt; &quot;Number of edges: &quot; \n\t    &lt;&lt; arr.number_of_halfedges()/2 &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Number of faces: &quot; \n\t    &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;\n\n  return 0;\n}\n\n#endif\n</pre>\n<P>\n\nThe output of the program looks like this:\n<pre class=\"Verbatim\">\nNumber of vertices: 19\nNumber of edges: 23\nNumber of faces: 6\n</pre>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<a name=\"Section_6\"></a>\n        \n<h2>23.6&nbsp;&nbsp;&nbsp;User-defined Hierarchy</h2>\n<P>\n\nThe default hierarchy structure can be extended to include more levels\naccording to user defined split functions.\n<P>\n\n<h3>23.6.1&nbsp;&nbsp;&nbsp;Example of a User-defined Hierarchy</h3>\n\n<A NAME=\"ssec:example4\"></A>\n<P>\n\nThe following example demonstrates the construction of an\narrangement of two segments, using a user-defined\nhierarchy.\nWe use a simple split function that splits a segment in its middle\npoint. We insert the first segment using the user-defined function\nand the second segment with the regular function.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example4.C\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;                  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_836\">CGAL::Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;              Traits;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                 <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::Curve_2                                 Curve_2;\ntypedef Traits::X_monotone_curve_2                      X_monotone_curve_2;\ntypedef CGAL::Arr_2_default_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits&gt;                Arr_2;\n\n// A simple function that splits a segment into 2\nvoid my_split_f(const Curve_2 &amp; cv, std::list&lt;Curve_2&gt; &amp; l) \n{\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> s = cv.source(); // Uses the knowledge of the curve functions\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> t = cv.target();\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> m1 = s + (t - s) / 2.0;\n  l.push_back(Curve_2(s, m1));\n  l.push_back(Curve_2(m1, t));\n}\n\ntypedef void (*SPLIT_FUNC)(const Curve_2 &amp; cv, std::list&lt;Curve_2&gt; &amp; l);\n\nint main() \n{\n  std::vector&lt;SPLIT_FUNC&gt; func_vec;\n  func_vec.push_back(&amp;my_split_f);\n  Arr_2 arr;\n   \n  // Insertion with user-defined function\n  Arr_2::Curve_iterator cit = arr.insert(Curve_2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(0, 0),<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(6, 6)),\n                                         func_vec.begin(), func_vec.end());\n   \n  // Regular insertion                                  \n  cit = arr.insert(Curve_2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(0, 4), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(6, 4))); \n   \n  // Traversal of the curves\n  Arr_2::Edge_iterator eit;\n  for (cit = arr.curve_node_begin(); cit != arr.curve_node_end(); ++cit) \n  {\n    std::cout &lt;&lt; std::endl &lt;&lt; &quot;Curve level:&quot; &lt;&lt; std::endl &lt;&lt; cit-&gt;curve()\n              &lt;&lt; std::endl ;\n    std::cout &lt;&lt; &quot;Edge level:&quot; &lt;&lt; std::endl;\n    for (eit = cit-&gt;edges_begin(); eit != cit-&gt;edges_end(); ++eit) \n    {\n      std::cout &lt;&lt; eit-&gt;x_curve() &lt;&lt; std::endl ;\n    }\n  }\n\n  return 0;\n}\n</pre>\n<P>\n\nThe output of the program looks like this:\n<pre class=\"Verbatim\">\nCurve level:\n0 0 6 6\nEdge level:\n0 0 3 3\n3 3 4 4\n4 4 6 6\n\nCurve level:\n0 4 6 4\nEdge level:\n0 4 4 4\n4 4 6 4\n</pre>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<P>\n\n<h3>23.6.2&nbsp;&nbsp;&nbsp;Example of a User-defined Hierarchy with Function Objects</h3>\n\n<A NAME=\"ssec:example5\"></A>\n<P>\n\nThe following example demonstrates the use of a function object in\na user-defined hierarchy. We define a base class for the function objects\nwith a virtual <I>operator()</I>, that the function objects override (this\nkind of pattern is sometimes called an <I>Action</I> class\n(see for example [<A HREF=\"../biblio.html#Biblio_cgal:s-cpl-97\">Str97</A>, Chapter&nbsp;25.5]). This enables us to\nuse an inner state in our function as is done in the example.\n<P>\n\nIn the example we define two levels of a hierarchy. The first level\nsplits the inserted segment in the middle. The second layer splits every\ncurve of the first layer in a ratio of <MATH><I>1/3 : 2/3</I></MATH>. Therefore, after\nan insertion of the segment <MATH><I>(0,0) - (6,6)</I></MATH>\nwe will have four edges (eight halfedges)\ninside the arrangement, corresponding to the segments: <MATH><I>(0,0) - (1,1)</I></MATH>,\n<MATH><I>(1,1) - (3,3)</I></MATH>, <MATH><I>(3,3) - (4,4)</I></MATH> and <MATH><I>(4,4) - (6,6)</I></MATH>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example5.C\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;                  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_836\">CGAL::Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;              Traits;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                 Point;\ntypedef Traits::Curve_2                                 Curve;\ntypedef Traits::X_monotone_curve_2                      X_monotone_curve_2;\ntypedef CGAL::Arr_2_default_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits&gt;                Arr_2;\n\n// A base class for split functors\nstruct Split_base \n{\n  virtual void operator()(const Curve&amp; cv, std::list&lt;Curve&gt;&amp; l)=0;\n};\n\n// A user-defined insertion functor\nstruct Split_func : public Split_base \n{\n  Split_func(double ratio) : r(ratio) {}\n  void operator()(const Curve &amp; cv, std::list&lt;Curve&gt; &amp; l) \n  {\n     Point s=cv.source(); // Uses the knowledge of the curve functions\n     Point t=cv.target();\n     Point m1 = s + (t - s) / r;\n     l.push_back(Curve(s, m1));\n     l.push_back(Curve(m1, t));\n\n   }     \n\n  virtual ~Split_func(){};\nprivate:\n  NT r;\n};\n\nint main() \n{\n  // Prepare a vector of pointers to the functor base class \n  std::vector&lt;Split_base*&gt; func_vec;\n\n  // Create 2 functors\n  Split_func Sf1(2.0), Sf2(3.0);\n\n  func_vec.push_back(&amp;Sf1);\n  func_vec.push_back(&amp;Sf2);\n\n  Arr_2 arr;\n\n  // Insertion with user-defined functor\n  Arr_2::Curve_iterator cit=arr.insert(Curve(Point(0, 0),Point(6, 6)),\n                                       func_vec.begin(), func_vec.end());\n\n  CGAL_assertion(arr.number_of_halfedges() == 8);\n  CGAL_assertion(cit-&gt;number_of_sc_levels() == 2);\n\n  return 0;\n}\n</pre>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n\n<h3>23.6.3&nbsp;&nbsp;&nbsp;I/O functions</h3>\n\nThe <I>Arrangement</I> package supports I/O functions, which include reading \nan arrangement representation from \nthe standard input or writing it to the standard output, \nand also sending an arrangement to a graphic stream.\n<P>\n\nAs already mentioned at chapter , the motivation for \nusing I/O functions is not only to be able to draw the arrangement \nto a window for instance, but also to be capable to save an arrangement \nin a text file by writing it and reloading it from a text file by reading it.\n<P>\n\nReading an arrangement from the standard input or printing it to the\nstandard output may be done simply with the <I>Extractor</I> (<I> &gt;&gt; </I>) and <I>Insertor</I> (<I> &lt;&lt; </I>) operators defined for\n<I><A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A></I>, respectively.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Arr_iostream.h\">CGAL/IO/Arr_iostream.h</A>&gt;</I>\n<P>\n\nThe ability of sending the <I>Arrangement</I> \ninto a graphic stream as <I>leda_window</I>, Postscript file or\nGeomview is also provided, users simply have to apply the Insertor\noperator on the graphic stream and their arrangement instance.\n<P>\n\nUsers of I/O functions for the arrangement package are required to define I/O \noperators for the curves defined in their <I>Traits</I> classes. \nWhen using <I>Traits</I> classes in which this operators are already defined \n(as <I>Segment Traits</I>) the operator definition is not obligated, \nhowever using <I>Traits</I> classes as the <I>Conic Traits</I> will force \nthe users to define I/O operators on their conic curve.\n<P>\n\nThe <I>Arrangement</I> class data consists of the induced planar map and the \nobtained hierarchy tree. Hence, the data sent to the output stream or \nread from an input stream should contain both parts.\n<P>\n\nThe format of the planar map part is as specified in the Planar Map \nreference pages (). \nThe format of the hierarchy tree is specified below.\n<P>\n\nThe format of the output file is defined in a way the reading function \nwill construct the arrangement efficiently. \nThe induced planar map is constructed efficiently as specified in the Planar \nMap reference pages (), and the hierarchy tree is also \nconstructed efficiently by directly accessing its parts and updating them. \nWhen constructing an arrangement from an input stream, no use of its \ninsertion functions is performed.\n<P>\n\nConsequently, the reading function constructs the arrangement very \nefficiently, and hence users who would like to save their arrangement and \nreload it have to construct their  arrangement by the insertion functions \nonly once. After saving the arrangement to a text file it can be reloaded \nvery efficiently when needed, instead of constructing it from scratch.\n<P>\n\nWhen users would like to read their arrangement from the standard input or \nprint it into the standard output, they may simply use the <I>Extractor</I> \n(<I> &gt;&gt; </I>) and <I>Insertor</I> (<I> &lt;&lt; </I>) operators defined for \n<I>Arrangement</I> respectively. \nIf users add attributes to their arrangement components, reading (resp. \nwriting) arrangement would be done by inheriting the class \n<I><A HREF=\"../Arrangement_2_ref/Class_Arr_file_scanner.html#Cross_link_anchor_845\">Arr_file_scanner</A></I>  (resp. <I><A HREF=\"../Arrangement_2_ref/Class_Arr_file_writer.html#Cross_link_anchor_847\">Arr_file_writer</A></I> ) \nand overriding all the relevant function for scanning (resp. writing) the \narrangement components. After the definition of the inherited class users \nhave to call the function <I>read</I> of <I>Arrangement</I> (resp. the \nglobal function <I><A HREF=\"../Arrangement_2_ref/Function_write_arr.html#Cross_link_anchor_849\">write_arr</A></I> ) with the inherited class as a parameter.\nThe ability of sending the <I>Arrangement</I> into a graphic stream as \n<I>leda_window</I>, Postscript file or Geomview is also provided, \nusers simply have to use the Insertor operator operated on the graphic \nstream and their arrangement. When users would like to add attributes to \ntheir arrangement components and send their arrangement to a graphic stream, \nthey have to inherit the class <I><A HREF=\"../Planar_map_ref/Class_Pm_drawer.html#Cross_link_anchor_813\">Pm_drawer</A></I> and then call the global \nfunction <I><A HREF=\"../Planar_map_ref/Function_draw_pm.html#Cross_link_anchor_815\">draw_pm</A></I> with this class and their arrangement as parameters.\nThe function  <I><A HREF=\"../Planar_map_ref/Class_Pm_drawer.html#Cross_link_anchor_813\">Pm_drawer</A></I> is used both for <I>Planar map</I> and \n<I>Arrangement</I>, since drawing an arrangement is defined as drawing only \nits planar map part.\n<P>\n\n<b>Format</b>\n\n<A NAME=\"ccRef_Arr_IO_format\"></A>\nAs mentioned above, the format of the planar map part is as specified \nin the Planar Map reference pages (). \nHere, we are representing the format of the hierarchy tree.\n<P>\n\nGenerally, the format represents the curve nodes list of the \n<I>arrangement</I>. Each component of one curve node is compound from all the \nsubcurves and edge nodes this curve node contains. This data is associative \nwith geometric information and some topological information in order to be \nable to update the hierarchy tree efficiently.\n<P>\n\nThe format is detailed below:\n<P>\n\n<OL>\n    <LI>The data begins with a line of one integer specifying the number \n    of curve nodes the hierarchy tree has.\n    <LI>The list of curve nodes: \n    each curve node has the following format:\n    <OL>\n        <LI>Its associative curve.\n        <LI>An integer specifying the number of levels the curve node has.\n        <LI>The list of all subcurves levels. Each described level goes as \n              follows:\n        <OL>\n            <LI>An integer specifying the number of subcurve nodes in the \n                  current level.\n            <LI>List of subcurve nodes belong to the current level. \n            Each subcurve consist of the following:\n            <OL>\n                <LI>Pointers to subcurves (edge nodes, if the next level \n                      is the last) \n                      of lower level which are given as the begin and past \n                      end indices of children subcurve nodes (edge nodes).\n                <LI>The curve associative with the subcurve node.\n            </OL>\n        </OL>\n        <LI>An integer specifying the number of edge nodes.\n        <LI>List of edge nodes. Each described edge node goes as follows:\n        <OL>\n            <LI>A pointer to an overlapping edge node.\n            This pointer is represented by two indices, the first is an index \n            to a curve node \n            and the second is an index to an edge node defined in that curve \n            node.\n            <LI>An index to the associated halfedge.\n            <LI>The associated curve.\n        </OL>    \n    </OL>\n</OL>\n<P>\n\nOther rules concerning the format are detailed in the Planar Map \nreference pages ().\n<P>\n\n<h4>Example of Usage of the I/O Functions</h4>\n\n<A NAME=\"ARR_sec:example11\"></A>\n<P>\n\nThe input of the program is a text file presenting the <I>Arrangement</I>:\n<pre class=\"ExampleCode\"># ------------------------------------- Printing Arrangement\n# --------------------------------------------------------\n# ------------------------------------- Printing Planar map\n# --------------------------------------------------------\n# Printing number of vertices halfedges and faces in Planar map\n5 8 1\n# 5 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n1/2 1/2\n0/1 1/1\n1/1 0/1\n# 8 halfedges\n# ------------------------------------------\n2 0/1 0/1 1/2 1/2\n1 0/1 0/1 1/2 1/2\n0 1/2 1/2 1/1 1/1\n2 1/2 1/2 1/1 1/1\n2 0/1 1/1 1/2 1/2\n3 0/1 1/1 1/2 1/2\n2 1/2 1/2 1/1 0/1\n4 1/2 1/2 1/1 0/1\n# 1 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n8\n0 5 4 2 3 7 6 1 \n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End of Planar map\n# --------------------------------------------------------\n# Printing curve hierachy\n# number of curves\n2\n# 1 'th curve\n# ------------------------------------------\n0/1 0/1 1/1 1/1\n# number of levels\n0\n# number of edge nodes\n2\n# ----------------------- Edge nodes childrens:\n# pair indices (curve node and its edge node) for next overlapping edge node :\n0 0\n# Halfedge indices associtaed with edge nodes\n0\n# Edge node curve\n0/1 0/1 1/2 1/2\n# pair indices (curve node and its edge node) for next overlapping edge node :\n0 1\n# Halfedge indices associtaed with edge nodes\n2\n# Edge node curve\n1/2 1/2 1/1 1/1\n# finished current level\n# 2 'th curve\n# ------------------------------------------\n0/1 1/1 1/1 0/1\n# number of levels\n0\n# number of edge nodes\n2\n# ----------------------- Edge nodes childrens:\n# pair indices (curve node and its edge node) for next overlapping edge node :\n1 0\n# Halfedge indices associtaed with edge nodes\n4\n# Edge node curve\n0/1 1/1 1/2 1/2\n# pair indices (curve node and its edge node) for next overlapping edge node :\n1 1\n# Halfedge indices associtaed with edge nodes\n7\n# Edge node curve\n1/2 1/2 1/1 0/1\n# finished current level\n# ------------------------------------- End of Arrangement\n# --------------------------------------------------------\n</pre>\n<P>\n\nThe example above presents an arrangement containing two segments that \nintersect in their interior. The segments are <MATH><I>(0,0) - (1,1)</I></MATH> and <MATH><I>(0,1) -\n(1,0)</I></MATH>.  The <I>Arrangement</I> instance that was used to produce this example \nwas templated  with the <I><A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A></I> class, which was \ntemplated with the representation class <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;int&gt; &gt;</I>.\n<P>\n\nThe first part of the input represents the planar map our arrangement \ncontains, and hence its format is identical with . \nIt can be seen that the planar map described here represents all the vertices \nand halfedges obtained by the disjoint subcurves of the arrangement.\n<P>\n\nThe next part of the input file presents the hierarchy tree of our \narrangement. This presentation begins with the number 2, indicating there are \ntwo curve nodes in our arrangement. The list of curve nodes follows.\nThe first curve node begins with its associated curve <MATH><I>(0,0) - (1,1)</I></MATH>, \nit has 0 levels since it does not contain any subcurve nodes (only curve \nnodes and edge nodes). \nThe number of edge nodes the curve <MATH><I>(0,0) - (1,1)</I></MATH> induces is two, \nand the curves these two edge nodes are associated with are \n<MATH><I>(0,0) - (1/2,1/2)</I></MATH> and <MATH><I>(1/2,1/2) - (1,1)</I></MATH> respectively. \nThe indices of each edge node to an overlapping edge node point to the edge \nnode itself since there are no overlapping in the input file. \nFinally, the indices of the halfedge indicates the halfedge our edge node is \nassociated with. \nFor example, the first edge node induced by the curve <MATH><I>(0,0) - (1,1)</I></MATH> is \nassociated  with the first halfedge presented in the halfedges list. The \nreader may verify that this halfedge holds the same curve the edge node holds.\n<P>\n\nThe current format may not be comfortable for a user to read, because the \nusage of indices. There is a possibility to define a verbose format which \ncontains instead of indices, the components themselves, and hence the user \nhas the option to have a format which is easy for human to read.\nThis format cannot be scanned by the reading functions of <I>Arrangement</I>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>/example11.C\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Arr_2_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_837\">Arr_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_821\">Arrangement_2</A>.h&gt;\n#include &lt;CGAL/IO/Arr_iostream.h&gt;\n#include &lt;iostream&gt;\n\n#ifdef CGAL_USE_LEDA\n// #include &lt;CGAL/IO/Arr_Postscript_file_stream.h&gt;\n#endif\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;                  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arr_segment_traits_2.html#Cross_link_anchor_836\">CGAL::Arr_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;              Traits;\ntypedef Traits::Curve                                   Curve;\ntypedef Traits::X_monotone_curve_2                      X_monotone_curve_2;\ntypedef CGAL::Arr_2_default_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Arrangement_2_ref/Class_Arrangement_2.html#Cross_link_anchor_820\">CGAL::Arrangement_2</A>&lt;Dcel,Traits&gt;                Arr;\n\nint main()\n{\n  Arr arr;\n\n  std::cout &lt;&lt; &quot;* * * Demonstrating a trivial use of IO functions&quot;;\n  std::cout &lt;&lt; std::endl &lt;&lt; std::endl;\n  std::cin &gt;&gt; arr;\n  std::cout &lt;&lt; arr;\n  \n  std::cout &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; &quot;* * * Presenting the use of verbose format&quot;;\n  std::cout &lt;&lt; std::endl &lt;&lt; std::endl;;\n  <A HREF=\"../Arrangement_2_ref/Class_Arr_file_writer.html#Cross_link_anchor_846\">CGAL::Arr_file_writer</A>&lt;Arr&gt; verbose_writer(std::cout, arr, true);\n  <A HREF=\"../Arrangement_2_ref/Function_write_arr.html#Cross_link_anchor_848\">CGAL::write_arr</A>(arr, verbose_writer, std::cout);\n\n  // printing to Postscript file.\n#ifdef CGAL_USE_LEDA\n  //  <A HREF=\"../Colors_and_windows_ref/Class_Postscript_file_stream.html#Cross_link_anchor_1755\">CGAL::Postscript_file_stream</A>  LPF(500, 500 ,&quot;arr.ps&quot;);\n  //  LPF.init(-3,3,-3);\n  //  LPF.set_line_width( 1);\n  //  LPF &lt;&lt; arr;\n#endif\n\n  return 0;\n}\n</pre>\n<P>\n\nThe output is the <I>Arrangement</I> written in both formats, non verbose and \nverbose. \n<pre class=\"ExampleCode\">* * * Demonstrating a trivial use of IO functions\n\n# ------------------------------------- Printing Arrangement\n# --------------------------------------------------------\n# ------------------------------------- Begin Planar Map\n# --------------------------------------------------------\n# Number of vertices halfedges and faces in Planar map\n5 8 1\n# 5 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n1/2 1/2\n0/1 1/1\n1/1 0/1\n# 8 halfedges\n# ------------------------------------------\n2 0/1 0/1 1/2 1/2\n1 0/1 0/1 1/2 1/2\n0 1/2 1/2 1/1 1/1\n2 1/2 1/2 1/1 1/1\n2 0/1 1/1 1/2 1/2\n3 0/1 1/1 1/2 1/2\n2 1/2 1/2 1/1 0/1\n4 1/2 1/2 1/1 0/1\n# 1 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n8\n0 5 4 2 3 7 6 1 \n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End Planar Map\n# --------------------------------------------------------\n# Printing curve hierachy\n# number of curves\n2\n# 1 'th curve\n# ------------------------------------------\n0/1 0/1 1/1 1/1\n# number of levels\n0\n# number of edge nodes\n2\n# ----------------------- Edge nodes childrens:\n# pair indices (curve node and its edge node) for next overlapping edge node :\n0 0\n# Halfedge indices associated with edge nodes\n0\n# Edge node curve\n0/1 0/1 1/2 1/2\n# pair indices (curve node and its edge node) for next overlapping edge node :\n0 1\n# Halfedge indices associated with edge nodes\n2\n# Edge node curve\n1/2 1/2 1/1 1/1\n# finished current level\n# 2 'th curve\n# ------------------------------------------\n0/1 1/1 1/1 0/1\n# number of levels\n0\n# number of edge nodes\n2\n# ----------------------- Edge nodes childrens:\n# pair indices (curve node and its edge node) for next overlapping edge node :\n1 0\n# Halfedge indices associated with edge nodes\n4\n# Edge node curve\n0/1 1/1 1/2 1/2\n# pair indices (curve node and its edge node) for next overlapping edge node :\n1 1\n# Halfedge indices associated with edge nodes\n7\n# Edge node curve\n1/2 1/2 1/1 0/1\n# finished current level\n# ------------------------------------- End of Arrangement\n# --------------------------------------------------------\n\n* * * Presenting the use of verbose format\n\n# ------------------------------------- Printing Arrangement\n# --------------------------------------------------------\n# ------------------------------------- Begin Planar Map\n# --------------------------------------------------------\n# Number of vertices halfedges and faces in Planar map\n5 8 1\n# 5 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n1/2 1/2\n0/1 1/1\n1/1 0/1\n# 8 halfedges\n# ------------------------------------------\n0/1 0/1 1/2 1/2 towards  1/2 1/2\n0/1 0/1 1/2 1/2 towards  0/1 0/1\n1/2 1/2 1/1 1/1 towards  1/1 1/1\n1/2 1/2 1/1 1/1 towards  1/2 1/2\n0/1 1/1 1/2 1/2 towards  1/2 1/2\n0/1 1/1 1/2 1/2 towards  0/1 1/1\n1/2 1/2 1/1 0/1 towards  1/2 1/2\n1/2 1/2 1/1 0/1 towards  1/1 0/1\n# 1 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n8\n0/1 0/1 1/2 1/2 towards  1/2 1/2\n0/1 1/1 1/2 1/2 towards  0/1 1/1\n0/1 1/1 1/2 1/2 towards  1/2 1/2\n1/2 1/2 1/1 1/1 towards  1/1 1/1\n1/2 1/2 1/1 1/1 towards  1/2 1/2\n1/2 1/2 1/1 0/1 towards  1/1 0/1\n1/2 1/2 1/1 0/1 towards  1/2 1/2\n0/1 0/1 1/2 1/2 towards  0/1 0/1\n\n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End Planar Map\n# --------------------------------------------------------\n# Printing curve hierachy\n# number of curves\n2\n# 1 'th curve\n# ------------------------------------------\n0/1 0/1 1/1 1/1\n# number of levels\n0\n# number of edge nodes\n2\n# ----------------------- Edge nodes childrens:\n# Halfedge associated with edge nodes\n0/1 0/1 1/2 1/2 towards  1/2 1/2\n# Edge node curve\n0/1 0/1 1/2 1/2\n# Halfedge associated with edge nodes\n1/2 1/2 1/1 1/1 towards  1/1 1/1\n# Edge node curve\n1/2 1/2 1/1 1/1\n# finished current level\n# 2 'th curve\n# ------------------------------------------\n0/1 1/1 1/1 0/1\n# number of levels\n0\n# number of edge nodes\n2\n# ----------------------- Edge nodes childrens:\n# Halfedge associated with edge nodes\n0/1 1/1 1/2 1/2 towards  1/2 1/2\n# Edge node curve\n0/1 1/1 1/2 1/2\n# Halfedge associated with edge nodes\n1/2 1/2 1/1 0/1 towards  1/1 0/1\n# Edge node curve\n1/2 1/2 1/1 0/1\n# finished current level\n# ------------------------------------- End of Arrangement\n# --------------------------------------------------------\n</pre>\n<P>\n\nFor more examples see chapter .\n<P>\n\nMore details are given in sections\n<I><A HREF=\"../Arrangement_2_ref/Class_Arr_file_scanner.html#Cross_link_anchor_845\">Arr_file_scanner</A>&lt;Arrangement&gt;</I>, \n<I><A HREF=\"../Arrangement_2_ref/Class_Arr_file_writer.html#Cross_link_anchor_847\">Arr_file_writer</A>&lt;Arrangement&gt;</I> \n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Arrangement_2_ref/Chapter_intro.html\">2D Arrangements</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_23!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 37912.0}