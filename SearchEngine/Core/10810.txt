{"text": "Program 2 Classes Overloaded Operators and Iterators ICS 33 Intermediate Programming Introduction This programming assignment is designed first to ensure that you know how to write a simple numeric like class that overloads many of the standard Python operators by defining various double underscore methods It also ensures that you know how to write a class that implements iterators by defining an iter method that returns an object that we Python can call next on Finally it ensure that you know how to write iterator decorators by using special generators similar to functions but using yield instead of return in a module There are three separate parts to this assignment In the first part you will write a module defining a single large numeric like class that overloads many operators including those performing arithmetic and relational comparisons In the second part you will write a medium size class which defines various methods including some double underscore methods and specifically by defining an iter method that returns an object that we Python can call next on In the third part you will write a module that defines various iterator decorators implemented by generators each iterator decorator has argument s that are iterators and is itself used an iterator You should download the program2 project folder and unzip it to produce an Eclipse project with three modules You will write classes in the first two modules which can be tested in the script and using the standard driver using the batch self check files that I supplied you will write generators in the third module which can also be tested in the script and including the batch self check file that I supplied Eventually you will submit each of the three modules you write separately to Checkmate It is recommend that you work on this assignment in pairs with someone in your lab section Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early Only one student should submit all parts of the the assignment but both students UCInetID and name should appear in a comment at the top of each submitted py file A special grading program reads this information The format is a comment starting with Submitter and Partner when working with a partner followed by a colon followed by the student s UCInetID in all lower case followed by the student s name in parentheses last name comma first name capitalized appropriately If you omit this information or do not follow this exact form it will require extra work for us to grade your program so we will deduct points Note if you are submitting by yourself and do NOT have a partner you should OMIT the partner line For example if Romeo Montague whose UCInetID is romeo1 submitted a program that he worked on with his partner Juliet Capulet whose UCInetID is jcapulet the comment at the top of each py file would appear as Submitter romeo1 Montague Romeo Partner jcapulet Capulet Juliet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can more accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files The code you write should be as compact and elegant as possible using appropriate Python idioms Problem 1 Sparse Matric Class operators Problem Summary A Matrix is a 2 dimensional type storing values indexed by a row and a column For example the following is a 3x3 Matrix its 3 rows and columns are numbered starting at so 2 Here the value indexed by Row 1 and Column 2 is 3 IndexesColumn Column 1Column 2Row 1 Row 1 53Row 2 1 We could choose to store this Matrix by using a tuple of rows where each row is a tuple of values in its columns 1 5 3 1 But in this problem we will use a more interesting data structure A Sparse Matrix stores the row and column size of a Matrix and a dictonary whose keys are 2 tuples row and column index and their associated non zero values any index in the Matrix that is not a key in its dictionary stores implicitly no key in its dictionary should store a zero value A Sparse Matrix would store the 9 values in the Matrix above in a dictionary of 4 index keys and their associated non values The remaining 5 s are stored implicitly any index key in the Sparse Matrix but not in the dictionary e g the 1 tuple implicitly stores 1 1 1 5 1 2 3 2 2 1 Write a class named Sparse Matrix that represents and defines operators for Sparse Matrix objects which are represented by a dictionary whose keys are 2 tuples representing a row and column of the Sparse Matrix and whose associated values are the non zero matrix values stored at that row and colum Operators will typically be defined to work on Sparse Matrix objects or between a Sparse Matrix and a numeric int or float value The Sparse Matrix class will be be immutable except for the call method which can change the number of rows and columns in a matrix and of course the setitem and delitem methods All other methods will not mutate their Sparse Matrix objects methods that must return a Sparse Matrix like the arithmetic operators will return a newly constructed Sparse Matrix storing the appropriate values Details Define a class named Sparse Matrix in a module named sparsematrix py Define an init method that has two required parameters the number of rows and columns specifying the size of the Sparse Matrix followed by any number zero or more of 3 tuple arguments each will contain a 1 row and a 2 column index and a 3 value that is to be stored at that index For example writing Sparse Matrix 2 2 5 1 1 5 represents a Sparse Matrix whose value at indexes and 1 1 is 5 and whose values at all other indexes are The str method read its definition below displays such a Sparse Matrix as 2x2 5 5 showing it size and all its values both non and The dictionary representing this Sparse Matrix stores only the two non values 5 1 1 5 IMPORTANT Store a Sparse Matrix using the attributes named rows cols and matrix which is a dictionary dict whose keys are 2 tuples row column each of which is associated with a non zero value Store only these attributes no others You must set these attributes as self rows self cols and self matrix because I have defined the str method and various batch self tests to refer to these attributes by these names This dictionary should never store an associated value of if the third value of a 3 tuple supplied to init is ignore it do not store it in self matrix So Sparse Matrix 2 2 5 1 1 5 1 still stores only the two non values in its dictionary 5 1 1 5 The init method should raise an AssertionError with an appropiate message if the arguments violate any of the following conditions The row and column arguments must be integers that are strictly greater than The row and column in each triple must be non negative integers that are strictly less than the number of rows and columns in the Sparse Matrix e g if the Sparse Matrix specifies 3 rows then all the row indexes must be 1 or 2 The row and column in each triple must be unique not repeated Raise an exception on just the first duplicate index if there are any you don t have to find all the duplicates just raise an exception on the first The value in each triple must be numeric an int or float For example in my code writing Sparse Matrix 3 2 1 2 raises AssertionError with the message Sparse Matrix init repeated index Define a size method that returns a 2 tuple containing the row and column size of a Sparse Matrix For m Sparse Matrix 3 2 a Sparse Matrix filled with s so its dictionary is empty m size returns 3 2 You will find this method useful when you write later methods to check for compatible sizes for Sparse Matrices Define a len method that returns the number of values counting all non zero and values in the Sparse Matrix it returns the product of the number of rows and columns Define a bool method that returns False if the Sparse Matrix object stores all zero values it returns True if it returns any non zero values Recall that the dictionary stores only non values Define a repr method that returns a string which when passed to eval returns a newly constructed Sparse Matrix object that represents the same Sparse Matrix object on which repr was called For example if we define m Sparse Matrix 3 3 1 1 1 1 2 2 1 calling repr m returns something like Sparse Matrix 3 3 1 1 1 1 2 2 1 although the order of the 3 tuples doesn t matter Hint I used Python s join function to construct a string of all the 3 tuple values that appear near the end of what repr returns The following three methods are all similar in structure You will find it useful to call these methods implicitly using indexing in other methods operators you are asked to define below but doing so is not necessary Hint 1 d get key default returns d key if key is in the dictionary d and returns default if key is not in the dictionary d Hint 2 writing m calls Sparse Matrix getitem m i e the arguments in m are passed as the 2 tuple to getitem Define a getitem method whose argument is row column 2 tuple it returns the value of the Sparse Matrix at that row and column If the type of the argument is not a 2 tuple whose first and second indexes are integers specifying a legal row then column in the Sparse Matrix then raise a TypeError exception with an appropriate message Define a setitem method whose arguments are a row column 2 tuple and a value it updates the value for that row column If the type of the first argument is not a 2 tuple whose first and second indexes are integers specifying a legal row then column in the Sparse Matrix then raise a TypeError exception with an appropriate message Also if the value argument is not numeric not an int or float then raise a TypeError exception with an appropriate message Otherwise update the Sparse Matrix to store the value at the row column key Hint if the value argument is equal to update the dictionary only if it currently stores a non zero value at that row column key by removing the the row column key from the dictionary This method can mutate the state of a Sparse Matrix Define a delitem method whose argument is row column 2 tuple it deletes that row column key from the Sparse Matrix it is equivalent to storing a zero at that row column key If the type of the argument is not a 2 tuple whose first and second indexes are integers specifying a legal row then column in the Sparse Matrix then raise a TypeError exception with an appropriate message This method can mutate the state of a Sparse Matrix The following two methods are similar in structure You will find it useful to call these methods in other methods operators you are asked to define below specifically in the details and mul methods but doing so is not necessary In the examples directly below we define m so that str m is 3x3 2 3 4 6 7 8 Define the following two methods The row method that takes one int argument it returns a tuple containing all the values in that row from left to right Using m defined above m row returns 2 3 m row 1 returns 4 6 and m row 2 returns 7 8 If the row argument is not an integer whose values specify a legal row in the Sparse Matrix raise an AssertionError with an appropriate message The col method that takes one int argument it returns a tuple containing all the values in that column from top to bottom Using m defined above m col returns 4 7 m col 1 returns 2 8 and m col 2 returns 3 6 If the col argument is not an integer whose values specifies a legal column in the Sparse Matrix raise an AssertionError with an appropriate message Define the details method that returns a string of three pieces of information about a Sparse Matrix object separated by the size the dictionary and a tuple of all the rows see the row method above row row 1 etc If we define m Sparse Matrix 3 3 1 1 1 5 2 2 1 then the of calling m details is 3x3 1 1 1 5 2 2 1 1 5 1 Of course the keys in the dictionary 2nd part can appear in any order but the tuples 3rd part must occur in the exact order shown I have defined a str method that returns a string that nicely displays a Sparse Matrix in a 2 dimensional form I wrote this method to work even if getitem is not implemented correctly it calls self matrix get r c but if getitem were correctly implemented it would call only self r c Define a call method that takes two int arguments specifying the new number of rows and columns in a Sparse Matrix these must each be integers that are strictly greater than if not raise an AssertionError similarly to what you did in the init method It modifies the Sparse Matrix by resetting its row and column size and deleting all values from the dictionary whose indexes lie outside the new size of the re sized Sparse Matrix For example if we define m Sparse Matrix 2 2 1 1 1 1 1 1 1 1 a 2x2 Sparse Matrix filled with 1s and we call m 1 1 then m becomes a 1x1 Sparse Matrix whose dict matrix stores just 1 because all the other indexes that used to be in the dict matrix are now outside the size of Sparse Matrix This method mutates the state of a Sparse Matrix Hint You cannot delete any keys in a dictionary while iterating over it iterate over a copy Define an iter method that produces 3 tuples containing the row column and value for each index in the Sparse Matrix that stores a non value These values must be sorted by the value from smallest to biggest For example if we define m Sparse Matrix 2 2 1 1 3 1 4 1 1 2 which prints as 2x2 1 3 4 2 then iterating through it produces the tuples 1 1 1 2 1 3 1 4 in this order Hint Write this method as a generator covered in Friday s lecture in Week 4 Define all the underscore methods needed to ensure the prefix and abs work correctly returns a new Sparse Matrix with the same values returns a new Sparse Matrix with negated values not that abs returns a new Sparse Matrix with all non negative values Hint I wrote each in 1 line using a comprehension and using to turn a list into arguments for a function call Define all the underscore methods needed to ensure that the add subtract and multiply operators produce the correct answers when their operands are any combination of a Sparse Matrix object with a Sparse Matrix int or float object If Python tries to apply an arithmetic operator to a Sparse Matrix object and any other type of value raise the standard TypeError exception with the standard messsage about unsupported operand types see what 1 a produces in the Python interpreter Recall that none of these operators mutate their operands each produces a new Sparse Matrix and returns it as a result Note that both and but not are commutative when applied to a Sparse Matrix and a numeric value Commutivity with numeric values can make programming these methods simpler so can using the infix operator Hint Create a Sparse Matrix that is the appropriate size with no initial non values then fill in all its indexes with the correct values using getitem and setitem is simplest for computing the resulting Sparse Matrix ensuring that the dictionary contains no values To add two Sparse Matrix objects their sizes must be the same the the new resulting Sparse Matrix will be the same size as both its operand Sparse Matrices and its values are the pair wise addition of the two Sparse Matrix values If we define m1 on the left and m2 on the right as follows 2x3 1 2 3 2x3 1 2 3 4 5 6 4 5 1 Then the result of adding these two Sparse Matrix objects either m1 m2 or m2 m1 is the new Sparse Matrix object 2x3 4 8 7 For example the value in the resulting Sparse Matrix at row and column is the sum of the value 1 in m1 at row and column plus the value 1 in m2 at row and column This pattern repeats for all the other rows and columns in the resulting Sparse Matrix To add a numeric value to a Sparse Matrix the new resulting Sparse Matrix will be the same size as the one operand that is a Sparse Matrix and have that numeric value added to each of the values in the argument Sparse Matrix If we define the Sparse Matrix m as follows 2x3 1 1 2 2 Then the result of adding 1 to this Sparse Matrix 1 m or m 1 adding 1 on the left or on the right is the new Sparse Matrix 2x3 1 2 1 1 3 If the argument is not a Sparse Matrix or numeric value raise a TypeError with the appropriate information if the argument is a Sparse Matrix of a different size see the size method raise an AssertionError with the appropriate information To subtract two Sparse Matrix objects use the identity that m1 m2 m1 m2 the difference between m1 and m2 is the sum of m1 and the negation see part 13 of m2 To multiply two Sparse Matrix objects their sizes must be compatible the number of columns in the left Sparse Matrix must be the same as the number of rows in the right Sparse Matrix the new resulting Sparse Matrix will have the number of rows of the left Sparse Matrix and the number of columns of the right Sparse Matrix The value in the resulting Sparse Matrix at row r and column c is computed by adding together the pairwise products of all the values in row r in the left Sparse Matrix and in column c in the right Sparse Matrix If we define m1 left and m2 right as follows 2x3 1 2 1 3x2 1 2 1 2 2 1 1 Then the result of multiplying these two Sparse Matrix objects is the new Sparse Matrix object 2x2 5 2 4 4 The value at index is the sum of the pairwise multiplication of row in m1 1 2 1 and column in m2 2 1 1 2 2 1 1 5 The value at index 1 is the sum of the pairwise multiplication of row in m1 1 2 1 and column 1 in m2 1 1 1 1 2 1 1 2 The value at index 1 is the sum of the pairwise multiplication of row 1 in m1 2 1 2 and column in m2 2 1 2 1 2 2 1 4 The value at index 1 1 is the sum of the pairwise multiplication of row 1 in m1 1 2 1 and column 1 in m2 1 1 1 1 2 1 1 4 Hint Use the row and col method specified in part 8 To multiply a numeric value by a Sparse Matrix the new resulting Sparse Matrix will have that numeric value multiplied by each of the non values in the Sparse Matrix If we define the Sparse Matrix m as follows 2x3 1 1 2 2 Then the result of multiplying 2 by this Sparse Matrix either 2 m or m 2 multiplying on the left or right is the new Sparse Matrix 2x3 2 2 4 4 Note that if the numeric value is the Sparse Matrix will store all s If the argument is not a Sparse Matrix or numeric value raise a TypeError with the appropriate information if the argument is a Sparse Matrix that is not of a compatible size see the size method raise an AssertionError with the appropriate information Define all the underscore method needed to ensure that the power operator produces the correct answers when its left operand is a square Sparse Matrix object same number of rows as columns and its right operand is restricted to be a non negative int object Compute the answer by using repeated multiplication If the power is not an int raise a TypeError if the power is less than 1 or the Sparse Matrix is not square raise an AssertionError Python automatically provides meanings for and Define the relational operator and These operators must work correctly when one operand is a Sparse Matrix and the the other operand is a Sparse Matrix or a numeric value int or float For any other operands return False for and True for Two Sparse Matrix objects are considered equal if they have the same sizes see the size method and pair wise the same values i e the value in row r column c in one Sparse Matrix is equal to the value in row r column c in the other Sparse Matrix for all rows and columns A Sparse Matrix is considered equal to a numeric value if the Sparse Matrix is any size but all its values are all equal to the numeric value otherwise they are unequal Hint for the numeric value comparison with If the value to check is there must be no values stored in the dictionary representing the non values in the Sparse Matrix If the value to check is non that value must be stored in every index in the Sparse Matrix with this value that is every index must appear in the matrix dict because there must be no values in the Sparse Matrix Define a setattr method that ensures objects in the Sparse Matrix class cannot store new attributes they store only rows cols and matrix The methods you will write should never bind any instance names except in init which initializes rows cols and matrix but exclusively returns newly constructed Sparse Matrix objects with the correct values If an attempt is made to add new attributes to an object by defining a new attribute or rebinding an existing attribute raise an AssertionError with an appropriate message Do not attempt to solve this part of the problem until all other parts are working correctly Important To solve this problem correctly you must also find a way to allow the call method which mutates rows and cols to work correctly this is hard to do If you cannot it best just to not write the setattr method Testing The Sparse Matrix py module includes a script that does some simple matrix calculations and then calls driver driver The project folder contains a bsc1 txt file examine it to use for batch self checking your class These are rigorous but not exhaustive tests Incrementally write and test your class for example getting one arithmetic operator working correctly will create a pattern for the others Note that when exceptions are raised they are printed by the driver but the Command prompt sometimes appears misplaced You can also test code you type into the driver as illustrated below but if you want to perform the same test over and over again when debugging it it better to put this code in the script before the driver is called Notice the default for each command printed in the square brackets is the command previously entered Driver started Command from sparse matrix import Sparse Matrix as SM Command from sparse matrix import Sparse Matrix as SM m SM 2 2 1 1 1 2 1 1 3 Command m SM 2 2 1 1 1 2 1 1 3 print m 2x2 1 2 3 Command print m print m details 2x2 1 1 1 2 1 1 3 1 2 3 Command print m details print m m 2x2 2 4 6 Command print m m print m 1 2x2 1 2 3 4 Command print m 1 print m m 2x2 2 3 6 11 Command print m m quit Driver stopped Problem 2 Bag Class iterators Problem Summary Write a class that represents and defines methods operators and an iterator for the Bag class Bags are similar to sets and have similar operations of which we will implement just the most important but unlike sets they can store multiple copies of items We will store the information in bags as dictionaries I suggest using a defaultdict whose elements are keys whose associated values are the number of times the key occurs in the bag You must store Bags using this data type as specified Details Define a class named Bag in a module named bag py Define an init method that has one parameter an iterable of values that initalize the bag Writing Bag constructs an empty bag Writing Bag d a b d c b d construct a bag with one a two b s one c and three d s Define a repr method that returns a string which when passed to eval returns a newly constructed bag with the same value to the object repr was called on For example for the Bag in the discussion of init the repr method would print its result as Bag a c b b d d d Bags like sets are not sorted so these 7 values can appear in any order We might require that information in the list is sorted but not all values we might put in a bag may be ordered and therefore not sortable e g a bag storing both string and int values Bag a 1 which is allowed Note This method is used to test several other methods operators in the batch self check file so it is critical to write it correctly Define a str method that returns a string that more compactly shows a bag For example for the Bag in the discussion of init the str method would print its result as Bag a 1 c 1 b 2 d 3 Bags like sets are not sorted so these 7 values can appear in any order Define a len method that returns the total number of values in the Bag For example for the Bag in the discussion of init the len method would return 7 Define a unique method that returns the number of different unique values in the Bag For example for the Bag in the discussion of init the unique method would return 4 because there are four different values in the Bag contrast this method with len Define a contains method that returns whether or not its argument is in the Bag one or more times Define a count method that returns the number of times its argument is in the Bag if the argument is not in the Bag Define an add method that adds its argument to the Bag if that value is already in the Bag its count is incremented by 1 if it is not already in the Bag it is added to the Bag with a count of 1 Define an add method that unions its two Bag operands it returns a new Bag with all the values in Bag operands For example str Bag a b Bag b c should be Bag a 1 b 2 c 1 Neither Bag operand should change Define a remove method that removes its argument from the Bag if that value is already in the Bag its count is decremented by 1 and if the count reduces to the value is removed from the dictionary if it is not in the Bag raise a ValueError exception with an appropriate message that includes the value that could not be removed Define eq ne methods that return whether one Bag is equal not equal to another contains the same values the same number of times A Bag is not equal to anything whose type is not a Bag This this method should not change either Bag Define an iter method that that returns an object on which next can be called to produce every value in the Bag all len of them For example for the Bag in the discussion of init the following code for i in x print i end would print acbbddd Bags like sets are not sorted so these 7 values can appear in any order Ensure that the iterator produces those values in the Bag at the time the iterator starts executing so mutating the Bag during iteration will not affect what values it produces Hint Write this method as a generator covered in Friday s lecture in Week 4 I have shown only examples of Bags storing strings because they are convenient to write But bags can store any type of data The repr str and iter next methods must be written independently neither should call the other to get things done Testing The bag py module includes a script that calls driver driver The project folder contains a bsc2 txt file examine it to use for batch self checking your class These are rigorous but not exhaustive tests Incrementally write and test your class check each method as you write it Note that when exceptions are raised they are printed by the driver but the Command prompt sometimes appears misplaced You can write other code at the bottom of your bag py module to test the Bag class or type code into the driver as illustrated below Notice the default for each command is the command previously entered Driver started Command from bag import Bag Command from bag import Bag b Bag d a b d c b d Command b Bag d a b d c b d print b Bag a 1 b 2 c 1 d 3 Command len b print len b 7 Command print len b print b count d 3 Command print b count d quit Driver stopped Problem 3 Module of Decorators iterators Problem Summary Write the following iterator decorators iterators that operate on iterators using Python generators Write each generator to be self contained not calling any other generators fuctions or generators and do not use anything in the itertools py module or any other module that would trivialize this code you may also not call the zip function Note that the argument passed to these generators can be anything that we can iterate over that includes strings lists tuples dictionaries and other generators so you cannot compute the len of the parameter because although strings lists tuples and dictionariess have simple methods to compute lengths generators don t Define space efficient functions They should not create temporary local lists or tuples with all the values in their iterable parameters running count takes any iterable and any predicate function taking one argument and returning a bool value it produces a running count of how many values up to and including the one just iterated over satisfied the predicate For example for i in count bananastand lambda x x in aeiou is vowel print i end produces the values 1 1 2 2 3 3 3 4 4 and 4 up to first false takes any iterable and any predicate function taking one argument and returning a bool value it produces a every value in the iterable for which the predicate is True but produces no more values starting when the predicate is False even if subequent values would produce True For example for i in up to first false 2 5 11 7 8 3 7 4 12 lambda x is prime x print i end produces the values 2 5 11 and 7 it stops when 8 the first non prime is reached n with pad takes any iterable an int n and a pad whose default value is None it produces the first n values from the iterable padded by pad if there are fewer than n values in the iterable for i n with pad abcdefg 3 print i end produces the values a b and c for i n with pad abcdefg 1 print i end produces the values a b c d e f g and Hint use a for loop with a try except and explicit calls to iter and next sequence takes any number of iterables as parameters it produces all the values in the first iterable followed by all in the second all values in the last iterable For example for i in sequence abcd ef ghij print i end produces the values a b c d e f g h i and j alternate takes any number of iterables as parameters it produces the first value from the first parameter then the first value from the the second parameter then the first value from the last parameter then the second value from the first parameter then the second value from the the second parameter then the second value from the last parameter etc If any iteratable produces no more values this generator produces no more values for i in alternate abcde fg hijk print i end produces the values a f h b g i and c Testing The generator py module includes a script that runs various tests in a form better for debugging and finally calls driver driver The project folder contains a bsc3 txt file examine it to use for batch self checking your class These are rigorous but not exhaustive tests Incrementally write and test your class check each function as you write it ", "_id": "http://www.ics.uci.edu/~pattis/ICS-33/assignments/program2/program.html", "title": "program 2", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 2</title>\r\n</head>\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 2</h1>\r\n<h1>\r\nClasses, Overloaded Operators, and Iterators\r\n</h1>\r\n<p>\r\n<h2>ICS-33: Intermediate Programming<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed first to ensure that you know how to\r\n  write a simple (numeric-like) class that overloads many of the standard Python\r\n  operators by defining various double-underscore methods.\r\nIt also ensures that you know how to write a class that implements iterators,\r\n  by defining an <b>__iter__</b> method that returns an object that we/Python\r\n  can call <b>__next__</b> on.\r\nFinally it ensure that you know how to write iterator decorators by using\r\n  special generators (similar to functions, but using <b>yield</b> instead of\r\n  <b>return</b>) in a module.\r\n<p>\r\nThere are three separate parts to this assignment.\r\nIn the first part you will write a module defining a single, large numeric-like\r\n  class that overloads many operators (including those performing arithmetic\r\n  and relational comparisons).\r\nIn the second part you will write a medium-size class, which defines various\r\n  methods, including some double-underscore methods and specifically by\r\n  defining an <b>__iter__</b> method that returns an object that we/Python\r\n  can call <b>__next__</b> on.\r\nIn the third part you will write a module that defines various iterator\r\n  decorators implemented by generators: each iterator decorator has argument(s)\r\n  that are iterators and is itself used an iterator.\r\n<p>\r\nYou should download the \r\n  <a href=\"program2.zip\">program2</a> project folder and unzip it to produce\r\n  an Eclipse project with three modules.\r\nYou will write classes in the first two modules, which can be tested in the\r\n  script and using the standard driver using the batch self-check files that\r\n  I supplied; you will write generators in the third module, which can also be\r\n  tested in the script and including the batch self-check file that I supplied.\r\nEventually you will submit each of the three modules you write separately to\r\n  Checkmate.\r\n<p>\r\nIt is recommend that you work on this assignment in pairs, with someone in your\r\n  lab section.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<!---\r\nIf you believe that it is impossible for you to work with someone, because of\r\n  some special reason(s), you should send me email stating them and asking for\r\n  special permission to work alone (which I do grant, but not frequently).\r\n--->\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  students' UCInetID and name should appear in a comment at the <b>top</b> of\r\n  <b>each submitted .py file</b>.\r\nA special grading program reads this information.\r\nThe format is a comment starting with <b>Submitter</b> and <b>Partner</b> (when\r\n  working with a partner), followed by a <b>colon</b>, followed by the student's <b>UCInetID</b> (in all lower-case), followed by the student's <b>name in\r\n  parentheses</b> (last name, comma, first name -capitalized appropriately).\r\nIf you omit this information, or do not follow this exact form, it will require\r\n  extra work for us to grade your program, so we will deduct points.\r\nNote: if you are submitting by yourself, and do <b>NOT</b> have a partner, you\r\n  should <b>OMIT</b> the partner line.\r\n<p>\r\nFor example if Romeo Montague (whose UCInetID is romeo1) submitted a program\r\n  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)\r\n  the comment at the top of each .py file would appear as:\r\n<pre><b># Submitter: romeo1(Montague, Romeo)\r\n# Partner  : jcapulet(Capulet, Juliet)\r\n# We certify that we worked cooperatively on this programming\r\n#   assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  <b>before</b> starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can more\r\n  accurately assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nThe code you write should be as compact and elegant as possible, using \r\n  appropriate Python idioms.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Sparse Matric Class (operators)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nA <b>Matrix</b> is a 2-dimensional type storing values indexed by a row and a\r\n  column.\r\nFor example, the following is a 3x3 Matrix (its 3 rows and columns are numbered\r\n  starting at 0; so 0-2).\r\nHere, the value indexed by <b>Row 1</b> and <b>Column 2</b> is <b>3</b>.\r\n<p>\r\n<blockquote>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr><th><b>Indexes</b></th>\r\n  <th><b>Column 0</b></th>\r\n  <th><b>Column 1</b></th>\r\n  <th><b>Column 2</b></th>\r\n  </thead>\r\n  <tbody>\r\n  <tr><td><b>Row 0</b></td>\r\n    <td><center>1</center></td>\r\n    <td><center>0</center></td>\r\n    <td><center>0</center></td>\r\n  <tr><td><b>Row 1</b></td>\r\n    <td><center>0</center></td>\r\n    <td><center>5</center></td>\r\n    <td><center><b>3</b></center></td>\r\n  <tr><td><b>Row 2</b></td>\r\n    <td><center>0</center></td>\r\n    <td><center>0</center></td>\r\n    <td><center>1</center></td>\r\n</table>\r\n</blockquote>\r\n<p>\r\nWe could choose to store this Matrix by using a tuple of rows; where each\r\n  row is a tuple of values in its columns.\r\n<blockquote>\r\n<b><pre>( (1, 0, 0), (0, 5, 3), (0, 0, 1) )</pre></b> \r\n</blockquote>\r\nBut in this problem, we will use a more interesting data structure.\r\n<p>\r\nA <b>Sparse Matrix</b> stores the row and column size of a Matrix, and a\r\n  dictonary whose keys are 2-tuples (row and column index) and their associated\r\n  <b>non-zero values</b>: any index in the Matrix that is not a key in its\r\n  dictionary stores <b>0</b> implicitly; no key in its dictionary should store\r\n  a <b>zero</b> value.\r\n<p>\r\nA Sparse Matrix would store the 9 values in the Matrix above in a dictionary of\r\n  4 index keys (and their associated <b>non-0</b> values).\r\nThe remaining 5 <b>0</b>s are stored implicitly: any index key in the Sparse\r\n  Matrix but not in the dictionary (e.g., the <b>(0,1)</b> tuple) implicitly\r\n  stores <b>0</b>.\r\n<blockquote>\r\n<b><pre>{(0,0): 1, (1,1): 5, (1,2): 3, (2,2): 1}</pre></b> \r\n</blockquote>\r\n<p>\r\nWrite a class named <b>Sparse_Matrix</b> that represents and defines operators\r\n  for Sparse Matrix objects, which are represented by a dictionary whose keys\r\n  are 2-tuples representing a row and column of the Sparse Matrix and whose\r\n  associated values are the non-zero matrix values stored at that row and colum.\r\nOperators will typically be defined to work on <b>Sparse_Matrix</b> objects, or\r\n  between a <b>Sparse_Matrix</b> and a numeric (<b>int</b> or <b>float</b>)\r\n  value.\r\n<p>\r\nThe <b>Sparse_Matrix</b> class will be be immutable except for the\r\n  <b>__call__</b> method, which can change the number of rows and columns in a \r\n  matrix (and of course the <b>__setitem__</b> and <b>__delitem__</b> methods).\r\nAll other methods will not mutate their <b>Sparse_Matrix</b> objects; methods\r\n  that must return a <b>Sparse_Matrix</b> (like the arithmetic operators) will\r\n  return a newly_constructed <b>Sparse Matrix</b> storing the appropriate\r\n  values.\r\n<h3>Details</h3>\r\n<ol>\r\n<li>Define a class named <b>Sparse_Matrix</b> in a module named\r\n  <b>sparsematrix.py</b>.\r\n<p>\r\n<li>Define an <b>__init__</b> method that has two required parameters (the\r\n  number of rows and columns specifying the size of the Sparse Matrix),\r\n  followed by any number (zero or more) of 3-tuple arguments: each will\r\n  contain a (1) row and a (2) column index, and a (3) value that is to be\r\n  stored at that index.\r\n<p>\r\nFor example, writing <b>Sparse_Matrix(2, 2, (0,0,5), (1,1,5))</b>\r\n  represents a Sparse Matrix whose value at indexes <b>(0,0)</b> and\r\n  <b>(1,1)</b> is <b>5</b>, and whose values at all other indexes are <b>0</b>.\r\nThe <b>__str__</b> method (read its definition below) displays such a Sparse\r\n  Matrix as\r\n<b><pre>2x2:[5  0\r\n     0  5]</pre></b>\r\nshowing it size and all its values: both <b>non-0</b> and <b>0</b>.\r\nThe dictionary representing this <b>Sparse_Matrix</b> stores only the two\r\n  <b>non-0</b> values: <b>{(0,0): 5, (1,1): 5}</b>\r\n<p>\r\n<b>IMPORTANT:</b>\r\nStore a Sparse Matrix using the attributes named <b>rows</b>, <b>cols</b>,\r\n  and <b>matrix</b> (which is a dictionary (<b>dict</b>) whose keys are\r\n  2-tuples (row,column), each of which is associated with a <b>non-zero</b>\r\n  value).\r\n<b>Store only these attributes: no others.</b>\r\nYou must set these attributes as <b>self.rows</b>, <b>self.cols</b> and\r\n  <b>self.matrix</b>, because I have defined the <b>__str__</b> method and\r\n various <b>batch self-tests</b> to refer to these attributes, by these names.\r\n<p>\r\nThis dictionary should <b>never store</b> an associated value of <b>0</b>:\r\n  if the third value of a 3-tuple supplied to <b>__init__</b> is <b>0</b>\r\n  ignore  it: <b>do not store it in self.matrix</b>.\r\nSo <b>Sparse_Matrix(2, 2, (0,0,5), (1,1,5), (0,1,0))</b> still stores \r\nonly the two <b>non-0</b> values in its dictionary:\r\n  <b>{(0,0): 5, (1,1): 5}</b>.\r\n<p>\r\nThe <b>__init__</b> method should raise an <b>AssertionError</b> with\r\n   an appropiate message if the arguments violate any of the following\r\n   conditions:\r\n<ul>\r\n  <li>The row and column arguments must be integers that are strictly\r\n        greater than <b>0</b>.\r\n  <p>\r\n  <li>The row and column in each triple must be non-negative integers that\r\n        are strictly less than the number of rows and columns in the Sparse\r\n        Matrix: e.g., if the Sparse Matrix specifies 3 rows, then all the\r\n        row indexes must be 0, 1, or 2.\r\n  <p>\r\n  <li>The row and column in each triple must be unique (not repeated).\r\n      Raise an exception on just the first duplicate index (if there are any):\r\n        you don't have to find all the duplicates, just raise an exception on\r\n        the first.\r\n  <p>\r\n  <li>The value in each triple must be numeric (an <b>int</b> or <b>float</b>).\r\n</ul>\r\n<p>\r\nFor example, in my code writing <b>Sparse_Matrix(3,2, (0,0,1), (0,0,2))</b>\r\n  raises\r\n  <b>AssertionError</b> with the message\r\n  <b>Sparse_Matrix.__init__: repeated index (0, 0)</b>.\r\n<p>\r\n<li>Define a <b>size</b> method that returns a 2-tuple containing the row and\r\n      column size of a Sparse Matrix.\r\n    For <b>m = Sparse_Matrix(3,2)</b> (a Sparse Matrix filled with <b>0</b>s, so\r\n      its dictionary is empty) <b>m.size()</b> returns <b>(3,2)</b>.\r\n    You will find this method useful when you write later methods, to check\r\n      for compatible sizes for Sparse Matrices.\r\n<p>\r\n<li>Define a <b>__len__</b> method that returns the number of values (counting\r\n      all <b>non-zero</b> and <b>0</b> values) in the Sparse Matrix: it returns\r\n      the product of the number of rows and columns.\r\n<p>\r\n<li>Define a <b>__bool__</b> method that returns <b>False</b> if the\r\n      <b>Sparse_Matrix</b> object stores all zero values; it returns\r\n      <b>True</b> if it returns any non-zero values.\r\n    Recall that the dictionary stores only non-0 values.\r\n<p>\r\n<li>Define a <b>__repr__</b> method that returns a string, which when\r\n      passed to <b>eval</b> returns a newly constructed <b>Sparse_Matrix</b>\r\n      object that represents the same <b>Sparse_Matrix</b> object on which\r\n      <b>__repr__</b> was called.\r\n    <p>\r\n    For example, if we define\r\n      <b>m = Sparse_Matrix(3,3, (0,0,1), (1,1,1), (2,2,1))</b>, calling\r\n      <b>repr(m)</b> returns something like\r\n      <b>'Sparse_Matrix(3, 3, (0, 0, 1), (1, 1, 1), (2, 2, 1))'</b>, although\r\n      the order of the 3-tuples doesn't matter.\r\n    <p>\r\n    <b>Hint:</b>I used Python's <b>join</b> function to construct a string of\r\n        all the 3-tuple values that appear near the end of what <b>repr</b>\r\n        returns.\r\n<p>\r\n<li>The following three methods are all similar in structure.\r\nYou will find it useful to call these methods implicitly (using <b>[]</b>\r\n  indexing) in other methods/operators you are asked to define below; but doing\r\n  so is not necessary.\r\n<b>Hint 1</b>: <b>d.get(key,default)</b> returns <b>d[key]</b> if <b>key</b>\r\n   is in the dictionary <b>d</b> and returns <b>default</b> if <b>key</b> is\r\n   not in the dictionary <b>d</b>.\r\n<b>Hint 2</b>: writing <b>m[0,0]</b> calls\r\n   <b>Sparse_Matrix.__getitem__(m,(0,0))</b>: i.e., the arguments <b>0,0</b>\r\n   in <b>m[...]</b> are passed as the 2-tuple <b>(0,0)</b> to\r\n   <b>__getitem__</b>.\r\n<p>\r\n<ul>\r\n<li>Define a <b>__getitem__</b> method whose argument is row,column 2-tuple; it\r\n      returns the value of the Sparse Matrix at that row and column.\r\n    If the type of the argument is not a 2-tuple, whose first and second\r\n      indexes are integers specifying a legal row then column in the Sparse\r\n      Matrix, then raise a <b>TypeError</b> exception with an appropriate\r\n      message.\r\n<p>\r\n<li>Define a <b>__setitem__</b> method whose arguments are a row,column 2-tuple\r\n      and a value; it updates the value for that row,column.\r\n    If the type of the first argument is not a 2-tuple whose first and second\r\n      indexes are integers specifying a legal row then column in the Sparse\r\n      Matrix, then raise a <b>TypeError</b> exception with an appropriate\r\n      message.\r\n    Also, if the value argument is not numeric (not an <b>int</b> or\r\n       <b>float</b>), then raise a <b>TypeError</b> exception with an\r\n       appropriate message.\r\n    Otherwise update the Sparse Matrix to store the value at the row,column key.\r\n    <b>Hint</b>: if the value argument is equal to <b>0</b>, update the\r\n      dictionary only if it currently stores a non-zero value at that\r\n      row,column key by removing the the row,column key from the dictionary.\r\n    This method can mutate the state of a Sparse Matrix.\r\n<p>\r\n\r\n<li>Define a <b>__delitem__</b> method whose argument is row,column 2-tuple; it\r\n      deletes that row,column key from the Sparse Matrix; it is equivalent to\r\n      storing a zero at that row,column key.\r\n    If the type of the argument is not a 2-tuple, whose first and second\r\n      indexes are integers specifying a legal row then column in the Sparse\r\n      Matrix, then raise a <b>TypeError</b> exception with an appropriate\r\n      message.\r\n    This method can mutate the state of a Sparse Matrix.\r\n</ul>\r\n<p>\r\n<li>The following two methods are similar in structure.\r\nYou will find it useful to call these methods in other methods/operators you\r\n  are asked to define below (specifically, in the <b>details</b> and\r\n  <b>__mul__</b> methods); but doing so is not necessary.\r\nIn the examples directly below we define <b>m</b> so that <b>str(m)</b> is\r\n<b><pre>  3x3:[0  2  3\r\n       4  0  6\r\n       7  8  0]</pre></b>\r\nDefine the following two methods:\r\n<p>\r\n<ul>\r\n<li>The <b>row</b> method that takes one <b>int</b> argument: it returns\r\n  a tuple containing all the values in that row (from left to right).\r\nUsing <b>m</b> defined above</b>, <b>m.row(0)</b> returns <b>(0, 2, 3)</b>; \r\n  <b>m.row(1)</b> returns <b>(4, 0, 6)</b>; and\r\n  <b>m.row(2)</b> returns <b>(7, 8, 0)</b>. \r\nIf the <b>row</b> argument is not an integer whose values specify a legal\r\n  row in the Sparse Matrix, raise an <b>AssertionError</b> with an\r\n  appropriate message.\r\n<p>\r\n<li>The <b>col</b> method that takes one <b>int</b> argument: it returns\r\n  a tuple containing all the values in that column (from top to bottom).\r\nUsing <b>m</b> defined above</b>, <b>m.col(0)</b> returns <b>(0, 4, 7)</b>; \r\n  <b>m.col(1)</b> returns <b>(2, 0, 8)</b>; and\r\n  <b>m.col(2)</b> returns <b>(3, 6, 0)</b>. \r\nIf the <b>col</b> argument is not an integer whose values specifies a legal\r\n  column in the Sparse Matrix, raise an <b>AssertionError</b> with an\r\n appropriate message.\r\n</ul>\r\n<p>\r\n<li>Define the <b>details</b> method that returns a string of three pieces of\r\n  information about a <b>Sparse_Matrix</b> object, separated by <b> -&gt; </b>:\r\n  the size, the dictionary, and a tuple of all the rows (see the <b>row</b>\r\n  method above): row 0, row 1, etc.\r\nIf we define\r\n  <b>m = Sparse_Matrix(3,3, (0,0,1), (1,1,5), (2,2,1))</b>,\r\n  then the of calling <b>m.details()</b> is\r\n<b><pre>'3x3 -> {(0, 0): 1, (1, 1): 5, (2, 2): 1} -> ((1, 0, 0), (0, 5, 0), (0, 0, 1))'</pre></b>\r\nOf course, the keys in the dictionary (2nd part) can appear in any order, but\r\n  the tuples (3rd part) must occur in the exact order shown.\r\n<p>\r\n<li>I have defined a <b>__str__</b> method that returns a string that nicely\r\n      displays a Sparse Matrix in a 2-dimensional form.\r\n    I wrote this method to work even if <b>__getitem__</b> is not\r\n      implemented correctly; it calls <b>self.matrix.get((r,c),0)</b>, but if\r\n      <b>__getitem</b> were correctly implemented it would call only \r\n      <b>self[r,c]</b>.\r\n<p>\r\n<li>Define a <b>__call__</b> method that takes two <b>int</b> arguments,\r\n      specifying the new number of rows and columns in a Sparse Matrix; these\r\n      must each be integers that are strictly greater than <b>0</b>; if not,\r\n      raise an <b>AssertionError</b>, similarly to what you did in the\r\n      <b>__init__</b> method.\r\n    It modifies the Sparse Matrix by resetting its row and column size and\r\n      <b>deleting</b> all values from the dictionary whose indexes lie\r\n      outside the new size of the re-sized Sparse Matrix.\r\n    <p>\r\n    For example if we define\r\n      <b>m = Sparse_Matrix(2, 2, (0,0,1),(0,1,1),(1,0,1),(1,1,1))</b>\r\n      (a 2x2 Sparse Matrix filled with 1s) and we call <b>m(1,1)</b> then\r\n      <b>m</b> becomes a 1x1 Sparse Matrix whose <b>dict matrix</b> stores just\r\n      <b>{(0,0): 1}</b> because all the other indexes (that used to be in the\r\n      <b>dict matrix</b>) are now outside the size of Sparse Matrix.\r\n    <p>\r\n    This method mutates the state of a Sparse Matrix.\r\n    <b>Hint:</b> You cannot delete any keys in a dictionary while iterating\r\n        over it: iterate over a copy.\r\n<p>\r\n<li>Define an <b>__iter__</b> method that produces 3-tuples containing \r\n      the row, column, and value for each index in the Sparse Matrix that\r\n      stores a <b>non-0</b> value.\r\n    These values must be <b>sorted by the value (from smallest to biggest)</b>.\r\n    For example, if we define\r\n        <b>m = Sparse_Matrix(2, 2, (0,0,1),(0,1,3), (1,0,4), (1,1,2)))</b>\r\n    which prints as\r\n<b><pre>2x2:[1  3\r\n     4  2]</pre></b>\r\n    then iterating through it produces the tuples <b>(0,0,1)</b>, \r\n      <b>(1,1,2)</b>, <b>(0,1,3)</b>, <b>(1,0,4)</b> in this order.\r\n    <p>\r\n    <b>Hint</b>: Write this method as a generator (covered in Friday's lecture\r\n      in Week 4).\r\n<p>\r\n<li>Define all the underscore methods needed to ensure the prefix +/- and\r\n      <b>abs</b> work correctly: <b>+</b> returns a new Sparse Matrix with the\r\n      same values; <b>-</b> returns a new Sparse Matrix with negated values\r\n      (not that <b>-0</b> == <b>0</b>); <b>abs</b> returns a new Sparse Matrix\r\n      with all non-negative values.\r\n    <b>Hint</b>: I wrote each in 1 line, using a comprehension, and using\r\n      <b>*</b> to turn a list into arguments for a function call.\r\n<p> \r\n<li>Define all the underscore methods needed to ensure that the add, subtract,\r\n      and multiply operators produce the correct answers when their operands\r\n      are any combination of a <b>Sparse_Matrix</b> object with a\r\n      <b>Sparse_Matrix</b>, <b>int</b>, or <b>float</b> object.\r\n    <p>\r\n    If Python tries to apply an arithmetic operator to a <b>Sparse_Matrix</b>\r\n      object and any other type of value, raise the standard <b>TypeError</b>\r\n      exception with the standard messsage about unsupported operand types: see\r\n      what <b>1+'a'</b> produces in the Python interpreter.\r\n<p>\r\nRecall that none of these operators mutate their operands: each produces a new\r\n  Sparse Matrix and returns it as a result.\r\nNote that both <b>+</b> and <b>*</b> (but not <b>-</b>) are commutative when\r\n  applied to a Sparse Matrix and <b>a numeric value</b>.\r\nCommutivity with numeric values can make programming these methods simpler;\r\n  so can using the infix <b>-</b> operator.\r\n<p>\r\n<b>Hint:</b> Create a Sparse Matrix that is the appropriate size, with no\r\n  initial <b>non-0</b> values; then fill in all its indexes with the correct\r\n  values: using <b>__getitem__</b> and <b>__setitem__</b> is simplest, for\r\n  computing the resulting Sparse Matrix, ensuring that the dictionary contains\r\n  no <b>0</b> values.\r\n<ul>\r\n<li>To add two <b>Sparse_Matrix</b> objects, their sizes must be the\r\n      <b>same</b>; the the new resulting Sparse Matrix will be the same size as\r\n      both its operand Sparse Matrices, and its values are the pair-wise\r\n      addition of the two Sparse Matrix values.\r\nIf we define <b>m1</b> (on the left) and <b>m2</b> (on the right) as follows\r\n<b><pre>2x3:[1  2  3          2x3:[-1   2   -3\r\n     4  5  6]               4  -5    1]</pre></b>\r\nThen the result of adding these two Sparse Matrix objects (either <b>m1+m2</b>\r\n  or <b>m2+m1</b>) is the new Sparse Matrix object\r\n<b><pre>2x3:[0  4  0\r\n     8  0  7]</pre></b>\r\nFor example, the value (<b>0</b>) in the resulting Sparse Matrix at row 0 and\r\n column 0 is the sum of the value (<b>1</b>) in <b>m1</b> at row 0 and column 0\r\n plus the value (<b>-1</b>) in <b>m2</b> at row 0 and column 0.\r\nThis pattern repeats for all the other rows and columns in the resulting Sparse\r\n  Matrix.\r\n<p>\r\nTo add a numeric value to a Sparse Matrix, the new resulting Sparse Matrix\r\n  will be the same size as the one operand that is a Sparse Matrix, and have\r\n  that numeric value added to each of the values in the argument Sparse Matrix.\r\nIf we define the Sparse Matrix <b>m</b> as follows\r\n<b><pre>\r\n2x3:[-1   0   1\r\n     -2   0   2]</pre></b>\r\nThen the result of adding <b>1</b> to this Sparse Matrix (<b>1+m</b> or\r\n  <b>m+1</b>: adding <b>1</b> on the left or on the right) is the new Sparse\r\n  Matrix\r\n<b><pre>2x3:[ 0   1   2\r\n     -1   1   3]</pre></b>\r\nIf the argument is not a Sparse Matrix or numeric value, raise a\r\n  <b>TypeError</b> with the appropriate information; if the argument is a\r\n  Sparse Matrix of a different size (see the <b>size</b> method), raise an\r\n  <b>AssertionError</b> with the appropriate information.\r\n<p>\r\n<li>To subtract two <b>Sparse_Matrix</b> objects, use the identity that\r\n      <b>m1-m2</b> = <b>m1 + -m2</b>: the difference between <b>m1</b> and\r\n      <b>m2</b> is the sum of <b>m1</b> and the negation (see part 13) of\r\n      <b>m2</b>.\r\n<p>\r\n<li>To multiply two Sparse Matrix objects, their sizes must be\r\n      <b>compatible</b>: the number of <b>columns in the left</b> Sparse\r\n      Matrix must be the same as the number of <b>rows in the right</b> Sparse\r\n      Matrix; the new resulting Sparse Matrix will have the number of\r\n      <b>rows of the left</b> Sparse Matrix and the number of\r\n      <b>columns of the right</b> Sparse Matrix.\r\nThe value in the resulting Sparse Matrix at row <b>r</b> and column <b>c</b> is\r\n  computed by adding together the pairwise products of all the values in <b>row\r\n  r in the left</b> Sparse Matrix and in <b>column c in the right</b> Sparse\r\n  Matrix.\r\n<p>\r\nIf we define <b>m1</b> (left) and <b>m2</b> (right) as follows\r\n<b><pre>2x3:[1  2  1          3x2:[0  1\r\n     2  1  2]              2  0\r\n                           1  1]</pre></b>\r\nThen the result of multiplying these two Sparse Matrix objects is the new Sparse\r\n  Matrix object\r\n<b><pre>2x2:[5  2\r\n     4  4]</pre></b>\r\n<ul>\r\n<li>The value at index (0,0) is the sum of the pairwise multiplication of\r\n  row 0 in <b>m1</b> (1, 2, 1) and column 0 in <b>m2</b> (0, 2, 1):\r\n  1*0 + 2*2 + 1*1 = 5.\r\n<li>The value at index (0,1) is the sum of the pairwise multiplication of\r\n  row 0 in <b>m1</b> (1, 2, 1) and column 1 in <b>m2</b> (1, 0, 1):\r\n  1*1 + 2*0 + 1*1 = 2.\r\n<li>The value at index (1,0) is the sum of the pairwise multiplication of\r\n  row 1 in <b>m1</b> (2, 1, 2) and column 0 in <b>m2</b> (0, 2, 1):\r\n  2*0 + 1*2 + 2*1 = 4.\r\n<li>The value at index (1,1) is the sum of the pairwise multiplication of\r\n  row 1 in <b>m1</b> (1, 2, 1) and column 1 in <b>m2</b> (1, 0, 1):\r\n  1*1 + 2*0 + 1*1 = 4.\r\n</ul>\r\n<p>\r\n<b>Hint</b>: Use the <b>row</b> and <b>col</b> method specified in part 8.\r\n<p>\r\nTo multiply a numeric value by a Sparse Matrix, the new resulting Sparse Matrix\r\n  will have that numeric value multiplied by each of the <b>non-0</b> values in\r\n  the Sparse Matrix.\r\nIf we define the Sparse Matrix <b>m</b> as follows\r\n<b><pre>\r\n2x3:[-1   0   1\r\n     -2   0   2]</pre></b>\r\nThen the result of multiplying <b>2</b> by this Sparse Matrix\r\n  (either <b>2*m</b> or <b>m*2</b>; multiplying on the left or right)\r\n  is the new Sparse Matrix\r\n<b><pre>2x3:[-2   0   2\r\n     -4   0   4]</pre></b>\r\nNote that if the numeric value is <b>0</b> the Sparse Matrix will store all\r\n  <b>0</b>s.\r\n<p>\r\nIf the argument is not a Sparse Matrix or numeric value, raise a\r\n  <b>TypeError</b> with the appropriate information; if the argument is a\r\n  Sparse Matrix that is not of a compatible size (see the <b>size</b> method),\r\n  raise an <b>AssertionError</b> with the appropriate information.\r\n</ul>\r\n<p>\r\n<li>Define all the underscore method needed to ensure that the power\r\n      operator (**) produces the correct answers when its left operand is a\r\n      square <b>Sparse_Matrix</b> object (same number of rows as columns) and\r\n      its right operand is restricted to be a non-negative <b>int</b> object.\r\n    Compute the answer by using repeated multiplication.\r\n    If the power is not an <b>int</b> raise a <b>TypeError</b>; if the power is\r\n      less than <b>1</b> or the Sparse Matrix is not square, raise an\r\n      <b>AssertionError</b>.\r\n<p> \r\n<li>Python automatically provides meanings for <b>+=</b>, <b>-=</b>, \r\n      <b>*=</b>, and <b>**=</b>.\r\n<p>\r\n<li>Define the relational operator <b>==</b> and <b>!=</b>.\r\nThese operators must work correctly when one operand is a Sparse Matrix and the\r\n  the other operand is a Sparse Matrix or a numeric value\r\n  (<b>int</b> or <b>float</b>).\r\nFor any other operands, return <b>False</b> for <b>==</b> and <b>True</b> for\r\n   <b>!=</b>.\r\n<p>\r\nTwo <b>Sparse_Matrix</b> objects are considered equal if they have the\r\n  <b>same</b> sizes (see the <b>size</b> method) and pair-wise the same values:\r\n  i.e., the value in row r,column c in one Sparse Matrix is equal to the value\r\n  in row r,column c in the other Sparse Matrix, for all rows and columns.\r\nA Sparse Matrix is considered equal to a numeric value if the Sparse Matrix is\r\n  any size, but all its values are all equal to the numeric value; otherwise\r\n  they are unequal.\r\n<p>\r\n<b>Hint for the numeric value comparison with ==</b>:\r\n<ul>\r\n<li>If the value to check is <b>0</b>, there must be no values stored in the\r\n  dictionary representing the <b>non-0</b> values in the Sparse Matrix.\r\n<p>\r\n<li>If the value to check is <b>non-0</b>, that value must be stored in every\r\n  index in the Sparse Matrix with this value: that is, every index must appear\r\n  in the <b>matrix dict</b>, because there must be no <b>0</b> values in the\r\n  Sparse Matrix.\r\n</ul>\r\n<p>\r\n\r\n<li>Define a <b>__setattr__</b> method that ensures objects in the\r\n      <b>Sparse_Matrix</b> class cannot store new attributes: they store\r\n      only <b>rows</b>, <b>cols</b>, and <b>matrix</b>.\r\n    The methods you will write should never bind any instance names\r\n       (except in  <b>__init__</b>, which initializes <b>rows</b>, <b>cols</b>, \r\n       and <b>matrix</b>) but exclusively returns newly constructed\r\n       <b>Sparse_Matrix</b> objects with the  correct values.\r\n    If an attempt is made to add new attributes to an object (by defining a new\r\n      attribute or rebinding an existing attribute), raise an\r\n      <b>AssertionError</b> with an appropriate message.\r\n    <p>\r\n    Do not attempt to solve this part of the problem until all other parts\r\n      are working correctly.\r\n<p>\r\n<b>Important:</b> To solve this problem correctly, you must also find a way to\r\n  allow the <b>__call__</b> method (which mutates <b>rows</b> and <b>cols</b>)\r\n  to work correctly; this is hard to do.\r\n  If you cannot, it best just to not write the <b>__setattr__</b> method.\r\n</ol>\r\n<p>\r\n\r\n<h3>Testing</h3>\r\nThe <b>Sparse_Matrix.py</b> module includes a script that does some simple\r\n  matrix calculations and then calls <b>driver.driver()</b>.\r\nThe project folder contains a <b>bsc1.txt</b> file (examine it) to use for\r\n   batch-self-checking your class.\r\nThese are rigorous but not exhaustive tests.\r\nIncrementally write and test your class: for example, getting one arithmetic\r\n  operator working correctly will create a pattern for the others.\r\n<p>\r\nNote that when exceptions are raised, they are printed by the driver but the \r\n  <b>Command:</b> prompt sometimes appears misplaced.\r\n<p>\r\nYou can also test code you type into the driver as illustrated below; but if you\r\n  want to perform the same test over and over again when debugging, it it\r\n  better to put this code in the script before the driver is called.\r\nNotice the default for each command (printed in the square brackets) is the\r\n  command previously entered.\r\n<b><pre>  Driver started\r\n  Command[!]: from sparse_matrix import Sparse_Matrix as SM\r\n  Command[from sparse_matrix import Sparse_Matrix as SM]: m = SM(2,2,(0,0,0),(0,1,1),(1,0,2),(1,1,3))\r\n  Command[m = SM(2,2,(0,0,0),(0,1,1),(1,0,2),(1,1,3))]: print(m)\r\n  2x2:[0  1\r\n       2  3]\r\n  Command[print(m)]: print(m.details())\r\n  2x2 -> {(0, 1): 1, (1, 0): 2, (1, 1): 3} -> ((0, 1), (2, 3))\r\n  Command[print(m.details())]: print(m+m)\r\n  2x2:[0  2\r\n       4  6]\r\n  Command[print(m+m)]: print(m+1)\r\n  2x2:[1  2\r\n       3  4]\r\n  Command[print(m+1)]: print(m*m)\r\n  2x2:[ 2   3\r\n        6  11]\r\n  Command[print(m*m)]: quit\r\n  Driver stopped</pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem #2 -->\r\n\r\n<a name=\"problem6\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2: Bag Class (iterators)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite a class that represents and defines methods, operators, and an iterator\r\n  for the <b>Bag</b> class.\r\nBags are similar to sets, and have similar operations (of which we will\r\n  implement just the most important) but unlike sets they can store multiple\r\n  copies of items.\r\nWe will store the information in bags as dictionaries (I suggest using a \r\n   <b>defaultdict</b>) whose elements are keys whose associated values are the\r\n   number of times the key  occurs in the bag.\r\n<b>You must store Bags using this data type as specified</b>\r\n<h3>Details</h3>\r\n<ul>\r\n<li>Define a class named <b>Bag</b> in a module named <b>bag.py</b>\r\n<p>\r\n<li>Define an <b>__init__</b> method that has one parameter, an iterable of\r\n       values that initalize the bag.\r\n    Writing <b>Bag()</b> constructs an empty bag.\r\n    Writing <b>Bag(['d','a','b','d','c','b','d'])</b> construct a bag with\r\n      one <b>'a'</b>, two <b>'b'</b>s, one <b>'c'</b>, and three <b>'d'</b>s.\r\n<p>\r\n<li>Define a <b>__repr__</b> method that returns a string, which when passed to\r\n       <b>eval</b> returns a newly constructed bag with the same value\r\n       (<b>==</b>) to the object <b>__repr__</b> was called on.\r\n    For example, for the <b>Bag</b> in the discussion of <b>__init__</b> the\r\n        <b>__repr__</b> method would print its result as\r\n       <b>Bag(['a', 'c', 'b', 'b', 'd', 'd', 'd'])</b>.\r\n    Bags like sets are not sorted, so these 7 values can appear in any order.\r\n    We might require that information in the list is sorted, but not all values\r\n      we might put in a bag may be ordered (and therefore not sortable): e.g.,\r\n      a bag storing both string and int values, <b>Bag(['a',1])</b> which is\r\n      allowed.\r\n    <p>\r\n    <b>Note</b>: This method is used to test several other methods/operators\r\n       in the batch self-check file; so it is critical to write it correctly.\r\n<p>\r\n<li>Define a <b>__str__</b> method that returns a string that more compactly\r\n      shows a bag.\r\n    For example, for the <b>Bag</b> in the discussion of <b>__init__</b> the\r\n        <b>__str__</b> method would print its result as\r\n       <b>Bag(a[1], c[1], b[2], d[3])</b>.\r\n    Bags like sets are not sorted, so these 7 values can appear in any order.\r\n<p>\r\n<li>Define a <b>__len__</b> method that returns the total number of values in\r\n      the <b>Bag</b>.\r\n    For example, for the <b>Bag</b> in the discussion of <b>__init__</b> the\r\n        <b>__len__</b> method would return <b>7</b>.\r\n<p>\r\n<li>Define a <b>unique</b> method that returns the number of different\r\n      (<b>unique</b>) values in the <b>Bag</b>.\r\n    For example, for the <b>Bag</b> in the discussion of <b>__init__</b> the\r\n        <b>unique</b> method would return <b>4</b>, because there are four\r\n        different values in the <b>Bag</b>; contrast this method with\r\n        <b>__len__</b>.\r\n<p>      \r\n<li>Define a <b>__contains__</b> method that returns whether or not its\r\n      argument is in the <b>Bag</b> (one or more times).\r\n<p>\r\n<li>Define a <b>count</b> method that returns the number of times its argument\r\n      is in the <b>Bag</b>: <b>0</b> if the argument is not in the <b>Bag</b>.\r\n<p>\r\n<li>Define an <b>add</b> method that adds its argument to the <b>Bag</b>: if\r\n      that value is already in the <b>Bag</b>, its count is incremented by\r\n      <b>1</b>; if it is not already in the <b>Bag</b>, it is added to the\r\n      <b>Bag</b> with a count of <b>1</b>.\r\n<p>\r\n<li>Define an <b>__add__</b> method that unions its two <b>Bag</b> operands:\r\n      it returns a new <b>Bag</b> with all the values in <b>Bag</b> operands.\r\n    For example: <b>str(Bag(['a','b] + Bag(['b','c']))</b> should be\r\n      <b>'Bag(a[1],b[2],c[1])'</b>\r\n    Neither <b>Bag</b> operand should change.\r\n<p>\r\n<li>Define a <b>remove</b> method that removes its argument from the\r\n      <b>Bag</b>: if that value is already in the <b>Bag</b>, its count is\r\n      decremented by <b>1</b> (and if the count reduces to <b>0</b>, the value\r\n      is removed from the dictionary; if it is not in the <b>Bag</b>, raise a\r\n      <b>ValueError</b> exception, with an appropriate message that includes\r\n      the value that could not be removed.\r\n<p>\r\n<li>Define <b>__eq__</b>/<b>__ne__</b> methods that return whether one\r\n      <b>Bag</b> is equal/not equal to another: contains the same values the\r\n      same number of times.\r\n    A <b>Bag</b> is not equal to anything whose type is not a <b>Bag</b>\r\n    This this method should not change either <b>Bag</b>.\r\n<p>\r\n<li>Define an <b>__iter__</b> method that that returns an object on which\r\n      <b>next</b> can be called to produce every value in the <b>Bag</b>: all\r\n      <b>len</b> of them.\r\n    For example, for the <b>Bag</b> in the discussion of <b>__init__</b>, \r\n      the following code\r\n<b><pre>  for i in x:\r\n      print(i,end='')</pre></b>\r\nwould print\r\n<b><pre>  acbbddd</pre></b>\r\n    Bags like sets are not sorted, so these 7 values can appear in any order.\r\n<p>\r\nEnsure that the iterator produces those values in the <b>Bag</b> at the time\r\n      the iterator starts executing; so mutating the <b>Bag</b> during\r\n      iteration will <b>not</b> affect what values it produces.\r\n<p>\r\n    <b>Hint</b>: Write this method as a generator (covered in Friday's lecture\r\n      in Week 4).\r\n</ul>\r\nI have shown only examples of <b>Bag</b>s storing strings, because they are\r\n  convenient to write.\r\nBut bags can store any type of data.\r\nThe <b>__repr__</b>, <b>__str__</b>, and <b>__iter__/__next__</b> methods must\r\n  be written independently: neither should call the other to get things done.\r\n<p>\r\n<h3>Testing</h3>\r\nThe <b>bag.py</b> module includes a script that calls <b>driver.driver()</b>.\r\nThe project folder contains a <b>bsc2.txt</b> file (examine it) to use for\r\n   batch-self-checking your class.\r\nThese are rigorous but not exhaustive tests.\r\nIncrementally write and test your class; check each method as you write it.\r\n<p>\r\nNote that when exceptions are raised, they are printed by the driver but the \r\n  <b>Command:</b> prompt sometimes appears misplaced.\r\n<p>\r\nYou can write other code at the bottom of your <b>bag.py</b> module to test the\r\n  <b>Bag</b> class, or type code into the driver as illustrated below.\r\nNotice the default for each command is the command previously entered.\r\n<b><pre>  Driver started\r\n  Command[!]: from bag import Bag\r\n  Command[from bag import Bag]: b = Bag(['d','a','b','d','c','b','d'])\r\n  Command[b = Bag(['d','a','b','d','c','b','d'])]: print(b)\r\n  Bag(a[1], b[2], c[1], d[3])\r\n  Command[len(b)]: print(len(b))\r\n  7\r\n  Command[print(len(b))]: print(b.count('d'))\r\n  3\r\n  Command[print(b.count('d'))]: quit\r\n  Driver stopped</pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem #3 -->\r\n\r\n<a name=\"problem6\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #3: Module of Decorators (iterators)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the following iterator decorators (iterators that operate on iterators)\r\n  using Python generators.\r\nWrite each generator to be self contained, not calling any other generators\r\n  fuctions or generators and do not use anything in the <b>itertools.py</b>\r\n  module (or any other module that would trivialize this code); you may also\r\n  <b>not call</b> the <b>zip</b> function.\r\n<p>\r\nNote that the argument passed to these generators can be anything that we can\r\n  iterate over: that includes strings, lists, tuples, dictionaries, and other\r\n  generators: so, you cannot compute the <b>len</b> of the parameter because\r\n  although strings, lists, tuples, and dictionariess have simple methods to\r\n  compute lengths, generators don't.\r\n<p>\r\nDefine space-efficient functions.\r\nThey should not create temporary/local lists or tuples with all the values in\r\n  their iterable parameters.\r\n<ul>\r\n<li><b>running_count</b> takes any iterable and any predicate function\r\n      (taking one argument and returning a <b>bool</b> value): it produces a\r\n      running count of how many values up to (and including) the one just\r\n      iterated over, satisfied the predicate.\r\n   For example\r\n<b><pre>  for i in count('bananastand', lambda x : x in 'aeiou'): # is vowel\r\n    print(i,end=' ')</pre></b>\r\n   produces the values <b>0</b>, <b>1</b>, <b>1</b>, <b>2</b>, <b>2</b>,\r\n      <b>3</b>, <b>3</b>, <b>3</b>, <b>4</b>, <b>4</b>, and <b>4</b>.\r\n<p>\r\n<li><b>up_to_first_false</b> takes any iterable and any predicate function\r\n      (taking one argument and returning a <b>bool</b> value): it produces a\r\n      every value in the iterable for which the predicate is <b>True</b>, but\r\n      produces no more values starting when the predicate is <b>False</b>\r\n      (even if subequent values would produce <b>True</b>).\r\n   For example\r\n<b><pre>  for i in up_to_first_false([2,5,11,7,8,3,7,4,12], lambda x : is_prime(x)):\r\n    print(i,end=' ')</pre></b>\r\n   produces the values <b>2</b>, <b>5</b>, <b>11</b>, and <b>7</b>; it stops\r\n   when <b>8</b> the first non-prime is reached.\r\n<p>\r\n<li><b>n_with_pad</b> takes any iterable, an int <b>n</b> and a <b>pad</b> \r\n      (whose default value is <b>None</b>): it produces the first <b>n</b>\r\n      values from the iterable, padded by <b>pad</b> if there are fewer than\r\n     <b>n</b> values in the iterable.\r\n<b><pre>  for i n_with_pad('abcdefg',3):\r\n    print(i,end=' ')</pre></b>\r\n   produces the values <b>'a'</b>, <b>'b'</b> and <b>'c'</b>\r\n<b><pre>  for i n_with_pad('abcdefg',10,'?'):\r\n    print(i,end=' ')</pre></b>\r\n   produces the values <b>'a'</b>, <b>'b'</b>, <b>'c'</b>, <b>'d'</b>,\r\n   <b>'e'</b>, <b>'f'</b>, <b>'g'</b>, <b>'?'</b>, <b>'?'</b> and <b>'?'</b>.\r\n   Hint: use a <b>for</b> loop with a <b>try/except</b> and explicit calls to\r\n   <b>iter</b> and <b>next</b>.\r\n<p>\r\n<li><b>sequence</b> takes any number of iterables as parameters: it produces\r\n     all the values in the first iterable, followed by all in the second, ... ,\r\n     all values in the last iterable. For example\r\n<b><pre>  for i in sequence('abcd','ef','ghij'):\r\n      print(i,end='')</pre></b>\r\n     produces the values <b>'a'</b>, <b>'b'</b>, <b>'c'</b>, <b>'d'</b>,\r\n     <b>'e'</b>, <b>'f'</b>, <b>'g'</b>, <b>'h'</b>, <b>'i'</b>, and <b>'j'</b>.\r\n<p>\r\n<li><b>alternate</b> takes any number of iterables as parameters: it produces\r\n     the first value from the first parameter, then the first value from the\r\n     the second parameter, ..., then the first value from the last parameter;\r\n     then the second value from the first parameter, then the second value from\r\n     the the second parameter, ..., then the second value from the last\r\n     parameter; etc. If any iteratable produces no more values, this generator\r\n     produces no more values.\r\n<b><pre>  for i in alternate('abcde','fg','hijk'):\r\n      print(i,end='')</pre></b>\r\n     produces the values <b>'a'</b>, <b>'f'</b>, <b>'h'</b>, <b>'b'</b>,\r\n     <b>'g'</b>, <b>'i'</b>, and <b>'c'</b>.\r\n<p>\r\n\r\n<h3>Testing</h3>\r\nThe <b>generator.py</b> module includes a script that runs various tests (in a\r\n  form better for debugging) and finally calls <b>driver.driver()</b>.\r\nThe project folder contains a <b>bsc3.txt</b> file (examine it) to use for\r\n   batch-self-checking your class.\r\nThese are rigorous but not exhaustive tests.\r\nIncrementally write and test your class; check each function as you write it.\r\n</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n</html>\r\n", "id": 10810.0}