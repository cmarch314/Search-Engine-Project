{"text": "ICS 46 Spring 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 46 Spring 2 14 Project 2 Black and White Due date and time Monday May 5 11 59pm Introduction Many of you have played video games and while it can be more compelling to play them against other people we ve all become quite accustomed to the idea that you can often play them without anyone else being involved with the game making its own decisions about how to play against you This project explores one way to write programs that can make these kinds of decisions that provide a kind of artificial intelligence AI In our case we ll focus our efforts on techniques based around search trees which will also give you more practice with traversing tree based structures and with implementing a more complex recursive algorithm than the ones you built in the previous project After everyone has submitted this project I ll run a tournament in which your AI will compete against those written by others While the tournament has no course credit associated with it you are competing for the notoriety of putting together a better algorithm than anyone else s May the best algorithm win Getting started Before you begin work on this project there are a couple of chores you ll need to complete on your ICS 46 VM to get it set up to proceed Refreshing your ICS 46 VM environment Even if you previously downloaded your ICS 46 VM you may need to refresh its environment before proceeding with this project Log into your VM and issue the command ics46 version to see what version of the ICS 46 environment you currently have stored on your VM Note in particular the timestamp if you see a version with a timestamp older than the one listed below you ll want to refresh your environment by running the command ics46 refresh to download the latest one before you proceed with this project 2 14 4 22 19 13 44 Project 2 template added Creating your project directory on your ICS 46 VM A project template has been created specifically for this project containing a similar structure to the basic template you saw in Project but including a fair amount of code both source code and compiled libraries that is being provided as a starting point So you ll absolutely need to use the project1 template for this project as opposed to the basic one Decide on a name for your project directory then issue the command ics46 start project YOUR CHOSEN PROJECT NAME project2 to create your new project directory using the project2 template For example if you wanted to call your project directory proj2 you would issue the command ics46 start project proj2 project2 to create it Now you re ready to proceed The project directory Change into your project directory and take a look around Having already completed Project 1 what you will see will look very familiar Once again your project directory is capable of building three separate programs that you can run by issuing the commands run app run exp or run gtest As before a lib directory contains precompiled libraries that make up the part of the project that you won t be implementing yourself an include directory contains declarations of things you ll need and others you won t and the usual app core exp and gtest directories for writing your code The game of Othello This project asks you to implement an artificial intelligence for a game called Othello Othello also known as Reversi is a well known two player strategy game The game is played on a square board divided into a grid usually 8x8 though the size of the grid can vary Players alternately place tiles on the game board one player s tiles are black and the other player s are white When tiles are placed on the game board other tiles already on the board are flipped i e a black tile becomes a white tile or vice versa The game concludes when every cell in the grid contains a tile or when neither player is able to make a legal move the winning player is the one who has more tiles on the board at the end of the game The rules of the game along with some notion of strategy are described in the Wikipedia entry on Reversi If you haven t played Othello before or have seen it previously but don t remember how it works you should at least read the sections of the Wikipedia entry that covers the rules of the game knowing how the game is played is crucial to implementing code capable of playing the game well If you want to try playing the game you ll find that a complete working version of Othello is included as part of this project already The application Your work on this project begins with an already working Othello game with a graphical user interface GUI allowing two human players to play the game against each other Also included are two rudimentary artificial intelligence implementations neither is all that intelligent actually but they are at least capable of selecting moves automatically so you can play against them When you run the application a window arranged like the one below will appear The green area will initially be empty and a message will ask you to click the green area to start a new game You ll be asked to choose who will play in game a human player or one of the available AIs and then a game will begin While a game is running the GUI window will look like this When it is a human player s turn to move all you need to do is click on a square to make your move When it an AI s turn to move the AI will make its own decision and the GUI will be updated automatically once the move has been chosen When the game ends you can click anywhere on the board to start a new game Any time an AI makes an invalid move or throws an exception an error message will be displayed along the bottom of the window again you can click anywhere on the board to then start a new game if you d like In addition to the score you ll be able to see which AIs or human players are playing against each other A brief word of warning When you start the application on your ICS 46 VM you may notice an error message like this one in your Terminal window OpenGL Warning Failed to connect to host Make sure 3D acceleration is enabled for this VM libGL error failed to load drive vboxvideo libGL error Try again with LIBGL DEBUG verbose for more details This is something you can safely ignore While the GUI was built with a library called Qt that integrates with OpenGL and provides support for 3D graphics and video playback that functionality is not being used by our application I tried turning 3D acceleration on in my VM s settings in VirtualBox but that caused many additional error messages to pop up instead so I gave up trying to solve this problem since it has no effect on our work anyway The requirements This project actually requires you to complete only a single task write an AI that is capable of choosing moves in an Othello game by using the recursive search tree based algorithm described below Optionally you can implement as many additional AIs as you d like but one of them constitutes your official submission that will be graded the others are strictly for use in the tournament described below Each of your Othello AI implementations is subject to a few restrictions You must derive the outermost class that implements your AI from the abstract base class OthelloAI which is declared in a file OthelloAI hpp in include othellogame You can include this file by simply saying include OthelloAI hpp since the compiler has already been configured to look in the include othellogame directory for header files Your class must provide an implementation of this member function which is pure virtual in the OthelloAI class virtual std pair int int chooseMove const OthelloGameState state the goal of which is to intelligently choose a move that the current player would make in the given game state by returning a std pair that contains an x y coordinate for the move Your class must be registered using the ICS46 DYNAMIC FACTORY REGISTER macro similarly to how you registered your maze generator and maze solver in Project 1 Your class must be declared in a namespace whose name is your UCInetID all lowercase For example my UCInetID is thornton so I would declare and define my class this way MyOthelloAI hpp include OthelloAI hpp namespace thornton class MyOthelloAI public OthelloAI public virtual std pair int int chooseMove const OthelloGameState state MyOthelloAI cpp include MyOthelloAI hpp include ics46 factory DynamicFactory hpp std pair int int thornton MyOthelloAI chooseMove const OthelloGameState state implementation of my AI goes here ICS46 DYNAMIC FACTORY REGISTER OthelloAI thornton MyOthelloAI a human readable name for your class You would do something similar though of course you wouldn t use my UCInetID of thornton you d need to use your own You might also want to choose a better name for your class than MyOthelloAI any name is fine as long as you put your class into a correctly named namespace This requirement ensures that everyone s classes have unique full names necessary so that they can all be linked together for me to run the tournament Naming your Othello AIs Each of your Othello AIs is registered with a display name using the ICS46 DYNAMIC FACTORY REGISTER macro The display name serves three purposes It is displayed in the GUI so you select your AIs as one or both of the players in a game It uniquely identifies which of your AIs is intended to meet this project s requirements The one you want graded should have a name that has Required at the end of it any others you submit should not It will show up in the final results of the Othello tournament so be sure you choose something that is a unique enough that no one else will have chosen it and b is inoffensive I reserve the right to change names that I think are potentially offensive Game trees You can think of the possible game states as being arranged conceptually in a kind of search tree called a game tree Each node of the tree contains a particular game state g Its children are the game states that can result from making each valid move from the state g The root of the tree is the initial game state that is the Othello game before the first move is made The children of this initial state are all of the possible states that can arise from the black player who moves first making a valid opening move There are four such states corresponding to the four possible moves that the black player is permitted to make at the opening All other moves are illegal and as such are not to be considered Here is a partial look at an Othello game tree In the picture from the initial state there are four possibilies from which the black player can choose its initial move From the first of those we see that there are three possible moves that the white player can make in response Other moves aren t pictured but the tree continues to grow in this fashion Not surprisingly the game tree can grow large rather quickly so you ll find that it s difficult to draw very much of it on paper We ll call the leaves in such a game tree the final states These leaves indicate the states in which one player or the other has won the game Exhaustively searching all possibilities Each time a player wants to pick a move he or she wants to pick the one that will lead to a winning game state One algorithm for doing that would determine the best move in three steps We apply an evaluation function to each final game state An evaluation function typically returns a number where higher numbers are considered better We then identify the final state with the highest value that is the end game that we would like to occur as it is the best win for us We determine the path from the current game state to the final state that we chose above We make the move that takes us from the current game state down the path toward the chosen final state Assuming that you had a complete game tree at your disposal this is a simple approach to implement However practical limitations make this approach impossible First of all the number of game states on each level of the tree grows exponentially as you work your way down the tree since there are a number of possible moves that can be taken from any particular game state There simply won t be enough memory to store the entire game tree You can imagine that if you build the game tree 2 levels deep and there are four possible moves that can be made from any particular state the number of nodes in the tree would be greater than 42 which is more than one quadrillion nodes Besides even if there were enough memory available to store the tree the processing time to create the entire game tree would be prohibitive So we ll need to find a compromise an approach that perhaps doesn t always find the best possible outcome but that makes a decision in a reasonable amount of time and using a reasonable amount of memory Also it s important to realize that just because you ve found a path to the end game you want doesn t mean that you can force the events to take place that will get you there Just as your goal is to make moves that are in your best interest your opponent s goal is the opposite So your algorithm will need to account for the fact that our opponent wants to beat you as much as you want to beat your opponent Heuristic search The study of artificial intelligence has much to say about good ways to search toward a goal when it s impractical to check all possible paths toward it We can first make use of the following observation Suppose the top player has made a move in the game and the bottom player wants to figure out the best move to make using the search tree approach we ve been discussing Then the bottom player need only concern himself with the subtree that has the current game state as its root Once a move is made all the other moves that could have been made can be ignored as it is now not possible to take those paths down the tree Thus when analyzing the next move to make we need only generate the part of the search tree that originates from the current game state That s a good step toward reducing our storage needs significantly though it s only the first step especially early in the game there might still be huge numbers of states that can arise from the state we re currently in To reduce our workload even more we can employ a technique called heuristic search In a heuristic search we generate as much of the relevant subtree as is practical using the resulting game states to guide us in selecting a move that we hope will be the best even though we don t have time to get full information about how the move might turn out There are several strategies that we could use At the heart of the strategy that we ll use is the notion of an evaluation function that we discussed earlier We ll need to rate each particular game state in some way so that we can decide which of a large number of game states is the best outcome for us A simple approach though one that ignores some important aspects of the game is the following eval state number of tiles belonging to me number of tiles belonging to my opponent It s also important to note here that you do not need to actually build a game tree in memory Our algorithm will perform a sort of depth first search on the game tree meaning that we can use parameters in a recursive method stored on the run time stack to perform the search negating the need to actually build and store a game tree This will dramatically reduce the amount of memory needed to choose a move since only one path in the tree will ever need to be stored on the run time stack at a time So in an eight level deep search we ll store as many as eight nodes rather than all of the nodes that can be reached in eight moves which might be huge Putting these ideas together we can develop a search algorithm that will help us to evaluate each of the possible moves we might make That algorithm sketched in a very rough pseudo code looks something like this int search OthelloGameState s int depth if depth return evaluation of s else if it s my turn to move for each valid move that I can make from s make that move on s yielding a state s search s depth 1 return the maximum value returned from recursive search calls else for each valid move that my opponent can make from s make that move on s yielding a state s search s depth 1 return the minimum value returned from recursive search calls There are a few things we need to discuss about the algorithm above First notice that there are two cases of recursion either it is your algorithm s turn who is currently making the decision or its opponent s turn In each case the algorithm is almost the same except when it is your algorithm s turn the maximum value is returned In other words the algorithm wants to make the best possible move it can on its own behalf when it is the opponent s turn the minimum value is returned This is because it is assumed that the opponent will also make the move that s in its best interest which in turn is in our worst interest You may not assume that your algorithm will always be the black or the white player Either the black or the white player or both might be played by your algorithm When deciding whether it s my turn or my opponent s turn you ll have to exercise some caution to ensure that you re making the right decision Second notice the depth parameter This will be used to limit the depth of our search to make sure that our search does a manageable amount of work Each time we recurse one level deeper the depth is reduced by one and we stop recursing when it reaches zero You ll need to experiment a bit to decide what depth can be handled in a reasonable amount of time but without limiting the depth you ll find that moves will take orders of magnitude longer than you ll be willing to wait Third observe that when one player makes a move it isn t necessarily the case that the other player will be making the next move occasionally in Othello the same player gets to move twice in a row So care must be taken in deciding whose turn it is The easiest way to deal with this problem is to count on the current game state to keep track of this for you it can always tell you reliably whose turn it is Lastly note that this algorithm returns the evaluation of the best state not the best state itself In short calling search s 4 for some state s asks the following question Looking four moves into the future and assuming I do the best I can do and so does my opponent how well will the state s turn out for me You ll need to exercise some care in actually implementing this algorithm so that chooseMove will be able to call search and use the result to help it choose the right move Evaluation functions The core of your AI what will set it apart from others is the evaluation function that it uses to decide how good each board configuration is I m leaving this as an open problem and you re welcome to implement your evaluation function however you d like You might want to poke around the web looking for strategy guides or other information taking into account for example that some squares on the Othello board are considered more important than others It s intended to be fun to play against your own program to see if you can beat it and I also hope you enjoy fine tuning your program until you have trouble beating it A tournament After the project s due date has passed I ll be gathering all of your AIs together and running a tournament to determine who has the best AI In fairness I ll explain here how the tournament will be organized you ll need to follow these rules in order to win or possibly even to participate You can submit as many AIs as you d like but do be sure that there s something interesting and different about them don t submit ten AIs that are virtually identical for example because I ll need to run O a2 games to complete a tournament with a AIs That grows fast When you register your AIs with a name using the ICS46 DYNAMIC FACTORY REGISTER macro the name you choose will be displayed in the final results posted to the web so a make sure that you don t include your name unless you want your name posted online and b choose names that are somehow unique to you be clever but inoffensive Each AI will play two games against each other AI one each as black and as white The primary factor in determining the best AI is the total percentage of games won Draws with count as 1 2 of a win and 1 2 of a loss So first and foremost your goal is to win games A secondary factor to be used in the case of a tie is the total number of tiles accumulated in all games This means that winning games big as opposed to squeaking out close wins is important if there s a tie but that winning small more often still trumps winning big less often Your AI will be given three seconds of CPU time to choose each of its moves Note that CPU time is not a measurement of actual time passed but only of time consumed by the CPU On the other hand note that threads won t buy you any additional time since four threads running simultaneously consume four times as much CPU as one thread does The three seconds is a hard limit as soon as your AI reaches this limit it will be aborted immediately I ll run the tournament on a machine with these specs Intel Core i7 48 MQ CPU 2 7 GHz 24 GB RAM Windows 7 Professional as the host operating system with the ICS 46 VM running in A VirtualBox instance Your AI needs to be stateless It is entirely possible that different objects of your AI class will be called to choose different moves during the course of the same game so you won t be able to save values in member variables and expect them to still be available the next time your AI chooses a move Your AI is not permitted to launch additional processes though you can launch threads if you d like Note though that every thread can consume CPU time If your AI takes too long to make a move returns an invalid move throws an exception crashes isn t implemented in a class within a namespace named by your UCInetID or violates any of the other rules laid out in the project write up it will be disqualified from the tournament Ultimately only games between AIs that completed the tournament without being disqualified are counted The outcome of the tournament will have no bearing on your grade but it will hopefully motivate you to think a bit about how you might tune up your evaluation function or explore alternative ways of helping your AI to see farther into the future You are required fundamentally to use the algorithm shown in this write up to implement your required AI though you can additionally do anything you d like and you can apply any optimizations to your required AI provided that you re still basically implementing a recursive search tree based algorithm Good luck Deliverables After using the gather script in your project directory to gather up your C source and header files into a single project2 tar gz file as you did in Project submit that file and only that file to Checkmate Refer back to Project if you need instructions on how to do that Follow this link for a discussion of how to submit your project via Checkmate Be aware that I ll be holding you to all of the rules specified in that document including the one that says that you re reponsible for submitting the version of the project that you want graded We won t regrade a project simply because you submitted the wrong version accidentally It s not a bad idea to look at the contents of your tarball before submitting it see Project for instructions on how to do that Can I submit after the deadline Yes it is possible subject to the late work policy for this course which is described in the section titled Late work at this link Originally written by Alex Thornton Spring 2 14 with heavy influence from a similarly named project from ICS 23 ", "_id": "http://www.ics.uci.edu/~thornton/ics46/ProjectGuide/Project2/", "title": "ics 46 spring 2014, project #2: black and white", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2014, Project #2: Black and White</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2014<br />\r\n   Project #2: <i>Black and White</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Monday, May 5, 11:59pm</i></b></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>Many of you have played video games, and while it can be more compelling to play them against other people, we've all become quite accustomed to the idea that you can often play them without anyone else being involved, with the game making its own decisions about how to play against you.  This project explores one way to write programs that can make these kinds of decisions, that provide a kind of <i>artificial intelligence</i> (AI).  In our case, we'll focus our efforts on techniques based around <i>search trees</i>, which will also give you more practice with traversing tree-based structures and with implementing a more complex recursive algorithm than the ones you built in the <a href=\"../Project1\">previous project</a>.</p>\r\n\r\n<p>After everyone has submitted this project, I'll run a tournament in which your AI will compete against those written by others.  While the tournament has no course credit associated with it, you are competing for the notoriety of putting together a better algorithm than anyone else's.  May the best algorithm win!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Getting started</p>\r\n\r\n<p>Before you begin work on this project, there are a couple of chores you'll need to complete on your ICS 46 VM to get it set up to proceed.</p>\r\n\r\n<p class=\"subtitle\">Refreshing your ICS 46 VM environment</p>\r\n\r\n<p>Even if you previously downloaded your ICS 46 VM, you may need to refresh its environment before proceeding with this project.  Log into your VM and issue the command <b>ics46 version</b> to see what version of the ICS 46 environment you currently have stored on your VM.  Note, in particular, the timestamp; if you see a version with a timestamp older than the one listed below, you'll want to refresh your environment by running the command <b>ics46 refresh</b> to download the latest one before you proceed with this project.</p>\r\n\r\n<blockquote><pre>\r\n2014-04-22 19:13:44\r\nProject #2 template added\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Creating your project directory on your ICS 46 VM</p>\r\n\r\n<p>A project template has been created specifically for this project, containing a similar structure to the <b>basic</b> template you saw in <a href=\"../Project0\">Project #0</a>, but including a fair amount of code (both source code and compiled libraries) that is being provided as a starting point.  So you'll absolutely need to use the <b>project1</b> template for this project, as opposed to the <b>basic</b> one.</p>\r\n\r\n<p>Decide on a name for your project directory, then issue the command <b>ics46 start_project <i>YOUR_CHOSEN_PROJECT_NAME</i> project2</b> to create your new project directory using the <b>project2</b> template.  (For example, if you wanted to call your project directory <b>proj2</b>, you would issue the command <b>ics46 start_project proj2 project2</b> to create it.)  Now you're ready to proceed!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The project directory</p>\r\n\r\n<p>Change into your project directory and take a look around.  Having already completed <a href=\"../Project1\">Project #1</a>, what you will see will look very familiar.  Once again, your project directory is capable of building three separate programs that you can run by issuing the commands <b>./run app</b>, <b>./run exp</b>, or <b>./run gtest</b>.  As before, a <b>lib</b> directory contains precompiled libraries that make up the part of the project that you won't be implementing yourself, an <b>include</b> directory contains declarations of things you'll need (and others you won't), and the usual <b>app</b>, <b>core</b>, <b>exp</b>, and <b>gtest</b> directories for writing your code.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The game of Othello</p>\r\n\r\n<p>This project asks you to implement an artificial intelligence for a game called Othello.  Othello (also known as Reversi) is a well-known two-player strategy game.  The game is played on a square board divided into a grid &mdash; usually 8x8, though the size of the grid can vary.  Players alternately place <i>tiles</i> on the game board; one player's tiles are black and the other player's are white.  When tiles are placed on the game board, other tiles already on the board are <i>flipped</i> (i.e., a black tile becomes a white tile or vice versa).  The game concludes when every cell in the grid contains a tile, or when neither player is able to make a legal move; the winning player is the one who has more tiles on the board at the end of the game.</p>\r\n\r\n<p>The rules of the game, along with some notion of strategy, are described in the <a href=\"http://en.wikipedia.org/wiki/Reversi\">Wikipedia entry on Reversi</a>.  If you haven't played Othello before, or have seen it previously but don't remember how it works, you should at least read the sections of the Wikipedia entry that covers the rules of the game; knowing how the game is played is crucial to implementing code capable of playing the game well.</p>\r\n\r\n<p>If you want to try playing the game, you'll find that a complete, working version of Othello is included as part of this project already.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The application</p>\r\n\r\n<p>Your work on this project begins with an already-working Othello game with a graphical user interface (GUI), allowing two human players to play the game against each other.  Also included are two rudimentary artificial intelligence implementations &mdash; neither is all that intelligent, actually, but they are at least capable of selecting moves automatically so you can play against them.</p>\r\n\r\n<p>When you run the application, a window arranged like the one below will appear.  The green area will initially be empty and a message will ask you to click the green area to start a new game.  You'll be asked to choose who will play in game &mdash; a human player or one of the available AIs &mdash; and then a game will begin.</p>\r\n\r\n<p>While a game is running, the GUI window will look like this:</p>\r\n\r\n<p class=\"center\"><img src=\"OthelloUI.png\" alt=\"Screenshot of Othello UI\" /></p>\r\n\r\n<p>When it is a human player's turn to move, all you need to do is click on a square to make your move.  When it an AI's turn to move, the AI will make its own decision and the GUI will be updated automatically once the move has been chosen.</p>\r\n\r\n<p>When the game ends, you can click anywhere on the board to start a new game.  Any time an AI makes an invalid move or throws an exception, an error message will be displayed along the bottom of the window; again, you can click anywhere on the board to then start a new game if you'd like.</p>\r\n\r\n<p>In addition to the score, you'll be able to see which AIs (or human players) are playing against each other.</p>\r\n\r\n<p class=\"subtitle\">A brief word of warning</p>\r\n\r\n<p>When you start the application on your ICS 46 VM, you may notice an error message like this one in your Terminal window:</p>\r\n\r\n<blockquote><pre>\r\nOpenGL Warning: Failed to connect to host. Make sure 3D acceleration is enabled for this VM.\r\nlibGL error: failed to load drive: vboxvideo\r\nlibGL error: Try again with LIBGL_DEBUG=verbose for more details.\r\n</pre></blockquote>\r\n\r\n<p>This is something you can safely ignore.  While the GUI was built with a library called Qt that integrates with OpenGL and provides support for 3D graphics and video playback, that functionality is not being used by our application.  (I tried turning 3D acceleration on in my VM's settings in VirtualBox, but that caused many additional error messages to pop up instead, so I gave up trying to solve this problem, since it has no effect on our work anyway.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The requirements</p>\r\n\r\n<p>This project actually requires you to complete only a single task: write an AI that is capable of choosing moves in an Othello game, by using the recursive, search-tree-based algorithm described below.  Optionally, you can implement as many additional AIs as you'd like, but one of them constitutes your \"official\" submission that will be graded; the others are strictly for use in the tournament (described below). </p>\r\n\r\n<p>Each of your Othello AI implementations is subject to a few restrictions:</p>\r\n\r\n<ul>\r\n  <li>You must derive the outermost class that implements your AI from the abstract base class <b>OthelloAI</b>, which is declared in a file <b>OthelloAI.hpp</b> in <b>include/othellogame</b>.  (You can include this file by simply saying <b>#include \"OthelloAI.hpp\"</b>, since the compiler has already been configured to look in the <b>include/othellogame</b> directory for header files.)</li>\r\n  <li>Your class must provide an implementation of this member function, which is pure virtual in the <b>OthelloAI</b> class:\r\n<blockquote><pre>\r\nvirtual std::pair&lt;int, int&gt; chooseMove(const OthelloGameState&amp; state);\r\n</pre></blockquote>\r\n    the goal of which is to intelligently choose a move that the current player would make in the given game state, by returning a <b>std::pair</b> that contains an <b>(x, y)</b> coordinate for the move.</li>\r\n  <li>Your class must be registered using the <b>ICS46_DYNAMIC_FACTORY_REGISTER</b> macro, similarly to how you registered your maze generator and maze solver in <a href=\"../Project1\">Project #1</a>.</li>\r\n  <li>Your class must be declared in a namespace whose name is your UCInetID (all lowercase).  For example, my UCInetID is <b>thornton</b>, so I would declare and define my class this way:\r\n<blockquote><pre>\r\n// MyOthelloAI.hpp\r\n\r\n#include \"OthelloAI.hpp\"\r\n\r\n\r\nnamespace thornton\r\n{\r\n    class MyOthelloAI : public OthelloAI\r\n    {\r\n    public:\r\n        virtual std::pair&lt;int, int&gt; chooseMove(const OthelloGameState&amp; state);\r\n    };\r\n}\r\n\r\n\r\n// MyOthelloAI.cpp\r\n\r\n#include \"MyOthelloAI.hpp\"\r\n#include &lt;ics46/factory/DynamicFactory.hpp&gt;\r\n\r\n\r\nstd::pair&lt;int, int&gt; thornton::MyOthelloAI::chooseMove(const OthelloGameState&amp; state)\r\n{\r\n    <i>// implementation of my AI goes here</i>\r\n}\r\n\r\n\r\nICS46_DYNAMIC_FACTORY_REGISTER(OthelloAI, thornton::MyOthelloAI, \"<i>a human-readable name for your class</i>\");\r\n</pre></blockquote>\r\n    You would do something similar, though, of course, you wouldn't use my UCInetID of <b>thornton</b>; you'd need to use your own.  You might also want to choose a better name for your class than <b>MyOthelloAI</b>; any name is fine, as long as you put your class into a correctly-named namespace.  (This requirement ensures that everyone's classes have unique full names, necessary so that they can all be linked together for me to run the tournament.)\r\n  </li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Naming your Othello AIs</p>\r\n\r\n<p>Each of your Othello AIs is registered with a <i>display name</i> using the <b>ICS46_DYNAMIC_FACTORY_REGISTER</b> macro.  The display name serves three purposes:</p>\r\n\r\n<ul>\r\n  <li>It is displayed in the GUI, so you select your AIs as one or both of the players in a game.</li>\r\n  <li>It uniquely identifies which of your AIs is intended to meet this project's requirements.  The one you want graded should have a name that has <b>(Required)</b> at the end of it; any others you submit should not.</li>\r\n  <li>It will show up in the final results of the Othello tournament, so be sure you choose something that is (a) unique enough that no one else will have chosen it, and (b) is inoffensive (I reserve the right to change names that I think are potentially offensive).</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Game trees</p>\r\n\r\n<p>You can think of the possible game states as being arranged, conceptually, in a kind of search tree called a <i>game tree</i>.  Each node of the tree contains a particular game state <i>g</i>.  Its children are the game states that can result from making each valid move from the state <i>g</i>.</p>\r\n\r\n<p>The root of the tree is the initial game state &mdash; that is, the Othello game before the first move is made.  The children of this initial state are all of the possible states that can arise from the black player (who moves first) making a valid opening move.  There are four such states, corresponding to the four possible moves that the black player is permitted to make at the opening.  (All other moves are illegal and, as such, are not to be considered.)</p>\r\n\r\n<p>Here is a partial look at an Othello game tree:</p>\r\n\r\n<p class=\"center\"><img src=\"SearchTree.jpg\" /></p>\r\n\r\n<p>In the picture, from the initial state, there are four possibilies from which the black player can choose its initial move.  From the first of those, we see that there are three possible moves that the white player can make in response.  Other moves aren't pictured, but the tree continues to grow in this fashion.  (Not surprisingly, the game tree can grow large rather quickly, so you'll find that it's difficult to draw very much of it on paper.)</p>\r\n\r\n<p>We'll call the leaves in such a game tree the <i>final states</i>.  These leaves indicate the states in which one player or the other has won the game.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Exhaustively searching all possibilities</p>\r\n\r\n<p>Each time a player wants to pick a move, he or she wants to pick the one that will lead to a winning game state.  One algorithm for doing that would determine the best move in three steps:</p>\r\n\r\n<ol>\r\n  <li>We apply an <i>evaluation function</i> to each final game state.  An evaluation function typically returns a number, where higher numbers are considered better.  We then identify the final state with the highest value &mdash; that is the \"end game\" that we would like to occur, as it is the best win for us.</li>\r\n  <li>We determine the path from the current game state to the final state that we chose above.</li>\r\n  <li>We make the move that takes us from the current game state down the path toward the chosen final state.</li>\r\n</ol>\r\n\r\n<p>Assuming that you had a complete game tree at your disposal, this is a simple approach to implement.  However, practical limitations make this approach impossible.  First of all, the number of game states on each level of the tree grows exponentially as you work your way down the tree, since there are a number of possible moves that can be taken from any particular game state.  There simply won't be enough memory to store the entire game tree.  (You can imagine that, if you build the game tree 20 levels deep, and there are four possible moves that can be made from any particular state, the number of nodes in the tree would be greater than 4<sup>20</sup>, which is more than one quadrillion nodes!)  Besides, even if there were enough memory available to store the tree, the processing time to create the entire game tree would be prohibitive.</p>\r\n\r\n<p>So we'll need to find a compromise &mdash; an approach that perhaps doesn't always find the best possible outcome, but that makes a decision in a reasonable amount of time and using a reasonable amount of memory.</p>\r\n\r\n<p>Also, it's important to realize that just because you've found a path to the end game you want doesn't mean that you can force the events to take place that will get you there.  Just as your goal is to make moves that are in your best interest, your opponent's goal is the opposite.  So your algorithm will need to account for the fact that our opponent wants to beat you as much as you want to beat your opponent.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Heuristic search</p>\r\n\r\n<p>The study of artificial intelligence has much to say about good ways to search toward a goal when it's impractical to check all possible paths toward it.</p>\r\n\r\n<p>We can first make use of the following observation: Suppose the top player has made a move in the game, and the bottom player wants to figure out the best move to make, using the search tree approach we've been discussing.  Then the bottom player need only concern himself with the subtree that has the current game state as its root.  Once a move is made, all the other moves that could have been made can be ignored, as it is now not possible to take those paths down the tree.  Thus, when analyzing the next move to make, we need only generate the part of the search tree that originates from the current game state.  That's a good step toward reducing our storage needs significantly, though it's only the first step; especially early in the game, there might still be huge numbers of states that can arise from the state we're currently in.</p>\r\n\r\n<p>To reduce our workload even more, we can employ a technique called <i>heuristic search</i>.  In a heuristic search, we generate as much of the relevant subtree as is practical, using the resulting game states to guide us in selecting a move that we hope will be the best, even though we don't have time to get full information about how the move might turn out.</p>\r\n\r\n<p>There are several strategies that we could use.  At the heart of the strategy that we'll use is the notion of an <i>evaluation function</i> that we discussed earlier.  We'll need to rate each particular game state in some way, so that we can decide which of a large number of game states is the best outcome for us.  A simple approach &mdash; though one that ignores some important aspects of the game &mdash; is the following:</p>\r\n\r\n<p><i>eval(state) = number of tiles belonging to me &minus; number of tiles belonging to my opponent</i></p>\r\n\r\n<p>It's also important to note here that <i><b>you do not need to actually build a game tree in memory</b></i>.  Our algorithm will perform a sort of <i>depth-first search</i> on the game tree, meaning that we can use parameters in a recursive method (stored on the run-time stack) to perform the search, negating the need to actually build and store a game tree.  This will dramatically reduce the amount of memory needed to choose a move, since only one path in the tree will ever need to be stored on the run-time stack at a time.  So, in an eight-level-deep search, we'll store as many as eight nodes, rather than all of the nodes that can be reached in eight moves (which might be huge).</p>\r\n\r\n<p>Putting these ideas together, we can develop a search algorithm that will help us to evaluate each of the possible moves we might make.  That algorithm, sketched in a very rough pseudo-code, looks something like this:</p>\r\n\r\n<pre>\r\nint search(OthelloGameState s, int depth)\r\n{\r\n    if (depth == 0)\r\n        return evaluation of s\r\n    else\r\n    {\r\n        if (it's my turn to move)\r\n        {\r\n            for each valid move that I can make from s\r\n            {\r\n                make that move on s yielding a state s'\r\n                search(s', depth - 1)\r\n            }\r\n            \r\n            return the <i>maximum</i> value returned from recursive search calls\r\n        }\r\n        else\r\n        {\r\n            for each valid move that my opponent can make from s\r\n            {\r\n                make that move on s yielding a state s'\r\n                search(s', depth - 1)\r\n            }\r\n            \r\n            return the <i>minimum</i> value returned from recursive search calls\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<p>There are a few things we need to discuss about the algorithm above.  First, notice that there are two cases of recursion: either it is your algorithm's turn (who is currently making the decision) or its opponent's turn.  In each case, the algorithm is almost the same, except:</p>\r\n\r\n<ul>\r\n  <li>...when it is your algorithm's turn, the <i>maximum</i> value is returned.  In other words, the algorithm wants to make the best possible move it can on its own behalf.</li>\r\n  <li>...when it is the opponent's turn, the <i>minimum</i> value is returned.  This is because it is assumed that the opponent will also make the move that's in <i>its</i> best interest (which, in turn, is in our worst interest).</li>\r\n</ul>\r\n\r\n<p>You <i>may not</i> assume that your algorithm will always be the black or the white player.  Either the black or the white player (or both!) might be played by your algorithm.  When deciding whether it's \"my turn\" or \"my opponent's turn,\" you'll have to exercise some caution to ensure that you're making the right decision.</p>\r\n\r\n<p>Second, notice the <b>depth</b> parameter.  This will be used to limit the depth of our search, to make sure that our search does a manageable amount of work.  Each time we recurse one level deeper, the depth is reduced by one, and we stop recursing when it reaches zero.  You'll need to experiment a bit to decide what depth can be handled in a reasonable amount of time, but without limiting the depth, you'll find that moves will take orders of magnitude longer than you'll be willing to wait.</p>\r\n\r\n<p>Third, observe that when one player makes a move, it isn't necessarily the case that the other player will be making the next move; occasionally, in Othello, the same player gets to move twice in a row.  So, care must be taken in deciding whose turn it is.  The easiest way to deal with this problem is to count on the current game state to keep track of this for you; it can always tell you reliably whose turn it is.</p>\r\n\r\n<p>Lastly, note that this algorithm returns the <i>evaluation</i> of the best state, not the best state itself.  In short, calling search(<i>s</i>, 4) for some state <i>s</i> asks the following question: \"Looking four moves into the future, and assuming I do the best I can do and so does my opponent, how well will the state <i>s</i> turn out for me?\"  You'll need to exercise some care in actually implementing this algorithm so that chooseMove() will be able to call search() and use the result to help it choose the right move.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Evaluation functions</p>\r\n\r\n<p>The core of your AI &mdash; what will set it apart from others &mdash; is the evaluation function that it uses to decide how \"good\" each board configuration is.  I'm leaving this as an open problem and you're welcome to implement your evaluation function however you'd like.  You might want to poke around the web looking for strategy guides or other information, taking into account, for example, that some squares on the Othello board are considered more important than others.</p>\r\n\r\n<p>It's intended to be fun to play against your own program to see if you can beat it, and I also hope you enjoy fine-tuning your program until you have trouble beating it.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">A tournament!</p>\r\n\r\n<p>After the project's due date has passed, I'll be gathering all of your AIs together and running a tournament to determine who has the best AI.  In fairness, I'll explain here how the tournament will be organized; you'll need to follow these rules in order to win (or possibly even to participate).</p>\r\n\r\n<ul>\r\n  <li>You can submit as many AIs as you'd like, but do be sure that there's something interesting and different about them; don't submit ten AIs that are virtually identical, for example, because I'll need to run <i>O</i>(<i>a</i><sup><small>2</small></sup>) games to complete a tournament with <i>a</i> AIs.  That grows fast!</li>\r\n  <li>When you register your AIs with a name using the <b>ICS46_DYNAMIC_FACTORY_REGISTER</b> macro, the name you choose will be displayed in the final results posted to the web, so (a) make sure that you don't include your name unless you want your name posted online, and (b) choose names that are somehow unique to you &mdash; be clever (but inoffensive).</li>\r\n  <li>Each AI will play two games against each other AI, one each as black and as white.</li>\r\n  <li>The primary factor in determining the \"best\" AI is the total percentage of games won.  (Draws with count as 1/2 of a win and 1/2 of a loss.)  So, first and foremost, your goal is to win games.</li>\r\n  <li>A secondary factor, to be used in the case of a tie, is the total number of tiles accumulated in all games.  This means that winning games big, as opposed to squeaking out close wins, is important if there's a tie, but that winning small more often still trumps winning big less often.</li>\r\n  <li>Your AI will be given three seconds of CPU time to choose each of its moves.  (Note that <i>CPU time</i> is not a measurement of actual time passed, but only of time consumed by the CPU.  On the other hand, note that threads won't buy you any additional time, since four threads running simultaneously consume four times as much CPU as one thread does.)  The three seconds is a hard limit; as soon as your AI reaches this limit, it will be aborted immediately.\r\n    <ul>\r\n      <li>I'll run the tournament on a machine with these specs: Intel Core i7-4800MQ CPU 2.7 GHz, 24 GB RAM, Windows 7 Professional as the host operating system, with the ICS 46 VM running in A VirtualBox instance.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Your AI needs to be <i>stateless</i>.  It is entirely possible that different objects of your AI class will be called to choose different moves during the course of the same game, so you won't be able to save values in member variables and expect them to still be available the next time your AI chooses a move.</li>\r\n  <li>Your AI is not permitted to launch additional processes, though you can launch threads if you'd like.  (Note, though, that every thread can consume CPU time.)</li>\r\n  <li>If your AI takes too long to make a move, returns an invalid move, throws an exception, crashes, isn't implemented in a class <i>within a namespace named by your UCInetID</i>, or violates any of the other rules laid out in the project write-up, it will be disqualified from the tournament.\r\n    <ul>\r\n      <li>Ultimately, only games between AIs that completed the tournament without being disqualified are counted.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>The outcome of the tournament will have no bearing on your grade, but it will hopefully motivate you to think a bit about how you might tune up your evaluation function &mdash; or explore alternative ways of helping your AI to see farther into the future.  (You are required, fundamentally, to use the algorithm shown in this write-up to implement your \"required\" AI, though you can additionally do anything you'd like, and you can apply any optimizations to your required AI, provided that you're still basically implementing a recursive search tree based algorithm.)</li>\r\n\r\n<p>Good luck!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>After using the <b>gather</b> script in your project directory to gather up your C++ source and header files into a single <b>project2.tar.gz</b> file (as you did in <a href=\"../Project0\">Project #0</a>, submit that file (and only that file) to Checkmate.  Refer back to <a href=\"../Project0\">Project #0</a> if you need instructions on how to do that.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for a discussion of how to submit your project via Checkmate.  Be aware that I'll be holding you to all of the rules specified in that document, including the one that says that you're reponsible for submitting the version of the project that you want graded.  We won't regrade a project simply because you submitted the wrong version accidentally.  (It's not a bad idea to look at the contents of your tarball before submitting it; see <a href=\"../Project0\">Project #0</a> for instructions on how to do that.)</p>\r\n\r\n<p class=\"subtitle\">Can I submit after the deadline?</p>\r\n\r\n<p>Yes, it is possible, subject to the late work policy for this course, which is described in the section titled <i>Late work</i> at <a href=\"../index.html\">this link</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Originally written by Alex Thornton, Spring 2014, with heavy influence from a similarly-named project from ICS 23.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 16818.0}