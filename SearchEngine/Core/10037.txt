{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Templates The moniker for this code example is Templates Background In C the demands of the static type system sometimes seem to warrant copying and pasting functions or classes whose only differences are the types of their arguments member functions or member variables Consider for example a simple three line swap function that swaps a pair of integers void myswap int a int b int temp a a b b temp This function works wonderfully for two integers but doesn t work at all for values of any other type But when you consider what you d have to do to swap two doubles or two strings or two whatevers you realize that it could be done with exactly the same code with only the word int changed to something else in each place where it occurs For example a version of myswap that swaps two doubles instead of two ints might look like this void myswap double a double b double temp a a b b temp Because C allows function overloading i e two functions with the same name differentiated by the types of its arguments and or return value it will be legal to have both of these functions in the same program and the compiler will dutifully follow its overload resolution rules to determine which version to call in which circumstance In fact you could have ten twenty or a hundred of these functions that coexist all with the same names and differing only in the types of their arguments and temporary variable But why should we have to write the same function over and over again Wouldn t it be better if we could just write the function once then tell the compiler how to convert it from one version to another based on the types in use That s what template functions let you do They let you define the blueprint for an infinite set of possible functions in that blueprint you specify the ways that the different functions in the set would differ from each other and the ways that they would be the same In our case we might like to write a template function that demonstrates how to generate myswap implementations for each possible type of value I might want to swap which would be identical except for the types of their arguments and local variable Similarly we might have a set of similar classes that differ from each other only with respect to one or more types used throughout the class Data structure implementations like std vector are a good example of this C doesn t have a particularly usable notion of Any type can go here so a vector containing strings is a different type from a vector containing ints But rather than requiring a separate implementation of std vector for every different type of element we might like to store in one std vector is instead a template class which is a blueprint for an infinite set of possible classes in which we describe how the classes in the set differ from one another The devil as they say lies in the details but the idea is a simple one and the need is clear Let s talk about how to do this properly in C Template functions Writing a template function Writing a template function is actually quite simple Whenever we want to write a template we begin with the word template followed by a set of template parameters which are usually but not always types After this we write a function in just the same way we always write them except that we use the names of the template parameters to indicate the ways that different functions generated from our template are different So for example if we wanted to write our myswap function as a template function we would write this template typename T void myswap T t1 T t2 T temp t1 t1 t2 t2 temp The word template here means that we ve written a template function There isn t one myswap function there is a potentially infinite set of them which differ in terms of the template s parameters In this case there is one parameter the type of values being swapped The keyword typename establishes that the first parameter is a type as opposed to something else like an int constant and T in this case is a name used throughout the function to describe that type Instantiating a template function When you call a template function in a source file the C compiler stops to decide whether it s seen that use of the template function before For example imagine this source file void foo int i 3 int j 4 myswap i j At the point where myswap has been called the compiler realizes that this particular call to myswap would only make sense if the type T in the template was int because the parameters being passed are both of type int Standard C overloading rules apply so exact matches are favored over inexact ones If the compiler can t make a concrete determination we would have to specify the template argument ourselves but this turns out to be unnecessary for many template functions void foo int i 3 int j 4 myswap int i j legal but unnecessary in many cases when calling template functions So we now need the compiler to instantiate the template which is to say that we need it to generate an actual function from it where T int A template function describes a potentially infinite set of functions but none of those functions exists until we instantiate the template i e we call the function with a particular set of template parameters for the first time So at this point we need the compiler to actually compile the myswap template function with T int That means the entire body of the myswap template function not just its declaration but its definition needs to be available to the compiler For that reason we generally implement template functions in header files as opposed to source files except when we want to write a template function that is local to a particular source file Note that this means that there may ultimately be multiple definitions of the same template function in separate source files e g if two source files make calls to myswap int Fortunately C linkers allow this for templates and are able to handle it for us which is necessary for the template feature in C to actually work Constraints on template parameters As written the only explicit constraint on the type parameter T in myswap is that it s some type However there are constraints on what T is allowed to be implicitly arising from the things we do with T s inside of the function As we look at the function we can see that we do the following things with T s The line T temp t1 invokes T s copy constructor The lines t1 t2 and t2 temp invoke T s assignment operator Since temp is statically allocated T s destructor will be called on temp when the function ends So it will not be possible to instantiate our template function for any type T that doesn t have all three of these things a copy constructor an assignment operator and a destructor Defaults are fine if a type has a default Big Three they ll be used but types that lack these features will be disqualified It may sound strange but there are types in C that disallow some or all of these features For example we could declare the following class X with neither a copy constructor nor an assignment operator class X public X X const X x delete X operator const X x delete It would now be impossible to call myswap and pass it two X s because swapping them requires both a copy constructor and an assignment operator Template classes Consider again what classes are in C They are a blueprint for a kind of object specifying what information objects of that class store and how objects of that class behave As you ve no doubt seen previously C has an aggressive static type system requiring classes to be pretty specific about the types of data their objects work with This is with good reason a C compiler given a class declaration has to make decisions about things like object layout and the sizes of parameters being passed to functions all of which require knowing the specifics of the types involved It doesn t take much thinking to realize that classes might benefit from templates the same way that functions do C provides us the ability to write template classes which are a solution to a similar kind of problem A template class is a blueprint for a set of classes each of which becomes a distinct separate type The instantiations of a template class are similar in the sense that they all contain the same code with uses of template parameters replaced by something concrete but they aren t related by inheritance or in any other way unless you explicitly set them up that way and are fundamentally incompatible with each other Like template functions template classes take a set of template parameters that describe the things that make one instantiation of the template different from another Most of the time these are types once in a while constant values such as ints which might be used to specify things like a hard coded size limit on a data structure are used instead Data structure implementations are a common example where you see template classes used because how a data structure works is often quite separate from the kinds of objects stored within it std vector in the C Standard Library is a template class for exactly this reason a vector doesn t behave differently if it stores int objects than it does if it stores std string objects or Person objects or even pointers But it does allocate a different amount of memory for each cell in its underlying array each kind of vector allows only correctly typed values to be added into it and so on So std vector is a template class with a template parameter that specifies what type of value will be stored in each vector you create A std vector int is a vector that stores integers a std vector std string is a vector that stores strings and so on And while they re similar they re not compatible you can t assign a std vector std string into a std vector int or pass one as a parameter to a function expecting the other Writing a template class We write template classes in the same way that we write template functions we begin with the word template followed by the template s parameters listed between angle brackets and separated by commas So for example a class like the std vector class in the standard library might look something like this template typename ElementType class Vector where ElementType is a parameter used to describe the type of element being stored in a particular Vector Within the class declaration we would use ElementType whenever we want to specify The type of element being stored in this Vector rather than using something specific like int or std string Instantiating a template class Every time the compiler sees a new use of a template class with a set of template parameters that hasn t been used before in that source file it generates a new class on the fly including only the member functions that are actually being used on an object of that class which saves code size and also offers some flexibility as we ll see later As with template functions all of the code needs to be generated by the compiler when used so we typically implement template classes including definitions of member functions in header files so all of the code will be available to the compiler at the point where the template class is instantiated As with template functions there is no way to explicitly limit what the type ElementType is allowed to be though there is an implicit limitation brought about by the things you do to ElementType objects inside the class For example if we wrote this code in a member function in our Vector class ElementType e e foo then we d be introducing three constraints on ElementType It must be possible to default construct an ElementType i e ElementType has a constructor that takes no parameters ElementType has a destructor a necessity because the statically allocated variable e will be destroyed when it falls out of scope ElementType must have a member function foo that takes no parameters though there is no limitation on what its return type is since we re not doing anything with the return value This particular code example This code example demonstrates how to write a template class and how to write template functions that implement member functions of a template class The example is of a template class called Point which represents a point in a three dimensional space A point is made up of three coordinates x y and z but the types of these coordinates is flexible any given point can have coordinates of different types e g double int etc So Point is a template class with one parameter CoordinateType which specifies the type of each coordinate The code This code example briefly demonstrates how to write and instantiate template functions and template classes including writing their details in header files The official moniker for this code example is Templates so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code Templates to download the code example into your project directory s app directory Alternatively you can click the link to the tarball below Templates tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/Templates/", "title": "ics 45c fall 2014, code example: classes", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Classes</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Templates</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>Templates</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>In C++, the demands of the static type system sometimes seem to warrant copying and pasting functions or classes whose only differences are the types of their arguments, member functions, or member variables.  Consider, for example, a simple three-line swap function that swaps a pair of integers.</p>\r\n\r\n<blockquote><pre>\r\nvoid myswap(int& a, int& b)\r\n{\r\n    int temp = a;\r\n    a = b;\r\n    b = temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>This function works wonderfully for two integers, but doesn't work at all for values of any other type.  But when you consider what you'd have to do to swap two doubles or two strings or two whatevers, you realize that it could be done with <i>exactly</i> the same code, with only the word <b>int</b> changed to something else in each place where it occurs.  For example, a version of <b>myswap</b> that swaps two doubles instead of two ints might look like this.</p>\r\n\r\n<blockquote><pre>\r\nvoid myswap(double& a, double& b)\r\n{\r\n    double temp = a;\r\n    a = b;\r\n    b= temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Because C++ allows <i>function overloading</i> (i.e., two functions with the same name, differentiated by the types of its arguments and/or return value), it will be legal to have both of these functions in the same program, and the compiler will dutifully follow its overload resolution rules to determine which version to call in which circumstance.  In fact, you could have ten, twenty, or a hundred of these functions that coexist, all with the same names and differing only in the types of their arguments and temporary variable.</p>\r\n\r\n<p>But why should we have to write the same function over and over again?  Wouldn't it be better if we could just write the function once, then tell the compiler how to convert it from one version to another based on the types in use?</p>\r\n\r\n<p>That's what <i>template functions</i> let you do.  They let you define the blueprint for an infinite set of possible functions; in that blueprint, you specify the ways that the different functions in the set would differ from each other and the ways that they would be the same.  In our case, we might like to write a template function that demonstrates how to generate <b>myswap</b> implementations for each possible type of value I might want to swap, which would be identical except for the types of their arguments and local variable.</p>\r\n\r\n<p>Similarly, we might have a set of similar classes that differ from each other only with respect to one or more types used throughout the class.  Data structure implementations like <b>std::vector</b> are a good example of this; C++ doesn't have a (particularly usable) notion of \"Any type can go here,\" so a vector containing strings is a different type from a vector containing ints.  But rather than requiring a separate implementation of <b>std::vector</b> for every different type of element we might like to store in one, <b>std::vector</b> is instead a <i>template class</i>, which is a blueprint for an infinite set of possible classes, in which we describe how the classes in the set differ from one another.</p>\r\n\r\n<p>The devil, as they say, lies in the details, but the idea is a simple one, and the need is clear.  Let's talk about how to do this properly in C++.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Template functions</p>\r\n\r\n<p class=\"subtitle\">Writing a template function</p>\r\n\r\n<p>Writing a template function is actually quite simple.  Whenever we want to write a template, we begin with the word <b>template</b>, followed by a set of template parameters (which are usually, but not always, types).  After this, we write a function in just the same way we always write them, except that we use the names of the template parameters to indicate the ways that different functions generated from our template are different.</p>\r\n\r\n<p>So, for example, if we wanted to write our <b>myswap</b> function as a template function, we would write this:</p>\r\n\r\n<blockquote><pre>\r\ntemplate &lt;typename T&gt;\r\nvoid myswap(T& t1, T& t2)\r\n{\r\n    T temp = t1;\r\n    t1 = t2;\r\n    t2 = temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The word <b>template</b> here means that we've written a template function.  There isn't one <b>myswap</b> function; there is a potentially infinite set of them, which differ in terms of the template's parameters.  In this case, there is one parameter, the type of values being swapped.  The keyword <b>typename</b> establishes that the first parameter is a type &mdash; as opposed to something else, like an <b>int</b> constant &mdash; and <b>T</b>, in this case, is a name used throughout the function to describe that type.</p>\r\n\r\n<p class=\"subtitle\">Instantiating a template function</p>\r\n\r\n<p>When you call a template function in a source file, the C++ compiler stops to decide whether it's seen that use of the template function before.  For example, imagine this source file:</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int i = 3;\r\n    int j = 4;\r\n    myswap(i, j);\r\n}\r\n</pre></blockquote>\r\n\r\n<p>At the point where <b>myswap</b> has been called, the compiler realizes that this particular call to <b>myswap</b> would only make sense if the type <b>T</b> in the template was <b>int</b>, because the parameters being passed are both of type <b>int</b>.  (Standard C++ overloading rules apply, so exact matches are favored over inexact ones.)  If the compiler can't make a concrete determination, we would have to specify the template argument ourselves, but this turns out to be unnecessary for many template functions:</li>\r\n</ul>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int i = 3;\r\n    int j = 4;\r\n    myswap&lt;int&gt;(i, j);   // legal, but unnecessary in many cases when calling template functions\r\n}\r\n</pre></blockquote>\r\n\r\n<p>So we now need the compiler to <i>instantiate</i> the template, which is to say that we need it to generate an actual function from it, where <b>T</b> = <b>int</b>.  A template function describes a potentially infinite set of functions, but none of those functions exists until we instantiate the template (i.e., we call the function with a particular set of template parameters for the first time).</p>\r\n\r\n<p>So, at this point, we need the compiler to actually compile the <b>myswap</b> template function with <b>T</b> = <b>int</b>.  That means the entire body of the <b>myswap</b> template function &mdash; not just its declaration, but its definition &mdash; needs to be available to the compiler.  For that reason, we generally implement template functions in header files as opposed to source files &mdash; except when we want to write a template function that is \"local\" to a particular source file.</p>\r\n\r\n<p>Note that this means that there may ultimately be multiple definitions of the same template function in separate source files (e.g., if two source files make calls to <b>myswap&lt;int&gt;</b>).  Fortunately, C++ linkers allow this for templates and are able to handle it for us, which is necessary for the template feature in C++ to actually work.</p>\r\n\r\n<p class=\"subtitle\">Constraints on template parameters</p>\r\n\r\n<p>As written, the only explicit constraint on the type parameter <b>T</b> in <b>myswap</b> is that it's some type.  However, there are constraints on what <b>T</b> is allowed to be, implicitly arising from the things we do with <b>T</b>'s inside of the function.  As we look at the function, we can see that we do the following things with <b>T</b>'s:</p>\r\n\r\n<ul>\r\n  <li>The line <b>T temp = t1;</b> invokes T's copy constructor.</li>\r\n  <li>The lines <b>t1 = t2;</b> and <b>t2 = temp;</b> invoke T's assignment operator.</li>\r\n  <li>Since <b>temp</b> is statically-allocated, <b>T</b>'s destructor will be called on <b>temp</b> when the function ends.</li>\r\n</ul>\r\n\r\n<p>So it will not be possible to instantiate our template function for any type <b>T</b> that doesn't have all three of these things: a copy constructor, an assignment operator, and a destructor.  Defaults are fine &mdash; if a type has a default \"Big Three\", they'll be used &mdash; but types that lack these features will be disqualified.  It may sound strange, but there are types in C++ that disallow some or all of these features.  For example, we could declare the following class <b>X</b> with neither a copy constructor nor an assignment operator.</p>\r\n\r\n<blockquote><pre>\r\nclass X\r\n{\r\npublic:\r\n    X();\r\n    X(const X& x) = delete;\r\n    X& operator=(const X& x) = delete;\r\n};\r\n</pre></blockquote>\r\n\r\n<p>It would now be impossible to call <b>myswap</b> and pass it two <b>X</b>'s, because swapping them requires both a copy constructor and an assignment operator.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Template classes</p>\r\n\r\n<p>Consider again what classes are in C++.  They are a blueprint for a kind of object, specifying what information objects of that class store and how objects of that class behave.  As you've no doubt seen previously, C++ has an aggressive static type system, requiring classes to be pretty specific about the types of data their objects work with.  This is with good reason: a C++ compiler, given a class declaration, has to make decisions about things like object layout and the sizes of parameters being passed to functions, all of which require knowing the specifics of the types involved.</p>\r\n\r\n<p>It doesn't take much thinking to realize that classes might benefit from templates the same way that functions do.  C++ provides us the ability to write <i>template classes</i>, which are a solution to a similar kind of problem.  A template class is a blueprint for a set of classes, each of which becomes a distinct, separate type.  The instantiations of a template class are similar in the sense that they all contain the same code (with uses of template parameters replaced by something concrete), but they aren't related by inheritance &mdash; or in any other way, unless you explicitly set them up that way &mdash; and are fundamentally incompatible with each other.</p>\r\n\r\n<p>Like template functions, template classes take a set of template parameters that describe the things that make one instantiation of the template different from another.  Most of the time, these are types: once in a while, constant values &mdash; such as ints, which might be used to specify things like a hard-coded size limit on a data structure &mdash; are used instead.  Data structure implementations are a common example where you see template classes used, because how a data structure works is often quite separate from the kinds of objects stored within it.  <b>std::vector</b> in the C++ Standard Library is a template class for exactly this reason; a vector doesn't behave differently if it stores <b>int</b> objects than it does if it stores <b>std::string</b> objects or <b>Person</b> objects or even pointers.  But it does allocate a different amount of memory for each cell in its underlying array, each kind of vector allows only correctly-typed values to be added into it, and so on.  So <b>std::vector</b> is a template class, with a template parameter that specifies what type of value will be stored in each vector you create.  A <b>std::vector&lt;int&gt;</b> is a vector that stores integers; a <b>std::vector&lt;std::string&gt;</b> is a vector that stores strings; and so on.  And while they're similar, they're not compatible; you can't assign a <b>std::vector&lt;std::string&gt;</b> into a <b>std::vector&lt;int&gt;</b>, or pass one as a parameter to a function expecting the other.</p>\r\n\r\n<p class=\"subtitle\">Writing a template class</p>\r\n\r\n<p>We write template classes in the same way that we write template functions: we begin with the word <b>template</b>, followed by the template's parameters listed between angle brackets and separated by commas.  So, for example, a class like the <b>std::vector</b> class in the standard library might look something like this:</p>\r\n\r\n<blockquote><pre>\r\ntemplate &lt;typename ElementType&gt;\r\nclass Vector\r\n{\r\n    ...\r\n};\r\n</pre></blockquote>\r\n\r\n<p>where <b>ElementType</b> is a parameter used to describe the type of element being stored in a particular <b>Vector</b>.  Within the class declaration, we would use <b>ElementType</b> whenever we want to specify \"The type of element being stored in this Vector,\" rather than using something specific like <b>int</b> or <b>std::string</b>.</p>\r\n\r\n<p class=\"subtitle\">Instantiating a template class</p>\r\n\r\n<p>Every time the compiler sees a new use of a template class &mdash; with a set of template parameters that hasn't been used before in that source file &mdash; it generates a new class on the fly, including only the member functions that are actually being used on an object of that class (which saves code size and also offers some flexibility, as we'll see later).  As with template functions, all of the code needs to be generated by the compiler when used, so we typically implement template classes, including definitions of member functions, in header files, so all of the code will be available to the compiler at the point where the template class is instantiated.</p>\r\n\r\n<p>As with template functions, there is no way to explicitly limit what the type <b>ElementType</b> is allowed to be, though there is an implicit limitation brought about by the things you do to <b>ElementType</b> objects inside the class.  For example, if we wrote this code in a member function in our <b>Vector</b> class:</p>\r\n\r\n<blockquote><pre>\r\nElementType e;\r\ne.foo();\r\n</pre></blockquote>\r\n\r\n<p>then we'd be introducing three constraints on <b>ElementType</b>:</p>\r\n\r\n<ul>\r\n  <li>It must be possible to default-construct an <b>ElementType</b> (i.e., <b>ElementType</b> has a constructor that takes no parameters).</li>\r\n  <li><b>ElementType</b> has a destructor &mdash; a necessity because the statically-allocated variable <b>e</b> will be destroyed when it falls out of scope.</li>\r\n  <li><b>ElementType</b> must have a member function <b>foo</b> that takes no parameters, though there is no limitation on what its return type is (since we're not doing anything with the return value).</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">This particular code example</p>\r\n\r\n<p>This code example demonstrates how to write a template class, and how to write template functions that implement member functions of a template class.  The example is of a template class called <b>Point</b>, which represents a point in a three-dimensional space.  A point is made up of three coordinates (<i>x</i>, <i>y</i>, and <i>z</i>), but the types of these coordinates is flexible; any given point can have coordinates of different types (e.g., <b>double</b>, <b>int</b>, etc.).  So <b>Point</b> is a template class with one parameter, <b>CoordinateType</b>, which specifies the type of each coordinate.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>This code example briefly demonstrates how to write and instantiate template functions and template classes, including writing their details in header files.</p>\r\n\r\n<p>The official moniker for this code example is <b>Templates</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code Templates</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"Templates.tar.gz\">Templates.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 10037.0}