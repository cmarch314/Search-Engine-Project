{"text": "Content type text html TCPDUMPSection Maintenance Commands 8 Updated 3 June 1997Index Return to Main Contents NAMEtcpdump dump traffic on a network SYNOPSIStcpdump adeflnNOpqStvx c count F file i interface r file s snaplen T type w file expression DESCRIPTION Tcpdump prints out the headers of packets on a network interface that match the boolean expression Under SunOS with nit or bpf To run tcpdump you must have read access to dev nit or dev bpf Under Solaris with dlpi You must have read access to the network pseudo device e g dev le Under HP UX with dlpi You must be root or it must be installed setuid to root Under IRIX with snoop You must be root or it must be installed setuid to root Under Linux You must be root or it must be installed setuid to root Under Ultrix and Digital UNIX Once the super user has enabled promiscuous mode operation using pfconfig 8 any user may run tcpdump Under BSD You must have read access to dev bpf OPTIONS a Attempt to convert network and broadcast addresses to names c Exit after receiving count packets d Dump the compiled packet matching code in a human readable form to standard output and stop dd Dump packet matching code as a C program fragment ddd Dump packet matching code as decimal numbers preceded with a count e Print the link level header on each dump line f Print foreign internet addresses numerically rather than symbolically this option is intended to get around serious brain damage in Sun s yp server usually it hangs forever translating non local internet numbers F Use file as input for the filter expression An additional expression given on the command line is ignored i Listen on interface If unspecified tcpdump searches the system interface list for the lowest numbered configured up interface excluding loopback Ties are broken by choosing the earliest match l Make stdout line buffered Useful if you want to see the data while capturing it E g tcpdump l tee dat or tcpdump l dat tail f dat n Don t convert addresses i e host addresses port numbers etc to names N Don t print domain name qualification of host names E g if you give this flag then tcpdump will print nic instead of nic ddn mil O Do not run the packet matching code optimizer This is useful only if you suspect a bug in the optimizer p Don t put the interface into promiscuous mode Note that the interface might be in promiscuous mode for some other reason hence p cannot be used as an abbreviation for ether host local hw addr or ether broadcast q Quick quiet output Print less protocol information so output lines are shorter r Read packets from file which was created with the w option Standard input is used if file is s Snarf snaplen bytes of data from each packet rather than the default of 68 with SunOS s NIT the minimum is actually 96 68 bytes is adequate for IP ICMP TCP and UDP but may truncate protocol information from name server and NFS packets see below Packets truncated because of a limited snapshot are indicated in the output with proto where proto is the name of the protocol level at which the truncation has occurred Note that taking larger snapshots both increases the amount of time it takes to process packets and effectively decreases the amount of packet buffering This may cause packets to be lost You should limit snaplen to the smallest number that will capture the protocol information you re interested in T Force packets selected by expression to be interpreted the specified type Currently known types are rpc Remote Procedure Call rtp Real Time Applications protocol rtcp Real Time Applications control protocol vat Visual Audio Tool wb distributed White Board and snmp Simple Network Management Protocol S Print absolute rather than relative TCP sequence numbers t Don t print a timestamp on each dump line tt Print an unformatted timestamp on each dump line v Slightly more verbose output For example the time to live and type of service information in an IP packet is printed vv Even more verbose output For example additional fields are printed from NFS reply packets w Write the raw packets to file rather than parsing and printing them out They can later be printed with the r option Standard output is used if file is x Print each packet minus its link level header in hex The smaller of the entire packet or snaplen bytes will be printed expression selects which packets will be dumped If no expression is given all packets on the net will be dumped Otherwise only packets for which expression is true will be dumped The expression consists of one or more primitives Primitives usually consist of an id name or number preceded by one or more qualifiers There are three different kinds of qualifier type qualifiers say what kind of thing the id name or number refers to Possible types are host net and port E g host foo net 128 3 port 2 If there is no type qualifier host is assumed dir qualifiers specify a particular transfer direction to and or from id Possible directions are src dst src or dst and src and dst E g src foo dst net 128 3 src or dst port ftp data If there is no dir qualifier src or dst is assumed For null link layers i e point to point protocols such as slip the inbound and outbound qualifiers can be used to specify a desired direction proto qualifiers restrict the match to a particular protocol Possible protos are ether fddi ip arp rarp decnet lat sca moprc mopdl tcp and udp E g ether src foo arp net 128 3 tcp port 21 If there is no proto qualifier all protocols consistent with the type are assumed E g src foo means ip or arp or rarp src foo except the latter is not legal syntax net bar means ip or arp or rarp net bar and port 53 means tcp or udp port 53 fddi is actually an alias for ether the parser treats them identically as meaning the data link level used on the specified network interface FDDI headers contain Ethernet like source and destination addresses and often contain Ethernet like packet types so you can filter on these FDDI fields just as with the analogous Ethernet fields FDDI headers also contain other fields but you cannot name them explicitly in a filter expression In addition to the above there are some special primitive keywords that don t follow the pattern gateway broadcast less greater and arithmetic expressions All of these are described below More complex filter expressions are built up by using the words and or and not to combine primitives E g host foo and not port ftp and not port ftp data To save typing identical qualifier lists can be omitted E g tcp dst port ftp or ftp data or domain is exactly the same as tcp dst port ftp or tcp dst port ftp data or tcp dst port domain Allowable primitives are dst host host True if the IP destination field of the packet is host which may be either an address or a name src host host True if the IP source field of the packet is host host host True if either the IP source or destination of the packet is host Any of the above host expressions can be prepended with the keywords ip arp or rarp as in ip host host which is equivalent to ether proto ip and host host If host is a name with multiple IP addresses each address will be checked for a match ether dst ehost True if the ethernet destination address is ehost Ehost may be either a name from etc ethers or a number see ethers 3N for numeric format ether src ehost True if the ethernet source address is ehost ether host ehost True if either the ethernet source or destination address is ehost gateway host True if the packet used host as a gateway I e the ethernet source or destination address was host but neither the IP source nor the IP destination was host Host must be a name and must be found in both etc hosts and etc ethers An equivalent expression is ether host ehost and not host host which can be used with either names or numbers for host ehost dst net net True if the IP destination address of the packet has a network number of net Net may be either a name from etc networks or a network number see networks 4 for details src net net True if the IP source address of the packet has a network number of net net net True if either the IP source or destination address of the packet has a network number of net net net mask mask True if the IP address matches net with the specific netmask May be qualified with src or dst net net len True if the IP address matches net a netmask len bits wide May be qualified with src or dst dst port port True if the packet is ip tcp or ip udp and has a destination port value of port The port can be a number or a name used in etc services see tcp 4P and udp 4P If a name is used both the port number and protocol are checked If a number or ambiguous name is used only the port number is checked e g dst port 513 will print both tcp login traffic and udp who traffic and port domain will print both tcp domain and udp domain traffic src port port True if the packet has a source port value of port port port True if either the source or destination port of the packet is port Any of the above port expressions can be prepended with the keywords tcp or udp as in tcp src port port which matches only tcp packets whose source port is port less length True if the packet has a length less than or equal to length This is equivalent to len length greater length True if the packet has a length greater than or equal to length This is equivalent to len length ip proto protocol True if the packet is an ip packet see ip 4P of protocol type protocol Protocol can be a number or one of the names icmp igrp udp nd or tcp Note that the identifiers tcp udp and icmp are also keywords and must be escaped via backslash which is in the C shell ether broadcast True if the packet is an ethernet broadcast packet The ether keyword is optional ip broadcast True if the packet is an IP broadcast packet It checks for both the all zeroes and all ones broadcast conventions and looks up the local subnet mask ether multicast True if the packet is an ethernet multicast packet The ether keyword is optional This is shorthand for ether 1 ip multicast True if the packet is an IP multicast packet ether proto protocol True if the packet is of ether type protocol Protocol can be a number or a name like ip arp or rarp Note these identifiers are also keywords and must be escaped via backslash In the case of FDDI e g fddi protocol arp the protocol identification comes from the 8 2 2 Logical Link Control LLC header which is usually layered on top of the FDDI header Tcpdump assumes when filtering on the protocol identifier that all FDDI packets include an LLC header and that the LLC header is in so called SNAP format decnet src host True if the DECNET source address is host which may be an address of the form 1 123 or a DECNET host name DECNET host name support is only available on Ultrix systems that are configured to run DECNET decnet dst host True if the DECNET destination address is host decnet host host True if either the DECNET source or destination address is host ip arp rarp decnet Abbreviations for ether proto p where p is one of the above protocols lat moprc mopdl Abbreviations for ether proto p where p is one of the above protocols Note that tcpdump does not currently know how to parse these protocols tcp udp icmp Abbreviations for ip proto p where p is one of the above protocols expr relop expr True if the relation holds where relop is one of and expr is an arithmetic expression composed of integer constants expressed in standard C syntax the normal binary operators a length operator and special packet data accessors To access data inside the packet use the following syntax proto expr size Proto is one of ether fddi ip arp rarp tcp udp or icmp and indicates the protocol layer for the index operation The byte offset relative to the indicated protocol layer is given by expr Size is optional and indicates the number of bytes in the field of interest it can be either one two or four and defaults to one The length operator indicated by the keyword len gives the length of the packet For example ether 1 catches all multicast traffic The expression ip xf 5 catches all IP packets with options The expression ip 6 2 x1fff catches only unfragmented datagrams and frag zero of fragmented datagrams This check is implicitly applied to the tcp and udp index operations For instance tcp always means the first byte of the TCP header and never means the first byte of an intervening fragment Primitives may be combined using A parenthesized group of primitives and operators parentheses are special to the Shell and must be escaped Negation or not Concatenation or and Alternation or or Negation has highest precedence Alternation and concatenation have equal precedence and associate left to right Note that explicit and tokens not juxtaposition are now required for concatenation If an identifier is given without a keyword the most recent keyword is assumed For example not host vs and ace is short for not host vs and host ace which should not be confused with not host vs or ace Expression arguments can be passed to tcpdump as either a single argument or as multiple arguments whichever is more convenient Generally if the expression contains Shell metacharacters it is easier to pass it as a single quoted argument Multiple arguments are concatenated with spaces before being parsed EXAMPLES To print all packets arriving at or departing from sundown tcpdump host sundown To print traffic between helios and either hot or ace tcpdump host helios and hot or ace To print all IP packets between ace and any host except helios tcpdump ip host ace and not helios To print all traffic between local hosts and hosts at Berkeley tcpdump net ucb ether To print all ftp traffic through internet gateway snup note that the expression is quoted to prevent the shell from mis interpreting the parentheses tcpdump gateway snup and port ftp or ftp data To print traffic neither sourced from nor destined for local hosts if you gateway to one other net this stuff should never make it onto your local net tcpdump ip and not net localnet To print the start and end packets the SYN and FIN packets of each TCP conversation that involves a non local host tcpdump tcp 13 3 and not src and dst net localnet To print IP packets longer than 576 bytes sent through gateway snup tcpdump gateway snup and ip 2 2 576 To print IP broadcast or multicast packets that were not sent via ethernet broadcast or multicast tcpdump ether 1 and ip 16 224 To print all ICMP packets that are not echo requests replies i e not ping packets tcpdump icmp 8 and icmp OUTPUT FORMAT The output of tcpdump is protocol dependent The following gives a brief description and examples of most of the formats Link Level Headers If the e option is given the link level header is printed out On ethernets the source and destination addresses protocol and packet length are printed On FDDI networks the e option causes tcpdump to print the frame control field the source and destination addresses and the packet length The frame control field governs the interpretation of the rest of the packet Normal packets such as those containing IP datagrams are async packets with a priority value between and 7 for example async4 Such packets are assumed to contain an 8 2 2 Logical Link Control LLC packet the LLC header is printed if it is not an ISO datagram or a so called SNAP packet N B The following description assumes familiarity with the SLIP compression algorithm described in RFC 1144 On SLIP links a direction indicator I for inbound O for outbound packet type and compression information are printed out The packet type is printed first The three types are ip utcp and ctcp No further link information is printed for ip packets For TCP packets the connection identifier is printed following the type If the packet is compressed its encoded header is printed out The special cases are printed out as S n and SA n where n is the amount by which the sequence number or sequence number and ack has changed If it is not a special case zero or more changes are printed A change is indicated by U urgent pointer W window A ack S sequence number and I packet ID followed by a delta n or n or a new value n Finally the amount of data in the packet and compressed header length are printed For example the following line shows an outbound compressed TCP packet with an implicit connection identifier the ack has changed by 6 the sequence number by 49 and the packet ID by 6 there are 3 bytes of data and 6 bytes of compressed header O ctcp A 6 S 49 I 6 3 6 ARP RARP Packets Arp rarp output shows the type of request and its arguments The format is intended to be self explanatory Here is a short sample taken from the start of an rlogin from host rtsg to host csam arp who has csam tell rtsg arp reply csam is at CSAM The first line says that rtsg sent an arp packet asking for the ethernet address of internet host csam Csam replies with its ethernet address in this example ethernet addresses are in caps and internet addresses in lower case This would look less redundant if we had done tcpdump n arp who has 128 3 254 6 tell 128 3 254 68 arp reply 128 3 254 6 is at 2 7 1 1 c4 If we had done tcpdump e the fact that the first packet is broadcast and the second is point to point would be visible RTSG Broadcast 8 6 64 arp who has csam tell rtsg CSAM RTSG 8 6 64 arp reply csam is at CSAM For the first packet this says the ethernet source address is RTSG the destination is the ethernet broadcast address the type field contained hex 8 6 type ETHER ARP and the total length was 64 bytes TCP Packets N B The following description assumes familiarity with the TCP protocol described in RFC 793 If you are not familiar with the protocol neither this description nor tcpdump will be of much use to you The general format of a tcp protocol line is src dst flags data seqno ack window urgent options Src and dst are the source and destination IP addresses and ports Flags are some combination of S SYN F FIN P PUSH or R RST or a single no flags Data seqno describes the portion of sequence space covered by the data in this packet see example below Ack is sequence number of the next data expected the other direction on this connection Window is the number of bytes of receive buffer space available the other direction on this connection Urg indicates there is urgent data in the packet Options are tcp options enclosed in angle brackets e g mss 1 24 Src dst and flags are always present The other fields depend on the contents of the packet s tcp protocol header and are output only if appropriate Here is the opening portion of an rlogin from host rtsg to host csam rtsg 1 23 csam login S 768512 768512 win 4 96 mss 1 24 csam login rtsg 1 23 S 947648 947648 ack 768513 win 4 96 mss 1 24 rtsg 1 23 csam login ack 1 win 4 96 rtsg 1 23 csam login P 1 2 1 ack 1 win 4 96 csam login rtsg 1 23 ack 2 win 4 96 rtsg 1 23 csam login P 2 21 19 ack 1 win 4 96 csam login rtsg 1 23 P 1 2 1 ack 21 win 4 77 csam login rtsg 1 23 P 2 3 1 ack 21 win 4 77 urg 1 csam login rtsg 1 23 P 3 4 1 ack 21 win 4 77 urg 1 The first line says that tcp port 1 23 on rtsg sent a packet to port login on csam The S indicates that the SYN flag was set The packet sequence number was 768512 and it contained no data The notation is first last nbytes which means sequence numbers first up to but not including last which is nbytes bytes of user data There was no piggy backed ack the available receive window was 4 96 bytes and there was a max segment size option requesting an mss of 1 24 bytes Csam replies with a similar packet except it includes a piggy backed ack for rtsg s SYN Rtsg then acks csam s SYN The means no flags were set The packet contained no data so there is no data sequence number Note that the ack sequence number is a small integer 1 The first time tcpdump sees a tcp conversation it prints the sequence number from the packet On subsequent packets of the conversation the difference between the current packet s sequence number and this initial sequence number is printed This means that sequence numbers after the first can be interpreted as relative byte positions in the conversation s data stream with the first data byte each direction being 1 S will override this feature causing the original sequence numbers to be output On the 6th line rtsg sends csam 19 bytes of data bytes 2 through 2 in the rtsg csam side of the conversation The PUSH flag is set in the packet On the 7th line csam says it s received data sent by rtsg up to but not including byte 21 Most of this data is apparently sitting in the socket buffer since csam s receive window has gotten 19 bytes smaller Csam also sends one byte of data to rtsg in this packet On the 8th and 9th lines csam sends two bytes of urgent pushed data to rtsg If the snapshot was small enough that tcpdump didn t capture the full TCP header it interprets as much of the header as it can and then reports tcp to indicate the remainder could not be interpreted If the header contains a bogus option one with a length that s either too small or beyond the end of the header tcpdump reports it as bad opt and does not interpret any further options since it s impossible to tell where they start If the header length indicates options are present but the IP datagram length is not long enough for the options to actually be there tcpdump reports it as bad hdr length UDP Packets UDP format is illustrated by this rwho packet actinide who broadcast who udp 84 This says that port who on host actinide sent a udp datagram to port who on host broadcast the Internet broadcast address The packet contained 84 bytes of user data Some UDP services are recognized from the source or destination port number and the higher level protocol information printed In particular Domain Name service requests RFC 1 34 1 35 and Sun RPC calls RFC 1 5 to NFS UDP Name Server Requests N B The following description assumes familiarity with the Domain Service protocol described in RFC 1 35 If you are not familiar with the protocol the following description will appear to be written in greek Name server requests are formatted as src dst id op flags qtype qclass name len h2opolo 1538 helios domain 3 A ucbvax berkeley edu 37 Host h2opolo asked the domain server on helios for an address record qtype A associated with the name ucbvax berkeley edu The query id was 3 The indicates the recursion desired flag was set The query length was 37 bytes not including the UDP and IP protocol headers The query operation was the normal one Query so the op field was omitted If the op had been anything else it would have been printed between the 3 and the Similarly the qclass was the normal one C IN and omitted Any other qclass would have been printed immediately after the A A few anomalies are checked and may result in extra fields enclosed in square brackets If a query contains an answer name server or authority section ancount nscount or arcount are printed as na nn or nau where n is the appropriate count If any of the response bits are set AA RA or rcode or any of the must be zero bits are set in bytes two and three b2 3 x is printed where x is the hex value of header bytes two and three UDP Name Server Responses Name server responses are formatted as src dst id op rcode flags a n au type class data len helios domain h2opolo 1538 3 3 3 7 A 128 32 137 3 273 helios domain h2opolo 1537 2 NXDomain 1 97 In the first example helios responds to query id 3 from h2opolo with 3 answer records 3 name server records and 7 authority records The first answer record is type A address and its data is internet address 128 32 137 3 The total size of the response was 273 bytes excluding UDP and IP headers The op Query and response code NoError were omitted as was the class C IN of the A record In the second example helios responds to query 2 with a response code of non existent domain NXDomain with no answers one name server and no authority records The indicates that the authoritative answer bit was set Since there were no answers no type class or data were printed Other flag characters that might appear are recursion available RA not set and truncated message TC set If the question section doesn t contain exactly one entry nq is printed Note that name server requests and responses tend to be large and the default snaplen of 68 bytes may not capture enough of the packet to print Use the s flag to increase the snaplen if you need to seriously investigate name server traffic s 128 has worked well for me NFS Requests and Replies Sun NFS Network File System requests and replies are printed as src xid dst nfs len op args src nfs dst xid reply stat len op results sushi 67 9 wrl nfs 112 readlink fh 21 24 1 73165 wrl nfs sushi 67 9 reply ok 4 readlink var sushi 2 1b wrl nfs 144 lookup fh 9 74 4 96 6878 xcolors wrl nfs sushi 2 1b reply ok 128 lookup fh 9 74 4134 315 In the first line host sushi sends a transaction with id 67 9 to wrl note that the number following the src host is a transaction id not the source port The request was 112 bytes excluding the UDP and IP headers The operation was a readlink read symbolic link on file handle fh 21 24 1 731657119 If one is lucky as in this case the file handle can be interpreted as a major minor device number pair followed by the inode number and generation number Wrl replies ok with the contents of the link In the third line sushi asks wrl to lookup the name xcolors in directory file 9 74 4 96 6878 Note that the data printed depends on the operation type The format is intended to be self explanatory if read in conjunction with an NFS protocol spec If the v verbose flag is given additional information is printed For example sushi 1372a wrl nfs 148 read fh 21 11 12 195 8192 bytes 24576 wrl nfs sushi 1372a reply ok 1472 read REG 1 664 ids 417 sz 29388 v also prints the IP header TTL ID and fragmentation fields which have been omitted from this example In the first line sushi asks wrl to read 8192 bytes from file 21 11 12 195 at byte offset 24576 Wrl replies ok the packet shown on the second line is the first fragment of the reply and hence is only 1472 bytes long the other bytes will follow in subsequent fragments but these fragments do not have NFS or even UDP headers and so might not be printed depending on the filter expression used Because the v flag is given some of the file attributes which are returned in addition to the file data are printed the file type REG for regular file the file mode in octal the uid and gid and the file size If the v flag is given more than once even more details are printed Note that NFS requests are very large and much of the detail won t be printed unless snaplen is increased Try using s 192 to watch NFS traffic NFS reply packets do not explicitly identify the RPC operation Instead tcpdump keeps track of recent requests and matches them to the replies using the transaction ID If a reply does not closely follow the corresponding request it might not be parsable KIP Appletalk DDP in UDP Appletalk DDP packets encapsulated in UDP datagrams are de encapsulated and dumped as DDP packets i e all the UDP header information is discarded The file etc atalk names is used to translate appletalk net and node numbers to names Lines in this file have the form number name 1 254 ether 16 1 icsd net 1 254 11 ace The first two lines give the names of appletalk networks The third line gives the name of a particular host a host is distinguished from a net by the 3rd octet in the number a net number must have two octets and a host number must have three octets The number and name should be separated by whitespace blanks or tabs The etc atalk names file may contain blank lines or comment lines lines starting with a Appletalk addresses are printed in the form net host port 144 1 2 9 2 icsd net 112 22 office 2 icsd net 112 22 jssmag 149 235 icsd net 2 If the etc atalk names doesn t exist or doesn t contain an entry for some appletalk host net number addresses are printed in numeric form In the first example NBP DDP port 2 on net 144 1 node 2 9 is sending to whatever is listening on port 22 of net icsd node 112 The second line is the same except the full name of the source node is known office The third line is a send from port 235 on net jssmag node 149 to broadcast on the icsd net NBP port note that the broadcast address 255 is indicated by a net name with no host number for this reason it s a good idea to keep node names and net names distinct in etc atalk names NBP name binding protocol and ATP Appletalk transaction protocol packets have their contents interpreted Other protocols just dump the protocol name or number if no name is registered for the protocol and packet size NBP packets are formatted like the following examples icsd net 112 22 jssmag 2 nbp lkup 19 LaserWriter jssmag 2 9 2 icsd net 112 22 nbp reply 19 RM114 LaserWriter 25 techpit 2 icsd net 112 22 nbp reply 19 techpit LaserWriter 186 The first line is a name lookup request for laserwriters sent by net icsd host 112 and broadcast on net jssmag The nbp id for the lookup is 19 The second line shows a reply for this request note that it has the same id from host jssmag 2 9 saying that it has a laserwriter resource named RM114 registered on port 25 The third line is another reply to the same request saying host techpit has laserwriter techpit registered on port 186 ATP packet formatting is demonstrated by the following example jssmag 2 9 165 helios 132 atp req 12266 7 xae 3 1 helios 132 jssmag 2 9 165 atp resp 12266 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 1 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 2 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 3 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 4 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 5 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 6 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 7 512 xae 4 jssmag 2 9 165 helios 132 atp req 12266 3 5 xae 3 1 helios 132 jssmag 2 9 165 atp resp 12266 3 512 xae 4 helios 132 jssmag 2 9 165 atp resp 12266 5 512 xae 4 jssmag 2 9 165 helios 132 atp rel 12266 7 xae 3 1 jssmag 2 9 133 helios 132 atp req 12267 7 xae 3 2 Jssmag 2 9 initiates transaction id 12266 with host helios by requesting up to 8 packets the 7 The hex number at the end of the line is the value of the userdata field in the request Helios responds with 8 512 byte packets The digit following the transaction id gives the packet sequence number in the transaction and the number in parens is the amount of data in the packet excluding the atp header The on packet 7 indicates that the EOM bit was set Jssmag 2 9 then requests that packets 3 5 be retransmitted Helios resends them then jssmag 2 9 releases the transaction Finally jssmag 2 9 initiates the next request The on the request indicates that XO exactly once was not set IP Fragmentation Fragmented Internet datagrams are printed as frag id size offset frag id size offset The first form indicates there are more fragments The second indicates this is the last fragment Id is the fragment id Size is the fragment size in bytes excluding the IP header Offset is this fragment s offset in bytes in the original datagram The fragment information is output for each fragment The first fragment contains the higher level protocol header and the frag info is printed after the protocol info Fragments after the first contain no higher level protocol header and the frag info is printed after the source and destination addresses For example here is part of an ftp from arizona edu to lbl rtsg arpa over a CSNET connection that doesn t appear to handle 576 byte datagrams arizona ftp data rtsg 117 1 24 1332 3 8 ack 1 win 4 96 frag 595a 328 arizona rtsg frag 595a 2 4 328 rtsg 117 arizona ftp data ack 1536 win 256 There are a couple of things to note here First addresses in the 2nd line don t include port numbers This is because the TCP protocol information is all in the first fragment and we have no idea what the port or sequence numbers are when we print the later fragments Second the tcp sequence information in the first line is printed as if there were 3 8 bytes of user data when in fact there are 512 bytes 3 8 in the first frag and 2 4 in the second If you are looking for holes in the sequence space or trying to match up acks with packets this can fool you A packet with the IP don t fragment flag is marked with a trailing DF Timestamps By default all output lines are preceded by a timestamp The timestamp is the current clock time in the form hh mm ss frac and is as accurate as the kernel s clock The timestamp reflects the time the kernel first saw the packet No attempt is made to account for the time lag between when the ethernet interface removed the packet from the wire and when the kernel serviced the new packet interrupt SEE ALSOtraffic 1C nit 4P bpf 4 pcap 3 AUTHORSVan Jacobson Craig Leres and Steven McCanne all of the Lawrence Berkeley National Laboratory University of California Berkeley CA The current version is available via anonymous ftp ftp ftp ee lbl gov tcpdump tar Z BUGSPlease send bug reports to tcpdump ee lbl gov NIT doesn t let you watch your own outbound traffic BPF will We recommend that you use the latter Some attempt should be made to reassemble IP fragments or at least to compute the right length for the higher level protocol Name server inverse queries are not dumped correctly The empty question section is printed rather than real query in the answer section Some believe that inverse queries are themselves a bug and prefer to fix the program generating them rather than tcpdump Apple Ethertalk DDP packets could be dumped as easily as KIP DDP packets but aren t Even if we were inclined to do anything to promote the use of Ethertalk we aren t LBL doesn t allow Ethertalk on any of its networks so we d would have no way of testing this code A packet trace that crosses a daylight savings time change will give skewed time stamps the time change is ignored Filters expressions that manipulate FDDI headers assume that all FDDI packets are encapsulated Ethernet packets This is true for IP ARP and DECNET Phase IV but is not true for protocols such as ISO CLNS Therefore the filter may inadvertently accept certain packets that do not properly match the filter expression Index NAME SYNOPSIS DESCRIPTION OPTIONS EXAMPLES OUTPUT FORMAT SEE ALSO AUTHORS BUGS This document was created by man2html using the manual pages Time 19 17 16 GMT August 9 2 ", "_id": "http://www.ics.uci.edu/~magda/Courses/ics156/Man_TCPDUMP.html", "title": "manpage of tcpdump", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\r\n<!-- saved from url=(0049)http://www.ics.uci.edu/~lchen/ics156/tcpdump.html -->\r\n<HTML><HEAD><TITLE>Manpage of TCPDUMP</TITLE>\r\n<META content=\"text/html; charset=windows-1252\" http-equiv=Content-Type>\r\n<META content=\"MSHTML 5.00.2920.0\" name=GENERATOR></HEAD>\r\n<BODY>Content-type: text/html \r\n<H1>TCPDUMP</H1>Section: Maintenance Commands (8)<BR>Updated: 30 June 1997<BR><A \r\nhref=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#index\">Index</A> <A \r\nhref=\"http://localhost/cgi-bin/man/man2html\">Return to Main Contents</A>\r\n<HR>\r\n <A name=lbAB>&nbsp;</A> \r\n<H2>NAME</H2>tcpdump - dump traffic on a network <A name=lbAC>&nbsp;</A> \r\n<H2>SYNOPSIS</H2><B>tcpdump</B> [ <B>-adeflnNOpqStvx</B> ] [ <B>-c</B> \r\n<I>count</I> ] [ <B>-F</B> <I>file</I> ] \r\n<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ <B>-i</B> \r\n<I>interface</I> ] [ <B>-r</B> <I>file</I> ] [ <B>-s</B> <I>snaplen</I> ] \r\n<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ <B>-T</B> <I>type</I> \r\n] [ <B>-w</B> <I>file</I> ] [ <I>expression</I> ] <BR><A name=lbAD>&nbsp;</A> \r\n<H2>DESCRIPTION</H2>\r\n<P><I>Tcpdump</I> prints out the headers of packets on a network interface that \r\nmatch the boolean <I>expression</I>. \r\n<P><B>Under SunOS with nit or bpf:</B> To run <I>tcpdump</I> you must have read \r\naccess to <I>/dev/nit</I> or <I>/dev/bpf*</I>. <B>Under Solaris with dlpi:</B> \r\nYou must have read access to the network pseudo device, e.g. <I>/dev/le</I>. \r\n<B>Under HP-UX with dlpi:</B> You must be root or it must be installed setuid to \r\nroot. <B>Under IRIX with snoop:</B> You must be root or it must be installed \r\nsetuid to root. <B>Under Linux:</B> You must be root or it must be installed \r\nsetuid to root. <B>Under Ultrix and Digital UNIX:</B> Once the super-user has \r\nenabled promiscuous-mode operation using <I><A \r\nhref=\"http://localhost/cgi-bin/man/man2html?8+pfconfig\">pfconfig</A></I>(8), any \r\nuser may run <B>tcpdump</B>. <B>Under BSD:</B> You must have read access to \r\n<I>/dev/bpf*</I>. <A name=lbAE>&nbsp;</A> \r\n<H2>OPTIONS</H2>\r\n<DL compact>\r\n  <DT><B>-a</B> \r\n  <DD>Attempt to convert network and broadcast addresses to names. \r\n  <DT><B>-c</B> \r\n  <DD>Exit after receiving <I>count</I> packets. \r\n  <DT><B>-d</B> \r\n  <DD>Dump the compiled packet-matching code in a human readable form to \r\n  standard output and stop. \r\n  <DT><B>-dd</B> \r\n  <DD>Dump packet-matching code as a <B>C</B> program fragment. \r\n  <DT><B>-ddd</B> \r\n  <DD>Dump packet-matching code as decimal numbers (preceded with a count). \r\n  <DT><B>-e</B> \r\n  <DD>Print the link-level header on each dump line. \r\n  <DT><B>-f</B> \r\n  <DD>Print `foreign' internet addresses numerically rather than symbolically \r\n  (this option is intended to get around serious brain damage in Sun's yp server \r\n  --- usually it hangs forever translating non-local internet numbers). \r\n  <DT><B>-F</B> \r\n  <DD>Use <I>file</I> as input for the filter expression. An additional \r\n  expression given on the command line is ignored. \r\n  <DT><B>-i</B> \r\n  <DD>Listen on <I>interface</I>. If unspecified, <I>tcpdump</I> searches the \r\n  system interface list for the lowest numbered, configured up interface \r\n  (excluding loopback). Ties are broken by choosing the earliest match. \r\n  <DT><B>-l</B> \r\n  <DD>Make stdout line buffered. Useful if you want to see the data while \r\n  capturing it. E.g., <BR>``tcpdump&nbsp;&nbsp;-l&nbsp;&nbsp;|&nbsp;&nbsp;tee \r\n  dat'' or ``tcpdump&nbsp;&nbsp;-l &nbsp;&nbsp;&gt; \r\n  dat&nbsp;&nbsp;&amp;&nbsp;&nbsp;tail&nbsp;&nbsp;-f&nbsp;&nbsp;dat''. \r\n  <DT><B>-n</B> \r\n  <DD>Don't convert addresses (i.e., host addresses, port numbers, etc.) to \r\n  names. \r\n  <DT><B>-N</B> \r\n  <DD>Don't print domain name qualification of host names. E.g., if you give \r\n  this flag then <I>tcpdump</I> will print ``nic'' instead of ``nic.ddn.mil''. \r\n  <DT><B>-O</B> \r\n  <DD>Do not run the packet-matching code optimizer. This is useful only if you \r\n  suspect a bug in the optimizer. \r\n  <DT><B>-p</B> \r\n  <DD><I>Don't</I> put the interface into promiscuous mode. Note that the \r\n  interface might be in promiscuous mode for some other reason; hence, `-p' \r\n  cannot be used as an abbreviation for `ether host {local-hw-addr} or ether \r\n  broadcast'. \r\n  <DT><B>-q</B> \r\n  <DD>Quick (quiet?) output. Print less protocol information so output lines are \r\n  shorter. \r\n  <DT><B>-r</B> \r\n  <DD>Read packets from <I>file</I> (which was created with the -w option). \r\n  Standard input is used if <I>file</I> is ``-''. \r\n  <DT><B>-s</B> \r\n  <DD>Snarf <I>snaplen</I> bytes of data from each packet rather than the \r\n  default of 68 (with SunOS's NIT, the minimum is actually 96). 68 bytes is \r\n  adequate for IP, ICMP, TCP and UDP but may truncate protocol information from \r\n  name server and NFS packets (see below). Packets truncated because of a \r\n  limited snapshot are indicated in the output with ``[|<I>proto</I>]'', where \r\n  <I>proto</I> is the name of the protocol level at which the truncation has \r\n  occurred. Note that taking larger snapshots both increases the amount of time \r\n  it takes to process packets and, effectively, decreases the amount of packet \r\n  buffering. This may cause packets to be lost. You should limit <I>snaplen</I> \r\n  to the smallest number that will capture the protocol information you're \r\n  interested in. \r\n  <DT><B>-T</B> \r\n  <DD>Force packets selected by \"<I>expression</I>\" to be interpreted the \r\n  specified <I>type</I>. Currently known types are <B>rpc</B> (Remote Procedure \r\n  Call), <B>rtp</B> (Real-Time Applications protocol), <B>rtcp</B> (Real-Time \r\n  Applications control protocol), <B>vat</B> (Visual Audio Tool), <B>wb</B> \r\n  (distributed White Board), and <B>snmp</B> (Simple Network Management \r\n  Protocol). \r\n  <DT><B>-S</B> \r\n  <DD>Print absolute, rather than relative, TCP sequence numbers. \r\n  <DT><B>-t</B> \r\n  <DD><I>Don't</I> print a timestamp on each dump line. \r\n  <DT><B>-tt</B> \r\n  <DD>Print an unformatted timestamp on each dump line. \r\n  <DT><B>-v</B> \r\n  <DD>(Slightly more) verbose output. For example, the time to live and type of \r\n  service information in an IP packet is printed. \r\n  <DT><B>-vv</B> \r\n  <DD>Even more verbose output. For example, additional fields are printed from \r\n  NFS reply packets. \r\n  <DT><B>-w</B> \r\n  <DD>Write the raw packets to <I>file</I> rather than parsing and printing them \r\n  out. They can later be printed with the -r option. Standard output is used if \r\n  <I>file</I> is ``-''. \r\n  <DT><B>-x</B> \r\n  <DD>Print each packet (minus its link level header) in hex. The smaller of the \r\n  entire packet or <I>snaplen</I> bytes will be printed. \r\n  <DT><I>expression</I>\r\n  <DD>\r\n  <DL compact>\r\n    <DT>\r\n    <DD>selects which packets will be dumped. If no <I>expression</I> is given, \r\n    all packets on the net will be dumped. Otherwise, only packets for which \r\n    <I>expression</I> is `true' will be dumped. \r\n    <P>The <I>expression</I> consists of one or more <I>primitives.</I> \r\n    Primitives usually consist of an <I>id</I> (name or number) preceded by one \r\n    or more qualifiers. There are three different kinds of qualifier: \r\n    <DL compact>\r\n      <DT><I>type</I>\r\n      <DD>qualifiers say what kind of thing the id name or number refers to. \r\n      Possible types are <B>host</B>, <B>net</B> and <B>port</B>. E.g., `host \r\n      foo', `net 128.3', `port 20'. If there is no type qualifier, <B>host</B> \r\n      is assumed. \r\n      <DT><I>dir</I>\r\n      <DD>qualifiers specify a particular transfer direction to and/or from \r\n      <I>id.</I> Possible directions are <B>src</B>, <B>dst</B>, <B>src or \r\n      dst</B> and <B>src and</B> <B>dst</B>. E.g., `src foo', `dst net 128.3', \r\n      `src or dst port ftp-data'. If there is no dir qualifier, <B>src or \r\n      dst</B> is assumed. For `null' link layers (i.e. point to point protocols \r\n      such as slip) the <B>inbound</B> and <B>outbound</B> qualifiers can be \r\n      used to specify a desired direction. \r\n      <DT><I>proto</I>\r\n      <DD>qualifiers restrict the match to a particular protocol. Possible \r\n      protos are: <B>ether</B>, <B>fddi</B>, <B>ip</B>, <B>arp</B>, <B>rarp</B>, \r\n      <B>decnet</B>, <B>lat</B>, <B>sca</B>, <B>moprc</B>, <B>mopdl</B>, \r\n      <B>tcp</B> and <B>udp</B>. E.g., `ether src foo', `arp net 128.3', `tcp \r\n      port 21'. If there is no proto qualifier, all protocols consistent with \r\n      the type are assumed. E.g., `src foo' means `(ip or arp or rarp) src foo' \r\n      (except the latter is not legal syntax), `net bar' means `(ip or arp or \r\n      rarp) net bar' and `port 53' means `(tcp or udp) port 53'. </DD></DL>\r\n    <P>[`fddi' is actually an alias for `ether'; the parser treats them \r\n    identically as meaning ``the data link level used on the specified network \r\n    interface.'' FDDI headers contain Ethernet-like source and destination \r\n    addresses, and often contain Ethernet-like packet types, so you can filter \r\n    on these FDDI fields just as with the analogous Ethernet fields. FDDI \r\n    headers also contain other fields, but you cannot name them explicitly in a \r\n    filter expression.] \r\n    <P>In addition to the above, there are some special `primitive' keywords \r\n    that don't follow the pattern: <B>gateway</B>, <B>broadcast</B>, \r\n    <B>less</B>, <B>greater</B> and arithmetic expressions. All of these are \r\n    described below. \r\n    <P>More complex filter expressions are built up by using the words \r\n    <B>and</B>, <B>or</B> and <B>not</B> to combine primitives. E.g., `host foo \r\n    and not port ftp and not port ftp-data'. To save typing, identical qualifier \r\n    lists can be omitted. E.g., `tcp dst port ftp or ftp-data or domain' is \r\n    exactly the same as `tcp dst port ftp or tcp dst port ftp-data or tcp dst \r\n    port domain'. \r\n    <P>Allowable primitives are: \r\n    <DL compact>\r\n      <DT><B>dst host </B><I>host</I>\r\n      <DD>True if the IP destination field of the packet is <I>host</I>, which \r\n      may be either an address or a name. \r\n      <DT><B>src host </B><I>host</I>\r\n      <DD>True if the IP source field of the packet is <I>host</I>. \r\n      <DT><B>host </B><I>host</I>\r\n      <DD>True if either the IP source or destination of the packet is \r\n      <I>host</I>. Any of the above host expressions can be prepended with the \r\n      keywords, <B>ip</B>, <B>arp</B>, or <B>rarp</B> as in: <PRE><B>ip host </B><I>host</I>\r\n</PRE>which is equivalent to: <PRE><B>ether proto </B><I>\\ip</I><B> and host </B><I>host</I>\r\n</PRE>If <I>host</I> is a name with multiple IP addresses, each address \r\n      will be checked for a match. \r\n      <DT><B>ether dst </B><I>ehost</I>\r\n      <DD>True if the ethernet destination address is <I>ehost</I>. <I>Ehost</I> \r\n      may be either a name from /etc/ethers or a number (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?3N+ethers\">ethers</A></I>(3N) \r\n      for numeric format). \r\n      <DT><B>ether src </B><I>ehost</I>\r\n      <DD>True if the ethernet source address is <I>ehost</I>. \r\n      <DT><B>ether host </B><I>ehost</I>\r\n      <DD>True if either the ethernet source or destination address is \r\n      <I>ehost</I>. \r\n      <DT><B>gateway</B> <I>host</I>\r\n      <DD>True if the packet used <I>host</I> as a gateway. I.e., the ethernet \r\n      source or destination address was <I>host</I> but neither the IP source \r\n      nor the IP destination was <I>host</I>. <I>Host</I> must be a name and \r\n      must be found in both /etc/hosts and /etc/ethers. (An equivalent \r\n      expression is <PRE><B>ether host </B><I>ehost </I><B>and not host </B><I>host</I>\r\n</PRE>which can be used with either names or numbers for <I>host / \r\n      ehost</I>.) \r\n      <DT><B>dst net </B><I>net</I>\r\n      <DD>True if the IP destination address of the packet has a network number \r\n      of <I>net</I>. <I>Net</I> may be either a name from /etc/networks or a \r\n      network number (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4+networks\">networks</A>(4)</I> \r\n      for details). \r\n      <DT><B>src net </B><I>net</I>\r\n      <DD>True if the IP source address of the packet has a network number of \r\n      <I>net</I>. \r\n      <DT><B>net </B><I>net</I>\r\n      <DD>True if either the IP source or destination address of the packet has \r\n      a network number of <I>net</I>. \r\n      <DT><B>net </B><I>net</I> <B>mask </B><I>mask</I>\r\n      <DD>True if the IP address matches <I>net</I> with the specific netmask. \r\n      May be qualified with <B>src</B> or <B>dst</B>. \r\n      <DT><B>net </B><I>net</I>/<I>len</I>\r\n      <DD>True if the IP address matches <I>net</I> a netmask <I>len</I> bits \r\n      wide. May be qualified with <B>src</B> or <B>dst</B>. \r\n      <DT><B>dst port </B><I>port</I>\r\n      <DD>True if the packet is ip/tcp or ip/udp and has a destination port \r\n      value of <I>port</I>. The <I>port</I> can be a number or a name used in \r\n      /etc/services (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4P+tcp\">tcp</A></I>(4P) and \r\n      <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4P+udp\">udp</A></I>(4P)). If a \r\n      name is used, both the port number and protocol are checked. If a number \r\n      or ambiguous name is used, only the port number is checked (e.g., <B>dst \r\n      port 513</B> will print both tcp/login traffic and udp/who traffic, and \r\n      <B>port domain</B> will print both tcp/domain and udp/domain traffic). \r\n      <DT><B>src port </B><I>port</I>\r\n      <DD>True if the packet has a source port value of <I>port</I>. \r\n      <DT><B>port </B><I>port</I>\r\n      <DD>True if either the source or destination port of the packet is \r\n      <I>port</I>. Any of the above port expressions can be prepended with the \r\n      keywords, <B>tcp</B> or <B>udp</B>, as in: <PRE><B>tcp src port </B><I>port</I>\r\n</PRE>which matches only tcp packets whose source port is <I>port</I>. \r\n      <DT><B>less </B><I>length</I>\r\n      <DD>True if the packet has a length less than or equal to <I>length</I>. \r\n      This is equivalent to: <PRE><B>len &lt;= </B><I>length</I>.\r\n</PRE>\r\n      <DT><B>greater </B><I>length</I>\r\n      <DD>True if the packet has a length greater than or equal to \r\n      <I>length</I>. This is equivalent to: <PRE><B>len &gt;= </B><I>length</I>.\r\n</PRE>\r\n      <DT><B>ip proto </B><I>protocol</I>\r\n      <DD>True if the packet is an ip packet (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4P+ip\">ip</A></I>(4P)) of \r\n      protocol type <I>protocol</I>. <I>Protocol</I> can be a number or one of \r\n      the names <I>icmp</I>, <I>igrp</I>, <I>udp</I>, <I>nd</I>, or <I>tcp</I>. \r\n      Note that the identifiers <I>tcp</I>, <I>udp</I>, and <I>icmp</I> are also \r\n      keywords and must be escaped via backslash (\\), which is \\\\ in the \r\n      C-shell. \r\n      <DT><B>ether broadcast</B>\r\n      <DD>True if the packet is an ethernet broadcast packet. The <I>ether</I> \r\n      keyword is optional. \r\n      <DT><B>ip broadcast</B>\r\n      <DD>True if the packet is an IP broadcast packet. It checks for both the \r\n      all-zeroes and all-ones broadcast conventions, and looks up the local \r\n      subnet mask. \r\n      <DT><B>ether multicast</B>\r\n      <DD>True if the packet is an ethernet multicast packet. The <I>ether</I> \r\n      keyword is optional. This is shorthand for `<B>ether[0] &amp; 1 != 0</B>'. \r\n\r\n      <DT><B>ip multicast</B>\r\n      <DD>True if the packet is an IP multicast packet. \r\n      <DT><B>ether proto </B><I>protocol</I>\r\n      <DD>True if the packet is of ether type <I>protocol</I>. <I>Protocol</I> \r\n      can be a number or a name like <I>ip</I>, <I>arp</I>, or <I>rarp</I>. Note \r\n      these identifiers are also keywords and must be escaped via backslash (\\). \r\n      [In the case of FDDI (e.g., `<B>fddi protocol arp</B>'), the protocol \r\n      identification comes from the 802.2 Logical Link Control (LLC) header, \r\n      which is usually layered on top of the FDDI header. <I>Tcpdump</I> \r\n      assumes, when filtering on the protocol identifier, that all FDDI packets \r\n      include an LLC header, and that the LLC header is in so-called SNAP \r\n      format.] \r\n      <DT><B>decnet src </B><I>host</I>\r\n      <DD>True if the DECNET source address is <I>host</I>, which may be an \r\n      address of the form ``10.123'', or a DECNET host name. [DECNET host name \r\n      support is only available on Ultrix systems that are configured to run \r\n      DECNET.] \r\n      <DT><B>decnet dst </B><I>host</I>\r\n      <DD>True if the DECNET destination address is <I>host</I>. \r\n      <DT><B>decnet host </B><I>host</I>\r\n      <DD>True if either the DECNET source or destination address is \r\n      <I>host</I>. \r\n      <DT><B>ip</B>, <B>arp</B>, <B>rarp</B>, <B>decnet</B>\r\n      <DD>Abbreviations for: <PRE><B>ether proto </B><I>p</I>\r\n</PRE>where <I>p</I> is one of the above protocols. \r\n      <DT><B>lat</B>, <B>moprc</B>, <B>mopdl</B>\r\n      <DD>Abbreviations for: <PRE><B>ether proto </B><I>p</I>\r\n</PRE>where <I>p</I> is one of the above protocols. Note that \r\n      <I>tcpdump</I> does not currently know how to parse these protocols. \r\n      <DT><B>tcp</B>, <B>udp</B>, <B>icmp</B>\r\n      <DD>Abbreviations for: <PRE><B>ip proto </B><I>p</I>\r\n</PRE>where <I>p</I> is one of the above protocols. \r\n      <DT><I>expr relop expr</I>\r\n      <DD>True if the relation holds, where <I>relop</I> is one of &gt;, &lt;, \r\n      &gt;=, &lt;=, =, !=, and <I>expr</I> is an arithmetic expression composed \r\n      of integer constants (expressed in standard C syntax), the normal binary \r\n      operators [+, -, *, /, &amp;, |], a length operator, and special packet \r\n      data accessors. To access data inside the packet, use the following \r\n      syntax: <PRE><I>proto</I><B> [ </B><I>expr</I><B> : </B><I>size</I><B> ]</B>\r\n</PRE><I>Proto</I> is one of <B>ether, fddi, ip, arp, rarp, tcp, udp, \r\n      </B>or <B>icmp</B>, and indicates the protocol layer for the index \r\n      operation. The byte offset, relative to the indicated protocol layer, is \r\n      given by <I>expr</I>. <I>Size</I> is optional and indicates the number of \r\n      bytes in the field of interest; it can be either one, two, or four, and \r\n      defaults to one. The length operator, indicated by the keyword <B>len</B>, \r\n      gives the length of the packet. \r\n      <P>For example, `<B>ether[0] &amp; 1 != 0</B>' catches all multicast \r\n      traffic. The expression `<B>ip[0] &amp; 0xf != 5</B>' catches all IP \r\n      packets with options. The expression `<B>ip[6:2] &amp; 0x1fff = 0</B>' \r\n      catches only unfragmented datagrams and frag zero of fragmented datagrams. \r\n      This check is implicitly applied to the <B>tcp</B> and <B>udp</B> index \r\n      operations. For instance, <B>tcp[0]</B> always means the first byte of the \r\n      TCP <I>header</I>, and never means the first byte of an intervening \r\n      fragment. </P></DD></DL>\r\n    <P>Primitives may be combined using: \r\n    <DL compact>\r\n      <DT>\r\n      <DD>A parenthesized group of primitives and operators (parentheses are \r\n      special to the Shell and must be escaped). \r\n      <DT>\r\n      <DD>Negation (`<B>!</B>' or `<B>not</B>'). \r\n      <DT>\r\n      <DD>Concatenation (`<B>&amp;&amp;</B>' or `<B>and</B>'). \r\n      <DT>\r\n      <DD>Alternation (`<B>||</B>' or `<B>or</B>'). </DD></DL>\r\n    <P>Negation has highest precedence. Alternation and concatenation have equal \r\n    precedence and associate left to right. Note that explicit <B>and</B> \r\n    tokens, not juxtaposition, are now required for concatenation. \r\n    <P>If an identifier is given without a keyword, the most recent keyword is \r\n    assumed. For example, <PRE><B>not host vs and ace</B>\r\n</PRE>is short for <PRE><B>not host vs and host ace</B>\r\n</PRE>which should not be confused with <PRE><B>not ( host vs or ace )</B>\r\n</PRE>\r\n    <P>Expression arguments can be passed to tcpdump as either a single argument \r\n    or as multiple arguments, whichever is more convenient. Generally, if the \r\n    expression contains Shell metacharacters, it is easier to pass it as a \r\n    single, quoted argument. Multiple arguments are concatenated with spaces \r\n    before being parsed. </P></DD></DL></DD></DL><A name=lbAF>&nbsp;</A> \r\n<H2>EXAMPLES</H2>\r\n<P>To print all packets arriving at or departing from <I>sundown</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump host sundown</B>\r\n</PRE></DD></DL>\r\n<P>To print traffic between <I>helios</I> and either <I>hot</I> or <I>ace</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump host helios and \\( hot or ace \\)</B>\r\n</PRE></DD></DL>\r\n<P>To print all IP packets between <I>ace</I> and any host except <I>helios</I>: \r\n\r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump ip host ace and not helios</B>\r\n</PRE></DD></DL>\r\n<P>To print all traffic between local hosts and hosts at Berkeley: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump net ucb-ether</B>\r\n</PRE></DD></DL>\r\n<P>To print all ftp traffic through internet gateway <I>snup</I>: (note that the \r\nexpression is quoted to prevent the shell from (mis-)interpreting the \r\nparentheses): \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'gateway snup and (port ftp or ftp-data)'</B>\r\n</PRE></DD></DL>\r\n<P>To print traffic neither sourced from nor destined for local hosts (if you \r\ngateway to one other net, this stuff should never make it onto your local net). \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump ip and not net </B><I>localnet</I>\r\n</PRE></DD></DL>\r\n<P>To print the start and end packets (the SYN and FIN packets) of each TCP \r\nconversation that involves a non-local host. \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'tcp[13] &amp; 3 != 0 and not src and dst net </B><I>localnet</I>'\r\n</PRE></DD></DL>\r\n<P>To print IP packets longer than 576 bytes sent through gateway <I>snup</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'gateway snup and ip[2:2] &gt; 576'</B>\r\n</PRE></DD></DL>\r\n<P>To print IP broadcast or multicast packets that were <I>not</I> sent via \r\nethernet broadcast or multicast: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'ether[0] &amp; 1 = 0 and ip[16] &gt;= 224'</B>\r\n</PRE></DD></DL>\r\n<P>To print all ICMP packets that are not echo requests/replies (i.e., not ping \r\npackets): \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'icmp[0] != 8 and icmp[0] != 0\"</B>\r\n</PRE></DD></DL><A name=lbAG>&nbsp;</A> \r\n<H2>OUTPUT FORMAT</H2>\r\n<P>The output of <I>tcpdump</I> is protocol dependent. The following gives a \r\nbrief description and examples of most of the formats. \r\n<P><B></B>Link Level Headers \r\n<P>If the '-e' option is given, the link level header is printed out. On \r\nethernets, the source and destination addresses, protocol, and packet length are \r\nprinted. \r\n<P>On FDDI networks, the '-e' option causes <I>tcpdump</I> to print the `frame \r\ncontrol' field, the source and destination addresses, and the packet length. \r\n(The `frame control' field governs the interpretation of the rest of the packet. \r\nNormal packets (such as those containing IP datagrams) are `async' packets, with \r\na priority value between 0 and 7; for example, `<B>async4</B>'. Such packets are \r\nassumed to contain an 802.2 Logical Link Control (LLC) packet; the LLC header is \r\nprinted if it is <I>not</I> an ISO datagram or a so-called SNAP packet. \r\n<P><I>(N.B.: The following description assumes familiarity with the SLIP \r\ncompression algorithm described in RFC-1144.)</I> \r\n<P>On SLIP links, a direction indicator (``I'' for inbound, ``O'' for outbound), \r\npacket type, and compression information are printed out. The packet type is \r\nprinted first. The three types are <I>ip</I>, <I>utcp</I>, and <I>ctcp</I>. No \r\nfurther link information is printed for <I>ip</I> packets. For TCP packets, the \r\nconnection identifier is printed following the type. If the packet is \r\ncompressed, its encoded header is printed out. The special cases are printed out \r\nas <B>*S+</B><I>n</I> and <B>*SA+</B><I>n</I>, where <I>n</I> is the amount by \r\nwhich the sequence number (or sequence number and ack) has changed. If it is not \r\na special case, zero or more changes are printed. A change is indicated by U \r\n(urgent pointer), W (window), A (ack), S (sequence number), and I (packet ID), \r\nfollowed by a delta (+n or -n), or a new value (=n). Finally, the amount of data \r\nin the packet and compressed header length are printed. \r\n<P>For example, the following line shows an outbound compressed TCP packet, with \r\nan implicit connection identifier; the ack has changed by 6, the sequence number \r\nby 49, and the packet ID by 6; there are 3 bytes of data and 6 bytes of \r\ncompressed header: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>O ctcp * A+6 S+49 I+6 3 (6)</B>\r\n</PRE></DD></DL>\r\n<P><B></B>ARP/RARP Packets \r\n<P>Arp/rarp output shows the type of request and its arguments. The format is \r\nintended to be self explanatory. Here is a short sample taken from the start of \r\nan `rlogin' from host <I>rtsg</I> to host <I>csam</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>arp who-has csam tell rtsg\r\narp reply csam is-at CSAM</TT>\r\n\r\n</PRE></DD></DL>The first line says that rtsg sent an arp packet asking for the \r\nethernet address of internet host csam. Csam replies with its ethernet address \r\n(in this example, ethernet addresses are in caps and internet addresses in lower \r\ncase). \r\n<P>This would look less redundant if we had done <B>tcpdump -n</B>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>arp who-has 128.3.254.6 tell 128.3.254.68\r\narp reply 128.3.254.6 is-at 02:07:01:00:01:c4</TT>\r\n</PRE></DD></DL>\r\n<P>If we had done <B>tcpdump -e</B>, the fact that the first packet is broadcast \r\nand the second is point-to-point would be visible: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>RTSG Broadcast 0806  64: arp who-has csam tell rtsg\r\nCSAM RTSG 0806  64: arp reply csam is-at CSAM</TT>\r\n\r\n</PRE></DD></DL>For the first packet this says the ethernet source address is \r\nRTSG, the destination is the ethernet broadcast address, the type field \r\ncontained hex 0806 (type ETHER_ARP) and the total length was 64 bytes. \r\n<P><B></B>TCP Packets \r\n<P><I>(N.B.:The following description assumes familiarity with the TCP protocol \r\ndescribed in RFC-793. If you are not familiar with the protocol, neither this \r\ndescription nor tcpdump will be of much use to you.)</I> \r\n<P>The general format of a tcp protocol line is: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src &gt; dst: flags data-seqno ack window urgent options</I>\r\n\r\n</PRE></DD></DL><I>Src</I> and <I>dst</I> are the source and destination IP \r\naddresses and ports. <I>Flags</I> are some combination of S (SYN), F (FIN), P \r\n(PUSH) or R (RST) or a single `.' (no flags). <I>Data-seqno</I> describes the \r\nportion of sequence space covered by the data in this packet (see example \r\nbelow). <I>Ack</I> is sequence number of the next data expected the other \r\ndirection on this connection. <I>Window</I> is the number of bytes of receive \r\nbuffer space available the other direction on this connection. <I>Urg</I> \r\nindicates there is `urgent' data in the packet. <I>Options</I> are tcp options \r\nenclosed in angle brackets (e.g., &lt;mss 1024&gt;). \r\n<P><I>Src, dst</I> and <I>flags</I> are always present. The other fields depend \r\non the contents of the packet's tcp protocol header and are output only if \r\nappropriate. \r\n<P>Here is the opening portion of an rlogin from host <I>rtsg</I> to host \r\n<I>csam</I>. \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;\r\ncsam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;\r\nrtsg.1023 &gt; csam.login: . ack 1 win 4096\r\nrtsg.1023 &gt; csam.login: P 1:<A href=\"http://localhost/cgi-bin/man/man2html?1+2\">2</A>(1) ack 1 win 4096\r\ncsam.login &gt; rtsg.1023: . ack 2 win 4096\r\nrtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096\r\ncsam.login &gt; rtsg.1023: P 1:<A href=\"http://localhost/cgi-bin/man/man2html?1+2\">2</A>(1) ack 21 win 4077\r\ncsam.login &gt; rtsg.1023: P 2:<A href=\"http://localhost/cgi-bin/man/man2html?1+3\">3</A>(1) ack 21 win 4077 urg 1\r\ncsam.login &gt; rtsg.1023: P 3:<A href=\"http://localhost/cgi-bin/man/man2html?1+4\">4</A>(1) ack 21 win 4077 urg 1</TT></FONT>\r\n\r\n</PRE></DD></DL>The first line says that tcp port 1023 on rtsg sent a packet to \r\nport <I>login</I> on csam. The <B>S</B> indicates that the <I>SYN</I> flag was \r\nset. The packet sequence number was 768512 and it contained no data. (The \r\nnotation is `first:last(nbytes)' which means `sequence numbers <I>first</I> up \r\nto but not including <I>last</I> which is <I>nbytes</I> bytes of user data'.) \r\nThere was no piggy-backed ack, the available receive window was 4096 bytes and \r\nthere was a max-segment-size option requesting an mss of 1024 bytes. \r\n<P>Csam replies with a similar packet except it includes a piggy-backed ack for \r\nrtsg's SYN. Rtsg then acks csam's SYN. The `.' means no flags were set. The \r\npacket contained no data so there is no data sequence number. Note that the ack \r\nsequence number is a small integer (1). The first time <B>tcpdump</B> sees a tcp \r\n`conversation', it prints the sequence number from the packet. On subsequent \r\npackets of the conversation, the difference between the current packet's \r\nsequence number and this initial sequence number is printed. This means that \r\nsequence numbers after the first can be interpreted as relative byte positions \r\nin the conversation's data stream (with the first data byte each direction being \r\n`1'). `-S' will override this feature, causing the original sequence numbers to \r\nbe output. \r\n<P>On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20 in the \r\nrtsg -&gt; csam side of the conversation). The PUSH flag is set in the packet. \r\nOn the 7th line, csam says it's received data sent by rtsg up to but not \r\nincluding byte 21. Most of this data is apparently sitting in the socket buffer \r\nsince csam's receive window has gotten 19 bytes smaller. Csam also sends one \r\nbyte of data to rtsg in this packet. On the 8th and 9th lines, csam sends two \r\nbytes of urgent, pushed data to rtsg. \r\n<P>If the snapshot was small enough that <B>tcpdump</B> didn't capture the full \r\nTCP header, it interprets as much of the header as it can and then reports \r\n``[|<I>tcp</I>]'' to indicate the remainder could not be interpreted. If the \r\nheader contains a bogus option (one with a length that's either too small or \r\nbeyond the end of the header), tcpdump reports it as ``[<I>bad opt</I>]'' and \r\ndoes not interpret any further options (since it's impossible to tell where they \r\nstart). If the header length indicates options are present but the IP datagram \r\nlength is not long enough for the options to actually be there, tcpdump reports \r\nit as ``[<I>bad hdr length</I>]''. \r\n<P><B></B><B>UDP Packets</B> \r\n<P>UDP format is illustrated by this rwho packet: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>actinide.who &gt; broadcast.who: udp 84</TT>\r\n\r\n</PRE></DD></DL>This says that port <I>who</I> on host <I>actinide</I> sent a \r\nudp datagram to port <I>who</I> on host <I>broadcast</I>, the Internet broadcast \r\naddress. The packet contained 84 bytes of user data. \r\n<P>Some UDP services are recognized (from the source or destination port number) \r\nand the higher level protocol information printed. In particular, Domain Name \r\nservice requests (RFC-1034/1035) and Sun RPC calls (RFC-1050) to NFS. \r\n<P><B></B>UDP Name Server Requests \r\n<P><I>(N.B.:The following description assumes familiarity with the Domain \r\nService protocol described in RFC-1035. If you are not familiar with the \r\nprotocol, the following description will appear to be written in greek.)</I> \r\n<P>Name server requests are formatted as \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src &gt; dst: id op? flags qtype qclass name (len)</I>\r\n\r\n<TT>h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</TT>\r\n\r\n</PRE></DD></DL>Host <I>h2opolo</I> asked the domain server on <I>helios</I> for \r\nan address record (qtype=A) associated with the name <I>ucbvax.berkeley.edu.</I> \r\nThe query id was `3'. The `+' indicates the <I>recursion desired</I> flag was \r\nset. The query length was 37 bytes, not including the UDP and IP protocol \r\nheaders. The query operation was the normal one, <I>Query</I>, so the op field \r\nwas omitted. If the op had been anything else, it would have been printed \r\nbetween the `3' and the `+'. Similarly, the qclass was the normal one, \r\n<I>C_IN</I>, and omitted. Any other qclass would have been printed immediately \r\nafter the `A'. \r\n<P>A few anomalies are checked and may result in extra fields enclosed in square \r\nbrackets: If a query contains an answer, name server or authority section, \r\n<I>ancount</I>, <I>nscount</I>, or <I>arcount</I> are printed as `[<I>n</I>a]', \r\n`[<I>n</I>n]' or `[<I>n</I>au]' where <I>n</I> is the appropriate count. If any \r\nof the response bits are set (AA, RA or rcode) or any of the `must be zero' bits \r\nare set in bytes two and three, `[b2&amp;3=<I>x</I>]' is printed, where <I>x</I> \r\nis the hex value of header bytes two and three. \r\n<P><B></B>UDP Name Server Responses \r\n<P>Name server responses are formatted as \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src &gt; dst:  id op rcode flags a/n/au type class data (len)</I>\r\n\r\n<TT>helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)\r\nhelios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</TT>\r\n\r\n</PRE></DD></DL>In the first example, <I>helios</I> responds to query id 3 from \r\n<I>h2opolo</I> with 3 answer records, 3 name server records and 7 authority \r\nrecords. The first answer record is type A (address) and its data is internet \r\naddress 128.32.137.3. The total size of the response was 273 bytes, excluding \r\nUDP and IP headers. The op (Query) and response code (NoError) were omitted, as \r\nwas the class (C_IN) of the A record. \r\n<P>In the second example, <I>helios</I> responds to query 2 with a response code \r\nof non-existent domain (NXDomain) with no answers, one name server and no \r\nauthority records. The `*' indicates that the <I>authoritative answer</I> bit \r\nwas set. Since there were no answers, no type, class or data were printed. \r\n<P>Other flag characters that might appear are `-' (recursion available, RA, \r\n<I>not</I> set) and `|' (truncated message, TC, set). If the `question' section \r\ndoesn't contain exactly one entry, `[<I>n</I>q]' is printed. \r\n<P>Note that name server requests and responses tend to be large and the default \r\n<I>snaplen</I> of 68 bytes may not capture enough of the packet to print. Use \r\nthe <B>-s</B> flag to increase the snaplen if you need to seriously investigate \r\nname server traffic. `<B>-s 128</B>' has worked well for me. \r\n<P>\r\n<P><B></B>NFS Requests and Replies \r\n<P>Sun NFS (Network File System) requests and replies are printed as: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src.xid &gt; dst.nfs: len op args</I>\r\n<I>src.nfs &gt; dst.xid: reply stat len op results</I>\r\n\r\n<TT>\r\nsushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165\r\nwrl.nfs &gt; sushi.6709: reply ok 40 readlink \"../var\"\r\nsushi.201b &gt; wrl.nfs:\r\n        144 lookup fh 9,74/4096.6878 \"xcolors\"\r\nwrl.nfs &gt; sushi.201b:\r\n        reply ok 128 lookup fh 9,74/4134.3150\r\n</TT>\r\n\r\n</PRE></DD></DL>In the first line, host <I>sushi</I> sends a transaction with id \r\n<I>6709</I> to <I>wrl</I> (note that the number following the src host is a \r\ntransaction id, <I>not</I> the source port). The request was 112 bytes, \r\nexcluding the UDP and IP headers. The operation was a <I>readlink</I> (read \r\nsymbolic link) on file handle (<I>fh</I>) 21,24/10.731657119. (If one is lucky, \r\nas in this case, the file handle can be interpreted as a major,minor device \r\nnumber pair, followed by the inode number and generation number.) <I>Wrl</I> \r\nreplies `ok' with the contents of the link. \r\n<P>In the third line, <I>sushi</I> asks <I>wrl</I> to lookup the name \r\n`<I>xcolors</I>' in directory file 9,74/4096.6878. Note that the data printed \r\ndepends on the operation type. The format is intended to be self explanatory if \r\nread in conjunction with an NFS protocol spec. \r\n<P>If the -v (verbose) flag is given, additional information is printed. For \r\nexample: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>\r\nsushi.1372a &gt; wrl.nfs:\r\n        148 read fh 21,11/12.195 8192 bytes @ 24576\r\nwrl.nfs &gt; sushi.1372a:\r\n        reply ok 1472 read REG 100664 ids 417/0 sz 29388\r\n</TT>\r\n\r\n</PRE></DD></DL>(-v also prints the IP header TTL, ID, and fragmentation fields, \r\nwhich have been omitted from this example.) In the first line, <I>sushi</I> asks \r\n<I>wrl</I> to read 8192 bytes from file 21,11/12.195, at byte offset 24576. \r\n<I>Wrl</I> replies `ok'; the packet shown on the second line is the first \r\nfragment of the reply, and hence is only 1472 bytes long (the other bytes will \r\nfollow in subsequent fragments, but these fragments do not have NFS or even UDP \r\nheaders and so might not be printed, depending on the filter expression used). \r\nBecause the -v flag is given, some of the file attributes (which are returned in \r\naddition to the file data) are printed: the file type (``REG'', for regular \r\nfile), the file mode (in octal), the uid and gid, and the file size. \r\n<P>If the -v flag is given more than once, even more details are printed. \r\n<P>Note that NFS requests are very large and much of the detail won't be printed \r\nunless <I>snaplen</I> is increased. Try using `<B>-s 192</B>' to watch NFS \r\ntraffic. \r\n<P>NFS reply packets do not explicitly identify the RPC operation. Instead, \r\n<I>tcpdump</I> keeps track of ``recent'' requests, and matches them to the \r\nreplies using the transaction ID. If a reply does not closely follow the \r\ncorresponding request, it might not be parsable. \r\n<P><B></B>KIP Appletalk (DDP in UDP) \r\n<P>Appletalk DDP packets encapsulated in UDP datagrams are de-encapsulated and \r\ndumped as DDP packets (i.e., all the UDP header information is discarded). The \r\nfile <I>/etc/atalk.names</I> is used to translate appletalk net and node numbers \r\nto names. Lines in this file have the form \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>number  name</I>\r\n\r\n<TT>1.254           ether\r\n16.1            icsd-net\r\n1.254.110       ace</TT>\r\n\r\n</PRE></DD></DL>The first two lines give the names of appletalk networks. The \r\nthird line gives the name of a particular host (a host is distinguished from a \r\nnet by the 3rd octet in the number - a net number <I>must</I> have two octets \r\nand a host number <I>must</I> have three octets.) The number and name should be \r\nseparated by whitespace (blanks or tabs). The <I>/etc/atalk.names</I> file may \r\ncontain blank lines or comment lines (lines starting with a `#'). \r\n<P>Appletalk addresses are printed in the form \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>net.host.port</I>\r\n\r\n<TT>144.1.209.2 &gt; icsd-net.112.220\r\noffice.2 &gt; icsd-net.112.220\r\njssmag.149.235 &gt; icsd-net.2</TT>\r\n\r\n</PRE></DD></DL>(If the <I>/etc/atalk.names</I> doesn't exist or doesn't contain \r\nan entry for some appletalk host/net number, addresses are printed in numeric \r\nform.) In the first example, NBP (DDP port 2) on net 144.1 node 209 is sending \r\nto whatever is listening on port 220 of net icsd node 112. The second line is \r\nthe same except the full name of the source node is known (`office'). The third \r\nline is a send from port 235 on net jssmag node 149 to broadcast on the icsd-net \r\nNBP port (note that the broadcast address (255) is indicated by a net name with \r\nno host number - for this reason it's a good idea to keep node names and net \r\nnames distinct in /etc/atalk.names). \r\n<P>NBP (name binding protocol) and ATP (Appletalk transaction protocol) packets \r\nhave their contents interpreted. Other protocols just dump the protocol name (or \r\nnumber if no name is registered for the protocol) and packet size. \r\n<P><B>NBP packets</B> are formatted like the following examples: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: \"=:LaserWriter@*\"\r\njssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: \"RM1140:LaserWriter@*\" 250\r\ntechpit.2 &gt; icsd-net.112.220: nbp-reply 190: \"techpit:LaserWriter@*\" 186</TT></FONT>\r\n\r\n</PRE></DD></DL>The first line is a name lookup request for laserwriters sent by \r\nnet icsd host 112 and broadcast on net jssmag. The nbp id for the lookup is 190. \r\nThe second line shows a reply for this request (note that it has the same id) \r\nfrom host jssmag.209 saying that it has a laserwriter resource named \"RM1140\" \r\nregistered on port 250. The third line is another reply to the same request \r\nsaying host techpit has laserwriter \"techpit\" registered on port 186. \r\n<P><B>ATP packet</B> formatting is demonstrated by the following example: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000\r\njssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000\r\njssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001\r\njssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002</TT></FONT>\r\n\r\n</PRE></DD></DL>Jssmag.209 initiates transaction id 12266 with host helios by \r\nrequesting up to 8 packets (the `&lt;0-7&gt;'). The hex number at the end of the \r\nline is the value of the `userdata' field in the request. \r\n<P>Helios responds with 8 512-byte packets. The `:digit' following the \r\ntransaction id gives the packet sequence number in the transaction and the \r\nnumber in parens is the amount of data in the packet, excluding the atp header. \r\nThe `*' on packet 7 indicates that the EOM bit was set. \r\n<P>Jssmag.209 then requests that packets 3 &amp; 5 be retransmitted. Helios \r\nresends them then jssmag.209 releases the transaction. Finally, jssmag.209 \r\ninitiates the next request. The `*' on the request indicates that XO (`exactly \r\nonce') was <I>not</I> set. \r\n<P>\r\n<P><B></B>IP Fragmentation \r\n<P>Fragmented Internet datagrams are printed as \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<B>(frag </B><I>id</I><B>:</B><I>size</I><B>@</B><I>offset</I><B>+)</B>\r\n<B>(frag </B><I>id</I><B>:</B><I>size</I><B>@</B><I>offset</I><B>)</B>\r\n\r\n</PRE></DD></DL>(The first form indicates there are more fragments. The second \r\nindicates this is the last fragment.) \r\n<P><I>Id</I> is the fragment id. <I>Size</I> is the fragment size (in bytes) \r\nexcluding the IP header. <I>Offset</I> is this fragment's offset (in bytes) in \r\nthe original datagram. \r\n<P>The fragment information is output for each fragment. The first fragment \r\ncontains the higher level protocol header and the frag info is printed after the \r\nprotocol info. Fragments after the first contain no higher level protocol header \r\nand the frag info is printed after the source and destination addresses. For \r\nexample, here is part of an ftp from arizona.edu to lbl-rtsg.arpa over a CSNET \r\nconnection that doesn't appear to handle 576 byte datagrams: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)\r\narizona &gt; rtsg: (frag 595a:204@328)\r\nrtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560</TT></FONT>\r\n\r\n</PRE></DD></DL>There are a couple of things to note here: First, addresses in \r\nthe 2nd line don't include port numbers. This is because the TCP protocol \r\ninformation is all in the first fragment and we have no idea what the port or \r\nsequence numbers are when we print the later fragments. Second, the tcp sequence \r\ninformation in the first line is printed as if there were 308 bytes of user data \r\nwhen, in fact, there are 512 bytes (308 in the first frag and 204 in the \r\nsecond). If you are looking for holes in the sequence space or trying to match \r\nup acks with packets, this can fool you. \r\n<P>A packet with the IP <I>don't fragment</I> flag is marked with a trailing \r\n<B>(DF)</B>. \r\n<P><B></B>Timestamps \r\n<P>By default, all output lines are preceded by a timestamp. The timestamp is \r\nthe current clock time in the form \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><I>hh:mm:ss.frac</I>\r\n</PRE></DD></DL>and is as accurate as the kernel's clock. The timestamp reflects \r\nthe time the kernel first saw the packet. No attempt is made to account for the \r\ntime lag between when the ethernet interface removed the packet from the wire \r\nand when the kernel serviced the `new packet' interrupt. <A name=lbAH>&nbsp;</A> \r\n\r\n<H2>SEE ALSO</H2><A \r\nhref=\"http://localhost/cgi-bin/man/man2html?1C+traffic\">traffic</A>(1C), <A \r\nhref=\"http://localhost/cgi-bin/man/man2html?4P+nit\">nit</A>(4P), <A \r\nhref=\"http://localhost/cgi-bin/man/man2html?4+bpf\">bpf</A>(4), <A \r\nhref=\"http://localhost/cgi-bin/man/man2html?3+pcap\">pcap</A>(3) <A \r\nname=lbAI>&nbsp;</A> \r\n<H2>AUTHORS</H2>Van Jacobson, Craig Leres and Steven McCanne, all of the \r\nLawrence Berkeley National Laboratory, University of California, Berkeley, CA. \r\n<P>The current version is available via anonymous ftp: \r\n<P>\r\n<DL compact>\r\n  <DT>\r\n  <DD><I><A \r\n  href=\"ftp://ftp.ee.lbl.gov/tcpdump.tar.Z\">ftp://ftp.ee.lbl.gov/tcpdump.tar.Z</A></I> \r\n  </DD></DL><A name=lbAJ>&nbsp;</A> \r\n<H2>BUGS</H2>Please send bug reports to <A \r\nhref=\"mailto:tcpdump@ee.lbl.gov\">tcpdump@ee.lbl.gov</A>. \r\n<P>NIT doesn't let you watch your own outbound traffic, BPF will. We recommend \r\nthat you use the latter. \r\n<P>Some attempt should be made to reassemble IP fragments or, at least to \r\ncompute the right length for the higher level protocol. \r\n<P>Name server inverse queries are not dumped correctly: The (empty) question \r\nsection is printed rather than real query in the answer section. Some believe \r\nthat inverse queries are themselves a bug and prefer to fix the program \r\ngenerating them rather than tcpdump. \r\n<P>Apple Ethertalk DDP packets could be dumped as easily as KIP DDP packets but \r\naren't. Even if we were inclined to do anything to promote the use of Ethertalk \r\n(we aren't), LBL doesn't allow Ethertalk on any of its networks so we'd would \r\nhave no way of testing this code. \r\n<P>A packet trace that crosses a daylight savings time change will give skewed \r\ntime stamps (the time change is ignored). \r\n<P>Filters expressions that manipulate FDDI headers assume that all FDDI packets \r\nare encapsulated Ethernet packets. This is true for IP, ARP, and DECNET Phase \r\nIV, but is not true for protocols such as ISO CLNS. Therefore, the filter may \r\ninadvertently accept certain packets that do not properly match the filter \r\nexpression. \r\n<P>\r\n<HR>\r\n<A name=index>&nbsp;</A>\r\n<H2>Index</H2>\r\n<DL>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAB\">NAME</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAC\">SYNOPSIS</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAD\">DESCRIPTION</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAE\">OPTIONS</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAF\">EXAMPLES</A>\r\n  <DD>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAG\">OUTPUT \r\n  FORMAT</A>\r\n  <DD>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAH\">SEE \r\n  ALSO</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAI\">AUTHORS</A>\r\n  <DD>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAJ\">BUGS</A>\r\n  <DD></DD></DL>\r\n<HR>\r\nThis document was created by <A \r\nhref=\"http://localhost/cgi-bin/man/man2html\">man2html</A>, using the manual \r\npages.<BR>Time: 19:17:16 GMT, August 09, 2000 </BODY></HTML>\r\n", "id": 34120.0}