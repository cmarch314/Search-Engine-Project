{"text": "XML Schemas Home Foundations home Sets Relations Correspondences Ordered Sets Lattices Graphs Powersets Binary Strings Logic AIA Greek Glossary Abstracts Argument Glossaries Inquiry Cycle Legal Relations Presentations Elicitation Glossaries Goals i SCR Tracing Alloy MSCs Regular Exprs Design Patterns Javadoc Java Packages Java Types X HTML XML Schemas XSLT Table of contents Introduction and context Basics An element Schema Referencing a schema in an XML file Elements and types in a schema Simple and complex types Empty simple complex and mixed content Character data Attribute types Element Simple type Restriction of a simple type List Union Predefined types Complex type Simple content Complex content Extension Restriction of a complex type Compositors all choice and sequence Particles any and group Attribute for a complex type Attribute group Any attribute allowed Attributes common to several schema elements More on element More on schema Comments Uniqueness constraints Advanced The distinction between lexical and value spaces Introduction and context This is a partial description of the XML Schema language It is provided because the W3C specification and published descriptions of the language are difficult to follow especially for a novice For a variety of reasons the XML Schema language is complex apparently arbitrary and difficult to explain or understand in its entirety This description does not give every feature of XML Schema nor every way of doing things but rather a relatively straightforward approach for defining most XML languages The W3C documents current at this writing are available online the XML Schema home page and the XML Schema specification consisting of XML Schema Part Primer XML Schema Part 1 Structures and XML Schema Part 2 Datatypes A useful Java package is Apache XMLBeans which provides methods to marshal and unmarshal XML to from Java objects and also a most useful verification tool validate for schemas and for XML files intended to match a particular schema All examples in this page were checked using validate Basics An element An element consists of a start tag and end tag and everything in between or an empty element tag A pair of start and end tags have the same name A start tag consists of an initial the name possibly some attributes and a terminal An end tag has no attributes and consists only of an initial the tag name and a terminal The material between an element s start tag and end tag are its contents The contents may contain elements and if so they must be either empty element tags or paren nested start and end tags An empty element tag starts with and its name may have attributes following its name and ends with A tag s name may be a localname such as item with no namespace prefix corresponding to the xs NCName predefined type or a qualified name or qname such as xs QName with a namespace prefix corresponding to the xs QName predefined type The prefix must have been defined in an xmlns attribute such as xmlns xs http www w3 org 2 1 XMLSchema of the current element or a parent element Examples An empty element tag name attr value Matched start and end tags name attr value character data or other elements can appear here name Schema A schema is a file defining a grammatical form for XML files The schema itself is in XML of a particular grammatical form described here The schema file defines a single schema element and looks something like this xml version 1 encoding UTF 8 xs schema xmlns xs http www w3 org 2 1 XMLSchema elementFormDefault qualified attributeFormDefault unqualified xml lang en xs schema with the representing the schema The line xml version 1 encoding UTF 8 is the XML declaration In this schema the attribute xmlns xs http www w3 org 2 1 XMLSchema of the schema element makes xs represent the namespace of the XMLSchema definition so that a prefix of xs identifies the schema elements such as xs simpleType We will use xs throughout this document Any prefix can be used xsd is also common as long as it is defined in the schema element An element is at the top level if it is a child element of the schema element rather than a child of a child or a child of a child of a child etc More on the schema element Referencing a schema in an XML file An XML element can identify its schema s in the xsi schemaLocation and xsi noNamespaceSchemaLocation attributes These two attributes are in the http www w3 org 2 1 XMLSchema instance namespace The xsi schemaLocation attribute s value is a list of whitespace separated namespaces and URIs for corresponding schemas anElement xmlns http www w3 org 1999 XSL Transform xmlns html http www w3 org 1999 xhtml xmlns xsi http www w3 org 2 1 XMLSchema instance xsi schemaLocation http www w3 org 1999 XSL Transform http www w3 org 1999 XSL Transform xsd http www w3 org 1999 xhtml http www w3 org 1999 xhtml xsd anElement example adapted from the W3C XML Schema Structures document The xsi noNamespaceSchemaLocation attribute s value is a single URI for the schema for elements and attributes with no namespace Elements and types in a schema Each XML element defined in a schema has a type The type is defined either as part of the element definition or elsewhere as a named type with the name attribute and referred to by that name in the element definition with the type attribute Each type definition consists of a simpleType or a complexType element Each attribute of an element has a type as well attribute types are restricted to be simpleTypes The element definition itself is made using an element element which is confusing to say but natural to do Examples An element containing a string its type is the basic XML type string and is referred to in the element definition xs element name stringElement type xs string An element containing a string this example s type is defined as part of the element definition In practice one would simply define the element as in the preceding example xs element name stringElementSimpleType xs simpleType xs restriction base xs string xs simpleType xs element An element containing a string and with an attribute The element type is defined as part of the element definition xs element name stringLangElementComplexType xs complexType xs simpleContent xs extension base xs string xs attribute name language type xs string xs extension xs simpleContent xs complexType xs element An element containing a string and with an attribute The element type is defined separately as stringLangType and referred to in the element definition xs element name stringLangElement type stringLangType xs complexType name stringLangType xs simpleContent xs extension base xs string xs attribute name language type xs language xs extension xs simpleContent xs complexType Although the same XML Schema constructs are used to define element and attribute types those types are interpreted in different ways An attribute type is simply a definition of the set of values that attribute can be given An element type on the other hand gives the values that the element can contain and possibly the names and types of the element s attributes In example a above xs string is the type of the contents of the element while in example c the same type xs string is the type of the values of the attribute language Rather than separating the definitions of element and attribute types XML Schema divides types into simpleTypes and complexTypes Attribute types are restricted to be simpleTypes while element types can be either simpleTypes interpreted as element contents or complexTypes Simple and complex types A simple type may contain only character data and may not have attributes All other types are complex A simple type is defined using a simpleType element and a complex type is defined using a complexType element TypeElement may containElement may have attributessimpleCharacter data onlyNocomplexCharacter data other elements or bothYes Empty simple complex and mixed content Element content may be empty simple complex or mixed ContentElement may containIndicated byemptyNothingsimpleType containing no character data example or complexType containing no character data and no elements easier example simpleCharacter data onlysimpleType or complexType containing simpleContentcomplex nOther elementscomplexContent declaring those subelementsmixedCharacter data and other elementscomplexContent declaring those subelements with attribute mixed true Simple types must have simple or empty content complex types may have any kind of content Character data Character data may consist of any characters except or literal A may be represented as lt and an as amp Within an attribute value character data may not contain the quote characters bracketing it A may be represented as apos and a as quot Attribute types Attribute types must be defined separately from the element that uses them and they must be simple types containing simple content Element An element element defines an element that may appear in an XML file If the element is defined at the top level then the XML file may contain an instance of the element as its sole contents otherwise the XML file may contain an instance of the element as part of another element Every element must have a name specified by its name attribute An element element may specify its type in one of these ways by naming the type in its type attribute by containing a simpleType element or by containing a complexType element An element with simple content may have either but not both of these attribute default giving the value that is assumed if the element is empty or fixed giving the only value the element is allowed to have An element may also have its contents restricted using either of these elements key keyref unique Simple type A simpleType element must contain an element of one of these kinds restriction list or union Restriction of a simple type A restriction element defines a new type by restricting an already existing type to produce a smaller set of values The already existing type is named in the restriction element s base attribute There are many ways of restricting a type some of which are listed below Note that a complex type can also be defined by restriction using the same tag but with additional possibilities By a regular expression Perl notation is used for the regular expression The set of values are all those that completely match the pattern xs simpleType name vowelString xs restriction base xs string xs pattern value aeiou xs restriction xs simpleType By enumeration of the restricted set of values The values are given in the value attribute of enumeration elements xs simpleType name emptySimpleType xs restriction base xs string xs enumeration value xs restriction xs simpleType xs simpleType name subtractiveColors xs restriction base xs string xs enumeration value blue xs enumeration value brown xs enumeration value green xs enumeration value orange xs enumeration value purple xs enumeration value red xs enumeration value yellow xs restriction xs simpleType xs simpleType name smallSquares xs restriction base xs integer xs enumeration value xs enumeration value 1 xs enumeration value 4 xs enumeration value 9 xs restriction xs simpleType By length The length may be limited by a minimum or by a maximum or to a single value xs simpleType name threeChars xs restriction base xs string xs length value 3 xs restriction xs simpleType xs simpleType name threeToFiveChars xs restriction base xs string xs minLength value 3 xs maxLength value 5 xs restriction xs simpleType List List types describe lists of elements of simple type the lists are represented with whitespace between the elements Definition of list types is not discussed here Union A union element defines a new simple type that is the union of two or more other simple types The new type consists of everything that the component types comprise The types may be listed by name in the memberTypes attribute or defined in the contents of the union element or both xs simpleType name vowelsOrColors xs union memberTypes vowelString subtractiveColors xs simpleType xs simpleType name vowelsOrColors2 xs union memberTypes subtractiveColors xs simpleType xs restriction base xs string xs pattern value aeiou xs restriction xs simpleType xs union xs simpleType Predefined types All predefined types are simple content except for anyType the supertype of all types xs anySimpleTypeThe supertype of all simple types provided for use when deriving a type if no other supertype will do xs stringStrings of printable character data xs normalizedStringLike xs string but the only whitespace characters are spaces on input other whitespace is replaced by spaces xs tokenLike xs normalizedString but leading spaces sequences of two or more spaces and trailing spaces are not allowed on input sequences are collapsed to single spaces and leading and trailing space is removed xs NMTOKENLike xs string but restricted to name characters A Za z 9 xs NameLike xs NMTOKEN but restricted to begin with a letter colon or underscore A Za z A Za z 9 If you want a name in the usual sense you probably want an xs NCName xs QNameA qualified name Like xs Name but can t start with a colon and at most one colon is allowed For example the string xs QName is an xs QName xs NCNameLike xs Name but no colons allowed A Za z A Za z 9 This datatype is closest to what one ordinarily thinks of as a name xs IDLike xs NCName but programs processing an XML file must check that each attribute value and simple type element value of this type is unique within the document containing them xs IDREFLike xs NCName but programs processing an XML file must check that each attribute value and simple type element value of this type is also an attribute or simple type element value of type xs ID in the same file xs languageLike xs string but restricted to be language codes such as en fr etc xs anyURILike xs string but restricted to be URIs for example http www w3 org 2 1 XMLSchema xs booleanA boolean value true false 1 or xs decimalA decimal number Like xs string but restricted to be 9 9 or 9 9 xs integerA decimal number with no fractional digits Like xs decimal but restricted to be 9 Has these self explanatory subtypes xs byte xs int xs long xs negativeInteger xs nonNegativeInteger xs nonPositiveInteger xs positiveInteger xs short xs unsignedByte xs unsignedInt xs unsignedLong xs unsignedShort xs floatLike xs decimal but with an optional E 9 on the end plus also the speciol values INF INF and NaN There is also xs double just like xs float but can be twice as long xs binaryValues are true false 1 and xs dateTimeA date and time of the form CCYY MM DDThh mm ss The hyphens T and colons are required Fractional seconds and a time zone Z or a time offset such as 5 are allowed xs dateLike xs dateTime but without hours minutes or seconds time zone is still allowed xs gDayLike xs dateTime but without century year month hour minute or second time zone is still allowed xs gMonthLike xs dateTime but without century year day hour minute or second time zone is still allowed xs gMonthDayLike xs dateTime but without century year hour minute or second time zone is still allowed xs gYearLike xs gYearMonth but without the month time zone is still allowed xs gYearMonthA Gregorian year and month thus the g Like xs date but without the day time zone is still allowed xs timeLike xs dateTime but without century year month or day time zone is still allowed xs durationA duration of the form xs PnYnMnDTnHnMnS The P is required and the T is required if any of the later elements are present Each nX substring represents a number and a unit years months days etc the number of seconds can be xs decimal the number of any other unit must be xs integer Not discussed here base64Binary ENTITY ENTITIES hexBinary IDREFS NMTOKENS NOTATION Complex type A complexType element must contain an element of one of these kinds simpleContent complexContent any compositor all choice or sequence or a group In addition a complexType element may contain elements of these kinds attribute any number of these attributeGroup any number of these and or anyAttribute A complexType may be defined to have by giving it empty contentan empty complexContent element with no mixed true attribute example simple contenta simpleContent elementcomplex contenta non empty complexContent element or a compositor or particlemixed contentcomplex content and the mixed true attribute For simplicity we will say a complex type is complex simple if it has empty or simple content and complex complex if it has complex or mixed content Simple content A simpleContent element of a complexType element must contain an element of either of these kinds an extension of a simple type without adding child elements or a restriction of a simple type Complex content A complexContent element of a complexType element must contain an element of either of these kinds an extension of a simple or complex type or a restriction of a simple or complex type If the mixed true attribute is given the contents may include character data as well as child elements otherwise it may only include child elements Extension An extension element creates a new type by adding elements and or attributes to a simple or complex type The type to extend must be defined at the top level and have a name The type to extend is identified using the extension element s base attribute Elements are added using a group all choice or sequence element in the contents of the extension Attributes are added using attribute and or attributeGroup elements or an anyAttribute element in the contents of the extension Example xs complexType name emptyComplexType xs complexType name vowelStringInLanguage xs complexContent xs extension base emptyComplexType xs attribute name vowels type vowelString a xs attribute name language type xs language xs extension xs complexContent xs complexType Restriction of a complex type A new complex type may be derived by from an existing complex simple type by restriction in all the ways that a simple type can be derived from an existing simple type see restriction for simple types In addition a new complex type may be derived by from an existing complex complex type by a restriction that reduces the child elements allowed or the type of a child element In either case the restriction of a complex type can reduce the scope of one or more attributes of the type Restriction of a complex simple type The character data allowed for a complex type with simple content may be restricted in all the ways that a simple type can see restriction of simple types In addition the types of attributes for the complex type may be restricted The restriction may contain attribute elements any number of these attributeGroup elements any number of these and or an anyAttribute element The attributes named in these elements must be attributes of the base type being restricted The type assigned to an attribute by these elements must be the same or a restriction of the type assigned to that attribute by the base type Any attribute of the base type that is not named in the restriction is assumed to have the same type as it did in the base type To exclude a base type attribute give it the use prohibited attribute in the restricted type Examples under construction Restriction of a complex complex type The character data and attributes allowed for a complex type with complex content may be restricted in all the ways that a simple type or complex type with simple content can see restriction of simple types and restriction of simple content In addition the child elements of the type may be restricted The restriction may contain group all choice or sequence elements These elements must be the same or a subset of the ones appearing in the base type The type assigned to each element must be the same or a restriction of the type assigned to that element in the base type An element of the base type may be excluded from the restricted type unlike attributes If an element is not listed in the restriction that element may not appear in instances of the new type Examples under construction Compositors all choice and sequence all choice and sequence are the XML Schema compositors useful in that they allow a composition of more than one particle where a single particle could otherwise appear all all is not discussed here it does not appear useful in ordinary situations choice A choice compositor lists mutually exclusive child elements that may appear where the compositor does A choice may contain element any group choice and or sequence elements These sub elements may be given minOccurs and or maxOccurs attributes to indicate how many instances of them must appear if that sub element is chosen If the choice is not an element of a group it may itself be given minOccurs and maxOccurs attributes so that it can represent a range of numbers of choices from the sub elements rather than a single choice Examples under construction sequence A sequence compositor lists child elements that must appear where the compositor does in the sequence in which they are listed A sequence may contain element any group choice and or sequence elements These sub elements may be given minOccurs and or maxOccurs attributes to indicate how many instances of them must appear there in the sequence If the sequence is not an element of a group it may itself be given minOccurs and maxOccurs attributes so that it can represent a range of numbers of sequences of the elements rather than a single sequence Examples under construction Particles any and group element any group and the compositors choice and sequence are the XML Schema particles A particle is used in a compositor to define a part of a complexType Any particle can have a minOccurs and or maxOccurs attribute as long as it is not appearing in a group any The any element represents any element in a specified namespace Its namespace attribute has several possible values A whitespace separated list of one or more URIs possibly including the special values targetNamespace for the target namespace specified in the schema element and or local for elements defined in the schema but not appearing with a namespace prefix any which causes the any element to represent elements from any namespace this is the default other which causes the any element to represent elements from namespaces other than the target namespace or from any namespace if the schema specifies no target namespace An any element must be empty There is also anyAttribute for attributes Examples under construction group A group is a named set of elements A named group must be defined at the top level contained only by the schema element and given a name using its name attribute as in this examples xs group name groupSubtractiveColorsWithLanguage xs sequence xs element name subtractiveColor type subtractiveColors xs element name language type xs language xs sequence xs group The named group can then be referenced by an empty element group tag using its ref attribute and the effect is as if the contents of the group appeared at that point This example defines two equivalent complex types the first using a group and the second directly xs complexType name SubtractiveColorsWithLanguage xs group ref groupSubtractiveColorsWithLanguage xs complexType xs complexType name subtractiveColorAndLanguage xs sequence xs element name subtractiveColor type subtractiveColors xs element name language type xs language xs sequence xs complexType A group may contain element group all choice and sequence elements The child elements of a group may not have either the minOccurs or the maxOccurs attributes A group definition may not have either the minOccurs or the maxOccurs attributes but an empty element group referring to a named group may have them unless it appears within a group itself There are also attributeGroups Attribute for a complex type A complexType is given an attribute by giving it an attribute child element Attributes may be defined globally referenced or defined locally Global definition of an attribute Attributes may be named and defined at the top level and then referenced by name elsewhere Such definitions may contain these attributes default giving the default value an xs string of the attribute that is used for any element in which the attribute can appear but does not fixed giving a single value an xs string that is the only value the attribute may be given the attribute then must either appear with that value or not appear fixed and default are mutually exclusive name the name of the defined attribute in any element it is part of and also the name by which this definition is referenced type the type of the defined attribute s value This attribute can t appear if a type is given in the body of the attribute element The type of the attribute s value is given either by a type attribute of the definition or by a simpleType child element of the definition Reference to a global definition of an attribute A defined attribute may be given to an element or element type by a child empty element attribute The empty element attribute may have these attributes ref specifying the attribute definition required use which may have one of these values use prohibited meaning the attribute may not appear useful in restrictions use optional this is the default use required form qualified if the attribute name must be qualified with the namespace when appearing in the element or type or form unqualified if not The default is set by the schema element s attributeFormDefault attribute Local definition of an attribute An attribute may be given to an element or element type by an attribute element that gives the name and type of the attribute directly The local definition can have these attributes default fixed form name giving the name of the attribute a local definition can t be referenced elsewhere by its name type use It may not have a ref attribute The type of the attribute s value is given either by a type attribute of the definition or by a simpleType child element of the definition Examples under construction Attribute group An attribute group is a named set of attributes Like a group it must be defined at the top level and can be referenced elsewhere An attributeGroup may contain attribute and or attributeGroup elements An attributeGroup definition must have a name attribute and a attributeGroup reference must be empty and have a ref attribute Examples under construction See group Any attribute allowed The anyAttribute element represents any attribute in a specified namespace An anyAttribute element may have a namespace attribute and must be empty It is analogous to any for elements Examples under construction Attributes common to several schema elements Many of the XML Schema elements share the same attributes Some of those are described here base base is used to refer to a simpleType or complexType that is being extended or restricted It is similar to ref and type but is only used to reference base types The type of a base value is xs NCName default default indicates the default value of an attribute or element the default value is assumed for an attribute that does not appear or for an element with empty content The only elements for which it is allowed are those with simple content as values of complex content cannot be given in an attribute value default and fixed may not appear together fixed fixed indicates an attribute or element that can only have one value that value is given by the value of the fixed attribute The only elements for which it is allowed are those with simple content as values of complex content cannot be given in an attribute value default and fixed may not appear together maxOccurs maxOccurs indicates the maximum number of times an instance represented by the element may appear If the maxOccurs attribute is not given 1 is assumed maxOccurs may be given any non negative integer value and also the special value unbounded The value of minOccurs assumed or explicit must not be greater than the value of maxOccurs assumed or explicit Examples xs group name OccursExample xs sequence xs element name Default xs element name SameAsDefault minOccurs 1 maxOccurs 1 xs element name ZeroOrOneTimes minOccurs xs element name OnceOrTwice maxOccurs 2 xs element name AtLeastOnce maxOccurs unbounded xs element name AnyNumber minOccurs maxOccurs unbounded xs sequence xs group minOccurs minOccurs indicates the minimum number of times an instance represented by the element may appear If the minOccurs attribute is not given 1 is assumed minOccurs may be given any non negative integer value The value of minOccurs assumed or explicit must not be greater than the value of maxOccurs assumed or explicit name name is used to give a name to a definition that can then be referenced elsewhere using a base ref type or other attribute It is also used to specify the names of elements and attributes that can appear in an XML file matching the schema The type of a name value is xs NCName ref ref is used to reference a named definition see name The type of a ref value is xs NCName type type is used to reference a named type see name It is similar to ref but is only used to reference types The type of a type value is xs NCName More on element Attributes default specifies a value that is assumed as the intended contents of an empty instance of this element The value must be of simpleContent because it is given in an attribute value default and fixed cannot both appear fixed specifies a value that all instances of the element must have and that is used as the default value of empty instances of this element default and fixed cannot both appear form specifies for a local element definition only whether the element name belongs to the target namespace form qualified or to no namespace form unqualified The default is set by the schema attribute Compare attribute s form element whose meaning is different although its syntax is identical More on schema Attributes attributeFormDefault specifies whether it is the default that attributes in XML files matching the schema must have a namespace prefix attributeFormDefault qualified or need not attributeFormDefault unqualified the default See the attribute attribute form elementFormDefault specifies whether it is the default that elements in XML files matching the schema must have a namespace prefix elementFormDefault qualified or need not elementFormDefault unqualified the default See the element attribute form lang gives the language in which the schema s text is written its value is of type xs language This attribute is defined as part of XML and can be given for any XML element often appearing as xml lang targetNamespace specifies the namespace if any whose names the schema defines The attribute value must be a URI that is the value of one of the schema s xmlns attributes All qualified attributes and elements defined in the schema must be qualified with the prefix given to this namespace in that xmlns attribute If no targetNamespace attribute is given the elements and attributes are not defined in a namespace xmlns gives the default namespace the namespace for unqualified elements those whose names have no prefix Its value is a URI Example xmlns http www w3 org 2 1 XMLSchema makes the XMLSchema namespace the default for unqualified element names but not unqualified attribute names those are assumed to be in the same namespace as the element containing them xmlns defines a prefix that refers to a specific namespace The prefix is the xs NCName that appears instead of the in the xmlns attribute The attribute s value is a URI that gives the namespace for the prefix Example xmlns xs http www w3 org 2 1 XMLSchema makes the xs prefix refer to the XMLSchema namespace Any name preceded by xs will be considered as a name in that namespace Comments Ordinary XML comments may be used in XML schemas These comments may appear anywhere an element may Example The annotation element is provided specifically for commenting schemas An annotation may appear as the first element of almost any XML Schema element and may appear anywhere at the top level in a schema element An annotation cannot appear within another annotation or its children An annotation may contain a documentation element containing a human readable comment and or an appinfo element containing program readable text Example xs element name annotatedElement xs annotation xs documentation Here is a comment for this schema element xs documentation xs annotation xs element Uniqueness constraints XML Schema provides several ways of ensuring unique values for attributes or elements and using those values in references Of course it is always possible to exercise discipline and ensure that certain values in an XML file are unique or to write a program to check the constraints you need Using the features described here forces XML validators to check the uniqueness constraints whenever an XML instance of your schema is read by a validator One way is through the predefined types ID and IDREF Schema processors are expected to check that values of type ID in an XML file are unique and that values of type IDREF are also values of type ID in the same file A second way is to use unique key and or keyref A unique element identifies elements with unique field or element values These values are constrained to be unique within each instance of unique s parent element unique can only occur as a child of an element This parent element defines the scope of the constraint and is here termed the scope node The unique element must contain two subelements selector whose xpath attribute identifies the scope node s descendant elements that are uniquely distinguished here termed the selected elements and field whose xpath attribute identifies the element or field here termed the distinguishing node whose value is unique for each of the selected elements The values are constrained to be unique among the selected descendants of the scope node contrast IDs which are unique within the entire file The distinguishing field or element may be an optional one in which case only descendants that possess it are constrained Each unique element is required to have a name field and the name values must be unique among all unique and key elements in the schema A selector element identifies a set of selected elements Its xpath attribute gives the pattern that selects those elements using the scope node the selector element s element grandparent as the context node In the most common case the pattern simply names the element type However any pattern that selects a child of the scope node is allowed A field element identifies a distinguishing node an element or field of the selected elements Its xpath attribute gives the pattern that selects the element or field using each element selected by the selector element as the context node In the most common case the pattern simply names the field preceded by to show it is a field However any pattern that selects a child of the selected elements or a field of a child is allowed It is possible to select several children as a composite field but that is not discussed further here A key element is like a unique element except that its field child element may only select a distinguishing node that is required whereas for unique the distinguishing node may be an element for which minOccurs or a field for which use optional A keyref element defines a reference to a selected element of a key or unique element The keyref should be a sibling of the key or unique element this is not required but produces results that are more predictable The keyref element must contain two subelements selector whose xpath attribute identifies the scope node s descendant elements that contain the key references and field whose xpath attribute identifies the element or field whose value is the key reference Each keyref element is required to have two attributes name and refer whose value is the name of the key or unique element whose unique value is referenced by this keyref s selected elements distinguishing nodes Example xs element name world xs complexType xs sequence xs element name state maxOccurs unbounded xs complexType xs choice maxOccurs unbounded xs element name car xs complexType empty content xs attribute name licenseNumber type xs string xs attribute name carPhoneNumber type xs string use optional xs complexType xs element xs element name carOwner xs complexType xs sequence xs element name carLicense type xs string maxOccurs unbounded xs sequence xs attribute name owner type xs string xs complexType xs element xs choice xs complexType xs key name car licenseNumber state key xs annotation xs documentation No two cars in the same state can have the same licenseNumber xs documentation xs annotation xs selector xpath car xs field xpath licenseNumber xs key xs keyref name owner state refer car licenseNumber state keyref xs selector xpath carOwner xs field xpath carLicense xs keyref xs element xs sequence xs complexType xs unique name car carPhoneNumber world unique xs annotation xs documentation No two cars in the world can have the same carPhoneNumber xs documentation xs annotation xs selector xpath car xs field xpath carPhoneNumber xs unique xs element Advanced Following are descriptions of XML Schema features that are more advanced and best avoided until needed Inclusion of other schemas There are several ways one schema can incorporate types elements attributes and groups defined in another schema besides simply copying the text which always works include has the effect of including all top level definitions of another schema The other schema is named in the schemaLocation attribute Its namespace if any must match the namespace of the including schema if any include may only appear at the top level import tells a program processing a schema where to find definitions in another namespace that are used in the schema The location of the definitions is given in the schemaLocation attribute only definitions at the top level can be imported The namespace of those definitions is given in the namespace attribute Compare schema s xmlns attribute Substitution groups Substitution groups provide a way to type elements and allow them to appear interchangeably without creating a type They do something of the same thing that types and choice do but can be extended elsewhere for example when a schema is included We will not describe substitution groups here in any more detail as in most cases the same function can be provided more straightforwardly by types and compositors and their description complicates the descriptions of other elements by requiring details that are not otherwise needed The distinction between lexical and value spaces Each type in XML Schema can be considered as a possibly infinite set of values of that type the type s value space Each type can also be considered as a possibly infinite set of strings representing the values of the type the type s lexical space Ordinarily there is no need to keep this distinction in mind But for many types a single value can be represented by more than one string for example a single xs integer is represented by 1 1 and 1 and a single xs normalizedString is represented by normalized string and normalized string Restriction by a regular expression acts on the lexical space not the value space It is best to avoid deriving types by regular expression for which the two spaces are not one to one as it makes confusion likely 2 1 May16Su21 42 Thomas A Alspaugh alspaugh at ics uci edu", "_id": "http://www.ics.uci.edu/~alspaugh/cls/shr/xmlSchema.html", "title": "xml schemas", "html": "<?xml version='1.1'?>\n<!DOCTYPE html\n     PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'\n     'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>\n<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>\n<head>\n  <title>XML Schemas</title>\n  <meta name='Author' content='Thomas A. Alspaugh'/>\n  <meta name='Description' content=\"XML Schemas\"/>\n  <meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'/>\n  <meta http-equiv='Content-Style-Type' content='text/css'/>\n  <link href='../../alspaugh-uci.css' rel='stylesheet' type='text/css'/>\n  <!-- <link href='../alspaugh-uci-cls.css' rel='stylesheet' type='text/css'/> -->\n  <style type='text/css'>\n\n    .egList      {  list-style-type: lower-alpha;  }\n    dl.code      {  padding-left: 0.75em;  }\n    dl.code dt   {  font-family: monospace;  font-style: normal;  }\n    dl.code dd   {  margin-left: 1.5em;  }\n    code dfn,\n    dfn code     {  font-style: normal;  }\n    span.comment {  color: olive;  }\n\n    @media screen {\n      body     {  background: url(\"img/bg-xmlSchema.png\") repeat-y;  }\n      #TMain   {  margin-left: 10.00em;  }\n    }\n  </style>\n</head>\n<body>\n\n<div id='TBg'>\n\n<div id='THeader'>\nXML Schemas\n</div>\n\n<div id='TLinks1' class='Links'> <!-- - - - - - - - - - - - - - - - - - - - -->\n<p>  <a class='sc' href='../../index.html'>Home</a>\n</p>\n<div class='hr'> </div>\n<p>  <a href='index.html'>Foundations home</a>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='set.html'>Sets</a><br/>\n<a href='relation.html'>Relations</a><br/>\n<a href='correspondence.html'>Correspondences</a><br/>\n<a href='orderedSet.html'>Ordered Sets</a><br/>\n<a href='lattice.html'>Lattices</a><br/>\n<a href='graph.html'>Graphs</a><br/>\n<a href='powerset.html'>Powersets</a><br/>\n<a href='binaryString.html'>Binary Strings</a><br/>\n<a href='logicConcepts.html'>Logic</a><br/>\n<a href='allen.html'>AIA</a><br/><!-- -spell AIA -->\n<a href='greek.html'>Greek</a><br/>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='glossaryExternal.html'>Glossary</a><br/>\n<a href='goodAbstract.html'>Abstracts</a><br/>\n<a href='argument.html'>Argument</a><br/>\n<a href='ontology.html'>Glossaries</a><br/>\n<a href='inquiryCycle.html'>Inquiry Cycle</a><br/>\n<a href='hohfeld.html'>Legal Relations</a><br/>\n<a href='goodPresentation.html'>Presentations</a><br/>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='quickStart.html'>Elicitation</a><br/>\n<a href='ontology.html'>Glossaries</a><br/>\n<a href='goal.html'>Goals</a><br/>\n<a href='istar.html'>i*</a><br/>\n<a href='SCR.html'>SCR</a><br/>\n<a href='tracing.html'>Tracing</a><br/>\n</p>\n<div class='hr2'> </div>\n<p>\n<a href='alloy.html'>Alloy</a><br/>\n<a href='msc.html'>MSCs</a><br/>\n<a href='regularExpression.html'>Regular Exprs.</a><br/>\n</p><!-- -spell MSCs Exprs -->\n<div class='hr2'> </div>\n<p>\n<a href='java-designPattern.html'>Design Patterns</a><br/>\n<a href='javadoc.html'>Javadoc</a><br/>\n<a href='java-package.html'>Java Packages</a><br/>\n<a href='java-type.html'>Java Types</a><br/>\n</p>\n<div class='hr2'> </div>\n<p>\n<a href='html.html'>(X)HTML</a><br/>\n<a href='xmlSchema.html'>XML Schemas</a><br/>\n<a href='xslt.html'>XSLT</a><br/>\n</p><!-- -spell XSLT -->\n</div>\n\n\n<!-- No right column -->\n<div id='TMain'><!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->\n<!--xhtml -y -->\n\n\n<!--spell AnyNumber AtLeastOnce CCYY DDThh Datatypes IDREF IDREFS NCName -->\n<!--spell NMTOKEN NMTOKENS NaN OccursExample OnceOrTwice PnYnMnDTnHnMnS QName -->\n<!--spell SameAsDefault SubtractiveColorsWithLanguage URIs UTF XMLBeans -->\n<!--spell XMLSchema XSL Za ZeroOrOneTimes aeiou anElement annotatedElement -->\n<!--spell anyAttribute anySimpleType anyType anyURI apos appinfo attr -->\n<!--spell attributeFormDefault attributeGroup attributeGroups carLicense -->\n<!--spell carOwner carPhoneNumber complexContent complexType complexTypes -->\n<!--spell datatype dateTime elementFormDefault emptyComplexType -->\n<!--spell emptySimpleType gDay gMonth gMonthDay gYear gYearMonth -->\n<!--spell groupSubtractiveColorsWithLanguage hexBinary html http keyref -->\n<!--spell keyref's lang licenseNumber localname lt maxLength maxOccurs -->\n<!--spell memberTypes minLength minOccurs nX namespace namespaces -->\n<!--spell negativeInteger noNamespaceSchemaLocation nonNegativeInteger -->\n<!--spell nonPositiveInteger normalizedString paren positiveInteger -->\n<!--spell qname schemaLocation simpleContent simpleType simpleTypes -->\n<!--spell smallSquares speciol ss stringElement stringElementSimpleType -->\n<!--spell stringLangElement stringLangElementComplexType stringLangType -->\n<!--spell subtractiveColor subtractiveColorAndLanguage subtractiveColors -->\n<!--spell supertype targetNamespace threeChars threeToFiveChars unique's -->\n<!--spell unmarshal unsignedByte unsignedInt unsignedLong unsignedShort -->\n<!--spell validator validators vowelString vowelStringInLanguage -->\n<!--spell vowelsOrColors xhtml xml xmlns xpath xs xsd xsi -->\n<!--spell attribute's -->\n\n\n<h1>Table of contents</h1>\n\n<div id='ToC'>\n  <h1><a href='#Introduction'>Introduction and context</a></h1>\n  <h1><a href='#Basics'>Basics</a></h1>\n  <h2><a href='#Elements'>An element</a></h2>\n  <h2><a href='#schema'>Schema</a></h2>\n  <h2><a href='#UsingASchema'>Referencing a schema in an XML file</a></h2>\n  <h2><a href='#ElementsAndTypes'>Elements and types in a schema</a></h2>\n  <h2><a href='#SimpleAndComplexType'>Simple and complex types</a></h2>\n  <h2><a href='#SimpleAndComplexContent'>Empty, simple, complex, and mixed content</a></h2>\n  <h2><a href='#character-data'>Character data</a></h2>\n  <h2><a href='#AttributeTypes'>Attribute types</a></h2>\n  <h1><a href='#element'>Element</a></h1>\n  <h1><a href='#simpleType'>Simple type</a></h1>\n  <h2><a href='#restriction'>Restriction (of a simple type)</a></h2>\n  <h2><a href='#list'>List</a></h2>\n  <h2><a href='#union'>Union</a></h2>\n  <h2><a href='#PredefinedTypes'>Predefined types</a></h2>\n  <h1><a href='#complexType'>Complex type</a></h1>\n  <h2><a href='#simpleContent'>Simple content</a></h2>\n  <h2><a href='#complexContent'>Complex content</a></h2>\n  <h2><a href='#extension'>Extension</a></h2>\n  <h2><a href='#ComplexRestriction'>Restriction (of a complex type)</a></h2>\n  <h2><a href='#Compositor'>Compositors <code>all</code>, <code>choice</code>, and <code>sequence</code></a></h2>\n  <h2><a href='#Particle'>Particles <code>any</code> and <code>group</code></a></h2>\n  <h2><a href='#attribute'>Attribute for a complex type</a></h2>\n  <h2><a href='#attributeGroup'>Attribute group</a></h2>\n  <h2><a href='#anyAttribute'>Any attribute allowed</a></h2>\n  <h1><a href='#CommonAttributes'>Attributes common to several schema elements</a></h1>\n  <h1><a href='#MoreElement'>More on <code>element</code></a></h1>\n  <h1><a href='#MoreSchema'>More on <code>schema</code></a></h1>\n  <h1><a href='#Comments'>Comments</a></h1>\n  <h1><a href='#UniqueValues'>Uniqueness constraints</a></h1>\n  <h1><a href='#NotRecommended'>Advanced</a></h1>\n  <h2><a href='#LexicalAndValue'>The distinction between lexical and value spaces</a></h2>\n</div> <!-- id='ToC' -->\n\n\n<h1 id='Introduction'>Introduction and context</h1>\n\n<p>\nThis is a partial description of the XML Schema language.&nbsp;\nIt is provided because the W3C specification and published descriptions\nof the language\nare difficult to follow, especially for a novice.&nbsp;\nFor a variety of reasons,\nthe XML Schema language is complex, apparently arbitrary,\nand difficult to explain or understand in its entirety.&nbsp;\nThis description does not give every feature of XML Schema\nnor every way of doing things,\nbut rather a (relatively) straightforward approach\nfor defining most XML languages.&nbsp;\n</p>\n\n<p>\nThe W3C documents current at this writing\nare available online:&nbsp;\nthe <a href='http://www.w3.org/XML/Schema'>XML Schema home page</a>\nand the XML Schema specification,\nconsisting of\n<a href='http://www.w3.org/TR/xmlschema-0/'>XML Schema Part 0: Primer</a>,\n<a href='http://www.w3.org/TR/xmlschema-1/'>XML Schema Part 1: Structures</a>, and\n<a href='http://www.w3.org/TR/xmlschema-2/'>XML Schema Part 2: Datatypes</a>.&nbsp;\n</p>\n\n<p>\nA useful Java package is\nApache <a href='http://xmlbeans.apache.org/'>XMLBeans</a>,\nwhich provides methods to marshal and unmarshal XML to/from Java objects\nand also a most useful verification tool (<code>validate</code>)\nfor schemas and for XML files intended to match a particular schema.&nbsp;\nAll examples in this page were checked using <code>validate</code>.&nbsp;\n</p>\n\n\n<h1 id='Basics'>Basics</h1>\n\n<h2 id='Elements'>An element</h2>\n\n<p>\nAn <dfn>element</dfn> consists of\na start tag and end tag and everything in between,\nor an empty-element tag.&nbsp;\nA pair of start and end tags have the same name.&nbsp;\nA <dfn>start tag</dfn> consists of an initial &lt;, the name,\npossibly some attributes, and a terminal &gt;.&nbsp;\nAn <dfn>end tag</dfn> has no attributes,\nand consists only of an initial &lt;/,\nthe tag name, and a terminal &gt;.&nbsp;\nThe material between an element's start tag and end tag\nare its <dfn>contents</dfn>.&nbsp;\nThe contents may contain elements, and if so they must be\neither empty-element tags\nor paren-nested start and end tags.&nbsp;\nAn <dfn id='EmptyElement'>empty-element tag</dfn> starts with &lt; and its name,\nmay have attributes following its name,\nand ends with /&gt;.&nbsp;\n</p>\n\n<p>\nA tag's name may be\n</p>\n\n<ul>\n  <li id='localname'>\n    a <dfn>localname</dfn> such as <code>item</code>\n    with no namespace prefix,\n    corresponding to the\n    <a href='#NCName'><code>xs:NCName</code></a> predefined type;&nbsp;\n    or\n  </li>\n  <li id='qname'>\n    a <dfn>qualified name</dfn> or <dfn>qname</dfn>  such as <code>xs:QName</code>\n    with a namespace prefix,\n    corresponding to the\n    <a href='#QName'><code>xs:QName</code></a> predefined type.&nbsp;\n    The prefix must have been defined in an\n    <code><a href='#xmlns_'>xmlns:*</a></code> attribute\n    such as <code>xmlns:xs='http://www.w3.org/2001/XMLSchema'</code>\n    of the current element or a parent element.&nbsp;\n  </li>\n</ul>\n\n<p>\nExamples:&nbsp;\n</p>\n\n<ol class='egList'>\n  <li> An empty-element tag:&nbsp; <pre>&lt;name attr='value'/&gt;</pre>\n  </li>\n  <li> Matched start and end tags:&nbsp;\n\n<pre>\n&lt;name attr='value'&gt;\n  <i>... <a href='#character-data'>character data</a> or other elements can appear here ...</i>\n&lt;/name&gt;\n</pre>\n  </li>\n</ol>\n\n<h2 id='schema'>Schema</h2>\n\n<p>\nA <dfn>schema</dfn> is a file defining a grammatical form for XML files.&nbsp;\nThe schema itself is in XML of a particular grammatical form described here.&nbsp;\nThe schema file defines a single <code><dfn>schema</dfn></code> element,\nand looks something like this:\n</p>\n\n<pre>\n&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'\n    elementFormDefault='qualified'\n    attributeFormDefault='unqualified'\n    xml:lang='en'&gt;\n    ...\n&lt;/xs:schema&gt;\n</pre>\n\n<p>\nwith the <b>...</b> representing the schema.&nbsp;\n</p>\n\n<p>\nThe line\n&lt;?xml&nbsp;version='1.0'&nbsp;encoding='UTF-8'?&gt;\nis the <dfn id='declaration'>XML declaration</dfn>.&nbsp;\n</p>\n\n<p>\nIn this schema,\nthe attribute <code>xmlns:xs='http://www.w3.org/2001/XMLSchema'</code>\nof the <code>schema</code> element\nmakes <code>xs</code> represent the namespace of the XMLSchema definition,\nso that a prefix of <code>xs:</code> identifies the schema elements\n(such as <code>xs:<a href='#simpleType'>simpleType</a></code>);&nbsp;\nWe will use <code>xs:</code> throughout this document.&nbsp;\nAny prefix can be used (<code>xsd:</code> is also common)\nas long as it is defined in the <code>schema</code> element.&nbsp;\n</p>\n\n<p id='TopLevel'>\nAn element is at the <dfn>top level</dfn>\nif it is a child element of the schema element\n(rather than a child of a child, or a child of a child of a child, etc).&nbsp;\n</p>\n\n<p>\n<a href='#MoreSchema'>More on the schema element ...</a>\n</p>\n\n\n<h2 id='UsingASchema'>Referencing a schema in an XML file</h2>\n\n<p>\nAn XML element can identify its schema(s)\nin the <code>xsi:<a href='#schemaLocation'>schemaLocation</a></code> and\n<code>xsi:<a href='#noNamespaceSchemaLocation'>noNamespaceSchemaLocation</a></code>\nattributes.&nbsp;\nThese two attributes are in the\n<code>http://www.w3.org/2001/XMLSchema-instance</code> namespace.&nbsp;\n</p>\n\n<p id='schemaLocation'>\nThe <code>xsi:<a href='#schemaLocation'>schemaLocation</a></code> attribute's\nvalue is a list of whitespace-separated\nnamespaces and URIs for corresponding schemas.&nbsp;\n</p>\n\n<pre>\n  &lt;anElement xmlns='http://www.w3.org/1999/XSL/Transform'\n             xmlns:html='http://www.w3.org/1999/xhtml'\n             xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n             xsi:schemaLocation='http://www.w3.org/1999/XSL/Transform\n                                 http://www.w3.org/1999/XSL/Transform.xsd\n                                 http://www.w3.org/1999/xhtml\n                                 http://www.w3.org/1999/xhtml.xsd'&gt;\n   ...\n  &lt;/anElement&gt;\n</pre>\n\n<p>\n(example adapted  from the W3C XML Schema Structures document)&nbsp;\n</p>\n\n<p id='noNamespaceSchemaLocation'>\nThe\n<code>xsi:<a href='#noNamespaceSchemaLocation'>noNamespaceSchemaLocation</a></code>\nattribute's\nvalue is a single URI for the schema for elements and attributes\nwith no namespace.&nbsp;\n</p>\n\n\n<h2 id='ElementsAndTypes'>Elements and types in a schema</h2>\n\n<p>\nEach XML element defined in a schema has a <i>type</i>.&nbsp;\nThe type is defined either\nas part of the element definition,\nor elsewhere as a named type\n(with the <code><a href='#name'>name</a></code> attribute)\nand referred to by that name in the element definition\n(with the <code><a href='#type'>type</a></code> attribute).&nbsp;\nEach type definition consists of a\n<code><a href='#simpleType'>simpleType</a></code> or a\n<code><a href='#complexType'>complexType</a></code> element.&nbsp;\nEach attribute of an element has a type as well;&nbsp;\nattribute types are restricted to be\n<code><a href='#simpleType'>simpleType</a></code>s.&nbsp;\n</p>\n\n<p>\nThe element definition itself is made using an\n<code>element</code> element\n(which is confusing to say, but natural to do).&nbsp;\n</p>\n\n<p>\nExamples:&nbsp;\n</p>\n\n<ol class='egList'>\n\n  <li> An element containing a string;&nbsp;\n    its type is the basic XML type <code><a href='#string'>string</a></code>\n    and is referred to in the element definition.&nbsp;\n<pre>\n  &lt;xs:element name='stringElement' type='xs:string'/&gt;\n</pre>\n  </li>\n\n  <li> An element containing a string;&nbsp;\n    this example's type is defined as part of the element definition.&nbsp;\n    (In practice, one would simply define the element\n    as in the preceding example.)&nbsp;\n<pre>\n  &lt;xs:element name='stringElementSimpleType'&gt;\n    &lt;xs:simpleType&gt;\n      &lt;xs:restriction base='xs:string'/&gt;\n    &lt;/xs:simpleType&gt;\n  &lt;/xs:element&gt;\n</pre>\n  </li>\n\n  <li> An element containing a string and with an attribute.&nbsp;\n    The element type is defined as part of the element definition.&nbsp;\n<pre>\n  &lt;xs:element name='stringLangElementComplexType'&gt;\n    &lt;xs:complexType&gt;\n      &lt;xs:simpleContent&gt;\n        &lt;xs:extension base='xs:string'&gt;\n          &lt;xs:attribute name='language' type='xs:string'/&gt;\n        &lt;/xs:extension&gt;\n      &lt;/xs:simpleContent&gt;\n    &lt;/xs:complexType&gt;\n  &lt;/xs:element&gt;\n</pre>\n  </li>\n\n  <li> An element containing a string and with an attribute.&nbsp;\n    The element type is defined separately as <code>stringLangType</code>\n    and referred to in the element definition.&nbsp;\n<pre>\n  &lt;xs:element name='stringLangElement' type='stringLangType'/&gt;\n  \n  &lt;xs:complexType name='stringLangType'&gt;\n    &lt;xs:simpleContent&gt;\n      &lt;xs:extension base='xs:string'&gt;\n        &lt;xs:attribute name='language' type='xs:language'/&gt;\n      &lt;/xs:extension&gt;\n    &lt;/xs:simpleContent&gt;\n  &lt;/xs:complexType&gt;\n</pre>\n  </li>\n\n</ol>\n\n<p>\nAlthough the same XML Schema constructs\nare used to define element and attribute types,\nthose types are interpreted in different ways.&nbsp;\nAn attribute type is simply\na definition of the set of values that attribute can be given.&nbsp;\nAn element type, on the other hand,\ngives the values that the element can contain\n(and possibly the names and types of the element's attributes).&nbsp;\nIn example (a) above,\n<code>xs:<a href='#string'>string</a></code>\nis the type of the contents of the element,\nwhile in example (c)\nthe same type <code>xs:<a href='#string'>string</a></code>\nis the type of the values of\nthe attribute <code>language</code>.&nbsp;\n</p>\n\n<p>\nRather than separating the definitions of\nelement and attribute types,\nXML Schema divides types into\n<code><a href='#simpleType'>simpleTypes</a></code> and\n<code><a href='#complexType'>complexTypes</a></code>.&nbsp;\nAttribute types are restricted to be\n<code><a href='#simpleType'>simpleTypes</a></code>,\nwhile element types can be either\n<code><a href='#simpleType'>simpleTypes</a></code>\n(interpreted as element contents) or\n<code><a href='#complexType'>complexTypes</a></code>.&nbsp;\n</p>\n\n\n<h2 id='SimpleAndComplexType'>Simple and complex types</h2>\n\n<p>\nA <dfn>simple type</dfn> may contain only\n<a href='#character-data'>character data</a>,\nand may not have attributes.&nbsp;\nAll other types are <dfn>complex</dfn>.&nbsp;\nA simple type is defined using a\n<code><a href='#simpleType'>simpleType</a></code> element,\nand\na complex type is defined using a\n<code><a href='#complexType'>complexType</a></code> element.&nbsp;\n</p>\n\n<table>\n<tbody>\n  <tr>\n    <th>Type</th>\n    <th>Element may contain</th>\n    <th>Element may have attributes</th>\n  </tr>\n  <tr>\n    <td>simple</td>\n    <td><a href='#character-data'>Character data</a> only</td>\n    <td>No</td>\n  </tr>\n  <tr>\n    <td>complex</td>\n    <td><a href='#character-data'>Character data</a>, other elements, or both</td>\n    <td>Yes</td>\n  </tr>\n</tbody>\n</table>\n\n\n<h2 id='SimpleAndComplexContent'>Empty, simple, complex, and mixed content</h2>\n\n<p>\nElement content may be <i>empty, simple, complex,</i> or <i>mixed</i>.&nbsp;\n</p>\n\n<table>\n<tbody>\n  <tr>\n    <th>Content</th>\n    <th>Element may contain</th>\n    <th>Indicated by</th>\n  </tr>\n  <tr>\n    <td id='EmptyContent'>empty</td>\n    <td>Nothing</td>\n    <td><code><a href='#simpleType'>simpleType</a></code>\n          containing no <a href='#character-data'>character data</a>\n          (<a href='#emptySimpleType'>example</a>)\n          or<br/>\n          <code><a href='#complexType'>complexType</a></code>\n          containing no <a href='#character-data'>character data</a> and no elements\n          (easier <a href='#emptyComplexType'>example</a>)</td>\n  </tr>\n  <tr>\n    <td id='SimpleContent'>simple</td>\n    <td><a href='#character-data'>Character data</a> only</td>\n    <td><code><a href='#simpleType'>simpleType</a></code> or<br/>\n          <code><a href='#complexType'>complexType</a></code>\n          containing <code><a href='#simpleContent'>simpleContent</a></code></td>\n  </tr>\n  <tr>\n    <td id='ComplexContent'>complex\\n</td>\n    <td>Other elements</td>\n    <td><code><a href='#complexContent'>complexContent</a></code>\n        declaring those subelements</td>\n  </tr>\n  <tr>\n    <td id='MixedContent'>mixed</td>\n    <td><a href='#character-data'>Character data</a> and other elements</td>\n    <td><code><a href='#complexContent'>complexContent</a></code>\n        declaring those subelements,\n        with attribute <code>mixed='true'</code></td>\n  </tr>\n</tbody>\n</table>\n\n<p>\nSimple types must have simple or empty content;&nbsp;\ncomplex types may have any kind of content, .&nbsp;\n</p>\n\n\n<h2 id='character-data'>Character data</h2>\n\n<p>\nCharacter data may consist of\nany characters except &lt; or literal &amp;.&nbsp;\nA &lt; may be represented as <code>&amp;lt;</code>,\nand an &amp; as <code>&amp;amp;</code>.&nbsp;\n</p>\n\n<p>\nWithin an attribute value,\ncharacter data may not contain the quote characters bracketing it.&nbsp;\nA ' may be represented as <code>&amp;apos;</code>,\nand a \" as <code>&amp;quot;</code>.&nbsp;\n</p>\n\n\n<h2 id='AttributeTypes'>Attribute types</h2>\n\n<p>\nAttribute types must be defined separately from the element that uses them,\nand they must be simple types containing simple content.&nbsp;\n</p>\n\n\n<h1 id='element'>Element</h1>\n\n<p>\nAn <code><dfn>element</dfn></code> element\ndefines an element that may appear in an XML file.&nbsp;\nIf the <code><a href='#element'>element</a></code> is defined at the top level,\nthen the XML file may contain an instance of the element\nas its sole contents;&nbsp;\notherwise, the XML file may contain an instance of the element\nas part of another element.&nbsp;\n</p>\n\n<p>\nEvery <code><a href='#element'>element</a></code> must have a name,\nspecified by its <code><a href='#name'>name</a></code> attribute.&nbsp;\n</p>\n\n<p>\nAn <code><a href='#element'>element</a></code> element may specify its type in one of these ways:\n</p>\n\n<ul>\n  <li> by naming the type in its <a href='#type'>type</a> attribute,\n  </li>\n  <li> by containing a <code><a href='#simpleType'>simpleType</a></code> element, or\n  </li>\n  <li> by containing a <code><a href='#complexType'>complexType</a></code>\n      element.&nbsp;\n  </li>\n</ul>\n\n<p>\nAn element with <a href='#SimpleContent'>simple content</a>\nmay have either (but not both) of these attribute:\n</p>\n\n<ul>\n  <li> <code><a href='#default'>default</a></code>\n    giving the value that is assumed if the element is empty, or\n  </li>\n  <li> <code><a href='#fixed'>fixed</a></code>\n    giving the only value the element is allowed to have.&nbsp;\n  </li>\n</ul>\n\n<p>\nAn element may also have its contents restricted using either of these elements:\n</p>\n\n<ul>\n  <li> <code><a href='#key'>key</a></code>\n  </li>\n  <li> <code><a href='#keyref'>keyref</a></code>\n  </li>\n  <li> <code><a href='#unique'>unique</a></code>\n  </li>\n</ul>\n\n\n<h1 id='simpleType'>Simple type</h1>\n\n<p>\nA <code><dfn>simpleType</dfn></code> element must contain\nan element of one of these kinds:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#restriction'>restriction</a></code>,\n  </li>\n  <li> <code><a href='#list'>list</a></code>, or\n  </li>\n  <li> <code><a href='#union'>union</a></code>.&nbsp;\n  </li>\n</ul>\n\n\n<h2 id='restriction'>Restriction (of a simple type)</h2>\n\n<p>\nA <code><dfn>restriction</dfn></code> element\ndefines a new type by restricting an already-existing type\nto produce a smaller set of values.&nbsp;\nThe already-existing type is named in the\n<code><a href='#restriction'>restriction</a></code> element's\n<code><a href='#base'>base</a></code> attribute.&nbsp;\nThere are many ways of restricting a type,\nsome of which are listed below.&nbsp;\n</p>\n\n<p>\n(Note that a complex type can also be defined by\n<code><a href='#ComplexRestriction'>restriction</a></code>,\nusing the same tag but with additional possibilities.)&nbsp;\n</p>\n\n\n<h3   id='ByRegularExpression'>By a regular expression</h3>\n\n<p id='pattern'>\nPerl notation is used for the regular expression.&nbsp;\nThe set of values are all those that completely match the pattern.&nbsp;\n</p>\n\n<pre>\n  &lt;xs:simpleType name='vowelString'&gt;\n    &lt;xs:restriction base='xs:string'&gt;\n      &lt;xs:pattern value='[aeiou]+'/&gt;\n    &lt;/xs:restriction&gt;\n  &lt;/xs:simpleType&gt;\n</pre>\n\n<h3   id='byEnumeration'>By enumeration of the restricted set of values</h3>\n\n<p id='enumeration'>\nThe values are given in the <code>value</code> attribute of\n<code><a href='#enumeration'>enumeration</a></code> elements.&nbsp;\n</p>\n\n<pre id='emptySimpleType'>\n  &lt;xs:simpleType name='emptySimpleType'&gt;\n    &lt;xs:restriction base='xs:string'&gt;\n      &lt;xs:enumeration value=''/&gt;\n    &lt;/xs:restriction&gt;\n  &lt;/xs:simpleType&gt;\n\n  &lt;xs:simpleType name='subtractiveColors'&gt;\n    &lt;xs:restriction base='xs:string'&gt;\n      &lt;xs:enumeration value='blue'/&gt;\n      &lt;xs:enumeration value='brown'/&gt;\n      &lt;xs:enumeration value='green'/&gt;\n      &lt;xs:enumeration value='orange'/&gt;\n      &lt;xs:enumeration value='purple'/&gt;\n      &lt;xs:enumeration value='red'/&gt;\n      &lt;xs:enumeration value='yellow'/&gt;\n    &lt;/xs:restriction&gt;\n  &lt;/xs:simpleType&gt;\n\n  &lt;xs:simpleType name='smallSquares'&gt;\n    &lt;xs:restriction base='xs:integer'&gt;\n      &lt;xs:enumeration value='0'/&gt;\n      &lt;xs:enumeration value='1'/&gt;\n      &lt;xs:enumeration value='4'/&gt;\n      &lt;xs:enumeration value='9'/&gt;\n    &lt;/xs:restriction&gt;\n  &lt;/xs:simpleType&gt;\n</pre>\n\n<h3   id='byLength'>By length</h3>\n\n<ul>\n  <li id='minLength'> The length may be limited by a minimum;\n  </li>\n  <li id='maxLength'> or by a maximum;\n  </li>\n  <li id='length'>or to a single value.&nbsp;\n  </li>\n</ul>\n\n<pre>\n  &lt;xs:simpleType name='threeChars'&gt;\n    &lt;xs:restriction base='xs:string'&gt;\n      &lt;xs:length value='3'/&gt;\n    &lt;/xs:restriction&gt;\n  &lt;/xs:simpleType&gt;\n\n  &lt;xs:simpleType name='threeToFiveChars'&gt;\n    &lt;xs:restriction base='xs:string'&gt;\n      &lt;xs:minLength value='3'/&gt;\n      &lt;xs:maxLength value='5'/&gt;\n    &lt;/xs:restriction&gt;\n  &lt;/xs:simpleType&gt;\n</pre>\n\n\n<h2 id='list'>List</h2>\n\n<p>\nList types describe lists of elements of simple type;&nbsp;\nthe lists are represented with whitespace between the elements.&nbsp;\nDefinition of list types is not discussed here.&nbsp;\n</p>\n\n\n<h2 id='union'>Union</h2>\n\n<p>A <code><dfn>union</dfn></code> element defines a new simple type\nthat is the union of two or more other simple types.&nbsp;\nThe new type consists of everything that the component types comprise.&nbsp;\nThe types may be listed by name in the <code>memberTypes</code> attribute,\nor defined in the contents of the\n<code><a href='#union'>union</a></code> element,\nor both.&nbsp;\n</p>\n\n<pre>\n  &lt;xs:simpleType name='vowelsOrColors'&gt;\n    &lt;xs:union memberTypes='vowelString subtractiveColors'/&gt;\n  &lt;/xs:simpleType&gt;\n</pre>\n\n<pre>\n  &lt;xs:simpleType name='vowelsOrColors2'&gt;\n    &lt;xs:union memberTypes='subtractiveColors'&gt;\n     &lt;xs:simpleType&gt;\n        &lt;xs:restriction base='xs:string'&gt;\n          &lt;xs:pattern value='[aeiou]+'/&gt;\n        &lt;/xs:restriction&gt;\n      &lt;/xs:simpleType&gt;\n    &lt;/xs:union&gt;\n  &lt;/xs:simpleType&gt;\n</pre>\n\n\n\n<h2 id='PredefinedTypes'>Predefined types</h2>\n\n<p>\nAll predefined types are simple content\nexcept for <code>anyType</code>, the supertype of all types.&nbsp;\n</p>\n\n<dl class='code'>\n  <dt id='anySimpleType'><code>xs:<dfn>anySimpleType</dfn></code></dt>\n    <dd>The supertype of all simple types,\n      provided for use when deriving a type\n      if no other supertype will do.&nbsp;\n    </dd>\n  <dt id='string'><code>xs:<dfn>string</dfn></code></dt>\n    <dd>Strings of printable <a href='#character-data'>character data</a>.&nbsp;\n      <dl class='code'>\n        <dt id='normalizedString'><code>xs:<dfn>normalizedString</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#string'>string</a></code>, but\n            the only whitespace characters are spaces\n            (on input, other whitespace is replaced by spaces).\n            <dl class='code'>\n              <dt id='token'><code>xs:<dfn>token</dfn></code></dt>\n                <dd>Like <code>xs:<a href='#normalizedString'>normalizedString</a></code>,\n                  but\n                  leading spaces,\n                  sequences of two or more spaces,\n                  and trailing spaces\n                  are not allowed\n                  (on input, sequences are collapsed to single spaces\n                  and leading and trailing space is removed),\n                </dd>\n            </dl>\n          </dd>\n        <dt id='NMTOKEN'><code>xs:<dfn>NMTOKEN</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#string'>string</a></code>\n            but restricted to name characters\n            <code>[-_:.A-Za-z0-9]*</code>.\n            <dl class='code'>\n              <dt id='Name'><code>xs:<dfn>Name</dfn></code></dt>\n                <dd>Like <code>xs:<a href='#NMTOKEN'>NMTOKEN</a></code>\n                  but restricted to begin with a letter, colon, or underscore\n                  <code>[_:A-Za-z][-_:.A-Za-z0-9]*</code>.&nbsp;\n                  <br/>(If you want a name in the usual sense,\n                  you probably want an\n                  <code>xs:<a href='#NCName'>NCName</a></code>.)&nbsp;\n                  <dl class='code'>\n                    <dt id='QName'><code>xs:<dfn>QName</dfn></code></dt>\n                      <dd>A qualified name.&nbsp;\n                        Like <code>xs:<a href='#Name'>Name</a></code> but\n                        can't start with a colon,\n                        and at most one colon is allowed.&nbsp;\n                        For example, the string\n                        '<code>xs:<a href='#QName'>QName</a></code>'\n                        is an <code>xs:<a href='#QName'>QName</a></code>.&nbsp;\n                      </dd>\n                    <dt id='NCName'><code>xs:<dfn>NCName</dfn></code></dt>\n                      <dd>Like <code>xs:<a href='#Name'>Name</a></code> but\n                        no colons allowed\n                        <code>[_A-Za-z][-_.A-Za-z0-9]*</code>.&nbsp;\n                        <br/>(This datatype is closest to\n                        what one ordinarily thinks of as a name.)&nbsp;\n                        <dl class='code'>\n                          <dt id='ID'><code>xs:<dfn>ID</dfn></code></dt>\n                            <dd>Like <code>xs:<a href='#NCName'>NCName</a></code>\n                              but programs processing an XML file must check that\n                              each attribute value and simple type element value\n                              of this type\n                              is unique within the document containing them.&nbsp;\n                            </dd>\n                          <dt id='IDREF'><code>xs:<dfn>IDREF</dfn></code></dt>\n                            <dd>Like <code>xs:<a href='#NCName'>NCName</a></code>\n                              but programs processing an XML file must check that\n                              each attribute value and simple type element value\n                              of this type\n                              is also an attribute or simple type element value\n                              of type <code>xs:<a href='#ID'>ID</a></code>\n                              in the same file.&nbsp;\n                            </dd>\n                        </dl>\n                      </dd>\n                  </dl>\n                </dd>\n            </dl>\n          </dd>\n        <dt id='language'><code>xs:<dfn>language</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#string'>string</a></code>\n            but restricted to be language codes\n            (such as <code>en</code>, <code>fr</code>, etc.).\n          </dd>\n        <dt id='anyURI'><code>xs:<dfn>anyURI</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#string'>string</a></code>\n            but restricted to be URIs;&nbsp;\n            for example '<code>http://www.w3.org/2001/XMLSchema</code>'.&nbsp;\n          </dd>\n      </dl>\n    </dd>\n  <dt id='boolean'><code>xs:<dfn>boolean</dfn></code></dt>\n    <dd>A boolean value.&nbsp;\n      'true', 'false', '1', or '0'.&nbsp;\n    </dd>\n\n  <dt id='decimal'><code>xs:<dfn>decimal</dfn></code></dt>\n    <dd>A decimal number.&nbsp;\n      Like <code>xs:<a href='#string'>string</a></code>\n      but restricted to be\n      <code>[-+]?[0-9]+(.[0-9]+)</code> or\n      <code>[-+]?[0-9]*.[0-9]+</code>.&nbsp;\n      <dl class='code'>\n        <dt id='integer'><code>xs:<dfn>integer</dfn></code></dt>\n          <dd>A decimal number with no fractional digits.&nbsp;\n            Like <code>xs:<a href='#decimal'>decimal</a></code>\n            but restricted to be\n            <code>[-+]?[0-9]+</code>.&nbsp;\n            Has these self-explanatory subtypes:&nbsp;\n            <code id='byte'>xs:<dfn>byte</dfn></code>,\n            <code id='int'>xs:<dfn>int</dfn></code>,\n            <code id='long'>xs:<dfn>long</dfn></code>,\n            <code id='negativeInteger'>xs:<dfn>negativeInteger</dfn></code>,\n            <code id='nonNegativeInteger'>xs:<dfn>nonNegativeInteger</dfn></code>,\n            <code id='nonPositiveInteger'>xs:<dfn>nonPositiveInteger</dfn></code>,\n            <code id='positiveInteger'>xs:<dfn>positiveInteger</dfn></code>,\n            <code id='short'>xs:<dfn>short</dfn></code>,\n            <code id='unsignedByte'>xs:<dfn>unsignedByte</dfn></code>,\n            <code id='unsignedInt'>xs:<dfn>unsignedInt</dfn></code>,\n            <code id='unsignedLong'>xs:<dfn>unsignedLong</dfn></code>,\n            <code id='unsignedShort'>xs:<dfn>unsignedShort</dfn></code>.&nbsp;\n          </dd>\n        <dt id='float'><code>xs:<dfn>float</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#decimal'>decimal</a></code>\n            but with an optional <code>E[-+]?[0-9]+</code> on the end,\n            plus also the speciol values\n            <code>INF</code>,\n            <code>-INF</code>, and\n            <code>NaN</code>.&nbsp;\n            There is also <code id='double'>xs:<dfn>double</dfn></code>,\n            just like <code>xs:<a href='#float'>float</a></code> but can be twice as long,&nbsp;\n          </dd>\n        <dt id='binary'><code>xs:<dfn>binary</dfn></code></dt>\n          <dd>Values are <code>true</code>, <code>false</code>,\n            <code>1</code>, and <code>0</code>.&nbsp;\n          </dd>\n      </dl>\n    </dd>\n\n  <dt id='dateTime'><code>xs:<dfn>dateTime</dfn></code></dt>\n    <dd>A date and time of the form\n      <code>CCYY<b>-</b>MM<b>-</b>DD<b>T</b>hh<b>:</b>mm<b>:</b>ss</code>.&nbsp;\n      The hyphens, T, and colons are required.&nbsp;\n      Fractional seconds and a time zone\n      (Z or a time offset such as +05:00) are allowed.&nbsp;\n      <dl class='code'>\n        <dt id='date'><code>xs:<dfn>date</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#dateTime'>dateTime</a></code>\n            but without hours, minutes, or seconds\n            (time zone is still allowed).&nbsp;\n          </dd>\n        <dt id='gDay'><code>xs:<dfn>gDay</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#dateTime'>dateTime</a></code>\n            but without century, year, month,\n            hour, minute, or second\n            (time zone is still allowed).&nbsp;\n          </dd>\n        <dt id='gMonth'><code>xs:<dfn>gMonth</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#dateTime'>dateTime</a></code>\n            but without century, year, day,\n            hour, minute, or second\n            (time zone is still allowed).&nbsp;\n          </dd>\n        <dt id='gMonthDay'><code>xs:<dfn>gMonthDay</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#dateTime'>dateTime</a></code>\n            but without century, year,\n            hour, minute, or second\n            (time zone is still allowed).&nbsp;\n          </dd>\n        <dt id='gYear'><code>xs:<dfn>gYear</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#gYearMonth'>gYearMonth</a></code>\n            but without the month\n            (time zone is still allowed).&nbsp;\n          </dd>\n        <dt id='gYearMonth'><code>xs:<dfn>gYearMonth</dfn></code></dt>\n          <dd>A Gregorian year and month (thus the 'g').&nbsp;\n            Like <code>xs:<a href='#date'>date</a></code> but without the day\n            (time zone is still allowed).&nbsp;\n          </dd>\n        <dt id='time'><code>xs:<dfn>time</dfn></code></dt>\n          <dd>Like <code>xs:<a href='#dateTime'>dateTime</a></code>\n            but without century, year, month, or day\n            (time zone is still allowed).&nbsp;\n          </dd>\n      </dl>\n    </dd>\n\n  <dt id='duration'><code>xs:<dfn>duration</dfn></code></dt>\n    <dd>A duration of the form\n      <code>xs:<b>P</b>nYnMnD<b>T</b>nHnMnS</code>.&nbsp;\n      The P is required, and the T is required\n      if any of the later elements are present.&nbsp;\n      Each nX substring represents a number and a unit\n      (years, months, days, etc.);&nbsp;\n      the number of seconds can be <code>xs:<a href='#decimal'>decimal</a></code>,\n      the number of any other unit must be\n      <code>xs:<a href='#integer'>integer</a></code>.&nbsp;\n    </dd>\n</dl>\n\n<p>\nNot discussed here:&nbsp;\nbase64Binary, ENTITY, ENTITIES, hexBinary, IDREFS, NMTOKENS, NOTATION.&nbsp;\n</p>\n\n\n<h1 id='complexType'>Complex type</h1>\n\n<p>\nA <code><dfn>complexType</dfn></code> element must contain\nan element of one of these kinds:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#simpleContent'>simpleContent</a></code>,\n  </li>\n  <li> <code><a href='#complexContent'>complexContent</a></code>,\n  </li>\n  <li> any <a href='#Compositor'>compositor</a>\n      (<code><a href='#all'>all</a></code>,\n        <code><a href='#choice'>choice</a></code>, or\n        <code><a href='#sequence'>sequence</a></code>), or\n  </li>\n  <li> a <code><a href='#group'>group</a></code>.&nbsp;\n  </li>\n</ul>\n\n<p>\nIn addition,\na <code><a href='#complexType'>complexType</a></code> element may contain\nelements of these kinds:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#attribute'>attribute</a></code> (any number of these),\n  </li>\n  <li> <code><a href='#attributeGroup'>attributeGroup</a></code>\n      (any number of these), and/or\n  </li>\n  <li> <code><a href='#anyAttribute'>anyAttribute</a></code>.\n  </li>\n</ul>\n\n<table>\n<tbody>\n  <tr>\n    <th>A <code><a href='#complexType'>complexType</a></code>\n        may <br/>be defined to have:</th>\n    <th>by giving it:</th>\n  </tr>\n  <tr>\n    <th><a href='#EmptyContent'>empty content</a></th>\n    <td>an empty\n        <code><a href='#complexContent'>complexContent</a></code> element\n        with no <code>mixed='true'</code> attribute\n        (<a href='#emptyComplexType'>example</a>)</td>\n  </tr>\n  <tr>\n    <th><a href='#SimpleContent'>simple content</a></th>\n    <td>a <code><a href='#simpleContent'>simpleContent</a></code> element</td>\n  </tr>\n  <tr>\n    <th><a href='#ComplexContent'>complex content</a></th>\n    <td>a non-empty\n        <code><a href='#complexContent'>complexContent</a></code> element,\n        or a <a href='#Compositor'>compositor</a>\n        or <a href='#Particle'>particle</a></td>\n  </tr>\n  <tr>\n    <th><a href='#MixedContent'>mixed content</a></th>\n    <td><a href='#complexContent'>complex content</a> and\n        the <code>mixed='true'</code> attribute.&nbsp;</td>\n  </tr>\n</tbody>\n</table>\n\n<p>\nFor simplicity,\nwe will say a complex type is\n</p>\n\n<ul>\n  <li id='Complex-Simple'> <dfn>complex-simple</dfn>\n      if it has empty or simple content,\n      and\n  </li>\n  <li id='Complex-Complex'> <dfn>complex-complex</dfn>\n      if it has complex or mixed content.&nbsp;\n  </li>\n</ul>\n\n<h2 id='simpleContent'>Simple content</h2>\n\n<p>\nA\n<code><dfn>simpleContent</dfn></code>\nelement of a\n<code><a href='#complexType'>complexType</a></code> element must contain\nan element of either of these kinds:&nbsp;\n </p>\n\n<ul>\n  <li> an <code><a href='#extension'>extension</a></code>\n      of a <a href='#simpleType'>simple type</a>\n      (without adding child elements), or\n  </li>\n  <li> a <code><a href='#ComplexRestriction'>restriction</a></code>\n      of a <a href='#simpleType'>simple type</a>.&nbsp;\n  </li>\n</ul>\n\n<h2 id='complexContent'>Complex content</h2>\n\n<p>\nA\n<code><dfn>complexContent</dfn></code>\nelement of a\n<code><a href='#complexType'>complexType</a></code> element must contain\nan element of either of these kinds:&nbsp;\n</p>\n\n<ul>\n  <li> an <code><a href='#extension'>extension</a></code>\n      of a <a href='#simpleType'>simple</a>\n      or <a href='#complexType'>complex type</a>, or\n  </li>\n  <li> a <code><a href='#ComplexRestriction'>restriction</a></code>\n      of a <a href='#simpleType'>simple</a>\n      or <a href='#complexType'>complex type</a>.&nbsp;\n  </li>\n</ul>\n\n<p>\nIf the <code>mixed='true'</code> attribute is given,\nthe contents may include <a href='#character-data'>character data</a>\nas well as child elements;&nbsp;\notherwise,\nit may only include child elements.&nbsp;\n</p>\n\n\n<h2 id='extension'>Extension</h2>\n\n<p>\nAn <code><dfn>extension</dfn></code> element\ncreates a new type by adding elements and/or attributes to\na <a href='#simpleType'>simple</a> or <a href='#complexType'>complex type</a>.&nbsp;\n</p>\n\n<ul>\n  <li> The type to extend must be defined at the <a href='#TopLevel'>top level</a>\n      and have a <code><a href='#name'>name</a></code>.&nbsp;\n  </li>\n  <li> The type to extend is identified using the\n      <code><a href='#extension'>extension</a></code> element's\n      <code><a href='#base'>base</a></code> attribute.&nbsp;\n  </li>\n  <li> Elements are added using a\n      <code><a href='#group'>group</a></code>,\n      <code><a href='#all'>all</a></code>,\n      <code><a href='#choice'>choice</a></code>, or\n      <code><a href='#sequence'>sequence</a></code> element\n      in the contents of the <code><a href='#extension'>extension</a></code>.&nbsp;\n  </li>\n  <li> Attributes are added using\n      <code><a href='#attribute'>attribute</a></code> and/or\n      <code><a href='#attributeGroup'>attributeGroup</a></code> elements or an\n      <code><a href='#anyAttribute'>anyAttribute</a></code> element\n      in the contents of the <code><a href='#extension'>extension</a></code>.&nbsp;\n  </li>\n</ul>\n\n<p id='emptyComplexType'>\nExample:&nbsp;\n</p>\n\n<pre>\n  &lt;xs:complexType name='emptyComplexType'/&gt;\n\n  &lt;xs:complexType name='vowelStringInLanguage'&gt;\n    &lt;xs:complexContent&gt;\n      &lt;xs:extension base='emptyComplexType'&gt;\n        &lt;xs:attribute name='vowels' type='vowelString'&lt;/a&gt;/&gt;\n        &lt;xs:attribute name='language' type='xs:language'/&gt;\n      &lt;/xs:extension&gt;\n    &lt;/xs:complexContent&gt;\n  &lt;/xs:complexType&gt;\n</pre>\n\n\n<h2 id='ComplexRestriction'>Restriction (of a complex type)</h2>\n\n<p>\nA new complex type may be derived by from an existing\n<a href='#Complex-Simple'>complex-simple type</a> by\n<a href='#ComplexRestrictionSimpleContent'>restriction</a>,\nin all the ways that\na simple type can be derived from an existing simple type\n(see <code><a href='#restriction'>restriction</a></code> for simple types).&nbsp;\n</p>\n\n<p>\nIn addition,\na new complex type may be derived by from an existing\n<a href='#Complex-Complex'>complex-complex type</a> by\na <a href='#ComplexRestrictionComplexContent'>restriction</a>\nthat reduces the child elements allowed\nor the type of a child element.&nbsp;\n</p>\n\n<p>\nIn either case,\nthe restriction of a complex type\ncan reduce the scope of one or more attributes of the type.&nbsp;\n</p>\n\n\n<h3   id='ComplexRestrictionSimpleContent'>Restriction (of a complex-simple type)</h3>\n\n<p>\nThe <a href='#character-data'>character data</a>\nallowed for a complex type with simple content\nmay be restricted in all the ways that a simple type can\n(see <code><a href='#restriction'>restriction</a></code> of simple types).&nbsp;\nIn addition,\nthe types of attributes for the complex type\nmay be restricted.&nbsp;\n</p>\n\n<ul>\n  <li> The <code><a href='#ComplexRestrictionSimpleContent'>restriction</a></code>\n    may contain\n    <code><a href='#attribute'>attribute</a></code> elements (any number of these),\n    <code><a href='#attributeGroup'>attributeGroup</a></code> elements (any number of these),\n    and/or an\n    <code><a href='#anyAttribute'>anyAttribute</a></code> element.&nbsp;\n  </li>\n  <li> The attributes named in these elements\n    must be attributes of the base type being restricted.&nbsp;\n  </li>\n  <li> The type assigned to an attribute by these elements\n    must be the same or a restriction\n    of the type assigned to that attribute by the base type.&nbsp;\n  </li>\n  <li> Any attribute of the base type\n    that is not named in the\n    <code><a href='#ComplexRestrictionSimpleContent'>restriction</a></code>\n    is assumed to have the same type as it did in the base type.&nbsp;\n  </li>\n  <li> To exclude a base type attribute,\n    give it the <code><a href='#UseProhibited'>use=prohibited</a></code>\n    attribute in the restricted type.&nbsp;\n  </li>\n</ul>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n\n<h3   id='ComplexRestrictionComplexContent'>Restriction (of a complex-complex type)</h3>\n\n<p>\nThe <a href='#character-data'>character data</a>\nand attributes allowed for a complex type with complex content\nmay be restricted in all the ways that a simple type\nor complex type with simple content can\n(see\n<code><a href='#restriction'>restriction</a></code> of simple types and\n<code><a href='#ComplexRestrictionSimpleContent'>restriction</a></code>\nof simple content).&nbsp;\nIn addition,\nthe child elements of the type may be restricted.&nbsp;\n</p>\n\n<ul>\n  <li> The <code><a href='#ComplexRestrictionComplexContent'>restriction</a></code>\n    may contain\n    <code><a href='#group'>group</a></code>,\n    <code><a href='#all'>all</a></code>,\n    <code><a href='#choice'>choice</a></code>, or\n    <code><a href='#sequence'>sequence</a></code> elements.&nbsp;\n  </li>\n  <li> These elements must be the same or a subset\n    of the ones appearing in the base type.&nbsp;\n  </li>\n  <li> The type assigned to each element must be the same\n    or a restriction of the type assigned to that element in the base type.&nbsp;\n  </li>\n  <li> An element of the base type\n    may be excluded from the restricted type (unlike attributes).&nbsp;\n    If an element is not listed in the restriction,\n    that element may not appear in instances of the new type.&nbsp;\n  </li>\n</ul>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n<h2 id='Compositor'>Compositors <code>all</code>, <code>choice</code>, and <code>sequence</code></h2>\n\n<p>\n<code><a href='#all'>all</a></code>,\n<code><a href='#choice'>choice</a></code>, and\n<code><a href='#sequence'>sequence</a></code>\nare the XML Schema <dfn>compositors</dfn>,\nuseful in that they allow a composition of more than one\n<a href='#Particle'>particle</a>\nwhere a single <a href='#Particle'>particle</a> could otherwise appear.&nbsp;\n</p>\n\n\n<h3   id='all'><code>all</code></h3>\n\n<p>\n<code><dfn>all</dfn></code> is not discussed here;&nbsp;\nit does not appear useful in ordinary situations.&nbsp;\n</p>\n\n\n<h3   id='choice'><code>choice</code></h3>\n\n<p>\nA <code><dfn>choice</dfn></code> compositor\nlists mutually exclusive child elements\nthat may appear where the compositor does.&nbsp;\n</p>\n\n<ul>\n  <li> A  <code><a href='#choice'>choice</a></code> may contain\n    <code><a href='#element'>element</a></code>,\n    <code><a href='#any'>any</a></code>,\n    <code><a href='#group'>group</a></code>,\n    <code><a href='#choice'>choice</a></code>, and/or\n    <code><a href='#sequence'>sequence</a></code> elements.&nbsp;\n  </li>\n  <li> These sub-elements may be given\n    <code><a href='#minOccurs'>minOccurs</a></code> and/or\n    <code><a href='#maxOccurs'>maxOccurs</a></code> attributes\n    to indicate how many instances of them\n    must appear if that sub-element is chosen.&nbsp;\n  </li>\n  <li> If the <code><a href='#choice'>choice</a></code> is not\n    an element of a <code><a href='#group'>group</a></code>,\n    it may itself be given <code><a href='#minOccurs'>minOccurs</a></code>\n    and <code><a href='#maxOccurs'>maxOccurs</a></code>\n    attributes, so that it can represent\n    a range of numbers of choices from the sub-elements\n    rather than a single choice.&nbsp;\n  </li>\n</ul>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n\n<h3   id='sequence'><code>sequence</code></h3>\n\n<p>\nA <code><dfn>sequence</dfn></code> compositor\nlists child elements\nthat must appear where the compositor does\nin the sequence in which they are listed.&nbsp;\n</p>\n\n<ul>\n  <li> A  <code><a href='#sequence'>sequence</a></code> may contain\n    <code><a href='#element'>element</a></code>,\n    <code><a href='#any'>any</a></code>,\n    <code><a href='#group'>group</a></code>,\n    <code><a href='#choice'>choice</a></code>, and/or\n    <code><a href='#sequence'>sequence</a></code> elements.&nbsp;\n  </li>\n  <li> These sub-elements may be given\n    <code><a href='#minOccurs'>minOccurs</a></code> and/or\n    <code><a href='#maxOccurs'>maxOccurs</a></code> attributes\n    to indicate how many instances of them\n    must appear there in the sequence.&nbsp;\n  </li>\n  <li> If the <code><a href='#sequence'>sequence</a></code> is not\n    an element of a <code><a href='#group'>group</a></code>,\n    it may itself be given <code><a href='#minOccurs'>minOccurs</a></code>\n    and <code><a href='#maxOccurs'>maxOccurs</a></code>\n    attributes, so that it can represent\n    a range of numbers of sequences of the elements\n    rather than a single sequence.&nbsp;\n  </li>\n</ul>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n\n<h2 id='Particle'>Particles <code>any</code> and <code>group</code></h2>\n\n<p>\n<code><a href='#element'>element</a></code>,\n<code><a href='#any'>any</a></code>,\n<code><a href='#group'>group</a></code>,\nand the <a href='#Compositor'>compositors</a>\n<code><a href='#choice'>choice</a></code> and\n<code><a href='#sequence'>sequence</a></code>\nare the XML Schema <dfn>particles</dfn>.&nbsp;\nA particle is used in a <a href='#Compositor'>compositor</a>\nto define a part of a <a href='#complexType'>complexType</a>.&nbsp;\n</p>\n\n<p>\nAny particle can have a\n<code><a href='#minOccurs'>minOccurs=</a></code> and/or\n<code><a href='#maxOccurs'>maxOccurs=</a></code> attribute,\nas long as it is not appearing in a <code><a href='#group'>group</a></code>.&nbsp;\n</p>\n\n\n<h3   id='any'><code>any</code></h3>\n\n<p>\nThe <code><dfn>any</dfn></code> element\nrepresents any element in a specified namespace.&nbsp;\n</p>\n\n<p id='namespace'>\nIts <code>namespace</code> attribute\nhas several possible values:\n</p>\n\n<ul>\n  <li> A whitespace-separated list of one or more URIs,\n      possibly including the special values\n      <code>##targetNamespace</code> for the\n      <a href='#targetNamespace'>target namespace</a> specified in\n      the schema element, and/or\n      <code>##local</code> for elements defined in the schema\n      but not appearing with a namespace prefix.&nbsp;\n  </li>\n  <li> <code>##any</code>, which causes the\n      <code><a href='#any'>any</a></code> element to represent\n      elements from any namespace\n      (this is the default).&nbsp;\n  </li>\n  <li> <code>##other</code>, which causes the\n      <code><a href='#any'>any</a></code> element to represent\n      elements from namespaces other than the\n      <a href='#targetNamespace'>target namespace</a>,\n      or from any namespace if the schema specifies no target namespace.&nbsp;\n  </li>\n</ul>\n\n<p>\nAn <code><a href='#any'>any</a></code> element\nmust be empty.&nbsp;\n</p>\n\n<p>\nThere is also <code><a href='#anyAttribute'>anyAttribute</a></code>\nfor attributes.&nbsp;\n</p>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n\n<h3   id='group'><code>group</code></h3>\n\n<p>\nA <code><dfn>group</dfn></code> is a named set of\n<code><a href='#element'>elements</a></code>.&nbsp;\nA named <code><a href='#group'>group</a></code> must be defined\nat the <a href='#TopLevel'>top level</a> (contained only by the\n<code><a href='#schema'>schema</a></code> element)\nand given a name using its <code><a href='#name'>name</a></code> attribute,\nas in this examples:\n</p>\n\n<pre>\n  &lt;xs:group name='groupSubtractiveColorsWithLanguage'&gt;\n    &lt;xs:sequence&gt;\n      &lt;xs:element name='subtractiveColor' type='subtractiveColors'/&gt;\n      &lt;xs:element name='language' type='xs:language'/&gt;\n    &lt;/xs:sequence&gt;\n  &lt;/xs:group&gt;\n</pre>\n\n<p>\nThe named <code><a href='#group'>group</a></code>\ncan then be referenced by an <a href='#EmptyElement'>empty-element</a>\n<code><a href='#group'>group</a></code> tag\nusing its <code><a href='#ref'>ref</a></code> attribute,\nand the effect is as if\nthe contents of the group appeared at that point.&nbsp;\n</p>\n\n<p>\nThis example defines two equivalent complex types,\nthe first using a group and the second directly:\n</p>\n\n<pre>\n  &lt;xs:complexType name='SubtractiveColorsWithLanguage'&gt;\n    &lt;xs:group ref='groupSubtractiveColorsWithLanguage'/&gt;\n  &lt;/xs:complexType&gt;\n\n  &lt;xs:complexType name='subtractiveColorAndLanguage'&gt;\n    &lt;xs:sequence&gt;\n      &lt;xs:element name='subtractiveColor' type='subtractiveColors'/&gt;\n      &lt;xs:element name='language' type='xs:language'/&gt;\n    &lt;/xs:sequence&gt;\n  &lt;/xs:complexType&gt;\n</pre>\n\n<ul>\n  <li> A <code><a href='#group'>group</a></code> may contain\n    <code><a href='#element'>element</a></code>,\n    <code><a href='#group'>group</a></code>,\n    <code><a href='#all'>all</a></code>,\n    <code><a href='#choice'>choice</a></code>, and\n    <code><a href='#sequence'>sequence</a></code> elements.&nbsp;\n  </li>\n  <li> The child elements of a <code><a href='#group'>group</a></code>\n    may not have either\n    the <code><a href='#minOccurs'>minOccurs</a></code> or\n    the <code><a href='#maxOccurs'>maxOccurs</a></code> attributes.&nbsp;\n  </li>\n  <li> A <code><a href='#group'>group</a></code> definition\n    may not have either\n    the <code><a href='#minOccurs'>minOccurs</a></code> or\n    the <code><a href='#maxOccurs'>maxOccurs</a></code> attributes,\n    but an empty-element <code><a href='#group'>group</a></code>\n    referring to a named group may have them\n    (unless it appears within a <code><a href='#group'>group</a></code> itself).&nbsp;\n  </li>\n</ul>\n\n<p>\nThere are also\n<a href='#attributeGroup'>attributeGroup</a>s.&nbsp;\n</p>\n\n\n<h2 id='attribute'>Attribute for a complex type</h2>\n\n<p>\nA <code><a href='#complexType'>complexType</a></code> is given an\nattribute by giving it an <code><dfn>attribute</dfn></code> child element.&nbsp;\n</p>\n\n<p>\nAttributes may be\n<a href='#AttributeDefinition'>defined globally</a>,\n<a href='#AttributeReference'>referenced</a>, or\n<a href='#AttributeLocal'>defined locally</a>.&nbsp;\n</p>\n\n\n<h3   id='AttributeDefinition'>Global definition of an attribute</h3>\n\n<p>\nAttributes may be named and defined at the <a href='#TopLevel'>top level</a>,\nand then referenced by name elsewhere.&nbsp;\nSuch definitions may contain these attributes:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#default'>default</a></code> giving the default value\n      (an <code>xs:<a href='#string'>string</a></code>)\n      of the attribute\n      that is used for any element in which the attribute can appear\n      but does not.&nbsp;\n  </li>\n  <li> <code><a href='#fixed'>fixed</a></code> giving a single value\n      (an <code>xs:<a href='#string'>string</a></code>)\n      that is the only value the attribute may be given;&nbsp;\n      the attribute then must either appear with that value,\n      or not appear.&nbsp;\n      <code>fixed</code> and <code>default</code>\n      are mutually exclusive.&nbsp;\n  </li>\n  <li> <code><a href='#name'>name</a></code>,\n      the name of the defined attribute in any element it is part of,\n      and also the name by which this definition is referenced.&nbsp;\n  </li>\n  <li> <code><a href='#type'>type</a></code>,\n      the type of the defined attribute's value.&nbsp;\n      This attribute can't appear if a type is given in the body of the\n      <code><a href='#attribute'>attribute</a></code> element.&nbsp;\n  </li>\n</ul>\n\n<p>\nThe type of the attribute's value\nis given either\nby a <code><a href='#type'>type</a></code> attribute of the definition\nor by a <code><a href='#simpleType'>simpleType</a></code> child element\nof the definition.&nbsp;\n</p>\n\n\n<h3   id='AttributeReference'>Reference to a global definition of an attribute</h3>\n\n<p>\nA defined attribute may be given to an element or element type\nby a child empty-element <code><a href='#attribute'>attribute</a></code>.&nbsp;\nThe empty-element <code><a href='#attribute'>attribute</a></code>\nmay have these attributes:\n</p>\n\n<ul>\n  <li> <code><a href='#ref'>ref</a></code>\n    specifying the attribute definition;&nbsp; required.&nbsp;\n  </li>\n  <li id='use'> <code>use</code>, which may have one of these values:&nbsp;\n    <ul>\n      <li id='UseProhibited'> <code>use=prohibited</code>,\n        meaning the attribute may not appear\n        (useful in\n        <code><a href='#ComplexRestrictionSimpleContent'\n        >restrictions</a></code>).&nbsp;\n      </li>\n      <li> <code>use=optional</code>:&nbsp; this is the default.&nbsp;\n      </li>\n      <li> <code>use=required</code>.&nbsp;\n      </li>\n    </ul>\n  </li>\n  <li id='AttributeForm'> <code>form=qualified</code> (if the attribute name\n    must be qualified with the namespace when appearing in\n    the element or type) or\n    <code>form=unqualified</code> if not.&nbsp;\n    The default is set by the <code><a href='#schema'>schema</a></code>\n    element's\n    <code><a href='#attributeFormDefault'>attributeFormDefault</a></code>\n    attribute.&nbsp;\n  </li>\n</ul>\n\n\n<h3   id='AttributeLocal'>Local definition of an attribute</h3>\n\n<p>\nAn attribute may be given to an element or element type\nby an <code><a href='#attribute'>attribute</a></code> element\nthat gives the name and type of the attribute directly.&nbsp;\nThe local definition can have these attributes:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#default'>default</a></code>\n  </li>\n  <li> <code><a href='#fixed'>fixed</a></code>\n  </li>\n  <li> <code><a href='#AttributeForm'>form</a></code>\n  </li>\n  <li> <code><a href='#name'>name</a></code> giving the name of the attribute;&nbsp;\n    a local definition can't be referenced elsewhere by its name.&nbsp;\n  </li>\n  <li> <code><a href='#type'>type</a></code>\n  </li>\n  <li> <code><a href='#use'>use</a></code>\n  </li>\n</ul>\n\n<p>\nIt may not have a <code><a href='#ref'>ref</a></code> attribute.&nbsp;\n</p>\n\n<p>\nThe type of the attribute's value\nis given either\nby a <code><a href='#type'>type</a></code> attribute of the definition\nor by a <code><a href='#simpleType'>simpleType</a></code> child element\nof the definition.&nbsp;\n</p>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n\n<h2 id='attributeGroup'>Attribute group</h2>\n\n<p>\nAn <dfn>attribute group</dfn> is a named set of\n<code><a href='#attribute'>attributes</a></code>.&nbsp;\nLike a <code><a href='#group'>group</a></code>,\nit must be defined at the <a href='#TopLevel'>top level</a>\nand can be referenced elsewhere.&nbsp;\nAn <code><a href='#attributeGroup'>attributeGroup</a></code>\nmay contain\n<code><a href='#attribute'>attribute</a></code> and/or\n<code><a href='#attributeGroup'>attributeGroup</a></code>\nelements.&nbsp;\nAn <code><a href='#attributeGroup'>attributeGroup</a></code>\ndefinition must have a <code><a href='#name'>name</a></code> attribute,\nand a <code><a href='#attributeGroup'>attributeGroup</a></code>\nreference must be empty\nand have a <code><a href='#ref'>ref</a></code> attribute.&nbsp;\n</p>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n<p>\nSee <code><a href='#group'>group</a></code>.&nbsp;\n</p>\n\n\n<h2 id='anyAttribute'>Any attribute allowed</h2>\n\n<p>\nThe <code><dfn>anyAttribute</dfn></code> element\nrepresents any attribute in a specified namespace.&nbsp;\nAn <code><a href='#anyAttribute'>anyAttribute</a></code> element\nmay have a <code><a href='#namespace'>namespace</a></code> attribute,\nand must be empty.&nbsp;\nIt is analogous to <code><a href='#any'>any</a></code>\nfor elements.&nbsp;\n</p>\n\n<p>\nExamples:&nbsp; <span class='FW'>(under construction)</span>\n</p>\n\n\n<h1 id='CommonAttributes'>Attributes common to several schema elements</h1>\n\n<p>\nMany of the XML Schema elements\nshare the same attributes.&nbsp;\nSome of those are described here.&nbsp;\n</p>\n\n\n<h2   id='base'><code>base</code></h2>\n\n<p>\n<code><dfn>base</dfn></code> is used to refer to\na simpleType or complexType\nthat is being extended or restricted.&nbsp;\nIt is similar to <code><a href='#ref'>ref</a></code>\nand <code><a href='#type'>type</a></code>\nbut is only used to reference base types.&nbsp;\n</p>\n\n<p>\nThe type of a <code><a href='#base'>base</a></code> value\nis <code>xs:<a href='#NCName'>NCName</a></code>.&nbsp;\n</p>\n\n\n<h2   id='default'><code>default</code></h2>\n\n<p><code><dfn>default</dfn></code> indicates the default value\nof an attribute or element;&nbsp;\nthe default value is assumed\nfor an attribute that does not appear,\nor for an element with <a href='#EmptyContent'>empty content</a>.&nbsp;\nThe only elements for which it is allowed\nare those with <a href='#SimpleContent'>simple content</a>,\nas values of <a href='#ComplexContent'>complex content</a> cannot be given\nin an attribute value.&nbsp;\n</p>\n\n<p>\n<code><a href='#default'>default</a></code> and\n<code><a href='#fixed'>fixed</a></code> may not appear together.&nbsp;\n</p>\n\n\n<h2   id='fixed'><code>fixed</code></h2>\n\n<p><code><dfn>fixed</dfn></code> indicates an attribute or element\nthat can only have one value;&nbsp;\nthat value is given by the value of the\n<code><a href='#fixed'>fixed</a></code> attribute.&nbsp;\nThe only elements for which it is allowed\nare those with <a href='#SimpleContent'>simple content</a>,\nas values of <a href='#ComplexContent'>complex content</a> cannot be given\nin an attribute value.&nbsp;\n</p>\n\n<p>\n<code><a href='#default'>default</a></code> and\n<code><a href='#fixed'>fixed</a></code> may not appear together.&nbsp;\n</p>\n\n\n<h2   id='maxOccurs'><code>maxOccurs</code></h2>\n\n<p><code><dfn>maxOccurs</dfn></code> indicates the maximum number of times\nan instance represented by the element may appear.&nbsp;\nIf the <code><a href='#maxOccurs'>maxOccurs</a></code> attribute is not given,\n1 is assumed.&nbsp;\n<code><a href='#maxOccurs'>maxOccurs</a></code> may be given\nany non-negative integer value,\nand also the special value <code>unbounded</code>.&nbsp;\n</p>\n\n<p>\nThe value of <code><a href='#minOccurs'>minOccurs</a></code>\n(assumed or explicit)\nmust not be greater than\nthe value of <code><a href='#maxOccurs'>maxOccurs</a></code>\n(assumed or explicit).&nbsp;\n</p>\n\n<p>\nExamples:\n</p>\n\n<pre>\n  &lt;xs:group name='OccursExample'&gt;\n    &lt;xs:sequence&gt;\n      &lt;xs:element name='Default'/&gt;\n      &lt;xs:element name='SameAsDefault'  minOccurs='1' maxOccurs='1'/&gt;\n      &lt;xs:element name='ZeroOrOneTimes' minOccurs='0'/&gt;\n      &lt;xs:element name='OnceOrTwice'                  maxOccurs='2'/&gt;\n      &lt;xs:element name='AtLeastOnce'                  maxOccurs='unbounded'/&gt;\n      &lt;xs:element name='AnyNumber'      minOccurs='0' maxOccurs='unbounded'/&gt;\n    &lt;/xs:sequence&gt;\n  &lt;/xs:group&gt;\n</pre>\n\n\n<h2   id='minOccurs'><code>minOccurs</code></h2>\n\n<p><code><dfn>minOccurs</dfn></code> indicates the minimum number of times\nan instance represented by the element may appear.&nbsp;\nIf the <code><a href='#minOccurs'>minOccurs</a></code> attribute is not given,\n1 is assumed.&nbsp;\n<code><a href='#minOccurs'>minOccurs</a></code> may be given\nany non-negative integer value.&nbsp;\n</p>\n\n<p>\nThe value of <code><a href='#minOccurs'>minOccurs</a></code>\n(assumed or explicit)\nmust not be greater than\nthe value of <code><a href='#maxOccurs'>maxOccurs</a></code>\n(assumed or explicit).&nbsp;\n</p>\n\n\n<h2   id='name'><code>name</code></h2>\n\n<p>\n<code><dfn>name</dfn></code> is used to give a name to a definition\nthat can then be referenced elsewhere using a\n<code><a href='#ref'>base</a></code>,\n<code><a href='#ref'>ref</a></code>,\n<code><a href='#ref'>type</a></code>,\nor other attribute.&nbsp;\n</p>\n\n<p>\nIt is also used to specify the names of elements and attributes\nthat can appear in an XML file matching the schema.&nbsp;\n</p>\n\n<p>\nThe type of a <code><a href='#name'>name</a></code> value\nis <code>xs:<a href='#NCName'>NCName</a></code>.&nbsp;\n</p>\n\n\n<h2   id='ref'><code>ref</code></h2>\n\n<p><code><dfn>ref</dfn></code> is used to reference\na named definition (see <code><a href='#name'>name</a></code>).&nbsp;\n</p>\n\n<p>\nThe type of a <code><a href='#ref'>ref</a></code> value\nis <code>xs:<a href='#NCName'>NCName</a></code>.&nbsp;\n</p>\n\n<h2   id='type'><code>type</code></h2>\n\n<p><code><dfn>type</dfn></code> is used to reference\na named type (see <code><a href='#name'>name</a></code>).&nbsp;\nIt is similar to <code><a href='#ref'>ref</a></code>\nbut is only used to reference types.&nbsp;\n</p>\n\n<p>\nThe type of a <code><a href='#type'>type</a></code> value\nis <code>xs:<a href='#NCName'>NCName</a></code>.&nbsp;\n</p>\n\n\n<h1 id='MoreElement'>More on <code>element</code></h1>\n\n<p>\nAttributes:&nbsp;\n</p>\n\n<ul>\n  <li id='ElementDefault'> <code><dfn>default</dfn></code>\n    specifies a value that is assumed as\n    the intended contents of an empty instance\n    of this element.&nbsp;\n    The value must be of <code><a href='#simpleContent'>simpleContent</a></code>\n    because it is given in an attribute value.&nbsp;\n    <code><a href='#default'>default</a></code> and\n    <code><a href='#fixed'>fixed</a></code> cannot both appear.&nbsp;\n  </li>\n  <li id='ElementFixed'> <code><dfn>fixed</dfn></code>\n    specifies a value that all instances of the element must have,\n    and that is used as the default value of empty instances of this element.&nbsp;\n    <code><a href='#default'>default</a></code> and\n    <code><a href='#fixed'>fixed</a></code> cannot both appear.&nbsp;\n  </li>\n  <li id='ElementForm'> <code><dfn>form</dfn></code>\n    specifies, for a local element definition only,\n    whether the element name belongs to\n    the target namespace (<code>form=qualified</code>)\n    or to no namespace (<code>form=unqualified</code>).&nbsp;\n    The default is set by the <code><a href='#schema'>schema</a></code>\n    attribute <code><a href='#elementFormDefault'></a></code>.&nbsp;\n    Compare <code><a href='#attribute'>attribute</a></code>'s\n    <code><a href='#AttributeForm'>form</a></code> element,\n    whose meaning is different although its syntax is identical.&nbsp;\n  </li>\n</ul>\n\n\n<h1 id='MoreSchema'>More on <code>schema</code></h1>\n\n<p>\nAttributes:&nbsp;\n</p>\n\n<ul>\n  <li id='attributeFormDefault'> <code><dfn>attributeFormDefault</dfn></code>\n    specifies whether it is the default that\n    attributes in XML files matching the schema\n    must have a namespace prefix (<code>attributeFormDefault=qualified</code>)\n    or need not (<code>attributeFormDefault=unqualified</code>, the default).&nbsp;\n    See the <code><a href='#attribute'>attribute</a></code> attribute\n    <code><a href='#AttributeForm'>form</a></code>.&nbsp;\n  </li>\n  <!-- <li id='blockDefault'> <code>blockDefault</code> -->\n  <li id='elementFormDefault'> <code><dfn>elementFormDefault</dfn></code>\n    specifies whether it is the default that\n    elements in XML files matching the schema\n    must have a namespace prefix (<code>elementFormDefault=qualified</code>)\n    or need not (<code>elementFormDefault=unqualified</code>, the default).&nbsp;\n    See the <code><a href='#element'>element</a></code> attribute\n    <code><a href='#ElementForm'>form</a></code>.&nbsp;\n  </li>\n  <!-- <li id='final'> <code>final</code> -->\n  <li id='lang'> <code><dfn>lang</dfn></code>\n    gives the language in which the schema's text is written;&nbsp;\n    its value is of type <code>xs:<a href='#language'>language</a></code>.&nbsp;\n    This attribute is defined as part of XML\n    and can be given for any XML element\n    (often appearing as <code>xml:lang</code>).&nbsp;\n  </li>\n  <li id='targetNamespace'> <code><dfn>targetNamespace</dfn></code>\n    specifies the namespace (if any) whose names\n    the <code><a href='#schema'>schema</a></code> defines.&nbsp;\n    <ul>\n      <li>\n        The attribute value must be a <a href='#anyURI'>URI</a>\n        that is the value of one of the <code><a href='#schema'>schema</a></code>'s\n        <code><a href='#xmlns'>xmlns</a></code> attributes.&nbsp;\n      </li>\n      <li>\n        All qualified attributes and elements defined in the schema\n        must be qualified with the prefix\n        given to this namespace in that\n        <code><a href='#xmlns'>xmlns</a></code> attribute.&nbsp;\n      </li>\n      <li>\n        If no <a class='tt' href='#targetNamespace'>targetNamespace</a>\n        attribute is given,\n        the elements and attributes are not defined in a namespace.&nbsp;\n      </li>\n    </ul>\n  </li>\n  <li id='xmlns'> <code><dfn>xmlns</dfn></code>\n    gives the default namespace,\n    the namespace for unqualified elements\n    (those whose names have no prefix).&nbsp;\n    Its value is a <a href='#anyURI'>URI</a>.&nbsp;\n    Example:&nbsp;\n    <ul>\n      <li> <code>xmlns='http://www.w3.org/2001/XMLSchema'</code>\n        makes the XMLSchema namespace the default\n        for unqualified element names\n        (but not unqualified attribute names &mdash;\n        those are assumed to be in the same namespace\n        as the element containing them).&nbsp;\n      </li>\n    </ul>\n  </li>\n  <li id='xmlns_'> <code><dfn>xmlns:*</dfn></code>\n    defines a prefix that refers to a specific namespace.&nbsp;\n    The prefix is the <a href='#NCName'>xs:NCName</a>\n    that appears instead of the <code>*</code> in the\n    <code>xmlns:*</code> attribute.&nbsp;\n    The attribute's value is a <a href='#anyURI'>URI</a>\n    that gives the namespace for the prefix.&nbsp;\n    Example:&nbsp;\n    <ul>\n      <li> <code>xmlns:xs='http://www.w3.org/2001/XMLSchema'</code>\n        makes the <code>xs</code> prefix\n        refer to the XMLSchema namespace.&nbsp;\n        Any name preceded by <code>xs:</code> will be considered\n        as a name in that namespace.&nbsp;\n      </li>\n    </ul>\n  </li>\n</ul>\n\n\n<h1 id='Comments'>Comments</h1>\n\n<p>\nOrdinary XML comments may be used in XML schemas.&nbsp;\nThese comments may appear anywhere an element may.&nbsp;\n</p>\n\n<p>\nExample:&nbsp;\n</p>\n<pre>\n  <!-- Comment -->\n</pre>\n\n<p id='annotation'>\nThe <dfn><code>annotation</code></dfn> element\nis provided specifically for commenting schemas.&nbsp;\nAn <code><a href='#annotation'>annotation</a></code>\nmay appear as the first element of almost any XML Schema element,\nand may appear anywhere at the <a href='#TopLevel'>top level</a>\nin a <code><a href='#schema'>schema</a></code> element.&nbsp;\n(An <code><a href='#annotation'>annotation</a></code>\ncannot appear within another <code><a href='#annotation'>annotation</a></code>\nor its children.)&nbsp;\n</p>\n\n<p id='documentation'>\nAn <code><a href='#annotation'>annotation</a></code>\nmay contain a <code><dfn>documentation</dfn></code> element\ncontaining a human-readable comment,\nand/or an <code><dfn>appinfo</dfn></code> element\ncontaining program-readable text.&nbsp;\n</p>\n\n<p>\nExample:&nbsp;\n</p>\n\n<pre>\n  &lt;xs:element name='annotatedElement'&gt;\n    &lt;xs:annotation&gt;\n      &lt;xs:documentation&gt;\n        Here is a comment for this schema element.\n      &lt;/xs:documentation&gt;\n    &lt;/xs:annotation&gt;\n  &lt;/xs:element&gt;\n</pre>\n\n\n<h1 id='UniqueValues'>Uniqueness constraints</h1>\n\n<p>\nXML Schema provides several ways of ensuring unique values\nfor attributes or elements\nand using those values in references.&nbsp;\nOf course,\nit is always possible to\nexercise discipline and ensure that certain values in an XML file are unique,\nor to write a program to check the constraints you need.&nbsp;\nUsing the features described here\nforces XML validators to check the uniqueness constraints\nwhenever an XML instance of your schema is read by a validator.&nbsp;\n</p>\n\n<p>\nOne way is through the predefined types\n<code><a href='#ID'>ID</a></code> and\n<code><a href='#IDREF'>IDREF</a></code>.&nbsp;\nSchema processors are expected to check\nthat values of type <code><a href='#ID'>ID</a></code> in an XML file are unique,\nand\nthat values of type <code><a href='#IDREF'>IDREF</a></code>\nare also values of type <code><a href='#ID'>ID</a></code> in the same file.&nbsp;\n</p>\n\n<p>\nA second way is to use\n<code><a href='#unique'>unique</a></code>,\n<code><a href='#key'>key</a></code>,\nand/or\n<code><a href='#keyref'>keyref</a></code>.&nbsp;\n</p>\n\n<p id='unique'>\nA <code><dfn>unique</dfn></code> element\nidentifies elements\nwith unique field or element values.&nbsp;\nThese values are constrained to be unique within\neach instance of <code><a href='#unique'>unique</a></code>'s\nparent <code><a href='#element'>element</a></code>\n(<code><a href='#unique'>unique</a></code> can only occur as\na child of an <code><a href='#element'>element</a></code>).&nbsp;\nThis parent <code><a href='#element'>element</a></code>\ndefines the scope of the constraint,\nand is here termed the <dfn>scope node</dfn>.&nbsp;\n</p>\n\n<p>\nThe <code><a href='#unique'>unique</a></code> element must contain\ntwo subelements:\n</p>\n\n<ul>\n  <li> <code><a href='#selector'>selector</a></code>,\n    whose <code>xpath</code> attribute identifies\n    the <code><a href='#unique'>scope node</a></code>'s descendant elements\n    that are uniquely distinguished\n    (here termed the <code><a href='#selector'>selected elements</a></code>), and\n  </li>\n  <li> <code><a href='#field'>field</a></code>,\n    whose <code>xpath</code> attribute identifies\n    the element or field\n    (here termed the <code><a href='#field'>distinguishing node</a></code>)\n    whose value is unique\n    for each of the <code><a href='#selector'>selected elements</a></code>.&nbsp;\n  </li>\n</ul>\n\n<p>\nThe values are constrained to be unique among the\nselected descendants of the <code><a href='#unique'>scope node</a></code>\n(contrast <code><a href='#ID'>ID</a></code>s, which\nare unique within the entire file).&nbsp;\nThe distinguishing field or element may be an optional one,\nin which case only descendants that possess it\nare constrained.&nbsp;\n</p>\n\n<p>\nEach <code><a href='#unique'>unique</a></code> element is required\nto have a <code><a href='#name'>name</a></code> field,\nand the name values must be unique among\nall <code><a href='#unique'>unique</a></code> and\n<code><a href='#key'>key</a></code> elements in the schema.&nbsp;\n</p>\n\n<p id='selector'>\nA <code><dfn>selector</dfn></code> element\nidentifies a set of <dfn>selected elements</dfn>.&nbsp;\nIts <code>xpath</code> attribute\ngives the <a href='xslt.html#Pattern'>pattern</a>\nthat selects those elements,\nusing the <code><a href='#unique'>scope node</a></code>\n(the <code><a href='#selector'>selector</a></code> element's\n<code><a href='#element'>element</a></code> grandparent)\nas the context node.&nbsp;\nIn the most common case,\nthe pattern simply names the element type.&nbsp;\nHowever, any pattern that selects a child of the\n<code><a href='#unique'>scope node</a></code> is allowed.&nbsp;\n</p>\n\n<p id='field'>\nA <code><dfn>field</dfn></code> element\nidentifies a <dfn>distinguishing node</dfn>,\nan element or field of the\n<code><a href='#selector'>selected elements</a></code>.&nbsp;\nIts <code>xpath</code> attribute\ngives the <a href='xslt.html#Pattern'>pattern</a>\nthat selects the element or field,\nusing each element selected by\nthe <code><a href='#selector'>selector</a></code> element\nas the context node.&nbsp;\nIn the most common case,\nthe pattern simply names the field\n(preceded by <code>@</code> to show it is a field).&nbsp;\nHowever, any pattern that selects a child of the selected elements\nor a field of a child is allowed.&nbsp;\nIt is possible to select several children as a composite field,\nbut that is not discussed further here.&nbsp;\n</p>\n\n<p id='key'>\nA <code><dfn>key</dfn></code> element\nis like a <code><a href='#unique'>unique</a></code> element,\nexcept that its <code><a href='#field'>field</a></code> child element\nmay only select a\n<code><a href='#field'>distinguishing node</a></code> that is required,\nwhereas for <code><a href='#unique'>unique</a></code>\nthe <code><a href='#field'>distinguishing node</a></code> may be\nan element for which\n<code><a href='#minOccurs'>minOccurs</a>=0</code>\nor a field for which <code>use=optional</code>.&nbsp;\n</p>\n\n<p id='keyref'>\nA <dfn><code>keyref</code></dfn> element\ndefines a reference to a\n<code><a href='#selector'>selected element</a></code> of\na <code><a href='#key'>key</a></code>\nor <code><a href='#unique'>unique</a></code> element.&nbsp;\nThe <code><a href='#keyref'>keyref</a></code> should be a sibling of the\n<code><a href='#key'>key</a></code> or\n<code><a href='#unique'>unique</a></code> element\n(this is not required, but produces results that are more predictable).&nbsp;\n</p>\n\n<p>\nThe <code><a href='#keyref'>keyref</a></code> element must contain\ntwo subelements:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#selector'>selector</a></code>,\n    whose <code>xpath</code> attribute identifies\n    the <code><a href='#unique'>scope node</a></code>'s descendant elements\n    that contain the key references, and\n  </li>\n  <li> <code><a href='#field'>field</a></code>,\n    whose <code>xpath</code> attribute identifies\n    the element or field whose value is the key reference.&nbsp;\n  </li>\n</ul>\n\n<p>\nEach <code><a href='#keyref'>keyref</a></code> element is required to have\ntwo attributes:&nbsp;\n</p>\n\n<ul>\n  <li> <code><a href='#name'>name</a></code>, and\n  </li>\n  <li> <code>refer</code>, whose value is\n    the <code><a href='#name'>name</a></code> of the\n    <code><a href='#key'>key</a></code> or\n    <code><a href='#unique'>unique</a></code> element\n    whose unique value is referenced by\n    this <code><a href='#keyref'>keyref</a></code>'s\n    <a href='#selector'>selected elements'</a>\n    <code><a href='#field'>distinguishing nodes</a></code>.&nbsp;\n  </li>\n</ul>\n\n<p>\nExample:&nbsp;\n</p>\n\n<pre>\n  &lt;xs:element name='world'&gt;\n    &lt;xs:complexType&gt;\n      &lt;xs:sequence&gt;\n        &lt;xs:element name='state' maxOccurs='unbounded'&gt;\n          &lt;xs:complexType&gt;\n            &lt;xs:choice maxOccurs='unbounded'&gt;\n              &lt;xs:element name='car'&gt;\n                &lt;xs:complexType&gt;\n                  &lt;!-- empty content --&gt;\n                  &lt;xs:attribute name='licenseNumber'  type='xs:string'/&gt;\n                  &lt;xs:attribute name='carPhoneNumber' type='xs:string' use='optional'/&gt;\n                &lt;/xs:complexType&gt;\n              &lt;/xs:element&gt;\n              &lt;xs:element name='carOwner'&gt;\n                &lt;xs:complexType&gt;\n                  &lt;xs:sequence&gt;\n                    &lt;xs:element name='carLicense' type='xs:string' maxOccurs='unbounded'/&gt;\n                  &lt;/xs:sequence&gt;\n                  &lt;xs:attribute name='owner'  type='xs:string'/&gt;\n                &lt;/xs:complexType&gt;\n              &lt;/xs:element&gt;\n            &lt;/xs:choice&gt;\n          &lt;/xs:complexType&gt;\n          &lt;xs:key name='car-licenseNumber-state'&gt;  &lt;!-- key --&gt;\n            &lt;xs:annotation&gt;\n              &lt;xs:documentation&gt;\n                No two cars in the same state can have the same licenseNumber.\n              &lt;/xs:documentation&gt;\n            &lt;/xs:annotation&gt;\n            &lt;xs:selector xpath='car'/&gt;\n            &lt;xs:field xpath='@licenseNumber'/&gt;\n          &lt;/xs:key&gt;\n          &lt;xs:keyref name='owner-state' refer='car-licenseNumber-state'&gt;  &lt;!-- keyref --&gt;\n            &lt;xs:selector xpath='carOwner'/&gt;\n            &lt;xs:field xpath='carLicense'/&gt;\n          &lt;/xs:keyref&gt;\n        &lt;/xs:element&gt;\n      &lt;/xs:sequence&gt;\n    &lt;/xs:complexType&gt;\n    &lt;xs:unique name='car-carPhoneNumber-world'&gt;  &lt;!-- unique --&gt;\n      &lt;xs:annotation&gt;\n        &lt;xs:documentation&gt;\n          No two cars in the world can have the same carPhoneNumber.\n        &lt;/xs:documentation&gt;\n      &lt;/xs:annotation&gt;\n      &lt;xs:selector xpath='car'/&gt;\n      &lt;xs:field xpath='@carPhoneNumber'/&gt;\n    &lt;/xs:unique&gt;\n  &lt;/xs:element&gt;\n</pre>\n\n\n<h1 id='NotRecommended'>Advanced</h1>\n\n<p>\nFollowing are descriptions of XML Schema features\nthat are more advanced,\nand best avoided until needed.&nbsp;\n</p>\n\n\n<h2   id='Inclusion'>Inclusion of other schemas</h2>\n\n<p>\nThere are several ways one schema can incorporate\ntypes, elements, attributes, and groups defined in another schema\n(besides simply copying the text, which always works).&nbsp;\n</p>\n\n<p id='include'>\n<code><dfn>include</dfn></code>\nhas the effect of including all <a href='#TopLevel'>top-level</a> definitions of\nanother schema.&nbsp;\nThe other schema is named in the <code>schemaLocation</code>\nattribute.&nbsp;\nIts namespace (if any) must match the namespace\nof the including schema (if any).&nbsp;\n<code><a href='#include'>include</a></code> may only appear\nat the <a href='#TopLevel'>top level</a>.&nbsp;\n</p>\n\n<p id='import'>\n<code><dfn>import</dfn></code>\ntells a program processing a schema\nwhere to find definitions in another namespace\nthat are used in the schema.&nbsp;\nThe location of the definitions is given in the <code>schemaLocation</code>\nattribute;&nbsp;\nonly definitions at the <a href='#TopLevel'>top level</a> can be imported.&nbsp;\nThe namespace of those definitions is given in the <code>namespace</code>\nattribute.&nbsp;\n(Compare <code><a href='#schema'>schema</a></code>'s\n<code><a href='#xmlns'>xmlns</a></code> attribute.)&nbsp;\n</p>\n\n\n<h2   id='SubstitutionGroup'>Substitution groups</h2>\n\n<p>\nSubstitution groups provide a way to 'type' elements\nand allow them to appear interchangeably,\nwithout creating a type.&nbsp;\nThey do something of the same thing that types and\n<code><a href='#choice'>choice</a></code> do,\nbut can be extended elsewhere,\nfor example when a schema is <a href='#include'>included</a>.&nbsp;\n</p>\n\n<p>\nWe will not describe substitution groups here in any more detail,\nas in most cases the same function can be provided more straightforwardly\nby types and compositors,\nand their description complicates the descriptions of other elements\nby requiring details that are not otherwise needed.&nbsp;\n</p>\n\n\n<h2 id='LexicalAndValue'>The distinction between lexical and value spaces</h2>\n\n<p>\nEach type in XML Schema\ncan be considered as\na possibly infinite set of values of that type (the type's value space).&nbsp;\nEach type can also be considered as\na possibly infinite set of strings representing the values of the type\n(the type's lexical space).&nbsp;\nOrdinarily there is no need to keep this distinction in mind.&nbsp;\nBut for many types,\na single value can be represented by more than one string;&nbsp;\nfor example,\na single <code>xs:<a href='#integer'>integer</a></code> is\nrepresented by\n'<code>1</code>', '<code>+1</code>', and '<code>01</code>',\nand a single <code>xs:<a href='#normalizedString'>normalizedString</a></code>\nis represented by\n'<code>normalized&nbsp;string</code>' and\n'<code>normalized&nbsp;&nbsp;string</code>'.&nbsp;\n</p>\n\n<p>\n<code><a href='#ByRegularExpression'>Restriction by a regular expression</a></code>\nacts on the lexical space, not the value space.&nbsp;\nIt is best to avoid deriving types by regular expression\nfor which the two spaces are not one-to-one,\nas it makes confusion likely.&nbsp;\n</p>\n\n\n<!--xhtml -n -->\n</div>\n\n</div><!-- #TBg -->\n\n<div id='TFooter'>\n<div class='W3C'>\n  <a href='http://validator.w3.org/check?uri=referer'><img class='W3C'\n    src='../../img/valid-xhtml10-blue.png'\n    alt='Valid XHTML 1.0 Strict'/></a>\n  <br/>\n  <a href='http://jigsaw.w3.org/css-validator/check/referer'><img class='W3C'\n    src='../../img/vcss-blue.png'\n    alt='Valid CSS!'/></a>\n</div>\n<div class='timestamp'>2010May16Su21:42</div>\n<div style='padding-top:1px;'>\n<a class='plain' href='./index.html' style='font-variant:small-caps;'\n>Thomas A. Alspaugh</a>\n<span style='padding-left:1em;'><span class='email ss sm'>alspaugh&nbsp;\n    <span class='ss sc sm'>at</span> &middot; ics &middot; uci &middot; edu</span>\n    <!-- -spell alspaugh uci edu --> </span>\n</div>\n</div>\n\n<!-- Google Analytics code -->\n<script type=\"text/javascript\">\nvar gaJsHost = ((\"https:\" == document.location.protocol)\n  ? \"https://ssl.\" : \"http://www.\");\ndocument.write(unescape(\"%3Cscript src='\" + gaJsHost +\n  \"google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E\"));\n</script>\n<script type=\"text/javascript\">\ntry {\nvar pageTracker = _gat._getTracker(\"UA-15281497-1\");\npageTracker._trackPageview();\n} catch(err) {}\n</script>\n\n</body>\n</html>\n\n", "id": 10726.0}