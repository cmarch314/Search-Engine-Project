{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 13Nef Polyhedra embedded on the Sphere Peter Hachenberger and Lutz Kettner 13 1 Introduction Nef polyhedra are defined as a subset of the d dimensional space obtained by a finite number of set complement and set intersection operations on halfspaces Due to the fact that all other binary set operations like union difference and symmetric difference can be reduced to intersection and complement calculations Nef polyhedra are also closed under those operations Also Nef polyhedra are closed under topological unary set operations Given a Nef polyhedron one can determine its interior its boundary and its closure Figure Two spherical Nef polyhedra A closed halfspace on the left and a complex polyhedron on the right The different colors indicate selected and unselected regions lines and points Additionally a d dimensional Nef polyhedron has the property that its boundary is a d 1 dimensional Nef polyhedron This property can be used as a way to represent 3 dimensional Nef polyhedra by means of planar Nef polyhedra This is done by intersecting the neighborhood of a vertex in a 3D Nef polyhedron with an sphere The result is a planar Nef polyhedron embedded on the sphere The intersection of a halfspace going through the center of the sphere with the sphere results in a halfsphere which is bounded by a great circle A binary operation of two halfspheres cuts the great circles into great arcs The incidence structure of planar Nef polyhedra can be reused The items are denoted as svertex shalfedge and sface analogous to their counterparts in Nef polyhedron S2 Additionally there is the shalfloop reprsenting the great circles The incidences are illustrated in the figure above 13 2 Restricted Spherical Geometry We introduce geometric objects that are part of the spherical surface S2 and operations on them We define types Sphere point Sphere circle Sphere segment and Sphere direction Sphere points are points on S2 Sphere circles are oriented great circles of S2 Sphere segments are oriented parts of Sphere circles bounded by a pair of Sphere points and Sphere directions are directions that are part of great circles a direction is usually defined to be a vector without length that floats around in its underlying space and can be used to specify a movement at any point of the underlying space in our case we use directions only at points that are part of the great circle that underlies also the direction Note that we have to consider special geometric properties of the objects For example two points that are part of a great circle define two Sphere segments and two arbitrary Sphere segments can intersect in two points If we restrict our geometric objects to a so called perfect hemisphere of S21 then the restricted objects behave like in classical geometry e g two points define exactly one segment two segments intersect in at most one interior point non degenerately or three non cocircular sphere points can be qualified as being positively or negatively oriented 13 3 Example Programs 13 3 1 First Example In this first example Nef polyhedron S2 is parametrized with a CGAL Kernel as traits class The types comprising the spherical geometry can be retrieved from the type Nef polyhedron S2 Traits as is done in the example with the type Sphere circle Then three Nef polyhedra are created N1 is a halfsphere including the boundary N2 is another halfsphere without the boundary and N3 is the intersection of N1 and N2 examples Nef S2 simple C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron S2 h typedef CGAL Gmpz RT typedef CGAL Homogeneous RT Kernel typedef CGAL Nef polyhedron S2 Kernel Nef polyhedron typedef Nef polyhedron Sphere circle Sphere circle int main Nef polyhedron N1 Sphere circle 1 Nef polyhedron N2 Sphere circle 1 Nef polyhedron EXCLUDED Nef polyhedron N3 N1 N2 return 13 3 2 Construction and Combinations Th example shows the different types of constructors N1 is the complete sphere N2 is a halfsphere which includes the boundary N3 is created with the copy constructor N4 is created as an arrangement of a set of Sphere segments and N5 is created as the empty set The example also shows the use of unary set operations binary operations and binary predicates N3 is defined as the complement of N2 N1 is compared with the union of N2 and N3 N5 is united with N2 and then intersected with N4 At last it is tested if N5 is a subset of N2 and if N5 is not equal to N4 examples Nef S2 construction C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron S2 h typedef CGAL Gmpz RT typedef CGAL Homogeneous RT Kernel typedef CGAL Nef polyhedron S2 Kernel Nef polyhedron typedef Nef polyhedron Sphere point Sphere point typedef Nef polyhedron Sphere segment Sphere segment typedef Nef polyhedron Sphere circle Sphere circle int main Nef polyhedron N1 Nef polyhedron COMPLETE Sphere circle c 1 1 1 c x y z Nef polyhedron N2 c Nef polyhedron INCLUDED Nef polyhedron N3 N2 complement CGAL assertion N1 N2 join N3 Sphere point p1 1 p2 1 p3 1 Sphere segment s1 p1 p2 s2 p2 p3 s3 p3 p1 Sphere segment triangle 3 s1 s2 s3 Nef polyhedron N4 triangle triangle 3 Nef polyhedron N5 N5 N2 N5 N5 intersection N4 CGAL assertion N5 N2 N5 N4 return 13 3 3 Exploration By recursively composing binary and unary operations one can end with a very complex rectilinear structure Nef polyhedron S2 allows read only exploration of the structure In the following example a random Nef polyhedron S2 S created from n halfspheres is explored Each sface is composed of one outer sface cycles and an arbitrary number of inner sfaces cycles The outer cycle is either an shalfloop or a cycle of shalfedges An inner cycles additionally can be an isolated vertex The example shows how to get the entry item it to all sface cycles of an sface sf and how to find out what type of item it is The macro CGAL forall sface cycles of is equivalent to a for loop on the range sf sface cycles begin sf sface cycles end An SFace cycle const iterator either represents a SVertex const handle a SHalfede const handle or a SHalfloop const handle In order to find out which handle type is represented the functions is svertex is shafledge and is shalfloop are provided Afterwards the iterator can be casted to the proper handle type examples Nef S2 exploration C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron S2 h include CGAL Nef S2 create random Nef S2 h typedef CGAL Gmpz RT typedef CGAL Homogeneous RT Kernel typedef CGAL Nef polyhedron S2 Kernel Nef polyhedron S2 typedef Nef polyhedron S2 SVertex const handle SVertex const handle typedef Nef polyhedron S2 SHalfedge const handle SHalfedge const handle typedef Nef polyhedron S2 SHalfloop const handle SHalfloop const handle typedef Nef polyhedron S2 SFace const iterator SFace const iterator typedef Nef polyhedron S2 SFace cycle const iterator SFace cycle const iterator int main Nef polyhedron S2 S CGAL create random Nef S2 S 5 int i SFace const iterator sf CGAL forall sfaces sf S SFace cycle const iterator it std cout the sface cycles of sface i std cout start with an std endl CGAL forall sface cycles of it sf if it is svertex std cout svertex at position std cout SVertex const handle it point std endl else if it is shalfedge std cout shalfedge from std cout SHalfedge const handle it source point to std cout SHalfedge const handle it target point std endl else if it is shalfloop std cout shalfloop lying in the plane std cout SHalfloop const handle it circle std endl else std cout something is wrong std endl return 13 3 4 Point Location Using the locate function it is possible to retrive an item at a certain location on the sphere In the following example the item at location Sphere point 1 in a random Nef polyhedron S2 is retrieved locate returns an instance of type Object handle which is a container for any handle type Here it either a SVertex const handle a SHalfedge const handle a SHafloop const handle or a SFace const handle The function CGAL assign performs the cast operation and returns a boolean which indicates whether the cast was successful or not examples Nef S2 point location C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron S2 h include CGAL Nef polyhedron 3 h include CGAL Nef S2 create random Nef S2 h typedef CGAL Gmpz RT typedef CGAL Homogeneous RT Kernel typedef CGAL Nef polyhedron S2 Kernel Nef polyhedron S2 typedef Nef polyhedron S2 SVertex const handle SVertex const handle typedef Nef polyhedron S2 SHalfedge const handle SHalfedge const handle typedef Nef polyhedron S2 SHalfloop const handle SHalfloop const handle typedef Nef polyhedron S2 SFace const handle SFace const handle typedef Nef polyhedron S2 Object handle Object handle typedef Nef polyhedron S2 Sphere point Sphere point int main Nef polyhedron S2 S CGAL create random Nef S2 S 5 SVertex const handle sv SHalfedge const handle se SHalfloop const handle sl SFace const handle sf Object handle o S locate Sphere point 1 if CGAL assign sv o std cout Locating svertex std endl else if CGAL assign se o std cout Locating shalfedge std endl else if CGAL assign sl o std cout Locating shalfloop std endl else if CGAL assign sf o std cout Locating sface std endl else std cout something wrong std endl return 1 return 13 3 5 Visualization Nef polyhedron S2 provides an interface for OpenGL visualization via a Qt widget The usage is shown in the following example examples Nef S2 visualization C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron S2 h include CGAL Nef S2 create random Nef S2 h include CGAL IO Qt widget Nef S2 h include qapplication h typedef CGAL Gmpz RT typedef CGAL Homogeneous RT Kernel typedef CGAL Nef polyhedron S2 Kernel Nef polyhedron S2 int main int argc char argv Nef polyhedron S2 S create random Nef S2 S 5 QApplication a argc argv CGAL Qt widget Nef S2 Nef polyhedron S2 w new CGAL Qt widget Nef S2 Nef polyhedron S2 S a setMainWidget w w show return a exec endif Footnotes 1 A perfect hemisphere of S2 is an open half sphere plus an open half circle in the boundary of the open half sphere plus one endpoint of the half circle Next chapter Nef Polyhedra embedded on the Sphere Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Nef_S2/Chapter_main.html", "title": "nef polyhedra embedded on the sphere", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Nef_S2/main.tex' -->\n<html> <head>  \n<title>Nef Polyhedra embedded on the Sphere</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_13\"></a>\n  \n<h1>Chapter 13<BR>Nef Polyhedra embedded on the Sphere</h1>\n\n<A NAME=\"chapterNef_S2\"></A>\n\n<EM>Peter Hachenberger  and Lutz Kettner</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>13.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nNef polyhedra are defined as a subset of the d-dimensional space obtained by\na finite number of set complement and set <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> operations on\nhalfspaces.\n<P>\n\nDue to the fact that all other binary set operations like union,\ndifference and symmetric difference can be reduced to <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> and\ncomplement calculations, Nef polyhedra are also closed under those\noperations. Also, Nef polyhedra are closed under topological unary \nset operations. Given a Nef polyhedron one can determine its interior, its\nboundary, and its closure.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Two spherical Nef polyhedra. A closed halfspace on the left \n  and a complex polyhedron on the right. The different colors indicate\n  selected and unselected regions, lines and points.<A NAME=\"nefsexamples\"></A>\n\n<CENTER>\n<IMG BORDER=0 SRC=\"fig/halfspace.gif\" ALIGN=center\nALT=\"a halfplane\">\n<IMG BORDER=0 SRC=\"fig/complex.gif\" ALIGN=center\nALT=\"a complex polyhedron\">\n</CENTER>\n<P>\n\nAdditionally, a d-dimensional Nef polyhedron has the property, that its boundary\nis a (d-1)-dimensional Nef polyhedron. This property can be used as a way to\nrepresent 3-dimensional Nef polyhedra by means of planar Nef polyhedra.\nThis is done by intersecting the neighborhood of a vertex in a 3D Nef polyhedron\nwith an <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>-sphere. The result is a planar Nef polyhedron embedded\non the sphere.\n<P>\n\nThe <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of a halfspace going through the center of the <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>-sphere,\nwith the <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>-sphere, results in a halfsphere which is bounded by\na great circle. A binary operation of two halfspheres cuts the great circles\ninto great arcs.\n<P>\n\n<CENTER>\n    <A HREF=\"./fig/shalfloopB.gif\">\n        <img src=\"./fig/shalfloopB.gif\" alt=\"SHalfloop Diagram\"></A>\n<P>\n\n</CENTER>\n<P>\n\nThe incidence structure of planar Nef polyhedra can be reused. The items\nare denoted as <MATH><I>svertex</I></MATH>, <MATH><I>shalfedge</I></MATH> and <MATH><I>sface</I></MATH>, analogous \nto their counterparts in <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I>. Additionally, there is the\n<I>shalfloop</I> reprsenting the great circles. The incidences are \nillustrated in the figure above.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>13.2&nbsp;&nbsp;&nbsp;Restricted Spherical Geometry</h2>\n<P>\n\nWe introduce geometric objects that are part of the spherical surface\n<MATH><I>S<SUB>2</SUB></I></MATH> and operations on them. We define types <I>Sphere_point</I>,\n<I>Sphere_circle</I>, <I>Sphere_segment</I>, and <I>Sphere_direction</I>.\n<I>Sphere_point</I>s are points on <MATH><I>S<SUB>2</SUB></I></MATH>, <I>Sphere_circle</I>s are\noriented great circles of <MATH><I>S<SUB>2</SUB></I></MATH>, <I>Sphere_segment</I>s are oriented\nparts of <I>Sphere_circles</I> bounded by a pair of\n<I>Sphere_point</I>s, and <I>Sphere_direction</I>s are directions that\nare part of great circles. (a direction is usually defined to be a\nvector without length, that floats around in its underlying space and\ncan be used to specify a movement at any point of the underlying\nspace; in our case we use directions only at points that are part of\nthe great circle that underlies also the direction.)\n<P>\n\nNote that we have to consider special geometric properties of the\nobjects. For example two points that are part of a great circle define\ntwo <I>Sphere_segment</I>s, and two arbitrary <I>Sphere_segment</I>s can\nintersect in two points.\n<P>\n\nIf we restrict our geometric objects to a so-called perfect hemisphere\nof <MATH><I>S<SUB>2</SUB></I></MATH><A HREF=\"#Footnote_1\"><SUP>1</SUP></A> then the restricted objects\nbehave like in classical geometry, e.g., two points define exactly one\nsegment, two segments intersect in at most one interior point\n(non-degenerately), or three non-cocircular sphere points can be\nqualified as being positively or negatively oriented.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>13.3&nbsp;&nbsp;&nbsp;Example Programs</h2>\n\n<A NAME=\"sectionNef_S2Examples\"></A>\n<P>\n\n<h3>13.3.1&nbsp;&nbsp;&nbsp;First Example</h3>\n<P>\n\nIn this first example <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> is parametrized with a CGAL\n<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A> as traits class. The types comprising the spherical geometry can be\nretrieved from the type <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>&lt;Traits&gt;</I> as is done in the example \nwith the type\n<I>Sphere_circle</I>. Then three Nef polyhedra are created: <MATH><I>N1</I></MATH> is a halfsphere\nincluding the boundary, <MATH><I>N2</I></MATH> is another halfsphere without the boundary, and \n<MATH><I>N3</I></MATH> is the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of <MATH><I>N1</I></MATH> and <MATH><I>N2</I></MATH>.\n<P>\n\n<pre class=\"ExampleCode\">// examples/Nef_S2/simple.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_726\">CGAL::Nef_polyhedron_S2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Nef_polyhedron;\ntypedef Nef_polyhedron::Sphere_circle Sphere_circle;\n\nint main()\n{\n  Nef_polyhedron N1(Sphere_circle(1,0,0));\n  Nef_polyhedron N2(Sphere_circle(0,1,0), Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">EXCLUDED</A>);\n  Nef_polyhedron N3 = N1 * N2;\n  return 0;\n}\n</pre>\n<P>\n\n<h3>13.3.2&nbsp;&nbsp;&nbsp;Construction and Combinations</h3>\n<P>\n\nTh example shows the different types of constructors: <MATH><I>N1</I></MATH> is the complete\nsphere, <MATH><I>N2</I></MATH> is a halfsphere which includes the boundary, <MATH><I>N3</I></MATH> is created\nwith the copy constructor, <MATH><I>N4</I></MATH> is created as an arrangement of a set\nof <I>Sphere_segments</I>, and <MATH><I>N5</I></MATH> is created as the empty set.\n<P>\n\nThe example also shows the use of unary set operations, binary operations, \nand binary predicates: <MATH><I>N3</I></MATH> is defined as the complement of <MATH><I>N2</I></MATH>, <MATH><I>N1</I></MATH> is\ncompared with the union of <MATH><I>N2</I></MATH> and <MATH><I>N3</I></MATH>, <MATH><I>N5</I></MATH> is united with <MATH><I>N2</I></MATH> and then\nintersected with <MATH><I>N4</I></MATH>. At last, it is tested if <MATH><I>N5</I></MATH> is a subset of <MATH><I>N2</I></MATH> and\nif <MATH><I>N5</I></MATH> is not equal to <MATH><I>N4</I></MATH>.\n<P>\n\n<pre class=\"ExampleCode\">// examples/Nef_S2/construction.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_726\">CGAL::Nef_polyhedron_S2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Nef_polyhedron;\ntypedef Nef_polyhedron::Sphere_point Sphere_point;\ntypedef Nef_polyhedron::Sphere_segment Sphere_segment;\ntypedef Nef_polyhedron::Sphere_circle Sphere_circle;\n\nint main() {\n\n  Nef_polyhedron N1(Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Content\">COMPLETE</A>);\n\n  Sphere_circle c(1,1,1); // c : x + y + z = 0\n  Nef_polyhedron N2(c, Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">INCLUDED</A>);\n  Nef_polyhedron N3(N2.complement());\n  CGAL_assertion(N1 == N2.join(N3));\n\n  Sphere_point   p1(1,0,0), p2(0,1,0), p3(0,0,1);\n  Sphere_segment s1(p1,p2), s2(p2,p3), s3(p3,p1);\n  Sphere_segment triangle[3] = { s1, s2, s3 };\n  Nef_polyhedron N4(triangle, triangle+3);\n  Nef_polyhedron N5;\n  N5 += N2;\n  N5 = N5.<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>(N4);\n  CGAL_assertion(N5 &lt;= N2 &amp;&amp; N5 != N4);\n\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>13.3.3&nbsp;&nbsp;&nbsp;Exploration</h3>\n<P>\n\nBy recursively composing binary and unary operations one can end with\na very complex rectilinear structure. <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> allows \nread-only exploration of the structure.\n<P>\n\nIn the following example, a random <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> S</I> created from\n<I>n</I> halfspheres is explored. Each sface is composed of one outer \nsface cycles and an arbitrary number of inner sfaces cycles. The outer cycle\nis either an shalfloop or a cycle of shalfedges. An inner cycles additionally\ncan be an isolated vertex. The example shows how to get the entry item <I>it</I>\nto all sface cycles of an sface <I>sf</I> and how to find out what type of item\nit is.\n<P>\n\nThe macro <I>CGAL_forall_sface_cycles_of</I> is equivalent to a for-loop\non the range <I>[sf-&gt;sface_cycles_begin(), sf-&gt;sface_cycles_end())</I>. An \n<I>SFace_cycle_const_iterator</I> either represents a <I>SVertex_const_handle</I>,\na <I>SHalfede_const_handle</I> or a <I>SHalfloop_const_handle</I>. In order\nto find out which handle type is represented, the functions\n<I>is_svertex()</I>, <I>is_shafledge()</I> and <I>is_shalfloop()</I> are provided.\nAfterwards the iterator can be casted to the proper handle type.\n<P>\n\n<pre class=\"ExampleCode\">// examples/Nef_S2/exploration.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>.h&gt;\n#include &lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_726\">CGAL::Nef_polyhedron_S2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SVertex_const_handle SVertex_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SHalfedge_const_handle SHalfedge_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SHalfloop_const_handle SHalfloop_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SFace_const_iterator SFace_const_iterator;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SFace_cycle_const_iterator \n                           SFace_cycle_const_iterator;\n\t\t\t   \nint main() {\n\n  <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> S;\n  CGAL::create_random_Nef_S2(S,5);\n\n  int i=0;\n  SFace_const_iterator sf;\n  CGAL_forall_sfaces(sf,S) {\n    SFace_cycle_const_iterator it;\n    std::cout &lt;&lt; &quot;the sface cycles of sface &quot; &lt;&lt; i++;\n    std::cout &lt;&lt; &quot; start with an &quot; &lt;&lt; std::endl; \n    CGAL_forall_sface_cycles_of(it,sf) {\n      if (it.is_svertex()) {\n\tstd::cout &lt;&lt; &quot;  svertex at position &quot;; \n\tstd::cout &lt;&lt; SVertex_const_handle(it)-&gt;point() &lt;&lt; std::endl;\n      }\n      else if (it.is_shalfedge()) { \n\tstd::cout &lt;&lt; &quot;  shalfedge from &quot;;\n\tstd::cout &lt;&lt; SHalfedge_const_handle(it)-&gt;source()-&gt;point() &lt;&lt; &quot; to &quot;;\n\tstd::cout &lt;&lt; SHalfedge_const_handle(it)-&gt;target()-&gt;point() &lt;&lt; std::endl;\n      }\n      else if (it.is_shalfloop()) {\n\tstd::cout &lt;&lt; &quot;  shalfloop lying in the plane &quot;;\n\tstd::cout &lt;&lt; SHalfloop_const_handle(it)-&gt;circle() &lt;&lt; std::endl;\n      }\n      else\n\tstd::cout &lt;&lt; &quot;something is wrong&quot; &lt;&lt; std::endl;\n    }\n  }\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>13.3.4&nbsp;&nbsp;&nbsp;Point Location</h3>\n<P>\n\nUsing the <I>locate</I> function, it is possible to retrive an item at a\ncertain location on the sphere. In the following example, the item at \nlocation <I>Sphere_point(1,0,0)</I> in a random <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> is \nretrieved. <I>locate</I> returns an instance of type <I>Object_handle</I>, which\nis a container for any handle type. Here, it  either a \n<I>SVertex_const_handle</I>, a <I>SHalfedge_const_handle</I>, \na <I>SHafloop_const_handle</I> or a <I>SFace_const_handle</I>. The function \n<I><A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A></I> performs the cast operation and returns a boolean which\nindicates whether the cast was successful or not.\n<P>\n\n<pre class=\"ExampleCode\">// examples/Nef_S2/point_location.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_726\">CGAL::Nef_polyhedron_S2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SVertex_const_handle SVertex_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SHalfedge_const_handle SHalfedge_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SHalfloop_const_handle SHalfloop_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SFace_const_handle SFace_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::Object_handle Object_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::Sphere_point Sphere_point;\n\nint main() {\n\n  <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> S;\n  CGAL::create_random_Nef_S2(S,5);\n\n  SVertex_const_handle sv;\n  SHalfedge_const_handle se;\n  SHalfloop_const_handle sl;\n  SFace_const_handle sf;\n  Object_handle o = S.locate(Sphere_point(1,0,0));\n  if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(sv,o))\n    std::cout &lt;&lt; &quot;Locating svertex&quot; &lt;&lt; std::endl;\n  else if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(se,o))\n    std::cout &lt;&lt; &quot;Locating shalfedge&quot; &lt;&lt; std::endl;\n  else if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(sl,o))\n    std::cout &lt;&lt; &quot;Locating shalfloop&quot; &lt;&lt; std::endl;\n  else if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(sf,o))\n    std::cout &lt;&lt; &quot;Locating sface&quot; &lt;&lt; std::endl;\n  else {\n    std::cout &lt;&lt; &quot;something wrong&quot; &lt;&lt; std::endl;\n    return 1;\n  }\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>13.3.5&nbsp;&nbsp;&nbsp;Visualization</h3>\n<P>\n\n<I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> provides an interface for OpenGL visualization via a\nQt widget. The usage is shown in the following example:\n<P>\n\n<pre class=\"ExampleCode\">// examples/Nef_S2/visualization.C\n\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>.h&gt;\n#include &lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_745\">Qt_widget_Nef_S2</A>.h&gt;\n#include &lt;qapplication.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_726\">CGAL::Nef_polyhedron_S2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>;\n\nint main(int argc, char* argv[]) {\n\n  <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> S;\n  create_random_Nef_S2(S,5);\n\n  QApplication a(argc, argv);\n  <A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_744\">CGAL::Qt_widget_Nef_S2</A>&lt;<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>&gt;* w = \n    new <A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_744\">CGAL::Qt_widget_Nef_S2</A>&lt;<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>&gt;(S);\n  a.setMainWidget(w);\n  w-&gt;show();\n  return a.exec();\n}\n#endif\n\n</pre>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nA perfect hemisphere of <MATH><I>S<SUB>2</SUB></I></MATH> is an open half-sphere\n  plus an open half-circle in the boundary of the open half-sphere\n  plus one endpoint of the half-circle.\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Nef_S2_ref/Chapter_intro.html\">Nef Polyhedra embedded on the Sphere</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_13!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38073.0}