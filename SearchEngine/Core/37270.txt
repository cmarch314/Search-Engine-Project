{"text": "6 Fingerprints Screening and Similarity Similarity measures calculations that quantify the similarity of two molecules and screening a way of rapidly eliminating molecules as candidates in a substructure search are both processes that use fingerprints Fingerprints are a very abstract representation of certain structural features of a molecule before we describe them we ll discuss the problems that inspired the development of the fingerprinting techniques used in the Daylight Chemical Information System To begin let us define a few terms patternThe thing for which you are searching also called a target or substructure moleculeThe thing being searched Sometimes called the object or structure NThe size of a pattern Roughly speaking equal to the number of atoms and bonds the pattern contains its exact definition isn t important only the general idea P in M We use the in symbol to mean is a substructure of i e P in M means pattern P is a substructure of molecule M P not in M means pattern P is not a substructure of molecule M O f N The order computation time or cost of performing a search For example O N2 pronounced order N squared means that the running time is proportional to the square of a pattern s size Substructure searching is known to be in the non polynomial complete NP complete class of computational problems Non polynomial means that the worst case time to solve such a problem can never be expressed as a polynomial in which the number of atoms and or bonds is the independent variable i e it can t be of the form O NK Instead the worst case time for a substructure search is always of the form O KkN This is quite unfortunate To see why imagine for simplicity that a substructure search program takes 2N 1 6 seconds to compute where N is the number of atoms This program can solve a 1 atom problem in a microsecond and a 1 atom problem takes about a millisecond This does not seem too bad until we realize that each time we add an atom we double our time a 2 atom problem takes about a second and a 3 atom problem takes 17 minutes Clearly this algorithm will be inadequate as we attempt to solve real chemical problems By contrast if we could find an algorithm that ran in N2 1 3 seconds it would be 1 times slower on the 1 atom problem but could solve the 3 atom problem in less than a second Clearly a polynomial solution is better than an exponential solution Luckily although substructure searching is polynomial in the worst case real chemicals don t exhibit the high connectivity which in a generalized mathematical graph leads to worst case behavior Typical chemical substructure searches take O N2 or O N3 time and although this is not exactly blazingly fast it is a lot better than exponential behavior But even this polynomial performance is slow it can take a significant fraction of a second for a substructure search and NP complete theory tells us that we might occasionally run into the worst case an exponential time search One of the cold hard facts about NP complete problems is that there is no way around them If you think you ve found a substructure search algorithm that always runs in polynomial time you should try your hand at a perpetual motion machine Your algorithm might work for most cases but if it always finishes in polynomial time some of its answers must be wrong Fortunately there is a hole of sorts in these cold hard facts we can t detect the presence of a substructure in polynomial time but we can often detect the absence of a substructure much faster often linear time O N The trick is to use an imperfect algorithm one that can say P not in M with 1 confidence but that can only say P in M with lower confidence Such an algorithm called a screen does not violate any mathematical laws ultimately we still have to use a real substructure search to get a 1 confident P in M answer but our cheap algorithm screens out most cases avoiding the expensive algorithm most of the time 6 1 A Brief History of Screening Large Databases Many substructure searching problems call for repeatedly examining a large number of molecules typically stored in a database comparing each with a pattern In such situations it pays to spend some time up front storing the answers to specific questions for each structure in the database Subsequent searches of the database use these pre computed answers to vastly improve search time the up front computation time is paid back quickly as repeated searches are performed For example one simple screen notes the molecular formula MF of each molecule as it is added to the database When a pattern is presented for searching we generate its molecular formula during the search we compare the pattern s MF to each molecule s MF and reject any molecules that are missing atoms the pattern requires By doing this we eliminate expensive substructure searches that are doomed to fail for the obvious reason of not having enough of a particular element If the MF screen says P not in M we can be 1 confident that it is correct if the molecular formulas are compatible we have to continue with other screens or with the substructure search itself Molecular Formula is only one of many screens we can apply but it illustrates the fundamental concept of screening We only do the expensive substructure search when no screen can say P in M By devising clever screens we can increase the reliability of the screens to where they reject almost all structures except those that ultimately pass the substructure test that is the screens have very few false positives 6 1 1 Structural keys Structural keys were the first type of screen employed for high speed screening of chemical databases A structural key is usually represented as a boolean array an array in which each element is TRUE or FALSE Boolean arrays in turn are usually represented as bitmaps an array of bytes or words in which each bit represents one position of the boolean array As the name implies a structural key is a bitmap in which each bit represents the presence TRUE or absence FALSE of a specific structural feature pattern To make a structural key one decides which structural features patterns are important assigns a bit of the bitmap to each then generates a bitmap for each molecule in the database Generating a structural key is time consuming you have to do a substructure search for each pattern represented in the bitmap and repeat this for each molecule in the database The list of patterns that one might use is long Some examples are The presence absence of each element or if an element is common nitrogen for example several bits might represent at least 1 N at least 2 N at least 4 N and so forth Unusual or important electronic configurations such as sp3 carbon or triple bonded nitrogen Rings and ring systems such as cyclohexane pyridine or napthalene Common functional groups such as alcohols amines hydrocarbons and so forth Functional groups of special importance in a particular database For example a database of organo metallic molecules might have bits assigned for metal containing functional groups in a drug database one might have bits for specific skeletal features such as steroids and barbiturates Disjunctions of unusual features There might be patterns that are particularly rare thus not individually worth the cost of a bit yet extremely significant when they do occur Several such patterns can be assigned to the same bit if any one of the patterns is present the bit is set When a database is to be searched for a particular pattern a structural key is generated for the pattern As the search proceeds the pattern s structural key is compared to that of each molecule in the database If any TRUE bit in the pattern s key is not also TRUE in the molecule s key then the feature represented by that bit is not in the molecule and the pattern couldn t possibly be a substructure of the molecule Structural keys make a very fast screen for substructure searching since computers perform the necessary boolean operations very quickly Structural keys vary widely in size from a few tens or hundreds of bits to several thousand bits in a single database structural keys are usually all the same size since they all must represent the same thing The choice of size is a tradeoff between specificity and space The more bits there are the better the chances that the screen can say P in M and thus avoid a full substructure search 6 1 2 Fingerprints The next evolutionary step in high speed structural screening was the fingerprint a more abstract relative of the structural key The structural keys described above suffer from a lack of generality The choice of patterns included in the key has a critical effect on the search speed across the database An effective choice will screen out virtually all structures that aren t of interest greatly increasing search speed whereas a poor choice will cause many false hits which slows searching to a crawl The choice of patterns also depends on the nature of the queries to be made A structural key used by a group of pharmaceutical researchers might be nearly worthless to a group of petrochemical researchers Fingerprints address this lack of generality by eliminating the idea of pre defined patterns A fingerprint is a boolean array or bitmap but unlike a structural key there is no assigned meaning to each bit Your own fingerprint is very characteristic of you yet there is no meaning to any particular feature Similarly a pattern s fingerprint characterizes the pattern but the meaning of any particular bit is not well defined Unlike a structural key with its pre defined patterns the patterns for a molecule s fingerprint are generated from the molecule itself The fingerprinting algorithm examines the molecule and generates the following a pattern for each atom a pattern representing each atom and its nearest neighbors plus the bonds that join them a pattern representing each group of atoms and bonds connected by paths up to 2 bonds long atoms and bonds connected by paths up to 3 bonds long continuing with paths up to 4 5 6 and 7 bonds long For example the molecule OC CN would generate the following patterns bond paths C O N1 bond paths OC C C CN2 bond paths OC C C CN3 bond paths OC CN The list of patterns produced is exhaustive Every pattern in the molecule up to the pathlength limit is generated For all practical purposes the number of patterns one might encounter by this exhaustive search is infinite but the number produced for any particular molecule can be easily handled by a computer Because there is no pre defined set of patterns and because the number of possible patterns is so huge it is not possible to assign a particular bit to each pattern as we did with structural keys Instead each pattern serves as a seed to a pseudo random number generator it is hashed the output of which is a set of bits typically 4 or 5 bits per pattern the set of bits thus produced is added with a logical OR to the fingerprint Note that because each set of bits is produced by a pseudo random generator it is likely that sets will overlap For example suppose we are in the middle of generating a fingerprint and it happens that 1 4 of the bits are already set If the next pattern generates a set containing 5 bits the probability that all 5 bits will be unique is 3 4 5 or about 24 Likewise the probability that all 5 bits will not be unique are 1 4 5 or about 1 In spite of the difference between the meaning of a fingerprint s bits and a structural key s bits fingerprints share an important feature with structural keys If a pattern is a substructure of a molecule every bit that is set in the pattern s fingerprint will be set in the molecule s fingerprint This means that like structural keys we can use simple boolean operations on fingerprints to screen molecules as we search a database making a fingerprint comparison an extremely fast screen for substructure searching The best way to think of the bits of a fingerprint is as shared among an unknown but very large number of patterns Each pattern generates its particular set of bits so long as at least one of those bits is unique not shared with any other pattern present in the molecule we can tell if the pattern is present or not A structural key indicates with certainty that a particular pattern is present or absent Fingerprints are not so definite if a fingerprint indicates a pattern is missing then it certainly is but it can only indicate a pattern s presence with some probability Although a fingerprint doesn t indicate with 1 certainty that a particular pattern is present it contains far more patterns total than a structural key the net result being that a fingerprint is a far better screen than a structural key in almost all situations Fingerprints have several advantages over structural keys Since fingerprints have no pre defined set of patterns one fingerprinting system serves all databases and all types of queries More effective use is made of the bitmap Structural keys are usually very sparse mostly zeros since a typical molecule has very few of the patterns that the structural key s bits represent Although a mathematical analysis of fingerprint density is beyond the scope of this introduction it turns out that fingerprints can be relatively dense 2 4 ones without losing specificity The result is that a fingerprint can be much smaller than a structural key with the same discriminating power The patterns that go into a fingerprint are highly overlapped except for lone atoms each pattern shares portions of itself with at least one other pattern the example above illustrates this The result is that the more complex a molecule gets the more accurately its fingerprint characterizes it 6 1 3 Variable sized Fingerprints The next evolutionary step in screening was the concept of folding a fingerprint to increase information density In the discussion above we mentioned the sparseness of a fingerprint which is directly related to its information density A fingerprint s information density can be thought of as the ratio how much information it actually holds to how much it could hold As a practical definition we measure the bit density the ratio of on bits to the total number of bits e g the bit density of 11 is 25 Fingerprints for small molecules and featureless molecules such as CH4 or C4 H82 have less information in them than those for large or rich molecules But the fingerprinting mechanisms discussed so far require a fixed fingerprint size for all molecules If we choose to use small fingerprints the fingerprint of large or complex molecules will be black nearly all ones and will not discriminate well there is more information than the fingerprint can hold On the other hand if we use very large fingerprints most molecules fingerprints will be white nearly all zeros and will waste space In both cases we have low information density the black fingerprint because it is too dense and the white one because it is too sparse Ideally we would like to choose a particular discriminatory power e g For a typical pattern 98 of the database is screened out by the pattern s fingerprint and compute the fingerprint density needed to achieve that discriminatory power on a case by case basis Although we can not actually do this the process of folding achieves nearly the same performance and size as the ideal case The folding process begins with a fixed fingerprint size that is quite large large enough to accurately represent any molecule we expect to encounter The fingerprint is then folded we divide it into two equal halves then combine the two halves using a logical OR The result is a shorter fingerprint with a higher bit density We can repeatedly fold the fingerprint until the desired information density called the minimum density is reached or exceeded As long as two fingerprints are the same size even if created with different sizes they are compatible To see why consider the fingerprints of a pattern P and a molecule M If the screen is initially positive e g all bits in the P s fingerprints are also in M s then the same will be true after folding On the other hand a negative screen at least one bit in P s fingerprint is not in M s might be converted to a positive screen after folding But this is ok converting correct negative to a false positive doesn t violate the rules of screening a screen is only required to say P in M with 1 reliability With each fold we increase the chances of a false positive but save half of the space needed to store the fingerprint Fingerprint folding allows us to optimize the information density in a set of fingerprints thus optimizing screening speed Rather than choosing one fingerprint size for the entire database we choose the size of each molecule s fingerprint individually according to the complexity of the molecule and the desired success rate of the screening process In most real databases optimizing the information density greatly reduces the amount of data stored and increases the screening speed correspondingly 6 1 4 In memory Screening Although there is no reason a structural key can t reside in memory rather than on disk they tend to be considerably larger than fingerprints too large to fit a reasonable number of them into memory This was especially true when structural keys were first developed memory was several orders of magnitude more expensive than it is now and most computers had precious little of it Thus structural key screening has almost always been done as a disk based screening technique Computer memories are roughly 1 5 times faster than disks If one can read the bitmaps of a structural key or fingerprint into memory and search it there the speed of the screen itself increases a corresponding amount About the time fingerprints were developed computer memory prices reached a point where the fingerprints from a relatively large database all could be loaded into memory With the advent of in memory fingerprint based screening exploratory data analysis takes on a completely new aspect One can quite literally explore a database trying different searches refining them taking side tracks to see where they would lead and so on The evolution of the above described screening techniques has now reached the point where the SMILES and fingerprints of all chemicals known in the world roughly 1 15 million structures can fit in the memory of a large workstation class computer it doesn t even take a mainframe computer much less a supercomputer An ordinary database of tens or hundreds of thousands of molecules can easily fit into the memory of today s run of the mill workstations Speed increases are correspondingly dramatic an ordinary workstation can screen 1 to 1 structures per second using in memory folded fingerprints The number of molecules that can be considered in a single search has also grown dramatically It is now actually possible to search all known chemicals in the world in a reasonable time that is if you can get your hands on such a database Most users using a corporate or academic database of less than a million molecules will be able to search their database in a few seconds the time it takes to answer the question is now much shorter than the time it takes to think of the question even on relatively large databases 6 2 Fingerprints and Reactions There are two distinct types of fingerprints which the Daylight system provides for reaction processing First is the normal structural fingerprint which is useful as a superstructure search screen Second is the difference fingerprint which is useful as a metric for the bond changes which occur during a reaction 6 2 1 Structural Reaction Fingerprints The structural reaction fingerprint is nothing more than the combination of the normal structural fingerprints for the reactant and product molecules within the reaction The combination is the bitwise OR of the following fingerprints Fingerprint of the reactant partFingerprint of the product partBit shifted fingerprint of the product part This behavior allows the fingerprint to serve as a structural screen for superstructure matching and allows the fingerprint to provide some discrimination power between reactant and product parts Note that the agent molecules are not used in the structural fingerprint Once the structural reaction fingerprint has been generated all of the normal fingerprint operations folding similarity substructure screen apply 6 2 2 Reaction Difference Fingerprints The difference fingerprint is a new type of fingerprint specifically tailored for reaction processing If one has a reaction which is stoichiometric all atoms on the reactant side appear on the product side then the difference in the fingerprint of the reactant molecules and the fingerprint of the product molecules will reflect the bond changes which occur during the reaction On the surface one could perform an exclusive OR operation between the reactant and product fingerprint Unfortunately since the molecule fingerprints do not keep track of the count of paths many of the relevant bonds get masked out during the XOR operation What is required is to keep track of the count of each path in the reactant and product and then subtract the counts of a given path If the difference in count is non zero then the path is used to set a bit in the difference fingerprint If the difference in count is zero then no bit is set for that path in the difference fingerprint For example consider our well worn Sn2 displacement reaction I Na C CCBr Na Br C CCI The paths generated for the molecules would be as follows Enumerated Fingerprint Paths Path Length Reactant count path Product count path 1 I 1 Na 3 C 1 Br1 I 1 Na 3 C 1 Br11 C C 1 C C 1 C Br1 C C 1 C C 1 C I21 C C C 1 C C Br1 C C C 1 C C I31 C C C Br1 C C C I Difference in Path Counts Path Length Difference count path I Na C Br1 C C C C 1 C Br 1 C I2 C C C 1 C C Br 1 C C I31 C C C Br 1 C C C I After generating the difference in counts we only use the six paths with non zero differences to set bits in the difference fingerprint These are the paths which walk through bonds that change during the reaction By considering only these paths we get a fingerprint which reflects the overall bond changes in the reaction Once generated the difference fingerprint is a normal fingerprint and can be folded used for similarity measurements and clustering The difference fingerprint may not be used as a substructure screen for any types of searching since it does not obey the strict subset relationship required for screening In the above example note that the Na atom does not appear in any of the difference fingerprint paths Thus any search query which contained Sodium containing paths would not pass the screening step even if a valid query match 6 3 Similarity Measures One often wishes to know how similar one molecule is to another independent of whether either is a substructure of the other There are many ways one might choose to measure such similarity for example a chemical approach might rank them according to the number of physical properties and reactions they share whereas a mathematical approach might rank them according to their similarity in three dimensions The Daylight fingerprints described above effectively encode the substructures present in a molecule It would not seem unreasonable that the proportion of substructures in common between two molecules should be a reasonable measure of similarity of the overall molecules In mathematical terms this is a comparison of the bits in the fingerprints which are set on Note that the similarity measures are independent of the molecular feature descriptors Fingerprints generated from structural keys or any other method can be used in the Daylight toolkits The only requirements are that the size is a power of 2 and a multiple of 8 This ensures folding and translation to ascii representation works correctly The current size limitations are 32 to 23 If we describe our molecules by the presence or absence of features then the binary association coefficients or similarity measures are based on the four terms a b c d shown in the two way table OBJECT B 1 TotalsOBJECT A d b b d1 a c a c ATotalsa db c Bn Where a is the count of bits on in object A but not in object B b is the count of bits on in object B but not in object A c is the count of the bits on in both object A and object B d is the count of the bits off in both object A and object B In addition n a b c d A a c B b c Where n is the total number of bits on or off in objects A or B A is the count of the bits on in object A B is the count of the bits on in object B N B This nomenclature differs from that used by others in particular the Sheffield group In their system the labels a and c are reversed Pre 4 5 releases of the Daylight software provided an example of each of these classes The Euclidian coefficient E is defined as the square root of the ratio c d n As both numerator and denominator are functions of d E belongs to the first class of association coefficients dependent on the double zeros As we do not take the square root given mostly we are only interested in ranking it is simply a matching coefficient Sokal R R Michener C D 1958 The University of Kansas Scientific Bulletin 38 14 9 1438 In reality the value returned for this coefficient is the complement of this i e the Hamming distance or the Total Difference Coefficient Sneath P H A 1968 Journal of General Microbiology 54 1 11 a b n The Tanimoto coefficient T is defined as the ratio c a b c T is independent of d i e T belongs to the second class of association coefficients defined above It may be regarded as the proportion of the on bits which are shared See Tanimoto T T 1957 IBM Internal Report 17th Nov see also Jaccard P 19 1 Bulletin del la Soci t Vaudoisedes Sciences Naturelles 37 241 272 N B These association coefficients are not necessarily true metrics In particular those where the divisor depends on the particular pairwise comparison i e is not equal to n may violate the triangle inequality See Anderberg MR 1973 Cluster Analysis For Applications Academic Press p 117 for further discussion Over the years there has been much discussion as to which type of coefficient to use In chemistry it has generally been thought that as most descriptor features are absent in most molecules i e the bit string descriptors such as the Daylight fingerprint contains mainly zeros coefficients such as the Tanimoto are more appropriate Further given that the size of a Daylight fingerprint can be arbitrarily doubled thereby adding mainly random off bits any measure using matching off bits d would be inappropriate However this may not be the case for fixed width key based fingerprints Daylight therefore offers access to both types of measure The user must ensure that an appropriate one is chosen In version 4 5 Daylight extended the range of coefficients which could be used by introducing the asymmetric Tversky index This allowed users to make use of directional similarity and harness the power of the concepts of prototypes in similarity searching As has been indicated above all of these indices are not monotonic and as early as 1982 Hubalek see Hubalek Z Biol Rev 1982 57 669 689 showed that the coefficients could be clustered on the ranking of a given set of objects Recently Holliday et al Holliday JD Hu C Y and Willett P 2 2 Combinatorial Chemistry and High Throughput Screening 5 155 166 have shown that a whole range of similarity measures can be clustered on the ranking of chemical structures With the release of version 4 9 therefore we have introduced a whole range of named similarity measures and additionally allowed users to construct their own from the terms a b c d as appropriate 6 3 1 Tversky Index As of Release 4 51 the Tversky index Tversky A Psychological Reviews 1977 84 4 327 352 provides a more powerful method for structural similarity searching Its use and interpretation however are not not as simple as the Tanimoto index The Tversky comparison is intrinsically asymmetric As with Tanimoto the features present in two objects are compared In the Tversky approach we have the concept of a prototype to which the objects or variants are compared Note this differs from the Tanimoto index in which the similarity between two objects is estimated This inherent asymmetry means that the Tversky index is very definitely not a metric The ratio model in which the value is bounded between and 1 is defined as follows c a b c Setting the weighting of prototype features to the same value does not use the power of this index Indeed setting 1 produces the Tanimoto index If 5 we get the Dice index See below The value of the index comes from setting the weighting of prototype and variant features asymmetrically producing a similarity measure in a more substructural or more superstructural sense or reflecting the increased knowledge the user has about the prototype Quite often one is looking for compounds like a known compound with appropriate properties Setting the weighting of prototype features to 1 1 and variant features to means that only the prototype features are important i e this produces a superstucture likeness measure In this case a Tversky similarity value of 1 means that all prototype features are represented in the variant that none are Conversely setting the weights to prototype 1 variant 1 produces a substructure likeness measure where completely embedded structures have a 1 value and near substructures have values near 1 Note with no weight at all given to variant features this measure is pretty sensitive to noise in Daylight fingerprints and settings of 9 1 generally produce a more useful ranking Tversky measures where the two weightings add up to 1 1 are of special interest In XVMerlin the Tversky search query panel provides a Sum 1 checkbox which when selected forces the two weights to add up to 1 Advanced users may wish to experiment with Tversky indices where weightings are not limited to 1 Weightings greater than 1 causes the distinguishing features a b to be emphasized more than common features c which may be useful in analysis of diversity or dissimilarity 6 3 2 User defined and Named Similarity indexes With the 4 9 release users are able to use their own similarity measure throughout the software where before they have been restricted to the hardcoded measures described above The measure is entered as a string representing a f a b c d with all of the usual mathematical expressions available There is no restriction on the form of the function but to work as a measure of similarity it should fulfill certain requirements Expressions such as c d a b c 2 c d a b 2 c c d 2 a b c are not useful even though the user has attempted to alter the weights of the matched unmatched pairs It is nonsense to include in the numerator that which has been specifically excluded in the denominator Anderberg MR 1973 Cluster Analysis For Applications Academic Press p 89 Users should also be cognizant of the restrictions imposed by the descriptors being compared Daylight fingerprints can be arbitrarily doubled in size as described above The value of d can be increased enormously without scaled increases in the information rich on bits It is not recommended therefore that indexes based on a function which uses the value of d are used with Daylight type fingerprints In the case of fingerprints based on structure keys there may be no such restrictions When doing comparisons users should also be aware of the range of possible values the index can take Most have the range 1 but this is not mandatory The most common useful indexes have been collected by Holliday et al Holliday JD Hu C Y and Willett P 2 2 Combinatorial Chemistry and High Throughput Screening 5 155 166 These are shown in the table and can be referred to by name in applications and toolkits calls which allow user defined similarity functions Measure RangeFormulaCosine 1 Dice 1 Euclid 1 Forbes Hamman 1 1 Jaccard 1 Kulczynski 1 Manhattan 1 Matching 1 Pearson 1 1 Rogers Tanimoto 1 Russell Rao 1 Simpson 1 Tanimoto 1 Yule 1 1 Notes The Tanimoto and Jaccard indexes are the same The Forbes index has no upper limit The Manhattan index is a distance 1 Matching indexThe Kulczynski index is the mean of the individual substructure similaritiesThe Simpson index is the best of the individual substructure similaritiesThe Dice index is the ratio of the bits in common to the arithmetic mean of the number of on bits in the two items The Cosine index is the ration of the bits in common to the geometric mean of the number of on bits in the two items Go To Next Chapter 7 THOR Chemical Database System Back to Table of Contents", "_id": "http://www.ics.uci.edu/~dock/manuals/DaylightTheoryManual/theory.finger.html", "title": "daylight theory: fingerprints", "html": "<html><head> \n    <link rel=\"stylesheet\" href=\"/b.css\" type=\"text/css\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<title>Daylight Theory: Fingerprints</title></head>\n<body leftmargin=0 marginwidth=0 topmargin=0 marginheight=0> \n<table width=750 border=0 cellpadding=0 cellspacing=0> \n     <tr> \n     <td><iframe src=\"/iframes/header2.html\" name=\"iframe4\" width=\"745\" height=\"170\" \n     scrolling=\"no\" frameborder=0></iframe></td>  \n     </tr> \n</table> \n<table width=750 cellpadding=15> \n     <tr><td class=\"border-bot\">\n\n<h1><center>\n6. Fingerprints - Screening and Similarity</h1></center>\n\n\n<P><I>Similarity measures</I>, calculations that quantify the similarity\n      of two molecules, and <I>screening</I>, a way of rapidly eliminating\n      molecules as candidates in a substructure search, are both processes that\n      use <I>fingerprints</I>. Fingerprints are a very abstract representation\n      of certain structural features of a molecule; before we describe them,\n      we'll discuss the problems that inspired the development of the\n      fingerprinting techniques used in the Daylight Chemical Information\n      System. To begin, let us define a few terms: </P>\n    <DL>\n      <DT><B>pattern</B></DT>\n      <DD>The thing for which you are searching; also called a <I>target </I>or\n        <I>substructure</I>.</DD>\n    </DL>\n    \n    <DL>\n      <DT><B>molecule</B></DT>\n      <DD>The thing being searched. Sometimes called the <I>object </I>or <I>structure</I>.</DD>\n    </DL>\n\n    <DL>\n      <DT><B>N</B></DT>\n      <DD>The &quot;size&quot; of a pattern. Roughly speaking, equal to the\n        number of atoms and bonds the pattern contains (its exact definition\n        isn't important, only the general idea).</DD>\n    </DL>\n    \n    <DL>\n      <DT><B>P &nbsp;&#171;in&#187; &nbsp;M</B> </DT>\n      <DD>We use the &nbsp;&#171;in&#187;&nbsp;symbol to mean &quot;is a\n        substructure of&quot; - i.e. &quot;P &nbsp;&#171;in&#187; &nbsp;M&quot;\n        means &quot;pattern P is a substructure of molecule M&quot;. &quot;P\n        &nbsp;&#171;not in&#187;&nbsp; M&quot; means &quot;pattern P is not a\n        substructure of molecule M&quot;. </DD>\n    </DL>\n    \n    <DL>\n      <DT><B>O(f(N))</B></DT>\n      <DD>The <I>order</I> (computation time, or &quot;cost&quot;) of\n        performing a search. For example, O(N<SUP>2</SUP>) (pronounced &quot;order\n        N squared&quot;) means that the running time is proportional to the\n        square of a pattern's size. </DD>\n    </DL>\n    \n    <P>Substructure searching is known to be in the <I>non-polynomial-complete\n      (NP-complete) </I>class of computational problems. <I>Non polynomial</I>\n      means that the worst-case time to solve such a problem can never be\n      expressed as a polynomial in which the number of atoms and/or bonds is the\n      independent variable; i.e. it can't be of the form O(N<small><SUP>K</SUP></small>).\n      Instead, the worst-case time for a substructure search is always of the\n      form O(K<small><SUP>kN</SUP></small>). </P>\n    \n    <P> This is quite unfortunate. To see why, imagine (for simplicity) that a\n      substructure-search program takes 2<small><SUP>N</SUP></small>/10<small><SUP>6 </SUP></small>seconds\n      to compute where N is the number of atoms. This program can solve a 1-atom\n      problem in a microsecond, and a 10-atom problem takes about a millisecond.\n      This does not seem too bad until we realize that each time we add an atom\n      we double our time: a 20-atom problem takes about a second, and a 30-atom\n      problem takes 17 minutes. Clearly this algorithm will be inadequate as we\n      attempt to solve real chemical problems. By contrast, if we could find an\n      algorithm that ran in N<small><SUP>2</SUP></small>/10<small><SUP>3</SUP></small> seconds, it would be\n      1000 times slower on the 1-atom problem but could solve the 30-atom\n      problem in less than a second. Clearly a polynomial solution is better\n      than an exponential solution. </P>\n    \n    <P> Luckily, although substructure searching is polynomial in the worst\n      case, real chemicals don't exhibit the high connectivity which, in a\n      generalized mathematical graph, leads to worst-case behavior. Typical\n      chemical substructure searches take O(N<small><SUP>2</SUP></small>) or \n\t\tO(N<small><SUP>3</SUP></small>)\n      time, and although this is not exactly blazingly fast, it is a lot better\n      than exponential behavior. But even this polynomial performance is slow -\n      it can take a significant fraction of a second for a substructure search -\n      and NP-complete theory tells us that we might occasionally run into the\n      worst-case, an exponential-time search. </P>\n    \n    <P> One of the cold, hard facts about NP-complete problems is that there is\n      no way around them. If you think you've found a substructure-search\n      algorithm that <I>always</I> runs in polynomial time, you should try your\n      hand at a perpetual-motion machine. Your algorithm might work for most\n      cases, but if it always finishes in polynomial time some of its answers\n      must be wrong. </P>\n    \n    <P> Fortunately there is a &quot;hole&quot; of sorts in these cold, hard\n      facts: we can't detect the <I>presence</I> of a substructure in\n      polynomial time, but we can often detect the <I>absence</I> of a\n      substructure much faster, often <I>linear</I> time: O(N). The trick is to\n      use an &quot;imperfect&quot; algorithm, one that can\n      say <B>P&nbsp;&#171;not in&#187;&nbsp;M</B> with 100% confidence but\n      that can only say <B>P&nbsp;&#171;in&#187;&nbsp;M</B> with lower\n      confidence Such an algorithm, called a <I>screen</I>, does not\n      violate any mathematical laws - ultimately we still have to use a real\n      substructure search to get a \n      100%-confident <B>P&nbsp;&#171;in&#187;&nbsp;M</B>\n      answer - but our &quot;cheap&quot; algorithm screens out most cases,\n      avoiding the &quot;expensive&quot; algorithm most of the time. </P>\n    \n    <H2><A NAME=\"RTFToC77\"></a>6.1 A Brief History of Screening Large Databases</H2>\n  \n    \n    <P>Many substructure-searching problems call for repeatedly examining a\n      large number of molecules (typically stored in a database), comparing\n      each with a pattern. In such situations, it pays to spend some\n      time &quot;up front,&quot; storing the answers to specific questions\n      for each structure in the database. Subsequent searches of the database\n      use these pre-computed answers to vastly improve search time; the\n      up-front computation time is paid back quickly as repeated searches\n      are performed.\n    </P>\n    \n    <P> For example, one simple screen notes the molecular formula (MF) of each\n      molecule as it is added to the database. When a pattern is presented for\n      searching, we generate its molecular formula; during the search, we\n      compare the pattern's MF to each molecule's MF, and reject any molecules\n      that are missing atoms the pattern requires. By doing this, we eliminate\n      expensive substructure searches that are doomed to fail for the &quot;obvious&quot;\n      reason of not having enough of a particular element. If the MF screen says\n      <B>P&nbsp;&#171;not in&#187;&nbsp;M</B>, we can be 100% confident that it\n      is correct; if the molecular formulas are compatible we have to continue\n      with other screens or with the substructure search itself. </P>\n    \n    <P>Molecular Formula is only one of many screens we can apply, but it\n      illustrates the fundamental concept of screening: We only do the &quot;expensive&quot;\n      substructure search when no screen can say <B>P&nbsp;&#171;in&#187;&nbsp;M</B>.\n      By devising clever screens, we can increase the reliability of the screens\n      to where they reject almost all structures except those that ultimately\n      pass the substructure test (that is, the screens have very few &quot;false\n      positives&quot;). </P>\n    \n    <H3><A NAME=\"RTFToC79\"></a>6.1.1 Structural keys</H3>\n    \n    <P><I>Structural keys</I> were the first type of screen employed for\n      high-speed screening of chemical databases. A structural key is usually\n      represented as a <I>boolean array</I>, an array in which each element is\n      TRUE or FALSE. Boolean arrays in turn are usually represented as <I>bitmaps</I>,\n      an array of bytes or words in which each bit represents one position of\n      the boolean array. As the name implies, a <I>structural key</I> is a\n      bitmap in which each bit represents the presence (TRUE) or absence\n      (FALSE) of a specific structural feature (pattern). </P>\n    \n    <P>To make a structural key, one decides which structural features\n      (patterns) are important, assigns a bit of the bitmap to each, then\n      generates a bitmap for each molecule in the database. Generating a\n      structural key is time-consuming: you have to do a substructure search\n      for <I>each</I> pattern represented in the bitmap, and repeat this\n      for <I>each</I> molecule in the database. </P>\n    \n    <P>The list of patterns that one might use is long. Some examples are: </P>\n    \n     <UL>\n      <LI>The presence/absence of each element, or if an element is common\n        (nitrogen, for example), several bits might represent &quot;at\n        least 1 N&quot;, &quot;at least 2 N&quot;, &quot;at \n        least 4 N&quot;, and so forth.</LI>\n      <p></p>\n      <LI>Unusual or important electronic configurations, such as \n\t\t&quot;sp<small><sup>3</sup></small>\n        carbon&quot; or &quot;triple-bonded nitrogen.&quot;</LI>\n      <p></p>\n      <LI>Rings and ring systems, such as cyclohexane, pyridine, or\n         napthalene.</LI>\n      <p></p>\n      <LI>Common functional groups, such as alcohols, amines, hydrocarbons, and\n        so forth.</LI>\n      <p></p>\n      <LI>Functional groups of special importance in a particular database. For\n        example, a database of organo-metallic molecules might have bits\n        assigned for metal-containing functional groups; in a drug database one\n        might have bits for specific skeletal features such as steroids and\n        barbiturates.</LI>\n      <p></p>\n      <LI> &quot;Disjunctions&quot; of unusual features. There might be\n        patterns that are particularly rare, thus not individually worth the &quot;cost&quot;\n        of a bit, yet extremely significant when they do occur. Several such\n        patterns can be assigned to the same bit; if any one of the patterns is\n        present the bit is set.</LI>\n    </UL>\n    \n    <P> When a database is to be searched for a particular pattern, a\n      structural key is generated for the pattern. As the search proceeds, the\n      pattern's structural key is compared to that of each molecule in the\n      database. If any TRUE bit in the pattern's key is not also TRUE in the\n      molecule's key, then the feature represented by that bit is not in the\n      molecule, and the pattern couldn't possibly be a substructure of the\n      molecule. Structural keys make a very fast screen for substructure\n      searching since computers perform the necessary boolean operations very\n      quickly. </P>\n    \n    <P> Structural keys vary widely in size, from a few tens or hundreds of\n      bits to several thousand bits (in a single database, structural keys are\n      usually all the same size since they all must represent the same thing).\n      The choice of size is a tradeoff between specificity and space: The more\n      bits there are, the better the chances that the screen can say <B>P&nbsp;&#171;in&#187;&nbsp;M</B>\n      and thus avoid a full substructure search. </P>\n    \n    <H3><A NAME=\"RTFToC80\"></a>6.1.2 Fingerprints</H3>\n    \n    <P>The next evolutionary step in high-speed structural screening was the\n      <I>fingerprint</I>, a more abstract relative of the structural key.</P>\n    \n    <P>The structural keys described above suffer from a lack of generality.\n      The choice of patterns included in the key has a critical effect on the\n      search speed across the database: An effective choice will screen out\n      virtually all structures that aren't of interest, greatly increasing\n      search speed, whereas a poor choice will cause many &quot;false hits,&quot;\n      which slows searching to a crawl. The choice of patterns also depends on\n      the nature of the queries to be made: A structural key used by a group of\n      pharmaceutical researchers might be nearly worthless to a group of\n      petrochemical researchers. </P>\n    \n    <P> <I>Fingerprints</I> address this lack of generality by eliminating the\n      idea of pre-defined patterns. A fingerprint is a boolean array, or bitmap,\n      but unlike a structural key there is no assigned meaning to each bit. Your\n      own fingerprint is very characteristic of you, yet there is no meaning to\n      any particular feature. Similarly, a pattern's fingerprint characterizes\n      the pattern, but the meaning of any particular bit is not well defined.\n    </P>\n    \n    <P> Unlike a structural key with its pre-defined patterns, the patterns for\n      a molecule's fingerprint are generated from the molecule itself. The\n      fingerprinting algorithm examines the molecule and generates the\n      following: </P>\n    \n    <UL>\n      <LI>a pattern for each atom</LI>\n        <p></p>\n      <LI>a pattern representing each atom and its nearest neighbors (plus the\n        bonds that join them)</LI>\n        <p></p>\n      <LI>a pattern representing each group of atoms and bonds connected by\n        paths up to 2 bonds long</LI>\n        <p></p>\n      <LI>... atoms and bonds connected by paths up to 3 bonds long</LI>\n        <p></p>\n      <LI>... continuing, with paths up to 4, 5, 6, and 7 bonds long.</LI>\n    </UL>\n    \n    <P> For example, the molecule <b>OC=CN</b> would generate the following\n      patterns: </P>\n    \n    <CENTER>\n    <TABLE>\n      <TBODY>\n      <TR>\n        <TD><I>0-bond paths:</I></TD>\n        <TD>&nbsp;&nbsp;<b>C</b></TD>\n        <TD>&nbsp;&nbsp;<b>O</b></TD>\n        <TD>&nbsp;&nbsp;<b>N</b></TD>\n      </TR>\n      <TR>\n        <TD><I>1-bond paths:</I></TD>\n        <TD>&nbsp;&nbsp;<b>OC</b></TD>\n        <TD>&nbsp;&nbsp;<b>C=C</b></TD>\n        <TD>&nbsp;&nbsp;<b>CN</b></TD>\n      </TR>\n      <TR>\n        <TD><I>2-bond paths:</I></TD>\n        <TD>&nbsp;&nbsp;<b>OC=C</b></TD>\n        <TD>&nbsp;&nbsp;<b>C=CN</b></TD>\n        <TD></TD>\n      </TR>\n      <TR>\n        <TD><I>3-bond paths:</I></TD>\n        <TD>&nbsp;&nbsp;<b>OC=CN</b></TD>\n        <TD COLSPAN=\"2\"></TD>\n      </TR></TBODY>\n    </TABLE> </CENTER>\n    \n    <P></P>\n    \n    <P> The list of patterns produced is exhaustive: <I>Every</I> pattern in\n      the molecule, up to the pathlength limit, is generated. For all practical\n      purposes, the number of patterns one might encounter by this exhaustive\n      search is infinite, but the number produced for any <I>particular</I>\n      molecule can be easily handled by a computer. </P>\n    \n    <P> Because there is no pre-defined set of patterns, and because the number\n      of possible patterns is so huge, it is not possible to assign a particular\n      bit to each pattern as we did with structural keys. Instead, each pattern\n      serves as a seed to a pseudo-random number generator (it is &quot;hashed&quot;),\n      the output of which is a set of bits (typically 4 or 5 bits per pattern);\n      the set of bits thus produced is added (with a logical <TT>OR)</TT> to\n      the fingerprint. </P>\n    \n    <P> Note that because each set of bits is produced by a pseudo-random\n      generator, it is likely that sets will overlap. For example, suppose we\n      are in the middle of generating a fingerprint, and it happens that 1/4 of\n      the bits are already set. If the next pattern generates a set containing 5\n      bits, the probability that all 5 bits will be unique is (3/4)<small><SUP>5</SUP></small>,\n      or about 24%. Likewise, the probability that all 5 bits will <I>not</I>\n      be unique are (1/4)<small><SUP>5</SUP></small></uch as CHsmall>, or about 0.1%. </P>\n    \n    <P> In spite of the difference between the meaning of a fingerprint's bits\n      and a structural key's bits, fingerprints share an important feature with\n      structural keys: If a pattern is a substructure of a molecule,<I> every\n      bit that is set in the pattern's fingerprint will be set in the molecule's\n      fingerprint.</I> This means that, like structural keys, we can use simple\n      boolean operations on fingerprints to screen molecules as we search a\n      database, making a fingerprint comparison an extremely fast screen for\n      substructure searching. </P>\n    \n    <P> The best way to think of the bits of a fingerprint is as &quot;shared&quot;\n      among an unknown but very large number of patterns. Each pattern generates\n      its particular set of bits; so long as at least one of those bits is\n      unique (not shared with any other pattern present in the molecule), we can\n      tell if the pattern is present or not. A structural key indicates with\n      certainty that a particular pattern is present or absent. Fingerprints are\n      not so definite: if a fingerprint indicates a pattern is missing then it\n      certainly is, but it can only indicate a pattern's presence with some\n      probability. Although a fingerprint doesn't indicate with 100% certainty\n      that a particular pattern is present, it contains far more patterns total\n      than a structural key, the net result being that a fingerprint is a far\n      better screen than a structural key in almost all situations. </P>\n    \n    <P> Fingerprints have several advantages over structural keys: </P>\n    \n    <UL>\n      <LI>Since fingerprints have no pre-defined set of patterns, one\n        fingerprinting system serves all databases and all types of\n        queries.</LI>\n    <P> </P>\n      <LI> More effective use is made of the bitmap. Structural keys are\n        usually very &quot;sparse&quot; (mostly zeros) since a typical molecule\n        has very few of the patterns that the structural key's bits represent.\n        Although a mathematical analysis of fingerprint density is beyond the\n        scope of this introduction, it turns out that fingerprints can be\n        relatively &quot;dense&quot; (20-40% ones) without losing specificity.\n        The result is that a fingerprint can be much smaller than a structural\n        key with the same discriminating power.</LI>\n    <P></P>\n      <LI>The patterns that go into a fingerprint are highly overlapped -\n        except for &quot;lone atoms&quot;, each pattern shares portions of\n        itself with at least one other pattern (the example above illustrates\n        this). The result is that the more complex a molecule gets, the more\n        accurately its fingerprint characterizes it.</LI>\n    </UL>\n    \n    <H3><A NAME=\"RTFToC81\"></a>6.1.3 Variable-sized Fingerprints</H3>\n    \n    <P>The next evolutionary step in screening was the concept of <I>folding</I>\n      a fingerprint to increase information density. </P>\n    \n    <P>In the discussion above we mentioned the <I>sparseness</I> of a\n      fingerprint, which is directly related to its <I>information density</I>.\n      A fingerprint's information density can be thought of as the ratio how\n      much information it actually holds to how much it could hold. As a\n      practical definition, we measure the <I>bit density</I>, the ratio of &quot;on&quot;\n      bits to the total number of bits (e.g. the bit density of &quot;11000000&quot;\n      is 0.25). </P>\n    \n    <P>Fingerprints for small molecules and &quot;featureless&quot; molecules\n      (such as <b>CH4</b> or <b>C40H82</b>) have less information in them than those for large\n      or &quot;rich&quot; molecules. But the fingerprinting mechanisms discussed\n      so far require a fixed fingerprint size for all molecules. If we choose to\n      use small fingerprints, the fingerprint of large or complex molecules will\n      be &quot;black&quot; - nearly all ones - and will not discriminate well\n      (there is more information than the fingerprint can hold). On the other\n      hand, if we use very large fingerprints, most molecules' fingerprints will\n      be &quot;white&quot; - nearly all zeros - and will waste space. In both\n      cases we have low information density; the &quot;black&quot; fingerprint\n      because it is too dense and the &quot;white&quot; one because it is too\n      sparse.</P>\n    \n    <P>Ideally, we would like to choose a particular discriminatory power (e.g.\n      &quot;For a typical pattern, 98% of the database is screened out by the\n      pattern's fingerprint&quot;) and compute the fingerprint density needed to\n      achieve that discriminatory power on a case-by-case basis. Although we can\n      not actually do this, the process of &quot;folding&quot; achieves nearly\n      the same performance and size as the &quot;ideal&quot; case. </P>\n    \n    <P>The folding process begins with a fixed fingerprint size that is quite\n      large - large enough to accurately represent any molecule we expect to\n      encounter. The fingerprint is then <I>folded</I>: we divide it into two\n      equal halves then combine the two halves using a logical OR. The result is\n      a shorter fingerprint with a higher bit density. We can repeatedly fold\n      the fingerprint until the desired information density (called the <I>minimum\n      density</I>) is reached or exceeded. </P>\n    \n    <P> As long as two fingerprints are the same size (even if created with\n      different sizes), they are compatible. To see why, consider the\n      fingerprints of a pattern P and a molecule M. If the screen is initially\n      positive (e.g. all bits in the P's fingerprints are also in M's) then the\n      same will be true after folding. On the other hand, a negative screen (at\n      least one bit in P's fingerprint is not in M's) might be converted to a\n      positive screen after folding. But this is ok - converting &quot;correct\n      negative&quot; to a &quot;false positive&quot; doesn't violate the rules\n      of screening: a screen is only required to say <B>P&nbsp;&#171;in&#187;&nbsp;M</B>\n      with 100% reliability. With each fold, we increase the chances of a false\n      positive but save half of the space needed to store the fingerprint. </P>\n    \n    <P>Fingerprint folding allows us to optimize the information density in a\n      set of fingerprints, thus optimizing screening speed. Rather than choosing\n      one fingerprint size for the entire database, we choose the size of each\n      molecule's fingerprint individually, according to the complexity of the\n      molecule and the desired success rate of the screening process. In most\n      real databases, optimizing the information density greatly reduces the\n      amount of data stored, and increases the screening speed correspondingly.\n    </P>\n    \n    <H3><A NAME=\"RTFToC82\"></a>6.1.4 In-memory Screening</H3>\n    \n    <P>Although there is no reason a structural key can't reside in memory\n      rather than on disk, they tend to be considerably larger than\n      fingerprints, too large to fit a reasonable number of them into memory.\n      This was especially true when structural keys were first developed -\n      memory was several orders of magnitude more expensive than it is now, and\n      most computers had precious little of it. Thus, structural-key screening\n      has almost always been done as a disk-based screening technique. </P>\n    \n    <P>Computer memories are roughly 10<small><SUP>5</SUP></small> times faster than disks.\n      If one can read the bitmaps of a structural key or fingerprint into memory\n      and search it there, the speed of the screen itself increases a\n      corresponding amount. About the time fingerprints were developed, computer\n      memory prices reached a point where the fingerprints from a relatively\n      large database all could be loaded into memory. </P>\n    \n    <P>With the advent of in-memory fingerprint-based screening, exploratory\n      data analysis takes on a completely new aspect. One can quite literally &quot;explore&quot;\n      a database, trying different searches, refining them, taking side-tracks\n      to see where they would lead, and so on. </P>\n    \n    <P>The evolution of the above-described screening techniques has now\n      reached the point where the SMILES and fingerprints of all chemicals known\n      in the world (roughly 10-15 million structures) can fit in the memory of a\n      large workstation-class computer; it doesn't even take a &quot;mainframe&quot;\n      computer, much less a supercomputer. An ordinary database of tens or\n      hundreds of thousands of molecules can easily fit into the memory of\n      today's run-of-the-mill workstations. Speed increases are correspondingly\n      dramatic: an ordinary workstation can screen 100,000 to 1,000,000\n      structures per second using in-memory folded fingerprints. </P>\n    \n    <P>The number of molecules that can be considered in a single search has\n      also grown dramatically. It is now actually possible to search all known\n      chemicals in the world in a reasonable time (that is, if you can get your\n      hands on such a database). Most users, using a corporate or academic\n      database of less than a million molecules, will be able to search their\n      database in a few seconds - the time it takes to answer the question is\n      now much shorter than the time it takes to think of the question, even on\n      relatively large databases. </P>\n\n<h2><a name=\"RTFrxn8\">6.2 Fingerprints and Reactions</a></h2>\n</p>\n<p>\nThere are two distinct types of fingerprints which the Daylight system\nprovides for reaction processing.  First is the &quot;normal&quot; structural\nfingerprint, which is useful as a superstructure search screen.  Second is the\n&quot;difference&quot; fingerprint, which is useful as a metric for the bond\nchanges which occur during a reaction.\n</p>\n<p>\n<h3><a name=\"RTFrxn9\">6.2.1 Structural Reaction Fingerprints</a></h3>\n</p>\n<p>\nThe structural reaction fingerprint is nothing more than the combination of\nthe normal structural fingerprints for the reactant and product molecules\nwithin the reaction.  The combination is the bitwise-OR of the following\nfingerprints: \n</p>\n<ul>\n  <li>Fingerprint of the reactant part</li>\n  <li>Fingerprint of the product part</li>\n  <li>Bit-shifted fingerprint of the product part</li>\n</ul>\nThis behavior allows the fingerprint to serve as a structural screen for\nsuperstructure-matching and allows the fingerprint to provide some\ndiscrimination power between reactant and product parts.  Note that the agent\nmolecules are not used in the structural fingerprint.\n<p>\nOnce the structural reaction fingerprint has been generated, all of the normal\nfingerprint operations (folding, similarity, substructure screen) apply.\n</p>\n<p>\n<h3><a name=\"RTFrxn10\">6.2.2 Reaction Difference Fingerprints</a></h3>\n</p>\n<p>\nThe difference fingerprint is a new type of fingerprint specifically tailored\nfor reaction processing.  If one has a reaction which is stoichiometric (all\natoms on the reactant side appear on the product side), then the difference in\nthe fingerprint of the reactant molecules and the fingerprint of the product\nmolecules will reflect the bond changes which occur during the reaction.\n</p>\n<p>\nOn the surface, one could perform an &quot;exclusive-OR&quot; operation\nbetween the reactant and product fingerprint.  Unfortunately, since the\nmolecule fingerprints do not keep track of the count of paths many of the\nrelevant bonds get masked out during the &quot;XOR&quot; operation.  What is\nrequired is to keep track of the count of each path in the reactant and\nproduct and then subtract the counts of a given path.  If the difference in\ncount is non-zero, then the path is used to set a bit in the difference\nfingerprint. If the difference in count is zero, then no bit is set for that\npath in the difference fingerprint.\n</p>\n<p>\nFor example, consider our well-worn Sn2 displacement reaction:\n</p>\n<p>\n<center><b>[I-].[Na+].C=CCBr&gt;&gt;[Na+].[Br-].C=CCI</b></center>\n</p>\n<p>\nThe paths generated for the molecules would be as follows:\n</p>\n<p>\n\n<center>\n<table border=\"1\">\n  <tr>\n    <td colspan=\"3\" align=\"center\">\n    <b>Enumerated Fingerprint Paths:</b>\n    <tr>\n      <td align=\"center\">Path Length:</td>\n      <td align=\"center\">Reactant (count/path):</td>\n      <td align=\"center\">Product (count/path):</td>\n    </tr>\n    <tr>\n      <td align=\"center\">0</td>\n      <td align=\"center\">1 I, 1 Na, 3 C, 1 Br</td>\n      <td align=\"center\">1 I, 1 Na, 3 C, 1 Br</td>\n    </tr>\n    <tr>\n      <td align=\"center\">1</td>\n      <td align=\"center\">1 C=C, 1 C-C, 1 C-Br</td>\n      <td align=\"center\">1 C=C, 1 C-C, 1 C-I</td>\n    </tr>\n    <tr>\n      <td align=\"center\">2</td>\n      <td align=\"center\">1 C=C-C, 1 C-C-Br</td>\n      <td align=\"center\">1 C=C-C, 1 C-C-I</td>\n    </tr>\n    <tr>\n      <td align=\"center\">3</td>\n      <td align=\"center\">1 C=C-C-Br</td>\n      <td align=\"center\">1 C=C-C-I</td>\n    </tr>\n    </td>\n  </tr>\n</table>\n</p>\n\n<p>\n<table border=\"1\">\n  <tr>\n    <td colspan=\"2\" align=\"center\">\n    <b>Difference in Path Counts:</b>\n    <tr>\n      <td align=\"center\">Path Length:</td>\n      <td align=\"center\">Difference (count/path):</td>\n    </tr>\n    <tr>\n      <td align=\"center\">0</td>\n      <td align=\"center\">0 I, 0 Na, 0 C, 0 Br</td>\n    </tr>\n    <tr>\n      <td align=\"center\">1</td>\n      <td align=\"center\">0 C=C, 0 C-C, 1 C-Br, 1 C-I</td>\n    </tr>\n    <tr>\n      <td align=\"center\">2</td>\n      <td align=\"center\">0 C=C-C, 1 C-C-Br, 1 C-C-I</td>\n    </tr>\n    <tr>\n      <td align=\"center\">3</td>\n      <td align=\"center\">1 C=C-C-Br, 1 C=C-C-I</td>\n    </tr>\n    </td>\n  </tr>\n</table>\n</center>\n</p>\n\n<p>\nAfter generating the difference in counts, we only use the six paths with\nnon-zero differences to set bits in the difference fingerprint.  These are\nthe paths which walk through bonds that change during the reaction.  By\nconsidering only these paths, we get a fingerprint which reflects the overall\nbond changes in the reaction.\n</p>\n<p>\nOnce generated, the difference fingerprint is a normal fingerprint and can be\nfolded, used for similarity measurements and clustering.  The difference\nfingerprint may not be used as a substructure screen for any types of\nsearching, since it does not obey the strict subset relationship required for\nscreening.  In the above example, note that the &quot;[Na+]&quot; atom does\nnot appear in any of the difference fingerprint paths.  Thus, any search query\nwhich contained Sodium-containing paths would not pass the screening step, even\nif a valid query match.\n</p>\n<p>\n\n\n    \n    <H2><A NAME=\"RTFToC83\"></a>6.3 Similarity Measures</H2>\n    \n    <P>One often wishes to know how similar one molecule is to another,\n      independent of whether either is a substructure of the other. There are\n      many ways one might choose to measure such similarity; for example a\n      chemical approach might rank them according to the number of physical\n      properties and reactions they share, whereas a mathematical approach\n      might rank them according to their similarity in three dimensions.</P>\n    \n    <P>The Daylight fingerprints described above effectively encode the\n      substructures present in a molecule. It would not seem unreasonable that\n      the proportion of substructures in common between two molecules should be\n      a reasonable measure of similarity of the overall molecules. In\n      mathematical terms this is a comparison of the bits in the fingerprints\n      which are set on. </P>\n    \n    <P>Note that the similarity measures are independent of the molecular\n      feature descriptors. Fingerprints generated from structural keys or any\n      other method can be used in the Daylight toolkits. The only requirements\n      are that the size is a power of 2 and a multiple of 8. This ensures\n      folding and translation to ascii representation works correctly. The\n      current size limitations are 32 to 2<small><SUP>30</SUP></small></P>\n\n\n    <P>If we describe our molecules by the presence or absence of features,\n      then the <I>binary association coefficients</I> or <I>similarity\n      measures</I> are based on the four terms <B>a</B>, <B>b</B>, <B>c</B>,\n      <B>d</B> shown in the two way table. </P>\n    \n    <CENTER>\n    <TABLE WIDTH=\"50%\" BORDER=\"2\" CELLPADDING=\"1\" CELLSPACING=\"1\">\n      <TR>\n        <TD COLSPAN=\"2\" ROWSPAN=\"2\"></TD>\n        <TH COLSPAN=\"3\" ALIGN=\"center\">OBJECT B </TH>\n      </TR>\n      <TR>\n        <TH>0 </TH>\n        <TH>1 </TH>\n        <TH>Totals</TH>\n      </TR>\n      <TR ALIGN=\"center\">\n        <TH ROWSPAN=\"3\">OBJECT A </TH>\n        <TH>0 </TH>\n        <TD ALIGN=\"CENTER\"><B>d</B> </TD>\n        <TD ALIGN=\"CENTER\"><B>b</B> </TD>\n        <TD ALIGN=\"CENTER\"><B>b+ d</B></TD>\n      </TR>\n      <TR ALIGN=\"center\">\n        <TH>1 </TH>\n        <TD ALIGN=\"CENTER\"><B>a</B> </TD>\n        <TD ALIGN=\"CENTER\"><B>c</B> </TD>\n        <TD ALIGN=\"CENTER\"><B>a + c = A</B></TD>\n      </TR>\n      <TR ALIGN=\"center\">\n        <TH>Totals</TH>\n        <TD ALIGN=\"CENTER\"><B>a + d</B></TD>\n        <TD ALIGN=\"CENTER\"><B>b + c = B</B></TD>\n        <TD ALIGN=\"CENTER\"><B>n</B></TD>\n      </TR>\n    </TABLE></CENTER>\n    <ul>\n    <P>Where:<BR>\n      <DFN><B>a</B> is the count of bits on in object A but not in object B.<BR>\n      <B>b</B> is the count of bits on in object B but not in object A.<BR>\n      <B>c</B> is the count of the bits on in both object A and object B.<BR>\n      <B>d</B> is the count of the bits off in both object A and object B.<BR>\n      </DFN></P>\n    \n    <P>In addition:<BR>\n      <DFN><B>n</B> = ( <B>a</B> + <B>b</B> + <B>c</B> + <B>d</B> )<BR>\n      <B>A</B> = ( <B>a</B> + <B>c</B> )<BR>\n      <B>B</B> = ( <B>b</B> + <B>c</B> )<BR>\n      \n      </DFN></P>\n    \n    <P>Where:<BR><DFN><B>n</B> is the total number of bits on or off in objects A \n\t\t<I><B>or</B> </I>B.<BR>\n      <B>A</B> is the count of the bits on in object A.<BR>\n      <B>B</B> is the count of the bits on in object B.<BR>\n      \n\n      </DFN></P>\n    </ul>\n    \n    <P><FONT SIZE=\"-1\"><B>N.B</B>. This nomenclature differs from that used\n      by others, in particular the Sheffield group. In their system the labels\n      <B>a</B> and <B>c</B> are reversed. </FONT></P>\n    \n    <P>Pre 4.5 releases of the Daylight software provided an example of each of\n      these classes. <BR> </P>\n    \n    <P></P>\n    <UL>\n      <LI>The <b>Euclidian</b> coefficient, <B>E</B> is defined as the square root of\n        the ratio:<BR>\n        \n        <CENTER> <B>( c + d )/n</B> </CENTER>\n        \n        <P> As both numerator and denominator are functions of <B>d</B>, <B>E</B>\n          belongs to the first class of association coefficients dependent on\n          the double zeros.</P>\n         As we do not take the square root, given mostly we are only interested\n        in ranking ; it is simply a matching coefficient (<CITE>Sokal, R.R.,\n        Michener, C.D., (1958) The University of Kansas Scientific Bulletin <B>38</B>,\n        1409-1438</CITE>).\n        \n        In reality the value returned for this coefficient\n          is the complement of this, i.e. the Hamming distance, or the Total\n          Difference Coefficient (<CITE>Sneath, P.H.A., (1968) Journal of\n          General Microbiology <B>54</B>, 1-11</CITE>)</P>\n\n        <CENTER> <B>( a + b )/n</B> </CENTER> </LI>\n    </UL>\n\n    <UL>\n      <LI>The <b>Tanimoto</b> coefficient, <B>T</B>, is defined as the ratio:<BR>\n        \n        <P></P>\n        <CENTER> <B>c/(a + b + c)</B></CENTER>\n        \n        <P><B>T</B> is independent of <B>d</B>, i.e. <B>T</B> belongs to the\n          second class of association coefficients defined above. It may be \n\t\tregarded as the proportion of the &quot;on-bits&quot; which\n          are shared. See <CITE>Tanimoto, T.T. (1957)\n        IBM Internal Report 17th Nov</CITE> see also<CITE> Jaccard, P. (1901)\n        Bulletin del la Soci&eacute;t&eacute; Vaudoisedes Sciences Naturelles\n        <B>37</B>, 241-272 </CITE>.</P></LI>\n    </UL>\n    \n    <P><FONT SIZE=\"-1\"><B>N.B</B>. These association coefficients are not\n      necessarily true metrics. In particular those where the divisor depends on\n      the particular pairwise comparison i.e. is not equal to <B>n</B>, may\n      violate the triangle inequality. See <CITE>Anderberg, MR (1973) Cluster\n      Analysis For Applications, Academic Press p 117</CITE>, for further discussion.</FONT></P>\n    \n    <P>Over the years there has been much discussion as to which type of\n      coefficient to use. In chemistry it has generally been thought that, as\n      most descriptor features are absent in most molecules, i.e. the bit string\n      descriptors such as the Daylight fingerprint contains mainly zeros,\n      coefficients such as the Tanimoto are more appropriate. Further, given\n      that the size of a Daylight fingerprint can be arbitrarily doubled,\n      thereby adding mainly random off bits, any measure using matching\n      off-bits, <B>d</B>, would be inappropriate. However this may not be the\n      case for fixed width key based fingerprints. Daylight therefore offers\n      access to both types of measure. The user must ensure that an appropriate\n      one is chosen. </P>\n    \n    <P>In version 4.5 Daylight extended the range of coefficients which could\n      be used by introducing the asymmetric\n      <A HREF=\"theory.finger.html#RTFToC87\">Tversky</A> index. This allowed\n      users to make use of directional similarity and harness the power of the\n      concepts of prototypes in similarity searching.</P>\n    \n    <P>As has been indicated above all of these indices are not monotonic, and\n      as early as 1982 Hubalek (see <CITE> Hubalek, Z. Biol. Rev. (1982) <B>57</B>,\n      669-689)</CITE> showed that the coefficients could be clustered on the\n      ranking of a given set of objects. </P>\n    \n    <P>Recently Holliday <I>et al </I>( <CITE>Holliday, JD., Hu, C-Y. and\n      Willett, P. (2002) Combinatorial Chemistry and High Throughput Screening\n      <B>5,</B> 155-166</CITE> ) have shown that a whole range of similarity\n      measures can be clustered on the ranking of chemical structures.</P>\n    \n    <P>With the release of version 4.9 therefore, we have introduced a whole\n      range of named similarity measures\n      and additionally allowed users to construct their own, from the terms <B>a</B>,\n      <B>b</B>, <B>c, d </B>as appropriate.</P>\n\n    <H3><A NAME=\"RTFToC87\"></a>6.3.1 Tversky Index</H3>    \n    <P> As of Release 4.51 the Tversky index (<CITE>Tversky, A. Psychological\n      Reviews (1977)84 (4) 327-352</CITE>), provides a more powerful method for\n      structural similarity searching. Its use and interpretation, however, are\n      not not as simple as the Tanimoto index. The Tversky comparison is\n      intrinsically asymmetric. As with Tanimoto the features present in two\n      objects are compared. In the Tversky approach we have the concept of a &quot;prototype&quot;\n      <I>to which</I> the objects or &quot;variants&quot; are compared. Note\n      this differs from the Tanimoto index in which the similarity <I>between</I>\n      two objects is estimated. This inherent asymmetry means that the Tversky\n      index is very definitely not a metric. The <I>ratio model</I> in which\n      the value is bounded (between 0 and 1) is defined as follows:<BR>\n       </P>\n    \n    <P ALIGN=\"CENTER\"><B>c/(</B>&alpha;<B>*\n      a + &beta;*\n      b + c)</B></P>\n    \n    <P>Setting the weighting of prototype features to the same value does not\n      use the power of this index. Indeed, setting &alpha;\n      = &beta;=\n      1, produces the Tanimoto index. If &alpha;\n      = &beta;=\n      0.5 we get the Dice index. <A HREF=\"theory.finger.html#RTFToC88\">See\n        below.</A>\n\n       The value of the index comes from setting the weighting of prototype and\n      variant features asymmetrically, producing a similarity measure in a\n      more-substructural or more-superstructural sense or reflecting the\n      increased knowledge the user has about the prototype. Quite often one is\n      looking for compounds <I> like</I> a known compound with appropriate\n      properties. </P>\n    \n    <P>Setting the weighting of prototype features to 100% (&alpha;=1)\n      and variant features to 0% (&beta;=0)\n      means that only the prototype features are important, i.e., this produces\n      a &quot;superstucture-likeness&quot; measure. In this case, a Tversky\n      similarity value of 1.0 means that all prototype features are represented\n      in the variant, 0.0 that none are. </P>\n        \n    <P>Conversely, setting the weights to 0% prototype (&alpha;=0)\n      / 100% variant (&beta;=1)\n      produces a &quot;substructure-likeness&quot; measure, where completely\n      embedded structures have a 1.0 value and &quot;near-substructures&quot;\n      have values near 1.0. Note: with no weight at all given to variant\n      features, this measure is pretty sensitive to &quot;noise&quot; in\n      Daylight fingerprints and settings of 90%/10% generally produce a more\n      useful ranking. </P>\n    \n    <P> Tversky measures where the two weightings add up to 100% (1.0) are of\n      special interest. In XVMerlin the Tversky search query panel provides a &quot;Sum\n      100%&quot; checkbox which, when selected, forces the two weights to add up\n      to 100%. </P>\n    \n    <P> Advanced users may wish to experiment with Tversky indices where\n      weightings are not limited to 100%.\nWeightings greater than 100% causes the distinguishing features <B>a, b</B>\n      to be emphasized more than common features, <B>c</B>, which may be useful\n      in analysis of diversity or dissimilarity. </P>\n    \n    <H3><A NAME=\"RTFToC88\"></a>6.3.2 User-defined and Named Similarity indexes\n    </H3>\n    \n    <P>With the 4.9 release, users are able to use their own similarity measure\n      throughout the software, where before they have been restricted to the\n      hardcoded measures described above. The measure is entered as a string\n      representing a <B>f( a, b, c, d)</b> with all of the usual mathematical\n      expressions available. There is no restriction on the form of the function, \n\tbut to work as a\n      measure of similarity it should fulfill certain requirements. Expressions\n      such as:</P>\n    \n    <P ALIGN=\"CENTER\"><B>(c + d) /( a + b + c )<BR>\n       2.0*(c +d)/( a + b + 2.0*c )<BR>\n       (c + d)/( 2.0* ( a + b ) + c )<BR>\n      </B></P>\n    \n    <P>are not useful, even though the user has attempted to alter the weights\n      of the matched/unmatched pairs. It is nonsense to include in the numerator\n      that which has been specifically excluded in the denominator (<CITE>Anderberg,\n      MR (1973) Cluster Analysis For Applications, Academic Press p. 89</CITE>).\n    </P>\n    \n    <P>Users should also be cognizant of the restrictions imposed by the\n      descriptors being compared. Daylight fingerprints can be arbitrarily\n      doubled in size, as described above. The value of <B>d</B>, can be\n      increased enormously without scaled increases in the information rich\n      on-bits. It is not recommended therefore that indexes based on a function\n      which uses the value of <B>d</B>, are used with Daylight type\n      fingerprints. In the case of fingerprints based on structure keys there\n      may be no such restrictions.</P>\n    \n    <P>When doing comparisons users should also be aware of the range of\n      possible values the index can take. Most have the range 0.0, 1.0 but this\n      is not mandatory. </P>\n    \n    <P>The most common useful indexes have been collected by Holliday <I>et\n      al </I> (<CITE>Holliday, JD., Hu, C-Y. and Willett, P. (2002)\n      Combinatorial Chemistry and High Throughput Screening 5, 155-166</CITE>) These are shown in the table, and can be referred to, by name, in\n      applications and toolkits calls which allow user defined similarity\n      functions.</P>\n    \n    <CENTER>\n    <TABLE WIDTH=\"50%\" BORDER=\"1\">\n      <TR>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\"><FONT SIZE=\"+1\"><B>Measure </B></FONT></TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\"><B><FONT SIZE=\"+1\">Range</FONT></B></TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><FONT SIZE=\"+1\"><B>Formula</B></FONT></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Cosine </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Cosine.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"123\" HEIGHT=\"63\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Dice </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Dice.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"123\" HEIGHT=\"60\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Euclid </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Euclid.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"111\" HEIGHT=\"66\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Forbes </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,&infin;</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Forbes.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"137\" HEIGHT=\"59\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Hamman </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">-1.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Hamman.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"118\" HEIGHT=\"55\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Jaccard </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Jaccard.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"77\" HEIGHT=\"49\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Kulczynski </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Kulczynski.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"140\" HEIGHT=\"59\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Manhattan </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">1.0,0.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Manhattan.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"115\" HEIGHT=\"52\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Matching </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Matching.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"99\" HEIGHT=\"51\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Pearson </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">-1.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Pearson.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"231\" HEIGHT=\"54\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Rogers-Tanimoto </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Rogers_Tanimoto.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"160\" HEIGHT=\"54\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Russell-Rao </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Russell_Rao.gif\" ALT=\"{short description of image}\" WIDTH=\"98\" HEIGHT=\"51\" ALIGN=\"MIDDLE\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Simpson </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Simpson.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"136\" HEIGHT=\"54\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Tanimoto </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">0.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Tanimoto.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"70\" HEIGHT=\"51\"></TD>\n      </TR>\n      <TR>\n        <TD WIDTH=\"170\">Yule </TD>\n        <TD WIDTH=\"170\" ALIGN=\"CENTER\">-1.0,1.0</TD>\n        <TD WIDTH=\"253\" ALIGN=\"CENTER\"><IMG SRC=\"Yule.gif\" ALT=\"{short description of image}\" ALIGN=\"MIDDLE\" WIDTH=\"108\" HEIGHT=\"51\"></TD>\n      </TR>\n    </TABLE> </CENTER>\n    <BLOCKQUOTE>\n      \n      <P><FONT SIZE=\"-1\">Notes</FONT></P>\n      <UL>\n        <LI><FONT SIZE=\"-1\">The Tanimoto and Jaccard indexes are the same.</FONT></LI>\n        <LI><FONT SIZE=\"-1\">The Forbes index has no upper limit. </FONT></LI>\n        <LI><FONT SIZE=\"-1\">The Manhattan index is a distance = 1.0 - Matching\n          index</FONT></LI>\n        <LI><FONT SIZE=\"-1\">The Kulczynski index is the mean of the individual\n          substructure similarities</FONT></LI>\n        <LI><FONT SIZE=\"-1\">The Simpson index is the best of the individual\n          substructure similarities</FONT></LI>\n        <LI><FONT SIZE=\"-1\">The Dice index is the ratio of the bits in common\n          to the arithmetic mean of the number of on bits in the two items.</FONT></LI>\n        <LI><FONT SIZE=\"-1\">The Cosine index is the ration of the bits in\n          common to the geometric mean of the number of on bits in the two\n          items.</FONT></LI>\n      </UL></BLOCKQUOTE>\n    \n    <P></P>\n    <br>\n<I>Go To Next Chapter...</I>\n       <A HREF=\"theory.thor.html\"> 7. THOR - Chemical Database System</A><br>\n<i>Back to...</i>\n<a href=\"index.html\">Table of Contents</a>\n\n    </td> \n    </tr> \n    <tr> \n    <td><iframe src=\"/iframes/footer.html\" name=\"iframe3\" width=\"350\" height=\"200\" \n       scrolling=\"no\" frameborder=\"0\"></iframe></td> \n    </tr> \n</table> \n</body> \n</html>\n", "id": 37270.0}