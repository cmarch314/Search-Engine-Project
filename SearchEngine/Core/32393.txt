{"text": "WEBDAV Working Group Y Y Goland Microsoft INTERNET DRAFT E J Whitehead Jr UC Irvine draft ietf webdav protocol 5 A Faizi Netscape S R Carter Novell D Jensen Novell Expires April 1998 November 19 1997 This HTML version was converted from plaintext ASCII to HTML by Jim Davis on 22 November 1997 My sincere apologies for any errors introduced in the process When in doubt consult the ASCII version Status of this Memo This document is an Internet Draft Internet Drafts are working documents of the Internet Engineering Task Force IETF its areas and its working groups Note that other groups may also distribute working documents as Internet Drafts Internet Drafts are draft documents valid for a maximum of six months and may be updated replaced or made obsolete by other documents at any time It is inappropriate to use Internet Drafts as reference material or to cite them other than as work in progress To learn the current status of any Internet Draft please check the 1id abstracts txt listing contained in the Internet Drafts Shadow Directories on ftp is co za Africa nic nordu net Europe munnari oz au Pacific Rim ds internic net US East Coast or ftp isi edu US West Coast Distribution of this document is unlimited Please send comments to the Distributed Authoring and Versioning WEBDAV working group at w3c dist auth w3 org which may be joined by sending a message with subject subscribe to w3c dist auth request w3 org Discussions of the WEBDAV working group are archived at http www w3 org pub WWW Archives Public w3c dist auth Abstract This document specifies a set of methods headers and content types ancillary to HTTP 1 1 for the management of resource properties creation and management of resource collections namespace manipulation resource locking collision avoidance and efficient transmission of resource changes Changes 1 1 Changes since draft ietf webdav protocol 4 txt Editor s note This section will not appear in the final form of this document Its purpose is to provide a concise list of changes from the previous revision of the draft for use by reviewers Added this change section Removed scoping for namespaces so the namespace for every element is explicitly stated Changed the syntax from XML Namespace to namespace Removed propfindresult this was left over from the old search format Changed all the DAV XML element names to lower case Changed the property format to use Name and Namespace rather than name and schema Removed proploc attribute and removed section on GETting DELETEing and PUTing properties since we do not provide a mechanism for getting a URI for properties Also removed the requirement that properties be URI addressable Removed quoted string choice from owner header it is just XML Made all the HTTP error codes use the same format Changed the name of the create element in PROPPATCH to set the new name seems to cause less confusion Moved all headers in the draft to a single section Deleted the state token section of the draft and moved the state token headers to the header section of the draft Removed the state token header Changed the write lock section to state that a Lock Token request header not a state token request header is to be submitted on request for write locked resources Created a generic XML element section for XML elements that get repeatedly re used throughout the spec I moved LINK XML element to this section Made multistatus and Schema discovery their own level one sections Collected all the properties together Removed all references to the possibility of properties have their own URIs This includes removing the property identifier section Separated the section on web collections and namespaces into two separate sections Collected all the new response codes together into their own section Changed the XML multiresponse element name to multistatus Added a stand alone section on levels of DAV compliance I also went method by method property by property to specify compliance requirements Added an introduction Changed all the True and False to T and F Altered the first two paragraphs of the Property Names section to make the relationship between a property s name and its schema a little clearer I also added some text in the same section defining a property name as a namespace and element Added a second paragraph to property model for http resources overview This paragraph clarifies why XML was chosen Added a 4 9 Conflict error to move to cover attempts to move a collection with members Changed the collection requirement to read the collections SHOULD end with Also added a SHOULD about returning a location header if the client submits a URL for a collection without a trailing Moved the owner header into the body due to size concerns Replaced the iscollection xml element with resourcetype Moved the DAV property to the DAV header that is returned with OPTIONS Folded the tree draft into this draft Changed the DELETE COPY and MOVE sections to include their effect on collections as taken from the tree draft Created a Depth header section and put in the general rules that were in the introduction to the tree draft I also added the 1 2 response and response status header Removed the versioning section Put all the methods into a single section Replaced the PROPFIND request body with a propfind header Now the response can be cached just using vary Nuked resinfo for INDEX and combined it with multistatus which is now used for both INDEX and PROPFIND Stripped down INDEX as agreed Removed the problem definition and proposed solution sections We can always cut and paste them together from the older version if we feel we need them but this draft is supposed to be a dry run for last call and last call documents do not have problem definition proposed solution sections Killed the section on schema discovery it is controversial and we aren t going to be able to require it We should specify it in a different spec Added a section on notational conventions used within the document Moved the terminology section to the end of the document to provide better flow from the high level introduction to the specific introduction sections Increased the numeric value of the 4xx status codes introduced in this specification to avoid conflicts with the new revision of the HTTP 1 1 specification which introduces two new 4xx status codes Wrote internationalization concerns section Added XML version number to all examples Contents STATUS OF THIS MEMO 1 ABSTRACT 1 CHANGES 1 1 1 Changes since draft ietf webdav protocol 4 txt 1 CONTENTS 5 2 INTRODUCTION 8 3 DATA MODEL FOR RESOURCE PROPERTIES 9 3 1 The Resource Property Model 9 3 2 Existing Metadata Proposals 1 3 3 Properties and HTTP Headers 1 3 4 Property Values 1 3 5 Property Names 11 4 COLLECTIONS OF WEB RESOURCES 11 4 1 Collection Resources 11 4 2 Creation and Retrieval of Collection Resources 12 4 3 HTTP URL Namespace Model 13 4 4 Source Resources and Output Resources 13 5 LOCKING 14 5 1 Exclusive Vs Shared Locks 14 5 2 Required Support 15 5 3 Lock Tokens 16 5 4 opaquelocktoken Lock Token URI Scheme 16 5 5 Lock Capability Discovery 16 5 6 Active Lock Discovery 17 6 WRITE LOCK 17 6 1 Methods Restricted by Write Locks 17 6 2 Write Locks and Properties 17 6 3 Write Locks and Null Resources 17 6 4 Write Locks and Collections 18 6 5 Write Locks and COPY MOVE 18 6 6 Re issuing Write Locks 18 6 7 Write Locks and The Lock Token Request Header 18 7 NOTATIONAL CONVENTIONS 19 8 HTTP METHODS FOR DISTRIBUTED AUTHORING 19 8 1 PROPFIND 19 8 2 PROPPATCH 23 8 3 MKCOL Method 25 8 4 INDEX Method 26 8 5 DELREF Method 28 8 6 ADDREF Method 28 8 7 GET HEAD for Collections 29 8 8 POST for Collections 29 8 9 DELETE 29 8 1 PUT 31 8 11 COPY Method 31 8 12 MOVE Method 35 8 13 LOCK Method 38 8 14 UNLOCK Method 42 8 15 PATCH Method 43 9 DAV HEADERS 47 9 1 Collection Member Header 47 9 2 DAV Header 47 9 3 Depth Header 47 9 4 Destination Header 48 9 5 Destroy Header 48 9 6 Enforce Live Properties Header 49 9 7 If None State Match 49 9 8 If State Match 5 9 9 Lock Info Request Header 5 9 1 Lock Token Request Header 51 9 11 Lock Token Response Header 51 9 12 Overwrite Header 52 9 13 Propfind Request Header 52 9 14 Status URI Response Header 52 9 15 Timeout Header 52 1 RESPONSE CODE EXTENSIONS TO RFC 2 68 54 1 1 1 2 Processing 54 1 2 2 7 Multi Status 54 1 3 418 Unprocessable Entity 54 1 4 419 Insufficient Space on Resource 54 1 5 42 Method Failure 54 11 MULTI STATUS RESPONSE 54 11 1 multistatus XML Element 55 11 2 response XML Element 55 11 3 status XML Element 55 11 4 responsedescription XML Element 55 12 GENERIC DAV XML ELEMENTS 55 12 1 href XML Element 56 12 2 link XML Element 56 12 3 prop XML element 57 13 DAV PROPERTIES 57 13 1 creationdate Property 57 13 2 displayname Property 57 13 3 get content language Property 58 13 4 get content length Property 58 13 5 get content type Property 58 13 6 get etag Property 58 13 7 get last modified Property 59 13 8 index content language Property 59 13 9 index content length Property 59 13 1 index content type Property 59 13 11 index etag Property 59 13 12 index last modified Property 6 13 13 lockdiscovery Property 6 13 14 resourcetype Property 62 13 15 Source Link Property Type 62 13 16 supportedlock Property 63 14 DAV COMPLIANCE LEVELS 64 14 1 Level 1 64 14 2 Level 2 64 15 INTERNATIONALIZATION SUPPORT 65 16 SECURITY CONSIDERATIONS 66 17 TERMINOLOGY 66 18 COPYRIGHT 66 19 ACKNOWLEDGEMENTS 67 2 REFERENCES 69 21 AUTHORS ADDRESSES 71 2 Introduction This document describes an extension to the HTTP 1 1 protocol that allows clients to perform remote web content authoring operations This extension provides a coherent set of methods headers request entity body formats and response entity body formats that provide operations for Properties The ability to create remove and query information about Web pages such as its author creation date etc Also the ability to link pages of any media type to related pages Collections The ability to create sets of related documents and to receive a listing of pages at a particular hierarchy level like a directory listing in a file system Locking The ability to keep more than one person from working on a document at the same time This prevents the lost update problem in which modifications are lost as first one author then another writes their changes without merging the other author s changes Namespace Operations The ability to copy and move Web resources Efficient Update The ability to send changes which are proportional to the size of the change rather than retransmitting the entire resource Requirements and rationale for these operations are described in a companion document Requirements for a Distributed Authoring and Versioning Protocol for the World Wide Web Slein et al 1997 The sections below provide a detailed introduction to resource properties Section 3 collections of resources Section 4 and locking operations Section 5 These sections introduce the abstractions manipulated by the WebDAV specific HTTP methods described in Section 8 HTTP Methods for Distributed Authoring In HTTP 1 1 method parameter information was exclusively encoded in HTTP headers Unlike HTTP 1 1 WebDAV encodes method parameter information either in an Extensible Markup Language XML Bray Sperberg McQueen 1997 request entity body or in an HTTP header The use of XML to encode method parameters was motivated by the ability to add extra XML elements to existing structures providing extensibility and by XML s ability to encode information in ISO 1 646 character sets providing internationalization support As a rule of thumb parameters are encoded in XML entity bodies when they have unbounded length or when they may be shown to a human user and hence require encoding in an ISO 1 646 character set Otherwise parameters are encoded within an HTTP header Section 9 describes the new HTTP headers used with WebDAV methods In addition to encoding method parameters XML is used in WebDAV to encode the responses from methods providing the extensibility and internationalization advantages of XML for method output as well as input XML elements used in this specification are defined in Section 12 While the response codes provided by HTTP 1 1 are sufficient to describe the preponderance of error conditions encountered by WebDAV methods there are some errors that do not fall neatly into the existing categories New status codes developed for the WebDAV methods are defined in Section 1 Since some WebDAV methods may operate over many resources the multiresponse status type has been introduced to return status information for multiple resources Multiresponse status is described in Section 11 The properties mechanism is employed by WebDAV to store information about the current state of the resource For example when a lock is taken out on a resource a lock information property describes the current state of the lock Section 13 defines the properties used within the WebDAV specification Finishing off the specification are sections on what it means to be compliant with this specification Section 14 on internationalization support Section 15 and on security Section 16 3 Data Model for Resource Properties 3 1 The Resource Property Model Properties are pieces of data that describe the state of a resource Properties are data about data Properties are used in distributed authoring environments to provide for efficient discovery and management of resources For example a subject property might allow for the indexing of all resources by their subject and an author property might allow for the discovery of what authors have written which documents The DAV property model consists of name value pairs The name of a property identifies the property s syntax and semantics and provides an address by which to refer to that syntax and semantics There are two categories of properties live and non live A live property has its syntax and semantics enforced by the server This represents the two cases of a the value of a property is read only maintained by the server and b the value of the property is maintained by the client but server performs syntax checking on submitted values A non live property has its syntax and semantics enforced by the client the server merely records the value of the property verbatim 3 2 Existing Metadata Proposals Properties have long played an essential role in the maintenance of large document repositories and many current proposals contain some notion of a property or discuss web metadata more generally These include PICS Miller et al 1996 PICS NG the Rel Rev draft Maloney 1996 Web Collections XML Bray Sperberg McQueen 1997 several proposals on representing relationships within HTML digital signature manifests DCMF and a position paper on Web metadata architecture Berners Lee 1997 Work on PICS NG and Web Collections has been subsumed by the Resource Definition Framework RDF metadata activity of the World Wide Web Consortium which consists of a network based data model and an XML representation of that model Some proposals come from a digital library perspective These include the Dublin Core Weibel et al 1995 metadata set and the Warwick Framework Lagoze 1996 a container architecture for different metadata schemas The literature includes many examples of metadata including MARC MARC 1994 a bibliographic metadata format and RFC 18 7 Lasher Cohen 1995 a technical report bibliographic format employed by the Dienst system Additionally the proceedings from the first IEEE Metadata conference describe many community specific metadata sets Participants of the 1996 Metadata II Workshop in Warwick UK Lagoze 1996 noted that new metadata sets will develop as the networked infrastructure matures and different communities will propose design and be responsible for different types of metadata These observations can be corroborated by noting that many community specific sets of metadata already exist and there is significant motivation for the development of new forms of metadata as many communities increasingly make their data available in digital form requiring a metadata format to assist data location and cataloging 3 3 Properties and HTTP Headers Properties already exist in a limited sense in HTTP message headers However in distributed authoring environments a relatively large number of properties are needed to describe the state of a resource and setting returning them all through HTTP headers is inefficient Thus a mechanism is needed which allows a principal to identify a set of properties in which the principal is interested and to then set or retrieve just those properties 3 4 Property Values The value of a property is expressed as a well formed XML document XML has been chosen because it is a flexible self describing structured data format that supports rich schema definitions and because of its support for multiple character sets XML s self describing nature allows any property s value to be extended by adding new elements Older clients will not break because they will still have the data specified in the original schema and will ignore elements they do not understand XML s support for multiple character sets allows human readable properties to be encoded and read in a character set familiar to the user 3 5 Property Names A property name is a universally unique identifier that is associated with a schema that provides information about the syntax and semantics of the property Because a property s name is universally unique clients can depend upon consistent behavior for a particular property across multiple resources so long as that property is live on the resources in question The XML namespace mechanism which is based on URIs is used to name properties because it provides a mechanism to prevent namespace collisions and for varying degrees of administrative control The property namespace is flat that is no hierarchy of properties is explicitly recognized Thus if a property A and a property A B exist on a resource there is no recognition of any relationship between the two properties It is expected that a separate specification will eventually be produced which will address issues relating to hierarchical properties Finally it is not possible to define the same property twice on a single resource as this would cause a collision in the resource s property namespace 4 Collections of Web Resources This section provides a description of a new type of Web resource the collection and discusses its interactions with the HTTP URL namespace The purpose of a collection resource is to model collection like objects e g filesystem directories within a server s namespace All DAV compliant resources MUST support the HTTP URL namespace model specified herein 4 1 Collection Resources A collection is a resource whose state consists of an unordered list of internal members an unordered list of external members and a set of properties An internal member resource MUST have a URI that is immediately relative to the base URI of the collection that is a relative URI in which is illegal which MUST begin with and which SHOULD contain a at the end of the URI if the internal member resource is itself a collection An external member resource MUST be an absolute URI that is not an internal URI Any given internal or external URI MUST only belong to the collection once i e it is illegal to have multiple instances of the same URI in a collection Properties defined on collections behave exactly as do properties on non collection resources There is a standing convention that when a collection is referred to by its name without a trailing slash the trailing slash is automatically appended Due to this a resource MAY accept a URI without a trailing to point to a collection In this case it SHOULD return a location header in the response pointing to the URL ending with the For example if a client performs an INDEX on http foo bar blah no trailing slash the resource http foo bar blah trailing slash MAY respond as if the operation were invoked on it and SHOULD return a location header with http foo bar blah in it 4 2 Creation and Retrieval of Collection Resources This document specifies the MKCOL method to create new collection resources rather than using the existing HTTP 1 1 PUT or POST method for the following reasons In HTTP 1 1 the PUT method is defined to store the request body at the location specified by the Request URI While a description format for a collection can readily be constructed for use with PUT the implications of sending such a description to the server are undesirable For example if a description of a collection that omitted some existing resources were PUT to a server this might be interpreted as a command to remove those members This would extend PUT to perform DELETE functionality which is undesirable since it changes the semantics of PUT and makes it difficult to control DELETE functionality with an access control scheme based on methods While the POST method is sufficiently open ended that a create a collection POST command could be constructed this is undesirable because it would be difficult to separate access control for collection creation from other uses of POST This document specifies the INDEX method for listing the contents of a collection rather than relying on the existing HTTP 1 1 GET method This is to avoid conflict with the de facto standard practice of redirecting a GET request on a directory to its index html resource The exact definition of the behavior of GET and PUT on collections is defined later in this document 4 3 HTTP URL Namespace Model The HTTP URL Namespace is a hierarchical namespace where the hierarchy is delimited with the character DAV compliant resources MUST maintain the consistency of the HTTP URL namespace Any attempt to create a resource excepting the root member of a namespace that would not be the internal member of a collection MUST fail For example if the collection http www foo bar org a exists but http www foo bar org a b does not exist an attempt to create http www foo bar org a b c must fail 4 4 Source Resources and Output Resources For many resources the entity returned by a GET method exactly matches the persistent state of the resource for example a GIF file stored on a disk For this simple case the URL at which a resource is accessed is identical to the URL at which the source the persistent state of the resource is accessed This is also the case for HTML source files that are not processed by the server prior to transmission However the server can sometimes process HTML resources before they are transmitted as a return entity body For example server side include directives within an HTML file instruct a server to replace the directive with another value such as the current date In this case what is returned by GET HTML plus date differs from the persistent state of the resource HTML plus directive Typically there is no way to access the HTML resource containing the unprocessed directive Sometimes the entity returned by GET is the output of a data producing process that is described by one or more source resources that may not even have a location in the URL namespace A single data producing process may dynamically generate the state of a potentially large number of output resources An example of this is a CGI script that describes a finger gateway process that maps part of the namespace of a server into finger requests such as http www foo bar org finger gateway user host In the absence of distributed authoring capabilities it is acceptable to have no mapping of source resource s to the URI namespace In fact preventing access to the source resource s has desirable security benefits However if remote editing of the source resource s is desired the source resource s should be given a location in the URI namespace This source location should not be one of the locations at which the generated output is retrievable since in general it is impossible for the server to differentiate requests for source resources from requests for process output resources There is often a many to many relationship between source resources and output resources On WebDAV compliant servers for all output resources which have a single source resource and that source resource has a URI the URI of the source resource SHOULD be stored in a link on the output resource with type http www ietf org standards dav source Note that by storing the source URIs in links on the output resources the burden of discovering the source is placed on the authoring client 5 Locking The ability to lock a resource provides a mechanism for serializing access to that resource Using a lock an authoring client can provide a reasonable guarantee that another principal will not modify a resource while it is being edited In this way a client can prevent the lost update problem This specification allows locks to vary over two client specified parameters the number of principals involved exclusive vs shared and the type of access to be granted Furthermore this document only provides the definition of locking for one lock access type the write lock However the syntax is extensible and permits the eventual specification of other access types 5 1 Exclusive Vs Shared Locks The most basic form of lock is an exclusive lock This is a lock where the access right in question is only granted to a single principal The need for this arbitration results from a desire to avoid having to constantly merge results However there are times when the goal of a lock is not to exclude others from exercising an access right but rather to provide a mechanism for principals to indicate that they intend to exercise their access right Shared locks are provided for this case A shared lock allows multiple principals to receive a lock Hence any principal with appropriate access can get the lock With shared locks there are two trust sets that affect a resource The first trust set is created by access permissions Principals who are trusted for example may have permission to write the resource Those who are not don t Among those who have access permission to write the resource the set of principals who have taken out a shared lock also must trust each other creating a typically smaller trust set within the access permission write set Starting with every possible principal on the Internet in most situations the vast majority of these principals will not have write access to a given resource Of the small number who do have write access some principals may decide to guarantee their edits are free from overwrite conflicts by using exclusive write locks Others may decide they trust their collaborators will not overwrite their work the potential set of collaborators being the set of principals who have write permission and use a shared lock which informs their collaborators that a principal is potentially working on the resource The WebDAV extensions to HTTP do not need to provide all of the communications paths necessary for principals to coordinate their activities When using shared locks principals may use any out of band communication channel to coordinate their work e g face to face interaction written notes post it notes on the screen telephone conversation Email etc The intent of a shared lock is to let collaborators know who else is potentially working on a resource Shared locks are included because experience from web distributed authoring systems has indicated that exclusive write locks are often too rigid An exclusive write lock is used to enforce a particular editing process take out exclusive write lock read the resource perform edits write the resource release the lock This editing process has the problem that locks are not always properly released for example when a program crashes or when a lock owner leaves without unlocking a resource While both timeouts and administrative action can be used to remove an offending lock neither mechanism may be available when needed the timeout may be long or the administrator may not be available Despite their potential problems exclusive write locks are extremely useful since often a guarantee of freedom from overwrite conflicts is what is needed This specification provides both exclusive write locks and the less strict mechanism of shared locks 5 2 Required Support A WebDAV compliant server is not required to support locking in any form If the server does support locking it MAY choose to support any combination of exclusive and shared locks for any access types The reason for this flexibility is that locking policy strikes to the very heart of the resource management and versioning systems employed by various storage repositories These repositories require control over what sort of locking will be made available For example some repositories only support shared write locks while others only provide support for exclusive write locks while yet others use no locking at all As each system is sufficiently different to merit exclusion of certain locking features this specification leaves locking as the sole axis of negotiation within WebDAV 5 3 Lock Tokens A lock token is a URI that identifies a particular lock A lock token is returned by every successful LOCK operation in the lock token response header and can also be discovered through lock discovery on a resource Lock token URIs are required to be unique across all resources for all time This uniqueness constraint allows lock tokens to be submitted across resources and servers without fear of confusion This specification provides a lock token URI scheme called opaquelocktoken that meets the uniqueness requirements However resources are free to return any URI scheme so long as it meets the uniqueness requirements 5 4 opaquelocktoken Lock Token URI Scheme The opaquelocktoken URI scheme is designed to be unique across all resources for all time Due to this uniqueness quality a client MAY submit an opaque lock token in a Lock Token request header and an if state not match header on a resource other than the one that returned it All resources MUST recognize the opaquelocktoken scheme and at minimum recognize that the lock token was not generated by the resource Note however that resources are not required to generate opaquelocktokens in LOCK method responses In order to guarantee uniqueness across all resources for all time the opaquelocktoken requires the use of the GUID mechanism Opaquelocktoken generators however have a choice of how they create these tokens They can either generate a new GUID for every lock token they create which is potentially very expensive or they can create a single GUID and then add extension characters If the second method is selected then the program generating the extensions MUST guarantee that the same extension will never be used twice with the associated GUID Opaque Lock Token opaquelocktoken GUID Extension GUID As defined in Leach Salz 1997 Extension urlc urlc is defined in Berners Lee et al 1997 draft fielding url syntax 7 txt 5 5 Lock Capability Discovery Since server lock support is optional a client trying to lock a resource on a server can either try the lock and hope for the best or perform some form of discovery to determine what lock capabilities the server supports This is known as lock capability discovery Lock capability discovery differs from discovery of supported access control types since there may be access control types without corresponding lock types A client can determine what lock types the server supports by retrieving the supportedlock property Any DAV compliant resource that supports the LOCK method MUST support the supportedlock property 5 6 Active Lock Discovery If another principal locks a resource that a principal wishes to access it is useful for the second principal to be able to find out who the first principal is For this purpose the lockdiscovery property is provided This property lists all outstanding locks describes their type and provides their lock token Any DAV compliant resource that supports the LOCK method MUST support the lockdiscovery property 6 Write Lock This section describes the semantics specific to the write access type for locks The write lock is a specific instance of a lock type and is the only lock type described in this specification A DAV compliant resource MAY support the write lock 6 1 Methods Restricted by Write Locks A write lock prevents a principal without the lock from successfully executing a PUT POST PATCH PROPPATCH MOVE DELETE MKCOL ADDREF or DELREF on the locked resource All other current methods GET in particular function independent of the lock Note however that as new methods are created it will be necessary to specify how they interact with a write lock 6 2 Write Locks and Properties While those without a write lock may not alter a property on a resource it is still possible for the values of live properties to change even while locked due to the requirements of their schemas Only dead properties and live properties defined to respect locks are guaranteed not to change while write locked 6 3 Write Locks and Null Resources It is possible to assert a write lock on a null resource in order to lock the name Please note however that locking a null resource effectively makes the resource non null as the resource now has lock related properties defined on it 6 4 Write Locks and Collections A write lock on a collection prevents the addition or removal of members of the collection As a consequence when a principal issues a request to create a new internal member of a collection using PUT or POST or to remove an existing internal member of a collection using DELETE this request MUST fail if the principal does not have a write lock on the collection However if a write lock request is issued to a collection containing internal member resources that are currently locked in a manner which conflicts with the write lock the request MUST fail with a 4 9 Conflict status code 6 5 Write Locks and COPY MOVE The owner of a write lock MUST NOT execute a MOVE method on a resource he has locked This specification intentionally does not define what happens if a MOVE method request is made on a locked resource by the lock s owner A COPY method invocation MUST NOT duplicate any write locks active on the source 6 6 Re issuing Write Locks If a principal already owns a write lock on a resource any future requests for the same type of write lock on the same resource while the principal s previous write lock is in effect MUST result in a successful response with the same lock token as provided for the currently existing lock Two lock requests are defined to be identical if their Lock Info headers are identical 6 7 Write Locks and The Lock Token Request Header If a user agent is not required to have knowledge about a lock when requesting an operation on a locked resource the following scenario might occur Program A run by User A takes out a write lock on a resource Program B also run by User A has no knowledge of the lock taken out by Program A yet performs a PUT to the locked resource In this scenario the PUT succeeds because locks are associated with a principal not a program and thus program B because it is acting with principal A s credential is allowed to perform the PUT However had program B known about the lock it would not have overwritten the resource preferring instead to present a dialog box describing the conflict to the user Due to this scenario a mechanism is needed to prevent different programs from accidentally ignoring locks taken out by other programs with the same authorization In order to prevent these collisions the lock token request header is introduced Please refer to the Lock Token Request Header section for details and requirements 6 7 1 Write Lock Token Example COPY fielding index html HTTP 1 1 Host www ics uci edu Destination http www ics uci edu users f fielding index html Lock Token opaquelocktoken 123AbcEfg1284h23h2 opaquelocktoken AAAASDFcalkjfdas12312 HTTP 1 1 2 OK In this example both the source and destination are locked so two lock tokens must be submitted If only one of the two resources was locked then only one token would have to be submitted 7 Notational Conventions Since this document describes a set of extensions to the HTTP 1 1 protocol the augmented BNF used herein to describe protocol elements is exactly the same as described in Section 2 1 of RFC 2 68 Hypertext Transfer Protocol HTTP 1 1 Fielding et al 1997 Since this augmented BNF uses the basic production rules provided in Section 2 2 of RFC 2 68 these rules apply to this document as well The key words MUST MUST NOT REQUIRED SHALL SHALL NOT SHOULD SHOULD NOT RECOMMENDED MAY and OPTIONAL in this document are to be interpreted as described in RFC 2119 Bradner 1997 8 HTTP Methods for Distributed Authoring 8 1 PROPFIND The PROPFIND method retrieves properties defined on the Request URI if it is a non collection resource or on the Request URI and potentially its member resources if the resource is a collection All DAV compliant resources MUST support the PROPFIND method A client MAY submit a Depth header with a PROPFIND on a collection with a value of 1 or infinity DAV compliant servers MUST support the 1 and infinity behaviors By default the PROPFIND method on a collection without a Depth header MUST act as if a Depth infinity header was included A client MUST submit a Propfind request header describing what information is being requested It is possible to request particular property values all property values or a list of the names of the resource s properties The response is a text xml message body that contains a multistatus XML element that describes the results of the attempts to retrieve the various properties If a property was successfully retrieved then its value MUST be returned in a prop XML element If the scope of PROPFIND covers more than a single resource as is the case with Depth values of 1 and infinity each response XML element MUST contain an href XML element which identifies the resource on which the properties in the prop XML element are defined In the case of allprop and propname if a principal does not have the right to know if a particular property exists an error MUST NOT be returned The results of this method SHOULD NOT be cached 8 1 1 Example Retrieving Named Properties PROPFIND files HTTP 1 1 Host www foo bar Depth Propfind http www foo bar boxschema bigbox http www foo bar boxschema author http www foo bar boxschema DingALing http w ww foo bar boxschema Random HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav AS D namespace href http www foo bar boxschema AS R D multistatus D response D prop R bigbox R BoxType Box type A R BoxType R bigbox R author R Name J J Dingleheimerschmidt R Name R author D prop D status HTTP 1 1 2 OK D status D response D response D prop R DingALing R Random D prop D status HTTP 1 1 4 3 Forbidden D status D responsedescription The user does not have access to the DingALing property D responsedescription D response D responsedescription There has been an access violation error D responsedescription D multistatus In this example PROPFIND is executed on the collection http www foo bar files The specified depth is zero hence the PROPFIND applies only to the collection itself and not to any of its members The Propfind header specifies the name of four properties whose values are being requested In this case only two properties were returned since the principal issuing the request did not have sufficient access rights to see the third and fourth properties 8 1 2 Example Using allprop to Retrieve All Properties PROPFIND container HTTP 1 1 Host www foo bar Depth 1 Propfind allprop HTTP 1 1 2 OK Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav As S namespace href http www foo bar boxschema AS R S multistatus S response S href http www foo bar container S href S prop R bigbox R BoxType Box type A R BoxType R bigbox R author R Name Hadrian R Name R author S prop S status HTTP 1 1 2 OK S status S response S response S href http www foo bar container index html S href S prop R bigbox R BoxType Box type B R BoxType R bigbox S prop S status HTTP 1 1 2 OK S status S response S multistatus In this example PROPFIND was invoked on the resource http www foo bar container with a Depth header of 1 meaning the request applies to the resource and its children and a Propfind header of allprop meaning the request should return the name and value of all properties defined on each resource The resource http www foo bar container has two properties defined on it named http www foo bar boxschema bigbox and http www foo bar boxschema author while resource http www foo bar container index html has only a single resource defined on it named http www foo bar boxschema bigbox another instance of the bigbox property type 8 1 3 Example Using propname to Retrieve all Property Names PROPFIND container HTTP 1 1 Host www foo bar Propfind propname HTTP 1 1 2 OK Content Type text xml Content Length xxxx XML version 1 namespace href http www ietf org standards dav As D namespace href http www foo bar boxschema AS R D multistatus D response D href http www foo bar container D href D prop R bigbox R author D prop D status HTTP 1 1 2 OK D status D response D response D href http www foo bar container index html D href D prop R bigbox D prop D status HTTP 1 1 2 OK D status D response D multistatus In this example PROPFIND is invoked on the collection resource http www foo bar container with a Propfind header set to propname meaning the name of all properties should be returned Since no depth header is present it assumes its default value of infinity meaning the name of the properties on the collection and all its progeny should be returned Consistent with the previous example resource http www foo bar container has two properties defined on it http www foo bar boxschema bigbox and http www foo bar boxschema author The resource http www foo bar container index html a member of the container collection has only one property defined on it http www foo bar boxschema bigbox 8 2 PROPPATCH The PROPPATCH method processes instructions specified in the request body to set and or remove properties defined on the resource identified by Request URI All DAV compliant resources MUST support the PROPPATCH method and MUST process instructions that are specified using the propertyupdate set and remove XML elements of the DAV schema Execution of the directives in this method is of course subject to access control constraints DAV compliant resources MUST support the setting of arbitrary dead properties The request message body of a PROPPATCH method MUST contain at least one propertyupdate XML element Instruction processing MUST occur in the order instructions are received i e from top to bottom and MUST be performed atomically 8 2 1 propertyupdate XML element Name propertyupdate Namespace http www ietf org standards dav Purpose To contain a request to alter the properties on a resource Parent None Values 1 set remove Description This XML element is a container for the information required to modify the properties on the resource This XML element is multi valued 8 2 2 set XML element Name set Namespace http www ietf org standards dav Purpose To set the DAV properties specified inside the set XML element Parent propertyupdate Values prop Description This XML element MUST contain only a prop XML element The elements contained by prop specify the name and value of properties that are set on the Request URI If a property already exists then its value is replaced 8 2 3 remove XML element Name remove Namespace http www ietf org standards dav Purpose To remove the DAV properties specified inside the remove XML element Parent propertyupdate Values prop Description Remove specifies that the properties specified in prop should be removed Specifying the removal of a property that does not exist is not an error All the elements in prop MUST be empty as only the names of properties to be removed are required 8 2 4 Response Codes 2 OK The command succeeded As there can be a mixture of sets and removes in a body a 2 1 Create seems inappropriate 4 3 Forbidden The client for reasons the server chooses not to specify cannot alter one of the properties 4 5 Conflict The client has provided a value whose semantics are not appropriate for the property This includes trying to set read only properties 413 Request Entity Too Long If a particular property is too long to be recorded then a composite XML error will be returned indicating the offending property 8 2 5 Example PROPPATCH bar html HTTP 1 1 Host www foo com Content Type text xml Content Length xxxx XML version 1 namespace href http www ietf org standards dav AS D namespace href http www w3 com standards z39 5 AS Z D propertyupdate D set D prop Z authors Z Author Jim Whitehead Z Author Z Author Roy Fielding Z Author Z authors D prop D set D remove D prop Z Copyright Owner D prop D remove D propertyupdate HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav AS D namespace href http www w3 com standards z39 5 AS Z D multistatus D response D prop Z Authors D prop D status HTTP 1 1 42 Method Failure D status D response D response D prop Z Copyright Owner D prop D status HTTP 1 1 4 9 Conflict D status D response D responsedescription Copyright Owner can not be deleted or altered D responsedescription D multistatus In this example the client requests the server to set the value of the http www w3 com standards z39 5 Authors property and to remove the property http www w3 com standards z39 5 Copyright Owner Since the Copyright Owner property could not be removed no property modifications occur The Method Failure response code for the Authors property indicates this action would have succeeded if it were not for the conflict with removing the Copyright Owner property 8 3 MKCOL Method The MKCOL method is used to create a new collection All DAV compliant resources MUST support the MKCOL method 8 3 1 Request MKCOL creates a new collection resource at the location specified by the Request URI If the Request URI exists then MKCOL must fail During MKCOL processing a server MUST make the Request URI a member of its parent collection If no such ancestor exists the method MUST fail When the MKCOL operation creates a new collection resource all ancestors MUST already exist or the method MUST fail with a 4 9 Conflict status code For example if a request to create collection a b c d is made and neither a b nor a b c exists the request MUST fail When MKCOL is invoked without a request body the newly created collection has no members A MKCOL request message MAY contain a message body The behavior of a MKCOL request when the body is present is limited to creating collections members of a collection bodies of members and properties on the collections or members If the server receives a MKCOL request entity type it does not support or understand it MUST respond with a 415 Unsupported Media Type status code The exact behavior of MKCOL for various request media types is undefined in this document and will be specified in separate documents 8 3 2 Response Codes Responses from a MKCOL request are not cacheable since MKCOL has non idempotent semantics 2 1 Created The collection or structured resource was created in its entirety 4 3 Forbidden This indicates at least one of two conditions 1 The server does not allow the creation of collections at the given location in its namespace and 2 The parent collection of the Request URI exists but cannot accept members 4 5 Method Not Allowed MKCOL can only be executed on a deleted non existent resource 4 9 Conflict A collection cannot be made at the Request URI until one or more intermediate collections have been created 415 Unsupported Media Type The server does not support the request type of the body 419 Insufficient Space on Resource The resource does not have sufficient space to record the state of the resource after the execution of this method 8 3 3 Example This example creates a collection called webdisc xfiles on the server www server org MKCOL webdisc xfiles HTTP 1 1 Host www server org HTTP 1 1 2 1 Created 8 4 INDEX Method The INDEX method is used to enumerate the members of a resource All DAV compliant resources MUST support the INDEX method if they have members 8 4 1 The Request For a collection INDEX MUST return a list of its members All WebDAV compliant resources MUST support the text xml response entity described below The INDEX result for a collection MAY also return a list of the members of child collections to any depth Collections that respond to an INDEX method with a text xml entity MUST contain a single multistatus XML element which contains a response XML element for each member A resource that supports INDEX MUST return the resourcetype property for each member Note that the prop XML element MAY contain additional properties 8 4 2 Example INDEX user yarong dav drafts HTTP 1 1 Host www microsoft com HTTP 1 1 2 OK Content Type text xml Content Length xxx Last Modified Thu 11 Sep 1997 23 45 12 GMT ETag fooyyybar XML version 1 namespace href http www ietf org standards dav as D D multistatus D response D href http www microsoft com user yarong dav drafts D href D prop D resourcetype D collection D resourcetype D prop D status HTTP 1 1 2 OK D status D response D response D href http www microsoft com user yarong dav drafts base D href D prop D resourcetype D prop D status HTTP 1 1 2 OK D status D response D multistatus 8 5 ADDREF Method The ADDREF method is used to add external members to a resource All DAV compliant collection resources MUST support the ADDREF method All other DAV compliant resources MAY support the ADDREF method as appropriate 8 5 1 The Request The ADDREF method adds the URI specified in the Collection Member header as an external member to the collection specified by the Request URI The value in the Collection Member header MUST be an absolute URI meeting the requirements of an external member URI It is not an error if the URI specified in the Collection Member header already exists as an external member of the collection However after processing the ADDREF there MUST be only one instance of the URI in the collection If the URI specified in the Collection Member header already exists as an internal member of the collection the ADDREF method MUST fail with a 412 Precondition Failed status code 8 5 2 Example ADDREF ejw dav HTTP 1 1 Host www ics uci edu Collection Member http www ietf org standards dav HTTP 1 1 2 OK This example adds the URI http www ietf org standards dav as an external member resource of the collection http www ics uci edu ejw dav 8 6 DELREF Method The DELREF method is used to remove external members from a resource All DAV compliant collection resources MUST support the DELREF method All other DAV compliant resources MUST support the DELREF method only if they support the ADDREF method 8 6 1 The Request The DELREF method removes the URI specified in the Collection Member header from the collection specified by the Request URI DELREFing a URI which is not a member of the collection is not an error DELREFing an internal member MUST fail with a 412 Precondition Failed status code 8 6 2 Example DELREF ejw dav HTTP 1 1 Host www ics udi edu Collection Member http www ietf org standards dav HTTP 1 1 2 OK This example removes the URI http www ietf org standards dav an external member resource from the collection http www ics uci edu ejw dav 8 7 GET HEAD for Collections The semantics of GET are unchanged when applied to a collection since GET is defined as retrieve whatever information in the form of an entity is identified by the Request URI Fielding et al 1997 GET when applied to a collection MAY return the contents of an index html resource a human readable view of the contents of the collection or something else altogether and hence it is possible the result of a GET on a collection will bear no correlation to the state of the collection Similarly since the definition of HEAD is a GET without a response message body the semantics of HEAD are unmodified when applied to collection resources 8 8 POST for Collections Since by definition the actual function performed by POST is determined by the server and often depends on the particular resource the behavior of POST when applied to collections cannot be meaningfully modified because it is largely undefined Thus the semantics of POST are unmodified when applied to a collection 8 9 DELETE 8 9 1 DELETE Method for Non Collection Resources If the DELETE method is issued to a non collection resource which is an internal member of a collection then during DELETE processing a server MUST remove the Request URI from its parent collection A server MAY remove the URI of a deleted resource from any collections of which the resource is an external member 8 9 2 DELETE for Collections The DELETE method on a collection MUST act as if a Depth Infinity header was used on it A client MUST NOT submit a Depth header on a DELETE on a collection with any value but Infinity DELETE instructs that the collection specified in the request URI the records of its external member resources and all its internal member resources are to be deleted If any member cannot be deleted then all of the member s progeny MUST NOT be deleted so as to maintain the namespace Any headers included with DELETE MUST be applied in processing every resource to be deleted In this case a header of special interest is the Destroy header which specifies the method to be used to delete all resources in the scope of the DELETE When the DELETE method has completed processing it MUST return a consistent namespace The response SHOULD be a Multi Status response that describes the result of the DELETE on each affected resource 8 9 2 1 Example DELETE container HTTP 1 1 Host www foo bar Destroy NoUndelete HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav As d d multistatus d response d href http www foo bar container resource1 d href d href http www foo bar container resource2 d href d status HTTP 1 1 2 OK d status d response d response d href http www foo bar container d href d status HTTP 1 1 42 Method Failure d status d response d response d href http www foo bar container resource3 d href d status HTTP 1 1 412 Precondition Failed d status d response d multistatus In this example the attempt to delete http www foo bar container resource3 failed because the server was unable to guarantee that resource3 would not be able to be undeleted Consequently the attempt to delete http www foo bar container also failed but resource1 and resource2 were deleted Even though a Depth header has not been included a depth of infinity is assumed because the method is on a collection As this example illustrates DELETE processing need not be atomic 8 1 PUT 8 1 1 PUT for Non Collection Resources A PUT performed on an existing resource replaces the GET response entity of the resource Properties defined on the resource MAY be recomputed during PUT processing For example if a server recognizes the content type of the request body it may be able to automatically extract information that could be profitably exposed as properties A PUT that would result in the creation of a resource without an appropriately scoped parent collection MUST fail with a 4 5 Method Not Allowed 8 1 2 PUT for Collections As defined in the HTTP 1 1 specification Fielding et al 1997 the PUT method requests that the enclosed entity be stored under the supplied Request URI Since submission of an entity representing a collection would implicitly encode creation and deletion of resources this specification intentionally does not define a transmission format for creating a collection using PUT Instead the MKCOL method is defined to create collections If a PUT is invoked on a collection resource it MUST fail When the PUT operation creates a new non collection resource all ancestors MUST already exist If all ancestors do not exist the method MUST fail with a 4 9 Conflict status code For example if resource a b c d html is to be created and a b c does not exist then the request must fail 8 11 COPY Method The COPY method creates a duplicate of the specified resource All DAV compliant resources MUST support the COPY method Support for the COPY method does not guarantee the ability to copy a resource For example separate programs may control resources on the same server As a result it may not even be possible to copy a resource to a location that appears to be on the same server 8 11 1 The Request The COPY method creates a duplicate of the source resource given by the Request URI in the destination resource given by the Destination header The Destination header MUST be present The exact behavior of the COPY method depends on the type of the source resource 8 11 1 1 COPY for HTTP 1 1 resources When the source resource is not a collection the body of the destination resource MUST be octet for octet identical to the body of the source resource Alterations to the destination resource do not modify the source resource Alterations to the source resource do not modify the destination resource Thus all copies are performed by value All properties on the source resource MUST be duplicated on the destination resource subject to modifying headers following the definition for copying properties 8 11 1 2 COPY for Properties The following section defines how properties on a resource are handled during a COPY operation Live properties SHOULD be duplicated as identically behaving live properties at the destination resource Since they are live properties the server determines the syntax and semantics of these properties Properties named by the Enforce Live Properties header MUST be live on the destination resource or the method MUST fail If a property is not named by Enforce Live Properties and cannot be copied live then its value MUST be duplicated octet for octet in an identically named dead property on the destination resource If a property on the source already exists on the destination resource and the Overwrite header is set to T then the property at the destination MUST be overwritten with the property from the source If the Overwrite header is F and the previous situation exists then the COPY MUST fail with a 4 9 Conflict 8 11 1 3 COPY for Collections The COPY method on a collection without a Depth header MUST act as if a Depth infinity header was included A client MAY submit a Depth header on a COPY on a collection with a value of or infinity DAV compliant servers MUST support the and infinity behaviors A COPY of depth infinity instructs that the collection specified in the Request URI the records of its external member resources and all its internal member resources are to be copied to a location relative to the Destination header A COPY of depth only instructs that the collection the properties and its external members not its internal members are to be copied Any headers included with a COPY are to be applied in processing every resource to be copied The exception to this rule is the Destination header This header only specifies the destination for the Request URI When applied to members of the collection specified in the request URI the value of Destination is to be modified to reflect the current location in the hierarchy So if the request URI is a and the destination is b then when a c d is processed it MUST use a destination of b c d When the COPY method has completed processing it MUST have created a consistent namespace at the destination Thus if it is not possible to COPY a collection with internal members the internal members may still be copied but a collection will have to be created at the destination to contain them The response is a Multi Status response that describes the result of the COPY on each affected resource The response is given for the resource that was to be copied not the resource that was created as a result of the copy In other words each entry indicates whether the copy on the resource specified in the href succeeded or failed and why The exception to this rule is for errors that occurred on the destination For example if the destination was locked the response would indicate the destination URL and a 421 Destination Locked error 8 11 1 4 Type Interactions If the destination resource identifies a collection and the Overwrite header is T prior to performing the copy the server MUST perform a DELETE operation on the collection 8 11 2 Response Codes 2 OK The source resource was successfully copied to a pre existing destination resource 2 1 Created The source resource was successfully copied The copy operation resulted in the creation of a new resource 412 Precondition Failed This status code MUST be returned if the server was unable to maintain the liveness of the properties listed in the Enforce Live Properties header or if the Overwrite header is F and the state of the destination resource is non null 419 Insufficient Space on Resource The destination resource does not have sufficient space to record the state of the resource after the execution of this method 421 Destination Locked The destination resource was locked and either a valid Lock Token header was not submitted or the Lock Token header identifies a lock held by another principal 5 Server Error The resource was in such a state that it could not be copied This may occur if the Destination header specifies a resource that is outside the namespace the resource is able to interact with 8 11 3 Overwrite Example This example shows resource http www ics uci edu fielding index html being copied to the location http www ics uci edu users f fielding index html The contents of the destination resource were overwritten if non null COPY fielding index html HTTP 1 1 Host www ics uci edu Destination http www ics uci edu users f fielding index html HTTP 1 1 2 OK 8 11 4 No Overwrite Example The following example shows the same copy operation being performed except with the Overwrite header set to F A response of 412 Precondition Failed is returned because the destination resource has a non null state COPY fielding index html HTTP 1 1 Host www ics uci edu Destination http www ics uci edu users f fielding index html Overwrite F HTTP 1 1 412 Precondition Failed 8 11 5 Collection Example COPY container HTTP 1 1 Host www foo bar Destination http www foo bar othercontainer Enforce Live Properties Depth Infinity HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav As d d multistatus d response d href http www foo bar othercontainer resource1 d href d href http www foo bar othercontainer resource2 d href d href http www foo bar othercontainer d href d href http www foo bar othercontainer R2 D2 d href d status HTTP 1 1 2 1 Created d status d response d response d href http www foo bar othercontainer R2 d href d status HTTP 1 1 412 Precondition Failed d status d response d multistatus The Depth header is unnecessary as the default behavior of COPY on a collection is to act as if a Depth Infinity header had been submitted In this example most of the resources along with the collection were copied successfully However the collection R2 failed most likely due to a problem with enforcing live properties R2 s member D2 was successfully copied As a result a collection was created at www foo bar othercontainer R2 to contain D2 8 12 MOVE Method The move operation on a resource is the logical equivalent of a copy followed by a delete where the actions are performed atomically All DAV compliant resources MUST support the MOVE method However support for the MOVE method does not guarantee the ability to move a resource to a particular destination For example separate programs may actually control different sets of resources on the same server Therefore it may not even be possible to move a resource within a namespace that appears to belong to the same server 8 12 1 The Request If a resource exists at the destination the destination resource will be DELETEd as a side effect of the MOVE operation subject to the restrictions of the Overwrite header 8 12 2 MOVE for Collections MOVE instructs that the collection specified in the Request URI the records of its external member resources and all its internal member resources are to be moved to a location relative to the Destination header The MOVE method on a collection MUST act as if a Depth infinity header was used on it A client MUST NOT submit a Depth header on a MOVE on a collection with any value but infinity Any headers included with MOVE are to be applied in processing every resource to be moved The exception to this rule is the Destination header The behavior of this header is the same as given for COPY on collections When the MOVE method has completed processing it MUST have created a consistent namespace on both the source and destination creating collections at the source or destination as necessary As specified in the definition of MOVE a MOVE of a collection over another collection causes the destination collection and all its members to be deleted The response is a Multi Status response that describes the result of the MOVE on each affected resource The response is given for the resource that was to be moved not the resource that was created as a result of the move In other words each entry indicates whether the move on the resource specified in the href succeeded or failed and why The exception to this rule is for errors that occurred on the destination For example if the destination was locked the response would indicate the destination URL and a 421 Destination Locked error 8 12 3 Response Codes 2 OK The move operation was successful 4 9 Conflict The MOVE was attempted on a collection with members While the COPY part of this operation could succeed the DELETE could not Therefore the MOVE MUST fail 412 Precondition Failed This status code MUST be returned if the server was unable to maintain the liveness of the properties listed in the Enforce Live Properties header or if the Overwrite header is F and the state of the destination resource is non null 421 Destination Locked The destination resource was locked and either a valid Lock Token header was not submitted or the Lock Token header identifies a lock held by another principal 5 2 Bad Gateway This may occur when the destination is on another server and the destination server refuses to accept the resource 8 12 4 Overwrite Example This example shows resource http www ics uci edu fielding index html being moved to the location http www ics uci edu users f fielding index html The contents of the destination resource were overwritten if non null MOVE fielding index html HTTP 1 1 Host www ics uci edu Destination http www ics uci edu users f fielding index html HTTP 1 1 2 OK 8 12 5 Collection Example MOVE container HTTP 1 1 Host www foo bar Destination http www foo bar othercontainer Enforce Live Properties Overwrite False Lock Token OpaqueLockToken xxxx OpaqueLockToken xxxx HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav As D d multistatus d response d href http www foo bar container resource1 d href d href http www foo bar container resource2 d href d href http www foo bar container d href d href http www foo bar container C2 R2 d href d status HTTP 1 1 2 1 Created d status d response d response d href http www foo bar container C2 d href d status HTTP 1 1 42 Method Failure d status d response d href http www foo bar othercontainer C2 d href d status HTTP 1 1 4 9 Conflict d status d response d multistatus In this example the client has submitted a number of lock tokens with the request A lock token will need to be submitted for every resource both source and destination anywhere in the scope of the method that is locked In this case the proper lock token was not submitted for the destination http www foo bar othercontainer C2 This means that the resource continer c2 could not be moved although its child container C2 R2 could be moved 8 13 LOCK Method The following sections describe the LOCK method which is used to take out a lock of any access type These sections on the LOCK method describe only those semantics that are specific to the LOCK method and are independent of the access type of the lock being requested Once the general LOCK method has been described subsequent sections describe the semantics of the write access type and the write lock 8 13 1 Operation A LOCK method invocation creates the lock specified by the Lock Info header on the Request URI Lock method requests SHOULD have a XML request body which contains an Owner XML element for this lock request The LOCK request MAY have a Timeout header A successful response to a lock invocation MUST include Lock Token and Timeout headers Clients MUST assume that locks may arbitrarily disappear at any time regardless of the value given in the Timeout header The Timeout header only indicates the behavior of the server if extraordinary circumstances do not occur For example an administrator may remove a lock at any time or the system may crash in such a way that it loses the record of the lock s existence The response MUST also contain the value of the lockdiscovery property in a prop XML element 8 13 2 The Effect of Locks on Properties and Collections By default the scope of a lock is the entire state of the resource including its body and associated properties As a result a lock on a resource also locks the resource s properties and a lock on a property may lock a property s resource or may restrict the ability to lock the property s resource Only a single lock token MUST be used when a lock extends to cover both a resource and its properties Note that certain lock types MAY override this behavior For collections a lock also affects the ability to add or remove members The nature of the effect depends upon the type of access control involved 8 13 3 Locking Replicated Resources Some servers automatically replicate resources across multiple URLs In such a circumstance the server MAY only accept a lock on one of the URLs if the server can guarantee that the lock will be honored across all the URLs 8 13 4 Locking Multiple Resources The LOCK method supports locking multiple resources simultaneously by allowing for the listing of several URIs in the LOCK request These URIs in addition to the Request URI are then to be locked as a result of the LOCK method s invocation When multiple resources are specified the LOCK method only succeeds if all specified resources are successfully locked The Lock Tree option of the lock request specifies that the resource and all its internal children including internal collections and their internal members are to be locked This is another mechanism by which a request for a lock on multiple resources can be specified Currently existing locks can not be extended to cover more or less resources and any request to expand or contract the number of resources in a lock MUST fail with a 4 9 Conflict status code So for example if resource A is exclusively write locked and then the same principal asks to exclusively write lock resources A B and C the request will fail as A is already locked and the lock can not be extended A successful result will return a single lock token which represents all the resources that have been locked If an UNLOCK is executed on this token all associated resources are unlocked If the lock cannot be granted to all resources a 4 9 Conflict status code MUST be returned with a response entity body containing a multistatus XML element describing which resource s prevented the lock from being granted 8 13 5 Interaction with other Methods The interaction of a LOCK with various methods is dependent upon the lock type However independent of lock type a successful DELETE of a resource MUST cause all of its locks to be removed 8 13 6 Lock Compatibility Table The table below describes the behavior that occurs when a lock request is made on a resource Current lock state Lock request Shared Lock ExclusiveLock None True True Shared Lock True False Exclusive Lock False False Legend True lock MAY be granted False lock MUST NOT be granted if the principal requesting the lock is the owner of the lock the lock MAY be regranted The current lock state of a resource is given in the leftmost column and lock requests are listed in the first row The intersection of a row and column gives the result of a lock request For example if a shared lock is held on a resource and an exclusive lock is requested the table entry is false indicating the lock must not be granted If an exclusive or shared lock is re requested by the principal who owns the lock the lock MUST be regranted If the lock is regranted the same lock token that was previously issued MUST be returned 8 13 7 Owner XML Element Name owner Namespace http www ietf org standards dav Purpose Provide information about the principal taking out a lock Parent Any Values XML Elements Descripton The Owner XML element provides information sufficient for either directly contacting a principal such as a telephone number or Email URI or for discovering the principal such as the URL of a homepage who owns a lock 8 13 8 Lock Response A successful lock response MUST contain a Lock Token response header a Timeout header and a prop XML element in the response body which contains the value of the lockdiscovery property 8 13 9 Response Codes 4 9 Conflict The resource is locked so the method has been rejected 412 Precondition Failed The included Lock Token was not enforceable on this resource or the server could not satisfy the request in the Lock Info header 8 13 1 Example Simple Lock Request LOCK workspace webdav proposal doc HTTP 1 1 Host webdav sb aol com Lock Info LockType Write LockScope Exclusive Timeout Infinite Second 41 Content Type text xml Content Length xyz XML version 1 namespace href http www ietf org standards dav AS D D owner D href http www ics uci edu ejw contact html D href D owner HTTP 1 1 2 OK Lock Token opaquelocktoken xyz12239348123 912asdfa 9s8df 9s7df Timeout Second 6 48 Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav AS D D prop D lockdiscovery D activelock D locktype write D locktype D lockscope exclusive D lockscope D addlocks D owner D href http www ics uci edu ejw contact html D href D owner D timeout Second 6 48 D timeout D locktoken D href opaquelocktoken xyz12239348123 912asdfa 9s8df 9s7df D href D locktoken D activelock D lockdiscovery D prop This example shows the successful creation of an exclusive write lock on resource http webdav sb aol com workspace webdav proposal doc The resource http www ics uci edu ejw contact html contains contact information for the owner of the lock The server has an activity based timeout policy in place on this resource which causes the lock to automatically be removed after 1 week 6 48 seconds The response has a Lock Token header that gives the lock token URL that uniquely identifies the lock created by this lock request 8 13 11 Example Multi Resource Lock Request LOCK workspace webdav proposal doc HTTP 1 1 Host webdav sb aol com Lock Info LockType Write LockScope Exclusive Addlocks http webdav sb aol com workspace http foo bar blah Timeout Infinite Second 41 XML version 1 namespace href http www ietf org standards dav AS D D href http www ics uci edu ejw contact html D href HTTP 1 1 4 9 Conflict Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav As D D multistatus D response D href http webdav sb aol com workspace webdav proposal doc D href D href http webdav sb aol com workspace webdav D href D status HTTP 1 1 2 2 Accepted D status D response D response D href http foo bar blah D href D status HTTP 1 1 4 3 Forbidden D status D response D multistatus This example shows a request for an exclusive write lock on three resources http webdav sb aol com workspace webdav proposal doc http webdav sb aol com workspace and http foo bar blah In this request the client has specified that it desires an infinite length lock if available otherwise a timeout of 4 1 billion seconds if available The Owner header field specifies the web address for contact information for the principal taking out the lock This lock request has failed because the server rejected the lock request for http foo bar blah The 4 9 Conflict status code indicates that the server was unable to satisfy the request because there is a conflict between the state of the resources and the operation named in the request Within the multistatus the 2 2 Accepted status code indicates that the lock method was accepted by the resources and would have been completed if all resources named in the request were able to be locked The 4 3 Forbidden status code indicates that the server does not allow lock requests on this resource 8 14 UNLOCK Method The UNLOCK method removes the lock identified by the lock token in the Lock Token header from the Request URI and all other resources included in the lock Any DAV compliant resource which supports the LOCK method MUST support the UNLOCK method 8 14 1 Example UNLOCK workspace webdav info doc HTTP 1 1 Host webdav sb aol com Lock Token opaquelocktoken 123AbcEfg1284h23h2 HTTP 1 1 2 OK In this example the lock identified by the lock token opaquelocktoken 123AbcEfg1284h23h2 is successfully removed from the resource http webdav sb aol com workspace webdav info doc If this lock included more than just one resource the lock was removed from those resources as well 8 15 PATCH Method The PATCH method is used to modify parts of the entity returned in the response to a GET method DAV compliant resources MAY support the PATCH method 8 15 1 The Request The request entity of the PATCH method contains a list of differences between the resource identified by the Request URI and the desired content of the resource after the PATCH action has been applied The list of differences is in a format defined by the media type of the entity e g application diff and must include sufficient information to allow the server to convert the original version of the resource to the desired version Processing performed by PATCH is atomic Hence all changes MUST be successfully executed or the method fails PATCH MUST fail if executed on a non existent resource i e PATCH does not create a resource as a side effect If the request appears at least initially to be acceptable the server MUST transmit an interim 1 response message after receiving the empty line terminating the request headers and continue processing the request Since the semantics of PATCH are non idempotent responses to this method are not cacheable While server support for PATCH is optional if a server does support PATCH it MUST support at least the text xml diff format defined below Support for the VTML difference format VTML is recommended but not required 8 15 2 text xml elements for PATCH The resourceupdate XML element contains a set of XML sub entities that describe modification operations The name and meaning of these XML elements are given below Processing of these directives MUST be performed in the order encountered within the XML document A directive operates on the resource as modified by all previous directives executed in sequential order The length of the resource MAY be extended or reduced by a PATCH The changes specified by the resourceupdate XML element MUST be executed atomically 8 15 2 1 resourceupdate XML Element Name resourceupdate Namespace http www ietf org standards dav patch Purpose Contains an ordered set of changes to a non collection non property resource Parent None Value insert delete replace 8 15 2 2 insert XML Element Name insert Namespace http www ietf org standards dav patch Purpose Insert the XML element s contents starting at the specified octet Parent resourceupdate Value The insert XML element MUST contain an octet range XML attribute that specifies an octet position within the body of a resource A value of end specifies the end of the resource The body of the insert XML element contains the octets to be inserted Please note that in order to protect the white space contained in this XML element the following attribute value MUST be included in the element XML SPACE PRESERVE This attribute is defined in the XML specification Bray Sperberg McQueen 1997 8 15 2 3 delete XML Element Name delete Namespace http www ietf org standards dav patch Purpose Removes the specified range of octets Parent resourceupdate Value The delete XML element MUST contain an octet range XML attribute Discussion The octets that are deleted are removed which means the resource is collapsed and the length of the resource is decremented by the size of the octet range It is not appropriate to replace deleted octets with zeroed out octets since zero is a valid octet value 8 15 2 4 replace XML Element Name replace Namespace http www ietf org standards dav patch Purpose Replaces the specified range of octets with the contents of the XML element If the number of octets in the XML element is different from the number of octets specified the update MUST be rejected Parent resourceupdate Value The replace XML element MUST contain an octet range XML attribute The contents of the entity are the replacement octets Please note that in order to protect the white space contained in this XML element the following attribute value MUST be included in the element XML SPACE PRESERVE This attribute is defined in the XML specification Bray Sperberg McQueen 1997 8 15 2 5 octet range Attribute Name octet range Namespace http www ietf org standards dav patch Purpose Specifies a range of octets that the enclosing property affects Parent insert delete replace Value number number end Number 1 Digit Description Octet numbering begins with If the octet contains a single number then the operation is to begin at that octet and to continue for a length specified by the operation In the case of a delete this would mean to delete a single octet In the case of an insert this would mean to begin the insertion at the specified octet and to continue for the length of the included value extending the resource if necessary In the case of replace the replace begins at the specified octet and overwrites all that follow to the length of the included value 8 15 3 Response Codes 2 OK The request entity body was processed without error resulting in an update to the state of the resource 4 9 Conflict If the update information in the request message body does not make sense given the current state of the resource e g an instruction to delete a non existent line this status code MAY be returned 415 Unsupported Media Type The server does not support the content type of the update instructions in the request message body 418 Unprocessable Entity The entity body submitted with the PATCH was not understood by the resource 419 Insufficient Space on Resource The resource does not have sufficient space to record the state of the resource after the execution of this method 8 15 4 HTML file modification Example The following example shows a modification of the title and contents of the HTML resource http www example org hello html Before HTML HEAD TITLE Hello world HTML page TITLE HEAD BODY P Hello world P BODY HTML PATCH Request Response PATCH hello html HTTP 1 1 Host www example org Content Type text xml Content Length xxx HTTP 1 1 1 Continue XML version 1 namespace href http www ietf org standards dav patch AS D D resourceupdate D replace XML SPACE PRESERVE D octet range 14 D octet range 3CTITLE 3ENew Title 3C TITLE 3E D replace D delete D octet range 38 5 D octet range D delete D insert XML SPACE PRESERVE D octet range 86 D octet range 3CP 3ENew paragraph 3C P 3E D insert D resourceupdate HTTP 1 1 2 OK After HTML HEAD TITLE New Title TITLE HEAD BODY P Hello world P P New paragraph P BODY HTML 9 HTTP Headers for Distributed Authoring 9 1 Collection Member Header CollectionMember Collection Member URI URI is defined in section 3 2 1 of Fielding et al 1997 The Collection Member header specifies the URI of an external resource to be added deleted to from a collection 9 2 DAV Header DAV DAV 1 2 extend This header indicates that the resource supports the DAV schema and protocol to the level indicated All DAV compliant resources MUST return the DAV header on all OPTIONS responses 9 3 Depth Header Depth Depth 1 infinity The Depth header is used with methods executed on collections to indicate whether the method is to be applied only to the collection Depth to the collection and its immediate children Depth 1 or the collection and all its progeny Depth infinity Note that Depth 1 and Depth infinity behavior only applies to internal member resources and not to external member resources The Depth header is only supported if a method s definition explicitly provides for such support The following rules are the default behavior for any method that supports the depth header A method MAY override these defaults by defining different behavior in its definition Methods which support the depth header MAY choose not to support all of the header s values and MAY define on a case by case basis the behavior of the method on a collection if a depth header is not present For example the MOVE method only supports Depth infinity and if a depth header is not present will act as if a Depth infinity header had been applied Clients MUST NOT rely upon methods executing on members of their hierarchies in any particular order or the execution being atomic Note that methods MAY provide guarantees on ordering and atomicity Upon execution a method with a depth header will perform as much of its assigned task as possible and then return a response specifying what it was able to accomplish and what it failed to do So for example an attempt to COPY a hierarchy may result in some of the members being copied and some not Any headers on a method with a depth header MUST be applied to all resources in the scope of the method For example an if match header will have its value applied against every resource in the method s scope and will cause the method to fail if the header fails to match If a resource source or destination within the scope of the method is locked in such a way as to prevent the successful execution of the method then the lock token for that resource MUST be submitted with the request in the Lock Token request header 9 4 Destination Header Destination Destination URI The Destination header specifies a destination resource for methods such as COPY and MOVE which take two URIs as parameters 9 5 Destroy Header DestroyHeader Destroy Choices Choices VersionDestroy NoUndelete Undelete extend Extend RFC Reg Coded URL RFC Req Token This is a token value defined in section 2 2 of Fielding et al 1997 that has been published as an RFC Coded URL URI When deleting a resource the client often wishes to specify exactly what sort of delete should be performed The Destroy header used with the Mandatory header allows the client to specify the end result it desires The Destroy header is specified as follows The Undelete token requests that if possible the resource should be left in a state such that it can be undeleted The server is not required to honor this request The NoUndelete token requests that the resource MUST NOT be left in a state such that it can be undeleted The VersionDestroy token includes the functionality of the NoUndelete token and extends it to include having the server remove all versioning references to the resource that it has control over 9 6 Enforce Live Properties Header EnforceLiveProperties Enforce Live Properties Omit 1 Property Name Property Name Coded URL The Enforce Live Properties header specifies properties that MUST be live after they are copied moved to the destination resource of a copy or move If the value is given for the header then it designates all live properties on the source resource If the value is Omit then the server MUST NOT duplicate on the destination resource any properties that are defined on the source resource If this header is not included then the server is expected to act as defined by the default property handling behavior of the associated method 9 7 If None State Match If None State Match If None State Match 1 Coded URL The If None State Match header is intended to have similar functionality to the If None Match header defined in section 14 26 of RFC 2 68 However the if none state match header is intended for use with any URI which represents state information about a resource referred to as a state token A typical example is a lock token If any of the state tokens identifies the current state of the resource the server MUST NOT perform the requested method Instead if the request method was GET HEAD INDEX or PROPFIND the server SHOULD respond with a 3 4 Not Modified response including the cache related entity header fields particularly ETag of the current state of the resource For all other request methods the server MUST respond with a status of 412 Precondition Failed If none of the state tokens identifies the current state of the resource the server MAY perform the requested method If any of the tokens is not recognized then the method MUST fail with a 412 Precondition Failed Note that the AND and OR keywords specified with the If State Match header are intentionally not defined for If None State Match because this functionality is not required 9 8 If State Match If State Match If State Match AND OR 1 Coded URL The If State Match header is intended to have similar functionality to the If Match header defined in section 14 25 of RFC 2 68 However the If State Match header is intended for use with any URI which represents state information about a resource A typical example is a lock token If the AND keyword is used and all of the state tokens identify the state of the resource then the server MAY perform the requested method If the OR keyword is used and any of the state tokens identifies the current state of the resource then the server MAY perform the requested method If the keyword requirement for the the keyword used is not met the server MUST NOT perform the requested method and MUST return a 412 Precondition Failed response If any of the tokens is not recognized then the method MUST fail with a 412 Precondition Failed 9 9 Lock Info Request Header LockInfo Lock Info DAVLockType SP DAVLockScope SP AdditionalLocks SP Lock Tree DAVLockType LockType DAVLockTypeValue DAVLockTypeValue Write Extend DAVLockScope LockScope DAVLockScopeValue DAVLockScopeValue Exclusive Shared Extend AdditionalLocks AddLocks 1 URI Lock Tree Lock Tree T F The Lock Info request header specifies the scope and type of a lock for a LOCK method request The syntax specification below is extensible allowing new type and scope identifiers to be added The LockType field specifies the access type of the lock At present this specification only defines one lock type the Write lock The LockScope field specifies whether the lock is an exclusive lock or a shared lock The AddLocks field specifies additional URIs beyond the Request URI to which the lock request applies The LockTree field is used to specify recursive locks If the LockTree field is T the lock request applies to the hierarchy traversal of the internal member resources of the Request URI and the AddLocks URIs inclusive of the Request URI and the AddLocks URIs It is not an error if LockTree is T and the Request URI or the AddLocks URIs have no internal member resources By default the value of LockTree is F and this field MAY be omitted when its value is F 9 1 Lock Token Request Header Lock Token Lock Token 1 Coded URL The Lock Token request header containing a lock token owned by the requesting principal is used by the principal to indicate that the principal is aware of the existence of the lock specified by the lock token If the following conditions are met 1 The method is restricted by a lock type that requires the submission of a lock token such as a write lock 2 The user agent has authenticated itself as a principal 3 The user agent is submitting a method request to a resource on which the principal owns a write lock Then 1 The method request MUST include a Lock Token header with the lock token or 2 The method MUST fail with a 4 9 Conflict status code If multiple resources are involved with a method such as a COPY or MOVE method then the lock tokens if any for all involved resources MUST be included in the Lock Token request header For example Program A used by user A takes out a write lock on a resource Program A then makes a number of PUT requests on the locked resource All the requests contain a Lock Token request header that includes the write lock state token Program B also run by User A then proceeds to perform a PUT to the locked resource However program B was not aware of the existence of the lock and so does not include the appropriate Lock Token request header The method is rejected even though principal A is authorized to perform the PUT Program B can if it so chooses now perform lock discovery and obtain the lock token Note that programs A and B can perform GETs without using the Lock Token header because the ability to perform a GET is not affected by a write lock Having a lock token provides no special access rights Anyone can find out anyone else s lock token by performing lock discovery Locks are to be enforced based upon whatever authentication mechanism is used by the server not based on the secrecy of the token values 9 11 Lock Token Response Header Lock Token Lock Token Coded URL If a resource is successfully locked then a Lock Token header will be returned containing the lock token that represents the lock 9 12 Overwrite Header Overwrite Overwrite T F The Overwrite header specifies whether the server should overwrite the state of a non null destination resource during a COPY or MOVE A value of F states that the server MUST NOT perform the COPY or MOVE operation if the state of the destination resource is non null By default the value of Overwrite is T and a client MAY omit this header from a request when its value is T While the Overwrite header appears to duplicate the functionality of the If Match header of HTTP 1 1 If Match applies only to the Request URI and not to the Destination of a COPY or MOVE If a COPY or MOVE is not performed due to the value of the Overwrite header the method MUST fail with a 4 9 Conflict status code 9 13 Propfind Request Header Propfind Propfind allprop propname RFC Reg 1 Property Name The Propfind header is used to specify which properties are to be returned in a PROPFIND method The properties are identified by their URIs Two special tokens are defined for use with the Propfind header allprop and propname The allprop token specifies that all property names and values on the resource are to be returned The propname token specifies that only a list of property names on the resource are to be returned 9 14 Status URI Response Header The Status URI response header MAY be used with the 1 2 Processing response code to inform the client as to the status of a method Status URI Status URI Status Code URI Status Code is defined in 6 1 1 of Fielding et al 1997 The URIs listed in the header are source resources which have been affected by the outstanding method The status code indicates the resolution of the method on the identified resource So for example if a MOVE method on a collection is outstanding and a 1 2 Processing response with a Status URI response header is returned the included URIs will indicate resources that have had move attempted on them and what the result was 9 15 Timeout Header TimeOut Timeout 1 TimeType TimeType Second DAVTimeOutVal Infinite Other DAVTimeOutVal 1 digit Other Extend field value See section 4 2 of RFC 2 68 Clients MAY include Timeout headers in their LOCK requests However the server is not required to honor or even consider these requests Clients MUST NOT submit a Timeout request header with any method other than a LOCK method A Timeout request header MUST contain at least one TimeType and MAY contain multiple TimeType entries The purpose of listing multiple TimeType entries is to indicate multiple different values and value types that are acceptable to the client The client lists the TimeType entries in order of preference The Timeout response header MUST use a Second value Infinite or a TimeType the client has indicated familiarity with The server MAY assume a client is familiar with any TimeType submitted in a Timeout header The Second TimeType specifies the number of seconds that MUST elapse between granting of the lock at the server and the automatic removal of the lock A server MUST not generate a timeout value for Second greater than 2 32 1 The timeout counter is restarted any time an owner of the lock sends a method to any member of the lock including unsupported methods or methods which are unsuccessful It is recommended that the HEAD method be used when the goal is simply to restart the timeout counter If the timeout expires then the lock is lost Specifically the server SHOULD act as if an UNLOCK method was executed by the server on the resource using the lock token of the timed out lock performed with its override authority Thus logs should be updated with the disposition of the lock notifications should be sent etc just as they would be for an UNLOCK request Servers are advised to pay close attention to the values submitted by clients as they will be indicative of the type of activity the client intends to perform For example an applet running in a browser may need to lock a resource but because of the instability of the environment within which the applet is running the applet may be turned off without warning As a result the applet is likely to ask for a relatively small timeout value so that if the applet dies the lock can be quickly harvested However a document management system is likely to ask for an extremely long timeout because its user may be planning on going off line 1 Response Code Extensions to HTTP 1 1 The following response codes are added to those defined in HTTP 1 1 Fielding et al 1997 1 1 1 2 Processing Methods can potentially take a long period of time to process especially methods that support the Depth header In such cases the client may time out the connection while waiting for a response To prevent this the server MAY return a 1 2 response code to indicate to the client that the server is still processing the method If a method is taking longer than 2 seconds a reasonable but arbitrary value to process the server SHOULD return a 1 2 Processing response 1 2 2 7 Multi Status The response requires providing status for multiple independent operations 1 3 418 Unprocessable Entity The server understands the content type of the request entity but was unable to process the contained instructions 1 4 419 Insufficient Space on Resource The resource does not have sufficient space to record the state of the resource after the execution of this method 1 5 42 Method Failure The method was not executed on a particular resource within its scope because some part of the method s execution failed causing the entire method to be aborted For example if a resource could not be moved as part of a MOVE method all the other resources would fail with a 42 Method Failure 1 6 421 Destination Locked The destination resource of a method is locked and either the request did not contain a valid Lock Info header or the Lock Info header identifies a lock held by another principal 11 Multi Status Response The default 2 7 Multi Status response body is a text xml HTTP entity that contains a single XML element called multistatus which contains a set of XML elements called response one for each 2 3 4 and 5 series status code generated during the method invocation 1 series status codes MUST NOT be recorded in a response XML element 11 1 multistatus XML Element Name multistatus Namespace http www ietf org standards dav Purpose Contains multiple response messages Parent Any Value 1 response responsedescription Description The responsedescription at the top level is used to provide a general message describing the overarching nature of the response If this value is available an application MAY use it instead of presenting the individual response descriptions contained within the responses 11 2 response XML Element Name response Namespace http www ietf org standards dav Purpose Holds a single response Parent multistatus Value href prop status responsedescription Description Prop MUST contain one or more empty XML elements representing the names of properties Multiple properties may be included if the same response applies to them all If href is used then the response refers to a problem with the referenced resource not a property 11 3 status XML Element Name status Namespace http www ietf org standards dav Purpose Holds a single HTTP status line Parent response Value status line status line defined in Fielding et al 1997 11 4 responsedescription XML Element Name responsedescription Namespace http www ietf org standards dav Purpose Contains a message that can be displayed to the user explaining the nature of the response Parent multistatus response Value Any Description This XML element provides information suitable to be presented to a user 12 Generic DAV XML Elements 12 1 href XML Element Name href Namespace http www ietf org standards dav Purpose To identify that the content of the element is a URI Parent Any Value URI See section 3 2 1 of Fielding et al 1997 12 2 link XML Element Name link Namespace http www ietf org standards dav Purpose To identify a property as a link and to contain the source and destination of that link Values 1 src 1 dst Description Link is used to provide the sources and destinations of a link The type of the property containing the link XML element provides the type of the link Link is a multi valued element so multiple Links may be used together to indicate multiple links with the same type 12 2 1 src XML Element Name src Namespace http www ietf org standards dav Purpose To indicate the source of a link Parent link Values URI 12 2 2 dst XML Element Name dst Namespace http www ietf org standards dav Purpose To indicate the destination of a link Parent link Values URI 12 2 3 Example XML version 1 namespace href http www ietf org standards dav AS D namespace href http www foocorp com Project AS F D prop D Source D link F projfiles Source F projfiles D src http foo bar program D src D dst http foo bar src main c D dst D link D link F projfiles Library F projfiles D src http foo bar program D src D dst http foo bar src main lib D dst D link D link F projfiles Makefile F projfiles D src http foo bar program D src D dst http foo bar src makefile D dst D link D Source D prop In this example the resource http foo bar program has a source property that contains three links Each link contains three elements two of which src and dst are part of the DAV schema defined in this document and one which is defined by the schema http www foocorp com project Source Library and Makefile A client which only implements the elements in the DAV spec will not understand the foocorp elements and will ignore them thus seeing the expected source and destination links An enhanced client may know about the foocorp elements and be able to present the user with additional information about the links This example demonstrates the power of XML markup that allows for element values to be enhanced without breaking older clients 12 3 prop XML element Name prop Namespace http www ietf org standards dav Purpose Contains properties related to a resource Parent Any Values XML Elements Description The prop XML element is a generic container for properties defined on resources All elements inside prop MUST define properties related to the resource No other elements may be used inside of a prop element 13 DAV Properties 13 1 creationdate Property Name creationdate Namespace http www ietf org standards dav Purpose The time and date the resource was created Value The time and date MUST be given in ISO 86 1 format ISO86 1 Description This property SHOULD be defined on all DAV compliant resources If present it contains a timestamp of the moment when the resource was created i e the moment it had non null state 13 2 displayname Property Name displayname Namespace http www ietf org standards dav Purpose A name for the resource that is suitable for presentation to a user Value Any valid XML character data as defined in Bray Sperberg McQueen 1997 Description This property SHOULD be defined on all DAV compliant resources If present the property contains a description of the resource that is suitable for presentation to a user 13 3 get content language Property Name get content language Namespace http www ietf org standards dav Purpose Contains the Content Language header returned by a GET without accept headers If no Content Language header is available this property MUST NOT exist Value language tag language tag is defined in section 14 13 of RFC 2 68 13 4 get content length Property Name get content length Namespace http www ietf org standards dav Purpose Contains the Content Length header returned by a GET without accept headers If no Content Length header is available this property MUST NOT exist Value content length see section 14 14 of RFC 2 68 13 5 get content type Property Name get content type Namespace http www ietf org standards dav Purpose Contains the Content Type header returned by a GET without accept headers If no Content Type header is available this property MUST NOT exist Value media type defined in Section 3 7 of Fielding et al 1997 13 6 get etag Property Name get etag Namespace http www ietf org standards dav Purpose Contains the ETag header returned by a GET without accept headers If no ETag header is available this property MUST NOT exist Value entity tag defined in Section 3 11 of Fielding et al 1997 Description Note that the ETag on some resource may reflect changes in any part of the state of the resource not necessarily just a change to the response to the GET method For example a change in the ACL may cause the ETag to change 13 7 get last modified Property Name get last modified Namespace http www ietf org standards dav Purpose Contains the Last Modified header returned by a GET method without accept headers If no Last Modified header is available this property MUST NOT exist Value HTTP date defined in Section 3 3 1 of Fielding et al 1997 Description Note that the last modified date on some resource may reflect changes in any part of the state of the resource not necessarily just a change to the response to the GET method For example a change in a property may cause the last modified date to change 13 8 index content language Property Name index content language Namespace http www ietf org standards dav Purpose Contains the Content Language header returned by an INDEX without accept headers If no Content Language header is available this property MUST NOT exist Value language tag language tag is defined in section 14 13 of RFC 2 68 13 9 index content length Property Name index content length Namespace http www ietf org standards dav Purpose Contains the Content Length header returned by an INDEX without accept headers If no Content Length header is available this property MUST NOT exist Value content length see section 14 14 of RFC 2 68 13 1 index content type Property Name index content type Namespace http www ietf org standards dav Purpose Contains the Content Type header returned by an INDEX without accept headers If no Content Type header is available this property MUST NOT exist Value media type defined in Section 3 7 of Fielding et al 1997 13 11 index etag Property Name index etag Namespace http www ietf org standards dav Purpose Contains the ETag header returned by an INDEX without accept headers If no ETag header is available this property MUST NOT exist Value entity tag defined in Section 3 11 of Fielding et al 1997 Description Note that the ETag on some resource may reflect changes in any part of the state of the resource not necessarily just a change to the response to the INDEX method For example a change in the ACL may cause the ETag to change 13 12 index last modified Property Name index last modified Namespace http www ietf org standards dav Purpose Contains the Last Modified header returned by an INDEX method without accept headers If no Last Modified header is available this property MUST NOT exist Value HTTP date defined in Section 3 3 1 of Fielding et al 1997 Description Note that the last modified date on some resource may reflect changes in any part of the state of the resource not necessarily just a change to the response to the INDEX method For example a change in a property may cause the last modified date to change 13 13 lockdiscovery Property Name lockdiscovery Namespace http www ietf org standards dav Purpose To discover what locks are active on a resource Values activelock Description The lockdiscovery property returns a listing of who has a lock what type of lock he have the timeout type and the time remaining on the timeout and the associated lock token The server is free to withhold any or all of this information if the requesting principal does not have sufficient access rights to see the requested data A server which supports locks MUST provide the lockdiscovery property on any resource with locks on it 13 13 1 activelock XML Element Name activelock Namespace http www ietf org standards dav Purpose A multivalued XML element that describes a particular active lock on a resource Parent lockdiscovery Values locktype lockscope addlocks owner timeout locktoken 13 13 2 owner XML Element Name owner Namespace http www ietf org standards dav Purpose Returns owner information Parent activelock Values XML REF PCDATA 13 13 3 timeout XML Element Name timeout Namespace http www ietf org standards dav Purpose Returns information about the timeout associated with the lock Parent activelock Values TimeType 13 13 4 addlocks XML Element Name addlocks Namespace http www ietf org standards dav Purpose Lists additional resources associated with this lock if any Parent activelock Values 1 href 13 13 5 locktoken XML Element Name locktoken Namespace http www ietf org standards dav Purpose Returns the lock token Parent activelock Values href Description The href contains a Lock Token URL 13 13 6 Example PROPFIND container HTTP 1 1 Host www foo bar Content Length xxxx Content Type text xml XML version 1 namespace href http www ietf org standards dav AS D D propfind D prop lockdiscovery D prop D propfind HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav AS D D multistatus D response D prop D lockdiscovery D activelock D locktype write D locktype D lockscope exclusive D lockscope D addlocks D href http foo com doc D href D addlocks D owner Jane Smith D owner D timeout Infinite D timeout D locktoken D href iamuri unique D href D locktoken D activelock D lockdiscovery D prop D status HTTP 1 1 2 OK D status D response D multistatus This resource has a single exclusive write lock on it with an infinite timeout This same lock also covers the resource http foo com doc 13 14 resourcetype Property Name resourcetype Namespace http www ietf org standards dav Purpose This property contains a series of XML elements that specify information regarding the nature of the resource This specification only defines a single value collection Value XML elements Description This property MUST be defined on all DAV compliant resources The default value is empty 13 14 1 collection XML Element Name collection Namespace http www ietf org standards dav Purpose Identifies the associated resource as a collection Collection resources MUST define this value with the resourcetype property Parent resourcetype Values None 13 15 Source Link Property Type Name source Namespace http www ietf org standards dav link Purpose The destination of the source link identifies the resource that contains the unprocessed source of the link s source Parent None Value An XML document with zero or more link XML elements Discussion The source of the link src is typically the URI of the output resource on which the link is defined and there is typically only one destination dst of the link which is the URI where the unprocessed source of the resource may be accessed When more than one link destination exists this specification asserts no policy on ordering 13 16 supportedlock Property Name supportedlock Namespace http www ietf org standards dav Purpose To provide a listing of the lock capabilities supported by the resource Values An XML document containing zero or more LockEntry XML elements Description The supportedlock property of a resource returns a listing of the combinations of scope and access types which may be specified in a lock request on the resource Note that the actual contents are themselves controlled by access controls so a server is not required to provide information the client is not authorized to see If supportedlock is available on then it MUST define the set of locks allowed on all resources on that server 13 16 1 lockentry XML Element Name lockentry Namespace http www ietf org standards dav Purpose Defines a DAVLockType LockScope pair that may be legally used with a LOCK on the specified resource Parent supportedlock Values locktype lockscope 13 16 2 locktype XML Element Name locktype Namespace http www ietf org standards dav Purpose Lists a DAVLockType Parent lockentry Values DAVLockTypeValue 13 16 3 lockscope XML Element Name lockscope Namespace http www ietf org standards dav Purpose Lists a DAVLockScope Parent lockentry Values DAVLockScopeValue 13 16 4 Example PROPFIND container HTTP 1 1 Host www foo bar Content Length xxxx Content Type text xml XML version 1 namespace href http www ietf org standards dav AS D D propfind D prop supportedlock D prop D propfind HTTP 1 1 2 7 Multi Status Content Type text xml Content Length xxxxx XML version 1 namespace href http www ietf org standards dav AS D D multistatus D response D prop D supportedlock D LockEntry D locktype Write D locktype D lockscope Exclusive D lockscope D LockEntry D LockEntry D locktype Write D locktype D lockscope Shared D lockscope D LockEntry D supportedlock D prop D status HTTP 1 1 2 OK D status D response D multistatus 14 DAV Compliance Levels A DAV compliant resource can choose from two levels of compliance A client can discover which level a resource supports by executing OPTIONS on the resource and examining the DAV header which is returned Since this document describes extensions to the HTTP 1 1 protocol minimally all DAV compliant resources clients and proxies MUST be compliant with RFC 2 68 Fielding et al 1997 14 1 Level 1 A level 1 compliant resource MUST meet all MUST requirements in all sections of this document 14 2 Level 2 A level 2 compliant resource MUST meet all level 1 requirements and support the supportedlock property as well as the LOCK method 15 Internationalization Considerations In the realm of internationalization issues this specification is substantively in compliance with the IETF Character Set Policy Alvestrand 1997 In this specification human readable fields can be found in either the value of a property or in an error message returned in a response entity body In both cases the human readable content is encoded using XML which has explicit provisions for character set tagging and encoding and requires by default that XML processors read XML elements encoded using the UTF 8 and UCS 2 encodings of the ISO 1 646 basic multilingual plane Furthermore XML contains provisions for encoding XML elements using other encoding schemes notable among them UCS 4 which permits encoding of characters from any ISO 1 646 character plane The default character set encoding for XML data in this specification and in general is UTF 8 WebDAV compliant applications MUST support the UTF 8 and UCS 2 character set encodings for XML elements and SHOULD support the UCS 4 encoding The XML character set encoding declaration for each supported character set MUST also be supported since it is by using this encoding declaration that an XML processor determines the encoding of an element XML also provides language tagging capability which provides the ability to specify the language of the contents of a particular XML element Although XML and hence WebDAV does not use RFC 1766 language tags for its language names the benefit of using standard XML in this context outweighs the advantage of using RFC 1766 language tags Names used within this specification fall into two categories names specific to protocol elements such as methods and headers names of XML elements and names of properties Naming of protocol elements follows the precedent of HTTP using English names encoded in USASCII for methods and headers Since these protocol elements are not visible to users and are in fact simply long token identifiers they do not need to support encoding in multiple character sets Similarly though the names of XML elements used in this specification are English names encoded in UTF 8 these names are not visible to the user and hence do not need to support multiple character set encodings The name of a property defined on a resource is a URI Although some applications e g a generic property viewer will display property URIs directly to their users it is expected that the typical application will use a fixed set of properties and will provide a mapping from the property name URI to a human readable field when displaying the property name to a user It is only in the case where the set of properties is not known ahead of time that an application need display a property name URI to a user We recommend that applications provide human readable property names wherever feasible For error reporting we follow the convention of HTTP 1 1 status codes including with each status code a short English description of the code e g 421 Destination Locked While the possibility exists that a poorly crafted user agent would display this message to a user internationalized applications will ignore this message and display an appropriate message in the user s language and character set Since interoperation of clients and servers does not require locale information this specification does not specify any mechanism for transmission of this information 16 Security Considerations TBD 17 Terminology Collection A resource that contains member resources Member Resource A resource contained by a collection There are two types of member resources external and internal Internal Member Resource A member resource of a collection whose URI is relative to the URI of the collection External Member Resource A member resource of a collection with an absolute URI that is not relative to its parent s URI Property A name value pair that contains descriptive information about a resource Live Property A property whose semantics and syntax are enforced by the server For example a live content length property would have its value the length of the entity returned by a GET request automatically calculated by the server Dead Property A property whose semantics and syntax are not enforced by the server The server only records the value of a dead property the client is responsible for maintaining the consistency of the syntax and semantics of a dead property 18 Copyright The following copyright notice is copied from RFC 2 26 chapter 1 4 and describes the applicable copyright for this document Copyright C The Internet Society November 19 1997 All Rights Reserved This document and translations of it may be copied and furnished to others and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared copied published and distributed in whole or in part without restriction of any kind provided that the above copyright notice and this paragraph are included on all such copies and derivative works However this document itself may not be modified in any way such as by removing the copyright notice or references to the Internet Society or other Internet organizations except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed or as required to translate it into languages other than English The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assignees This document and the information contained herein is provided on an AS IS basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 19 Acknowledgements A specification such as this thrives on piercing critical review and withers from apathetic neglect The authors gratefully acknowledge the contributions of the following people whose insights were so valuable at every stage of our work Terry Allen Harald Alvestrand Alan Babich Dylan Barrell Bernard Chester Tim Berners Lee Dan Connolly Jim Cunningham Ron Daniel Jr Jim Davis Keith Dawson Mark Day Martin Duerst David Durand Lee Farrell Chuck Fay Roy Fielding Mark Fisher Alan Freier George Florentine Jim Gettys Phill Hallam Baker Dennis Hamilton Steve Henning Alex Hopmann Andre van der Hoek Ben Laurie Paul Leach Ora Lassila Karen MacArthur Steven Martin Larry Masinter Michael Mealling Keith Moore Henrik Nielsen Kenji Ota Bob Parker Glenn Peterson Jon Radoff Saveen Reddy Henry Sanders Christopher Seiwald Judith Slein Mike Spreitzer Einar Stefferud Ralph Swick Kenji Takahashi Richard N Taylor Robert Thau John Turner Sankar Virdhagriswaran Fabio Vitali Gregory Woodhouse and Lauren Wood One from this list deserves special mention The contributions by Larry Masinter have been invaluable both in helping the formation of the working group and in patiently coaching the authors along the way In so many ways he has set high standards we have toiled to meet 2 References Alvestrand 1997 H T Alvestrand IETF Policy on Character Sets and Languages Internet draft work in progress ftp ds internic net internet drafts draft alvestrand charset policy 2 txt Berners Lee 1997 T Berners Lee Metadata Architecture Unpublished white paper January 1997 http www w3 org pub WWW DesignIssues Metadata html Bradner 1997 S Bradner Key words for use in RFCs to Indicate Requirement Levels RFC 2119 BCP 14 Harvard University March 1997 Bray Sperberg McQueen 1997 T Bray C M Sperberg McQueen Extensible Markup Language XML Part I Syntax WD xml lang html http www w3 org pub WWW TR WD xml lang html Fielding et al 1997 R Fielding J Gettys J Mogul H Frystyk T Berners Lee Hypertext Transfer Protocol HTTP 1 1 RFC 2 68 U C Irvine DEC MIT LCS January 1997 ftp ds internic net rfc rfc2 68 txt Lasher Cohen 1995 R Lasher D Cohen A Format for Bibliographic Records RFC 18 7 Stanford Myricom June 1995 ftp ds internic net rfc rfc18 7 txt Leach Salz 1997 P J Leach R Salz UUIDs and GUIDs Internet draft expired work in progress February 1997 http www internic net internet drafts draft leach uuids guids txt Maloney 1996 M Maloney Hypertext Links in HTML Internet draft expired work in progress January 1996 MARC 1994 Network Development and MARC Standards Office ed 1994 USMARC Format for Bibliographic Data 1994 Washington DC Cataloging Distribution Service Library of Congress Miller et al 1996 J Miller T Krauskopf P Resnick W Treese PICS Label Distribution Label Syntax and Communication Protocols Version 1 1 W3C Recommendation REC PICS labels 961 31 http www w3 org pub WWW TR REC PICS labels 961 31 html Slein et al 1997 J A Slein F Vitali E J Whitehead Jr D Durand Requirements for Distributed Authoring and Versioning Protocol for the World Wide Web RFC XXXX Xerox Univ of Bologna U C Irvine Boston Univ YYY 1997 ftp ds internic net rfc rfcXXXX txt WebDAV 1997 WEBDAV Design Team A Proposal for Web Metadata Operations Unpublished manuscript http www ics uci edu ejw authoring proposals metadata html Weibel et al 1995 S Weibel J Godby E Miller R Daniel OCLC NCSA Metadata Workshop Report http purl oclc org metadata dublin core report Yergeau 1997 F Yergeau UTF 8 a transformation format of Unicode and ISO 1 646 Internet Draft work in progress draft yergeau utf8 rev txt http www internic net internet drafts draft yergeau utf8 rev txt 21 Authors Addresses Y Y Goland Microsoft Corporation One Microsoft Way Redmond WA 98 52 6399 Email yarong microsoft com E J Whitehead Jr Dept Of Information and Computer Science University of California Irvine Irvine CA 92697 3425 Email ejw ics uci edu A Faizi Netscape 685 East Middlefield Road Mountain View CA 94 43 Email asad netscape com S R Carter Novell 1555 N Technology Way M S ORM F111 Orem UT 84 97 2399 Email srcarter novell com D Jensen Novell 1555 N Technology Way M S ORM F111 Orem UT 84 97 2399 Email dcjensen novell com", "_id": "http://www.ics.uci.edu/~ejw/authoring/protocol/draft-ietf-webdav-protocol-05.html", "title": "extensions for distributed authoring and versioning on the world wide web -- webdav", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n<HTML>\n<HEAD>\n<TITLE>Extensions for Distributed Authoring and Versioning on the World Wide Web -- WEBDAV</TITLE>\n</HEAD>\n<BODY>\n<PRE>\nWEBDAV Working Group                            Y.Y. Goland, Microsoft\n\nINTERNET DRAFT                          E.J. Whitehead, Jr., UC Irvine\n&lt;draft-ietf-webdav-protocol-05&gt;                     A. Faizi, Netscape\n                                                   S.R. Carter, Novell\n                                                     D. Jensen, Novell\nExpires April, 1998                                  November 19, 1997\n</PRE>\n<HR>\nThis HTML version was converted from plaintext ASCII to HTML\nby <A HREF=\"\\\"mailto:jdavis@parc.xerox.com\\\"\">Jim Davis</A>\non 22 November 1997.\nMy sincere apologies for any errors introduced in the process.\nWhen in doubt, consult the ASCII version.\n\n<H2>Status of this Memo</H2>\n\n\n<P>This document is an Internet-Draft. Internet-Drafts are working\n   documents of the Internet Engineering Task Force (IETF), its areas,\n   and its working groups. Note that other groups may also distribute\n   working documents as Internet-Drafts.\n\n<P>Internet-Drafts are draft documents valid for a maximum of six\n   months and may be updated, replaced, or made obsolete by other\n   documents at any time. It is inappropriate to use Internet-Drafts as\n   reference material or to cite them other than as \"work in progress\".\n\n<P>To learn the current status of any Internet-Draft, please check the\n   \"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow\n   Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),\n   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or\n   ftp.isi.edu (US West Coast).\n\n<P>Distribution of this document is unlimited. Please send comments to\n   the Distributed Authoring and Versioning (WEBDAV) working group at\n   &lt;w3c-dist-auth@w3.org&gt;, which may be joined by sending a message\n   with subject \"subscribe\" to &lt;w3c-dist-auth-request@w3.org&gt;.\n\n<P>Discussions of the WEBDAV working group are archived at\n   <A HREF=\"http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth\">http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth</A>.\n\n<H2>Abstract</H2>\n\n\n<P>This document specifies a set of methods, headers, and content-types\n   ancillary to HTTP/1.1 for the management of resource properties,\n   creation and management of resource collections, namespace\n   manipulation, resource locking (collision avoidance), and efficient\n   transmission of resource changes.\n\n<h2>Changes</h2>\n\n<h3>1.1. Changes since draft-ietf-webdav-protocol-04.txt</h3>\n\n   [Editor's note: This section will not appear in the final form of\n   this document.  Its purpose is to provide a concise list of changes\n   from the previous revision of the draft for use by reviewers.]\n\n<P>Added this change section.\n\n<P>Removed scoping for namespaces so the namespace for\n   every element is explicitly stated.\n\n<P>Changed the syntax from &lt;?XML:Namespace.../&gt; to &lt;?namespace...?&gt;.\n\n<P>Removed propfindresult, this was left over from the old search\n   format.\n\n<P>Changed all the DAV XML element names to lower case.\n\n<P>Changed the property format to use Name and Namespace rather than\n   name and schema.\n\n<P>Removed proploc attribute and removed section on GETting, DELETEing,\n   and PUTing properties since we do not provide a mechanism for\n   getting a URI for properties.  Also removed the requirement that\n   properties be URI addressable.\n\n<P>Removed quoted string choice from owner header, it is just XML.\n\n<P>Made all the HTTP error codes use the same format.\n\n<P>Changed the name of the create element in <TT>PROPPATCH</TT> to set, the new\n   name seems to cause less confusion.\n\n<P>Moved all headers in the draft to a single section.\n\n<P>Deleted the state token section of the draft and moved the state\n   token headers to the header section of the draft.  Removed the state\n   token header.\n\n<P>Changed the write lock section to state that a Lock-Token request\n   header, not a state-token request header, is to be submitted on\n   request for write locked resources.\n\n<P>Created a \"generic\" XML element section for XML elements that get\n   repeatedly re-used throughout the spec.  I moved LINK XML element to\n   this section.\n\n<P>Made <TT> multistatus</TT> and Schema discovery their own level one sections.\n\n<P>Collected all the properties together.\n\n<P>Removed all references to the possibility of properties have their\n   own URIs.  This includes removing the property identifier section.\n\n<P>Separated the section on web collections and namespaces into two\n   separate sections.\n\n<P>Collected all the new response codes together into their own\n   section.\n\n<P>Changed the XML multiresponse element name to <TT> multistatus</TT>.\n\n<P>Added a stand alone section on levels of DAV compliance. I also went\n   method by method, property by property, to specify compliance\n   requirements.\n\n<P>Added an introduction.\n\n<P>Changed all the \"True\" and \"False\" to \"T\" and \"F\".\n\n<P>Altered the first two paragraphs of the Property Names section to\n   make the relationship between a property's name and its schema a\n   little clearer.  I also added some text in the same section defining\n   a property name as a namespace and element.\n\n<P>Added a second paragraph to property model for http resources -\n   overview.  This paragraph clarifies why XML was chosen.\n\n<P>Added a 409 Conflict error to move to cover attempts to move a\n   collection with members.\n\n<P>Changed the collection requirement to read the collections SHOULD\n   end with \"/\".  Also added a SHOULD about returning a location header\n   if the client submits a URL for a collection without a trailing \"/\".\n\n<P>Moved the owner header into the body due to size concerns.\n\n<P>Replaced the iscollection xml element with <TT>resourcetype</TT>.\n\n<P>Moved the DAV property to the <TT>DAV</TT> header that is returned with\n   <TT>OPTIONS</TT>.\n\n<P>Folded the tree draft into this draft.  Changed the <TT>DELETE</TT>, <TT>COPY</TT>,\n   and <TT>MOVE</TT> sections to include their effect on collections as taken\n   from the tree draft.  Created a <TT>Depth</TT> header section and put in the\n   general rules that were in the introduction to the tree draft.  I\n   also added the 102 response and response-status header.\n\n<P>Removed the versioning section.\n\n<P>Put all the methods into a single section.\n\n<P>Replaced the <TT>PROPFIND</TT> request body with a propfind header. Now the\n   response can be cached just using vary.\n\n<P>Nuked resinfo for <TT>INDEX</TT> and combined it with <TT> multistatus</TT> which is\n   now used for both <TT>INDEX</TT> and <TT>PROPFIND</TT>.  Stripped down <TT>INDEX</TT> as\n   agreed.\n\n<P>Removed the problem definition and proposed solution sections. We\n   can always cut and paste them together from the older version if we\n   feel we need them but this draft is supposed to be a dry run for\n   last call and last call documents do not have problem\n   definition/proposed solution sections.\n\n<P>Killed the section on schema discovery, it is controversial and we\n   aren't going to be able to require it.  We should specify it in a\n   different spec.\n\n<P>Added a section on notational conventions used within the document.\n\n<P>Moved the terminology section to the end of the document to provide\n   better flow from the high-level introduction to the specific\n   introduction sections.\n\n<P>Increased the numeric value of the 4xx status codes introduced in\n   this specification to avoid conflicts with the new revision of the\n   HTTP/1.1 specification, which introduces two new 4xx status codes.\n\n<P>Wrote internationalization concerns section.\n\n<P>Added XML version number to all examples.\n\n<h2>Contents</h2>\n<PRE>\n\nSTATUS OF THIS MEMO...................................................1\nABSTRACT..............................................................1\nCHANGES...............................................................1\n\n1.1. Changes since draft-ietf-webdav-protocol-04.txt..................1\nCONTENTS..............................................................5\n2. INTRODUCTION.......................................................8\n3. DATA MODEL FOR RESOURCE PROPERTIES.................................9\n3.1. The Resource Property Model......................................9\n3.2. Existing Metadata Proposals.....................................10\n3.3. Properties and HTTP Headers.....................................10\n3.4. Property Values.................................................10\n3.5. Property Names..................................................11\n4. COLLECTIONS OF WEB RESOURCES......................................11\n4.1. Collection Resources............................................11\n4.2. Creation and Retrieval of Collection Resources..................12\n4.3. HTTP URL Namespace Model........................................13\n4.4. Source Resources and Output Resources...........................13\n5. LOCKING...........................................................14\n5.1. Exclusive Vs. Shared Locks......................................14\n5.2. Required Support................................................15\n5.3. Lock Tokens.....................................................16\n5.4. opaquelocktoken Lock Token URI Scheme...........................16\n5.5. Lock Capability Discovery.......................................16\n5.6. Active Lock Discovery...........................................17\n6. WRITE LOCK........................................................17\n6.1. Methods Restricted by Write Locks...............................17\n6.2. Write Locks and Properties......................................17\n6.3. Write Locks and Null Resources..................................17\n6.4. Write Locks and Collections.....................................18\n6.5. Write Locks and COPY/MOVE.......................................18\n6.6. Re-issuing Write Locks..........................................18\n6.7. Write Locks and The Lock-Token Request Header...................18\n7. NOTATIONAL CONVENTIONS............................................19\n8. HTTP METHODS FOR DISTRIBUTED AUTHORING............................19\n8.1. PROPFIND........................................................19\n8.2. PROPPATCH.......................................................23\n8.3. MKCOL Method....................................................25\n8.4. INDEX Method....................................................26\n8.5. DELREF Method...................................................28\n8.6. ADDREF Method...................................................28\n8.7. GET, HEAD for Collections.......................................29\n8.8. POST for Collections............................................29\n8.9. DELETE..........................................................29\n8.10. PUT............................................................31\n8.11. COPY Method....................................................31\n8.12. MOVE Method....................................................35\n8.13. LOCK Method....................................................38\n8.14. UNLOCK Method..................................................42\n8.15. PATCH Method...................................................43\n9. DAV HEADERS.......................................................47\n9.1. Collection-Member Header........................................47\n9.2. DAV Header......................................................47\n9.3. Depth Header....................................................47\n9.4. Destination Header..............................................48\n9.5. Destroy Header..................................................48\n9.6. Enforce-Live-Properties Header..................................49\n9.7. If-None-State-Match.............................................49\n9.8. If-State-Match..................................................50\n9.9. Lock-Info Request Header........................................50\n9.10. Lock-Token Request Header......................................51\n9.11. Lock-Token Response Header.....................................51\n9.12. Overwrite Header...............................................52\n9.13. Propfind Request Header........................................52\n9.14. Status-URI Response Header.....................................52\n9.15. Timeout Header.................................................52\n10. RESPONSE CODE EXTENSIONS TO RFC 2068.............................54\n10.1. 102 Processing.................................................54\n10.2. 207 Multi-Status...............................................54\n10.3. 418 Unprocessable Entity.......................................54\n10.4. 419 Insufficient Space on Resource.............................54\n10.5. 420 Method Failure.............................................54\n11. MULTI-STATUS RESPONSE............................................54\n11.1. multistatus XML Element........................................55\n11.2. response XML Element...........................................55\n11.3. status XML Element.............................................55\n11.4. responsedescription XML Element................................55\n12. GENERIC DAV XML ELEMENTS.........................................55\n12.1. href XML Element...............................................56\n12.2. link XML Element...............................................56\n12.3. prop XML element...............................................57\n13. DAV PROPERTIES...................................................57\n13.1. creationdate Property..........................................57\n13.2. displayname Property...........................................57\n13.3. get-content-language Property..................................58\n13.4. get-content-length Property....................................58\n13.5. get-content-type Property......................................58\n13.6. get-etag Property..............................................58\n13.7. get-last-modified Property.....................................59\n13.8. index-content-language Property................................59\n13.9. index-content-length Property..................................59\n13.10. index-content-type Property...................................59\n13.11. index-etag Property...........................................59\n13.12. index-last-modified Property..................................60\n13.13. lockdiscovery Property........................................60\n13.14. resourcetype Property.........................................62\n13.15. Source Link Property Type.....................................62\n13.16. supportedlock Property........................................63\n14. DAV COMPLIANCE LEVELS............................................64\n14.1. Level 1........................................................64\n14.2. Level 2........................................................64\n15. INTERNATIONALIZATION SUPPORT.....................................65\n16. SECURITY CONSIDERATIONS..........................................66\n17. TERMINOLOGY......................................................66\n18. COPYRIGHT........................................................66\n19. ACKNOWLEDGEMENTS.................................................67\n20. REFERENCES.......................................................69\n21. AUTHORS' ADDRESSES...............................................71\n</PRE>\n<h2>2. Introduction</h2>\n\n<P>This document describes an extension to the HTTP/1.1 protocol that\n   allows clients to perform remote web content authoring operations.\n   This extension provides a coherent set of methods, headers, request\n   entity body formats, and response entity body formats that provide\n   operations for:\n\n<P>Properties: The ability to create, remove, and query information\n   about Web pages, such as its author, creation date, etc. Also, the\n   ability to link pages of any media type to related pages.\n\n<P>Collections: The ability to create sets of related documents, and to\n   receive a listing of pages at a particular hierarchy level (like a\n   directory listing in a file system).\n\n<P>Locking: The ability to keep more than one person from working on a\n   document at the same time. This prevents the \"lost update problem\"\n   in which modifications are lost as first one author, then another\n   writes their changes without merging the other author's changes\n\n<P>Namespace Operations: The ability to copy and move Web resources\n\n<P>Efficient Update: The ability to send changes which are proportional\n   to the size of the change rather than retransmitting the entire\n   resource.\n\n<P>Requirements and rationale for these operations are described in a\n   companion document, \"Requirements for a Distributed Authoring and\n   Versioning Protocol for the World Wide Web\" [Slein et al., 1997].\n\n<P>The sections below provide a detailed introduction to resource\n   properties (Section 3), collections of resources (Section 4), and\n   locking operations (Section 5).  These sections introduce the\n   abstractions manipulated by the WebDAV-specific HTTP methods\n   described in Section 8, \"HTTP Methods for Distributed Authoring\".\n\n<P>In HTTP/1.1, method parameter information was exclusively encoded in\n   HTTP headers. Unlike HTTP/1.1, WebDAV, encodes method parameter\n   information either in an Extensible Markup Language (XML) [Bray,\n   Sperberg-McQueen, 1997] request entity body, or in an HTTP header.\n   The use of XML to encode method parameters was motivated by the\n   ability to add extra XML elements to existing structures, providing\n   extensibility, and by XML's ability to encode information in ISO\n   10646 character sets, providing internationalization support. As a\n   rule of thumb, parameters are encoded in XML entity bodies when they\n   have unbounded length, or when they may be shown to a human user and\n   hence require encoding in an ISO 10646 character set.  Otherwise,\n   parameters are encoded within an HTTP header.  Section 9 describes\n   the new HTTP headers used with WebDAV methods.\n\n<P>In addition to encoding method parameters, XML is used in WebDAV to\n   encode the responses from methods, providing the extensibility and\n   internationalization advantages of XML for method output, as well as\n   input. XML elements used in this specification are defined in\n   Section 12.\n\n<P>While the response codes provided by HTTP/1.1 are sufficient to\n   describe the preponderance of error conditions encountered by WebDAV\n   methods, there are some errors that do not fall neatly into the\n   existing categories.  New status codes developed for the WebDAV\n   methods are defined in Section 10.  Since some WebDAV methods may\n   operate over many resources, the multiresponse status type has been\n   introduced to return status information for multiple resources.\n   Multiresponse status is described in Section 11.\n\n<P>The properties mechanism is employed by WebDAV to store information\n   about the current state of the resource.  For example, when a lock\n   is taken out on a resource, a lock information property describes\n   the current state of the lock. Section 13 defines the properties\n   used within the WebDAV specification.\n\n<P>Finishing off the specification are sections on what it means to be\n   compliant with this specification (Section 14), on\n   internationalization support (Section 15), and on security (Section\n   16).\n\n\n<h2>3. Data Model for Resource Properties</h2>\n\n<h3>3.1. The Resource Property Model</h3>\n\n<P>Properties are pieces of data that describe the state of a resource.\n   Properties are data about data.\n\n<P>Properties are used in distributed authoring environments to provide\n   for efficient discovery and management of resources.  For example, a\n   'subject' property might allow for the indexing of all resources by\n   their subject, and an 'author' property might allow for the\n   discovery of what authors have written which documents.\n\n<P>The DAV property model consists of name/value pairs.  The name of a\n   property identifies the property's syntax and semantics, and\n   provides an address by which to refer to that syntax and semantics.\n\n<P>There are two categories of properties: \"live\" and \"non-live\".  A\n   live property has its syntax and semantics enforced by the server.\n   This represents the two cases of a) the value of a property is read-only, maintained by the server, and b) the value of the property is\n   maintained by the client, but server performs syntax checking on\n   submitted values. A non-live property has its syntax and semantics\n   enforced by the client; the server merely records the value of the\n   property verbatim.\n\n<h3>3.2. Existing Metadata Proposals</h3>\n\n<P>Properties have long played an essential role in the maintenance of\n   large document repositories, and many current proposals contain some\n   notion of a property, or discuss web metadata more generally.  These\n   include PICS [Miller et al., 1996], PICS-NG, the Rel/Rev draft\n   [Maloney, 1996], Web Collections, XML [Bray, Sperberg-McQueen,\n   1997], several proposals on representing relationships within HTML,\n   digital signature manifests (DCMF), and a position paper on Web\n   metadata architecture [Berners-Lee, 1997].  Work on PICS-NG and Web\n   Collections has been subsumed by the Resource Definition Framework\n   (RDF) metadata activity of the World Wide Web Consortium, which\n   consists of a network-based data model and an XML representation of\n   that model.\n\n<P>Some proposals come from a digital library perspective.  These\n   include the Dublin Core [Weibel et al., 1995] metadata set and the\n   Warwick Framework [Lagoze, 1996], a container architecture for\n   different metadata schemas.  The literature includes many examples\n   of metadata, including MARC [MARC, 1994], a bibliographic metadata\n   format, and RFC 1807 [Lasher, Cohen, 1995], a technical report\n   bibliographic format employed by the Dienst system. Additionally,\n   the proceedings from the first IEEE Metadata conference describe\n   many community-specific metadata sets.\n\n<P>Participants of the 1996 Metadata II Workshop in Warwick, UK\n   [Lagoze, 1996], noted that, \"new metadata sets will develop as the\n   networked infrastructure matures\" and \"different communities will\n   propose, design, and be responsible for different types of\n   metadata.\" These observations can be corroborated by noting that\n   many community-specific sets of metadata already exist, and there is\n   significant motivation for the development of new forms of metadata\n   as many communities increasingly make their data available in\n   digital form, requiring a metadata format to assist data location\n   and cataloging.\n\n<h3>3.3. Properties and HTTP Headers</h3>\n\n<P>Properties already exist, in a limited sense, in HTTP message\n   headers.  However, in distributed authoring environments a\n   relatively large number of properties are needed to describe the\n   state of a resource, and setting/returning them all through HTTP\n   headers is inefficient.  Thus a mechanism is needed which allows a\n   principal to identify a set of properties in which the principal is\n   interested and to then set or retrieve just those properties.\n\n<h3>3.4. Property Values</h3>\n\n<P>The value of a property is expressed as a well-formed XML document.\n\n<P>XML has been chosen because it is a flexible, self-describing,\n   structured data format that supports rich schema definitions, and\n   because of its support for multiple character sets.  XML's self-describing nature allows any property's value to be extended by\n   adding new elements.  Older clients will not break because they will\n   still have the data specified in the original schema and will ignore\n   elements they do not understand.  XML's support for multiple\n   character sets allows human-readable properties to be encoded and\n   read in a character set familiar to the user.\n\n<h3>3.5. Property Names</h3>\n\n<P>A property name is a universally unique identifier that is\n   associated with a schema that provides information about the syntax\n   and semantics of the property.\n\n<P>Because a property's name is universally unique, clients can depend\n   upon consistent behavior for a particular property across multiple\n   resources, so long as that property is \"live\" on the resources in\n   question.\n\n<P>The XML namespace mechanism, which is based on URIs, is used to name\n   properties because it provides a mechanism to prevent namespace\n   collisions and for varying degrees of administrative control.\n\n<P>The property namespace is flat; that is, no hierarchy of properties\n   is explicitly recognized.  Thus, if a property A and a property A/B\n   exist on a resource, there is no recognition of any relationship\n   between the two properties.  It is expected that a separate\n   specification will eventually be produced which will address issues\n   relating to hierarchical properties.\n\n<P>Finally, it is not possible to define the same property twice on a\n   single resource, as this would cause a collision in the resource's\n   property namespace.\n\n\n<h2>4. Collections of Web Resources</h2>\n\n<P>This section provides a description of a new type of Web resource,\n   the collection, and discusses its interactions with the HTTP URL\n   namespace. The purpose of a collection resource is to model\n   collection-like objects (e.g., filesystem directories) within a\n   server's namespace.\n\n<P>All DAV compliant resources MUST support the HTTP URL namespace\n   model specified herein.\n\n<h3>4.1. Collection Resources</h3>\n\n<P>A collection is a resource whose state consists of an unordered list\n   of internal members, an unordered list of external members, and a\n   set of properties.  An internal member resource MUST have a URI that\n   is immediately relative to the base URI of the collection, that is,\n   a relative URI in which \"../\" is illegal, which MUST begin with \"./\"\n   and which SHOULD contain a \"/\" at the end of the URI if the internal\n   member resource is itself a collection.\n\n<P>An external member resource MUST be an absolute URI that is not an\n   internal URI.  Any given internal or external URI MUST only belong\n   to the collection once, i.e., it is illegal to have multiple\n   instances of the same URI in a collection.  Properties defined on\n   collections behave exactly as do properties on non-collection\n   resources.\n\n<P>There is a standing convention that when a collection is referred to\n   by its name without a trailing slash, the trailing slash is\n   automatically appended.  Due to this, a resource MAY accept a URI\n   without a trailing \"/\" to point to a collection. In this case it\n   SHOULD return a location header in the response pointing to the URL\n   ending with the \"/\".  For example, if a client performs an <TT>INDEX</TT> on\n   http://foo.bar/blah (no trailing slash), the resource\n   http://foo.bar/blah/ (trailing slash) MAY respond as if the\n   operation were invoked on it, and SHOULD return a location header\n   with http://foo.bar/blah/ in it.\n\n\n<h3>4.2. Creation and Retrieval of Collection Resources</h3>\n\n<P>This document specifies the <TT>MKCOL</TT> method to create new collection\n   resources, rather than using the existing HTTP/1.1 <TT>PUT</TT> or <TT>POST</TT>\n   method, for the following reasons\n\n<P>In HTTP/1.1, the <TT>PUT</TT> method is defined to store the request body at\n   the location specified by the Request-URI.  While a description\n   format for a collection can readily be constructed for use with <TT>PUT</TT>,\n   the implications of sending such a description to the server are\n   undesirable.  For example, if a description of a collection that\n   omitted some existing resources were <TT>PUT</TT> to a server, this might be\n   interpreted as a command to remove those members.  This would extend\n   <TT>PUT</TT> to perform <TT>DELETE</TT> functionality, which is undesirable since it\n   changes the semantics of <TT>PUT</TT>, and makes it difficult to control\n   <TT>DELETE</TT> functionality with an access control scheme based on methods.\n\n<P>While the <TT>POST</TT> method is sufficiently open-ended that a \"create a\n   collection\" <TT>POST</TT> command could be constructed, this is undesirable\n   because it would be difficult to separate access control for\n   collection creation from other uses of <TT>POST</TT>.\n\n<P>This document specifies the <TT>INDEX</TT> method for listing the contents of\n   a collection, rather than relying on the existing HTTP/1.1 <TT>GET</TT>\n   method.  This is to avoid conflict with the de-facto standard\n   practice of redirecting a <TT>GET</TT> request on a directory to its\n   index.html resource.\n\n<P>The exact definition of the behavior of <TT>GET</TT> and <TT>PUT</TT> on collections\n   is defined later in this document.\n\n<h3>4.3. HTTP URL Namespace Model</h3>\n\n<P>The HTTP URL Namespace is a hierarchical namespace where the\n   hierarchy is delimited with the \"/\" character.  DAV compliant\n   resources MUST maintain the consistency of the HTTP URL namespace.\n   Any attempt to create a resource (excepting the root member of a\n   namespace) that would not be the internal member of a collection\n   MUST fail. For example, if the collection http://www.foo.bar.org/a/\n   exists, but http://www.foo.bar.org/a/b/does not exist, an attempt to\n   create http://www.foo.bar.org/a/b/c must fail.\n\n<h3>4.4. Source Resources and Output Resources</h3>\n\n<P>For many resources, the entity returned by a <TT>GET</TT> method exactly\n   matches the persistent state of the resource, for example, a GIF\n   file stored on a disk.  For this simple case, the URL at which a\n   resource is accessed is identical to the URL at which the source\n   (the persistent state) of the resource is accessed.  This is also\n   the case for HTML source files that are not processed by the server\n   prior to transmission.\n\n<P>However, the server can sometimes process HTML resources before they\n   are transmitted as a return entity body.  For example, server-side-include directives within an HTML file instruct a server to replace\n   the directive with another value, such as the current date.  In this\n   case, what is returned by <TT>GET</TT> (HTML plus date) differs from the\n   persistent state of the resource (HTML plus directive).  Typically\n   there is no way to access the HTML resource containing the\n   unprocessed directive.\n\n<P>Sometimes the entity returned by <TT>GET</TT> is the output of a data-producing process that is described by one or more source resources\n   (that may not even have a location in the URL namespace).  A single\n   data-producing process may dynamically generate the state of a\n   potentially large number of output resources.  An example of this is\n   a CGI script that describes a \"finger\" gateway process that maps\n   part of the namespace of a server into finger requests, such as\n   http://www.foo.bar.org/finger_gateway/user@host.\n\n<P>In the absence of distributed authoring capabilities, it is\n   acceptable to have no mapping of source resource(s) to the URI\n   namespace. In fact, preventing access to the source resource(s) has\n   desirable security benefits.  However, if remote editing of the\n   source resource(s) is desired, the source resource(s) should be\n   given a location in the URI namespace.  This source location should\n   not be one of the locations at which the generated output is\n   retrievable, since in general it is impossible for the server to\n   differentiate requests for source resources from requests for\n   process output resources.  There is often a many-to-many\n   relationship between source resources and output resources.\n\n<P>On WebDAV compliant servers, for all output resources which have a\n   single source resource (and that source resource has a URI), the URI\n   of the source resource SHOULD be stored in a link on the output\n   resource with type http://www.ietf.org/standards/dav/source.  Note\n   that by storing the source URIs in links on the output resources,\n   the burden of discovering the source is placed on the authoring\n   client.\n\n\n<h2>5. Locking</h2>\n\n<P>The ability to lock a resource provides a mechanism for serializing\n   access to that resource.  Using a lock, an authoring client can\n   provide a reasonable guarantee that another principal will not\n   modify a resource while it is being edited.  In this way, a client\n   can prevent the \"lost update\" problem.\n\n<P>This specification allows locks to vary over two client-specified\n   parameters, the number of principals involved (exclusive vs. shared)\n   and the type of access to be granted.  Furthermore, this document\n   only provides the definition of locking for one lock access type,\n   the write lock.  However, the syntax is extensible, and permits the\n   eventual specification of other access types.\n\n<h3>5.1. Exclusive Vs. Shared Locks</h3>\n\n<P>The most basic form of lock is an exclusive lock.  This is a lock\n   where the access right in question is only granted to a single\n   principal.  The need for this arbitration results from a desire to\n   avoid having to constantly merge results.\n\n<P>However, there are times when the goal of a lock is not to exclude\n   others from exercising an access right but rather to provide a\n   mechanism for principals to indicate that they intend to exercise\n   their access right.  Shared locks are provided for this case.  A\n   shared lock allows multiple principals to receive a lock.  Hence any\n   principal with appropriate access can get the lock.\n\n<P>With shared locks there are two trust sets that affect a resource.\n   The first trust set is created by access permissions.  Principals\n   who are trusted, for example, may have permission to write the\n   resource.  Those who are not, don't.  Among those who have access\n   permission to write the resource, the set of principals who have\n   taken out a shared lock also must trust each other, creating a\n   (typically) smaller trust set within the access permission write\n   set.\n\n<P>Starting with every possible principal on the Internet, in most\n   situations the vast majority of these principals will not have write\n   access to a given resource.  Of the small number who do have write\n   access, some principals may decide to guarantee their edits are free\n   from overwrite conflicts by using exclusive write locks.  Others may\n   decide they trust their collaborators will not overwrite their work\n   (the potential set of collaborators being the set of principals who\n   have write permission) and use a shared lock, which informs their\n   collaborators that a principal is potentially working on the\n   resource.\n\n<P>The WebDAV extensions to HTTP do not need to provide all of the\n   communications paths necessary for principals to coordinate their\n   activities.  When using shared locks, principals may use any out of\n   band communication channel to coordinate their work (e.g., face-to-face interaction, written notes, post-it notes on the screen,\n   telephone conversation, Email, etc.)  The intent of a shared lock is\n   to let collaborators know who else is potentially working on a\n   resource.\n\n<P>Shared locks are included because experience from web distributed\n   authoring systems has indicated that exclusive write locks are often\n   too rigid.  An exclusive write lock is used to enforce a particular\n   editing process: take out exclusive write lock, read the resource,\n   perform edits, write the resource, release the lock.  This editing\n   process has the problem that locks are not always properly released,\n   for example when a program crashes, or when a lock owner leaves\n   without unlocking a resource.  While both timeouts and\n   administrative action can be used to remove an offending lock,\n   neither mechanism may be available when needed; the timeout may be\n   long or the administrator may not be available.\n\n<P>Despite their potential problems, exclusive write locks are\n   extremely useful, since often a guarantee of freedom from overwrite\n   conflicts is what is needed. This specification provides both\n   exclusive write locks and the less strict mechanism of shared locks.\n\n<h3>5.2. Required Support</h3>\n\n<P>A WebDAV compliant server is not required to support locking in any\n   form.  If the server does support locking it MAY choose to support\n   any combination of exclusive and shared locks for any access types.\n\n<P>The reason for this flexibility is that locking policy strikes to\n   the very heart of the resource management and versioning systems\n   employed by various storage repositories.  These repositories\n   require control over what sort of locking will be made available.\n   For example, some repositories only support shared write locks while\n   others only provide support for exclusive write locks while yet\n   others use no locking at all.  As each system is sufficiently\n   different to merit exclusion of certain locking features, this\n   specification leaves locking as the sole axis of negotiation within\n   WebDAV.\n\n<h3>5.3. Lock Tokens</h3>\n\n<P>A lock token is a URI that identifies a particular lock.  A lock\n   token is returned by every successful <TT>LOCK</TT> operation in the lock-token response header, and can also be discovered through lock\n   discovery on a resource.\n\n<P>Lock token URIs are required to be unique across all resources for\n   all time. This uniqueness constraint allows lock tokens to be\n   submitted across resources and servers without fear of confusion.\n\n<P>This specification provides a lock token URI scheme called\n   opaquelocktoken that meets the uniqueness requirements.  However\n   resources are free to return any URI scheme so long as it meets the\n   uniqueness requirements.\n\n<h3>5.4. opaquelocktoken Lock Token URI Scheme</h3>\n\n<P>The opaquelocktoken URI scheme is designed to be unique across all\n   resources for all time.  Due to this uniqueness quality, a client\n   MAY submit an opaque lock token in a Lock-Token request header and\n   an if-state[-not]-match header on a resource other than the one that\n   returned it.\n\n<P>All resources MUST recognize the opaquelocktoken scheme and, at\n   minimum, recognize that the lock token was not generated by the\n   resource.  Note, however, that resources are not required to\n   generate opaquelocktokens in <TT>LOCK</TT> method responses.\n\n<P>In order to guarantee uniqueness across all resources for all time\n   the opaquelocktoken requires the use of the GUID mechanism.\n\n<P>Opaquelocktoken generators, however, have a choice of how they\n   create these tokens.  They can either generate a new GUID for every\n   lock token they create, which is potentially very expensive, or they\n   can create a single GUID and then add extension characters.  If the\n   second method is selected then the program generating the extensions\n   MUST guarantee that the same extension will never be used twice with\n   the associated GUID.\n\n<PRE>   Opaque-Lock-Token = \"opaquelocktoken\" \":\" GUID [Extension]\n   GUID = ; As defined in [Leach, Salz, 1997]\n   Extension = *urlc   ;urlc is defined in [Berners-Lee et al., 1997]\n   (draft-fielding-url-syntax-07.txt)\n</PRE>\n\n<h3>5.5. Lock Capability Discovery</h3>\n\n<P>Since server lock support is optional, a client trying to lock a\n   resource on a server can either try the lock and hope for the best,\n   or perform some form of discovery to determine what lock\n   capabilities the server supports.  This is known as lock capability\n   discovery.  Lock capability discovery differs from discovery of\n   supported access control types, since there may be access control\n   types without corresponding lock types.  A client can determine what\n   lock types the server supports by retrieving the supportedlock\n   property.\n\n<P>Any DAV compliant resource that supports the <TT>LOCK</TT> method MUST\n   support the supportedlock property.\n\n<h3>5.6. Active Lock Discovery</h3>\n\n<P>If another principal locks a resource that a principal wishes to\n   access, it is useful for the second principal to be able to find out\n   who the first principal is.  For this purpose the lockdiscovery\n   property is provided.  This property lists all outstanding locks,\n   describes their type, and provides their lock token.\n\n<P>Any DAV compliant resource that supports the <TT>LOCK</TT> method MUST\n   support the lockdiscovery property.\n\n\n<h2>6. Write Lock</h2>\n\n<P>This section describes the semantics specific to the write access\n   type for locks.  The write lock is a specific instance of a lock\n   type, and is the only lock type described in this specification.  A\n   DAV compliant resource MAY support the write lock.\n\n<h3>6.1. Methods Restricted by Write Locks</h3>\n\n<P>A write lock prevents a principal without the lock from successfully\n   executing a <TT>PUT</TT>, <TT>POST</TT>, <TT>PATCH</TT>, <TT>PROPPATCH</TT>, <TT>MOVE</TT>, <TT>DELETE</TT>, <TT>MKCOL</TT>, <TT>ADDREF</TT>\n   or <TT>DELREF</TT> on the locked resource.  All other current methods, <TT>GET</TT> in\n   particular, function independent of the lock.\n\n<P>Note, however, that as new methods are created it will be necessary\n   to specify how they interact with a write lock.\n\n<h3>6.2. Write Locks and Properties</h3>\n\n<P>While those without a write lock may not alter a property on a\n   resource it is still possible for the values of live properties to\n   change, even while locked, due to the requirements of their schemas.\n   Only dead properties and live properties defined to respect locks\n   are guaranteed not to change while write locked.\n\n<h3>6.3. Write Locks and Null Resources</h3>\n\n<P>It is possible to assert a write lock on a null resource in order to\n   lock the name.  Please note, however, that locking a null resource\n   effectively makes the resource non-null, as the resource now has\n   lock related properties defined on it.\n\n<h3>6.4. Write Locks and Collections</h3>\n\n<P>A write lock on a collection prevents the addition or removal of\n   members of the collection.  As a consequence, when a principal\n   issues a request to create a new internal member of a collection\n   using <TT>PUT</TT> or <TT>POST</TT>, or to remove an existing internal member of a\n   collection using <TT>DELETE</TT>, this request MUST fail if the principal\n   does not have a write lock on the collection.\n\n<P>However, if a write lock request is issued to a collection\n   containing internal member resources that are currently locked in a\n   manner which conflicts with the write lock, the request MUST fail\n   with a 409 Conflict status code.\n\n<h3>6.5. Write Locks and <TT>COPY</TT>/<TT>MOVE</TT></h3>\n\n<P>The owner of a write lock MUST NOT execute a <TT>MOVE</TT> method on a\n   resource he has locked.  This specification intentionally does not\n   define what happens if a <TT>MOVE</TT> method request is made on a locked\n   resource by the lock's owner.\n\n<P>A <TT>COPY</TT> method invocation MUST NOT duplicate any write locks active\n   on the source.\n\n<h3>6.6. Re-issuing Write Locks</h3>\n\n<P>If a principal already owns a write lock on a resource, any future\n   requests for the same type of write lock, on the same resource,\n   while the principal's previous write lock is in effect, MUST result\n   in a successful response with the same lock token as provided for\n   the currently existing lock.  Two lock requests are defined to be\n   identical if their <TT>Lock-Info</TT> headers are identical.\n\n<h3>6.7. Write Locks and The Lock-Token Request Header</h3>\n\n<P>If a user agent is not required to have knowledge about a lock when\n   requesting an operation on a locked resource, the following scenario\n   might occur.  Program A, run by User A, takes out a write lock on a\n   resource.  Program B, also run by User A, has no knowledge of the\n   lock taken out by Program A, yet performs a <TT>PUT</TT> to the locked\n   resource.  In this scenario, the <TT>PUT</TT> succeeds because locks are\n   associated with a principal, not a program, and thus program B,\n   because it is acting with principal A's credential, is allowed to\n   perform the <TT>PUT</TT>.  However, had program B known about the lock, it\n   would not have overwritten the resource, preferring instead to\n   present a dialog box describing the conflict to the user.  Due to\n   this scenario, a mechanism is needed to prevent different programs\n   from accidentally ignoring locks taken out by other programs with\n   the same authorization.\n\n<P>In order to prevent these collisions the lock token request header\n   is introduced.  Please refer to the Lock Token Request Header\n   section for details and requirements.\n\n<h4>6.7.1. Write Lock Token Example</h4>\n\n<PRE>\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n   Lock-Token: &lt;opaquelocktoken:123AbcEfg1284h23h2&gt;\n   &lt;opaquelocktoken:AAAASDFcalkjfdas12312&gt;\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 200 OK\n</PRE>\n\n\n<P>In this example, both the source and destination are locked so two\n   lock tokens must be submitted.  If only one of the two resources was\n   locked, then only one token would have to be submitted.\n\n\n<h2>7. Notational Conventions</h2>\n\n<P>Since this document describes a set of extensions to the HTTP/1.1\n   protocol, the augmented BNF used herein to describe protocol\n   elements is exactly the same as described in Section 2.1 of RFC\n   2068, <I>Hypertext Transfer Protocol -- HTTP/1.1</I> [Fielding et al.,\n   1997].  Since this augmented BNF uses the basic production rules\n   provided in Section 2.2 of RFC 2068, these rules apply to this\n   document as well.\n\n<P>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [Bradner,\n   1997].\n\n\n<h2>8. HTTP Methods for Distributed Authoring</h2>\n\n<H3>8.1. <TT>PROPFIND</TT></H3>\n\n<P>The <TT>PROPFIND</TT> method retrieves properties defined on the Request-URI,\n   if it is a non-collection resource, or on the Request-URI and\n   potentially its member resources, if the resource is a collection.\n   All DAV compliant resources MUST support the <TT>PROPFIND</TT> method.\n\n<P>A client MAY submit a <TT>Depth</TT> header with a <TT>PROPFIND</TT> on a collection\n   with a value of \"0\", \"1\" or \"infinity\".  DAV compliant servers MUST\n   support the \"0\", \"1\" and \"infinity\" behaviors. By default, the\n   <TT>PROPFIND</TT> method on a collection without a <TT>Depth</TT> header MUST act as\n   if a Depth = infinity header was included.\n\n<P>A client MUST submit a Propfind request header describing what\n   information is being requested.  It is possible to request\n   particular property values, all property values, or a list of the\n   names of the resource's properties.\n\n<P>The response is a text/xml message body that contains a <TT> multistatus</TT>\n   XML element that describes the results of the attempts to retrieve\n   the various properties.  If a property was successfully retrieved\n   then its value MUST be returned in a prop XML element.  If the scope\n   of <TT>PROPFIND</TT> covers more than a single resource, as is the case with\n   Depth values of \"1\" and \"infinity\", each response XML element MUST\n   contain an <TT>href</TT> XML element which identifies the resource on which\n   the properties in the prop XML element are defined. In the case of\n   allprop and propname, if a principal does not have the right to know\n   if a particular property exists, an error MUST NOT be returned.  The\n   results of this method SHOULD NOT be cached.\n\n<h4>8.1.1. Example: Retrieving Named Properties</h4>\n\n<PRE>\n   PROPFIND  /files/ HTTP/1.1\n   Host: www.foo.bar\n   Depth: 0\n   Propfind: &lt;http://www.foo.bar/boxschema/bigbox&gt; &lt;http://www.foo.bar/\n   boxschema/author&gt; &lt;http://www.foo.bar/boxschema/DingALing&gt; &lt;http://w\n   ww.foo.bar/boxschema/Random&gt;\n</PRE>\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;?namespace href = \"http://www.foo.bar/boxschema\" AS = R\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:prop&gt;\n               &lt;R:bigbox&gt;\n                    &lt;R:BoxType&gt;Box type A&lt;/R:BoxType&gt;\n               &lt;/R:bigbox&gt;\n               &lt;R:author&gt;\n                    &lt;R:Name&gt;J.J. Dingleheimerschmidt&lt;/R:Name&gt;\n               &lt;/R:author&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n     &lt;D:response&gt;\n          &lt;D:prop&gt;&lt;R:DingALing/&gt;&lt;R:Random/&gt;&lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP/1.1 403 Forbidden&lt;/D:status&gt;\n          &lt;D:responsedescription&gt; The user does not have access to the\n   DingALing property.\n          &lt;/D:responsedescription&gt;\n     &lt;/D:response&gt;\n\n     &lt;D:responsedescription&gt; There has been an access violation error.\n     &lt;/D:responsedescription&gt;\n     &lt;/D:multistatus&gt;\n</PRE>\n\n<P>In this example, <TT>PROPFIND</TT> is executed on the collection\n   http://www.foo.bar/files/.  The specified depth is zero, hence the\n   <TT>PROPFIND</TT> applies only to the collection itself, and not to any of\n   its members.  The <TT>Propfind</TT> header specifies the name of four\n   properties whose values are being requested. In this case only two\n   properties were returned, since the principal issuing the request\n   did not have sufficient access rights to see the third and fourth\n   properties.\n\n<h4>8.1.2. Example: Using allprop to Retrieve All Properties</h4>\n\n<PRE>\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Depth: 1\n   Propfind: allprop\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 200 OK\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"S\"?&gt;\n   &lt;?namespace href = \"http://www.foo.bar/boxschema/\" AS = R\"?&gt;\n   &lt;S:multistatus&gt;\n     &lt;S:response&gt;\n          &lt;S:href&gt;http://www.foo.bar/container/&lt;/S:href&gt;\n          &lt;S:prop&gt;\n               &lt;R:bigbox&gt;\n                    &lt;R:BoxType&gt;Box type A&lt;/R:BoxType&gt;\n               &lt;/R:bigbox&gt;\n               &lt;R:author&gt;\n                    &lt;R:Name&gt;Hadrian&lt;/R:Name&gt;\n               &lt;/R:author&gt;\n          &lt;/S:prop&gt;\n          &lt;S:status&gt;HTTP 1.1 200 OK&lt;/S:status&gt;\n     &lt;/S:response&gt;\n     &lt;S:response&gt;\n          &lt;S:href&gt;http://www.foo.bar/container/index.html&lt;/S:href&gt;\n          &lt;S:prop&gt;\n               &lt;R:bigbox&gt;\n                    &lt;R:BoxType&gt;Box type B&lt;/R:BoxType&gt;\n               &lt;/R:bigbox&gt;\n          &lt;/S:prop&gt;\n          &lt;S:status&gt;HTTP 1.1 200 OK&lt;/S:status&gt;\n     &lt;/S:response&gt;\n   &lt;/S:multistatus&gt;\n</PRE>\n\n<P>In this example, <TT>PROPFIND</TT> was invoked on the resource\n   http://www.foo.bar/container/ with a <TT>Depth</TT> header of 1, meaning the\n   request applies to the resource and its children, and a Propfind\n   header of \"allprop\", meaning the request should return the name and\n   value of all properties defined on each resource.\n\n<P>The resource http://www.foo.bar/container/ has two properties\n   defined on it, named http://www.foo.bar/boxschema/bigbox, and\n   http://www.foo.bar/boxschema/author, while resource\n   http://www.foo.bar/container/index.html has only a single resource\n   defined on it, named http://www.foo.bar/boxschema/bigbox, another\n   instance of the \"bigbox\" property type.\n\n<h4>8.1.3. Example: Using propname to Retrieve all Property Names</h4>\n\n<PRE>\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Propfind: propname\n</PRE>\n<PRE>\n\n   HTTP/1.1 200 OK\n   Content-Type: text/xml\n   Content-Length: xxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?&gt;\n   &lt;?namespace href = \"http://www.foo.bar/boxschema/\" AS = \"R\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:href&gt;http://www.foo.bar/container/&lt;/D:href&gt;\n          &lt;D:prop&gt;\n               &lt;R:bigbox/&gt;\n               &lt;R:author/&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP 1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n     &lt;D:response&gt;\n          &lt;D:href&gt;http://www.foo.bar/container/index.html&lt;/D:href&gt;\n          &lt;D:prop&gt;\n               &lt;R:bigbox/&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP 1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n   &lt;/D:multistatus&gt;\n</PRE>\n\n\n<P>In this example, <TT>PROPFIND</TT> is invoked on the collection resource\n   http://www.foo.bar/container/, with a <TT>Propfind</TT> header set to\n   \"propname\", meaning the name of all properties should be returned.\n   Since no depth header is present, it assumes its default value of\n   \"infinity\", meaning the name of the properties on the collection and\n   all its progeny should be returned.\n\n<P>Consistent with the previous example, resource\n   http://www.foo.bar/container/ has two properties defined on it,\n   http://www.foo.bar/boxschema/bigbox, and\n   http://www.foo.bar/boxschema/author.  The resource\n   http://www.foo.bar/container/index.html, a member of the \"container\"\n   collection, has only one property defined on it,\n   http://www.foo.bar/boxschema/bigbox.\n\n\n<H3>8.2. <TT>PROPPATCH</TT></H3>\n\n<P>The <TT>PROPPATCH</TT> method processes instructions specified in the request\n   body to set and/or remove properties defined on the resource\n   identified by Request-URI.\n\n<P>All DAV compliant resources MUST support the <TT>PROPPATCH</TT> method and\n   MUST process instructions that are specified using the\n   propertyupdate, set, and remove XML elements of the DAV schema.\n   Execution of the directives in this method is, of course, subject to\n   access control constraints.  DAV compliant resources MUST support\n   the setting of arbitrary dead properties.\n\n<P>The request message body of a <TT>PROPPATCH</TT> method MUST contain at least\n   one propertyupdate XML element.  Instruction processing MUST occur\n   in the order instructions are received (i.e., from top to bottom),\n   and MUST be performed atomically.\n\n<h4>8.2.1. propertyupdate XML element</h4>\n\n<BR>   Name:       <TT>propertyupdate</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To contain a request to alter the properties on a\n   resource.\n<BR>   Parent:     None\n<BR>   Values=     1*(set | remove)\n<BR>   Description: This XML element is a container for the information\n   required to modify the properties on the resource.  This XML element\n   is multi-valued.\n\n<h4>8.2.2. set XML element</h4>\n\n<BR>   Name:       <TT>set</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To set the DAV properties specified inside the set XML\n   element.\n<BR>   Parent:     propertyupdate\n<BR>   Values=     prop\n<BR>   Description: This XML element MUST contain only a prop XML element.\n   The elements contained by prop specify the name and value of\n   properties that are set on the Request-URI.  If a property already\n   exists then its value is replaced.\n\n\n<h4>8.2.3. remove XML element</h4>\n\n<BR>   Name:       <TT>remove</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To remove the DAV properties specified inside the remove\n   XML element.\n<BR>   Parent:     propertyupdate\n<BR>   Values=     prop\n<BR>   Description: Remove specifies that the properties specified in prop\n   should be removed.  Specifying the removal of a property that does\n   not exist is not an error.  All the elements in prop MUST be empty,\n   as only the names of properties to be removed are required.\n\n\n<h4>8.2.4. Response Codes</h4>\n\n<LI>   200 OK - The command succeeded.  As there can be a mixture of sets\n   and removes in a body, a 201 Create seems inappropriate.\n\n<LI>   403 Forbidden - The client, for reasons the server chooses not to\n   specify, cannot alter one of the properties.\n\n<LI>   405 Conflict - The client has provided a value whose semantics are\n   not appropriate for the property.  This includes trying to set read-only properties.\n\n<LI>   413 Request Entity Too Long - If a particular property is too long\n   to be recorded then a composite XML error will be returned\n   indicating the offending property.\n\n<h4>8.2.5. Example</h4>\n\n<PRE>\n   PROPPATCH /bar.html HTTP/1.1\n   Host: www.foo.com\n   Content-Type: text/xml\n   Content-Length: xxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;?namespace href = \"http://www.w3.com/standards/z39.50/\" AS = \"Z\"?&gt;\n   &lt;D:propertyupdate&gt;\n     &lt;D:set&gt;\n          &lt;D:prop&gt;\n               &lt;Z:authors&gt;\n                    &lt;Z:Author&gt;Jim Whitehead&lt;/Z:Author&gt;\n                    &lt;Z:Author&gt;Roy Fielding&lt;/Z:Author&gt;\n               &lt;/Z:authors&gt;\n          &lt;/D:prop&gt;\n     &lt;/D:set&gt;\n     &lt;D:remove&gt;\n          &lt;D:prop&gt;&lt;Z:Copyright-Owner/&gt;&lt;/D:prop&gt;\n     &lt;/D:remove&gt;\n   &lt;/D:propertyupdate&gt;\n</PRE>\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href=\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;?namespace href=\"http://www.w3.com/standards/z39.50/\" AS = \"Z\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:prop&gt;&lt;Z:Authors/&gt;&lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP/1.1 420 Method Failure&lt;/D:status&gt;\n     &lt;/D:response&gt;\n     &lt;D:response&gt;\n          &lt;D:prop&gt;&lt;Z:Copyright-Owner/&gt;&lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP/1.1 409 Conflict&lt;/D:status&gt;\n     &lt;/D:response&gt;\n     &lt;D:responsedescription&gt; Copyright Owner can not be deleted or\n   altered.&lt;/D:responsedescription&gt;\n   &lt;/D:multistatus&gt;\n</PRE>\n\n<P>In this example, the client requests the server to set the value of\n   the http://www.w3.com/standards/z39.50/Authors property, and to\n   remove the property http://www.w3.com/standards/z39.50/Copyright-Owner.  Since the Copyright-Owner property could not be removed, no\n   property modifications occur.  The Method Failure response code for\n   the Authors property indicates this action would have succeeded if\n   it were not for the conflict with removing the Copyright-Owner\n   property.\n\n<h3>8.3. <TT>MKCOL</TT> Method</h3>\n\n<P>The <TT>MKCOL</TT> method is used to create a new collection. All DAV\n   compliant resources MUST support the <TT>MKCOL</TT> method.\n\n<h4>8.3.1. Request</h4>\n\n<P><TT>MKCOL</TT> creates a new collection resource at the location specified by\n   the Request-URI.  If the Request-URI exists, then <TT>MKCOL</TT> must fail.\n   During <TT>MKCOL</TT> processing, a server MUST make the Request-URI a member\n   of its parent collection.  If no such ancestor exists, the method\n   MUST fail.  When the <TT>MKCOL</TT> operation creates a new collection\n   resource, all ancestors MUST already exist, or the method MUST fail\n   with a 409 Conflict status code.  For example, if a request to\n   create collection /a/b/c/d/ is made, and neither /a/b/ nor /a/b/c/\n   exists, the request MUST fail.\n\n<P>When <TT>MKCOL</TT> is invoked without a request body, the newly created\n   collection has no members.\n\n<P>A <TT>MKCOL</TT> request message MAY contain a message body.  The behavior of\n   a <TT>MKCOL</TT> request when the body is present is limited to creating\n   collections, members of a collection, bodies of members and\n   properties on the collections or members.  If the server receives a\n   <TT>MKCOL</TT> request entity type it does not support or understand it MUST\n   respond with a 415 Unsupported Media Type status code.  The exact\n   behavior of <TT>MKCOL</TT> for various request media types is undefined in\n   this document, and will be specified in separate documents.\n\n<h4>8.3.2. Response Codes</h4>\n\n<P>Responses from a <TT>MKCOL</TT> request are not cacheable, since <TT>MKCOL</TT> has\n   non-idempotent semantics.\n\n<LI>   201 Created - The collection or structured resource was created in\n   its entirety.\n\n<LI>   403 Forbidden - This indicates at least one of two conditions: 1)\n   The server does not allow the creation of collections at the given\n   location in its namespace, and 2) The parent collection of the\n   Request-URI exists but cannot accept members.\n\n<LI>   405 Method Not Allowed - <TT>MKCOL</TT> can only be executed on a\n   deleted/non-existent resource.\n\n<LI>   409 Conflict - A collection cannot be made at the Request-URI until\n   one or more intermediate collections have been created.\n\n<LI>   415 Unsupported Media Type- The server does not support the request\n   type of the body.\n\n<LI>   419 Insufficient Space on Resource - The resource does not have\n   sufficient space to record the state of the resource after the\n   execution of this method.\n\n<h4>8.3.3. Example</h4>\n\n<P>This example creates a collection called /webdisc/xfiles/ on the\n   server www.server.org.\n\n<PRE>\n   MKCOL /webdisc/xfiles/ HTTP/1.1\n   Host: www.server.org\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 201 Created\n</PRE>\n\n<h3>8.4. <TT>INDEX</TT> Method</h3>\n\n<P>The <TT>INDEX</TT> method is used to enumerate the members of a resource.\n   All DAV compliant resources MUST support the <TT>INDEX</TT> method if they\n   have members.\n\n<h4>8.4.1. The Request</h4>\n\n<P>For a collection, <TT>INDEX</TT> MUST return a list of its members.  All\n   WebDAV compliant resources MUST support the text/xml response entity\n   described below.  The <TT>INDEX</TT> result for a collection MAY also return\n   a list of the members of child collections, to any depth.\n\n<P>Collections that respond to an <TT>INDEX</TT> method with a text/xml entity\n   MUST contain a single <TT> multistatus</TT> XML element which contains a\n   response XML element for each member.\n\n<P>A resource that supports <TT>INDEX</TT> MUST return the <TT>resourcetype</TT> property\n   for each member.\n\n<P>Note that the prop XML element MAY contain additional properties.\n\n<h4>8.4.2. Example</h4>\n\n<PRE>\n   INDEX /user/yarong/dav_drafts/ HTTP/1.1\n   Host: www.microsoft.com\n</PRE>\n<PRE>\n\n   HTTP/1.1 200 OK\n   Content-Type: text/xml\n   Content-Length: xxx\n   Last-Modified: Thu, 11 Sep 1997 23:45:12 GMT\n   ETag: \"fooyyybar\"\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" as = \"D\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:href&gt;http://www.microsoft.com/user/yarong/dav_drafts/\n          &lt;/D:href&gt;\n          &lt;D:prop&gt;\n               &lt;D:resourcetype&gt;\n                    &lt;D:collection/&gt;\n               &lt;/D:resourcetype&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP 1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n     &lt;D:response&gt;\n          &lt;D:href&gt;\n          http://www.microsoft.com/user/yarong/dav_drafts/base\n          &lt;/D:href&gt;\n          &lt;D:prop&gt;\n               &lt;D:resourcetype/&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP 1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n   &lt;/D:multistatus&gt;\n</PRE>\n\n<h3>8.5. <TT>ADDREF</TT> Method</h3>\n\n<P>The <TT>ADDREF</TT> method is used to add external members to a resource.\n   All DAV compliant collection resources MUST support the <TT>ADDREF</TT>\n   method.  All other DAV compliant resources MAY support the <TT>ADDREF</TT>\n   method as appropriate.\n\n<h4>8.5.1. The Request</h4>\n\n<P>The <TT>ADDREF</TT> method adds the URI specified in the Collection-Member\n   header as an external member to the collection specified by the\n   Request-URI.  The value in the <TT>Collection-Member</TT> header MUST be an\n   absolute URI meeting the requirements of an external member URI.\n\n<P>It is not an error if the URI specified in the Collection-Member\n   header already exists as an external member of the collection.\n   However, after processing the <TT>ADDREF</TT> there MUST be only one instance\n   of the URI in the collection.  If the URI specified in the\n   <TT>Collection-Member</TT> header already exists as an internal member of the\n   collection, the <TT>ADDREF</TT> method MUST fail with a 412 Precondition\n   Failed status code.\n\n<h4>8.5.2. Example</h4>\n\n<PRE>\n   ADDREF /~ejw/dav/ HTTP/1.1\n   Host: www.ics.uci.edu\n   Collection-Member: http://www.ietf.org/standards/dav/\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 200 OK\n</PRE>\n\n\n<P>This example adds the URI http://www.ietf.org/standards/dav/ as an\n   external member resource of the collection\n   http://www.ics.uci.edu/~ejw/dav/.\n\n\n<h3>8.6. <TT>DELREF</TT> Method</h3>\n\n<P>The <TT>DELREF</TT> method is used to remove external members from a\n   resource.  All DAV compliant collection resources MUST support the\n   <TT>DELREF</TT> method.  All other DAV compliant resources MUST support the\n   <TT>DELREF</TT> method only if they support the <TT>ADDREF</TT> method.\n\n<h4>8.6.1. The Request</h4>\n\n<P>The <TT>DELREF</TT> method removes the URI specified in the Collection-Member\n   header from the collection specified by the Request-URI.\n\n<P>DELREFing a URI which is not a member of the collection is not an\n   error.  DELREFing an internal member MUST fail with a 412\n   Precondition Failed status code.\n\n<h4>8.6.2. Example</h4>\n\n<PRE>\n   <TT>DELREF</TT> /~ejw/dav/ HTTP/1.1\n   Host: www.ics.udi.edu\n   Collection-Member: http://www.ietf.org/standards/dav/\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 200 OK\n</PRE>\n\n<P>This example removes the URI http://www.ietf.org/standards/dav/, an\n   external member resource, from the collection\n   http://www.ics.uci.edu/~ejw/dav/.\n\n\n<h3>8.7. <TT>GET</TT>, <TT>HEAD</TT> for Collections</h3>\n\n<P>The semantics of <TT>GET</TT> are unchanged when applied to a collection,\n   since <TT>GET</TT> is defined as, \"retrieve whatever information (in the form\n   of an entity) is identified by the Request-URI\" [Fielding et al.,\n   1997].  <TT>GET</TT> when applied to a collection MAY return the contents of\n   an \"index.html\" resource, a human-readable view of the contents of\n   the collection, or something else altogether, and hence it is\n   possible the result of a <TT>GET</TT> on a collection will bear no\n   correlation to the state of the collection.\n\n<P>Similarly, since the definition of <TT>HEAD</TT> is a <TT>GET</TT> without a response\n   message body, the semantics of <TT>HEAD</TT> are unmodified when applied to\n   collection resources.\n\n<h3>8.8. <TT>POST</TT> for Collections</h3>\n\n<P>Since by definition the actual function performed by <TT>POST</TT> is\n   determined by the server and often depends on the particular\n   resource, the behavior of <TT>POST</TT> when applied to collections cannot be\n   meaningfully modified because it is largely undefined.  Thus the\n   semantics of <TT>POST</TT> are unmodified when applied to a collection.\n\n<H3>8.9. <TT>DELETE</TT></H3>\n\n<h4>8.9.1. <TT>DELETE</TT> Method for Non-Collection Resources</h4>\n\n<P>If the <TT>DELETE</TT> method is issued to a non-collection resource which is\n   an internal member of a collection, then during <TT>DELETE</TT> processing a\n   server MUST remove the Request-URI from its parent collection.  A\n   server MAY remove the URI of a deleted resource from any collections\n   of which the resource is an external member.\n\n<h4>8.9.2. <TT>DELETE</TT> for Collections</h4>\n\n<P>The <TT>DELETE</TT> method on a collection MUST act as if a Depth = Infinity\n   header was used on it.  A client MUST NOT submit a <TT>Depth</TT> header on a\n   <TT>DELETE</TT> on a collection with any value but Infinity.\n\n<P><TT>DELETE</TT> instructs that the collection specified in the request-URI,\n   the records of its external member resources, and all its internal\n   member resources, are to be deleted.\n\n<P>If any member cannot be deleted then all of the member's progeny\n   MUST NOT be deleted, so as to maintain the namespace.\n\n<P>Any headers included with <TT>DELETE</TT> MUST be applied in processing every\n   resource to be deleted.  In this case, a header of special interest\n   is the <TT>Destroy</TT> header, which specifies the method to be used to\n   delete all resources in the scope of the <TT>DELETE</TT>.\n\n<P>When the <TT>DELETE</TT> method has completed processing it MUST return a\n   consistent namespace.\n\n<P>The response SHOULD be a Multi-Status response that describes the\n   result of the <TT>DELETE</TT> on each affected resource.\n\n<h4>8.9.2.1. Example</h4>\n\n<PRE>\n   DELETE  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destroy: NoUndelete\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"d\"?&gt;\n   &lt;d:multistatus&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/resource1&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/resource2&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;\n     &lt;/d:response&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 420 Method Failure&lt;/d:status&gt;\n     &lt;/d:response&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/resource3&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 412 Precondition Failed&lt;/d:status&gt;\n     &lt;/d:response&gt;\n   &lt;/d:multistatus&gt;\n</PRE>\n\n<P>In this example the attempt to delete\n   http://www.foo.bar/container/resource3 failed because the server was\n   unable to guarantee that resource3 would not be able to be\n   undeleted.  Consequently, the attempt to delete\n   http://www.foo.bar/container/ also failed, but resource1 and\n   resource2 were deleted. Even though a <TT>Depth</TT> header has not been\n   included, a depth of infinity is assumed because the method is on a\n   collection. As this example illustrates, <TT>DELETE</TT> processing need not\n   be atomic.\n\n<H3>8.10. <TT>PUT</TT></H3>\n\n<h4>8.10.1. <TT>PUT</TT> for Non-Collection Resources</h4>\n\n<P>A <TT>PUT</TT> performed on an existing resource replaces the <TT>GET</TT> response\n   entity of the resource.  Properties defined on the resource MAY be\n   recomputed during <TT>PUT</TT> processing.  For example, if a server\n   recognizes the content type of the request body, it may be able to\n   automatically extract information that could be profitably exposed\n   as properties.\n\n<P>A <TT>PUT</TT> that would result in the creation of a resource without an\n   appropriately scoped parent collection MUST fail with a 405 Method\n   Not Allowed.\n\n<h4>8.10.2. <TT>PUT</TT> for Collections</h4>\n\n<P>As defined in the HTTP/1.1 specification [Fielding et al., 1997],\n   the \"<TT>PUT</TT> method requests that the enclosed entity be stored under\n   the supplied Request-URI.\"  Since submission of an entity\n   representing a collection would implicitly encode creation and\n   deletion of resources, this specification intentionally does not\n   define a transmission format for creating a collection using <TT>PUT</TT>.\n   Instead, the <TT>MKCOL</TT> method is defined to create collections.  If a\n   <TT>PUT</TT> is invoked on a collection resource it MUST fail.\n\n<P>When the <TT>PUT</TT> operation creates a new non-collection resource all\n   ancestors MUST already exist.  If all ancestors do not exist, the\n   method MUST fail with a 409 Conflict status code.  For example, if\n   resource /a/b/c/d.html is to be created and /a/b/c/ does not exist,\n   then the request must fail.\n\n<h3>8.11. <TT>COPY</TT> Method</h3>\n\n<P>The <TT>COPY</TT> method creates a duplicate of the specified resource.  All\n   DAV compliant resources MUST support the <TT>COPY</TT> method.\n\n<P>Support for the <TT>COPY</TT> method does not guarantee the ability to copy a\n   resource. For example, separate programs may control resources on\n   the same server.  As a result, it may not even be possible to copy a\n   resource to a location that appears to be on the same server.\n\n<h4>8.11.1. The Request</h4>\n\n<P>The <TT>COPY</TT> method creates a duplicate of the source resource, given by\n   the Request-URI, in the destination resource, given by the\n   <TT>Destination</TT> header.  The <TT>Destination</TT> header MUST be present.  The\n   exact behavior of the <TT>COPY</TT> method depends on the type of the source\n   resource.\n\n<h4>8.11.1.1. <TT>COPY</TT> for HTTP/1.1 resources</h4>\n\n<P>When the source resource is not a collection the body of the\n   destination resource MUST be octet-for-octet identical to the body\n   of the source resource.  Alterations to the destination resource do\n   not modify the source resource.  Alterations to the source resource\n   do not modify the destination resource.  Thus, all copies are\n   performed \"by-value\".\n\n<P>All properties on the source resource MUST be duplicated on the\n   destination resource, subject to modifying headers, following the\n   definition for copying properties.\n\n<h4>8.11.1.2. <TT>COPY</TT> for Properties</h4>\n\n<P>The following section defines how properties on a resource are\n   handled during a <TT>COPY</TT> operation.\n\n<P>Live properties SHOULD be duplicated as identically behaving live\n   properties at the destination resource.  Since they are live\n   properties, the server determines the syntax and semantics of these\n   properties.  Properties named by the <TT>Enforce-Live-Properties</TT> header\n   MUST be live on the destination resource, or the method MUST fail.\n   If a property is not named by Enforce-Live-Properties and cannot be\n   copied live, then its value MUST be duplicated, octet-for-octet, in\n   an identically named, dead property on the destination resource.\n\n<P>If a property on the source already exists on the destination\n   resource and the <TT>Overwrite</TT> header is set to \"T\" then the property at\n   the destination MUST be overwritten with the property from the\n   source.  If the <TT>Overwrite</TT> header is \"F\" and the previous situation\n   exists, then the <TT>COPY</TT> MUST fail with a 409 Conflict.\n\n<h4>8.11.1.3. <TT>COPY</TT> for Collections</h4>\n\n<P>The <TT>COPY</TT> method on a collection without a <TT>Depth</TT> header MUST act as\n   if a Depth = infinity header was included.  A client MAY submit a\n   <TT>Depth</TT> header on a <TT>COPY</TT> on a collection with a value of \"0\" or\n   \"infinity\".  DAV compliant servers MUST support the \"0\" and\n   \"infinity\" behaviors.\n\n<P>A <TT>COPY</TT> of depth infinity instructs that the collection specified in\n   the Request-URI, the records of its external member resources, and\n   all its internal member resources, are to be copied to a location\n   relative to the <TT>Destination</TT> header.\n\n<P>A <TT>COPY</TT> of depth \"0\" only instructs that the collection, the\n   properties, and its external members, not its internal members, are\n   to be copied.\n\n<P>Any headers included with a <TT>COPY</TT> are to be applied in processing\n   every resource to be copied.\n\n<P>The exception to this rule is the <TT>Destination</TT> header. This header\n   only specifies the destination for the Request-URI.  When applied to\n   members of the collection specified in the request-URI the value of\n   Destination is to be modified to reflect the current location in the\n   hierarchy.  So, if the request-URI is \"a\" and the destination is \"b\"\n   then when a/c/d is processed it MUST use a destination of b/c/d.\n\n<P>When the <TT>COPY</TT> method has completed processing it MUST have created a\n   consistent namespace at the destination.  Thus if it is not possible\n   to <TT>COPY</TT> a collection with internal members, the internal members may\n   still be copied but a collection will have to be created at the\n   destination to contain them.\n\n<P>The response is a Multi-Status response that describes the result of\n   the <TT>COPY</TT> on each affected resource.  The response is given for the\n   resource that was to be copied, not the resource that was created as\n   a result of the copy.  In other words, each entry indicates whether\n   the copy on the resource specified in the <TT>href</TT> succeeded or failed\n   and why.\n\n<P>The exception to this rule is for errors that occurred on the\n   destination.  For example, if the destination was locked the\n   response would indicate the destination URL and a 421 Destination\n   Locked error.\n\n<h4>8.11.1.4. Type Interactions</h4>\n\n<P>If the destination resource identifies a collection and the\n   <TT>Overwrite</TT> header is \"T\", prior to performing the copy the server\n   MUST perform a <TT>DELETE</TT> operation on the collection.\n\n<h4>8.11.2. Response Codes</h4>\n\n<LI>200 OK - The source resource was successfully copied to a pre-existing destination resource.\n\n<LI>201 Created - The source resource was successfully copied.  The copy\n   operation resulted in the creation of a new resource.\n\n<LI>412 Precondition Failed - This status code MUST be returned if the\n   server was unable to maintain the liveness of the properties listed\n   in the <TT>Enforce-Live-Properties</TT> header, or if the <TT>Overwrite</TT> header is\n   \"F\", and the state of the destination resource is non-null.\n\n<LI>419 Insufficient Space on Resource - The destination resource does\n   not have sufficient space to record the state of the resource after\n   the execution of this method.\n\n<LI>421 Destination Locked - The destination resource was locked and\n   either a valid <TT>Lock-Token</TT> header was not submitted, or the <TT>Lock-Token</TT> header identifies a lock held by another principal.\n\n<LI>500 Server Error - The resource was in such a state that it could\n   not be copied.  This may occur if the <TT>Destination</TT> header specifies a\n   resource that is outside the namespace the resource is able to\n   interact with.\n\n<h4>8.11.3. Overwrite Example</h4>\n\n<P>This example shows resource\n   http://www.ics.uci.edu/~fielding/index.html being copied to the\n   location http://www.ics.uci.edu/users/f/fielding/index.html.  The\n   contents of the destination resource were overwritten, if non-null.\n\n<PRE>\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 200 OK\n</PRE>\n\n<h4>8.11.4. No Overwrite Example</h4>\n\n<P>The following example shows the same copy operation being performed,\n   except with the <TT>Overwrite</TT> header set to \"F.\"  A response of 412\n   Precondition Failed is returned because the destination resource has\n   a non-null state.\n\n<PRE>\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n   Overwrite: \"F\"\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 412 Precondition Failed\n</PRE>\n\n<h4>8.11.5. Collection Example</h4>\n\n<PRE>\n   COPY /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Enforce-Live-Properties: *\n   Depth: Infinity\n</PRE>\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"d\"?&gt;\n   &lt;d:multistatus&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/othercontainer/resource1&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/othercontainer/resource2&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/othercontainer/&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/othercontainer/R2/D2&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 201 Created&lt;/d:status&gt;\n     &lt;/d:response&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/othercontainer/R2/&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 412 Precondition Failed&lt;/d:status&gt;\n     &lt;/d:response&gt;\n   &lt;/d:multistatus&gt;\n</PRE>\n\n<P>The <TT>Depth</TT> header is unnecessary as the default behavior of <TT>COPY</TT> on a\n   collection is to act as if a \"Depth: Infinity\" header had been\n   submitted.  In this example most of the resources, along with the\n   collection, were copied successfully. However the collection R2\n   failed, most likely due to a problem with enforcing live properties.\n   R2's member D2 was successfully copied.  As a result a collection\n   was created at www.foo.bar/othercontainer/R2 to contain D2.\n\n<h3>8.12. <TT>MOVE</TT> Method</h3>\n\n<P>The move operation on a resource is the logical equivalent of a copy\n   followed by a delete, where the actions are performed atomically.\n   All DAV compliant resources MUST support the <TT>MOVE</TT> method.\n\n<P>However, support for the <TT>MOVE</TT> method does not guarantee the ability\n   to move a resource to a particular destination. For example,\n   separate programs may actually control different sets of resources\n   on the same server.  Therefore, it may not even be possible to move\n   a resource within a namespace that appears to belong to the same\n   server.\n\n<h4>8.12.1. The Request</h4>\n\n<P>If a resource exists at the destination, the destination resource\n   will be DELETEd as a side effect of the <TT>MOVE</TT> operation, subject to\n   the restrictions of the <TT>Overwrite</TT> header.\n\n<h4>8.12.2. <TT>MOVE</TT> for Collections</h4>\n\n<P><TT>MOVE</TT> instructs that the collection specified in the Request-URI, the\n   records of its external member resources, and all its internal\n   member resources, are to be moved to a location relative to the\n   <TT>Destination</TT> header.\n\n<P>The <TT>MOVE</TT> method on a collection MUST act as if a Depth \"infinity\"\n   header was used on it.  A client MUST NOT submit a <TT>Depth</TT> header on a\n   <TT>MOVE</TT> on a collection with any value but \"infinity\".\n\n<P>Any headers included with <TT>MOVE</TT> are to be applied in processing every\n   resource to be moved.\n\n<P>The exception to this rule is the <TT>Destination</TT> header.  The behavior\n   of this header is the same as given for <TT>COPY</TT> on collections.\n\n<P>When the <TT>MOVE</TT> method has completed processing it MUST have created a\n   consistent namespace on both the source and destination, creating\n   collections at the source or destination as necessary.\n\n<P>As specified in the definition of <TT>MOVE</TT>, a <TT>MOVE</TT> of a collection over\n   another collection causes the destination collection and all its\n   members to be deleted.\n\n<P>The response is a Multi-Status response that describes the result of\n   the <TT>MOVE</TT> on each affected resource.  The response is given for the\n   resource that was to be moved, not the resource that was created as\n   a result of the move.  In other words, each entry indicates whether\n   the move on the resource specified in the <TT>href</TT> succeeded or failed\n   and why.\n\n<P>The exception to this rule is for errors that occurred on the\n   destination.  For example, if the destination was locked the\n   response would indicate the destination URL and a 421 Destination\n   Locked error.\n\n<h4>8.12.3. Response Codes</h4>\n\n<LI>   200 OK - The move operation was successful.\n\n<LI>   409 Conflict - The <TT>MOVE</TT> was attempted on a collection with members.\n   While the <TT>COPY</TT> part of this operation could succeed the <TT>DELETE</TT> could\n   not.  Therefore the <TT>MOVE</TT> MUST fail.\n\n<LI>   412 Precondition Failed - This status code MUST be returned if the\n   server was unable to maintain the liveness of the properties listed\n   in the <TT>Enforce-Live-Properties</TT> header, or if the <TT>Overwrite</TT> header is\n   \"F\", and the state of the destination resource is non-null.\n\n<LI>   421 Destination Locked - The destination resource was locked and\n   either a valid <TT>Lock-Token</TT> header was not submitted, or the <TT>Lock-Token</TT> header identifies a lock held by another principal.\n\n<LI>   502 Bad Gateway - This may occur when the destination is on another\n   server and the destination server refuses to accept the resource\n\n<h4>8.12.4. Overwrite Example</h4>\n\n<P>This example shows resource\n   http://www.ics.uci.edu/~fielding/index.html being moved to the\n   location http://www.ics.uci.edu/users/f/fielding/index.html.  The\n   contents of the destination resource were overwritten, if non-null.\n\n<PRE>\n   MOVE /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 200 OK\n</PRE>\n\n\n<h4>8.12.5. Collection Example</h4>\n\n<PRE>\n   MOVE /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Enforce-Live-Properties: *\n   Overwrite: False\n   Lock-Token: &lt;OpaqueLockToken:xxxx&gt; &lt;OpaqueLockToken:xxxx&gt;\n</PRE>\n\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?&gt;\n   &lt;d:multistatus&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/resource1&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/resource2&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/&lt;/d:href&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/C2/R2&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 201 Created&lt;/d:status&gt;\n     &lt;/d:response&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/container/C2&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 420 Method Failure&lt;/d:status&gt;\n     &lt;d:response&gt;\n          &lt;d:href&gt;http://www.foo.bar/othercontainer/C2&lt;/d:href&gt;\n          &lt;d:status&gt;HTTP/1.1 409 Conflict&lt;/d:status&gt;\n     &lt;/d:response&gt;\n   &lt;/d:multistatus&gt;\n</PRE>\n\n<P>In this example the client has submitted a number of lock tokens\n   with the request.  A lock token will need to be submitted for every\n   resource, both source and destination, anywhere in the scope of the\n   method, that is locked.  In this case the proper lock token was not\n   submitted for the destination http://www.foo.bar/othercontainer/C2.\n   This means that the resource continer/c2 could not be moved,\n   although its child container/C2/R2 could be moved.\n\n<h3>8.13. <TT>LOCK</TT> Method</h3>\n\n<P>The following sections describe the <TT>LOCK</TT> method, which is used to\n   take out a lock of any access type.  These sections on the <TT>LOCK</TT>\n   method describe only those semantics that are specific to the <TT>LOCK</TT>\n   method and are independent of the access type of the lock being\n   requested.  Once the general <TT>LOCK</TT> method has been described,\n   subsequent sections describe the semantics of the \"write\" access\n   type, and the write lock.\n\n<h4>8.13.1. Operation</h4>\n\n<P>A <TT>LOCK</TT> method invocation creates the lock specified by the Lock-Info\n   header on the Request-URI.  Lock method requests SHOULD have a XML\n   request body which contains an Owner XML element for this lock\n   request. The <TT>LOCK</TT> request MAY have a <TT>Timeout</TT> header.\n\n<P>A successful response to a lock invocation MUST include <TT>Lock-Token</TT>\n   and <TT>Timeout</TT> headers.  Clients MUST assume that locks may arbitrarily\n   disappear at any time, regardless of the value given in the Timeout\n   header.  The <TT>Timeout</TT> header only indicates the behavior of the\n   server if \"extraordinary\" circumstances do not occur.  For example,\n   an administrator may remove a lock at any time or the system may\n   crash in such a way that it loses the record of the lock's\n   existence. The response MUST also contain the value of the\n   lockdiscovery property in a prop XML element.\n\n<h4>8.13.2. The Effect of Locks on Properties and Collections</h4>\n\n<P>By default the scope of a lock is the entire state of the resource,\n   including its body and associated properties.  As a result, a lock\n   on a resource also locks the resource's properties, and a lock on a\n   property may lock a property's resource or may restrict the ability\n   to lock the property's resource.  Only a single lock token MUST be\n   used when a lock extends to cover both a resource and its\n   properties.  Note that certain lock types MAY override this\n   behavior.\n\n<P>For collections, a lock also affects the ability to add or remove\n   members.  The nature of the effect depends upon the type of access\n   control involved.\n\n<h4>8.13.3. Locking Replicated Resources</h4>\n\n<P>Some servers automatically replicate resources across multiple URLs.\n   In such a circumstance the server MAY only accept a lock on one of\n   the URLs if the server can guarantee that the lock will be honored\n   across all the URLs.\n\n<h4>8.13.4. Locking Multiple Resources</h4>\n\n<P>The <TT>LOCK</TT> method supports locking multiple resources simultaneously\n   by allowing for the listing of several URIs in the <TT>LOCK</TT> request.\n   These URIs, in addition to the Request-URI, are then to be locked as\n   a result of the <TT>LOCK</TT> method's invocation.  When multiple resources\n   are specified the <TT>LOCK</TT> method only succeeds if all specified\n   resources are successfully locked.\n\n<P>The Lock-Tree option of the lock request specifies that the resource\n   and all its internal children (including internal collections, and\n   their internal members) are to be locked.  This is another mechanism\n   by which a request for a lock on multiple resources can be\n   specified.\n\n<P>Currently existing locks can not be extended to cover more or less\n   resources, and any request to expand or contract the number of\n   resources in a lock MUST fail with a 409 Conflict status code. So,\n   for example, if resource A is exclusively write locked and then the\n   same principal asks to exclusively write lock resources A, B, and C,\n   the request will fail as A is already locked and the lock can not be\n   extended.\n\n<P>A successful result will return a single lock token which represents\n   all the resources that have been locked.  If an <TT>UNLOCK</TT> is executed\n   on this token, all associated resources are unlocked.\n\n<P>If the lock cannot be granted to all resources, a 409 Conflict\n   status code MUST be returned with a response entity body containing\n   a <TT> multistatus</TT> XML element describing which resource(s) prevented the\n   lock from being granted.\n\n<h4>8.13.5. Interaction with other Methods</h4>\n\n<P>The interaction of a <TT>LOCK</TT> with various methods is dependent upon the\n   lock type.  However, independent of lock type, a successful <TT>DELETE</TT>\n   of a resource MUST cause all of its locks to be removed.\n\n<h4>8.13.6. Lock Compatibility Table</h4>\n\n<P>The table below describes the behavior that occurs when a lock\n   request is made on a resource.\n\n<table>\n<TR><TH>   Current lock state/<BR>   Lock request<TH>      Shared Lock<TH>       Exclusive<BR>Lock</TR>\n<TR><TD>   None<TD>                     True<TD>              True</TR>\n<TR><TD>  Shared Lock<TD>              True<TD>              False</TR>\n<TR><TD>   Exclusive Lock<TD>           False <TD>            False*</TR>\n</TABLE>\n\n<P>Legend: True = lock MAY be granted.  False = lock MUST NOT be\n   granted.  *=if the principal requesting the lock is the owner of the\n   lock, the lock MAY be regranted.\n\n<P>The current lock state of a resource is given in the leftmost\n   column, and lock requests are listed in the first row.  The\n   intersection of a row and column gives the result of a lock request.\n   For example, if a shared lock is held on a resource, and an\n   exclusive lock is requested, the table entry is \"false\", indicating\n   the lock must not be granted.\n\n<P>If an exclusive or shared lock is re-requested by the principal who\n   owns the lock, the lock MUST be regranted.  If the lock is\n   regranted, the same lock token that was previously issued MUST be\n   returned.\n\n<h4>8.13.7. Owner XML Element</h4>\n\n<BR>   Name:       <TT>owner</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Provide information about the principal taking out a\n   lock.\n<BR>   Parent:     Any\n<BR>   Values:          XML Elements\n   Descripton: The Owner XML element provides information sufficient\n   for either directly contacting a principal (such as a telephone\n   number or Email URI), or for discovering the principal (such as the\n   URL of a homepage) who owns a lock.\n\n<h4>8.13.8. Lock Response</h4>\n\n<P>A successful lock response MUST contain a Lock-Token response\n   header, a <TT>Timeout</TT> header and a prop XML element in the response body\n   which contains the value of the lockdiscovery property.\n\n<h4>8.13.9. Response Codes</h4>\n\n<LI>   409 Conflict - The resource is locked, so the method has been\n   rejected.\n\n<LI>   412 Precondition Failed - The included Lock-Token was not\n   enforceable on this resource or the server could not satisfy the\n   request in the <TT>Lock-Info</TT> header.\n\n<h4>8.13.10. Example - Simple Lock Request</h4>\n\n<PRE>\n   LOCK /workspace/webdav/proposal.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Lock-Info: LockType=Write LockScope=Exclusive\n   Timeout: Infinite; Second-4100000000\n   Content-Type: text/xml\n   Content-Length: xyz\n   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href=\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:owner&gt;\n      &lt;D:href&gt;http://www.ics.uci.edu/~ejw/contact.html&lt;/D:href&gt;\n   &lt;/D:owner&gt;\n</PRE>\n\n<PRE>\n   HTTP/1.1 200 OK\n   Lock-Token: opaquelocktoken:xyz122393481230912asdfa09s8df09s7df\n   Timeout: Second-604800\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:prop&gt;\n     &lt;D:lockdiscovery&gt;\n          &lt;D:activelock&gt;\n               &lt;D:locktype&gt;write&lt;/D:locktype&gt;\n               &lt;D:lockscope&gt;exclusive&lt;/D:lockscope&gt;\n               &lt;D:addlocks/&gt;\n               &lt;D:owner&gt;\n                    &lt;D:href&gt;\n                    http://www.ics.uci.edu/~ejw/contact.html\n                    &lt;/D:href&gt;\n               &lt;/D:owner&gt;\n               &lt;D:timeout&gt;Second-604800&lt;/D:timeout&gt;\n               &lt;D:locktoken&gt;\n                    &lt;D:href&gt;\n               opaquelocktoken:xyz122393481230912asdfa09s8df09s7df\n                    &lt;/D:href&gt;\n               &lt;/D:locktoken&gt;\n          &lt;/D:activelock&gt;\n     &lt;/D:lockdiscovery&gt;\n   &lt;/D:prop&gt;\n</PRE>\n\n<P>This example shows the successful creation of an exclusive write\n   lock on resource\n   http://webdav.sb.aol.com/workspace/webdav/proposal.doc.  The\n   resource http://www.ics.uci.edu/~ejw/contact.html contains contact\n   information for the owner of the lock.  The server has an activity-based timeout policy in place on this resource, which causes the\n   lock to automatically be removed after 1 week (604800 seconds).  The\n   response has a <TT>Lock-Token</TT> header that gives the lock token URL that\n   uniquely identifies the lock created by this lock request.\n\n<h4>8.13.11. Example - Multi-Resource Lock Request</h4>\n\n<PRE>\n   LOCK /workspace/webdav/proposal.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Lock-Info: LockType=Write LockScope=Exclusive\n   Addlocks=&lt;http://webdav.sb.aol.com/workspace/&gt;&lt;http://foo.bar/blah&gt;\n   Timeout: Infinite, Second-4100000000\n\n   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href=\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:href&gt;http://www.ics.uci.edu/~ejw/contact.html&lt;D:href&gt;\n</PRE>\n\n<PRE>\n   HTTP/1.1 409 Conflict\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:href&gt;\n               http://webdav.sb.aol.com/workspace/webdav/proposal.doc\n          &lt;/D:href&gt;\n          &lt;D:href&gt;\n               http://webdav.sb.aol.com/workspace/webdav/\n          &lt;/D:href&gt;\n          &lt;D:status&gt;HTTP/1.1 202 Accepted&lt;/D:status&gt;\n     &lt;/D:response&gt;\n     &lt;D:response&gt;\n          &lt;D:href&gt;http://foo.bar/blah&lt;/D:href&gt;\n          &lt;D:status&gt;HTTP/1.1 403 Forbidden&lt;/D:status&gt;\n     &lt;/D:response&gt;\n   &lt;/D:multistatus&gt;\n</PRE>\n\n<P>This example shows a request for an exclusive write lock on three\n   resources, http://webdav.sb.aol.com/workspace/webdav/proposal.doc,\n   http://webdav.sb.aol.com/workspace/, and http://foo.bar/blah.  In\n   this request, the client has specified that it desires an infinite\n   length lock, if available, otherwise a timeout of 4.1 billion\n   seconds, if available.  The <TT>Owner</TT> header field specifies the web\n   address for contact information for the principal taking out the\n   lock.\n\n<P>This lock request has failed, because the server rejected the lock\n   request for http://foo.bar/blah.  The 409 Conflict status code\n   indicates that the server was unable to satisfy the request because\n   there is a conflict between the state of the resources and the\n   operation named in the request.  Within the <TT> multistatus</TT>, the 202\n   Accepted status code indicates that the lock method was accepted by\n   the resources, and would have been completed if all resources named\n   in the request were able to be locked.  The 403 Forbidden status\n   code indicates that the server does not allow lock requests on this\n   resource.\n\n<h3>8.14. <TT>UNLOCK</TT> Method</h3>\n\n<P>The <TT>UNLOCK</TT> method removes the lock identified by the lock token in\n   the <TT>Lock-Token</TT> header from the Request-URI, and all other resources\n   included in the lock.\n\n<P>Any DAV compliant resource which supports the <TT>LOCK</TT> method MUST\n   support the <TT>UNLOCK</TT> method.\n\n<h4>8.14.1. Example</h4>\n\n<PRE>\n   UNLOCK /workspace/webdav/info.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Lock-Token:opaquelocktoken:123AbcEfg1284h23h2\n</PRE>\n<PRE>\n   HTTP/1.1 200 OK\n</PRE>\n\n\n<P>In this example, the lock identified by the lock token\n   \"opaquelocktoken:123AbcEfg1284h23h2\" is successfully removed from\n   the resource http://webdav.sb.aol.com/workspace/webdav/info.doc.  If\n   this lock included more than just one resource, the lock was removed\n   from those resources as well.\n\n<h3>8.15. <TT>PATCH</TT> Method</h3>\n\n<P>The <TT>PATCH</TT> method is used to modify parts of the entity returned in\n   the response to a <TT>GET</TT> method.  DAV compliant resources MAY support\n   the <TT>PATCH</TT> method.\n\n<h4>8.15.1. The Request</h4>\n\n<P>The request entity of the <TT>PATCH</TT> method contains a list of\n   differences between the resource identified by the Request-URI and\n   the desired content of the resource after the <TT>PATCH</TT> action has been\n   applied.  The list of differences is in a format defined by the\n   media type of the entity (e.g., \"application/diff\") and must include\n   sufficient information to allow the server to convert the original\n   version of the resource to the desired version.  Processing\n   performed by <TT>PATCH</TT> is atomic.  Hence all changes MUST be\n   successfully executed or the method fails.  <TT>PATCH</TT> MUST fail if\n   executed on a non-existent resource; i.e., <TT>PATCH</TT> does not create a\n   resource as a side effect.\n\n<P>If the request appears (at least initially) to be acceptable, the\n   server MUST transmit an interim 100 response message after receiving\n   the empty line terminating the request headers and continue\n   processing the request.  Since the semantics of <TT>PATCH</TT> are non-idempotent, responses to this method are not cacheable.\n\n<P>While server support for <TT>PATCH</TT> is optional, if a server does support\n   <TT>PATCH</TT>, it MUST support at least the text/xml diff format defined\n   below.  Support for the VTML difference format [VTML] is\n   recommended, but not required.\n\n<h4>8.15.2. text/xml elements for <TT>PATCH</TT></h4>\n\n<P>The resourceupdate XML element contains a set of XML sub-entities\n   that describe modification operations.  The name and meaning of\n   these XML elements are given below.  Processing of these directives\n   MUST be performed in the order encountered within the XML document.\n   A directive operates on the resource as modified by all previous\n   directives (executed in sequential order).  The length of the\n   resource MAY be extended or reduced by a <TT>PATCH</TT>.\n\n<P>The changes specified by the resourceupdate XML element MUST be\n   executed atomically.\n\n<h4>8.15.2.1. resourceupdate XML Element</h4>\n\n<BR>   Name:       <TT>resourceupdate</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/patch/\n<BR>   Purpose:    Contains an ordered set of changes to a non-collection,\n   non-property resource.\n<BR>   Parent:     None\n<BR>   Value=      *(insert | delete | replace)\n\n\n<h4>8.15.2.2. insert XML Element</h4>\n\n<BR>   Name:       <TT>insert</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/patch/\n<BR>   Purpose:    Insert the XML element's contents starting at the\n   specified octet.\n<BR>   Parent:     resourceupdate\n<BR>   Value:      The insert XML element MUST contain an octet-range XML\n   attribute that specifies an octet position within the body of a\n   resource.  A value of \"end\" specifies the end of the resource.  The\n   body of the insert XML element contains the octets to be inserted.\n\n<P>Please note that in order to protect the white space contained in\n   this XML element the following attribute/value MUST be included in\n   the element: XML-SPACE = \"PRESERVE\". This attribute is defined in\n   the XML specification [Bray, Sperberg-McQueen, 1997].\n\n<h4>8.15.2.3. delete XML Element</h4>\n\n<BR>   Name:       <TT>delete</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/patch/\n<BR>   Purpose:    Removes the specified range of octets.\n<BR>   Parent:     resourceupdate\n<BR>   Value:      The delete XML element MUST contain an octet-range XML\n   attribute.\n\n<P>Discussion: The octets that are deleted are removed, which means the\n   resource is collapsed and the length of the resource is decremented\n   by the size of the octet range.  It is not appropriate to replace\n   deleted octets with zeroed-out octets, since zero is a valid octet\n   value.\n\n<h4>8.15.2.4. replace XML Element</h4>\n\n<BR>   Name:       <TT>replace</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/patch/\n<BR>   Purpose:    Replaces the specified range of octets with the contents\n   of the XML element.  If the number of octets in the XML element is\n   different from the number of octets specified, the update MUST be\n   rejected.\n<BR>   Parent:     resourceupdate\n<BR>   Value:      The replace XML element MUST contain an octet-range XML\n   attribute.  The contents of the entity are the replacement octets.\n\n<P>Please note that in order to protect the white space contained in\n   this XML element the following attribute/value MUST be included in\n   the element: XML-SPACE = \"PRESERVE\"\n                                     .\n\n                                       This attribute is defined in the\n   XML specification [Bray, Sperberg-McQueen, 1997].\n\n<h4>8.15.2.5. octet-range Attribute</h4>\n\n<BR>   Name:       <TT>octet-range</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/patch/\n<BR>   Purpose:    Specifies a range of octets that the enclosing property\n   affects.\n<BR>   Parent:     insert | delete | replace\n<BR>   Value:      number [\"-\" (number | \"end\")]\n               Number = 1*Digit\n\n<BR>   Description: Octet numbering begins with 0.  If the octet contains a\n   single number then the operation is to begin at that octet and to\n   continue for a length specified by the operation.  In the case of a\n   delete, this would mean to delete a single octet.  In the case of an\n   insert this would mean to begin the insertion at the specified octet\n   and to continue for the length of the included value, extending the\n   resource if necessary.  In the case of replace, the replace begins\n   at the specified octet and overwrites all that follow to the length\n   of the included value.\n\n<h4>8.15.3. Response Codes</h4>\n\n<LI>200 OK - The request entity body was processed without error,\n   resulting in an update to the state of the resource.\n\n<LI>409 Conflict - If the update information in the request message body\n   does not make sense given the current state of the resource (e.g.,\n   an instruction to delete a non-existent line), this status code MAY\n   be returned.\n\n<LI>415 Unsupported Media Type - The server does not support the content\n   type of the update instructions in the request message body.\n\n<LI>418 Unprocessable Entity - The entity body submitted with the <TT>PATCH</TT>\n   was not understood by the resource.\n\n<LI>419 Insufficient Space on Resource - The resource does not have\n   sufficient space to record the state of the resource after the\n   execution of this method.\n\n<h4>8.15.4. HTML file modification Example</h4>\n\n<P>The following example shows a modification of the title and contents\n   of the HTML resource http://www.example.org/hello.html.\n\n<P>Before:\n<PRE>   &lt;HTML&gt;\n   &lt;HEAD&gt;\n   &lt;TITLE&gt;Hello world HTML page&lt;/TITLE&gt;\n   &lt;/HEAD&gt;\n   &lt;BODY&gt;\n   &lt;P&gt;Hello, world!&lt;/P&gt;\n   &lt;/BODY&gt;\n   &lt;/HTML&gt;\n</PRE>\n\n   <TT>PATCH</TT> Request:                       Response:\n\n<PRE>\n   PATCH hello.html HTTP/1.1\n   Host: www.example.org\n   Content-Type: text/xml\n   Content-Length: xxx\n                                        HTTP/1.1 100 Continue\n\n   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/patch/\" AS =\n   \"D\"?&gt;\n   &lt;D:resourceupdate&gt;\n     &lt;D:replace XML-SPACE = \"PRESERVE\"&gt;\n          &lt;D:octet-range&gt;14&lt;/D:octet-range&gt;&amp;003CTITLE&amp;003ENew\n   Title&amp;003C/TITLE&amp;003E&lt;/D:replace&gt;\n     &lt;D:delete&gt;&lt;D:octet-range&gt;38-50&lt;/D:octet-range&gt;&lt;/D:delete&gt;\n     &lt;D:insert XML-SPACE = \"PRESERVE\"&gt;&lt;D:octet-range&gt;86&lt;/D:octet-range&gt;&amp;003CP&amp;003ENew paragraph&amp;003C/P&amp;003E&lt;/D:insert&gt;\n   &lt;/D:resourceupdate&gt;\n\n                                        HTTP/1.1 200 OK\n</PRE>\n\n<P>   After:\n<PRE>   &lt;HTML&gt;\n   &lt;HEAD&gt;\n   &lt;TITLE&gt;New Title&lt;/TITLE&gt;\n   &lt;/HEAD&gt;\n   &lt;BODY&gt;\n   &lt;P&gt;Hello, world!&lt;/P&gt;\n   &lt;P&gt;New paragraph&lt;/P&gt;\n   &lt;/BODY&gt;\n   &lt;/HTML&gt;\n</PRE>\n\n\n<h2>9. HTTP Headers for Distributed Authoring</h2>\n\n<h3>9.1. Collection-Member Header</h3>\n\n<PRE>   CollectionMember = \"Collection-Member\" \":\" URI   ; URI is defined in\n   section 3.2.1 of [Fielding et al., 1997]\n</PRE>\n\n<P>The <TT>Collection-Member</TT> header specifies the URI of an external\n   resource to be added/deleted to/from a collection.\n\n<h3>9.2. DAV Header</h3>\n\n<PRE>   DAV = \"DAV\" \":\" (\"1\" | \"2\" | extend)\n</PRE>\n\n<P>This header indicates that the resource supports the DAV schema and\n   protocol to the level indicated.  All DAV compliant resources MUST\n   return the <TT>DAV</TT> header on all <TT>OPTIONS</TT> responses.\n\n<h3>9.3. Depth Header</h3>\n\n<PRE>   Depth = \"Depth\" \":\" (\"0\" | \"1\" | \"infinity\")\n</PRE>\n\n<P>The <TT>Depth</TT> header is used with methods executed on collections to\n   indicate whether the method is to be applied only to the collection\n   (Depth = 0), to the collection and its immediate children, (Depth =\n   1), or the collection and all its progeny (Depth = infinity).  Note\n   that Depth = 1 and Depth = infinity behavior only applies to\n   internal member resources, and not to external member resources.\n\n<P>The <TT>Depth</TT> header is only supported if a method's definition\n   explicitly provides for such support.\n\n<P>The following rules are the default behavior for any method that\n   supports the depth header. A method MAY override these defaults by\n   defining different behavior in its definition.\n\n<P>Methods which support the depth header MAY choose not to support all\n   of the header's values and MAY define, on a case by case basis, the\n   behavior of the method on a collection if a depth header is not\n   present. For example, the <TT>MOVE</TT> method only supports Depth = infinity\n   and if a depth header is not present will act as if a Depth =\n   infinity header had been applied.\n\n<P>Clients MUST NOT rely upon methods executing on members of their\n   hierarchies in any particular order or the execution being atomic.\n   Note that methods MAY provide guarantees on ordering and atomicity.\n\n<P>Upon execution, a method with a depth header will perform as much of\n   its assigned task as possible and then return a response specifying\n   what it was able to accomplish and what it failed to do.\n\n<P>So, for example, an attempt to <TT>COPY</TT> a hierarchy may result in some\n   of the members being copied and some not.\n\n<P>Any headers on a method with a depth header MUST be applied to all\n   resources in the scope of the method. For example, an if-match\n   header will have its value applied against every resource in the\n   method's scope and will cause the method to fail if the header fails\n   to match.\n\n<P>If a resource, source or destination, within the scope of the method\n   is locked in such a way as to prevent the successful execution of\n   the method, then the lock token for that resource MUST be submitted\n   with the request in the Lock-Token request header.\n\n<h3>9.4. Destination Header</h3>\n\n<PRE>   Destination = \"Destination\" \":\" URI\n</PRE>\n\n<P>The <TT>Destination</TT> header specifies a destination resource for methods\n   such as <TT>COPY</TT> and <TT>MOVE</TT>, which take two URIs as parameters.\n\n<h3>9.5. Destroy Header</h3>\n\n<PRE>   DestroyHeader = \"Destroy\" \":\" #Choices\n</PRE>\n\n<PRE>   Choices = \"VersionDestroy\" | \"NoUndelete\" | \"Undelete\" | extend\n</PRE>\n\n<PRE>   Extend = RFC-Reg | Coded-URL\n</PRE>\n\n<PRE>   RFC-Req = Token ; This is a token value (defined in section 2.2 of\n   [Fielding et al., 1997]) that has been published as an RFC.\n</PRE>\n\n<PRE>   Coded-URL = \"&lt;\" URI \"&gt;\"\n</PRE>\n\n<P>When deleting a resource the client often wishes to specify exactly\n   what sort of delete should be performed.  The <TT>Destroy</TT> header, used\n   with the <TT>Mandatory</TT> header, allows the client to specify the end\n   result it desires.  The <TT>Destroy</TT> header is specified as follows:\n\n<P>The Undelete token requests that, if possible, the resource should\n   be left in a state such that it can be undeleted.  The server is not\n   required to honor this request.\n\n<P>The NoUndelete token requests that the resource MUST NOT be left in\n   a state such that it can be undeleted.\n\n<P>The VersionDestroy token includes the functionality of the\n   NoUndelete token and extends it to include having the server remove\n   all versioning references to the resource that it has control over.\n\n<h3>9.6. Enforce-Live-Properties Header</h3>\n\n<PRE>   EnforceLiveProperties = \"Enforce-Live-Properties\" \":\" (\"*\" | \"Omit\"\n   | 1*(Property-Name))\n</PRE>\n\n<PRE>   Property-Name = Coded-URL\n</PRE>\n\n<P>The <TT>Enforce-Live-Properties</TT> header specifies properties that MUST be\n   \"live\" after they are copied (moved) to the destination resource of\n   a copy (or move).  If the value \"*\" is given for the header, then it\n   designates all live properties on the source resource.  If the value\n   is \"Omit\" then the server MUST NOT duplicate on the destination\n   resource any properties that are defined on the source resource.  If\n   this header is not included then the server is expected to act as\n   defined by the default property handling behavior of the associated\n   method.\n\n<h3>9.7. If-None-State-Match</h3>\n\n<PRE>   If-None-State-Match = \"If-None-State-Match\" \":\" 1#Coded-URL\n</PRE>\n\n<P>The <TT>If-None-State-Match</TT> header is intended to have similar\n   functionality to the <TT>If-None-Match</TT> header defined in section 14.26\n   of RFC 2068.  However the if-none-state-match header is intended for\n   use with any URI which represents state information about a\n   resource, referred to as a state token.  A typical example is a lock\n   token.\n\n<P>If any of the state tokens identifies the current state of the\n   resource, the server MUST NOT perform the requested method.\n   Instead, if the request method was <TT>GET</TT>, <TT>HEAD</TT>, <TT>INDEX</TT>, or <TT>PROPFIND</TT>,\n   the server SHOULD respond with a 304 Not Modified response,\n   including the cache-related entity-header fields (particularly ETag)\n   of the current state of the resource.  For all other request\n   methods, the server MUST respond with a status of 412 Precondition\n   Failed.\n\n<P>If none of the state tokens identifies the current state of the\n   resource, the server MAY perform the requested method.\n\n<P>If any of the tokens is not recognized then the method MUST fail\n   with a 412 Precondition Failed.\n\n<P>Note that the \"AND\" and \"OR\" keywords specified with the <TT>If-State-Match</TT> header are intentionally not defined for If-None-State-Match,\n   because this functionality is not required.\n\n<h3>9.8. If-State-Match</h3>\n\n<PRE>   If-State-Match = \"If-State-Match\" \":\" (\"AND\" | \"OR\") 1#Coded-URL\n</PRE>\n\n<P>The <TT>If-State-Match</TT> header is intended to have similar functionality\n   to the <TT>If-Match</TT> header defined in section 14.25 of RFC 2068.\n   However the <TT>If-State-Match</TT> header is intended for use with any URI\n   which represents state information about a resource.  A typical\n   example is a lock token.\n\n<P>If the AND keyword is used and all of the state tokens identify the\n   state of the resource, then the server MAY perform the requested\n   method.  If the OR keyword is used and any of the state tokens\n   identifies the current state of the resource, then the server MAY\n   perform the requested method.  If the keyword requirement for the\n   the keyword used is not met, the server MUST NOT perform the\n   requested method, and MUST return a 412 Precondition Failed\n   response.\n\n<P>If any of the tokens is not recognized then the method MUST fail\n   with a 412 Precondition Failed.\n\n<h3>9.9. Lock-Info Request Header</h3>\n\n<PRE>   LockInfo = \"Lock-Info\" \":\" DAVLockType SP DAVLockScope [SP\n   AdditionalLocks] [SP Lock-Tree]\n   DAVLockType = \"LockType\" \"=\" DAVLockTypeValue\n   DAVLockTypeValue = (\"Write\" | Extend)\n   DAVLockScope = \"LockScope\" \"=\" DAVLockScopeValue\n   DAVLockScopeValue = (\"Exclusive\" |\"Shared\" | Extend)\n   AdditionalLocks = \"AddLocks\" \"=\" 1*(\"&lt;\" URI \"&gt;\")\n   Lock-Tree = \"Lock-Tree\" \"=\" (\"T\" | \"F\")\n</PRE>\n\n<P>The Lock-Info request header specifies the scope and type of a lock\n   for a <TT>LOCK</TT> method request.  The syntax specification below is\n   extensible, allowing new type and scope identifiers to be added.\n\n<P>The LockType field specifies the access type of the lock.  At\n   present, this specification only defines one lock type, the \"Write\"\n   lock.  The LockScope field specifies whether the lock is an\n   exclusive lock, or a shared lock.  The AddLocks field specifies\n   additional URIs, beyond the Request-URI, to which the lock request\n   applies.  The LockTree field is used to specify recursive locks.  If\n   the LockTree field is \"T\", the lock request applies to the hierarchy\n   traversal of the internal member resources of the Request-URI, and\n   the AddLocks URIs, inclusive of the Request-URI and the AddLocks\n   URIs.  It is not an error if LockTree is \"T\", and the Request-URI or\n   the AddLocks URIs have no internal member resources.  By default,\n   the value of LockTree is \"F\", and this field MAY be omitted when its\n   value is \"F\".\n\n<h3>9.10. Lock-Token Request Header</h3>\n\n<PRE>   Lock-Token = \"Lock-Token\" \":\" 1#Coded-URL\n</PRE>\n\n<P>The Lock-Token request header, containing a lock token owned by the\n   requesting principal, is used by the principal to indicate that the\n   principal is aware of the existence of the lock specified by the\n   lock token.\n\n<P>If the following conditions are met:\n\n   1) The method is restricted by a lock type that requires the\n   submission of a lock token, such as a write lock,\n   2) The user-agent has authenticated itself as a principal,\n   3) The user-agent is submitting a method request to a resource on\n   which the principal owns a write lock,\n\n<P>Then:\n\n   1) The method request MUST include a <TT>Lock-Token</TT> header with the lock\n      token, or,\n   2) The method MUST fail with a 409 Conflict status code.\n\n<P>If multiple resources are involved with a method, such as a <TT>COPY</TT> or\n   <TT>MOVE</TT> method, then the lock tokens, if any, for all involved\n   resources, MUST be included in the Lock-Token request header.\n\n<P>For example, Program A, used by user A, takes out a write lock on a\n   resource.  Program A then makes a number of <TT>PUT</TT> requests on the\n   locked resource.  All the requests contain a Lock-Token request\n   header that includes the write lock state token.  Program B, also\n   run by User A, then proceeds to perform a <TT>PUT</TT> to the locked\n   resource.  However, program B was not aware of the existence of the\n   lock and so does not include the appropriate Lock-Token request\n   header.  The method is rejected even though principal A is\n   authorized to perform the <TT>PUT</TT>.  Program B can, if it so chooses, now\n   perform lock discovery and obtain the lock token.  Note that\n   programs A and B can perform GETs without using the Lock-Token\n   header because the ability to perform a <TT>GET</TT> is not affected by a\n   write lock.\n\n<P>Having a lock token provides no special access rights.  Anyone can\n   find out anyone else's lock token by performing lock discovery.\n   Locks are to be enforced based upon whatever authentication\n   mechanism is used by the server, not based on the secrecy of the\n   token values.\n\n<h3>9.11. Lock-Token Response Header</h3>\n\n<PRE>   Lock-Token = \"Lock-Token\" \":\" Coded-URL\n</PRE>\n\n<P>If a resource is successfully locked then a <TT>Lock-Token</TT> header will\n   be returned containing the lock token that represents the lock.\n\n<h3>9.12. Overwrite Header</h3>\n\n<PRE>   Overwrite = \"Overwrite\" \":\" (\"T\" | \"F\")\n</PRE>\n\n<P>The <TT>Overwrite</TT> header specifies whether the server should overwrite\n   the state of a non-null destination resource during a <TT>COPY</TT> or <TT>MOVE</TT>.\n   A value of \"F\" states that the server MUST NOT perform the <TT>COPY</TT> or\n   <TT>MOVE</TT> operation if the state of the destination resource is non-null.\n   By default, the value of Overwrite is \"T,\" and a client MAY omit\n   this header from a request when its value is \"T.\" While the\n   <TT>Overwrite</TT> header appears to duplicate the functionality of the If-Match: * header of HTTP/1.1, If-Match applies only to the Request-URI, and not to the Destination of a <TT>COPY</TT> or <TT>MOVE</TT>.\n\n<P>If a <TT>COPY</TT> or <TT>MOVE</TT> is not performed due to the value of the Overwrite\n   header, the method MUST fail with a 409 Conflict status code.\n\n<h3>9.13. Propfind Request Header</h3>\n\n<PRE>   Propfind = \"Propfind\" \":\" (\"allprop\" | \"propname\" | RFC-Reg |\n   1*(Property-Name))\n</PRE>\n\n<P>The <TT>Propfind</TT> header is used to specify which properties are to be\n   returned in a <TT>PROPFIND</TT> method.  The properties are identified by\n   their URIs.  Two special tokens are defined for use with the\n   <TT>Propfind</TT> header, allprop and propname.  The allprop token specifies\n   that all property names and values on the resource are to be\n   returned.  The propname token specifies that only a list of property\n   names on the resource are to be returned.\n\n<h3>9.14. Status-URI Response Header</h3>\n\n<P>The Status-URI response header MAY be used with the 102 Processing\n   response code to inform the client as to the status of a method.\n\n<PRE>   Status-URI = \"Status-URI\" \":\" *(Status-Code \"&lt;\" URI \"&gt;\") ; Status-\n   Code is defined in 6.1.1 of [Fielding et al., 1997]\n</PRE>\n\n<P>The URIs listed in the header are source resources which have been\n   affected by the outstanding method.  The status code indicates the\n   resolution of the method on the identified resource.  So, for\n   example, if a <TT>MOVE</TT> method on a collection is outstanding and a 102\n   \"Processing\" response with a Status-URI response header is returned,\n   the included URIs will indicate resources that have had move\n   attempted on them and what the result was.\n\n<h3>9.15. Timeout Header</h3>\n\n<PRE>   TimeOut = \"Timeout\" \":\" 1#TimeType\n   TimeType = (\"Second-\" DAVTimeOutVal | \"Infinite\" | Other)\n   DAVTimeOutVal = 1*digit\n   Other = Extend field-value   ; See section 4.2 of RFC 2068\n</PRE>\n\n<P>Clients MAY include <TT>Timeout</TT> headers in their <TT>LOCK</TT> requests.\n   However, the server is not required to honor or even consider these\n   requests.  Clients MUST NOT submit a Timeout request header with any\n   method other than a <TT>LOCK</TT> method.\n\n<P>A Timeout request header MUST contain at least one TimeType and MAY\n   contain multiple TimeType entries. The purpose of listing multiple\n   TimeType entries is to indicate multiple different values and value\n   types that are acceptable to the client.  The client lists the\n   TimeType entries in order of preference.\n\n<P>The Timeout response header MUST use a Second value, Infinite, or a\n   TimeType the client has indicated familiarity with.  The server MAY\n   assume a client is familiar with any TimeType submitted in a Timeout\n   header.\n\n<P>The \"Second\" TimeType specifies the number of seconds that MUST\n   elapse between granting of the lock at the server, and the automatic\n   removal of the lock.  A server MUST not generate a timeout value for\n   \"Second\" greater than 2^32-1.\n\n<P>The timeout counter is restarted any time an owner of the lock sends\n   a method to any member of the lock, including unsupported methods,\n   or methods which are unsuccessful.  It is recommended that the <TT>HEAD</TT>\n   method be used when the goal is simply to restart the timeout\n   counter.\n\n<P>If the timeout expires then the lock is lost.  Specifically the\n   server SHOULD act as if an <TT>UNLOCK</TT> method was executed by the server\n   on the resource using the lock token of the timed-out lock,\n   performed with its override authority. Thus logs should be updated\n   with the disposition of the lock, notifications should be sent,\n   etc., just as they would be for an <TT>UNLOCK</TT> request.\n\n<P>Servers are advised to pay close attention to the values submitted\n   by clients, as they will be indicative of the type of activity the\n   client intends to perform.  For example, an applet running in a\n   browser may need to lock a resource, but because of the instability\n   of the environment within which the applet is running, the applet\n   may be turned off without warning.  As a result, the applet is\n   likely to ask for a relatively small timeout value so that if the\n   applet dies, the lock can be quickly harvested.  However, a document\n   management system is likely to ask for an extremely long timeout\n   because its user may be planning on going off-line.\n\n<h2>10. Response Code Extensions to HTTP/1.1</h2>\n\n<P>The following response codes are added to those defined in HTTP/1.1\n   [Fielding et al., 1997].\n\n<h3>10.1. 102 Processing</h3>\n\n<P>Methods can potentially take a long period of time to process,\n   especially methods that support the <TT>Depth</TT> header.  In such cases the\n   client may time-out the connection while waiting for a response.  To\n   prevent this the server MAY return a 102 response code to indicate\n   to the client that the server is still processing the method.\n\n<P>If a method is taking longer than 20 seconds (a reasonable, but\n   arbitrary value) to process the server SHOULD return a 102\n   \"Processing\" response.\n\n<h3>10.2. 207 Multi-Status</h3>\n\n<P>The response requires providing status for multiple independent\n   operations.\n\n<h3>10.3. 418 Unprocessable Entity</h3>\n\n<P>The server understands the content type of the request entity, but\n   was unable to process the contained instructions.\n\n<h3>10.4. 419 Insufficient Space on Resource</h3>\n\n<P>The resource does not have sufficient space to record the state of\n   the resource after the execution of this method.\n\n<h3>10.5. 420 Method Failure</h3>\n\n<P>The method was not executed on a particular resource within its\n   scope because some part of the method's execution failed causing the\n   entire method to be aborted.  For example, if a resource could not\n   be moved as part of a <TT>MOVE</TT> method, all the other resources would\n   fail with a 420 Method Failure.\n\n<h3>10.6. 421 Destination Locked</h3>\n\n<P>The destination resource of a method is locked, and either the\n   request did not contain a valid <TT>Lock-Info</TT> header, or the Lock-Info\n   header identifies a lock held by another principal.\n\n\n<h2>11. Multi-Status Response</h2>\n\n<P>The default 207 Multi-Status response body is a text/xml HTTP entity\n   that contains a single XML element called <TT> multistatus</TT>, which\n   contains a set of XML elements called response, one for each 200,\n   300, 400, and 500 series status code generated during the method\n   invocation.  100 series status codes MUST NOT be recorded in a\n   response XML element.\n\n<h3>11.1. <TT> multistatus</TT> XML Element</h3>\n\n<BR>   Name:       <TT>multistatus</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains multiple response messages.\n<BR>   Parent:     Any\n<BR>   Value:      1*response [responsedescription]\n<BR>   Description: The responsedescription at the top level is used to\n   provide a general message describing the overarching nature of the\n   response.  If this value is available an application MAY use it\n   instead of presenting the individual response descriptions contained\n   within the responses.\n\n<h3>11.2. response XML Element</h3>\n\n<BR>   Name:       <TT>response</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Holds a single response\n<BR>   Parent:     <TT> multistatus</TT>\n<BR>   Value:      <TT>href</TT> [prop] status [responsedescription]\n<BR>   Description: Prop MUST contain one or more empty XML elements\n   representing the names of properties.  Multiple properties may be\n   included if the same response applies to them all.  If <TT>href</TT> is used\n   then the response refers to a problem with the referenced resource,\n   not a property.\n\n<h3>11.3. status XML Element</h3>\n\n<BR>   Name:       <TT>status</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Holds a single HTTP status-line\n<BR>   Parent:     response\n<BR>   Value:      status-line   ;status-line defined in [Fielding et al.,\n   1997]\n\n<h3>11.4. responsedescription XML Element</h3>\n\n<BR>   Name:       <TT>responsedescription</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains a message that can be displayed to the user\n   explaining the nature of the response.\n<BR>   Parent:     <TT> multistatus</TT> | response\n<BR>   Value:      Any\n<BR>   Description: This XML element provides information suitable to be\n   presented to a user.\n\n\n<h2>12. Generic DAV XML Elements</h2>\n\n<h3>12.1. <TT>href</TT> XML Element</h3>\n\n<BR>   Name:       <TT>href</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To identify that the content of the element is a URI.\n<BR>   Parent:     Any\n<BR>   Value:      URI ; See section 3.2.1 of [Fielding et al., 1997]\n\n<h3>12.2. link XML Element</h3>\n\n<BR>   Name:       <TT>link</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To identify a property as a link and to contain the\n   source and destination of that link.\n<BR>   Values=     1*<TT>src</TT> 1*<TT>dst</TT>\n<BR>   Description: Link is used to provide the sources and destinations of\n   a link.  The type of the property containing the link XML element\n   provides the type of the link.  Link is a multi-valued element, so\n   multiple Links may be used together to indicate multiple links with\n   the same type.\n\n\n<h4>12.2.1. <TT>src</TT> XML Element</h4>\n\n<BR>   Name:       <TT><TT>src</TT></TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To indicate the source of a link.\n<BR>   Parent:     link\n<BR>   Values=     URI\n\n\n<h4>12.2.2. <TT>dst</TT> XML Element</h4>\n\n<BR>   Name:       <TT><TT>dst</TT></TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To indicate the destination of a link\n<BR>   Parent:     link\n<BR>   Values=     URI\n\n\n<h4>12.2.3. Example</h4>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;?namespace href = \"http://www.foocorp.com/Project/\" AS = \"F\"?&gt;\n   &lt;D:prop&gt;\n     &lt;D:Source&gt;\n          &lt;D:link&gt;\n               &lt;F:projfiles&gt;Source&lt;/F:projfiles&gt;\n               &lt;D:src&gt;http://foo.bar/program&lt;/D:src&gt;\n               &lt;D:dst&gt;http://foo.bar/src/main.c&lt;/D:dst&gt;\n          &lt;/D:link&gt;\n          &lt;D:link&gt;\n               &lt;F:projfiles&gt;Library&lt;/F:projfiles&gt;\n               &lt;D:src&gt;http://foo.bar/program&lt;/D:src&gt;\n               &lt;D:dst&gt;http://foo.bar/src/main.lib&lt;/D:dst&gt;\n          &lt;/D:link&gt;\n          &lt;D:link&gt;\n               &lt;F:projfiles&gt;Makefile&lt;/F:projfiles&gt;\n               &lt;D:src&gt;http://foo.bar/program&lt;/D:src&gt;\n               &lt;D:dst&gt;http://foo.bar/src/makefile&lt;/D:dst&gt;\n          &lt;/D:link&gt;\n     &lt;/D:Source&gt;\n   &lt;/D:prop&gt;\n</PRE>\n\n<P>In this example the resource http://foo.bar/program has a <TT>source</TT>\n   property that contains three links.  Each link contains three\n   elements, two of which, <TT>src</TT> and <TT>dst</TT>, are part of the DAV schema\n   defined in this document, and one which is defined by the schema\n   http://www.foocorp.com/project/ (Source, Library, and Makefile).  A\n   client which only implements the elements in the DAV spec will not\n   understand the foocorp elements and will ignore them, thus seeing\n   the expected source and destination links.  An enhanced client may\n   know about the foocorp elements and be able to present the user with\n   additional information about the links.  This example demonstrates\n   the power of XML markup that allows for element values to be\n   enhanced without breaking older clients.\n\n<h3>12.3. prop XML element</h3>\n\n<BR>   Name:       <TT>prop</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains properties related to a resource.\n<BR>   Parent:     Any\n<BR>   Values:     XML Elements\n<BR>   Description: The prop XML element is a generic container for\n   properties defined on resources.  All elements inside prop MUST\n   define properties related to the resource.  No other elements may be\n   used inside of a prop element.\n\n\n<h2>13. DAV Properties</h2>\n\n<h3>13.1. creationdate Property</h3>\n\n<BR>   Name:       <TT>creationdate</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    The time and date the resource was created.\n<BR>   Value:      The time and date MUST be given in ISO 8601 format\n   [ISO8601]\n<BR>   Description: This property SHOULD be defined on all DAV compliant\n   resources.  If present, it contains a timestamp of the moment when\n   the resource was created (i.e., the moment it had non-null state).\n\n<h3>13.2. displayname Property</h3>\n\n<BR>   Name:       <TT>displayname</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    A name for the resource that is suitable for\n   presentation to a user.\n<BR>   Value:      Any valid XML character data (as defined in [Bray,\n   Sperberg-McQueen, 1997])\n<BR>   Description:This property SHOULD be defined on all DAV compliant\n   resources.  If present, the property contains a description of the\n   resource that is suitable for presentation to a user.\n\n<h3>13.3. get-content-language Property</h3>\n\n<BR>   Name:       <TT>get-content-language</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Content-Language</TT> header returned by a <TT>GET</TT>\n   without accept headers.  If no <TT>Content-Language</TT> header is available,\n   this property MUST NOT exist.\n<BR>   Value:      language-tag   ;language-tag is defined in section 14.13\n   of RFC 2068\n\n<h3>13.4. get-content-length Property</h3>\n\n<BR>   Name:       <TT>get-content-length</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Content-Length</TT> header returned by a <TT>GET</TT>\n   without accept headers.  If no <TT>Content-Length</TT> header is available,\n   this property MUST NOT exist.\n<BR>   Value:      content-length ; see section 14.14 of RFC 2068\n\n<h3>13.5. get-content-type Property</h3>\n\n<BR>   Name:       <TT>get-content-type</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Content-Type</TT> header returned by a <TT>GET</TT>\n   without accept headers.  If no <TT>Content-Type</TT> header is available,\n   this property MUST NOT exist.\n<BR>   Value:      media-type   ; defined in Section 3.7 of [Fielding et\n   al., 1997]\n\n<h3>13.6. get-etag Property</h3>\n\n<BR>   Name:       <TT>get-etag</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>ETag</TT> header returned by a <TT>GET</TT> without\n   accept headers.  If no <TT>ETag</TT> header is available, this property MUST\n   NOT exist.\n<BR>   Value:      entity-tag  ; defined in Section 3.11 of [Fielding et\n   al., 1997]\n<BR>   Description:Note that the ETag on some resource may reflect changes\n   in any part of the state of the resource, not necessarily just a\n   change to the response to the <TT>GET</TT> method.  For example, a change in\n   the ACL may cause the ETag to change.\n\n<h3>13.7. get-last-modified Property</h3>\n\n<BR>   Name:       <TT>get-last-modified</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Last-Modified</TT> header returned by a <TT>GET</TT>\n   method without accept headers.  If no <TT>Last-Modified</TT> header is\n   available, this property MUST NOT exist.\n<BR>   Value:      HTTP-date  ; defined in Section 3.3.1 of [Fielding et\n   al., 1997]\n<BR>   Description:Note that the last-modified date on some resource may\n   reflect changes in any part of the state of the resource, not\n   necessarily just a change to the response to the <TT>GET</TT> method.  For\n   example, a change in a property may cause the last-modified date to\n   change.\n\n<h3>13.8. index-content-language Property</h3>\n\n<BR>   Name:       <TT>index-content-language</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Content-Language</TT> header returned by an\n   <TT>INDEX</TT> without accept headers.  If no <TT>Content-Language</TT> header is\n   available, this property MUST NOT exist.\n<BR>   Value:      language-tag   ;language-tag is defined in section 14.13\n   of RFC 2068\n\n<h3>13.9. index-content-length Property</h3>\n\n<BR>   Name:       <TT>index-content-length</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Content-Length</TT> header returned by an <TT>INDEX</TT>\n   without accept headers.  If no <TT>Content-Length</TT> header is available,\n   this property MUST NOT exist.\n<BR>   Value:      content-length ; see section 14.14 of RFC 2068\n\n<h3>13.10. index-content-type Property</h3>\n\n<BR>   Name:       <TT>index-content-type</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Content-Type</TT> header returned by an <TT>INDEX</TT>\n   without accept headers.  If no <TT>Content-Type</TT> header is available,\n   this property MUST NOT exist.\n<BR>   Value:      media-type   ; defined in Section 3.7 of [Fielding et\n   al., 1997]\n\n<h3>13.11. index-etag Property</h3>\n\n<BR>   Name:       <TT>index-etag</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>ETag</TT> header returned by an <TT>INDEX</TT> without\n   accept headers.  If no <TT>ETag</TT> header is available, this property MUST\n   NOT exist.\n<BR>   Value:      entity-tag  ; defined in Section 3.11 of [Fielding et\n   al., 1997]\n<BR>   Description:Note that the ETag on some resource may reflect changes\n   in any part of the state of the resource, not necessarily just a\n   change to the response to the <TT>INDEX</TT> method.  For example, a change\n   in the ACL may cause the ETag to change.\n\n<h3>13.12. index-last-modified Property</h3>\n\n<BR>   Name:       <TT>index-last-modified</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Contains the <TT>Last-Modified</TT> header returned by an <TT>INDEX</TT>\n   method without accept headers.  If no <TT>Last-Modified</TT> header is\n   available, this property MUST NOT exist.\n<BR>   Value:      HTTP-date  ; defined in Section 3.3.1 of [Fielding et\n   al., 1997]\n<BR>   Description:Note that the last-modified date on some resource may\n   reflect changes in any part of the state of the resource, not\n   necessarily just a change to the response to the <TT>INDEX</TT> method.  For\n   example, a change in a property may cause the last-modified date to\n   change.\n\n<h3>13.13. lockdiscovery Property</h3>\n\n<BR>   Name:       <TT>lockdiscovery</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To discover what locks are active on a resource\n<BR>   Values=     *activelock\n<BR>   Description:The lockdiscovery property returns a listing of who has\n   a lock, what type of lock he have, the timeout type and the time\n   remaining on the timeout, and the associated lock token.  The server\n   is free to withhold any or all of this information if the requesting\n   principal does not have sufficient access rights to see the\n   requested data.  A server which supports locks MUST provide the\n   lockdiscovery property on any resource with locks on it.\n\n\n<h4>13.13.1. activelock XML Element</h4>\n\n<BR>   Name:       <TT>activelock</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    A multivalued XML element that describes a particular\n   active lock on a resource\n<BR>   Parent:     lockdiscovery\n<BR>   Values=     locktype lockscope [addlocks] owner timeout locktoken\n\n\n<h4>13.13.2. owner XML Element</h4>\n\n<BR>   Name:       <TT>owner</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Returns owner information\n<BR>   Parent:     activelock\n<BR>   Values=     XML:REF | *PCDATA\n\n\n<h4>13.13.3. timeout XML Element</h4>\n\n<BR>   Name:       <TT>timeout</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Returns information about the timeout associated with\n   the lock\n<BR>   Parent:     activelock\n<BR>   Values=     TimeType\n\n\n<h4>13.13.4. addlocks XML Element</h4>\n\n<BR>   Name:       <TT>addlocks</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Lists additional resources associated with this lock, if\n   any.\n<BR>   Parent:     activelock\n<BR>   Values=     1*href\n\n\n<h4>13.13.5. locktoken XML Element</h4>\n\n<BR>   Name:       <TT>locktoken</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Returns the lock token\n<BR>   Parent:     activelock\n<BR>   Values=     <TT>href</TT>\n<BR>   Description:The <TT>href</TT> contains a Lock-Token-URL.\n\n\n<h4>13.13.6. Example</h4>\n\n<PRE>\n   PROPFIND /container/ HTTP/1.1\n   Host: www.foo.bar\n   Content-Length: xxxx\n   Content-Type: text/xml\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:propfind&gt;\n     &lt;D:prop&gt;&lt;lockdiscovery/&gt;&lt;/D:prop&gt;\n   &lt;/D:propfind&gt;\n</PRE>\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:prop&gt;\n               &lt;D:lockdiscovery&gt;\n                    &lt;D:activelock&gt;\n                         &lt;D:locktype&gt;write&lt;/D:locktype&gt;\n                         &lt;D:lockscope&gt;exclusive&lt;/D:lockscope&gt;\n                         &lt;D:addlocks&gt;\n                              &lt;D:href&gt;http://foo.com/doc/&lt;/D:href&gt;\n                         &lt;/D:addlocks&gt;\n                         &lt;D:owner&gt;Jane Smith&lt;/D:owner&gt;\n                         &lt;D:timeout&gt;Infinite&lt;/D:timeout&gt;\n                         &lt;D:locktoken&gt;\n                              &lt;D:href&gt;iamuri:unique!!!!!&lt;/D:href&gt;\n                         &lt;/D:locktoken&gt;\n                    &lt;/D:activelock&gt;\n               &lt;/D:lockdiscovery&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n   &lt;/D:multistatus&gt;\n</PRE>\n\n<P>This resource has a single exclusive write lock on it, with an\n   infinite timeout.  This same lock also covers the resource\n   http://foo.com/doc/.\n\n<h3>13.14. <TT>resourcetype</TT> Property</h3>\n\n<BR>   Name:       <TT>resourcetype</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    This property contains a series of XML elements that\n   specify information regarding the nature of the resource.  This\n   specification only defines a single value, collection.\n<BR>   Value:      XML elements\n<BR>   Description:This property MUST be defined on all DAV compliant\n   resources.  The default value is empty.\n\n<h4>13.14.1. collection XML Element</h4>\n\n<BR>   Name:       <TT>collection</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Identifies the associated resource as a collection.\n   Collection resources MUST define this value with the <TT>resourcetype</TT>\n   property.\n<BR>   Parent:     <TT>resourcetype</TT>\n<BR>   Values:          None\n\n<h3>13.15. Source Link Property Type</h3>\n\n<BR>   Name:       <TT>source</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/link/\n<BR>   Purpose:    The destination of the <TT>source</TT> link identifies the\n   resource that contains the unprocessed source of the link's source.\n<BR>   Parent:     None\n<BR>   Value:      An XML document with zero or more link XML elements.\n<br>   Discussion: The source of the link (<TT>src</TT>) is typically the URI of the\n   output resource on which the link is defined, and there is typically\n   only one destination (<TT>dst</TT>) of the link, which is the URI where the\n   unprocessed source of the resource may be accessed.  When more than\n   one link destination exists, this specification asserts no policy on\n   ordering.\n\n<h3>13.16. supportedlock Property</h3>\n\n<BR>   Name:       <TT>supportedlock</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    To provide a listing of the lock capabilities supported\n   by the resource.\n<BR>   Values:     An XML document containing zero or more LockEntry XML\n   elements.\n<BR>   Description:The supportedlock property of a resource returns a\n   listing of the combinations of scope and access types which may be\n   specified in a lock request on the resource.  Note that the actual\n   contents are themselves controlled by access controls so a server is\n   not required to provide information the client is not authorized to\n   see.  If supportedlock is available on \"*\" then it MUST define the\n   set of locks allowed on all resources on that server.\n\n<h4>13.16.1. lockentry XML Element</h4>\n\n<BR>   Name:       <TT>lockentry</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Defines a DAVLockType/LockScope pair that may be legally\n   used with a <TT>LOCK</TT> on the specified resource.\n<BR>   Parent:     supportedlock\n<BR>   Values=     locktype lockscope\n\n\n<h4>13.16.2. locktype XML Element</h4>\n\n<BR>   Name:       <TT>locktype</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Lists a DAVLockType\n<BR>   Parent:     lockentry\n<BR>   Values=     DAVLockTypeValue\n\n<h4>13.16.3. lockscope XML Element</h4>\n\n<BR>   Name:       <TT>lockscope</TT>\n<BR>   Namespace:  http://www.ietf.org/standards/dav/\n<BR>   Purpose:    Lists a DAVLockScope\n<BR>   Parent:     lockentry\n<BR>   Values:     DAVLockScopeValue\n\n<h4>13.16.4. Example</h4>\n\n<PRE>\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n</PRE>\n\n   Content-Length: xxxx\n   Content-Type: text/xml\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:propfind&gt;\n     &lt;D:prop&gt;&lt;supportedlock/&gt;&lt;/D:prop&gt;\n   &lt;/D:propfind&gt;\n</PRE>\n<PRE>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n</PRE>\n\n<PRE>   &lt;?XML version=\"1.0\"&gt;\n   &lt;?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?&gt;\n   &lt;D:multistatus&gt;\n     &lt;D:response&gt;\n          &lt;D:prop&gt;\n               &lt;D:supportedlock&gt;\n                    &lt;D:LockEntry&gt;\n                         &lt;D:locktype&gt;Write&lt;/D:locktype&gt;\n                         &lt;D:lockscope&gt;Exclusive&lt;/D:lockscope&gt;\n                    &lt;/D:LockEntry&gt;\n                    &lt;D:LockEntry&gt;\n                         &lt;D:locktype&gt;Write&lt;/D:locktype&gt;\n                         &lt;D:lockscope&gt;Shared&lt;/D:lockscope&gt;\n                    &lt;/D:LockEntry&gt;\n               &lt;/D:supportedlock&gt;\n          &lt;/D:prop&gt;\n          &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;\n     &lt;/D:response&gt;\n   &lt;/D:multistatus&gt;\n</PRE>\n\n\n<h2>14. DAV Compliance Levels</h2>\n\n<P>A DAV compliant resource can choose from two levels of compliance.\n   A client can discover which level a resource supports by executing\n   <TT>OPTIONS</TT> on the resource, and examining the \"DAV\" header which is\n   returned.\n\n<P>Since this document describes extensions to the HTTP/1.1 protocol,\n   minimally all DAV compliant resources, clients, and proxies MUST be\n   compliant with RFC 2068 [Fielding et al., 1997].\n\n<h3>14.1. Level 1</h3>\n\n<P>A level 1 compliant resource MUST meet all \"MUST\" requirements in\n   all sections of this document.\n\n<h3>14.2. Level 2</h3>\n\n<P>A level 2 compliant resource MUST meet all level 1 requirements and\n   support the supportedlock property as well as the <TT>LOCK</TT> method.\n\n\n<h2>15. Internationalization Considerations</h2>\n\n<P>In the realm of internationalization issues, this specification is\n   substantively in compliance with the IETF Character Set Policy\n   [Alvestrand, 1997]. In this specification, human-readable fields can\n   be found in either the value of a property, or in an error message\n   returned in a response entity body.  In both cases, the human-readable content is encoded using XML, which has explicit provisions\n   for character set tagging and encoding, and requires by default that\n   XML processors read XML elements encoded using the UTF-8 and UCS-2\n   encodings of the ISO 10646 basic multilingual plane.  Furthermore,\n   XML contains provisions for encoding XML elements using other\n   encoding schemes, notable among them UCS-4, which permits encoding\n   of characters from any ISO 10646 character plane.\n\n<P>The default character set encoding for XML data in this\n   specification, and in general, is UTF-8.  WebDAV compliant\n   applications MUST support the UTF-8 and UCS-2 character set\n   encodings for XML elements, and SHOULD support the UCS-4 encoding.\n   The XML character set encoding declaration for each supported\n   character set MUST also be supported, since it is by using this\n   encoding declaration that an XML processor determines the encoding\n   of an element.\n\n<P>XML also provides language tagging capability which provides the\n   ability to specify the language of the contents of a particular XML\n   element.  Although XML, and hence WebDAV, does not use RFC 1766\n   language tags for its language names, the benefit of using standard\n   XML in this context outweighs the advantage of using RFC 1766\n   language tags.\n\n<P>Names used within this specification fall into two categories: names\n   specific to protocol elements such as methods and headers, names of\n   XML elements, and names of properties.  Naming of protocol elements\n   follows the precedent of HTTP, using English names encoded in\n   USASCII for methods and headers.  Since these protocol elements are\n   not visible to users, and are in fact simply long token identifiers,\n   they do not need to support encoding in multiple character sets.\n   Similarly, though the names of XML elements used in this\n   specification are English names encoded in UTF-8, these names are\n   not visible to the user, and hence do not need to support multiple\n   character set encodings.\n\n<P>The name of a property defined on a resource is a URI.  Although\n   some applications (e.g., a generic property viewer) will display\n   property URIs directly to their users, it is expected that the\n   typical application will use a fixed set of properties, and will\n   provide a mapping from the property name URI to a human-readable\n   field when displaying the property name to a user.  It is only in\n   the case where the set of properties is not known ahead of time that\n   an application need display a property name URI to a user. We\n   recommend that applications provide human-readable property names\n   wherever feasible.\n\n<P>For error reporting, we follow the convention of HTTP/1.1 status\n   codes, including with each status code a short, English description\n   of the code (e.g., 421 Destination Locked).  While the possibility\n   exists that a poorly crafted user agent would display this message\n   to a user, internationalized applications will ignore this message,\n   and display an appropriate message in the user's language and\n   character set.\n\n<P>Since interoperation of clients and servers does not require locale\n   information, this specification does not specify any mechanism for\n   transmission of this information.\n\n\n<h2>16. Security Considerations</h2>\n   [TBD]\n\n\n<h2>17. Terminology</h2>\n\n<P>Collection - A resource that contains member resources.\n\n<P>Member Resource - A resource contained by a collection.  There are\n   two types of member resources: external and internal.\n\n<P>Internal Member Resource - A member resource of a collection whose\n   URI is relative to the URI of the collection.\n\n<P>External Member Resource - A member resource of a collection with an\n   absolute URI that is not relative to its parent's URI.\n\n<P>Property - A name/value pair that contains descriptive information\n   about a resource.\n\n<P>Live Property - A property whose semantics and syntax are enforced\n   by the server.  For example, a live \"content-length\" property would\n   have its value, the length of the entity returned by a <TT>GET</TT> request,\n   automatically calculated by the server.\n\n<P>Dead Property - A property whose semantics and syntax are not\n   enforced by the server.  The server only records the value of a dead\n   property; the client is responsible for maintaining the consistency\n   of the syntax and semantics of a dead property.\n\n\n<h2>18. Copyright</h2>\n\n<P>The following copyright notice is copied from RFC 2026 chapter 10.4,\n   and describes the applicable copyright for this document\n\n<P>Copyright (C) The Internet Society November 19, 1997. All Rights\n   Reserved.\n\n<P>This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph\n   are included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English.\n\n<P>The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assignees.\n\n<P>This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\n\n<h2>19. Acknowledgements</h2>\n\n<P>A specification such as this thrives on piercing critical review and\n   withers from apathetic neglect.  The authors gratefully acknowledge\n   the contributions of the following people, whose insights were so\n   valuable at every stage of our work.\n\n<P>Terry Allen, Harald Alvestrand, Alan Babich, Dylan Barrell, Bernard\n   Chester, Tim Berners-Lee, Dan Connolly, Jim Cunningham, Ron Daniel,\n   Jr., Jim Davis, Keith Dawson, Mark Day, Martin Duerst, David Durand,\n   Lee Farrell, Chuck Fay, Roy Fielding, Mark Fisher, Alan Freier,\n   George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis Hamilton,\n   Steve Henning, Alex Hopmann, Andre van der Hoek, Ben Laurie, Paul\n   Leach, Ora Lassila, Karen MacArthur, Steven Martin, Larry Masinter,\n   Michael Mealling, Keith Moore, Henrik Nielsen, Kenji Ota, Bob\n   Parker, Glenn Peterson, Jon Radoff, Saveen Reddy, Henry Sanders,\n   Christopher Seiwald, Judith Slein, Mike Spreitzer, Einar Stefferud,\n   Ralph Swick, Kenji Takahashi, Richard N. Taylor, Robert Thau, John\n   Turner, Sankar Virdhagriswaran, Fabio Vitali, Gregory Woodhouse, and\n   Lauren Wood.\n\n<P>One from this list deserves special mention.  The contributions by\n   Larry Masinter have been invaluable, both in helping the formation\n   of the working group and in patiently coaching the authors along the\n   way.  In so many ways he has set high standards we have toiled to\n   meet.\n\n<h2>20. References</h2>\n\n<P>   [Alvestrand, 1997] H. T. Alvestrand, \"IETF Policy on Character Sets\n   and Languages.\"  Internet-draft, work-in-progress.\n   <A HREF=\"ftp://ds.internic.net/internet-drafts/draft-alvestrand-charset-policy-02.txt\">ftp://ds.internic.net/internet-drafts/draft-alvestrand-charset-policy-02.txt</A>\n\n<P>   [Berners-Lee, 1997] T. Berners-Lee, \"Metadata Architecture.\"\n   Unpublished white paper, January 1997.\n   <A HREF=\"http://www.w3.org/pub/WWW/DesignIssues/Metadata.html\">http://www.w3.org/pub/WWW/DesignIssues/Metadata.html</A>.\n\n<P>   [Bradner, 1997] S. Bradner, \"Key words for use in RFCs to Indicate\n   Requirement Levels.\"  RFC 2119, BCP 14. Harvard University.  March,\n   1997.\n\n<P>   [Bray, Sperberg-McQueen, 1997] T. Bray, C. M. Sperberg-McQueen,\n   \"Extensible Markup Language (XML): Part I. Syntax\", WD-xml-lang.html, <A HREF=\"http://www.w3.org/pub/WWW/TR/WD-xml-lang.html\">http://www.w3.org/pub/WWW/TR/WD-xml-lang.html</A>.\n\n<P>   [Fielding et al., 1997] R. Fielding, J. Gettys, J. Mogul, H.\n   Frystyk, T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1.\"\n   RFC 2068. U.C. Irvine, DEC, MIT/LCS.  January, 1997.\n   <A HREF=\"ftp://ds.internic.net/rfc/rfc2068.txt\">ftp://ds.internic.net/rfc/rfc2068.txt</A>\n\n<P>   [Lasher, Cohen, 1995] R. Lasher, D. Cohen, \"A Format for\n   Bibliographic Records,\" RFC 1807. Stanford, Myricom. June, 1995.\n   <A HREF=\"ftp://ds.internic.net/rfc/rfc1807.txt\">ftp://ds.internic.net/rfc/rfc1807.txt</A>\n\n<P>   [Leach, Salz, 1997] P. J. Leach, R. Salz, \"UUIDs and GUIDs.\"\n   Internet-draft (expired), work-in-progress, February, 1997.\n   <A HREF=\"http://www.internic.net/internet-drafts/draft-leach-uuids-guids-00.txt\">http://www.internic.net/internet-drafts/draft-leach-uuids-guids-00.txt</A>\n\n<P>   [Maloney, 1996] M. Maloney, \"Hypertext Links in HTML.\" Internet\n   draft (expired), work-in-progress, January, 1996.\n\n<P>   [MARC, 1994] Network Development and MARC Standards, Office, ed.\n   1994. \"USMARC Format for Bibliographic Data\", 1994. Washington, DC:\n   Cataloging Distribution Service, Library of Congress.\n\n<P>   [Miller et al., 1996] J. Miller, T. Krauskopf, P. Resnick, W.\n   Treese, \"PICS Label Distribution Label Syntax and Communication\n   Protocols\" Version 1.1, W3C Recommendation REC-PICS-labels-961031.\n   <A HREF=\"http://www.w3.org/pub/WWW/TR/REC-PICS-labels-961031.html\">http://www.w3.org/pub/WWW/TR/REC-PICS-labels-961031.html</A>.\n\n<P>   [Slein et al., 1997] J. A. Slein, F. Vitali, E. J. Whitehead, Jr.,\n   D. Durand, \"Requirements for Distributed Authoring and Versioning\n   Protocol for the World Wide Web.\" RFC XXXX. Xerox, Univ. of Bologna,\n   U.C. Irvine, Boston Univ. YYY, 1997.\n   <A HREF=\"ftp://ds.internic.net/rfc/rfcXXXX.txt\">ftp://ds.internic.net/rfc/rfcXXXX.txt</A>\n\n<P>   [WebDAV, 1997] WEBDAV Design Team. \"A Proposal for Web Metadata\n   Operations.\" Unpublished manuscript.\n   <A HREF=\"http://www.ics.uci.edu/~ejw/authoring/proposals/metadata.html\">http://www.ics.uci.edu/~ejw/authoring/proposals/metadata.html</A>\n\n<P>   [Weibel et al., 1995] S. Weibel, J. Godby, E. Miller, R. Daniel,\n   \"OCLC/NCSA Metadata Workshop Report.\"\n   <A HREF=\"http://purl.oclc.org/metadata/dublin_core_report\">http://purl.oclc.org/metadata/dublin_core_report</A>.\n\n<P>   [Yergeau, 1997] F. Yergeau, \"UTF-8, a transformation format of\n   Unicode and ISO 10646\", Internet Draft, work-in-progress, draft-yergeau-utf8-rev-00.txt, <A HREF=\"http://www.internic.net/internet-drafts/draft-yergeau-utf8-rev-00.txt\">http://www.internic.net/internet-drafts/draft-yergeau-utf8-rev-00.txt</A>.\n\n<h2>21. Authors' Addresses</h2>\n\n<PRE>\n   Y. Y. Goland\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA 98052-6399\n   Email: yarong@microsoft.com\n\n   E. J. Whitehead, Jr.\n   Dept. Of Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425\n   Email: ejw@ics.uci.edu\n\n   A. Faizi\n   Netscape\n   685 East Middlefield Road\n   Mountain View, CA 94043\n   Email: asad@netscape.com\n\n   S. R. Carter\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   Email: srcarter@novell.com\n\n   D. Jensen\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   Email: dcjensen@novell.com\n</PRE>\n</BODY>\n</HTML>\n", "id": 32393.0}