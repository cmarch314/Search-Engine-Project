{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 Definition The class Triangulation 3 represents a 3 dimensional tetrahedralization of points include CGAL Triangulation 3 h Parameters The first template argument must be a model of the TriangulationTraits 3 concept The second template argument must be a model of the TriangulationDataStructure 3 concept It has the default value Triangulation data structure 3 Triangulation vertex base 3 TriangulationTraits 3 Triangulation cell base 3 TriangulationTraits 3 Inherits FromTriangulation utils 3 TypesThe class Triangulation 3 defines the following types typedef TriangulationDataStructure 3 Triangulation data structure typedef TriangulationTraits 3 Geom traits typedef TriangulationTraits 3 Point 3 Point typedef TriangulationTraits 3 Segment 3 Segment typedef TriangulationTraits 3 Triangle 3 Triangle typedef TriangulationTraits 3 Tetrahedron 3 Tetrahedron Only vertices faces and cells 3 faces are stored Edges 1 faces and facets 2 faces are not explicitly represented and thus there are no corresponding classes see Section typedef TriangulationDataStructure 3 Vertex Vertex typedef TriangulationDataStructure 3 Cell Cell typedef TriangulationDataStructure 3 Facet Facet typedef TriangulationDataStructure 3 Edge Edge The vertices and faces of the triangulations are accessed through handles iterators and circulators A handle is a type which supports the two dereference operators operator and operator The Handle concept is documented in the support library Iterators and circulators are bidirectional and non mutable The edges and facets of the triangulation can also be visited through iterators and circulators which are bidirectional and non mutable Iterators and circulators are convertible to the corresponding handles thus the user can pass them directly as arguments to the functions typedef TriangulationDataStructure 3 Vertex handle Vertex handle handle to a vertex typedef TriangulationDataStructure 3 Cell handle Cell handle handle to a cell typedef TriangulationDataStructure 3 size type size type Size type an unsigned integral type typedef TriangulationDataStructure 3 difference type difference type Difference type a signed integral type typedef TriangulationDataStructure 3 Cell iterator All cells iterator iterator over cells typedef TriangulationDataStructure 3 Facet iterator All facets iterator iterator over facets typedef TriangulationDataStructure 3 Edge iterator All edges iterator iterator over edges typedef TriangulationDataStructure 3 Vertex iterator All vertices iterator iterator over vertices Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 Finite cells iterator iterator over finite cells Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 Finite facets iterator iterator over finite facets Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 Finite edges iterator iterator over finite edges Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 Finite vertices iterator iterator over finite vertices Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 Point iterator iterator over the points corresponding to the finite vertices of the triangulation typedef TriangulationDataStructure 3 Cell circulator Cell circulator circulator over all cells incident to a given edge typedef TriangulationDataStructure 3 Facet circulator Facet circulator circulator over all facets incident to a given edge The triangulation class also defines the following enum type to specify which case occurs when locating a point in the triangulation enum Locate type VERTEX EDGE FACET CELL OUTSIDE CONVEX HULL OUTSIDE AFFINE HULL Creation Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 t TriangulationTraits 3 traits TriangulationTraits 3 Introduces a triangulation t having only one vertex which is the infinite vertex Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 t Triangulation 3 tr Copy constructor All vertices and faces are duplicated template class InputIterator Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 t InputIterator first InputIterator last TriangulationTraits 3 traits TriangulationTraits 3 Introduces a triangulation t constructed by the repeated insertion of the iterator range first last of value type Point Assignment Triangulation 3 t Triangulation 3 tr The triangulation tr is duplicated and modifying the copy after the duplication does not modify the original The previous triangulation held by t is deleted void t swap Triangulation 3 tr The triangulations tr and t are swapped t swap tr should be preferred to t tr or to t tr if tr is deleted after that Indeed there is no copy of cells and vertices thus this method runs in constant time void t clear Deletes all finite vertices and all cells of t void t Triangulation 3 Destructor All vertices including the infinite vertex and cells are deleted template class GT class Tds bool Triangulation 3 GT Tds t1 Triangulation 3 GT Tds t2 Equality operator Returns true iff there exist a bijection between the vertices of t1 and those of t2 and a bijection between the cells of t1 and those of t2 which preserve the geometry of the triangulation that is the points of each corresponding pair of vertices are equal and the tetrahedra corresponding to each pair of cells are equal up to a permutation of their vertices template class GT class Tds bool Triangulation 3 GT Tds t1 Triangulation 3 GT Tds t2 The opposite of operator Access Functions TriangulationTraits 3 t geom traits Returns a const reference to the geometric traits object TriangulationDataStructure 3 t tds Returns a const reference to the triangulation data structure advanced Non const access The responsibility of keeping a valid triangulation belongs to the user when using advanced operations allowing a direct manipulation of the tds TriangulationDataStructure 3 t tds Returns a reference to the triangulation data structure This method is mainly a help for users implementing their own triangulation algorithms advanced int t dimension Returns the dimension of the affine hull size type t number of vertices Returns the number of finite vertices size type t number of cells Returns the number of cells or if t dimension 3 Vertex handle t infinite vertex Returns the infinite vertex Cell handle t infinite cell Returns a cell incident to the infinite vertex Non constant time access functions As previously said the triangulation is a collection of cells that are either infinite or represent a finite tetrahedra where an infinite cell is a cell incident to the infinite vertex Similarly we call an edge resp facet infinite if it is incident to the infinite vertex size type t number of facets The number of facets Returns if t dimension 2 size type t number of edges The number of edges Returns if t dimension 1 size type t number of finite cells The number of finite cells Returns if t dimension 3 size type t number of finite facets The number of finite facets Returns if t dimension 2 size type t number of finite edges The number of finite edges Returns if t dimension 1 Geometric access functions Tetrahedron t tetrahedron const Cell handle c Returns the tetrahedron formed by the four vertices of c Precondition t dimension 3 and the cell is finite Triangle t triangle const Cell handle c int i Returns the triangle formed by the three vertices of facet c i The triangle is oriented so that its normal points to the inside of cell c Precondition t dimension 2 and i 1 2 3 in dimension 3 i 3 in dimension 2 and the facet is finite Triangle t triangle Facet f Same as the previous method for facet f Precondition t dimension 2 and the facet is finite Segment t segment Edge e Returns the line segment formed by the vertices of e Precondition t dimension 1 and e is finite Segment t segment const Cell handle c int i int j Same as the previous method for edge c i j Precondition As above and i j Moreover i j 1 2 3 in dimension 3 i j 1 2 in dimension 2 i j 1 in dimension 1 Tests for Finite and Infinite Vertices and Faces bool t is infinite const Vertex handle v true iff vertex v is the infinite vertex bool t is infinite const Cell handle c true iff c is incident to the infinite vertex Precondition t dimension 3 bool t is infinite const Cell handle c int i true iff the facet i of cell c is incident to the infinite vertex Precondition t dimension 2 and i 1 2 3 in dimension 3 i 3 in dimension 2 bool t is infinite Facet f true iff facet f is incident to the infinite vertex Precondition t dimension 2 bool t is infinite const Cell handle c int i int j true iff the edge i j of cell c is incident to the infinite vertex Precondition t dimension 1 and i j Moreover i j 1 2 3 in dimension 3 i j 1 2 in dimension 2 i j 1 in dimension 1 bool t is infinite Edge e true iff edge e is incident to the infinite vertex Precondition t dimension 1 Queries bool t is vertex Point p Vertex handle v Tests whether p is a vertex of t by locating p in the triangulation If p is found the associated vertex v is given bool t is vertex Vertex handle v Tests whether v is a vertex of t bool t is edge Vertex handle u Vertex handle v Cell handle c int i int j Tests whether u v is an edge of t If the edge is found it gives a cell c having this edge and the indices i and j of the vertices u and v in c in this order Precondition u and v are vertices of t bool t is facet Vertex handle u Vertex handle v Vertex handle w Cell handle c int i int j int k Tests whether u v w is a facet of t If the facet is found it computes a cell c having this facet and the indices i j and k of the vertices u v and w in c in this order Precondition u v and w are vertices of t bool t is cell Cell handle c Tests whether c is a cell of t bool t is cell Vertex handle u Vertex handle v Vertex handle w Vertex handle x Cell handle c int i int j int k int l Tests whether u v w x is a cell of t If the cell c is found the method computes the indices i j k and l of the vertices u v w and x in c in this order Precondition u v w and x are vertices of t bool t is cell Vertex handle u Vertex handle v Vertex handle w Vertex handle x Cell handle c Tests whether u v w x is a cell of t and computes this cell c Precondition u v w and x are vertices of t There is a method has vertex in the cell class The analogous methods for facets are defined here bool t has vertex Facet f Vertex handle v int j If v is a vertex of f then j is the index of v in the cell f first and the method returns true Precondition t dimension 3 bool t has vertex Cell handle c int i Vertex handle v int j Same for facet c i Computes the index j of v in c bool t has vertex Facet f Vertex handle v bool t has vertex Cell handle c int i Vertex handle v Same as the first two methods but these two methods do not return the index of the vertex The following three methods test whether two facets have the same vertices bool t are equal Cell handle c int i Cell handle n int j bool t are equal Facet f Facet g bool t are equal Facet f Cell handle n int j For these three methods Precondition t dimension 3 Point location The class Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 provides two functions to locate a given point with respect to a triangulation It provides also functions to test if a given point is inside a finite face or not Note that the class Delaunay triangulation 3 also provides a nearest vertex function Cell handle t locate Point query Cell handle start Cell handle If the point query lies inside the convex hull of the points the cell that contains the query in its interior is returned If query lies on a facet an edge or on a vertex one of the cells having query on its boundary is returned If the point query lies outside the convex hull of the points an infinite cell with vertices p q r is returned such that the tetrahedron p q r query is positively oriented the rest of the triangulation lies on the other side of facet p q r Note that locate works even in degenerate dimensions in dimension 2 resp 1 the Cell handle returned is the one that represents the facet resp edge vertex containing the query point The optional argument start is used as a starting place for the search Cell handle t locate Point query Locate type lt int li int lj Cell handle start Cell handle If query lies inside the affine hull of the points the k face finite or infinite that contains query in its interior is returned by means of the cell returned together with lt which is set to the locate type of the query VERTEX EDGE FACET CELL or OUTSIDE CONVEX HULL if the cell is infinite and query lies strictly in it and two indices li and lj that specify the k face of the cell containing query If the k face is a cell li and lj have no meaning if it is a facet resp vertex li gives the index of the facet resp vertex and lj has no meaning if it is and edge li and lj give the indices of its vertices If the point query lies outside the affine hull of the points which can happen in case of degenerate dimensions lt is set to OUTSIDE AFFINE HULL and the cell returned has no meaning As a particular case if there is no finite vertex yet in the triangulation lt is set to OUTSIDE AFFINE HULL and locate returns the default constructed handle The optional argument start is used as a starting place for the search Bounded side t side of cell Point p Cell handle c Locate type lt int li int lj Returns a value indicating on which side of the oriented boundary of c the point p lies More precisely it returns ON BOUNDED SIDE if p is inside the cell For an infinite cell this means that p lies strictly in the half space limited by its finite facet and not containing any other point of the triangulation ON BOUNDARY if p on the boundary of the cell For an infinite cell this means that p lies on the finite facet Then lt together with li and lj give the precise location on the boundary See the descriptions of the locate methods ON UNBOUNDED SIDE if p lies outside the cell For an infinite cell this means that p does not satisfy either of the two previous conditions Precondition t dimension 3 Bounded side t side of facet Point p Facet f Locate type lt int li int lj Returns a value indicating on which side of the oriented boundary of f the point p lies ON BOUNDED SIDE if p is inside the facet For an infinite facet this means that p lies strictly in the half plane limited by its finite edge and not containing any other point of the triangulation ON BOUNDARY if p is on the boundary of the facet For an infinite facet this means that p lies on the finite edge lt li and lj give the precise location of p on the boundary of the facet li and lj refer to indices in the degenerate cell c representing f ON UNBOUNDED SIDE if p lies outside the facet For an infinite facet this means that p does not satisfy either of the two previous conditions Precondition t dimension 2 and p lies in the plane containing the triangulation f second 3 in dimension 2 there is only one facet per cell Bounded side t side of facet Point p Cell handle c Locate type lt int li int lj Same as the previous method for the facet c 3 Bounded side t side of edge Point p Edge e Locate type lt int li Returns a value indicating on which side of the oriented boundary of e the point p lies ON BOUNDED SIDE if p is inside the edge For an infinite edge this means that p lies in the half line defined by the vertex and not containing any other point of the triangulation ON BOUNDARY if p equals one of the vertices li give the index of the vertex in the cell storing e ON UNBOUNDED SIDE if p lies outside the edge For an infinite edge this means that p lies on the other half line which contains the other points of the triangulation Precondition t dimension 1 and p is collinear with the points of the triangulation e second and e third 1 in dimension 1 there is only one edge per cell Bounded side t side of edge Point p Cell handle c Locate type lt int li Same as the previous method for edge c 1 Flips Two kinds of flips exist for a three dimensional triangulation They are reciprocal To be flipped an edge must be incident to three tetrahedra During the flip these three tetrahedra disappear and two tetrahedra appear Figure left shows the edge that is flipped as bold dashed and one of its three incident facets is shaded On the right the facet shared by the two new tetrahedra is shaded Flips are possible only under the following conditions the edge or facet to be flipped is not on the boundary of the convex hull of the triangulation the five points involved are in convex position Figure Flips The following methods guarantee the validity of the resulting 3D triangulation Flips for a 2d triangulation are not implemented yet bool t flip Edge e bool t flip Cell handle c int i int j Before flipping these methods check that edge e c i j is flippable which is quite expensive They return false or true according to this test void t flip flippable Edge e void t flip flippable Cell handle c int i int j Should be preferred to the previous methods when the edge is known to be flippable Precondition The edge is flippable bool t flip Facet f bool t flip Cell handle c int i Before flipping these methods check that facet f c i is flippable which is quite expensive They return false or true according to this test void t flip flippable Facet f void t flip flippable Cell handle c int i Should be preferred to the previous methods when the facet is known to be flippable Precondition The facet is flippable Insertions The following operations are guaranteed to lead to a valid triangulation when they are applied on a valid triangulation Vertex handle t insert Point p Cell handle start Cell handle Inserts point p in the triangulation and returns the corresponding vertex If point p coincides with an already existing vertex this vertex is returned and the triangulation remains unchanged If point p lies in the convex hull of the points it is added naturally if it lies inside a cell the cell is split into four cells if it lies on a facet the two incident cells are split into three cells if it lies on an edge all the cells incident to this edge are split into two cells If point p is strictly outside the convex hull but in the affine hull p is linked to all visible points on the convex hull to form the new triangulation See Figure If point p is outside the affine hull of the points p is linked to all the points and the dimension of the triangulation is incremented All the points now belong to the boundary of the convex hull so the infinite vertex is linked to all the points to triangulate the new infinite face See Figure The optional argument start is used as a starting place for the search Vertex handle t insert Point p Locate type lt Cell handle loc int li int lj Inserts point p in the triangulation and returns the corresponding vertex Similar to the above insert function but takes as additional parameter the return values of a previous location query See description of locate above template class InputIterator int t insert InputIterator first InputIterator last Inserts the points in the range first last Returns the number of inserted points Precondition The value type of first and last is Point The previous methods are sufficient to build a whole triangulation We also provide some other methods that can be used instead of insert p when the place where the new point p must be inserted is already known They are also guaranteed to lead to a valid triangulation when they are applied on a valid triangulation Vertex handle t insert in cell Point p Cell handle c Inserts point p in cell c Cell c is split into 4 tetrahedra Precondition t dimension 3 and p lies strictly inside cell c Vertex handle t insert in facet Point p Facet f Inserts point p in facet f In dimension 3 the 2 neighboring cells are split into 3 tetrahedra in dimension 2 the facet is split into 3 triangles Precondition t dimension 2 and p lies strictly inside face f Vertex handle t insert in facet Point p Cell handle c int i As above insertion in facet c i Precondition As above and i 1 2 3 in dimension 3 i 3 in dimension 2 Vertex handle t insert in edge Point p Edge e Inserts p in edge e In dimension 3 all the cells having this edge are split into 2 tetrahedra in dimension 2 the 2 neighboring facets are split into 2 triangles in dimension 1 the edge is split into 2 edges Precondition t dimension 1 and p lies on edge e Vertex handle t insert in edge Point p Cell handle c int i int j As above inserts p in edge i j of c Precondition As above and i j Moreover i j 1 2 3 in dimension 3 i j 1 2 in dimension 2 i j 1 in dimension 1 Vertex handle t insert outside convex hull Point p Cell handle c The cell c must be an infinite cell containing p Links p to all points in the triangulation that are visible from p Updates consequently the infinite faces See Figure Precondition t dimension c and the k face represented by c is infinite and contains t Figure insert outside convex hull 2 dimensional case Vertex handle t insert outside affine hull Point p p is linked to all the points and the infinite vertex is linked to all the points including p to triangulate the new infinite face so that all the points now belong to the boundary of the convex hull See Figure This method can be used to insert the first point in an empty triangulation Precondition t dimension 3 and p lies outside the affine hull of the points Figure insert outside affine hull 2 dimensional case template class CellIt Vertex handle t insert in hole Point p CellIt cell begin CellIt cell end Cell handle begin int i Creates a new vertex by starring a hole It takes an iterator range cell begin cell end of Cell handles which specifies a hole a set of connected cells resp facets in dimension 2 which is star shaped wrt p begin i is a facet resp an edge on the boundary of the hole that is begin belongs to the set of cells resp facets previously described and begin neighbor i does not Then this function deletes all the cells resp facets describing the hole creates a new vertex v and for each facet resp edge on the boundary of the hole creates a new cell resp facet with v as vertex Then v set point p is called and v is returned This operation is equivalent to calling tds insert in hole cell begin cell end begin i v set point p Precondition t dimension 2 the set of cells resp facets in dimension 2 is connected its boundary is connected and p lies inside the hole which is star shaped wrt p Traversal of the Triangulation The triangulation class provides several iterators and circulators that allow one to traverse it completely or partially Cell Face Edge and Vertex Iterators The following iterators allow the user to visit cells facets edges and vertices of the triangulation These iterators are non mutable bidirectional and their value types are respectively Cell Facet Edge and Vertex They are all invalidated by any change in the triangulation Finite vertices iterator t finite vertices begin Starts at an arbitrary finite vertex Then and will iterate over finite vertices Returns finite vertices end when t number of vertices Finite vertices iterator t finite vertices end Past the end iterator Finite edges iterator t finite edges begin Starts at an arbitrary finite edge Then and will iterate over finite edges Returns finite edges end when t dimension 1 Finite edges iterator t finite edges end Past the end iterator Finite facets iterator t finite facets begin Starts at an arbitrary finite facet Then and will iterate over finite facets Returns finite facets end when t dimension 2 Finite facets iterator t finite facets end Past the end iterator Finite cells iterator t finite cells begin Starts at an arbitrary finite cell Then and will iterate over finite cells Returns finite cells end when t dimension 3 Finite cells iterator t finite cells end Past the end iterator All vertices iterator t all vertices begin Starts at an arbitrary vertex Iterates over all vertices even the infinite one Returns vertices end when t number of vertices All vertices iterator t all vertices end Past the end iterator All edges iterator t all edges begin Starts at an arbitrary edge Iterates over all edges even infinite ones Returns edges end when t dimension 1 All edges iterator t all edges end Past the end iterator All facets iterator t all facets begin Starts at an arbitrary facet Iterates over all facets even infinite ones Returns facets end when t dimension 2 All facets iterator t all facets end Past the end iterator All cells iterator t all cells begin Starts at an arbitrary cell Iterates over all cells even infinite ones Returns cells end when t dimension 3 All cells iterator t all cells end Past the end iterator Point iterator t points begin Iterates over the points of the triangulation Point iterator t points end Past the end iterator Cell and Facet Circulators The following circulators respectively visit all cells or all facets incident to a given edge They are non mutable and bidirectional They are invalidated by any modification of one of the cells traversed Cell circulator t incident cells Edge e Starts at an arbitrary cell incident to e Precondition t dimension 3 Cell circulator t incident cells Cell handle c int i int j As above for edge i j of c Cell circulator t incident cells Edge e Cell handle start Starts at cell start Precondition t dimension 3 and start is incident to e Cell circulator t incident cells Cell handle c int i int j Cell handle start As above for edge i j of c The following circulators on facets are defined only in dimension 3 though facets are defined also in dimension 2 there are only two facets sharing an edge in dimension 2 Facet circulator t incident facets Edge e Starts at an arbitrary facet incident to e Precondition t dimension 3 Facet circulator t incident facets Cell handle c int i int j As above for edge i j of c Facet circulator t incident facets Edge e Facet start Starts at facet start Precondition start is incident to e Facet circulator t incident facets Edge e Cell handle start int f Starts at facet of index f in start Facet circulator t incident facets Cell handle c int i int j Facet start As above for edge i j of c Facet circulator t incident facets Cell handle c int i int j Cell handle start int f As above for edge i j of c and facet start f Traversal of the incident cells and the adjacent vertices of a given vertex template class OutputIterator OutputIterator t incident cells Vertex handle v OutputIterator cells Copies the Cell handles of all cells incident to v to the output iterator cells If t dimension 3 then do nothing Returns the resulting output iterator Precondition v Vertex handle t is vertex v template class OutputIterator OutputIterator t incident vertices Vertex handle v OutputIterator vertices Copies the Vertex handles of all vertices incident to v to the output iterator vertices If t dimension 2 then do nothing Returns the resulting output iterator Precondition v Vertex handle t is vertex v size type t degree Vertex handle v Returns the degree of a vertex that is the number of incident vertices The infinite vertex is counted Precondition v Vertex handle t is vertex v advanced Checking The responsibility of keeping a valid triangulation belongs to the user when using advanced operations allowing a direct manipulation of cells and vertices We provide the user with the following methods to help debugging bool t is valid bool verbose false Checks the combinatorial validity of the triangulation Checks also the validity of its geometric embedding see Section When verbose is set to true messages describing the first invalidity encountered are printed bool t is valid Cell handle c bool verbose false Checks the combinatorial validity of the cell by calling the is valid method of the TriangulationDataStructure 3 cell class Also checks the geometric validity of c if c is finite See Section When verbose is set to true messages are printed to give a precise indication of the kind of invalidity encountered advanced I O CGAL provides an interface to Geomview for a 3D triangulation See the chapter on Geomview in the Support Library manual include CGAL IO Triangulation geomview ostream 3 h istream istream is Triangulation 3 t Reads the underlying combinatorial triangulation from is by calling the corresponding input operator of the triangulation data structure class and the non combinatorial information by calling the corresponding input operators of the vertex and the cell classes Assigns the resulting triangulation to t ostream ostream os Triangulation 3 t Writes the triangulation t into os The information in the iostream is the dimension the number of finite vertices the non combinatorial information about vertices point etc the number of cells the indices of the vertices of each cell plus the non combinatorial information about each cell then the indices of the neighbors of each cell where the index corresponds to the preceding list of cells When dimension 3 the same information is stored for faces of maximal dimension instead of cells See Also TriangulationDataStructure 3 Vertex TriangulationDataStructure 3 Cell Next Delaunay triangulation 3 DelaunayTriangulationTraits 3 TriangulationDataStructure 3 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Triangulation_3_ref/Class_Triangulation_3", "title": "triangulation_3&lt;triangulationtraits_3,triangulationdatastructure_3&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Triangulation_3_ref/Triangulation_3.tex' -->\n<html> <head>  \n<title>Triangulation_3&lt;TriangulationTraits_3,TriangulationDataStructure_3&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_971\"></A>\n\n<A NAME=\"Cross_link_anchor_972\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_915\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Triangulation_3<TriangulationTraits_3,TriangulationDataStructure_3>\"></A>\n<h2><I>CGAL::Triangulation_3&lt;TriangulationTraits_3,TriangulationDataStructure_3&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I> represents a 3-dimensional tetrahedralization\nof points.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Triangulation_3.h\">CGAL/Triangulation_3.h</A>&gt;</I>\n<P>\n\n<H3>Parameters</H3>\n<P>\n\nThe first template argument must be a model of the\n<I><A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A></I> concept.\n<P>\n\nThe second template argument must be a model of the\n<I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I> concept.\nIt has the default value <I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A>&lt; <A HREF=\"Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994\">Triangulation_vertex_base_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>&gt;,<A HREF=\"Class_Triangulation_cell_base_3.html#Cross_link_anchor_990\">Triangulation_cell_base_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>&gt;  &gt;</I>.\n<P>\n\n<H3>Inherits From</H3><I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_utils_3.html#Cross_link_anchor_1014\">Triangulation_utils_3</A></I>\n<P>\n\n<H3>Types</H3>The class <I><A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I> defines the following types:\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Triangulation_data_structure\"></A>\n<A NAME=\"Typedef_Triangulation_data_structure\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Triangulation_data_structure;\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Geom_traits\"></A>\n<A NAME=\"Typedef_Geom_traits\"></A>\ntypedef <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Geom_traits;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Point\"></A>\n<A NAME=\"Typedef_Point\"></A>\ntypedef <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Point;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Segment\"></A>\n<A NAME=\"Typedef_Segment\"></A>\ntypedef <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Segment_3.html#Cross_link_anchor_78\">Segment_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Segment;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Triangle\"></A>\n<A NAME=\"Typedef_Triangle\"></A>\ntypedef <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Triangle_3.html#Cross_link_anchor_84\">Triangle_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Triangle;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Tetrahedron\"></A>\n<A NAME=\"Typedef_Tetrahedron\"></A>\ntypedef <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Tetrahedron_3.html#Cross_link_anchor_82\">Tetrahedron_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Tetrahedron;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        </TABLE>\n<P>\n\nOnly vertices (<MATH><I>0</I></MATH>-faces) and cells (<MATH><I>3</I></MATH>-faces) are stored. Edges\n(<MATH><I>1</I></MATH>-faces) and facets (<MATH><I>2</I></MATH>-faces) are not explicitly represented and\nthus there are no corresponding classes (see\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex\"></A>\n<A NAME=\"Typedef_Vertex\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004\">TriangulationDataStructure_3::Vertex</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Vertex;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Cell\"></A>\n<A NAME=\"Typedef_Cell\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003\">TriangulationDataStructure_3::Cell</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Cell;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Facet\"></A>\n<A NAME=\"Typedef_Facet\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Facet\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Facet;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Edge\"></A>\n<A NAME=\"Typedef_Edge\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Edge\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Edge;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        </TABLE>\n<P>\n\nThe vertices and faces of the triangulations are accessed through\n<I>handles</I>, <I>iterators</I> and <I>circulators</I>. \nA handle is a type which supports the two dereference operators\n<I>operator*</I> and <I>operator-&gt;</I>.  The <A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A> concept is\ndocumented in the support library.\nIterators and circulators are bidirectional and non-mutable.\nThe edges and facets of the triangulation can also be visited through\niterators and circulators which are bidirectional and non-mutable.\n<P>\n\nIterators and circulators are convertible to the corresponding handles, thus\nthe user can pass them directly as arguments to the functions.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle\"></A>\n<A NAME=\"Typedef_Vertex_handle\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Vertex_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Vertex_handle;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    handle to a vertex\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle\"></A>\n<A NAME=\"Typedef_Cell_handle\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Cell_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Cell_handle;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    handle to a cell\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_size_type\"></A>\n<A NAME=\"Typedef_size_type\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::size_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    size_type;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Size type (an unsigned integral type)\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_difference_type\"></A>\n<A NAME=\"Typedef_difference_type\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::difference_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    difference_type;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Difference type (a signed integral type)\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_cells_iterator\"></A>\n<A NAME=\"Typedef_All_cells_iterator\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Cell_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    All_cells_iterator;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over cells\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_facets_iterator\"></A>\n<A NAME=\"Typedef_All_facets_iterator\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Facet_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    All_facets_iterator;\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over facets\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_edges_iterator\"></A>\n<A NAME=\"Typedef_All_edges_iterator\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Edge_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    All_edges_iterator;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over edges\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator\"></A>\n<A NAME=\"Typedef_All_vertices_iterator\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Vertex_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    All_vertices_iterator;\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over vertices\n        </TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;::Finite_cells_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite cells\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;::Finite_facets_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite facets\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;::Finite_edges_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite edges\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;::Finite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite vertices\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over the points corresponding to the\nfinite vertices of the triangulation.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator\"></A>\n<A NAME=\"Typedef_Cell_circulator\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Cell_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Cell_circulator;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    circulator over all cells incident to a given edge\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator\"></A>\n<A NAME=\"Typedef_Facet_circulator\"></A>\ntypedef <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Facet_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Facet_circulator;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    circulator over all facets incident to a given edge\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe triangulation class also defines the following <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> type to specify\nwhich case occurs when locating a point in the triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A NAME=\"Function_Locate_type\"></A>\n<A NAME=\"Enum_Locate_type\"></A>\n<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> <A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> { </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n    <A HREF=\"Class_Triangulation_3#Enum_Locate_type\">VERTEX</A>=0<A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">EDGE</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">FACET</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">CELL</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">OUTSIDE_CONVEX_HULL</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">OUTSIDE_AFFINE_HULL</A><A NAME=\"Function_Locate_type\"></A>\n};</TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt; t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A> traits = <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Introduces a triangulation <I>t</I> having only one vertex which is the\ninfinite vertex.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt; t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> tr);</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Copy constructor. All vertices and faces are duplicated.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt; t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\n<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A> traits = <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Introduces a triangulation <I>t</I> constructed by the repeated insertion\nof the iterator range <I>[first,last)</I> of value type <I>Point</I>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Assignment</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> &amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     t =  <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> tr<A NAME=\"Function_Triangulation_3___operator=6const_Triangulation_3___tr9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The triangulation <I>tr</I> is duplicated, and modifying the copy after the \nduplication does not modify the original. The previous triangulation held\nby <I>t</I> is deleted.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_swap6Triangulation_3___tr9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.swap ( <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> &amp; tr)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The triangulations <I>tr</I> and <I>t</I> are swapped.\n<I>t</I>.<I>swap(tr)</I> should be preferred to <I>t</I> = <I>tr</I> or to\n<I>t(tr)</I> if <I>tr</I> is deleted after that. Indeed, there is no\ncopy of cells and vertices, thus this method runs in constant time.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Deletes all finite vertices and all cells of <I>t</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_~Triangulation_369;\"></A>\nvoid ~\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.<A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Destructor. All vertices (including the infinite vertex) and cells are\ndeleted.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class GT, class Tds &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n      <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;GT, Tds&gt; t1 ==  <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;GT, Tds&gt; t2<A NAME=\"Function_bool_operator==6const_Triangulation_36GT+_Tds9___t1+_const_Triangulation_36GT+_Tds9___t29;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Equality operator.  Returns true iff there exist a bijection between the\nvertices of <I>t1</I> and those of <I>t2</I> and a bijection between the cells of\n<I>t1</I> and those of <I>t2</I>, which preserve the geometry of the\ntriangulation, that is, the points of each corresponding pair of vertices are\nequal, and the tetrahedra corresponding to each pair of cells are equal (up to\na permutation of their vertices).\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class GT, class Tds &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n      <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;GT, Tds&gt; t1 !=  <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;GT, Tds&gt; t2<A NAME=\"Function_bool_operator!=6const_Triangulation_36GT+_Tds9___t1+_const_Triangulation_36GT+_Tds9___t29;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> of <I>operator==</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_const_TriangulationTraits_3___geom_traits69_const;\"></A>\n <A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.geom_traits ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a const reference to the geometric traits object.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_const_TriangulationDataStructure_3___tds69_const;\"></A>\n <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.tds ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a const reference to the triangulation data structure.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Non const access</H3>\nThe responsibility of keeping a valid triangulation belongs to the user\nwhen using advanced operations allowing a direct manipulation of the <I>tds</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_TriangulationDataStructure_3___tds69;\"></A>\n<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> &amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.tds ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a reference to the triangulation data structure.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThis method is mainly a help for users implementing their own triangulation\nalgorithms.\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_dimension69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.dimension ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the dimension of the affine hull.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_vertices69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the number of finite vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_cells69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_cells ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the number of cells or 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;3</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_infinite_vertex69;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.infinite_vertex ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the infinite vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_infinite_cell69_const;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.infinite_cell ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a cell incident to the infinite vertex.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Non-constant-time access functions</H3>\n<P>\n\nAs previously said, the triangulation is a collection of cells that\nare either infinite or represent a finite tetrahedra, where an\ninfinite cell is a \ncell incident to the infinite vertex. Similarly we call\nan edge (resp. facet) <I>infinite</I> if it is incident to the infinite vertex.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_facets69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_facets ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of facets. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_edges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_edges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of edges. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;1</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_finite_cells69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_finite_cells ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of finite cells. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;3</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_finite_facets69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_finite_facets ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of finite facets. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_finite_edges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_finite_edges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of finite edges. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;1</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Geometric access functions</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Tetrahedron_tetrahedron6const_Cell_handle_c9_const;\"></A>\nTetrahedron\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.tetrahedron ( const Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the tetrahedron formed by the four vertices of <I>c</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH> and the cell is finite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Triangle_triangle6const_Cell_handle_c+_int_i9_const;\"></A>\nTriangle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.triangle ( const Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the triangle formed by the three vertices of facet\n<I>(c,i)</I>. The triangle is oriented so that its normal points to the\ninside of cell <I>c</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and <MATH><I>i  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH>\nin dimension&nbsp;3, <MATH><I>i = 3</I></MATH> in dimension&nbsp;2, and the facet is finite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Triangle_triangle6const_Facet___f9_const;\"></A>\nTriangle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.triangle (  Facet f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the previous method for facet <I>f</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and the facet is finite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_segment6const_Edge___e9_const;\"></A>\nSegment\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.segment (  Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the line segment formed by the vertices of <I>e</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH> and <I>e</I> is finite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_segment6const_Cell_handle_c+_int_i+_int_j9_const;\"></A>\nSegment\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.segment ( const Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the previous method for edge <I>(c,i,j)</I>.<BR>\n\n<EM>Precondition: </EM>As above and <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> j</I></MATH>. Moreover <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> in\ndimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2}</I></MATH> in dimension&nbsp;2, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1}</I></MATH> in \ndimension&nbsp;1.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Tests for Finite and Infinite Vertices and Faces</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6const_Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( const Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I>, iff vertex <I>v</I> is the infinite vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6const_Cell_handle_c9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( const Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I>, iff <I>c</I> is incident to the infinite vertex.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6const_Cell_handle_c+_int_i9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( const Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I>, iff the facet <I>i</I> of cell <I>c</I> is incident to the\ninfinite vertex.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and <MATH><I>i <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> in\ndimension&nbsp;3, <MATH><I>i=3</I></MATH> in dimension&nbsp;2.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6const_Facet___f9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite (  Facet f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff facet <I>f</I> is incident to the infinite vertex.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6const_Cell_handle_c+_int_i+_int_j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( const Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I>, iff the edge <I>(i,j)</I> of cell <I>c</I> is incident to\nthe infinite vertex.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH> and <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> j</I></MATH>. Moreover\n<MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> in dimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2}</I></MATH> in dimension\n2, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1}</I></MATH> in  dimension&nbsp;1.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6const_Edge___e9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite (  Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff edge <I>e</I> is incident to the infinite vertex.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Queries</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_vertex6const_Point___p+_Vertex_handle___v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_vertex (  Point p,  Vertex_handle &amp; v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>p</I> is a vertex of <I>t</I> by locating <I>p</I> in\nthe triangulation. If <I>p</I> is found, the associated vertex <I>v</I>\nis given.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_vertex6Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_vertex ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>v</I> is a vertex of <I>t</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_u+_Vertex_handle_v+_Cell_handle___c+_int___i+_int___j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nCell_handle &amp; c,<BR>\n\nint &amp; i,<BR>\n\nint &amp; j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v)</I> is an edge of <I>t</I>. If the edge is found,\nit gives a cell <I>c</I> having this edge and the indices <I>i</I>\nand <I>j</I> of the vertices <I>u</I> and <I>v</I> in <I>c</I>, in this order.<BR>\n\n<EM>Precondition: </EM><I>u</I> and <I>v</I> are vertices of <I>t</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_facet6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Cell_handle___c+_int___i+_int___j+_int___k9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nVertex_handle w,<BR>\n\nCell_handle &amp; c,<BR>\n\nint &amp; i,<BR>\n\nint &amp; j,<BR>\n\nint &amp; k)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v,w)</I> is a facet of <I>t</I>. If the facet is found,\nit computes a cell <I>c</I> having this facet and the indices <I>i</I>,\n<I>j</I> and <I>k</I> of the vertices <I>u</I>, <I>v</I> and <I>w</I> in <I>c</I>, \nin this order.<BR>\n\n<EM>Precondition: </EM><I>u</I>, <I>v</I> and <I>w</I> are vertices of <I>t</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_cell6Cell_handle_c9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_cell ( Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>c</I> is a cell of <I>t</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_cell6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Vertex_handle_x+_Cell_handle___c+_int___i+_int___j+_int___k+_int___l9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nVertex_handle w,<BR>\n\nVertex_handle x,<BR>\n\nCell_handle &amp; c,<BR>\n\nint &amp; i,<BR>\n\nint &amp; j,<BR>\n\nint &amp; k,<BR>\n\nint &amp; l)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v,w,x)</I> is a cell of <I>t</I>. \nIf the cell <I>c</I> is found, the method\ncomputes the indices <I>i</I>, <I>j</I>, <I>k</I> and <I>l</I> of the\nvertices <I>u</I>, <I>v</I>, <I>w</I> and <I>x</I> in <I>c</I>, in this\norder.<BR>\n\n<EM>Precondition: </EM><I>u</I>, <I>v</I>, <I>w</I> and <I>x</I> are vertices of <I>t</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_cell6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Vertex_handle_x+_Cell_handle___c9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nVertex_handle w,<BR>\n\nVertex_handle x,<BR>\n\nCell_handle &amp; c)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v,w,x)</I> is a cell of <I>t</I> and computes \nthis cell <I>c</I>.<BR>\n\n<EM>Precondition: </EM><I>u</I>, <I>v</I>, <I>w</I> and <I>x</I> are vertices of <I>t</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThere is a method <I>has_vertex</I> in the cell class. The analogous\nmethods for facets are defined here.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6const_Facet___f+_Vertex_handle_v+_int___j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.has_vertex (  Facet f,  Vertex_handle v,  int &amp; j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    If <I>v</I> is a vertex of <I>f</I>, then <I>j</I> is the index of\n<I>v</I> in the cell <I>f.first</I>, and the method returns <I>true</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.dimension()=3\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6Cell_handle_c+_int_i+_Vertex_handle_v+_int___j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.has_vertex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nVertex_handle v,<BR>\n\nint &amp; j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same for facet <I>(c,i)</I>. Computes the index <I>j</I> of <I>v</I> in\n<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6const_Facet___f+_Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.has_vertex (  Facet f,  Vertex_handle v)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6Cell_handle_c+_int_i+_Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.has_vertex ( Cell_handle c,  int i,  Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the first two methods, but these two methods do not return the\nindex of the vertex.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following three methods test whether two facets have the same\nvertices.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_are_equal6Cell_handle_c+_int_i+_Cell_handle_n+_int_j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.are_equal ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nCell_handle n,<BR>\n\nint j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_are_equal6const_Facet___f+_const_Facet___g9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.are_equal (  Facet f,  Facet g)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_are_equal6const_Facet___f+_Cell_handle_n+_int_j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.are_equal (  Facet f,  Cell_handle n,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    For these three methods:<BR>\n\n<EM>Precondition: </EM><I>t</I>.dimension()=3.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Point location</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;</I>  provides two functions to locate\na given point with respect to a triangulation. It provides\nalso functions to test if a given point is inside a finite face\nor not.  Note that the class <I><A HREF=\"Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> also\nprovides a <I>nearest_vertex()</I> function.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_locate6const_Point___query+_Cell_handle_start_=_Cell_handle699_const;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.locate ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point query,<BR>\n\nCell_handle start = Cell_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    If the point <I>query</I> lies inside the convex hull of the points, the cell \nthat contains the query in its interior is returned. If <I>query</I> lies on a\nfacet, an edge or on a vertex, one of the cells having <I>query</I> on\nits boundary is returned.<BR>\n\nIf the point <I>query</I> lies outside the convex hull of the points,\nan infinite cell with vertices <MATH><I>{ p, q, r,  <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> }</I></MATH> is returned such that\nthe tetrahedron <MATH><I>( p, q, r, query )</I></MATH> is positively oriented\n(the rest of the triangulation lies on the other side of facet \n<MATH><I>( p, q, r )</I></MATH>).<BR>\n\nNote that locate works even in degenerate dimensions: in dimension 2\n(resp. 1, 0) the <I>Cell_handle</I> returned is the one that represents\nthe facet (resp. edge, vertex) containing the query point.<BR>\n\nThe optional argument <I>start</I> is used as a starting place for the search.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_locate6const_Point___query+_Locate_type___lt+_int___li+_int___lj+_Cell_handle_start_=_Cell_handle69_9_const;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.locate ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point query,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nint &amp; li,<BR>\n\nint &amp; lj,<BR>\n\nCell_handle start = Cell_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    If <I>query</I> lies inside the affine hull of the points, the <MATH><I>k</I></MATH>-face\n(finite or infinite) that contains <I>query</I> in its interior is\nreturned, by means of the cell returned together with <I>lt</I>, which\nis set to the locate type of the query (<I><A HREF=\"Class_Triangulation_3#Enum_Locate_type\">VERTEX</A>, <A HREF=\"Class_Triangulation_3#Enum_Locate_type\">EDGE</A>, <A HREF=\"Class_Triangulation_3#Enum_Locate_type\">FACET</A>, <A HREF=\"Class_Triangulation_3#Enum_Locate_type\">CELL</A></I>, or <I><A HREF=\"Class_Triangulation_3#Enum_Locate_type\">OUTSIDE_CONVEX_HULL</A></I> if the cell is infinite and <I>query</I>\nlies strictly in it) and two indices <I>li</I> and <I>lj</I> that\nspecify the <MATH><I>k</I></MATH>-face of the cell containing <I>query</I>.<BR>\n\nIf the <MATH><I>k</I></MATH>-face is a cell, <I>li</I> and <I>lj</I> have no\nmeaning; if it is a facet (resp. vertex), <I>li</I> gives the index of\nthe facet (resp. vertex) and <I>lj</I> has no meaning; if it is and\nedge, <I>li</I> and <I>lj</I> give the indices of its vertices.<BR>\n\nIf the point <I>query</I> lies outside the affine hull of the points,\nwhich can happen in case of degenerate dimensions, <I>lt</I> is set to\n<I><A HREF=\"Class_Triangulation_3#Enum_Locate_type\">OUTSIDE_AFFINE_HULL</A></I>, and the cell returned has no meaning.\nAs a particular case, if there is no finite vertex yet in the\ntriangulation, <I>lt</I> is set to <I><A HREF=\"Class_Triangulation_3#Enum_Locate_type\">OUTSIDE_AFFINE_HULL</A></I> and\n<I>locate</I> returns the default constructed handle.<BR>\n\nThe optional argument <I>start</I> is used as a starting place for the search.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_cell6const_Point___p+_Cell_handle_c+_Locate_type___lt+_int___li+_int___lj9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.side_of_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nCell_handle c,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nint &amp; li,<BR>\n\nint &amp; lj)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a value indicating on which side of the oriented boundary\nof <I>c</I> the point <I>p</I> lies. More precisely, it returns:<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the cell. For an infinite\ncell this means that <I>p</I> lies strictly in the half space limited by\nits finite facet and not containing any other point of the triangulation.<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if p on the boundary of the cell. For an infinite\ncell this means that <I>p</I> lies on the <I>finite</I> facet. Then\n<I>lt</I> together with <I>li</I> and <I>lj</I> give the precise location\non the boundary. (See the descriptions of the <I>locate</I> methods.)<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the cell. For an\ninfinite cell this means that <I>p</I> does not satisfy either of the\ntwo previous conditions.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_facet6const_Point___p+_const_Facet___f+_Locate_type___lt+_int___li+_int___lj9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.side_of_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nFacet f,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nint &amp; li,<BR>\n\nint &amp; lj)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a value indicating on which side of the oriented boundary\nof <I>f</I> the point <I>p</I> lies:<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the facet. For an\ninfinite facet this means that <I>p</I> lies strictly in the half plane\nlimited by its finite edge and not containing any other point of the\ntriangulation .<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if <I>p</I> is on the boundary of the facet.\nFor an infinite facet this means that <I>p</I> lies on the finite\nedge. <I>lt</I>, <I>li</I> and <I>lj</I> give the precise location of\n<I>p</I> on the boundary of the facet. <I>li</I> and <I>lj</I> refer to\nindices in the degenerate cell <I>c</I> representing <I>f</I>.<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the facet. For\nan infinite facet this means that <I>p</I> does not satisfy either of\nthe two previous conditions.<BR>\n\n<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=2</I></MATH> and <I>p</I> lies in the\nplane containing the triangulation. <I>f.second</I> <MATH><I>=3</I></MATH> (in dimension&nbsp;2 \nthere is only one facet per cell).\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_facet6const_Point___p+_Cell_handle_c+_Locate_type___lt+_int___li+_int___lj9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.side_of_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nCell_handle c,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nint &amp; li,<BR>\n\nint &amp; lj)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the previous method for the facet <I>(c,3)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_edge6const_Point___p+_const_Edge___e+_Locate_type___lt+_int___li9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.side_of_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nEdge e,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nint &amp; li)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a value indicating on which side of the oriented boundary\nof <I>e</I> the point <I>p</I> lies:<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the edge. For an\ninfinite edge this means that <I>p</I> lies in the half line defined by\nthe vertex and not containing any other point of the triangulation.<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if <I>p</I> equals one of the vertices,\n<I>li</I> give the index of the vertex in the cell storing <I>e</I><BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the edge. For\nan infinite edge this means that <I>p</I> lies on the other half line,\nwhich contains the other points of the triangulation.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=1</I></MATH> and <I>p</I> is <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A>\nwith the points of the triangulation. <I>e.second</I> <MATH><I>=0</I></MATH> and\n<I>e.third</I> <MATH><I>=1</I></MATH> (in dimension&nbsp;1 there is only one edge per cell).\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_edge6const_Point___p+_Cell_handle_c+_Locate_type___lt+_int___li9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.side_of_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nCell_handle c,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nint &amp; li)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the previous method for edge <MATH><I>(c,0,1)</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Flips</H3>\n<P>\n\nTwo kinds of flips exist for a three-dimensional triangulation. They\nare reciprocal. To be flipped, an edge must be incident to three\ntetrahedra. During the flip, these three tetrahedra disappear and two\ntetrahedra appear. Figure&nbsp;<A HREF=\"Class_Triangulation_3.html#Triangulation3-fig-flips\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>(left) shows the\nedge that is flipped as bold dashed, and one of its three incident\nfacets is shaded. On the right, the facet shared by the two new\ntetrahedra is shaded.\n<P>\n\nFlips are possible only under the following conditions:<BR>\n\n- the edge or facet to be flipped is not on the boundary of the convex\nhull of the triangulation<BR>\n\n- the five points involved are in convex position.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Flips.\n<A NAME=\"Triangulation3-fig-flips\"></A>\n\n<CENTER>\n<img border=0 src=\"./flips.gif\" align=center\nalt=\"Flips\">\n</CENTER>\n<P>\n\nThe following methods guarantee the validity of the resulting 3D\ntriangulation.\n<P>\n\n<I>Flips for a 2d triangulation are not implemented yet</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Edge_e9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip ( Edge e)\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Cell_handle_c+_int_i+_int_j9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Before flipping, these methods check that edge <I>e=(c,i,j)</I> is\nflippable (which is quite expensive). They return <I>false</I> or\n<I>true</I> according to this test.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Edge_e9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip_flippable ( Edge e)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Cell_handle_c+_int_i+_int_j9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip_flippable ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Should be preferred to the previous methods when the edge is\nknown to be flippable.<BR>\n\n<EM>Precondition: </EM>The edge is flippable.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Facet_f9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip ( Facet f)\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Cell_handle_c+_int_i9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Before flipping, these methods check that facet <I>f=(c,i)</I> is\nflippable (which is quite expensive). They return <I>false</I> or\n<I>true</I> according to this test.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Facet_f9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip_flippable ( Facet f)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Cell_handle_c+_int_i9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip_flippable ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Should be preferred to the previous methods when the facet is\nknown to be flippable.<BR>\n\n<EM>Precondition: </EM>The facet is flippable.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Insertions</H3>\n<P>\n\nThe following operations are guaranteed to lead to a valid triangulation \nwhen they are applied on a valid triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Point___p+_Cell_handle_start_=_Cell_handle69_9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert (  Point p,  Cell_handle start = Cell_handle())\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in the triangulation and returns the corresponding\n vertex.<BR>\n\nIf point <I>p</I> coincides with an already existing vertex, this \nvertex is returned and the triangulation remains unchanged.<BR>\n\nIf point <I>p</I> lies in the convex hull of the points, it is added\nnaturally: if it lies inside a cell, the cell is split into four\ncells, if it lies on a facet, the two incident cells are split into\nthree cells, if it lies on an edge, all the cells incident to this\nedge are split into two cells.<BR>\n\nIf point <I>p</I> is strictly outside the convex hull but in the affine\nhull, <I>p</I> is linked to all visible points on the convex hull to\nform the new triangulation. See\nFigure&nbsp;<A HREF=\"Class_Triangulation_3.html#Triangulation3-fig-insert_outside_convex_hull\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.<BR>\n\nIf point <I>p</I> is outside the affine hull of the points, <I>p</I> is\nlinked to all the points, and the dimension of the triangulation is\nincremented. All the points now belong to the boundary of the convex\nhull, so, the infinite vertex is linked to all the points to\ntriangulate the new infinite face. See \nFigure&nbsp;<A HREF=\"Class_Triangulation_3.html#Triangulation3-fig-insert_outside_affine_hull\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nThe optional argument <I>start</I> is used as a starting place for the search.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Point___p+_Locate_type_lt+_Cell_handle_loc+_int_li+_int_lj9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> lt,<BR>\n\nCell_handle loc,<BR>\n\nint li,<BR>\n\nint lj)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in the triangulation and returns the corresponding\n vertex. Similar to the above <I>insert()</I> function, but takes as additional\n parameter the return values of a previous location query.  See description of\n <I>locate()</I> above.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_insert6InputIterator_first+_InputIterator_last9;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert ( InputIterator first,  InputIterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the points in the range <MATH><I>[.</I></MATH><I>first</I>,\n<I>last</I><MATH><I>.)</I></MATH>.  Returns the number of inserted points.<BR>\n\n<EM>Precondition: </EM>The <I>value_type</I> of <I>first</I> and <I>last</I> is\n<I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe previous methods are sufficient to build a whole triangulation. We\nalso provide some other methods that can be used instead of\n<I>insert(p)</I> when the place where the new point <I>p</I> must be inserted\nis already known. They are also guaranteed to lead to a valid\ntriangulation when they are applied on a valid triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_cell6const_Point___p+_Cell_handle_c9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_in_cell (  Point p,  Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in cell <I>c</I>. Cell <I>c</I> is split into 4\ntetrahedra.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH> and <I>p</I> lies strictly\ninside cell <I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_facet6const_Point___p+_const_Facet___f9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_in_facet (  Point p,  Facet f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in facet <I>f</I>. In dimension&nbsp;3, the 2\nneighboring cells are split into 3 tetrahedra; in dimension&nbsp;2, the facet \nis split into 3 triangles.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and <I>p</I> lies strictly\ninside face <I>f</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_facet6const_Point___p+_Cell_handle_c+_int_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_in_facet (  Point p,  Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above, insertion in facet <I>(c,i)</I>.<BR>\n\n<EM>Precondition: </EM>As above and <MATH><I>i  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> in dimension&nbsp;3, <MATH><I>i = 3</I></MATH> in\ndimension&nbsp;2.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_edge6const_Point___p+_const_Edge___e9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_in_edge (  Point p,  Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts <I>p</I> in edge <I>e</I>. In dimension&nbsp;3, \nall the cells having this edge are split into 2 tetrahedra; in\ndimension&nbsp;2, the 2 neighboring facets are split into 2 triangles; in\ndimension&nbsp;1, the edge is split into 2 edges.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH> and <I>p</I> lies on edge\n<I>e</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_edge6Point_p+_Cell_handle_c+_int_i+_int_j9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.insert_in_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nCell_handle c,<BR>\n\nint i,<BR>\n\nint j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above, inserts <I>p</I> in edge <MATH><I>(<I>i</I>, <I>j</I>)</I></MATH> of <I>c</I>.<BR>\n\n<EM>Precondition: </EM>As above and <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> j</I></MATH>. Moreover <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> in\ndimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2}</I></MATH> in dimension&nbsp;2, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1}</I></MATH> in \ndimension&nbsp;1.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_outside_convex_hull6const_Point___p+_Cell_handle_c9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_outside_convex_hull (  Point p,  Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The cell <I>c</I> must be an infinite cell containing <I>p</I>.<BR>\n\nLinks <I>p</I> to all  points in the triangulation that are visible from\n<I>p</I>. Updates consequently the infinite faces. See\nFigure&nbsp;<A HREF=\"Class_Triangulation_3.html#Triangulation3-fig-insert_outside_convex_hull\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>&gt;0</I></MATH>, <I>c</I>, and the <MATH><I>k</I></MATH>-face\nrepresented by <I>c</I> is infinite and contains <I>t</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B><I>insert_outside_convex_hull</I> (2-dimensional case).\n<A NAME=\"Triangulation3-fig-insert_outside_convex_hull\"></A>\n\n<CENTER>\n<img border=0 src=\"./insert_outside_convex_hull.gif\" align=center \nalt=\"insert_outside_convex_hull} (2-dimensional case)\">\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_outside_affine_hull6const_Point___p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_outside_affine_hull (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>p</I> is linked to all the points, and the infinite vertex is linked\nto all the points (including <I>p</I>) to triangulate the new infinite\nface, so that all the points now belong to the boundary of the convex\nhull. See Figure&nbsp;<A HREF=\"Class_Triangulation_3.html#Triangulation3-fig-insert_outside_affine_hull\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.<BR>\n\nThis method can be used to insert the first point in an empty\ntriangulation.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH> and <I>p</I> lies outside the\naffine hull of the points.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B><I>insert_outside_affine_hull</I> (2-dimensional case).\n<A NAME=\"Triangulation3-fig-insert_outside_affine_hull\"></A>\n\n<CENTER>\n<img border=0 src=\"./insert_outside_affine_hull.gif\" align=center\nalt=\"insert_outside_affine_hull} (2-dimensional case)\">\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class CellIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_hole6Point_p+_CellIt_cell_begin+_CellIt_cell_end+_Cell_handle_begin+_int_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.insert_in_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nCellIt cell_begin,<BR>\n\nCellIt cell_end,<BR>\n\nCell_handle begin,<BR>\n\nint i)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex by starring a hole.  It takes an iterator range\n[<I>cell_begin</I>; <I>cell_end</I>[ of <I>Cell_handle</I>s which specifies\na hole: a set of connected cells (resp. facets in dimension 2) which is\nstar-shaped wrt <I>p</I>.\n(<I>begin</I>, <I>i</I>) is a facet (resp. an edge) on the boundary of the hole,\nthat is, <I>begin</I> belongs to the set of cells (resp.  facets) previously\ndescribed, and <I>begin-&gt;neighbor(i)</I> does not.  Then this function deletes\nall the cells (resp. facets) describing the hole, creates a new vertex\n<I>v</I>, and for each facet (resp. edge) on the boundary of the hole, creates\na new cell (resp. facet) with <I>v</I> as vertex.  Then <I>v-&gt;set_point(p)</I>\nis called and <I>v</I> is returned.<BR>\n\nThis operation is equivalent to calling\n<I>tds().insert_in_hole(cell_begin, cell_end, begin, i); v-&gt;set_point(p)</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>, the set of cells (resp. facets in\ndimension 2) is connected, its boundary is connected, and <I>p</I> lies inside\nthe hole, which is star-shaped wrt <I>p</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Traversal of the Triangulation</H3>\n<P>\n\nThe triangulation class provides several iterators and circulators\nthat allow one to traverse it (completely or partially).\n<P>\n\n<H3>Cell, Face, Edge and Vertex Iterators</H3>\n<P>\n\nThe following iterators allow the user to visit cells,\nfacets, edges and vertices of the\ntriangulation. These iterators are non-mutable, bidirectional and\ntheir value types are respectively <I>Cell</I>, <I>Facet</I>, <I>Edge</I>\nand <I>Vertex</I>. They are all invalidated by any change in the\ntriangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_vertices_iterator_finite_vertices_begin69_const;\"></A>\nFinite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite vertex. Then <I>++</I> and <I>--</I> will\niterate over finite vertices. Returns <I>finite_vertices_end()</I> when\n<I>t</I>.<I>number_of_vertices()</I> <MATH><I>=0</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_vertices_iterator_finite_vertices_end69_const;\"></A>\nFinite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_edges_iterator_finite_edges_begin69_const;\"></A>\nFinite_edges_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_edges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite edge. Then <I>++</I> and <I>--</I> will\niterate over finite edges. Returns <I>finite_edges_end()</I> when\n<I>t</I>.<I>dimension()</I> <MATH><I>&lt;1</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_edges_iterator_finite_edges_end69_const;\"></A>\nFinite_edges_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_edges_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_facets_iterator_finite_facets_begin69_const;\"></A>\nFinite_facets_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_facets_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite facet. Then <I>++</I> and <I>--</I> will\niterate over finite facets. Returns <I>finite_facets_end()</I> when\n<I>t</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_facets_iterator_finite_facets_end69_const;\"></A>\nFinite_facets_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_facets_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_cells_iterator_finite_cells_begin69_const;\"></A>\nFinite_cells_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_cells_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite cell. Then <I>++</I> and <I>--</I> will\niterate over finite cells. Returns <I>finite_cells_end()</I> when\n<I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_cells_iterator_finite_cells_end69_const;\"></A>\nFinite_cells_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_cells_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator_all_vertices_begin69_const;\"></A>\nAll_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary vertex. Iterates over all vertices (even the infinite\none). Returns <I>vertices_end()</I> when\n<I>t</I>.<I>number_of_vertices()</I> <MATH><I>=0</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator_all_vertices_end69_const;\"></A>\nAll_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_edges_iterator_all_edges_begin69_const;\"></A>\nAll_edges_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_edges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary edge. Iterates over all edges (even infinite\nones). Returns <I>edges_end()</I> when <I>t</I>.<I>dimension()</I> <MATH><I>&lt;1</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_edges_iterator_all_edges_end69_const;\"></A>\nAll_edges_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.all_edges_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_facets_iterator_all_facets_begin69_const;\"></A>\nAll_facets_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_facets_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary facet. Iterates over all facets (even infinite\nones). Returns <I>facets_end()</I> when \n<I>t</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_facets_iterator_all_facets_end69_const;\"></A>\nAll_facets_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_facets_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_cells_iterator_all_cells_begin69_const;\"></A>\nAll_cells_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_cells_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary cell. Iterates over all cells (even infinite\nones). Returns <I>cells_end()</I> when \n<I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_cells_iterator_all_cells_end69_const;\"></A>\nAll_cells_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.all_cells_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_begin69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.points_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Iterates over the points of the triangulation.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_end69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.points_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Cell and Facet Circulators</H3>\n<P>\n\nThe following circulators respectively visit all cells or all facets\nincident to a given edge. They are non-mutable and bidirectional. They\nare invalidated by any modification of one of the cells traversed.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6Edge_e9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_cells ( Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary cell incident to <I>e</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6Cell_handle_c+_int_i+_int_j9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_cells ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6Edge_e+_Cell_handle_start9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_cells ( Edge e,  Cell_handle start)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at cell <I>start</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH> and <I>start</I> is incident to\n<I>e</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6Cell_handle_c+_int_i+_int_j+_Cell_handle_start9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.incident_cells ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nint j,<BR>\n\nCell_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following circulators on facets are defined only in dimension&nbsp;3,\nthough facets are defined also in dimension&nbsp;2: there are only two\nfacets sharing an edge in dimension&nbsp;2.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Edge_e9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_facets ( Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary facet incident to <I>e</I>.<BR>\n\n<EM>Precondition: </EM><I>t</I>.<I>dimension()</I>&nbsp;<MATH><I>=3</I></MATH>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_facets ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Edge_e+_Facet_start9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_facets ( Edge e,  Facet start)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at facet <I>start</I>.<BR>\n\n<EM>Precondition: </EM><I>start</I> is incident to <I>e</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Edge_e+_Cell_handle_start+_int_f9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_facets ( Edge e,  Cell_handle start,  int f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at facet of index <I>f</I> in <I>start</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j+_Facet_start9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.incident_facets ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nint j,<BR>\n\nFacet start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j+_Cell_handle_start+_int_f9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.incident_facets ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nint j,<BR>\n\nCell_handle start,<BR>\n\nint f)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I> and facet <I>(start,f)</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Traversal of the incident cells and the adjacent vertices\nof a given vertex</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_incident_cells6Vertex_handle_v+_OutputIterator_cells9_const;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.incident_cells ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nOutputIterator cells)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Copies the <I>Cell_handle</I>s of all cells incident to <I>v</I> to the output\niterator <I>cells</I>.  If <I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH>, then do nothing.\nReturns the resulting output iterator.<BR>\n\n<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <I>Vertex_handle()</I>, <I>t</I>.<I>is_vertex(v)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_incident_vertices6Vertex_handle_v+_OutputIterator_vertices9_const;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.incident_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nOutputIterator vertices)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Copies the <I>Vertex_handle</I>s of all vertices incident to <I>v</I> to the\noutput iterator <I>vertices</I>.  If <I>t</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>, then do\nnothing.  Returns the resulting output iterator.<BR>\n\n<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <I>Vertex_handle()</I>, <I>t</I>.<I>is_vertex(v)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_degree6Vertex_handle_v9_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.degree ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the degree of a vertex, that is, the number of incident vertices.\nThe infinite vertex is counted.<BR>\n\n<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <I>Vertex_handle()</I>, <I>t</I>.<I>is_vertex(v)</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Checking</H3>\nThe responsibility of keeping a valid triangulation belongs to the user\nwhen using advanced operations allowing a direct manipulation of cells\nand vertices. We provide the user with the following methods to help\ndebugging.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_valid ( bool verbose = false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Checks the combinatorial validity of the triangulation. Checks also the\nvalidity of its geometric embedding (see\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).<BR>\n\nWhen <I>verbose</I> is set to true, \nmessages describing the first invalidity encountered are printed.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6Cell_handle_c+_bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_valid ( Cell_handle c,  bool verbose = false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Checks the combinatorial validity of the cell by calling the\n<I>is_valid</I> method of the <I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I> cell class. Also checks the\ngeometric validity of <I>c</I>, if <I>c</I> is finite. (See\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.)<BR>\n\nWhen <I>verbose</I> is set to <I>true</I>, messages are printed to give\na precise indication of the kind of invalidity encountered.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>I/O</H3>\n<P>\n\nC<SMALL>GAL</SMALL> provides an interface to Geomview for a 3D-triangulation. \nSee the chapter on Geomview in the Support Library manual.\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Triangulation_geomview_ostream_3.h\">CGAL/IO/Triangulation_geomview_ostream_3.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     istream&amp; is &gt;&gt;  <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> &amp;t<A NAME=\"Function_istream__operator99_6istream__is+_Triangulation_3__t9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Reads the underlying combinatorial triangulation from <I>is</I> by\ncalling the corresponding input operator of the triangulation data\nstructure class, and the non-combinatorial information by calling the\ncorresponding input operators of the vertex and the cell\nclasses. Assigns the resulting triangulation to <I>t</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     ostream&amp; os &lt;&lt;  <A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A> t<A NAME=\"Function_ostream__operator66_6ostream__os+_const_Triangulation_3__t9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Writes the triangulation <I>t</I> into <I>os</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe information in the <I>iostream</I> is: the dimension, the number of\nfinite vertices, the non-combinatorial information about vertices (point,\netc), the number of cells, the indices of the vertices of each cell,\nplus the non-combinatorial information about each cell, \nthen the indices of the neighbors of each cell, where the index\ncorresponds to the preceding list of cells. When dimension <MATH><I>&lt;</I></MATH> 3, the\nsame information is stored for faces of maximal dimension instead of\ncells.\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004\">TriangulationDataStructure_3::Vertex</A></I><BR>\n\n<I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003\">TriangulationDataStructure_3::Cell</A></I>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Delaunay_triangulation_3.html\"><I>Delaunay_triangulation_3&lt;DelaunayTriangulationTraits_3,TriangulationDataStructure_3&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_36!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 41912.0}