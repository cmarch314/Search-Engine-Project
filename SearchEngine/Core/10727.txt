{"text": "VHDL MINI REFERENCE See the VHDL Language Reference Manual VLRM for Additional Details The following Mini Reference can be divided into the following parts I Primary Design Unit Model Structure A Entity Declaration Format B Architecture II Packages A Declaration and Libraries B Identifiers Numbers Strings and Expressions C Data Types D Objects Signals Constants and Variables E Concurrent Statements 1 Signal Assignment 2 Process Statement 3 Block Statement 4 Procedure Statement 5 Component Instantiation 6 Concurrent Assertion 7 Generate Statement F Sequential Statements 1 Wait Statement 2 Signal Assignment 3 Variable Assignment 4 Procedure Call 5 Conditional Statements 6 Loop Statements 7 Procedure Statement 8 Function Statement G Other IEEE std logic Functions H Object Attributes I The TEXTIO Package PRIMARY DESIGN UNIT MODEL STRUCTURE Back To Top Each VHDL design unit comprises an entity declaration and one or more architectures Each architecture defines a different implementation or model of a given design unit The entity definition defines the inputs to and outputs from the module and any generic parameters used by the different implementations of the module Entity Declaration Format Back To Top entity name is port port definition list input output signal ports generic generic list optional generic list end name Port declaration format port name mode data type The mode of a port defines the directions of the singals on that pirt and is one of in out buffer or inout Port Modes An in port can be read but not updated within the module carrying information into the module An in port cannot appear on the left hand side of a signal assignment An out port can be updated but not read within the module carrying information out of the module An out port cannot appear on the right hand side of a signal assigment A buffer port likewise carries information out of a module but can be both updated and read within the module An inout port is bidirectional and can be both read and updated with multiple update sources possible NOTE A buffer is strictly an output port i e can only be driven from within the module while inout is truly bidirectional with drivers both within and external to the module Example entity counter is port Incr Load Clock in bit Carry out bit Data Out buffer bit vector 7 downto Data In in bit vector 7 downto end counter Generics allow static information to be communicated to a block from its environment for all architectures of a design unit These include timing information setup hold delay times part sizes and other parameters Example entity and gate is port a b in bit c out bit generic gate delay time 5ns end and gate Architecture Back To Top An architecture defines one particular implementation of a design unit at some desired level of abstraction architecture arch name of entity name is declarations begin concurrent statements end Declarations include data types constants signals files components attributes subprograms and other information to be used in the implementation description Concurrent statements describe a design unit at one or more levels of modeling abstraction including dataflow structure and or behavior Behavioral Model No structure or technology implied Usually written in sequential procedural style Dataflow Model All datapaths shown plus all control signals Structural Model Interconnection of components VHDL PACKAGES Back To Top A VHDL package contains subprograms constant definitions and or type definitions to be used throughout one or more design units Each package comprises a declaration section in which the available i e exportable subprograms constants and types are declared and a package body in which the subprogram implementations are defined along with any internally used constants and types The declaration section represents the portion of the package that is visible to the user of that package The actual implementations of subroutines in the package are typically not of interest to the users of those subroutines Package declaration format package package name is exported constant declarations exported type declarations exported subprogram declarations end package name Example package ee53 is constant maxint integer 16 ffff type arith mode type is signed unsigned function minimum constant a b in integer return integer end ee53 Package body format package body package name is exported subprogram bodies other internally used declarations end package name Example package body ee53 is function minimum constant a b integer return integer is variable c integer local variable begin if a b then c a a is min else c b b is min end if return c return min value end end ee53 Package Visibility To make all items of a package visible to a design unit precede the desired design unit with a use statement Example use library name package name all A use statement may precede the declaration of any entity or architecture which is to utilize items from the package If the use statement precedes the entity declaration the package is also visible to the architecture User Developed Packages Compile user developed packages in your current working library To make it visible use package name all Note std and work your current working library are the two default libraries The VHDL library statement is needed to make the ieee library and or additional libraries visible Example library lib name make library visible use lib name pkg name all make package visible VHDL Standard Packages STANDARD basic type declarations always visible by default TEXTIO ASCII input output data types and subprograms To make TEXTIO visible use std textio all IEEE Standard 1164 Package This package contained in the ieee library supports multi valued logic signals with type declarations and functions To make visible library ieee VHDL Library stmt use ieee std logic 1164 all Special 12 valued data types functions to interface with QuickSim II and schematic diagrams library mgc portable Special Mentor Graphics Library use mgc portable qsim logic all Quicksim portable data types VHDL IDENTIFIERS NUMBERS STRINGS AND EXPRESSIONS Back To Top Identifiers Identifiers in VHDL must begin with a letter and may comprise any combination of letters digits and underscores Note that VHDL internally converts all characters to UPPER CASE Examples Memory1 Adder Module Bus 16 Bit Numeric Constants Numeric contants can be defined and can be of any base default is decimal Numbers may include embedded underscores to improve readability Format base digits base must be a decimal number Examples 16 9fba hexadecimal 2 1111 11 1 1 11 binary 16 f 1f E 2 floating point exponent is decimal Bit String Literals Bit vector constants are are specified as literal strings Examples x ffe 12 bit hexadecimal value o 777 9 bit octal value b 1111 11 1 11 1 12 bit binary value Arithmetic and Logical Expressions Expressions in VHDL are similar to those of most high level languages Data elements must be of the type or subtypes of the same base type Operators include the following Logical and or nand nor xor not for boolean or bit ops Relational Arithmetic mod rem abs a mod b takes sign of b a rem b takes sign of a Concatenate ex a b makes one array Examples a b nand c d g1 g2 3 Bus 16 Bus1 8 Bus2 8 VHDL DATA TYPES Back To Top Each VHDL objects must be classified as being of a specific data type VHDL includes a number of predefined data types and allows users to define custom data types as needed Predefined Scalar Data Types single objects VHDL Standard bit values 1 boolean values TRUE FALSE integer values 231 to 231 1 SUN Limit natural values to integer high subtype of integer positive values 1 to integer high subtype of integer character values ASCII characters eg A time values include units eg 1 ns 2 us IEEE Standard 1164 package ieee std logic 1164 all std ulogic values U X 1 Z W H L U uninitialized X unknown W weak X Z floating H L weak 1 don t care std logic resolved std ulogic values X 1 subtype X 1 of std ulogic X 1Z subtype X 1 Z of std ulogic UX 1 subtype U X 1 of std ulogic UX 1Z subtype U X 1 Z of std ulogic Predefined VHDL Aggregate Data Types bit vector array natural range of bit string array natural range of char text file of string IEEE Standard 1164 Aggregate Data Types From package ieee std logic 1164 all std ulogic vector array natural range of std ulogic std logic vector array natural range of std logic Examples signal dbus bit vector 15 downto dbus 7 downto 4 4 bit slice of dbus signal cnt std ulogic vector 1 to 3 variable message string to 2 User Defined Enumeration Types An enumerated data type can be created by explicitely listing all possible values Example type opcodes is add sub jump call Type with 4 values signal instruc opcodes Signal of this type if instruc add then test for value add Other user defined types Custom data types can include arrays constrained and unconstrained and record structures Constrained array Upper and lower indexes are specified Example type word is array to 15 of bit Unconstrained array Indexes are specified when a signal or variable of that type is declared Examples type memory is array integer range of bit vector to 7 a type which is an arbitrary sized array of 8 bit vectors variable memory256 memory to 255 a 256 byte memory array variable stack memory 15 downto a 16 byte memory array Subtype A selected subset of values of a given type Elements of different subtypes having the same base type may be combined in expressions elements of different types cannot Subtypes can be used to detect out of range values during simulation Examples subtype byte signed is integer range 128 to 127 subtype byte unsigned is integer range to 255 Aliases An alias defines an alternate name for a signal or part of a signal Aliases are often used to refer to selected slices of a bit vector Example signal instruction bit vector 31 downto alias opcode bit vector 6 downto is instruction 31 downto 25 opcode 1 1 1 1 Set the opcode part of an instruction code VHDL OBJECTS CONSTANTS VARIABLES AND SIGNALS Back To Top Constants A constant associates a value to a symbol of a given data type The use of constants may improve the readability of VHDL code and reduce the likelihood of making errors The declaration syntax is constant symbol type value Examples constant Vcc signal 1 logic 1 constant constant zero4 bit vector to 3 Variables A variable is declared within a blocks process procedure or function and is updated immediately when an assignment statement is executed A variable can be of any scalar or aggregate data type and is utilized primarily in behavioral descriptions It can optionally be assigned initial values done only once prior to simulation The declaration syntax is variable symbol type initial value Examples process variable count integer variable rega bit vector 7 downto begin count 7 assign values to variables rega x 1 end Signals A signal is an object with a history of values related to event times i e times at which the signal value changes Signals are declared via signal declaration statements or entity port definitions and may be of any data type The declaration syntax is signal sig name data type initial value Examples signal clock bit signal GND bit signal databus std ulogic vector 15 downto signal addrbus std logic vector to 31 Each signal has one or more drivers which determine the value and timing of changes to the signal Each driver is a queue of events which indicate when and to what value a signal is to be changed Each signal assignment results in the corresponding event queue being modified to schedule the new event signal line x1 ns Driver of 2 ns 1 signal x Event Values Times NOTE If no delay is specified the signal event is scheduled for one infinitessimally small delta delay from the current time The signal change will occur in the next simulation cycle Examples Assume current time is T clock not clock after 1 ns change at T 1 ns databus mem1 and mem2 after delay change at T delay x 1 change to 1 at time T delta Element delay models may be specified as either inertial or transport Inertial delay is the default and should be used in most cases Inertial delay The addition to an event queue of an event scheduled at time T automatically cancels any events in the queue scheduled to occur prior to time T i e any event shorter than the delay time is suppressed Transport delay Each new event is simply inserted into the event queue i e behavior is that of a delay line The keyword transport is used to indicate transport delays Examples B A after 5ns inertial delay C transport A after 5 ns transport delay 5 15 17 3 A B Inertial Delay C Transport Delay 1 2 22 35 Where there are multiple drivers for one signal a resolution function must be provided to determine the value to be assigned to the signal from the values supplied by the multiple drivers This allows simulation of buses with multiple sources drivers NOTE The std logic and std logic vector types from the ieee library have predefined resolution functions Example signal data line std logic begin block1 data line 1 one driver block2 data line Z 2nd driver The resolved value is 1 since 1 overrides a Z floating value If the two values had been 1 and the resolved value would have been X indicating an unknown result CONCURRENT STATEMENTS Back To Top Concurrent statements are included within architecture definitions and within block statements representing concurrent behavior within the modelled design unit These statements are executed in an asynchronous manner with no defined order modeling the behavior of independent hardware elements within a system Concurrent Signal Assignment A signal assignment statement represents a process that assigns values to signals It has three basic formats A B A B when condition1 elseC when condition2 else D when condition3 else E with expression select A B when choice1 C when choice2 D when choice3 E when others For each of the above waveforms time value pairs can also be specified Examples A B after 1 ns when condition1 else C after 12ns when condition2 else D after 11ns 4 input multiplexer Choice is a 2 bit vector with Choice select Out In after 2ns when In1 after 2ns when 1 In2 after 2ns when 1 In3 after 2ns when 11 2 to 4 decoder Y 4 bit and A 2 bit vectors Y 1 after 2ns when A else 1 after 2ns when A 1 else 1 after 2ns when A 1 else 1 after 2ns Tri state driver Y is logic4 X is bit vector Y after 1ns when En 1 and X else 1 after 1ns when En 1 and X 1 else Z after 1ns A is a 16 bit vector A others set all bits of A to The keyword others in the last example indicates that all elements of A not explicitly listed are to be set to Process Statement Back To Top An independent sequential process represents the behavior of some portion of a design The body of a process is a list of sequential statements Syntax label process sensitivity list local declarations begin sequential statements end process label Example DFF process clock begin if clock 1 then Q D after 5ns QN not D after 5ns end if end process DFF The sequential statements in the process are executed in order commencing with the beginning of simulation After the last statement of a process has been executed the process is repeated from the first statement and continues to repeat until suspended If the optional sensitivity list is given a wait on statement is inserted after the last sequential statement causing the process to be suspended at that point until there is an event on one of the signals in the list at which time processing resumes with the first statement in the process Block Statement Back To Top A block is a grouping of related concurrent statements that can be used in representing designs in a hierarchical manner Syntax label block guard expression local declarations begin concurrent statements end block label If a guard expression is given guarded a boolean variable GUARD is automatically defined and set to the boolean value of the guard expression GUARD can then be tested within the block to perform selected signal assignments or other statements only when the guard condition evaluates to TRUE Examples D Latch Transfer D input to Q output when Enable 1 block Enable 1 begin Q guarded D after 5ns end block D Flip flop Transfer D to Q on falling edge of Clock block Clock EVENT and Clock begin Q guarded D after 5ns end block Tristate driver with input B and output A block Enable 1 begin A B when GUARD 1 else Z end block In the last example B is assigned to signal A only when GUARD is true which implies Enable 1 Concurrent Procedure Call Back To Top An externally defined procedure subroutine can be invoked with parameters passed to it as necessary This serves the same function and behaves in the same manner as a process statement with any signals in the passed parameters forming a sensitivity list Example ReadMemory DataIn DataOut RW Clk where the ReadMemory procedure is defined elsewhere Component instantiation Back To Top Instantiates i e create instances of predefined components within a design architecture Each such component is first declared in the declaration section of that architecture and then instantiated one or more times in the body of the architecture In the declaration section list the component declaration and one or more configuration specifications The component declaration defines the component interface which corresponds to the component s entity declaration This allows the VHDL compiler to check signal compatibilities Example component adder port a b in bit vector 7 downto s out bit vector 7 downto cin in bit cout out bit end component The configuration specification identifies specific architecture s to be used for each instance of the component There may be multiple architectures for a given component Examples for ALL comp1 use entity work comp1 equations for ADDER1 adder use entity work adder equations for ADDER2 adder use entity work adder dataflow In all three examples the prefix work indicates that the current working library contains the indicated component models In the first example architecture equations of entity comp1 is used for all instances of comp1 In the other examples architecture equations is to be used for instance ADDER1 of component adder and architecture dataflow is to be used for instance ADDER2 of component adder Component Instantiation Each instance of a declared component is listed an instance name assigned and actual signals connected to its ports as follows instance name component name port map port list The port list may be in either of two formats 1 Positional association signals are connected to ports in the order listed in the component declaration Ex A1 adder port map v w x y z v w and y must be bit vectors y and z bits 2 Named association each signal to port connection is listed explicitly as signal port Example A1 adder port map a v b w s y cin x cout z The signal ordering is not important in this format Example architecture r1 of register is component jkff port J K CLK in bit Q QN out bit end component for ALL jkff use entity work jkff equations Use architecture equations of entity jkff for all instances component dff port D CLK in bit Q QN out bit end component for DFF1 dff use entity work dff equations for DFF2 dff use entity work dff circuit Use different architectures of dff for instances DFF1 and DFF2 begin JKFF1 jkff port map j1 k1 clk q1 qn1 JKFF2 jkff port map j2 k1 clk q2 qn2 DFF1 dff port map d1 clk q4 qn4 DFF2 dff port map d2 clk q5 qn5 end Concurrent assertion Back To Top A concurrent assertion statement checks a condition occurrence of an event and issues a report if the condition is not true This can be used to check for timing violations illegal conditions etc An optional severity level can be reported to indicate the nature of the detected condition Syntax assert clear 1 or preset 1 report Both preset and clear are set severity warning Generate statement Back To Top A generate statement is an iterative or conditional elaboration of a portion of a description This provides a compact way to represent what would ordinarily be a group of statements Example Generate a 4 bit full adder from 1 bit full adder stages add label Note that a label is required here for i in 4 downto 1 generate FA full adder port map C i 1 A i B i C i Sum i end generate The resulting code would look like FA4 full adder port map C 3 A 4 B 4 C 4 Sum 4 FA3 full adder port map C 2 A 3 B 3 C 3 Sum 3 FA2 full adder port map C 1 A 2 B 2 C 2 Sum 2 FA1 full adder port map C A 1 B 1 C 1 Sum 1 SEQUENTIAL STATEMENTS Back To Top Sequential statements are used to define algorithms to express the behavior of a design entity These statements appear in process statements and in subprograms procedures and functions Wait statement Back To Top suspends process subprogram execution until a signal changes a condition becomes true or a defined time period has elapsed Combinations of these can also be used Syntax wait on signal name signal name until condition for time expression Example Suspend execution until one of the two conditions becomes true or for 25ns whichever occurs first wait until clock 1 or enable 1 for 25ns Signal assignment statement Back To Top Assign a waveform to one signal driver edit the event queue Example A B after 1 ns C A after 1 ns value of C is current A value Variable assignment statement Back To Top Update a process procedure function variable with an expression The update takes affect immediately Example A B and C D A value of D is new A value Procedure call Back To Top Invoke an externally defined subprogram in the same manner as a concurrent procedure call Conditional Statements Back To Top Standard if then and case constructs can be used for selective operations if condition then sequence of statements elsif condition then sequence of statements else sequence of statements end if NOTE elsif and else clauses are optional case expression is when choices sequence of statements when choices sequence of statements when others sequence of statements end case NOTE case choices can be expressions or ranges Loop statements Back To Top Sequences of statements can be repeated some number of times under the control of while or for constructs label while condition loop sequence of statements end loop label label for loop variable in range loop sequence of statements end loop label NOTE the label is optional Loop termination statements allow termination of one iteration loop or procedure next when condition end current loop iteration exit when condition exit innermost loop entirely return expression exit from subprogram NOTES 1 The next exit condition clause is optional 2 The return expression is used for functions 8 Sequential assertion same format as a concurrent assertion PROCEDURES Back To Top A procedure is a subprogram that is passed parameters and may return values via a parameter list Example procedure proc name signal clk in vlbit constant d in vlbit signal data out vlbit is local variable declarations begin sequence of statements end proc name Procedure call proc name clk1 d1 dout FUNCTIONS Back To Top A function is a subprogram that is passed parameters and returns a single value Unlike procedures functions are primarily used in expressions Example Convert bit vector to IEEE std logic vector format attributes LENGTH and RANGE are described below function bv2slv b bit vector return std logic vector is variable result std logic vector b LENGTH 1 downto begin for i in result RANGE loop case b i is when result i when 1 result i 1 end case end loop return result end Convert bit vector to unsigned natural value function b2n B bit vector return Natural is variable S bit vector B Length 1 downto B variable N Natural begin for i in S Right to S Left loop if S i 1 then N N 2 i end if end loop return N end Function Calls signal databus vector4 15 downto signal internal bit vector 15 downto variable x integer databus bv2slv internal x b2n internal Data conversion between ieee types and bit bit vector functions in ieee std logic 1164 To bit sul from std ulogic to bit To bitvector sulv from std ulogic vector std logic vector To StdULogic b from bit to std ulogic To StdLogicVector bv from bit vector or std ulogic vector To StdULogicVector bv from bit vector or std logic vector To X 1 v from bit std ulogic or std logic to X 1 To X 1Z v from bit std ulogic or std logic to X 1Z To UX 1 v from bit std ulogic or std logic to UX 1 Other ieee std logic 1164 functions Back To Top rising edge s true if rising edge on signal s std ulogic falling edge s true if falling edge on signal s std ulogic Additional Mentor Graphics supplied functions for elements of types Bit vector implemented as overloaded operator definitions library mgc portable use mgc portable qsim logic ALL Arithmetic between bit vectors use normal binary operator tokens a b a b a b a b a mod b a rem b Logical operations between all signal types and vectors of signal types in the ieee library and or nand nor xor xnor not Shift rotate left right logical arithmetic operators sll srl sra rll rrl Ex a x sll 2 shift left logical bit vector x by 2 bits Relational operations Type conversion to bit from integer to integer from bit vector OBJECT ATTRIBUTES Back To Top An object attribute returns information about a signal or data type Signal Condition Attributes for a signal S S DELAYED T value of S delayed by T time units S STABLE T true if no event on S over last T time units S QUIET T true if S quiet for T time units S LAST VALUE value of S prior to latest change S LAST EVENT time at which S last changed S LAST ACTIVE time at which S last active S EVENT true if an event has occurred on S in current cycle S ACTIVE true if signal S is active in the current cycle S TRANSACTION bit value which toggles each time signal S changes Examples if clock STABLE ns then change in clock action if no clock edge else action on edge of clock end if if clock EVENT and clock 1 then Q D after 5ns set Q to D on rising edge of clock end if Data Type Bounds Attributes of data type T T BASE base type of T T LEFT left bound of data type T T RIGHT right bound T HIGH upper bound may differ from left bound T LOW lower bound Enumeration Data Types Variable signal x of data type T T POS x position number of value of x of type T T VAL x value of type T whose position number is x T SUCC x value of type T whose position is x 1 T PRED x value of type T whose position is x 1 T LEFTOF x value of type T whose position is left of x T RIGHTOF x value of type T whose position is right of x Array Indexes for an Array A Nth index of array A A LEFT N left bound of index A RIGHT N right bound of index A HIGH N upper bound of index A LOW N lower bound of index A LENGTH N number of values in range of index A RANGE N range A LEFT to A RIGHT A REVERSE RANGE N range A LEFT downto A RIGHT NOTE For multi dimensional array Nth index must be indicated in the attribute specifier N may be omitted for a one dimensional array Examples for i in data bus RANGE loop for i in d LEFT 1 to d RIGHT 1 loop Block Attributes of a block B B BEHAVIOR true if block B contains no component instantiations B STRUCTURE true if no signal assignment statements in block B THE TEXTIO PACKAGE Back To Top TEXTIO is a package of VHDL functions that read and write text files To make the package visible use std textio all Data Types text a file of character strings line one string from a text file Example Declarations file Prog text is in file name text file file name variable L line read lines from file to L Reading Values From a File readline F L Read one line from text file F to line L read L VALUE GOOD Read one value from line L into variable VALUE GOOD is TRUE if successful Data type of VALUE can be bit bit vector integer real character string or time Writing values to a file writeline F L Write one line to text file F from line L write L VALUE JUSTIFY FIELD Write one value to line L from variable VALUE Data type of VALUE can be bit bit vector integer real character string or time JUSTIFY is left or right to justify within the field FIELD is the desired field width of the written value Back To Top", "_id": "http://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl.html", "title": "", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head>\n\n\n   <meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n   <meta name=\"GENERATOR\" content=\"Microsoft FrontPage 5.0\">\n   <meta name=\"OPERATOR\" content=\"Victor P Nelson\">\n</head><body>\n\n<h1>\n<a name=\"top\"></a>VHDL MINI-REFERENCE</h1>\n\n<h4>\nSee the VHDL Language Reference Manual (<b>VLRM</b>) for Additional Details</h4>\nThe following Mini-Reference can be divided into the following parts:\n<p>I.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#primary\">Primary Design Unit\nModel Structure</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.&nbsp;&nbsp;&nbsp; <a href=\"#entity\">Entity\nDeclaration Format</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.&nbsp;&nbsp;&nbsp; <a href=\"#architecture\">Architecture</a>\n<br>II.&nbsp;&nbsp;&nbsp; <a href=\"#packages\">Packages</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.&nbsp;&nbsp;&nbsp; <a href=\"#packages\">Declaration\nand Libraries</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.&nbsp;&nbsp;&nbsp; <a href=\"#numbers\">Identifiers,\nNumbers, Strings, and Expressions</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.&nbsp;&nbsp;&nbsp; <a href=\"#data\">Data\nTypes</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D.&nbsp;&nbsp;&nbsp; <a href=\"#objects\">Objects:\nSignals, Constants, and Variables</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E.&nbsp;&nbsp;&nbsp; <a href=\"#concurrent\">Concurrent\nStatements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#concurrent\">Signal\nAssignment</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#process\">Process\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#block\">Block Statement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#procedure\">Procedure\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#instantiation\">Component\nInstantiation</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#assertion\">Concurrent\nAssertion</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#generate\">Generate\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F.&nbsp;&nbsp;&nbsp; <a href=\"#sequential\">Sequential\nStatements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#wait\">Wait Statement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#seq_assign\">Signal\nAssignment</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#var_assign\">Variable\nAssignment</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#procedure_call\">Procedure\nCall</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#conditional\">Conditional\nStatements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#loop\">Loop Statements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#procedure_syntax\">Procedure\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#function_syntax\">Function\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G.&nbsp;&nbsp;&nbsp; <a href=\"#other_ieee\">Other\nIEEE \"std.logic\" Functions</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H.&nbsp;&nbsp;&nbsp; <a href=\"#object_attr\">Object\nAttributes</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I.&nbsp;&nbsp;&nbsp;&nbsp;\n<a href=\"#textio\">The TEXTIO Package</a>\n</p><h1>\n<a name=\"primary\"></a>PRIMARY DESIGN UNIT MODEL STRUCTURE - <a href=\"#top\">Back\nTo Top</a></h1>\nEach VHDL design unit comprises an \"entity\" declaration and one or more\n\"architectures\". Each architecture defines a different implementation or\nmodel of a given design unit. The entity definition defines the inputs\nto, and outputs from the module, and any \"generic\" parameters used by the\ndifferent implementations of the module.\n<h2>\n<a name=\"entity\"></a>Entity Declaration Format - <a href=\"#top\">Back To\nTop</a></h2>\n\n<pre>&nbsp;&nbsp;&nbsp; <b>entity</b>&nbsp; name&nbsp; <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>port(</b> port definition list <b>);</b>-- input/output signal ports\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>generic(</b> generic list<b>);</b>&nbsp;&nbsp; -- optional generic list\n&nbsp;&nbsp;&nbsp; <b>end</b> name;</pre>\nPort declaration format: <i>port_name: mode data_type;</i>\n<p>The <i>mode</i> of a port defines the directions of the singals on that\npirt, and is one of: <b>in</b>, <b>out</b>, <b>buffer</b>, or\n<b>inout</b>.\n</p><dl>Port Modes:\n<dt>\nAn <b>in</b> port</dt>\n\n<dd>\ncan be read but not updated within the module, carrying information into\nthe module. (An in port cannot appear on the left hand side of a signal\nassignment.)</dd>\n\n<dt>\nAn <b>out</b> port</dt>\n\n<dd>\ncan be updated but not read within the module, carrying information out\nof the module. (An out port cannot appear on the right hand side of a signal\nassigment.)</dd>\n\n<dt>\nA <b>buffer</b> port</dt>\n\n<dd>\nlikewise carries information out of a module, but can be both updated and\nread within the module.</dd>\n\n<dt>\nAn <b>inout</b> port</dt>\n\n<dd>\nis bidirectional and can be both read and updated, with multiple update\nsources possible.</dd>\n</dl>\n\n<li>\nNOTE: A buffer is strictly an output port, i.e. can only be driven from\nwithin the module, while inout is truly bidirectional with drivers both\nwithin and external to the module.</li>\n\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; entity counter is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port (Incr, Load, Clock: in&nbsp;&nbsp;&nbsp;&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Carry:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data_Out:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer bit_vector(7 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data_In:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp; bit_vector(7 downto 0));\n&nbsp;&nbsp; end counter;</pre>\n<b>Generics</b> allow static information to be communicated to a block\nfrom its environment for all architectures of a design unit. These include\ntiming information (setup, hold, delay times), part sizes, and other parameters.\n<h4>\n<b>Example</b></h4>\n\n<pre>&nbsp;&nbsp;&nbsp; entity and_gate is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(a,b: in&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c:&nbsp;&nbsp; out bit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generic (gate_delay: time := 5ns);\n&nbsp;&nbsp;&nbsp; end and_gate;</pre>\n\n<h2>\n<a name=\"architecture\"></a>Architecture - <a href=\"#top\">Back To Top</a></h2>\nAn architecture defines one particular implementation of a design unit,\nat some desired level of abstraction.\n<pre>&nbsp; <b>architecture</b> arch_name <b>of</b> entity_name <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp; declarations ...\n&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp; concurrent statements&nbsp; ...\n&nbsp;&nbsp; end</pre>\n<i>Declarations</i> include data types, constants, signals, files, components,\nattributes, subprograms, and other information to be used in the implementation\ndescription. <i>Concurrent statements</i> describe a design unit at one\nor more levels of modeling abstraction, including dataflow, structure,\nand/or behavior.\n<ul>\n<li>\n<b>Behavioral Model:</b> No structure or technology implied. Usually written\nin sequential, procedural style.</li>\n\n<li>\n<b>Dataflow Model:</b> All datapaths shown, plus all control signals.</li>\n\n<li>\n<b>Structural Model:</b> Interconnection of components.</li>\n</ul>\n\n<h1>\n<a name=\"packages\"></a>VHDL PACKAGES - <a href=\"#top\">Back To Top</a></h1>\nA VHDL <i>package</i> contains subprograms, constant definitions, and/or\ntype definitions to be used throughout one or more design units. Each package\ncomprises a \"declaration section\", in which the available (i.e. exportable)\nsubprograms, constants, and types are declared, and a \"package body\", in\nwhich the subprogram implementations are defined, along with any internally-used\nconstants and types. The declaration section represents the portion of\nthe package that is \"visible\" to the user of that package. The actual implementations\nof subroutines in the package are typically not of interest to the users\nof those subroutines.\n<h3>\nPackage declaration format:</h3>\n\n<pre>&nbsp;&nbsp; <b>package</b> package_name <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp; ... exported constant declarations\n&nbsp;&nbsp;&nbsp;&nbsp; ... exported type declarations\n&nbsp;&nbsp;&nbsp;&nbsp; ... exported subprogram declarations\n&nbsp;&nbsp; <b>end</b> package_name;</pre>\n\n<h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; package ee530 is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant maxint: integer := 16#ffff#;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type arith_mode_type is (signed, unsigned);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function minimum(constant a,b: in integer) return integer;\n&nbsp;&nbsp;&nbsp; end ee530;</pre>\n\n<h3>\nPackage body format:</h3>\n\n<pre>&nbsp;&nbsp; <b>package body</b> package_name <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... exported subprogram bodies\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... other internally-used declarations\n&nbsp;&nbsp; <b>end</b> package_name;</pre>\n\n<h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp; package body ee530 is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function minimum (constant a,b: integer) return integer is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable c: integer; -- local variable\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if a &lt; b then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c := a;&nbsp; -- a is min\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c := b;&nbsp; -- b is min\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c;&nbsp; -- return min value\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;\n&nbsp;&nbsp;&nbsp; end ee530;</pre>\n\n<h3>\nPackage Visibility</h3>\nTo make all items of a package \"visible\" to a design unit, precede the\ndesired design unit with a \"use\" statement:\n<h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp; <b>use</b> library_name.package_name.all</pre>\nA \"use\" statement may precede the declaration of any entity or architecture\nwhich is to utilize items from the package. If the \"use\" statement precedes\nthe entity declaration, the package is also visible to the architecture.\n<h3>\nUser-Developed Packages</h3>\nCompile user-developed packages in your current working library. To make\nit visible:\n<pre>&nbsp;&nbsp;&nbsp; <b>use</b> package_name<b>.all;</b></pre>\nNote: '<b>std</b>' and '<b>work</b>' (your current working library) are\nthe two default libraries. The VHDL 'library' statement is needed to make\nthe 'ieee' library and/or additional libraries visible.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; <b>library</b> lib_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- make library visible\n&nbsp;&nbsp; <b>use</b> lib_name.pkg_name.all;&nbsp;&nbsp; -- make package visible</pre>\n\n<h3>\nVHDL Standard Packages</h3>\n\n<ul>STANDARD - basic type declarations (always visible by default)\n<br>TEXTIO - ASCII input/output data types and subprograms</ul>\nTo make TEXTIO visible: <b>use</b> std.textio.all;\n<h3>\nIEEE Standard 1164 Package</h3>\nThis package contained in the 'ieee' library supports multi-valued logic\nsignals with type declarations and functions. To make visible:\n<pre>&nbsp;&nbsp; <b>library ieee;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- VHDL Library stmt\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>use</b> <b>ieee.</b>std_logic_1164<b>.all;</b></pre>\n\n<h3>\nSpecial 12-valued data types/functions to interface with QuickSim II and\nschematic diagrams.</h3>\n\n<pre>&nbsp;&nbsp; library mgc_portable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Special Mentor Graphics Library\n&nbsp;&nbsp; use mgc_portable.qsim_logic.all; -- Quicksim portable data types</pre>\n\n<h2>\n<a name=\"numbers\"></a>VHDL IDENTIFIERS, NUMBERS, STRINGS, AND EXPRESSIONS\n- <a href=\"#top\">Back To Top</a></h2>\n\n<h3>\nIdentifiers</h3>\nIdentifiers in VHDL must begin with a letter, and may comprise any combination\nof letters, digits, and underscores. Note that VHDL internally converts\nall characters to UPPER CASE.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp; Memory1, Adder_Module, Bus_16_Bit</pre>\n\n<h3>\nNumeric Constants</h3>\nNumeric contants can be defined, and can be of any base (default is decimal).\nNumbers may include embedded underscores to improve readability.\n<p>Format: <b>base#digits#</b> -- base must be a decimal number\n</p><h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp; 16#9fba#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hexadecimal)\n&nbsp;&nbsp;&nbsp;&nbsp; 2#1111_1101_1011#&nbsp; (binary)\n&nbsp;&nbsp;&nbsp;&nbsp; 16#f.1f#E+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (floating-point, exponent is decimal)\n\n</pre>\n\n<h3>\nBit String Literals</h3>\nBit vector constants are are specified as literal strings.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp; x\"ffe\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (12-bit hexadecimal value)\n&nbsp;&nbsp;&nbsp;&nbsp; o\"777\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (9-bit octal value)\n&nbsp;&nbsp;&nbsp;&nbsp; b\"1111_1101_1101\" (12-bit binary value)</pre>\n\n<h3>\nArithmetic and Logical Expressions</h3>\nExpressions in VHDL are similar to those of most high-level languages.\nData elements must be of the type, or subtypes of the same base type. Operators\ninclude the following:\n<ul>\n<li>\nLogical: <b>and</b>, <b>or</b>, <b>nand</b>, <b>nor</b>,\n<b>xor</b>, <b>not</b>\n(for boolean or bit ops)</li>\n\n<li>\nRelational: =, /=, &lt;, &lt;=, &gt;, &gt;=</li>\n\n<li>\nArithmetic: +, -, *, /, mod, rem, **, abs</li>\n\n<br>(a mod b takes sign of b, a rem b takes sign of a)\n<li>\nConcatenate: <b>&amp;</b></li>\n\n<br>(ex. a &amp; b makes one array)</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; a &lt;= b nand c;\n&nbsp;&nbsp; d := g1 * g2 / 3;\n&nbsp;&nbsp; Bus_16 &lt;= Bus1_8 &amp; Bus2_8;</pre>\n\n<h2>\n<a name=\"data\"></a>VHDL DATA TYPES - <a href=\"#top\">Back To Top</a></h2>\nEach VHDL objects must be classified as being of a specific data type.\nVHDL includes a number of predefined data types, and allows users to define\ncustom data types as needed.\n<h3>\nPredefined Scalar Data Types (single objects)</h3>\n\n<h4>\nVHDL Standard:</h4>\n\n<ul>\n<li>\n<b>bit</b> values: '0', '1'</li>\n\n<li>\n<b>boolean</b> values: TRUE, FALSE</li>\n\n<li>\n<b>integer</b> values: -(231) to +(231 - 1) {SUN Limit}</li>\n\n<li>\n<b>natural</b> values: 0 to integer'high (subtype of integer)</li>\n\n<li>\n<b>positive</b> values: 1 to integer'high (subtype of integer)</li>\n\n<li>\n<b>character</b> values: ASCII characters (eg. 'A')</li>\n\n<li>\n<b>time</b> values include units (eg. 10ns, 20us)</li>\n</ul>\n\n<h4>\nIEEE Standard 1164 (package ieee.std_logic_1164.all)</h4>\n\n<ul>\n<li>\n<b>std_ulogic</b> values: 'U','X','1','0','Z','W','H','L','-'</li>\n\n<ul>'U' = uninitialized\n<br>'X' = unknown\n<br>'W' = weak 'X'\n<br>'Z' = floating\n<br>'H'/'L' = weak '1'/'0'\n<br>'-' = don't care</ul>\n\n<li>\n<b>std_logic</b> resolved \"std_ulogic\" values</li>\n\n<li>\n<b>X01</b> subtype {'X','0','1'} of std_ulogic</li>\n\n<li>\n<b>X01Z</b> subtype {'X','0','1','Z'} of std_ulogic</li>\n\n<li>\n<b>UX01</b> subtype {'U','X','0','1'} of std_ulogic</li>\n\n<li>\n<b>UX01Z</b> subtype {'U','X','0','1','Z'} of std_ulogic</li>\n</ul>\n\n<h3>\nPredefined VHDL Aggregate Data Types</h3>\n\n<ul>\n<li>\n<b>bit_vector</b> array (natural range &lt;&gt;) of bit</li>\n\n<li>\n<b>string</b> array (natural range &lt;&gt;) of char</li>\n\n<li>\n<b>text</b> file of \"string\"</li>\n</ul>\n\n<h3>\nIEEE Standard 1164 Aggregate Data Types</h3>\n(From package: <i>ieee.std_logic_1164.all</i>)\n<ul>\n<li>\n<b>std_ulogic_vector</b> array (natural range &lt;&gt;) of std_ulogic</li>\n\n<li>\n<b>std_logic_vector</b> array (natural range &lt;&gt;) of std_logic</li>\n</ul>\n\n<h4>\n<b>Examples</b></h4>\n\n<pre>&nbsp;&nbsp;&nbsp; signal dbus: bit_vector(15 downto 0);\n&nbsp;&nbsp;&nbsp; dbus (7 downto 4) &lt;= \"0000\"; (4-bit slice of dbus)\n&nbsp;&nbsp;&nbsp; signal cnt:&nbsp; std_ulogic_vector(1 to 3);\n&nbsp;&nbsp;&nbsp; variable message: string(0 to 20);</pre>\n\n<h3>\nUser-Defined Enumeration Types</h3>\nAn enumerated data type can be created by explicitely listing all possible\nvalues.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; type opcodes is (add, sub, jump, call);&nbsp; -- Type with 4 values\n&nbsp;&nbsp; signal instruc: opcodes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Signal of this type\n&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; if instruc = add then&nbsp;&nbsp; -- test for value 'add'\n&nbsp;&nbsp;&nbsp;&nbsp; ...</pre>\n\n<h3>\nOther user-defined types</h3>\nCustom data types can include arrays, constrained and unconstrained, and\nrecord structures.\n<ul>\n<li>\n<i>Constrained array:</i> Upper and lower indexes are specified.</li>\n\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; <b>type</b> word <b>is</b> <b>array</b> (0 to 15) <b>of</b> bit;</pre>\n\n<li>\n<i>Unconstrained array:</i> Indexes are specified when a signal or variable\nof that type is declared.</li>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; <b>type</b> memory <b>is</b> array (integer range &lt;&gt;) of bit_vector(0 to 7);\n&nbsp; -- a type which is an arbitrary-sized array of 8-bit vectors\n&nbsp;&nbsp; <b>variable</b> memory256: memory(0 to 255); -- a 256-byte memory array\n&nbsp;&nbsp; <b>variable</b> stack: memory(15 downto 0);&nbsp; -- a 16-byte memory array</pre>\n\n<li>\n<i>Subtype:</i> A selected subset of values of a given type. Elements of\ndifferent subtypes having the same base type may be combined in expressions\n(elements of different types cannot). Subtypes can be used to detect out-of-range\nvalues during simulation.</li>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; <b>subtype</b> byte_signed <b>is</b> integer <b>range</b> -128 to 127;\n&nbsp;&nbsp; <b>subtype</b> byte_unsigned <b>is</b> integer <b>range</b> 0 to 255;</pre>\n</ul>\n\n<h3>\nAliases</h3>\nAn alias\" defines an alternate name for a signal or part of a signal. Aliases\nare often used to refer to selected slices of a bit_vector.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; signal instruction: bit_vector(31 downto 0);\n&nbsp;&nbsp; alias opcode: bit_vector(6 downto 0) is instruction(31 downto 25);\n&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp; opcode &lt;= \"1010101\";&nbsp; -- Set the opcode part of an instruction code</pre>\n&nbsp;\n<h2>\n<a name=\"objects\"></a>VHDL OBJECTS: CONSTANTS, VARIABLES, AND SIGNALS -\n<a href=\"#top\">Back\nTo Top</a></h2>\n\n<h3>\nConstants</h3>\nA <i>constant</i> associates a value to a symbol of a given data type.\nThe use of constants may improve the readability of VHDL code and reduce\nthe likelihood of making errors. The declaration syntax is:\n<ul><b>constant</b> symbol: type := value;</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp; <b>constant</b>&nbsp; Vcc:&nbsp; signal:= '1';&nbsp;&nbsp; --logic 1 constant\n&nbsp; <b>constant</b>&nbsp; zero4: bit_vector(0 to 3) := ('0','0','0','0');</pre>\n\n<h3>\nVariables</h3>\nA <i>variable</i> is declared within a blocks, process, procedure, or function,\nand is updated immediately when an assignment statement is executed. A\nvariable can be of any scalar or aggregate data type, and is utilized primarily\nin behavioral descriptions. It can optionally be assigned initial values\n(done only once prior to simulation). The declaration syntax is:\n<ul><b>variable</b> symbol: type [:= initial_value];</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; process\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable count: integer&nbsp; := 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable rega: bit_vector(7 downto 0);\n&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count := 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- assign values to variables\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rega&nbsp; := x\"01\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp; end;</pre>\n\n<h3>\nSignals</h3>\nA <i>signal</i> is an object with a history of values (related to \"event\"\ntimes, i.e. times at which the signal value changes).\n<p>Signals are declared via signal declaration statements or entity port\ndefinitions, and may be of any data type. The declaration syntax is:\n</p><ul><b>signal</b> sig_name: data_type [:=initial_value];</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; signal clock: bit;\n&nbsp;&nbsp;&nbsp; signal GND:&nbsp;&nbsp; bit := '0';\n&nbsp;&nbsp;&nbsp; signal databus: std_ulogic_vector(15 downto 0);\n&nbsp;&nbsp;&nbsp; signal addrbus: std_logic_vector(0 to 31);</pre>\nEach signal has one or more \"drivers\" which determine the value and timing\nof changes to the signal. Each driver is a queue of events which indicate\nwhen and to what value a signal is to be changed. Each signal assignment\nresults in the corresponding event queue being modified to schedule the\nnew event.\n<blockquote>\n<li>\nsignal line x</li>\n\n<p><br>10ns '0' Driver of\n</p><p>20ns '1' signal x\n</p><li>\nEvent Values</li>\n\n<li>\nTimes</li>\n</blockquote>\nNOTE: If no delay is specified, the signal event is scheduled for one infinitessimally-small\n\"delta\" delay from the current time. The signal change will occur in the\nnext simulation cycle.\n<h4>\nExamples</h4>\n(Assume current time is T)\n<pre>&nbsp;&nbsp;&nbsp; clock&nbsp;&nbsp; &lt;= not clock after 10ns;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- change at T + 10ns\n&nbsp;&nbsp;&nbsp; databus &lt;= mem1 and mem2 after delay; -- change at T + delay\n&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= '1';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- change to '1' at time T + \"delta\";</pre>\nElement delay models may be specified as either \"inertial\" or \"transport\".\nInertial delay is the default, and should be used in most cases.\n<ul>\n<li>\n<b>Inertial delay:</b> The addition to an event queue of an event scheduled\nat time T automatically cancels any events in the queue scheduled to occur\nprior to time T, i.e. any event shorter than the delay time is suppressed.</li>\n\n<li>\n<b>Transport delay</b>: Each new event is simply inserted into the event\nqueue, i.e. behavior is that of a delay line. The keyword <b>transport</b>\nis used to indicate transport delays.</li>\n</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; B &lt;= A after 5ns;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- inertial delay\n&nbsp;&nbsp;&nbsp; C &lt;= transport A after 5 ns; -- transport delay</pre>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5______15 17_________30\n&nbsp;&nbsp;&nbsp; A _______|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_____________&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ____________________\n&nbsp;&nbsp;&nbsp; B ___________|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_________ (Inertial Delay)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _______&nbsp;&nbsp; __________\n&nbsp;&nbsp;&nbsp; C ___________|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_________ (Transport Delay)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20 22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35</pre>\nWhere there are multiple drivers for one signal, a \"resolution function\"\nmust be provided to determine the value to be assigned to the signal from\nthe values supplied by the multiple drivers. This allows simulation of\nbuses with multiple sources/drivers.\n<p>NOTE: The <i>std_logic</i> and <i>std_logic_vector</i> types from the\nieee library have predefined resolution functions:\n</p><h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; signal data_line: std_logic;\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block1:&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_line &lt;= '1';&nbsp;&nbsp;&nbsp;&nbsp; -- one driver\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block2:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_line &lt;= 'Z';&nbsp; -- 2nd driver</pre>\nThe resolved value is '1' since '1' overrides a 'Z' (floating) value. If\nthe two values had been '1' and '0', the resolved value would have been\n'X', indicating an unknown result.\n<h2>\n<a name=\"concurrent\"></a>CONCURRENT STATEMENTS - <a href=\"#top\">Back To\nTop</a></h2>\nConcurrent statements are included within architecture definitions and\nwithin \"block\" statements, representing concurrent behavior within the\nmodelled design unit. These statements are executed in an asynchronous\nmanner, with no defined order, modeling the behavior of independent hardware\nelements within a system.\n<h3>\nConcurrent Signal Assignment</h3>\nA signal assignment statement represents a process that assigns values\nto signals. It has three basic formats.\n<ol>\n<li>\nA &lt;= B;&nbsp;<l1>A &lt;= B when condition1 elseC <b>when</b> condition2\n<b>else</b>\nD <b>when</b> condition3 <b>else</b> E;</l1></li>\n\n<li>\n<b>with</b> expression <b>select</b> A <b>&lt;=</b> B <b>when</b> choice1,\nC <b>when</b> choice2, D <b>when</b> choice3, E when others;</li>\n</ol>\nFor each of the above, waveforms (time-value pairs) can also be specified.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; A &lt;= B after 10ns when condition1 else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C after 12ns when condition2 else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D after 11ns;\n\n&nbsp;&nbsp;&nbsp; -- 4-input multiplexer (Choice is a 2-bit vector)\n&nbsp;&nbsp;&nbsp; with Choice select&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Out &lt;=&nbsp; In0 after 2ns when \"00\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In1 after 2ns when \"01\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In2 after 2ns when \"10\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In3 after 2ns when \"11\";\n\n&nbsp;&nbsp;&nbsp; -- 2-to-4 decoder (Y = 4-bit and A = 2-bit vectors)\n&nbsp;&nbsp;&nbsp; Y &lt;= \"0001\" after 2ns when A = \"00\" else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"0010\" after 2ns when A = \"01\" else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"0100\" after 2ns when A = \"10\" else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"1000\" after 2ns ;\n\n&nbsp;&nbsp;&nbsp; -- Tri-state driver: (Y is logic4; X is bit_vector)\n&nbsp;&nbsp;&nbsp; Y &lt;= '0' after 1ns when En = '1' and X = '0' else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '1' after 1ns when En = '1' and X = '1' else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Z' after 1ns;\n\n&nbsp;&nbsp;&nbsp; -- A is a 16-bit vector\n&nbsp;&nbsp;&nbsp; A &lt;= (others =&gt; '0');&nbsp;&nbsp; -- set all bits of A to '0'</pre>\nThe keyword \"others\" in the last example indicates that all elements of\nA not explicitly listed are to be set to '0'.\n<h3>\n<a name=\"process\"></a>Process Statement - <a href=\"#top\">Back To Top</a></h3>\nAn independent sequential process represents the behavior of some portion\nof a design. The body of a process is a list of sequential statements.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; label: <b>process</b> (sensitivity list)&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... local declarations ...&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequential statements ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>end process</b> label;</pre>\n\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; DFF: process (clock)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if clock = '1' then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q&nbsp; &lt;= D after 5ns;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QN &lt;= not D after 5ns;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end process DFF;</pre>\nThe sequential statements in the process are executed in order, commencing\nwith the beginning of simulation. After the last statement of a process\nhas been executed, the process is repeated from the first statement, and\ncontinues to repeat until suspended. If the optional sensitivity list is\ngiven, a <b>wait on</b> ... statement is inserted after the last sequential\nstatement, causing the process to be suspended at that point until there\nis an event on one of the signals in the list, at which time processing\nresumes with the first statement in the process.\n<h3>\n<a name=\"block\"></a>Block Statement - <a href=\"#top\">Back To Top</a></h3>\nA <i>block</i> is a grouping of related concurrent statements that can\nbe used in representing designs in a hierarchical manner.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp; label: <b>block</b> (guard expression)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... local declarations ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... concurrent statements ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end block label;</pre>\nIf a <i>guard expression</i> is given, \"guarded\" a boolean variable GUARD\nis automatically defined and set to the boolean value of the guard expression.\nGUARD can then be tested within the block, to perform selected signal assignments\nor other statements only when the guard condition evaluates to TRUE.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; -- D Latch: Transfer D input to Q output when Enable = '1'&nbsp;\n&nbsp;&nbsp;&nbsp; block (Enable = '1')\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q &lt;= guarded D after 5ns;\n\n&nbsp;&nbsp;&nbsp; end block;\n\n&nbsp;&nbsp;&nbsp; -- D Flip-flop: Transfer D to Q on falling edge of Clock\n&nbsp;&nbsp;&nbsp; block (Clock'EVENT and Clock = '0')\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q &lt;= guarded D after 5ns;\n&nbsp;&nbsp;&nbsp; end block;\n\n&nbsp;&nbsp;&nbsp; -- Tristate driver with input B and output A&nbsp;\n&nbsp;&nbsp;&nbsp; block (Enable = '1')\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A &lt;= B when GUARD = '1' else 'Z';\n&nbsp;&nbsp;&nbsp; end block;\n\n</pre>\nIn the last example, B is assigned to signal A only when GUARD is true,\nwhich implies Enable = '1'.\n<h3>\n<a name=\"procedure\"></a>Concurrent Procedure Call - <a href=\"#top\">Back\nTo Top</a></h3>\nAn externally defined procedure/subroutine can be invoked, with parameters\npassed to it as necessary. This serves the same function and behaves in\nthe same manner as a \"process\" statement, with any signals in the passed\nparameters forming a sensitivity list.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; ReadMemory (DataIn, DataOut, RW, Clk);\n&nbsp;&nbsp; (where the ReadMemory procedure is defined elsewhere)</pre>\n\n<h3>\n<a name=\"instantiation\"></a>Component instantiation - <a href=\"#top\">Back\nTo Top</a></h3>\nInstantiates (i.e. create instances of) predefined components within a\ndesign architecture. Each such component is first declared in the declaration\nsection of that architecture, and then \"instantiated\" one or more times\nin the body of the architecture.\n<ul>\n<li>\nIn the declaration section: list the \"component declaration\" and one or\nmore \"configuration specifications\".<br>\n<br></li>\n\n<br>The \"component declaration\" defines the component interface, which\ncorresponds to the component's entity declaration. This allows the VHDL\ncompiler to check signal compatibilities.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; component adder\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(a,b:&nbsp; in&nbsp; bit_vector(7 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s:&nbsp;&nbsp;&nbsp; out bit_vector(7 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin:&nbsp; in&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout: out bit);\n&nbsp;&nbsp;&nbsp; end component;</pre>\n\n<li>\nThe \"configuration specification\" identifies specific architecture(s) to\nbe used for each instance of the component. (There may be multiple architectures\nfor a given component.)</li>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; for ALL:&nbsp;&nbsp;&nbsp;&nbsp; comp1 use entity work.comp1 (equations);\n&nbsp;&nbsp;&nbsp; for ADDER1:&nbsp; adder use entity work.adder (equations);\n&nbsp;&nbsp;&nbsp; for ADDER2:&nbsp; adder use entity work.adder (dataflow);</pre>\nIn all three examples, the prefix <b>work.</b> indicates that the current\nworking library contains the indicated component models. In the first example,\narchitecture <i>equations</i> of entity\n<i>comp1</i> is used for all instances\nof <i>comp1</i>. In the other examples, architecture <i>equations</i> is\nto be used for instance <i>ADDER1</i> of component <i>adder</i>, and architecture\n<i>dataflow</i>\nis to be used for instance ADDER2 of component <i>adder</i>.</ul>\n\n<h3>\nComponent Instantiation Each instance of a declared component is listed,\nan instance name assigned, and actual signals connected to its ports as\nfollows:</h3>\n\n<ul>instance_name: component_name <b>port map</b> (port list);</ul>\nThe port list may be in either of two formats:\n<li>\n(1) \"Positional association\": signals are connected to ports in the order\nlisted in the component declaration.</li>\n\n<li>\nEx. A1: adder port map (v,w,x,y,z)</li>\n\n<ul>\n<li>\nv,w, and y must be bit_vectors, y and z bits</li>\n</ul>\n\n<li>\n(2) \"Named association\": each signal-to-port connection is listed explicitly\nas \"signal=&gt;port\".</li>\n\n<h4>\nExample</h4>\nA1: adder port map(a=&gt;v, b=&gt;w, s=&gt;y, cin-&gt;x, cout-&gt;z);\n<p>(The signal ordering is not important in this format)\n</p><h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; architecture r1 of register is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component jkff\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(J,K,CLK: in bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q,QN:&nbsp;&nbsp;&nbsp; out bit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end component;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ALL: jkff use entity work.jkff (equations);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Use architecture <i>equations</i> of entity jkff\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for all instances\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component dff\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(D,CLK: in bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q,QN:&nbsp; out bit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end component;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for DFF1: dff&nbsp; use entity work.dff&nbsp; (equations);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for DFF2: dff&nbsp; use entity work.dff&nbsp; (circuit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --Use different architectures of <i>dff</i> for instances\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFF1 and DFF2\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JKFF1: jkff port map (j1,k1,clk,q1,qn1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JKFF2: jkff port map (j2,k1,clk,q2,qn2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFF1:&nbsp; dff&nbsp; port map (d1,clk,q4,qn4);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFF2:&nbsp; dff&nbsp; port map (d2,clk,q5,qn5);\n&nbsp;&nbsp;&nbsp; end.</pre>\n\n<h3>\n<a name=\"assertion\"></a>Concurrent assertion - <a href=\"#top\">Back To Top</a></h3>\nA <i>concurrent assertion statement</i> checks a condition (occurrence\nof an event) and issues a report if the condition is not true. This can\nbe used to check for timing violations, illegal conditions, etc. An optional\nseverity level can be reported to indicate the nature of the detected condition.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; <b>assert</b>&nbsp; (clear /= '1') or (preset /= '1')\n&nbsp;&nbsp;&nbsp; <b>report</b> \"Both preset and clear are set!\"\n&nbsp;&nbsp;&nbsp; <b>severity warning;</b></pre>\n\n<h3>\n<a name=\"generate\"></a>Generate statement - <a href=\"#top\">Back To Top</a></h3>\nA <i>generate statement</i> is an iterative or conditional elaboration\nof a portion of a description. This provides a compact way to represent\nwhat would ordinarily be a group of statements.\n<h4>\nExample</h4>\nGenerate a 4-bit full adder from 1-bit full_adder stages:\n<pre>&nbsp; add_label:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Note that a label is required here\n&nbsp;&nbsp;&nbsp; for i in 4 downto 1 generate\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FA: full_adder port map(C(i-1), A(i), B(i), C(i), Sum(i));\n&nbsp;&nbsp;&nbsp; end generate;</pre>\n\n<pre>The resulting code would look like:\n\n&nbsp;&nbsp;&nbsp; FA4: full_adder port map(C(3), A(4), B(4), C(4), Sum(4));\n&nbsp;&nbsp;&nbsp; FA3: full_adder port map(C(2), A(3), B(3), C(3), Sum(3));\n&nbsp;&nbsp;&nbsp; FA2: full_adder port map(C(1), A(2), B(2), C(2), Sum(2));\n&nbsp;&nbsp;&nbsp; FA1: full_adder port map(C(0), A(1), B(1), C(1), Sum(1));</pre>\n\n<h2>\n<a name=\"sequential\"></a>SEQUENTIAL STATEMENTS - <a href=\"#top\">Back To\nTop</a></h2>\nSequential statements are used to define algorithms to express the behavior\nof a design entity. These statements appear in process statements and in\nsubprograms (procedures and functions).\n<h3>\n<a name=\"wait\"></a>Wait statement - <a href=\"#top\">Back To Top</a></h3>\n- suspends process/subprogram execution until a signal changes, a condition\nbecomes true, or a defined time period has elapsed. Combinations of these\ncan also be used.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; <b>wait</b> [<b>on</b> signal_name {,signal_name}]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<b>until</b> condition]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<b>for</b> time expression]</pre>\n\n<h4>\nExample</h4>\nSuspend execution until one of the two conditions becomes true, or for\n25ns, whichever occurs first.\n<pre>&nbsp;&nbsp;&nbsp; wait until clock = '1' or enable /='1' for 25ns;</pre>\n\n<h3>\n<a name=\"seq_assign\"></a>Signal assignment statement - <a href=\"#top\">Back\nTo Top</a></h3>\nAssign a waveform to one signal driver (edit the event queue).\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; A &lt;= B after 10ns;\n&nbsp;&nbsp;&nbsp; C &lt;= A after 10ns;&nbsp; -- value of C is current A value</pre>\n\n<h3>\n<a name=\"var_assign\"></a>Variable assignment statement - <a href=\"#top\">Back\nTo Top</a></h3>\nUpdate a process/procedure/function variable with an expression. The update\ntakes affect immediately.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; A := B and C;\n&nbsp;&nbsp;&nbsp; D := A;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- value of D is new A value</pre>\n\n<h3>\n<a name=\"procedure_call\"></a>Procedure call - <a href=\"#top\">Back To Top</a></h3>\nInvoke an externally-defined subprogram in the same manner as a concurrent\nprocedure call.\n<h3>\n<a name=\"conditional\"></a>Conditional Statements - <a href=\"#top\">Back\nTo Top</a></h3>\nStandard <i>if..then</i> and <i>case</i> constructs can be used for selective\noperations.\n<pre>&nbsp;&nbsp;&nbsp; <b>if</b> condition <b>then\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements...&nbsp;\n&nbsp;&nbsp;&nbsp; <b>elsif</b> condition <b>then\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements...\n&nbsp;&nbsp;&nbsp; <b>else</b>&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements...\n&nbsp;&nbsp;&nbsp; <b>end if;</b></pre>\nNOTE: <i>elsif</i> and <i>else</i> clauses are optional.\n<pre>&nbsp;&nbsp;&nbsp; <b>case</b> expression <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>when</b> choices <b>=&gt;</b> sequence of statements\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>when</b> choices <b>=&gt;</b> sequence of statements\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>when others</b> <b>=&gt;</b> sequence of statements\n&nbsp;&nbsp;&nbsp; <b>end case;</b></pre>\nNOTE: <i>case</i> choices can be expressions or ranges.\n<h3>\n<a name=\"loop\"></a>Loop statements - <a href=\"#top\">Back To Top</a></h3>\nSequences of statements can be repeated some number of times under the\ncontrol of <b>while</b> or <b>for</b> constructs.\n<pre>&nbsp;label: <b>while</b> condition <b>loop\n</b>&nbsp;&nbsp;&nbsp; ... sequence of statements ...\n&nbsp;&nbsp;&nbsp; <b>end loop</b> label;</pre>\n\n<pre>&nbsp;label:&nbsp; <b>for</b> loop_variable <b>in</b> range <b>loop\n</b>&nbsp; ... sequence of statements...\n&nbsp;&nbsp; <b>end loop</b> label;</pre>\nNOTE: the label is optional.\n<p><b>Loop termination statements</b> - allow termination of one iteration,\nloop, or procedure.\n</p><p><b>next</b> <b>[when</b> condition<b>];</b> -- end current loop iteration\n</p><p><b>exit [when</b> condition<b>];</b> -- exit innermost loop entirely\n</p><p><b>return</b> expression; -- exit from subprogram\n</p><p>NOTES: 1. The next/exit condition clause is optional.\n</p><p>2. The return expression is used for functions.\n</p><li>\n8. <b>Sequential assertion</b> - same format as a concurrent assertion.</li>\n\n<h3>\n<a name=\"procedure_syntax\"></a>PROCEDURES - <a href=\"#top\">Back To Top</a></h3>\nA <i>procedure</i> is a subprogram that is passed parameters and may return\nvalues via a parameter list.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; <b>procedure</b>&nbsp; proc_name (signal clk: in vlbit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant d: in vlbit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal data: out vlbit) <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... local variable declarations ...\n&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements ...\n&nbsp;&nbsp; <b>end</b> proc_name;</pre>\nProcedure call: proc_name(clk1, d1, dout);\n<h3>\n<a name=\"function_syntax\"></a>FUNCTIONS - <a href=\"#top\">Back To Top</a></h3>\nA <i>function</i> is a subprogram that is passed parameters and returns\na single value. Unlike procedures, functions are primarily used in expressions.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; -- Convert bit_vector to IEEE std_logic_vector format\n&nbsp;&nbsp; -- (attributes LENGTH and RANGE are described below)\n&nbsp;&nbsp; <b>function</b> bv2slv (b:bit_vector) <b>return</b> std_logic_vector <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable result: std_logic_vector(b'LENGTH-1 downto 0);\n&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in result'RANGE loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case b(i) is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when '0' =&gt; result(i) := '0';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when '1' =&gt; result(i) := '1';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end case;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end loop;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;\n&nbsp;&nbsp; <b>end;</b></pre>\n\n<pre>&nbsp;&nbsp; -- Convert bit_vector to unsigned (natural) value&nbsp;\n&nbsp;&nbsp; <b>function</b> b2n (B: bit_vector) <b>return</b> Natural <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable S: bit_vector(B'Length - 1 downto 0) := B;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable N: Natural := 0;\n&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in S'Right to S'Left loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if S(i) = '1' then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N := N + (2**i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end loop;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;\n&nbsp;&nbsp; <b>end;</b></pre>\n\n<h4>\nFunction Calls:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal databus:&nbsp; vector4(15 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal internal: bit_vector (15 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable x: integer;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; databus &lt;= bv2slv (internal);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x := b2n(internal);</pre>\nData conversion between ieee types and bit/bit_vector (functions in \"ieee.std_logic_1164\")\n<ul><b>To_bit(sul)</b> - from std_ulogic to bit\n<br><b>To_bitvector(sulv)</b> - from std_ulogic_vector/std_logic_vector\n<br><b>To_StdULogic(b)</b> - from bit to std_ulogic\n<br><b>To_StdLogicVector(bv)</b> - from bit_vector or std_ulogic_vector\n<br><b>To_StdULogicVector(bv)</b>- from bit_vector or std_logic_vector\n<br><b>To_X01(v)</b> - from bit, std_ulogic, or std_logic to X01\n<br><b>To_X01Z(v)</b> - from bit, std_ulogic, or std_logic to X01Z\n<br><b>To_UX01(v)</b> - from bit, std_ulogic, or std_logic to UX01</ul>\n\n<h3>\n<a name=\"other_ieee\"></a>Other \"ieee.std_logic_1164\" functions - <a href=\"#top\">Back\nTo Top</a></h3>\n\n<ul><b>rising_edge(s)</b> - true if rising edge on signal s (std_ulogic)\n<br><b>falling_edge(s)</b> - true if falling edge on signal s (std_ulogic)</ul>\nAdditional Mentor Graphics-supplied functions for elements of types Bit_vector\n(implemented as overloaded operator definitions):\n<ul><b>library mgc_portable;</b>\n<br><b>use mgc_portable.qsim_logic.ALL;</b></ul>\nArithmetic between bit_vectors: use normal binary operator tokens\n<p>a + b, a - b, a * b, a / b, a mod b, a rem b\n</p><p>Logical operations between all signal types and vectors of signal types\nin the \"ieee\" library.\n</p><p><b>and, or, nand, nor, xor, xnor, not</b>\n</p><p>Shift/rotate left/right logical/arithmetic operators:\n</p><p><b>sll, srl, sra, rll, rrl</b>\n</p><p>Ex. a := x sll 2; -- \"shift left logical\" bit_vector x by 2 bits\n</p><p>Relational operations: <b>=,/=,&lt;,&gt;,&lt;=,&gt;=</b>\n</p><p>Type conversion:\n</p><ul><b>to_bit</b> (from integer)\n<br><b>to_integer</b> (from bit_vector)</ul>\n\n<h2>\n<a name=\"object_attr\"></a>OBJECT ATTRIBUTES - <a href=\"#top\">Back To Top</a></h2>\nAn <i>object attribute </i>returns information about a signal or data type.\n<h3>\nSignal Condition Attributes (for a signal S)</h3>\n\n<ul><b>S'DELAYED(T)</b> - value of S delayed by T time units\n<br><b>S'STABLE(T)</b> - true if no event on S over last T time units\n<br><b>S'QUIET(T)</b> - true if S quiet for T time units\n<br><b>S'LAST_VALUE</b> - value of S prior to latest change\n<br><b>S'LAST_EVENT</b> - time at which S last changed\n<br><b>S'LAST_ACTIVE</b> - time at which S last active\n<br><b>S'EVENT</b> - true if an event has occurred on S in current cycle\n<br><b>S'ACTIVE</b> - true if signal S is active in the current cycle\n<br><b>S'TRANSACTION</b> - bit value which toggles each time signal S changes</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; if (clock'STABLE(0ns)) then&nbsp; -- change in clock?\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- action if no clock edge\n&nbsp;&nbsp;&nbsp; else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- action on edge of clock\n&nbsp;&nbsp;&nbsp; end if;</pre>\n\n<pre>&nbsp;&nbsp;&nbsp; if clock'EVENT and clock = '1' then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q &lt;= D after 5ns;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- set Q to D on rising edge of clock\n&nbsp;&nbsp;&nbsp; end if;</pre>\n\n<h3>\nData Type Bounds (Attributes of data type T)</h3>\n\n<ul><b>T'BASE</b> - base type of T\n<br><b>T'LEFT</b> - left bound of data type T\n<br><b>T'RIGHT</b> - right bound\n<br><b>T'HIGH</b> - upper bound (may differ from left bound)\n<br><b>T'LOW</b> - lower bound</ul>\n\n<h3>\nEnumeration Data Types (Variable/signal x of data type T)</h3>\n\n<ul><b>T'POS(x)</b> - position number of value of x of type T\n<br><b>T'VAL(x)</b> - value of type T whose position number is x\n<br><b>T'SUCC(x)</b> - value of type T whose position is x+1\n<br><b>T'PRED(x)</b> - value of type T whose position is x-1\n<br><b>T'LEFTOF(x)</b> - value of type T whose position is left of x\n<br><b>T'RIGHTOF(x)</b> - value of type T whose position is right of x</ul>\n\n<h3>\nArray Indexes for an Array A (Nth index of array A)</h3>\n\n<ul><b>A'LEFT(N)</b> - left bound of index\n<br><b>A'RIGHT(N)</b> - right bound of index\n<br><b>A'HIGH(N)</b> - upper bound of index\n<br><b>A'LOW(N)</b> - lower bound of index\n<br><b>A'LENGTH(N)</b> - number of values in range of index\n<br><b>A'RANGE(N)</b> - range: A'LEFT to A'RIGHT\n<br><b>A'REVERSE_RANGE(N)</b> - range A'LEFT downto A'RIGHT</ul>\nNOTE: For multi-dimensional array, Nth index must be indicated in the attribute\nspecifier. N may be omitted for a one-dimensional array.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; for i in (data_bus'RANGE) loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp; for i in (d'LEFT(1) to d'RIGHT(1)) loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</pre>\n\n<h3>\nBlock Attributes (of a block B)</h3>\n\n<ul><b>B'BEHAVIOR</b> - true if block B contains no component instantiations\n<br><b>B'STRUCTURE</b> - true if no signal assignment statements in block\nB</ul>\n\n<h2>\n<a name=\"textio\"></a>THE TEXTIO PACKAGE - <a href=\"#top\">Back To Top</a></h2>\n<i>TEXTIO</i> is a package of VHDL functions that read and write text files.\nTo make the package visible:\n<ul><b>use std.textio.all;</b></ul>\n\n<h3>\nData Types:</h3>\n\n<ul><b>text</b> - a file of character strings\n<br><b>line</b> - one string from a text file</ul>\n\n<h4>\nExample Declarations</h4>\n\n<pre>&nbsp;&nbsp; <b>file</b> Prog: <b>text is in</b> \"file_name\"; --text file \"file_name\"\n&nbsp;&nbsp; <b>variable</b> L: <b>line</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- read lines from file to L</pre>\n\n<h3>\nReading Values From a File:</h3>\n\n<dl>\n<dt>\n<b>readline(F, L)</b></dt>\n\n<dd>\nRead one line from \"text\" file F to \"line\" L</dd>\n\n<br>&nbsp;\n<dt>\n<b>read(L, VALUE, GOOD);</b></dt>\n\n<dd>\nRead one value from \"line\" L into variable VALUE</dd>\n\n<ul>\n<li>\nGOOD is TRUE if successful</li>\n\n<li>\nData_type of VALUE can be bit, bit_vector, integer, real, character, string,\nor time.</li>\n</ul>\n</dl>\n\n<h3>\nWriting values to a file:</h3>\n\n<dl>\n<dt>\n<b>writeline(F, L);</b></dt>\n\n<dd>\nWrite one line to \"text\" file F from \"line\" L</dd>\n\n<br>&nbsp;\n<dt>\n<b>write(L, VALUE, JUSTIFY, FIELD);</b></dt>\n\n<dd>\nWrite one value to \"line\" L from variable VALUE</dd>\n\n<ul>\n<li>\nData_type of VALUE can be bit, bit_vector, integer, real, character, string,\nor time.</li>\n\n<li>\nJUSTIFY is \"left\" or \"right\" to justify within the field</li>\n\n<li>\nFIELD is the desired field width of the written value</li>\n\n<br>&nbsp;\n<p>&nbsp;</p></ul>\n</dl>\n&nbsp;<a href=\"#top\">Back To Top</a>\n</body></html>", "id": 10727.0}