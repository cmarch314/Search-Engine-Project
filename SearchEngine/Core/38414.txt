{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Polyhedron 3 Traits Definition A polyhedral surface Polyhedron 3 Traits consists of vertices V edges E facets F and an incidence relation on them Each edge is represented by two halfedges with opposite orientations Vertices represent points in 3d space Edges are straight line segments between two endpoints Facets are planar polygons without holes defined by the circular sequence of halfedges along their boundary The polyhedral surface itself can have holes The halfedges along the boundary of a hole are called border halfedges and have no incident facet An edge is a border edge if one of its halfedges is a border halfedge A surface is closed if it contains no border halfedges A closed surface is a boundary representation for polyhedra in three dimensions The convention is that the halfedges are oriented counterclockwise around facets as seen from the outside of the polyhedron An implication is that the halfedges are oriented clockwise around the vertices The notion of the solid side of a facet as defined by the halfedge orientation extends to polyhedral surfaces with border edges although they do not define a closed object If normal vectors are considered for the facets normals point outwards following the right hand rule The strict definition can be found in Ket99 One implication of this definition is that the polyhedral surface is always an orientable and oriented 2 manifold with border edges i e the neighborhood of each point on the polyhedral surface is either homeomorphic to a disc or to a half disc except for vertices where many holes and surfaces with boundary can join Another implication is that the smallest representable surface is a triangle for polyhedral surfaces with border edges or a tetrahedron for polyhedra Boundary representations of orientable 2 manifolds are closed under Euler operations They are extended with operations that create or close holes in the surface Other intersections besides the incidence relation are not allowed although they are not automatically handled since self intersections are not easy to check efficiently Polyhedron 3 Traits does only maintain the combinatorial integrity of the polyhedral surface using Euler operations and does not consider the coordinates of the points or any geometric information The class Polyhedron 3 Traits can represent polyhedral surfaces as well as polyhedra The interface is designed in such a way that it is easy to ignore border edges and work only with polyhedra The sequence of edges can be ordered in the data structure on request such that the sequence starts with the non border edges and ends with the border edges Border edges are then itself ordered such that the halfedge which is incident to the facet comes first and the halfedge incident to the hole comes thereafter This normalization step counts simultaneously the number of border edges This number is zero if and only if the surface is a closed polyhedron Note that this class does not maintain this counter nor the halfedge order during further modifications There is no automatic caching done for auxiliary information include CGAL Polyhedron 3 h Parameters The full template declaration of Polyhedron 3 Traits states four template parameters template class PolyhedronTraits 3 class PolyhedronItems 3 CGAL Polyhedron items 3 template class T class I class HalfedgeDS CGAL HalfedgeDS default class Alloc CGAL ALLOCATOR int class Polyhedron 3 The first parameter requires a model of the PolyhedronTraits 3 concept as argument for example CGAL Polyhedron traits 3 The second parameter expects a model of the PolyhedronItems 3 concept By default the class CGAL Polyhedron items 3 is preselected The third parameter is a class template A model of the HalfedgeDS concept is expected By default the class CGAL HalfedgeDS default is preselected which is a list based implementation of the halfedge data structure The fourth parameter Alloc requires a standard allocator for STL container classes The rebind mechanism from Alloc will be used to create appropriate allocators internally A default is provided with the macro CGAL ALLOCATOR int from the CGAL memory h header file Types Polyhedron 3 Traits Traits traits class selected for PolyhedronTraits 3 Polyhedron 3 Traits Items items class selected for PolyhedronItems 3 Polyhedron 3 Traits HalfedgeDS instantiated halfedge data structure Polyhedron 3 Traits size type size type of HalfedgeDS Polyhedron 3 Traits difference type difference type of HalfedgeDS Polyhedron 3 Traits iterator category iterator category of HalfedgeDS for all iterators Polyhedron 3 Traits circulator category circulator category of all circulators bidirectional category if the Items Halfedge provides a prev member function otherwise forward category Polyhedron 3 Traits allocator type allocator type Alloc Polyhedron 3 Traits Vertex vertex type Polyhedron 3 Traits Halfedge halfedge type Polyhedron 3 Traits Facet facet type Polyhedron 3 Traits Point 3 point stored in vertices Polyhedron 3 Traits Plane 3 plane equation stored in facets if supported The following handles iterators and circulators have appropriate non mutable counterparts i e const handle const iterator and const circulator The mutable types are assignable to their non mutable counterparts Both circulators are assignable to the Halfedge iterator The iterators are assignable to the respective handle types Wherever the handles appear in function parameter lists the corresponding iterators can be used as well For convenience the Edge iterator enumerates every other halfedge It is based on the CGAL N step adaptor class For convenience the Point iterator enumerates all points in the polyhedral surface in the same order as the Vertex iterator but with the value type Point It is based on the CGAL Iterator project adaptor Similarly a Plane iterator is provided Polyhedron 3 Traits Vertex handle handle to vertex Polyhedron 3 Traits Halfedge handle handle to halfedge Polyhedron 3 Traits Facet handle handle to facet Polyhedron 3 Traits Vertex iterator iterator over all vertices Polyhedron 3 Traits Halfedge iterator iterator over all halfedges Polyhedron 3 Traits Facet iterator iterator over all facets Polyhedron 3 Traits Halfedge around vertex circulator circulator of halfedges around a vertex cw Polyhedron 3 Traits Halfedge around facet circulator circulator of halfedges around a facet ccw Polyhedron 3 Traits Edge iterator iterator over all edges every other halfedge Polyhedron 3 Traits Point iterator iterator over all points Polyhedron 3 Traits Plane iterator iterator over all plane equations advanced Types for Tagging Optional Features The following types are equal to either CGAL Tag true or CGAL Tag false depending on whether the named feature is supported or not Polyhedron 3 Traits Supports vertex halfedge Vertex halfedge Polyhedron 3 Traits Supports vertex point Vertex point Polyhedron 3 Traits Supports halfedge prev Halfedge prev Polyhedron 3 Traits Supports halfedge vertex Halfedge vertex Polyhedron 3 Traits Supports halfedge facet Halfedge facet Polyhedron 3 Traits Supports facet halfedge Facet halfedge Polyhedron 3 Traits Supports facet plane Facet plane Polyhedron 3 Traits Supports removal supports removal of individual elements advanced Creation Polyhedron 3 Traits P Traits traits Traits Polyhedron 3 Traits P size type v size type h size type f Traits traits Traits a polyhedron P with storage reserved for v vertices h halfedges and f facets The reservation sizes are a hint for optimizing storage allocation void P reserve size type v size type h size type f reserve storage for v vertices h halfedges and f facets The reservation sizes are a hint for optimizing storage allocation If the capacity is already greater than the requested size nothing happens If the capacity changes all iterators and circulators might invalidate Halfedge handle P make tetrahedron a tetrahedron is added to the polyhedral surface Returns a halfedge of the tetrahedron Halfedge handle P make tetrahedron Point p1 Point p2 Point p3 Point p4 a tetrahedron is added to the polyhedral surface with its vertices initialized to p1 p2 p3 and p4 Returns that halfedge of the tetrahedron which incident vertex is initialized to p1 The incident vertex of the next halfedge is p2 and the vertex thereafter is p3 The remaining fourth vertex is initialized to p4 Halfedge handle P make triangle a triangle with border edges is added to the polyhedral surface Returns a non border halfedge of the triangle Halfedge handle P make triangle Point p1 Point p2 Point p3 a triangle with border edges is added to the polyhedral surface with its vertices initialized to p1 p2 and p3 Returns that non border halfedge of the triangle which incident vertex is initialized to p1 The incident vertex of the next halfedge is p2 and the vertex thereafter is p3 Access Member Functions bool P empty returns true if P is empty size type P size of vertices number of vertices size type P size of halfedges number of halfedges incl border halfedges size type P size of facets number of facets size type P capacity of vertices space reserved for vertices size type P capacity of halfedges space reserved for halfedges size type P capacity of facets space reserved for facets size t P bytes bytes used for the polyhedron size t P bytes reserved bytes reserved for the polyhedron allocator type P get allocator allocator object Vertex iterator P vertices begin iterator over all vertices Vertex iterator P vertices end past the end iterator Halfedge iterator P halfedges begin iterator over all halfedges Halfedge iterator P halfedges end past the end iterator Facet iterator P facets begin iterator over all facets excluding holes Facet iterator P facets end past the end iterator Edge iterator P edges begin iterator over all edges Edge iterator P edges end past the end iterator Point iterator P points begin iterator over all points Point iterator P points end past the end iterator Plane iterator P planes begin iterator over all plane equations Plane iterator P planes end past the end iterator Traits P traits returns the traits class Combinatorial Predicates bool P is closed returns true if there are no border edges bool P is pure bivalent returns true if all vertices have exactly two incident edges bool P is pure trivalent returns true if all vertices have exactly three incident edges bool P is pure triangle returns true if all facets are triangles bool P is pure quad returns true if all facets are quadrilaterals bool P is triangle Halfedge const handle h true iff the connected component denoted by h is a triangle bool P is tetrahedron Halfedge const handle h true iff the connected component denoted by h is a tetrahedron Euler Operators Combinatorial Modifications The following Euler operations modify consistently the combinatorial structure of the polyhedral surface The geometry remains unchanged Halfedge handle P split facet Halfedge handle h Halfedge handle g splits the facet incident to h and g into two facets with a new diagonal between the two vertices denoted by h and g respectively The second new facet is a copy of the first facet Returns h next after the operation i e the new diagonal The new face is to the right of the new diagonal the old face is to the left The time is proportional to the distance from h to g around the facet Precondition h and g are incident to the same facet h g no loops h next g and g next h no multi edges Halfedge handle P join facet Halfedge handle h joins the two facets incident to h The facet incident to h opposite gets removed Both facets might be holes Returns the predecessor of h around the facet The invariant join facet split facet h g returns h and keeps the polyhedron unchanged The time is proportional to the size of the facet removed and the time to compute h prev Precondition The degree of both vertices incident to h is at least three no antennas Requirement Supports removal CGAL Tag true Halfedge handle P split vertex Halfedge handle h Halfedge handle g splits the vertex incident to h and g into two vertices the old vertex remains and a new copy is created and connects them with a new edge Let hnew be h next opposite after the split i e a halfedge of the new edge The split regroups the halfedges around the two vertices The halfedge sequence hnew g next opposite h remains around the old vertex while the halfedge sequence hnew opposite h next opposite before the split g is regrouped around the new vertex The split returns hnew i e the new halfedge incident to the old vertex The time is proportional to the distance from h to g around the vertex Precondition h and g are incident to the same vertex h g antennas are not allowed Note A special application of the split is split vertex h h next opposite which is equivalent to an edge split of the halfedge h next that creates a new vertex on the halfedge h next See also split edge h below Halfedge handle P join vertex Halfedge handle h joins the two vertices incident to h The vertex denoted by h opposite gets removed Returns the predecessor of h around the vertex i e h opposite prev The invariant join vertex split vertex h g returns h and keeps the polyhedron unchanged The time is proportional to the degree of the vertex removed and the time to compute h prev and h opposite prev Precondition The size of both facets incident to h is at least four no multi edges Requirement Supports removal CGAL Tag true Halfedge handle P split edge Halfedge handle h splits the halfedge h into two halfedges inserting a new vertex that is a copy of h opposite vertex Is equivalent to split vertex h prev h opposite The call of prev can make this method slower than a direct call of split vertex if the previous halfedge is already known and computing it would be costly when the halfedge data structure does not support the prev member function Returns the new halfedge hnew pointing to the inserted vertex The new halfedge is followed by the old halfedge i e hnew next h Halfedge handle P flip edge Halfedge handle h performs an edge flip It returns h after rotating the edge h one vertex in the direction of the face orientation Precondition h Halfedge handle and both facets incident to h are triangles Halfedge handle P create center vertex Halfedge handle h barycentric triangulation of h facet Creates a new vertex a copy of h vertex and connects it to each vertex incident to h facet splitting h facet into triangles h remains incident to the original facet all other triangles are copies of this facet Returns the halfedge h next after the operation i e a halfedge pointing to the new vertex The time is proportional to the size of the facet Precondition h is not a border halfedge Halfedge handle P erase center vertex Halfedge handle g reverses create center vertex Erases the vertex pointed to by g and all incident halfedges thereby merging all incident facets Only g facet remains The neighborhood of g vertex may not be triangulated it can have larger facets Returns the halfedge g prev Thus the invariant h erase center vertex create center vertex h holds if h is not a border halfedge The time is proportional to the sum of the size of all incident facets Precondition None of the incident facets of g vertex is a hole There are at least two distinct facets incident to the facets that are incident to g vertex This prevents the operation from collapsing a volume into two facets glued together with opposite orientations such as would happen with any vertex of a tetrahedron Requirement Supports removal CGAL Tag true Euler Operators Modifying Genus Halfedge handle P split loop Halfedge handle h Halfedge handle i Halfedge handle j cuts the polyhedron into two parts along the cycle h i j edge j runs on the backside of the three dimensional figure above Three new vertices one copy for each vertex in the cycle and three new halfedges one copy for each halfedge in the cycle and two new triangles are created h i j will be incident to the first new triangle The return value will be the halfedge incident to the second new triangle which is the copy of h opposite Precondition h i j denote distinct consecutive vertices of the polyhedron and form a cycle i e h vertex i opposite vertex j vertex h opposite vertex The six facets incident to h i j are all distinct Halfedge handle P join loop Halfedge handle h Halfedge handle g glues the boundary of the two facets denoted by h and g together and returns h Both facets and the vertices along the facet denoted by g gets removed Both facets may be holes The invariant join loop h split loop h i j returns h and keeps the polyhedron unchanged Precondition The facets denoted by h and g are different and have equal degree i e number of edges Requirement Supports removal CGAL Tag true Modifying Facets and Holes Halfedge handle P make hole Halfedge handle h removes the incident facet of h and changes all halfedges incident to the facet into border edges Returns h See erase facet h for a more generalized variant Precondition None of the incident halfedges of the facet is a border edge Requirement Supports removal CGAL Tag true Halfedge handle P fill hole Halfedge handle h fills a hole with a newly created facet Makes all border halfedges of the hole denoted by h incident to the new facet Returns h Precondition h is border Halfedge handle P add vertex and facet to border Halfedge handle h Halfedge handle g creates a new facet within the hole incident to h and g by connecting the tip of g with the tip of h with two new halfedges and a new vertex and filling this separated part of the hole with a new facet such that the new facet is incident to g Returns the halfedge of the new edge that is incident to the new facet and the new vertex Precondition h is border g is border h g and g can be reached along the same hole starting with h Halfedge handle P add facet to border Halfedge handle h Halfedge handle g creates a new facet within the hole incident to h and g by connecting the vertex denoted by g with the vertex denoted by h with a new halfedge and filling this separated part of the hole with a new facet such that the new facet is incident to g Returns the halfedge of the new edge that is incident to the new facet Precondition h is border g is border h g h next g and g can be reached along the same hole starting with h Erasing void P erase facet Halfedge handle h removes the incident facet of h and changes all halfedges incident to the facet into border edges or removes them from the polyhedral surface if they were already border edges If this creates isolated vertices they get removed as well See make hole h for a more specialized variant Precondition h is border false Requirement Supports removal CGAL Tag true void P erase connected component Halfedge handle h removes the vertices halfedges and facets that belong to the connected component of h Requirement Supports removal CGAL Tag true void P clear removes all vertices halfedges and facets Operations with Border Halfedges advanced Halfedges incident to a hole are called border halfedges An halfedge is a border edge if itself or its opposite halfedge are border halfedges The only requirement to work with border halfedges is that the Halfedge class provides a member function is border returning a bool Usually the halfedge data structure supports facets and a NULL facet pointer will indicate a border halfedge but this is not the only possibility The is border predicate divides the edges into two classes the border edges and the non border edges The following normalization reorganizes the sequential storage of the edges such that the non border edges precede the border edges and that for each border edge the latter one of the two halfedges is a border halfedge the first one is a non border halfedge in conformance with the polyhedral surface definition The normalization stores the number of border halfedges and the halfedge iterator the border edges start at within the data structure Halfedge insertion or removal and changing the border status of a halfedge invalidate these values They are not automatically updated void P normalize border sorts halfedges such that the non border edges precede the border edges For each border edge the halfedge iterator will reference the halfedge incident to the facet right before the halfedge incident to the hole size type P size of border halfedges number of border halfedges Precondition last normalize border call still valid see above size type P size of border edges number of border edges Since each border edge of a polyhedral surface has exactly one border halfedge this number is equal to size of border halfedges Precondition last normalize border call still valid see above Halfedge iterator P border halfedges begin halfedge iterator starting with the border edges The range halfedges begin border halfedges begin denotes all non border halfedges The range border halfedges begin halfedges end denotes all border edges Precondition last normalize border call still valid see above Edge iterator P border edges begin edge iterator starting with the border edges The range edges begin border edges begin denotes all non border edges The range border edges begin edges end denotes all border edges Precondition last normalize border call still valid see above advanced Miscellaneous void P inside out reverses facet orientations incl plane equations if supported bool P is valid bool verbose false int level returns true if the polyhedral surface is combinatorially consistent If verbose is true statistics are printed to cerr For level 1 the normalization of the border edges is checked too This method checks in particular level 3 of CGAL Halfedge data structure decorator is valid from page and that each facet is at least a triangle and that the two incident facets of a non border edge are distinct bool P normalized border is valid bool verbose false returns true if the border halfedges are in normalized representation which is when enumerating all halfedges with the iterator The non border edges precede the border edges and for border edges the second halfedge is the border halfedge The halfedge iterator border halfedges begin denotes the first border edge If verbose is true statistics are printed to cerr advanced void P delegate CGAL Modifier base HDS m calls the operator of the modifier m See CGAL Modifier base in the Support Library Manual for a description of modifier design and its usage Precondition The polyhedral surface must be valid when the modifier returns from execution advanced See Also CGAL Polyhedron 3 Traits Vertex CGAL Polyhedron 3 Traits Halfedge CGAL Polyhedron 3 Traits Facet PolyhedronTraits 3 CGAL Polyhedron traits 3 Kernel PolyhedronItems 3 CGAL Polyhedron items 3 HalfedgeDS CGAL HalfedgeDS default CGAL Polyhedron incremental builder 3 HDS CGAL Modifier base in the Support Library Reference Manual Example This example program instantiates a polyhedron using the default traits class and creates a tetrahedron file examples Polyhedron polyhedron prog simple C include CGAL Simple cartesian h include CGAL Polyhedron 3 h typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron Halfedge handle Halfedge handle int main Polyhedron P Halfedge handle h P make tetrahedron if P is tetrahedron h return return 1 Next Polyhedron 3 Traits Facet Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Polyhedron_ref/Class_Polyhedron_3.html", "title": "polyhedron_3&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Polyhedron_ref/Polyhedron_3.tex' -->\n<html> <head>  \n<title>Polyhedron_3&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_853\"></A>\n\n<A NAME=\"Cross_link_anchor_854\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_836\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Polyhedron_3<Traits>\"></A>\n<h2><I>CGAL::Polyhedron_3&lt;Traits&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nA polyhedral surface <I><A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;</I> consists of vertices <MATH><I>V</I></MATH>,\nedges <MATH><I>E</I></MATH>, facets <MATH><I>F</I></MATH> and an incidence relation on them.  Each edge is\nrepresented by two halfedges with <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations.\n<P>\n\n<CENTER>\n    <A HREF=\"fig/halfedge.gif\">\n        <img src=\"fig/halfedge_small.gif\" alt=\"Halfedge Diagram\"></A>\n<P>\n\n</CENTER>\n<P>\n\nVertices represent points in 3d-space. Edges are straight line segments\nbetween two endpoints. Facets are planar polygons without holes\ndefined by the circular sequence of halfedges along their boundary.\nThe polyhedral surface itself can have holes. The halfedges\nalong the boundary of a hole are called <I>border halfedges</I> and\nhave no incident facet. An edge is a <I>border edge</I> if one of\nits halfedges is a border halfedge.  A surface is <I>closed</I> if it\ncontains no border halfedges. A closed surface is a boundary\nrepresentation for polyhedra in three dimensions. The convention is\nthat the halfedges are oriented counterclockwise around facets as seen\nfrom the outside of the polyhedron. An implication is that the\nhalfedges are oriented clockwise around the vertices. The notion of\nthe solid side of a facet as defined by the halfedge <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>\nextends to polyhedral surfaces with border edges although they do not\ndefine a closed object. If normal vectors are considered for the\nfacets, normals point outwards (following the right hand rule).\n<P>\n\nThe strict definition can be found in&nbsp;[<A HREF=\"../biblio.html#Biblio_k-ugpdd-99\">Ket99</A>]. One\nimplication of this definition is that the polyhedral surface is\nalways an orientable and oriented 2-manifold with border edges, i.e.,\nthe neighborhood of each point on the polyhedral surface is either\nhomeomorphic to a disc or to a half disc, except for vertices where\nmany holes and surfaces with boundary can join. Another implication is\nthat the smallest representable surface is a triangle (for polyhedral\nsurfaces with border edges) or a tetrahedron (for polyhedra). <A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">Boundary</A>\nrepresentations of orientable 2-manifolds are closed under Euler\noperations. They are extended with operations that create or close\nholes in the surface.\n<P>\n\nOther intersections besides the incidence relation are not allowed,\nalthough they are not automatically handled, since self intersections\nare not easy to check efficiently. <I><A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;</I> does only\nmaintain the combinatorial integrity of the polyhedral surface (using\nEuler operations) and does not consider the coordinates of the points\nor any geometric information.\n<P>\n\nThe class <I><A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;</I> can represent polyhedral surfaces as\nwell as polyhedra. The interface is designed in such a way that it\nis easy to ignore border edges and work only with polyhedra.\n<P>\n\nThe sequence of edges can be ordered in the data structure on request\nsuch that the sequence starts with the non-border edges and ends with\nthe border edges. Border edges are then itself ordered such that the\nhalfedge which is incident to the facet comes first and the halfedge\nincident to the hole comes thereafter. This normalization step counts\nsimultaneously the number of border edges. This number is zero if and\nonly if the surface is a closed polyhedron. Note that this class does\nnot maintain this counter nor the halfedge order during further\nmodifications. There is no automatic caching done for auxiliary\ninformation.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Polyhedron_3.h\">CGAL/Polyhedron_3.h</A>&gt;</I>\n<P>\n\n<H3>Parameters</H3>\n<P>\n\nThe full template declaration of <I><A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;</I> states four\ntemplate parameters:\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n<I>template &lt;</I> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I>class <A HREF=\"Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>,</I>\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I>class <A HREF=\"Concept_PolyhedronItems_3.html#Cross_link_anchor_863\">PolyhedronItems_3</A>  = <A HREF=\"Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A>,</I>\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I>template &lt; class T, class I&gt;</I>\n                 <I>class <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A> = <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_882\">CGAL::HalfedgeDS_default</A>,</I>\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I>class Alloc = CGAL_ALLOCATOR(int)&gt;</I>\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I>class <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>;</I>\n\n</TD></TR></TABLE>\n<P>\n\nThe first parameter requires a model of the <I><A HREF=\"Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A></I>\nconcept as argument, for example <I><A HREF=\"Class_Polyhedron_traits_3.html#Cross_link_anchor_869\">CGAL::Polyhedron_traits_3</A></I>.  The\nsecond parameter expects a model of the <I><A HREF=\"Concept_PolyhedronItems_3.html#Cross_link_anchor_863\">PolyhedronItems_3</A></I>\nconcept.  By default, the class <I><A HREF=\"Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A></I> is\npreselected. The third parameter is a class template. A model of the\n<I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I> concept is expected. By default, the class\n<I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_882\">CGAL::HalfedgeDS_default</A></I> is preselected, which is a list based\nimplementation of the halfedge data structure.\nThe fourth parameter <I>Alloc</I> requires a standard allocator for \nSTL container classes. The  <I>rebind</I> mechanism from <I>Alloc</I>\nwill be used to create appropriate allocators internally. A default is\nprovided with the macro <I>CGAL_ALLOCATOR(int)</I> from the\n<I>&lt;CGAL/memory.h&gt;</I> header file.\n<P>\n\n<H3>Types</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Traits\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    traits class selected for <I><A HREF=\"Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A></I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Items\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    items class selected for <I><A HREF=\"Concept_PolyhedronItems_3.html#Cross_link_anchor_863\">PolyhedronItems_3</A></I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    instantiated halfedge data structure.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::size_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    size type of <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::difference_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    difference type of <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::iterator_category\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator category of <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>\n    for all iterators.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::circulator_category\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator category of all circulators;\n  bidirectional category if the <I>Items::Halfedge</I>  provides a <I>prev()</I>\n  member function, otherwise forward category.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::allocator_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    allocator type <I>Alloc</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3-Traits---Vertex.html#Cross_link_anchor_860\">Polyhedron_3&lt;Traits&gt;::Vertex</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    vertex type.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3-Traits---Halfedge.html#Cross_link_anchor_858\">Polyhedron_3&lt;Traits&gt;::Halfedge</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    halfedge type.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3-Traits---Facet.html#Cross_link_anchor_856\">Polyhedron_3&lt;Traits&gt;::Facet</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    facet type.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    point stored in vertices.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    plane equation stored in facets (if supported).\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\nThe following handles, iterators, and circulators have appropriate\nnon-mutable counterparts, i.e., <I>const_handle</I>,\n<I>const_iterator</I>, and <I>const_circulator</I>. The mutable types are\nassignable to their non-mutable counterparts.  Both circulators are\nassignable to the <I>Halfedge_iterator</I>. The iterators are\nassignable to the respective handle types. Wherever the handles appear\nin function parameter lists, the corresponding iterators can be used as\nwell. For convenience, the <I>Edge_iterator</I> enumerates every other \nhalfedge. It is based on the <I><A HREF=\"../STL_Extension_ref/Class_N_step_adaptor.html#Cross_link_anchor_1461\">CGAL::N_step_adaptor</A></I> class. For\nconvenience, the <I>Point_iterator</I> enumerates all points in the polyhedral\nsurface in the same order as the <I>Vertex_iterator</I>, but with the \nvalue type <I>Point</I>. It is based on the <I>CGAL::Iterator_project</I> \nadaptor. Similarly, a <I>Plane_iterator</I> is provided.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Vertex_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    handle to vertex.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Halfedge_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    handle to halfedge.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Facet_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    handle to facet.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Vertex_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over all vertices.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Halfedge_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over all halfedges.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Facet_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over all facets.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Halfedge_around_vertex_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator of\n  halfedges around a vertex (cw).\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Halfedge_around_facet_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator of\n  halfedges around a facet (ccw).\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Edge_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over all edges (every other halfedge).\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over all points.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Plane_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over all plane equations.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Types for Tagging Optional Features</H3>\n<P>\n\nThe following types are equal to either <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I> or\n<I><A HREF=\"../Kernel_23_ref/Class_Tag_false.html#Cross_link_anchor_475\">CGAL::Tag_false</A></I>, depending on whether the named feature is\nsupported or not.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_vertex_halfedge\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Vertex::halfedge()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_vertex_point\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Vertex::point()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_halfedge_prev\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Halfedge::prev()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_halfedge_vertex\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Halfedge::vertex()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_halfedge_facet\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Halfedge::facet()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_facet_halfedge\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Facet::halfedge()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_facet_plane\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <I>Facet::plane()</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt;::Supports_removal\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    supports removal of individual elements.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt; P (  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n<TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>&lt;Traits&gt; P ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    size_type v,<BR>\n\nsize_type h,<BR>\n\nsize_type f,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    a polyhedron <I>P</I> with storage reserved\n               for <MATH><I>v</I></MATH> vertices, <MATH><I>h</I></MATH> halfedges, and <MATH><I>f</I></MATH> facets. The\n               reservation sizes are a hint for optimizing storage\n               allocation.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_reserve6_size_type_v+_size_type_h+_size_type_f9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.reserve ( size_type v,  size_type h,  size_type f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reserve storage\n               for <MATH><I>v</I></MATH> vertices, <MATH><I>h</I></MATH> halfedges, and <MATH><I>f</I></MATH> facets. The\n               reservation sizes are a hint for optimizing storage\n               allocation. If the <I>capacity</I> is already greater\n               than the requested size nothing happens. If the\n               <I>capacity</I> changes all iterators and circulators\n               might invalidate.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_make_tetrahedron69;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.make_tetrahedron ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a tetrahedron is added to the \n    polyhedral surface. Returns a halfedge of the tetrahedron.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_make_tetrahedron6const_Point__p1+_const_Point__p2+_const_Point__p3+_const_Point__p49;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    P.make_tetrahedron ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p1,<BR>\n\nPoint p2,<BR>\n\nPoint p3,<BR>\n\nPoint p4)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a tetrahedron is added to the polyhedral surface with its\n    vertices initialized to <MATH><I>p<SUB>1</SUB>, p<SUB>2</SUB>, p<SUB>3</SUB></I></MATH>, and <MATH><I>p<SUB>4</SUB></I></MATH>. Returns that\n    halfedge of the tetrahedron which incident vertex is initialized\n    to <MATH><I>p<SUB>1</SUB></I></MATH>. The incident vertex of the next halfedge is <MATH><I>p<SUB>2</SUB></I></MATH>,\n    and the vertex thereafter is <MATH><I>p<SUB>3</SUB></I></MATH>.\n    The remaining fourth vertex is initialized to <MATH><I>p<SUB>4</SUB></I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_make_triangle69;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.make_triangle ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a triangle with border edges is\n    added to the polyhedral surface. Returns a non-border\n    halfedge of the triangle.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_make_triangle6const_Point__p1+_const_Point__p2+_const_Point__p39;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.make_triangle (  Point p1,  Point p2,  Point p3)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a triangle with border edges is added to the polyhedral surface with its\n    vertices initialized to <MATH><I>p<SUB>1</SUB>, p<SUB>2</SUB></I></MATH>, and <MATH><I>p<SUB>3</SUB></I></MATH>. Returns that\n    non-border halfedge of the triangle which incident vertex is initialized\n    to <MATH><I>p<SUB>1</SUB></I></MATH>. The incident vertex of the next halfedge is <MATH><I>p<SUB>2</SUB></I></MATH>,\n    and the vertex thereafter is <MATH><I>p<SUB>3</SUB></I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Member Functions</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_empty69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.empty ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns true if <I>P</I> is empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_size_of_vertices69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.size_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    number of vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_size_of_halfedges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.size_of_halfedges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    number of halfedges (incl. border halfedges).\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_size_of_facets69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.size_of_facets ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    number of facets.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_capacity_of_vertices69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.capacity_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    space reserved for vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_capacity_of_halfedges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.capacity_of_halfedges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    space reserved for halfedges.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_capacity_of_facets69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.capacity_of_facets ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    space reserved for facets.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_t_bytes69_const;\"></A>\nsize_t\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.bytes ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    bytes used for the polyhedron.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_t_bytes_reserved69_const;\"></A>\nsize_t\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.bytes_reserved ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    bytes reserved for the polyhedron.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_allocator_type_get_allocator69_const;\"></A>\nallocator_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.get_allocator ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    allocator object.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_begin69;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_end69;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.vertices_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past-the-end iterator.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_iterator_halfedges_begin69;\"></A>\nHalfedge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.halfedges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all\n                                                 halfedges.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_iterator_halfedges_end69;\"></A>\nHalfedge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.halfedges_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past-the-end iterator.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_iterator_facets_begin69;\"></A>\nFacet_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.facets_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all facets\n  (excluding holes).\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_iterator_facets_end69;\"></A>\nFacet_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.facets_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_edges_begin69;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.edges_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all edges.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_edges_end69;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.edges_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_begin69;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.points_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all points.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_end69;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.points_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Plane_iterator_planes_begin69;\"></A>\nPlane_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.planes_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all plane equations.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Plane_iterator_planes_end69;\"></A>\nPlane_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.planes_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Traits__traits69_const;\"></A>\n Traits\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.traits ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the traits class.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Combinatorial Predicates</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_closed69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.is_closed ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if there are no\n    border edges.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_pure_bivalent69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.is_pure_bivalent ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if all\n    vertices have exactly two incident edges.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_pure_trivalent69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.is_pure_trivalent ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if all\n    vertices have exactly three incident edges.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_pure_triangle69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.is_pure_triangle ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if all\n    facets are triangles.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_pure_quad69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.is_pure_quad ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if all \n    facets are quadrilaterals.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_triangle6_Halfedge_const_handle_h9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.is_triangle ( Halfedge_const_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I>\n    iff the connected component denoted by <MATH><I>h</I></MATH> is a triangle.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_tetrahedron6_Halfedge_const_handle_h9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.is_tetrahedron ( Halfedge_const_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I>\n    iff the connected component denoted by <MATH><I>h</I></MATH> is a tetrahedron.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Euler Operators (Combinatorial Modifications)</H3>\n<A NAME=\"sectionPolyhedronEuler\"></A>\n<P>\n\nThe following Euler operations modify consistently the combinatorial\nstructure of the polyhedral surface. The geometry remains\nunchanged.\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_facet.gif\" alt=\"Euler Operator: Facet\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_facet6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.split_facet ( Halfedge_handle h,  Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    splits the facet incident to <I>h</I> and <I>g</I> into two facets\n     with a new diagonal between the two vertices denoted by <I>h</I> and\n     <I>g</I> respectively. The second (new) facet is a copy of the\n     first facet. Returns <I>h-&gt;next()</I> after the\n     operation, i.e., the new diagonal. The new face is to the right of the \n     new diagonal, the old face is to the left. The time is\n     proportional to the distance from <I>h</I> to <I>g</I> around the facet.<BR>\n\n<EM>Precondition: </EM><I>h</I> and <I>g</I> are incident to the same facet.\n               <I>h != g</I> (no loops). <I>h-&gt;next() != g</I> and\n               <I>g-&gt;next() != h</I> (no multi-edges).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_join_facet6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.join_facet ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    joins the two facets incident to <MATH><I>h</I></MATH>. The facet incident to\n      <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> gets removed. Both facets might be\n    holes. Returns the <A HREF=\"../STL_Extension_ref/Function_predecessor.html#Cross_link_anchor_1442\">predecessor</A> of <MATH><I>h</I></MATH> around the facet. The invariant\n    <I>join_facet( split_facet( h, g))</I> returns <MATH><I>h</I></MATH> and keeps\n    the polyhedron unchanged. The time is proportional to the size of the\n    facet removed and the time to compute <I>h-&gt;prev()</I>.<BR>\n\n<EM>Precondition: </EM>The degree of both vertices incident to <MATH><I>h</I></MATH> is at least\n    three (no antennas).<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"./fig/euler_vertex.gif\" alt=\"Euler Operator: Vertex\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_vertex6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.split_vertex ( Halfedge_handle h,  Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    splits the vertex incident to <I>h</I> and <I>g</I> into two vertices,\n    the old vertex remains and a new copy is created,\n    and connects them with a new edge. Let <I>hnew</I> be \n    <I>h-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> after the split, i.e., a halfedge\n    of the new edge. The split regroups the halfedges around the two \n    vertices. The halfedge sequence <I>hnew</I>, <I>g-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I>,\n    ..., <I>h</I> remains around the old vertex, while the \n    halfedge sequence <I>hnew-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I>, <I>h-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> \n    (before the split), ..., <I>g</I> is regrouped around the new\n    vertex. The split returns <I>hnew</I>, i.e., the new halfedge incident \n    to the old vertex. The time is proportional to the distance from \n    <I>h</I> to <I>g</I> around the vertex.<BR>\n\n<EM>Precondition: </EM><I>h</I> and <I>g</I> are incident to the same vertex.\n               <I>h != g</I> (antennas are not allowed).<BR>\n\n<EM>Note: </EM> A special application of the split is \n    <I>split_vertex(h,h-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>())</I> which is equivalent to an \n    edge split of the halfedge <I>h-&gt;next()</I> that creates a new \n    vertex on the halfedge <I>h-&gt;next()</I>. See also <I>split_edge(h)</I>\n    below.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_join_vertex6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.join_vertex ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    joins the two vertices incident to <MATH><I>h</I></MATH>. The vertex denoted by\n      <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> gets removed. Returns the <A HREF=\"../STL_Extension_ref/Function_predecessor.html#Cross_link_anchor_1442\">predecessor</A> of\n    <MATH><I>h</I></MATH> around the vertex, i.e., <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;prev()</I>. \n    The invariant <I>join_vertex( split_vertex( h, g))</I> returns\n    <MATH><I>h</I></MATH> and keeps the polyhedron unchanged. \n    The time is proportional to the degree of the vertex removed and \n    the time to compute <I>h-&gt;prev()</I> and <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;prev()</I>.<BR>\n\n<EM>Precondition: </EM>The size of both facets incident to <MATH><I>h</I></MATH> is at least \n    four (no multi-edges).<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_edge6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.split_edge ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    splits the halfedge <I>h</I> into two halfedges inserting a new vertex\n    that is a copy of <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()</I>. Is equivalent to\n    <I>split_vertex( h-&gt;prev(), h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>())</I>. The call of <I>prev()</I>\n    can make this method slower than a direct call of <I>split_vertex()</I>\n    if the previous halfedge is already known and computing it would be \n    costly when the halfedge data structure does not support the <I>prev()</I>\n    member function. Returns the new halfedge <I>hnew</I> pointing to the\n    inserted vertex. The new halfedge is followed by the old halfedge, i.e.,\n    <I>hnew-&gt;next() == h</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_flip_edge6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.flip_edge ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    performs an edge flip. It returns <MATH><I>h</I></MATH> after rotating the edge <MATH><I>h</I></MATH> one\n    vertex in the direction of the face <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>.<BR>\n\n<EM>Precondition: </EM><I>h != Halfedge_handle()</I> and both  facets incident\n    to <MATH><I>h</I></MATH> are triangles.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_center.gif\" alt=\"Euler Operator: Center Vertex\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_create_center_vertex6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.create_center_vertex ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    barycentric triangulation of <I>h-&gt;facet()</I>. Creates a new vertex,\n     a copy of <I>h-&gt;vertex()</I>, and connects it to each vertex incident \n     to <I>h-&gt;facet()</I> splitting <I>h-&gt;facet()</I> into triangles. \n     <I>h</I> remains incident to the original facet, all other triangles \n     are copies of this facet. Returns the halfedge <I>h-&gt;next()</I>\n     after the operation, i.e., a halfedge pointing to the new vertex.\n     The time is proportional to the size of the facet.<BR>\n\n<EM>Precondition: </EM><I>h</I> is not a border halfedge.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_erase_center_vertex6_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.erase_center_vertex ( Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reverses <I>create_center_vertex</I>. Erases the\n     vertex pointed to by <I>g</I> and all incident halfedges thereby\n     merging all incident facets. Only <I>g-&gt;facet()</I> remains. \n     The neighborhood of <I>g-&gt;vertex()</I> may not be triangulated,\n     it can have larger facets. Returns the halfedge <I>g-&gt;prev()</I>.\n     Thus, the invariant <I>h == erase_center_vertex(       create_center_vertex(h))</I> holds if <I>h</I> is not a border halfedge.\n     The time is proportional to the sum of the size of all incident facets.<BR>\n\n<EM>Precondition: </EM>None of the incident facets of <I>g-&gt;vertex()</I> is \n     a hole. There are at least two distinct facets incident\n     to the facets that are incident to <I>g-&gt;vertex()</I>. (This \n     prevents the operation from collapsing a <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> into two facets\n     glued together with <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations, such as would\n     happen with any vertex of a tetrahedron.)<BR>\n\n<EM>Requirement: </EM>\n     <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Euler Operators Modifying Genus</H3>\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_loop.gif\" alt=\"Euler Operator: Loop\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_loop6_Halfedge_handle_h+_Halfedge_handle_i+_Halfedge_handle_j9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    P.split_loop ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle h,<BR>\n\nHalfedge_handle i,<BR>\n\nHalfedge_handle j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    cuts the polyhedron into two parts along the cycle <MATH><I>(h,i,j)</I></MATH> (edge <I>j</I>\n    runs on the backside of the three dimensional figure above).\n    Three new vertices (one copy for each vertex in the cycle) and three \n    new halfedges (one copy for each halfedge in the cycle), and two new \n    triangles are created. <MATH><I>h,i,j</I></MATH> will be incident to the first new triangle.\n    The return value will be the halfedge incident to the second new triangle \n    which is the copy of <I>h-<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I>.<BR>\n\n<EM>Precondition: </EM><MATH><I>h,i,j</I></MATH> denote distinct, consecutive vertices of the\n    polyhedron and form a cycle: i.e., <I>h-&gt;vertex() ==     i-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()</I>, ..., <I>j-&gt;vertex() ==     h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()</I>. The six facets incident to <MATH><I>h,i,j</I></MATH> are all\n    distinct.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_join_loop6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.join_loop ( Halfedge_handle h,  Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    glues the boundary of the two facets denoted by <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH> together \n    and returns <MATH><I>h</I></MATH>. Both facets and the vertices along the facet denoted\n    by <MATH><I>g</I></MATH> gets removed. Both facets may be holes. The invariant \n    <I>join_loop( h, split_loop( h, i, j))</I> returns <MATH><I>h</I></MATH> and keeps the \n    polyhedron unchanged.<BR>\n\n<EM>Precondition: </EM>The facets denoted by <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH> are different and have\n    equal degree (i.e., number of edges).<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifying Facets and Holes</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_make_hole6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.make_hole ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the incident facet of <MATH><I>h</I></MATH> and changes all halfedges incident \n    to the facet into border edges. Returns <MATH><I>h</I></MATH>. \n    See <I>erase_facet(h)</I> for a more generalized variant.<BR>\n\n<EM>Precondition: </EM>None of the incident halfedges of the facet is a border edge.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_fill_hole6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.fill_hole ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    fills a hole with a newly created facet. Makes all border halfedges\n    of the hole denoted by <MATH><I>h</I></MATH> incident to the new facet. Returns <MATH><I>h</I></MATH>.<BR>\n\n<EM>Precondition: </EM><I>h.is_border()</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"fig/add_facet1.gif\" \n     alt=\"Modifying Facets and Holes: add_vertex_and_facet_to_border()\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_add_vertex_and_facet_to_border6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    P.add_vertex_and_facet_to_border ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle h,<BR>\n\nHalfedge_handle g)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    creates a new facet within the hole incident to <MATH><I>h</I></MATH>\n   and <MATH><I>g</I></MATH> by connecting the tip of <MATH><I>g</I></MATH> with the tip of <MATH><I>h</I></MATH> \n   with two new halfedges and a new vertex and filling this separated\n   part of the hole with a new facet, such that the new facet is\n   incident to <MATH><I>g</I></MATH>. Returns the halfedge of the new edge that is\n   incident to the new facet and the new vertex.<BR>\n\n<EM>Precondition: </EM><I>h-&gt;is_border()</I>, <I>g-&gt;is_border()</I>, <I>h != g</I>, \n    and <MATH><I>g</I></MATH> can be reached along the same hole starting with <MATH><I>h</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"./fig/add_facet2.gif\" \n     alt=\"Modifying Facets and Holes: add_facet_to_border()\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_add_facet_to_border6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    P.add_facet_to_border ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle h,<BR>\n\nHalfedge_handle g)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    creates a new facet within the hole incident to <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH> by\n    connecting the vertex denoted by <MATH><I>g</I></MATH> with the vertex denoted by <MATH><I>h</I></MATH>\n    with a new halfedge and filling this separated part of the hole with\n    a new facet, such that the new facet is incident to <MATH><I>g</I></MATH>. \n    Returns the halfedge of the new edge that is incident to the new facet.<BR>\n\n<EM>Precondition: </EM><I>h-&gt;is_border()</I>, <I>g-&gt;is_border()</I>, <I>h != g</I>, \n   <I>h-&gt;next() != g</I>, and <MATH><I>g</I></MATH> can be reached along the same hole\n   starting with <MATH><I>h</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Erasing</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase_facet6_Halfedge_handle_h9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.erase_facet ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the incident facet of <MATH><I>h</I></MATH> and changes all halfedges incident \n     to the facet into border edges or removes them from the\n     polyhedral surface if they were already border edges.\n     If this creates isolated vertices they get removed as well.\n     See <I>make_hole(h)</I> for a more specialized variant.<BR>\n\n<EM>Precondition: </EM><I>h-&gt;is_border() == false</I>.<BR>\n\n<EM>Requirement: </EM>\n     <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase_connected_component6_Halfedge_handle_h9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.erase_connected_component ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the  vertices, halfedges, and facets that belong to the \n     connected component of <MATH><I>h</I></MATH>.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH>\n     <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes all vertices, halfedges, and facets.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Operations with Border Halfedges</H3>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<P>\n\nHalfedges incident to a hole are called <I>border halfedges</I>. An\nhalfedge is a <I>border edge</I> if itself or its <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> halfedge\nare border halfedges. The only requirement to work with border\nhalfedges is that the <I>Halfedge</I> class provides a member function\n<I>is_border()</I> returning a <I>bool</I>. Usually, the halfedge data\nstructure supports facets and a <I>NULL</I> facet pointer will indicate\na border halfedge, but this is not the only possibility. The\n<I>is_border()</I> predicate divides the edges into two classes, the\nborder edges and the non-border edges. The following normalization\nreorganizes the sequential storage of the edges such that the\nnon-border edges precede the border edges, and that for each border\nedge the latter one of the two halfedges is a border halfedge (the\nfirst one is a non-border halfedge in conformance with the polyhedral\nsurface definition). The normalization stores the number of border\nhalfedges and the halfedge iterator the border edges start at within\nthe data structure.  Halfedge insertion or removal and changing the\nborder status of a halfedge invalidate these values. They are not\nautomatically updated.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_normalize_border69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.normalize_border ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sorts halfedges such that the non-border edges precede the\n     border edges. For each border edge the halfedge iterator will\n    reference the halfedge incident to the facet right before the\n    halfedge incident to the hole.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_size_of_border_halfedges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.size_of_border_halfedges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    number of border halfedges.<BR>\n\n<EM>Precondition: </EM>last <I>normalize_border()</I> call still valid, see above.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_size_of_border_edges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.size_of_border_edges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    number of border edges. Since each border edge of a polyhedral\n    surface has exactly one border halfedge,\n    this number is equal to <I>size_of_border_halfedges()</I>.<BR>\n\n<EM>Precondition: </EM>last <I>normalize_border()</I> call still valid, see above.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_iterator_border_halfedges_begin69;\"></A>\nHalfedge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.border_halfedges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    halfedge iterator starting with the border edges. The range\n      [<I>halfedges_begin(), border_halfedges_begin()</I>) denotes\n    all non-border halfedges. The range\n    [<I>border_halfedges_begin(), halfedges_end()</I>) denotes all\n    border edges.<BR>\n\n<EM>Precondition: </EM>last <I>normalize_border()</I> call still valid, see above.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_border_edges_begin69;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.border_edges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    edge iterator starting with the border edges. The range\n      [<I>edges_begin(), border_edges_begin()</I>) denotes\n    all non-border edges. The range\n    [<I>border_edges_begin(), edges_end()</I>) denotes all\n    border edges.<BR>\n\n<EM>Precondition: </EM>last <I>normalize_border()</I> call still valid, see above.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Miscellaneous</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_inside_out69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    P.inside_out ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reverses facet orientations (incl. plane equations if supported).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6_bool_verbose_=_false+_int_level_=_09_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.is_valid ( bool verbose = false,  int level = 0)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if the polyhedral surface is combinatorially \n    consistent. If <I>verbose</I> is <I>true</I>, statistics are\n    printed to <I>cerr</I>. For <I>level == 1</I> the normalization of the\n    border edges is checked too. This method checks in particular level 3 of\n    <I>CGAL::Halfedge_data_structure_decorator::is_valid</I> from\n    page&nbsp;<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_const_decorator.html#pageHalfedgeDSconstDecoratorRef\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and that each facet is at least\n    a triangle and that the two incident facets of a non-border edge are\n    distinct.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_normalized_border_is_valid6_bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.normalized_border_is_valid ( bool verbose = false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if the border halfedges are in normalized \n    representation, which is when enumerating all halfedges with the\n    iterator: The non-border edges precede the border edges and for\n    border edges, the second halfedge is the border halfedge. The halfedge\n    iterator <I>border_halfedges_begin()</I> denotes the first border\n    edge. If <I>verbose</I> is <I>true</I>, statistics are\n    printed to <I>cerr</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delegate6_CGAL::Modifier_base6HDS9__m9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    P.delegate ( <A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A>&lt;HDS&gt;&amp; m)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    calls the <I>operator()</I> of the modifier <MATH><I>m</I></MATH>. See\n    <I><A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A></I> in the Support Library Manual for a\n    description of modifier design and its usage.<BR>\n\n<EM>Precondition: </EM>The polyhedral surface must be valid when the modifier\n    returns from execution.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Polyhedron_3-Traits---Vertex.html#Cross_link_anchor_859\">CGAL::Polyhedron_3&lt;Traits&gt;::Vertex</A></I><BR>\n\n<I><A HREF=\"Class_Polyhedron_3-Traits---Halfedge.html#Cross_link_anchor_857\">CGAL::Polyhedron_3&lt;Traits&gt;::Halfedge</A></I><BR>\n\n<I><A HREF=\"Class_Polyhedron_3-Traits---Facet.html#Cross_link_anchor_855\">CGAL::Polyhedron_3&lt;Traits&gt;::Facet</A></I><BR>\n\n<I><A HREF=\"Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A></I><BR>\n\n<I><A HREF=\"Class_Polyhedron_traits_3.html#Cross_link_anchor_869\">CGAL::Polyhedron_traits_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I><BR>\n\n<I><A HREF=\"Concept_PolyhedronItems_3.html#Cross_link_anchor_863\">PolyhedronItems_3</A></I><BR>\n\n<I><A HREF=\"Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A></I><BR>\n\n<I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I><BR>\n\n<I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_882\">CGAL::HalfedgeDS_default</A></I><BR>\n\n<I><A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_861\">CGAL::Polyhedron_incremental_builder_3</A>&lt;HDS&gt;</I><BR>\n\n<I><A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A></I> in the Support Library Reference Manual.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThis example program instantiates a polyhedron using the default\ntraits class and creates a tetrahedron.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_simple.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;         Polyhedron;\ntypedef Polyhedron::Halfedge_handle        Halfedge_handle;\n\nint main() {\n    Polyhedron P;\n    Halfedge_handle h = P.make_tetrahedron();\n    if ( P.is_tetrahedron(h))\n        return 0;\n    return 1;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Polyhedron_3-Traits---Facet.html\"><I>Polyhedron_3&lt;Traits&gt;::Facet</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_28!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38414.0}