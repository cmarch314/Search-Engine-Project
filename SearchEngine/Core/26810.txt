{"text": "ICS 32 Winter 2 15 News Course Reference Schedule Project Guide Code Examples About Alex ICS 32 Winter 2 15 Code Example Classes Duck Typing and Interfaces Background We ve noticed before that Python is happy to allow us to store any kind of value in any variable we d like x 3 y Boo z 1 2 3 We ve also seen that we can potentially change the type of a variable any time we d like by simply assigning a value of a different type into it x 1 2 x is now a tuple y 9 5 y is now a float z Alex z is now a str Or thought differently variables themselves don t have types at all in Python only the values of those variables have types If we use a variable after assigning it a value what we re allowed to do with it what operators we can use what functions we can pass it as a parameter into and so on is a matter of what the type of its value is at the time we use it w Alex print len w prints 4 q 57 print len q raises an exception because ints don t have a length In the example above we could ask for the length of w because the value of w is a string and strings have a length On the other hand we couldn t ask for the length of q because q s value is an integer and integers don t have a length In general Python uses a technique that is sometimes called duck typing when deciding what we can and can t do with the values stored in variables The term duck typing comes from an old saying that insinuates that if a bird walks like a duck and quacks like a duck it s a duck meaning that we can deduce what something is or at least some aspect of what something is based on what it can do If you try to call a method on an object it s legal so long as that object s class has such a method it s illegal if it doesn t s Hello print s upper no problem because the str class has an upper method class XYZ def upper self return Argh x XYZ print x upper also legal prints Argh i 19 print i upper not legal because ints have no upper method What s more based on the type of the object the right thing will happen automatically Asking a string for its length will tell you how many characters it contains asking a list for its length will tell you how many elements are stored in it and so on Adding two integers together with the operator gives their sum adding two lists together with the operator gives you their concatenation Sometimes the same method or the same operator will behave wildly differently depending on the type of objects it s called on but the behavior will always be the right behavior for that type without you having to do anything special to ensure that Using duck typing to our advantage Armed with the knowledge that Python behaves this way we can write functions and methods that are more flexible than we could before Consider this nonsensical looking Python function def foo x y return x bar y 2 I ve left the types out of the function s signature because it s not as clear what they are until we stop to think about it What must be true about the types of x and y in order to successfully evaluate foo x y x must be an object of some class that has a method called bar that takes one parameter in addition to self There might be many classes like this and it may not always be the case that all their bar methods even do the same thing the presence of the method is one part of what makes this legal y must have a type that is compatible as an argument to bar Depending on x s type and depending on what its bar method does this constraint will be different Any combination that works is potentially legal The type of value returned from the bar method must be something that can be multiplied by 2 At first blush that sounds like it must be a number but if you think harder you ll remember that you can also multiply other kinds of things e g lists strings by numbers too If that sounds foreign to you try evaluating 1 2 3 2 in a Python interpreter and see what you get back The type of value returned from foo is whatever type of value you get when you multiply bar s result by 2 this again may be different depending on the types of x and y We don t normally use duck typing in situations as nonsensical looking as this one but this shows us the mechanics of how Python works It is legal to call a method on an object and pass it parameters if and only if the object s class has such a method that can accept those parameters If it walks like a duck and quacks like a duck it s a duck Why this is advantageous is because we can write multiple classes and intentionally give them the same interface i e they each have one or more methods in common whose signatures and meanings are the same then use objects of these classes interchangeably Python will automatically call the appropriate version of the method in the appropriate case just as in our example above of calling upper on objects of two different classes The code The code example below consists of several classes that have an identical interface i e they all contain a method with the same signature along with a function that is capable of taking an object of any of those classes it doesn t matter which one and calling that method on it duck typing py", "_id": "http://www.ics.uci.edu/~thornton/ics32/CodeExamples/DuckTyping/", "title": "ics 32 winter 2015, code example: classes, duck typing, and interfaces", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2015, Code Example: Classes, Duck Typing, and Interfaces</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2015 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2015<br />\r\n   Code Example: Classes, Duck Typing, and Interfaces</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>We've noticed before that Python is happy to allow us to store any kind of value in any variable we'd like.</p>\r\n\r\n<blockquote><pre>\r\nx = 3\r\ny = 'Boo'\r\nz = [1, 2, 3]\r\n</pre></blockquote>\r\n\r\n<p>We've also seen that we can potentially change the type of a variable any time we'd like by simply assigning a value of a different type into it.</p>\r\n\r\n<blockquote><pre>\r\nx = (1, 2)      <i># x is now a tuple</i>\r\ny = 9.5         <i># y is now a float</i>\r\nz = 'Alex'      <i># z is now a str</i>\r\n</pre></blockquote>\r\n\r\n<p>Or, thought differently, variables themselves don't have types at all in Python; only the values of those variables have types.  If we use a variable after assigning it a value, what we're allowed to do with it &mdash; what operators we can use, what functions we can pass it as a parameter into, and so on &mdash; is a matter of what the type of its value is at the time we use it.</p>\r\n\r\n<blockquote><pre>\r\nw = 'Alex'\r\nprint(len(w))   <i># prints <b>4</b></i>\r\nq = 57\r\nprint(len(q))   <i># raises an exception, because ints don't have a length</i>\r\n</pre></blockquote>\r\n\r\n<p>In the example above, we could ask for the length of <b>w</b>, because the value of <b>w</b> is a string and strings have a length.  On the other hand, we couldn't ask for the length of <b>q</b>, because <b>q</b>'s value is an integer and integers don't have a length.</p>\r\n\r\n<p>In general, Python uses a technique that is sometimes called <i>duck typing</i> when deciding what we can and can't do with the values stored in variables.  The term \"duck typing\" comes from an old saying that insinuates that \"if a bird walks like a duck and quacks like a duck, it's a duck,\" meaning that we can deduce what something is &mdash; or at least some aspect of what something is &mdash; based on what it can do.</p>\r\n\r\n<p>If you try to call a method on an object, it's legal so long as that object's class has such a method; it's illegal if it doesn't.</p>\r\n\r\n<blockquote><pre>\r\ns = 'Hello'\r\nprint(s.upper())   <i># no problem, because the str class has an <b>upper()</b> method</i>\r\n\r\nclass XYZ:\r\n    def upper(self):\r\n        return 'Argh!'\r\n\r\nx = XYZ()\r\nprint(x.upper())   <i># also legal, prints <b>Argh!</b></i>\r\n\r\ni = 19\r\nprint(i.upper())   <i># not legal, because ints have no <b>upper()</b> method</i>\r\n</pre></blockquote>\r\n\r\n<p>What's more, based on the type of the object, the \"right thing\" will happen automatically.  Asking a string for its length will tell you how many characters it contains; asking a list for its length will tell you how many elements are stored in it; and so on.  Adding two integers together with the <b>+</b> operator gives their sum; adding two lists together with the <b>+</b> operator gives you their concatenation.  Sometimes, the same method or the same operator will behave wildly differently depending on the type of objects it's called on, but the behavior will always be the \"right\" behavior for that type, without you having to do anything special to ensure that.</p>\r\n\r\n<p class=\"subtitle\">Using duck typing to our advantage</p>\r\n\r\n<p>Armed with the knowledge that Python behaves this way, we can write functions and methods that are more flexible than we could before.  Consider this nonsensical-looking Python function:</p>\r\n\r\n<blockquote><pre>\r\ndef foo(x, y):\r\n    return x.bar(y) * 2\r\n</pre></blockquote>\r\n\r\n<p>I've left the types out of the function's signature, because it's not as clear what they are until we stop to think about it.  What must be true about the types of <b>x</b> and <b>y</b> in order to successfully evaluate <b>foo(x, y)</b>?</p>\r\n\r\n<ul>\r\n  <li><b>x</b> must be an object of some class that has a method called <b>bar</b> that takes one parameter (in addition to <b>self</b>).  There might be many classes like this, and it may not always be the case that all their <b>bar</b> methods even do the same thing; the presence of the method is one part of what makes this legal.</li>\r\n  <li><b>y</b> must have a type that is compatible as an argument to <b>bar</b>.  Depending on <b>x</b>'s type &mdash; and depending on what its <b>bar</b> method does &mdash; this constraint will be different.  Any combination that works is potentially legal.</li>\r\n  <li>The type of value returned from the <b>bar</b> method must be something that can be multiplied by 2.  At first blush, that sounds like it must be a number, but if you think harder, you'll remember that you can also multiply other kinds of things (e.g., lists, strings) by numbers, too.  (If that sounds foreign to you, try evaluating <b>[1, 2, 3] * 2</b> in a Python interpreter and see what you get back.)</li>\r\n  <li>The type of value returned from <b>foo</b> is whatever type of value you get when you multiply <b>bar</b>'s result by 2; this, again, may be different depending on the types of <b>x</b> and <b>y</b>.</li>\r\n</ul>\r\n\r\n<p>We don't normally use duck typing in situations as nonsensical-looking as this one, but this shows us the mechanics of how Python works.  It is legal to call a method on an object and pass it parameters if and only if the object's class has such a method that can accept those parameters.  \"If it walks like a duck and quacks like a duck, it's a duck.\"</p>\r\n\r\n<p>Why this is advantageous is because we can write multiple classes and intentionally give them the same <i>interface</i> (i.e., they each have one or more methods in common, whose signatures and meanings are the same), then use objects of these classes interchangeably.  Python will automatically call the appropriate version of the method in the appropriate case, just as in our example above of calling <b>upper()</b> on objects of two different classes.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The code example below consists of several classes that have an identical interface (i.e., they all contain a method with the same signature), along with a function that is capable of taking an object of any of those classes (it doesn't matter which one) and calling that method on it.</p>\r\n\r\n<ul>\r\n  <li><a href=\"duck_typing.py\">duck_typing.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 26810.0}