{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Polyhedron incremental builder 3 HDS Definition The auxiliary class Polyhedron incremental builder 3 HDS supports the incremental construction of polyhedral surfaces which is for example convenient when constructing polyhedral surfaces from file formats such as the Object File Format OFF Phi96 OpenInventor Wer94 or VRML BPP95 VRM96 Polyhedron incremental builder 3 HDS needs access to the internal halfedge data structure of type HDS of the polyhedral surface It is intended to be used within a modifier see CGAL Modifier base in the Support Library Reference Manual The incremental builder might be of broader interest for other uses of the halfedge data structures but it is specifically bound to the definition of polyhedral surfaces given here During construction all conditions of polyhedral surfaces are checked and in case of violation an error status is set A diagnostic message will be issued to cerr if the verbose flag has been set at construction time The incremental construction starts with a list of all point coordinates and concludes with a list of all facet polygons Edges are not explicitly specified They are derived from the vertex incidence information provided from the facet polygons The polygons are given as a sequence of vertex indices The halfedge data structure HDS must support vertices i e Supports halfedge vertex CGAL Tag true Vertices and facets can be added in arbitrary order as long as a call to add vertex to facet refers only to a vertex index that is already known Some methods return already handles to vertices facets and halfedges newly constructed They can be used to initialize additional fields however the incidences in the halfedge data structure are not stable and are not allowed to be changed The incremental builder can work in two modes RELATIVE INDEXING the default in which a polyhedral surface already contained in the halfedge data structure is ignored and all indices are relative to the newly added surface or ABSOLUTE INDEXING in which all indices are absolute indices including an already existing polyhedral surface The former mode allows to create easily independent connected components while the latter mode allows to to continue the construction of an existing surface the absolute indexing allows to address existing vertices when creating new facets include CGAL Polyhedron incremental builder 3 h Types Polyhedron incremental builder 3 HDS HalfedgeDS halfedge data structure HDS Polyhedron incremental builder 3 HDS Point 3 point type of the vertex Polyhedron incremental builder 3 HDS size type size type typedef typename HalfedgeDS Vertex handle Vertex handle typedef typename HalfedgeDS Halfedge handle Halfedge handle typedef typename HalfedgeDS Face handle Facet handle Constants enum RELATIVE INDEXING ABSOLUTE INDEXING two different indexing modes Creation Polyhedron incremental builder 3 HDS B HDS hds bool verbose false stores a reference to the halfedge data structure hds of a polyhedral surface in its internal state An existing polyhedral surface in hds remains unchanged The incremental builder appends the new polyhedral surface If verbose is true diagnostic messages will be printed to cerr in case of malformed input data Surface Creation To build a polyhedral surface the following regular expression gives the correct and allowed order and nesting of method calls from this section begin surface add vertex begin facet add vertex to facet end facet end surface void B begin surface size type v size type f size type h int mode RELATIVE INDEXING starts the construction v is the number of new vertices to expect f the number of new facets and h the number of new halfedges If h is unspecified it is estimated using Euler s equation plus 5 for the so far unknown holes and genus of the object These values are used to reserve space in the halfedge data structure hds If the representation supports insertion these values do not restrict the class of constructible polyhedra If the representation does not support insertion the object must fit into the reserved sizes If mode is set to ABSOLUTE INDEXING the incremental builder uses absolute indexing and the vertices of the old polyhedral surface can be used in new facets needs preprocessing time linear in the size of the old surface Otherwise relative indexing is used starting with new indices for the new construction Vertex handle B add vertex Point 3 p adds a new vertex for p and returns its handle Facet handle B begin facet starts a new facet and returns its handle void B add vertex to facet size type i adds a vertex with index i to the current facet The first point added with add vertex has the index if mode was set to RELATIVE INDEXING otherwise the first vertex in the referenced hds has the index Halfedge handle B end facet ends a newly constructed facet Returns the handle to the halfedge incident to the new facet that points to the vertex added first The halfedge can be safely used to traverse the halfedge cycle around the new facet void B end surface ends the construction Additional Operations template class InputIterator Halfedge handle B add facet InputIterator first InputIterator beyond is a synonym for begin facet a call to add facet for each value in the range first beyond and a call to end facet Returns the return value of end facet Precondition The value type of InputIterator is std size t All indices must refer to vertices already added template class InputIterator bool B test facet InputIterator first InputIterator beyond returns true if a facet described by the vertex indices in the range first beyond can be successfully inserted e g with add facet first beyond Precondition The value type of InputIterator is std size t All indices must refer to vertices already added Vertex handle B vertex std size t i returns handle for the vertex of index i or Vertex handle if there is no i th vertex bool B error returns error status of the builder void B rollback undoes all changes made to the halfedge data structure since the last begin surface in relative indexing and deletes the whole surface in absolute indexing It needs a new call to begin surface to start inserting again bool B check unconnected vertices returns true if unconnected vertices are detected If verbose was set to true see the constructor above debug information about the unconnected vertices is printed bool B remove unconnected vertices returns true if all unconnected vertices could be removed successfully This happens either if no unconnected vertices had appeared or if the halfedge data structure supports the removal of individual elements See Also CGAL Polyhedron 3 Traits HalfedgeDS CGAL Modifier base in the Support Library Reference Manual Example A modifier class creates a new triangle in the halfedge data structure using the incremental builder file examples Polyhedron polyhedron prog incr builder C include CGAL Simple cartesian h include CGAL Polyhedron incremental builder 3 h include CGAL Polyhedron 3 h A modifier creating a triangle with the incremental builder template class HDS class Build triangle public CGAL Modifier base HDS public Build triangle void operator HDS hds Postcondition hds is a valid polyhedral surface CGAL Polyhedron incremental builder 3 HDS B hds true B begin surface 3 1 6 typedef typename HDS Vertex Vertex typedef typename Vertex Point Point B add vertex Point B add vertex Point 1 B add vertex Point 1 B begin facet B add vertex to facet B add vertex to facet 1 B add vertex to facet 2 B end facet B end surface typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron HalfedgeDS HalfedgeDS int main Polyhedron P Build triangle HalfedgeDS triangle P delegate triangle CGAL assertion P is triangle P halfedges begin return Next PolyhedronItems 3 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Polyhedron_ref/Class_Polyhedron_incremental_builder_3.html", "title": "polyhedron_incremental_builder_3&lt;hds&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Polyhedron_ref/Polyhedron_incremental_builder_3.tex' -->\n<html> <head>  \n<title>Polyhedron_incremental_builder_3&lt;HDS&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_861\"></A>\n\n<A NAME=\"Cross_link_anchor_862\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_840\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Polyhedron_incremental_builder_3<HDS>\"></A>\n<h2><I>CGAL::Polyhedron_incremental_builder_3&lt;HDS&gt;</I></h2>\n\n\n<A NAME=\"pagePolyIncrBuilder\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe auxiliary class <I><A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>&lt;HDS&gt;</I> supports the incremental\nconstruction of polyhedral surfaces, which is for example convenient\nwhen constructing polyhedral surfaces from file formats, such as the\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> File Format (OFF)&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:p-gmgv16-96\">Phi96</A>],\nOpenInventor&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:w-impoo-94\">Wer94</A>] or \nVRML&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:bpp-vrml-95\">BPP95</A>, <A HREF=\"../biblio.html#Biblio_cgal:vrmls-96\">VRM96</A>].\n<I><A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>&lt;HDS&gt;</I> needs access to the internal halfedge data\nstructure of type <I>HDS</I> of the polyhedral surface. It is intended\nto be used within a modifier, see <I><A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A></I> in the \nSupport Library Reference Manual.\n<P>\n\nThe incremental builder might be of broader interest for other uses of\nthe halfedge data structures, but it is specifically bound to the\ndefinition of polyhedral surfaces given here. During construction all\nconditions of polyhedral surfaces are checked and in case of violation\nan error status is set. A diagnostic message will be issued to\n<I>cerr</I> if the <I>verbose</I> flag has been set at construction\ntime.\n<P>\n\nThe incremental construction starts with a list of all point\ncoordinates and concludes with a list of all facet polygons. Edges are\nnot explicitly specified. They are derived from the vertex incidence\ninformation provided from the facet polygons. The polygons are given as a\nsequence of vertex indices.  The halfedge data structure <I>HDS</I> must\nsupport vertices (i.e., <I>Supports_halfedge_vertex</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH>\n<I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>). Vertices and facets can be added in arbitrary order\nas long as a call to <I>add_vertex_to_facet()</I> refers only to a\nvertex index that is already known. Some methods return already\nhandles to vertices, facets, and halfedges newly constructed. They can\nbe used to initialize additional fields, however, the incidences in\nthe halfedge-data structure are not stable and are not allowed to be\nchanged.\n<P>\n\nThe incremental builder can work in two modes: <I><A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">RELATIVE_INDEXING</A></I> (the\ndefault), in which a polyhedral surface already contained in the\nhalfedge data structure is ignored and all indices are relative to the\nnewly added surface, or <I><A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">ABSOLUTE_INDEXING</A></I>, in which all indices are\nabsolute indices including an already existing polyhedral surface. The\nformer mode allows to create easily independent connected components,\nwhile the latter mode allows to to continue the construction of an\nexisting surface, the absolute indexing allows to address existing\nvertices when creating new facets.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Polyhedron_incremental_builder_3.h\">CGAL/Polyhedron_incremental_builder_3.h</A>&gt;</I>\n<P>\n\n<H3>Types</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>&lt;HDS&gt;::<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    halfedge data structure <I>HDS</I>.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>&lt;HDS&gt;::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    point type of the vertex.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>&lt;HDS&gt;::size_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    size type.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle\"></A>\n<A NAME=\"Typedef_Vertex_handle\"></A>\ntypedef typename <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>::Vertex_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Vertex_handle;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle\"></A>\n<A NAME=\"Typedef_Halfedge_handle\"></A>\ntypedef typename <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>::Halfedge_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Halfedge_handle;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_handle\"></A>\n<A NAME=\"Typedef_Facet_handle\"></A>\ntypedef typename <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>::Face_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Facet_handle;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        </TABLE>\n<P>\n\n<H3>Constants</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A NAME=\"Function_enum\"></A>\n<A NAME=\"Enum_enum\"></A>\n<A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> { <A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">RELATIVE_INDEXING</A><A NAME=\"Function_enum\"></A>\n, <A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">ABSOLUTE_INDEXING</A><A NAME=\"Function_enum\"></A>\n};\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    two different indexing modes.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>&lt;HDS&gt; B ( HDS&amp; hds,  bool verbose = false);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    stores a reference to the halfedge data structure <I>hds</I> of a\n   polyhedral surface in its internal state. An existing polyhedral\n   surface in <I>hds</I> remains unchanged. The incremental builder\n   appends the new polyhedral surface. If <I>verbose</I> is <I>true</I>,\n   diagnostic messages will be printed to <I>cerr</I> in case of\n   malformed input data.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Surface Creation</H3>\n<P>\n\nTo build a polyhedral surface, the following regular expression gives\nthe correct and allowed order and nesting of method calls from this\nsection:\n<P>\n\n<I> begin_surface <MATH><I>(</I></MATH>add_vertex <MATH><I>|</I></MATH> \n                  <MATH><I>(</I></MATH>begin_facet add_vertex_to_facet<MATH><I>*</I></MATH>\n                            end_facet<MATH><I>))*</I></MATH> end_surface\n</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_begin_surface6_size_type_v+_size_type_f+_size_type_h_=_0+_int_mode_=_RELATIVE_INDEXING9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    B.begin_surface ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    size_type v,<BR>\n\nsize_type f,<BR>\n\nsize_type h = 0,<BR>\n\nint mode = <A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">RELATIVE_INDEXING</A>)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    starts the construction. <MATH><I>v</I></MATH> is the number of new vertices\n    to expect, <MATH><I>f</I></MATH> the number of new facets, and <MATH><I>h</I></MATH> the number of\n    new halfedges. If <MATH><I>h</I></MATH> is unspecified (<I>== 0</I>) it is estimated using\n    Euler's equation (plus 5% for the so far unknown holes and genus of\n    the object). These values are used to reserve space in the\n    halfedge data structure <I>hds</I>. If the representation supports\n    insertion these values do not restrict the class of constructible\n    polyhedra. If the representation does not support insertion the\n    object must fit into the reserved sizes.<BR>\n\nIf <I>mode</I> is set to <I><A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">ABSOLUTE_INDEXING</A></I> the incremental builder\n    uses absolute indexing and the vertices of the old polyhedral surface\n    can be used in new facets (needs preprocessing time linear in the\n    size of the old surface). Otherwise relative indexing is used \n    starting with new indices for the new construction.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_add_vertex6_const_Point_3__p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    B.add_vertex (  <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a new vertex for <MATH><I>p</I></MATH> and returns its handle.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_handle_begin_facet69;\"></A>\nFacet_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    B.begin_facet ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    starts a new facet and returns its handle.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_add_vertex_to_facet6_size_type_i9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    B.add_vertex_to_facet ( size_type i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a vertex with\n  index <MATH><I>i</I></MATH> to the current facet. The first point added with\n  <I>add_vertex()</I> has the index 0 if <I>mode</I> was set to \n  <I><A HREF=\"Class_Polyhedron_incremental_builder_3#Enum_enum\">RELATIVE_INDEXING</A></I>, otherwise the first vertex in the \n  referenced <I>hds</I> has the index 0.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_end_facet69;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    B.end_facet ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    ends a newly constructed facet.\n     Returns the handle to the halfedge incident to the new facet that points\n     to the vertex added first. The halfedge can be safely used to traverse\n     the halfedge cycle around the new facet.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_end_surface69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    B.end_surface ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    ends the construction.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Additional Operations</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_add_facet6_InputIterator_first+_InputIterator_beyond9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    B.add_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator beyond)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    is a synonym for <I>begin_facet()</I>, a call to <I>add_facet()</I> for each\n    value in the range <I>[first,beyond)</I>, and a call to <I>end_facet()</I>.\n    Returns the return value of <I>end_facet()</I>.<BR>\n\n<EM>Precondition: </EM>The value type of <I>InputIterator</I> is <I>std::size_t</I>.\n    All indices must refer to vertices already added.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_test_facet6_InputIterator_first+_InputIterator_beyond9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    B.test_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator beyond)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> if a facet described by the vertex indices in the range \n    <I>[first,beyond)</I> can be successfully inserted, e.g., with \n    <I>add_facet(first,beyond)</I>.<BR>\n\n<EM>Precondition: </EM>The value type of <I>InputIterator</I> is <I>std::size_t</I>.\n    All indices must refer to vertices already added.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_vertex6_std::size_t_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    B.vertex ( std::size_t i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns handle for the vertex of index <MATH><I>i</I></MATH>, or <I>Vertex_handle</I> if \n    there is no <MATH><I>i</I></MATH>-th vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_error69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    B.error ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns error status of the builder.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_rollback69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    B.rollback ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    undoes all changes made to the halfedge\n  data structure since the last <I>begin_surface()</I> in relative\n  indexing, and deletes the whole surface in absolute indexing.\n  It needs a new call to <I>begin_surface()</I> to start inserting again.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_check_unconnected_vertices69;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    B.check_unconnected_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns\n  <I>true</I> if unconnected vertices are detected. If <I>verbose</I> was set to\n  <I>true</I> (see the constructor above) debug information about the\n  unconnected vertices is printed.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_remove_unconnected_vertices69;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    B.remove_unconnected_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns\n  <I>true</I> if all unconnected vertices could be removed successfully.\n  This happens either if no unconnected vertices had appeared or if the\n  halfedge data structure supports the removal of individual elements.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I><BR>\n\n<I><A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A></I> in the Support Library Reference Manual.\n<P>\n\n<H3>Example</H3>\n<P>\n\nA modifier class creates a new triangle in the halfedge data structure\nusing the incremental builder.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_incr_builder.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n\n// A modifier creating a triangle with the incremental builder.\ntemplate &lt;class HDS&gt;\nclass Build_triangle : public <A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A>&lt;HDS&gt; {\npublic:\n    Build_triangle() {}\n    void operator()( HDS&amp; hds) {\n        // Postcondition: `hds' is a valid polyhedral surface.\n        <A HREF=\"Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_861\">CGAL::Polyhedron_incremental_builder_3</A>&lt;HDS&gt; B( hds, true);\n        B.begin_surface( 3, 1, 6);\n        typedef typename HDS::Vertex   Vertex;\n        typedef typename Vertex::Point Point;\n        B.add_vertex( Point( 0, 0, 0));\n        B.add_vertex( Point( 1, 0, 0));\n        B.add_vertex( Point( 0, 1, 0));\n        B.begin_facet();\n        B.add_vertex_to_facet( 0);\n        B.add_vertex_to_facet( 1);\n        B.add_vertex_to_facet( 2);\n        B.end_facet();\n        B.end_surface();\n    }\n};\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;         Polyhedron;\ntypedef Polyhedron::<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>             <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>;\n\nint main() {\n    Polyhedron P;\n    Build_triangle&lt;<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>&gt; triangle;\n    P.delegate( triangle);\n    CGAL_assertion( P.is_triangle( P.halfedges_begin()));\n    return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Concept_PolyhedronItems_3.html\"><I>PolyhedronItems_3</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_28!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38255.0}