{"text": "dy leftmargin marginwidth topmargin marginheight 4 SMARTS A Language for Describing Molecular Patterns Substructure searching the process of finding a particular pattern subgraph in a molecule graph is one of the most important tasks for computers in chemistry It is used in virtually every application that employs a digital representation of a molecule including depiction to highlight a particular functional group drug design searching a database for similar structures and activity analytical chemistry looking for previously characterized structures and comparing their data to that of an unknown and a host of other problems SMARTS is a language that allows you to specify substructures using rules that are straightforward extensions of SMILES For example to search a database for phenol containing structures one would use the SMARTS string OH c1ccccc1 which should be familiar to those acquainted with SMILES In fact almost all SMILES specifications are valid SMARTS targets Using SMARTS flexible and efficient substructure search specifications can be made in terms that are meaningful to chemists In the SMILES language there are two fundamental types of symbols atoms and bonds Using these SMILES symbols once can specify a molecule s graph its nodes and edges and assign labels to the components of the graph that is say what type of atom each node represents and what type of bond each edge represents The same is true in SMARTS One uses atomic and bond symbols to specify a graph However in SMARTS the labels for the graph s nodes and edges its atoms and bonds are extended to include logical operators and special atomic and bond symbols these allow SMARTS atoms and bonds to be more general For example the SMARTS atomic symbol C N is an atom that can be aliphatic C or aliphatic N the SMARTS bond symbol tilde matches any bond 4 1 Atomic Primitives SMARTS provides a number of primitive symbols describing atomic properties beyond those used in SMILES atomic symbol charge and isotopic specifications The following tables list the atomic primitives used in SMARTS all SMILES atomic symbols are also legal In these tables n stands for a digit c for chiral class Note that atomic primitive H can have two meanings implying a property or the element itself H means hydrogen atom H2 means any atom with exactly two hydrogens attached SMARTS Atomic PrimitivesSymbolSymbol nameAtomic property requirementsDefault wildcardany atom no default aaromaticaromatic no default Aaliphaticaliphatic no default D n degree n explicit connectionsexactly oneH n total H count n attached hydrogensexactly one1h n implicit H count n implicit hydrogensexactly oneR n ring membershipin n SSSR ringsany ring atomr n ring sizein smallest SSSR ring of size n any ring atom2v n valencetotal bond order n exactly one2X n connectivity n total connectionsexactly one2x n ring connectivity n total ring connectionsat least one2 n negative charge n charge 1 charge is 2 etc n positive charge n formal charge 1 charge is 2 etc natomic numberatomic number n no default 2 chiralityanticlockwiseanticlockwise default class2 chiralityclockwiseclockwise default class2 c n chiralitychiral class c chirality n nodefault c n chiral or unspecchirality c n orunspecified no default n atomic massexplicit atomic massunspecified mass 1 Semantics of H changed in v4 5 2 and introduced in v4 1 r v X and in v4 3 x in v4 9 Examples Caliphatic carbon atomcaromatic carbon atomaaromatic atom 6 carbon atom Ca calcium atom atom with a 2 charge R atom in any ring D3 atom with 3 explicit bonds implicit H s don t count X3 atom with 3 total bonds includes implicit H s v3 atom with bond orders totaling 3 includes implicit H s C C H F Omatch chirality H F O anticlockwise viewed from C C C H F Omatches if chirality is as specified or is not specified 4 2 Bond Primitives Various bond symbols are available to match connections between atoms A missing bond symbol is interpreted as single or aromatic SMARTS Bond Primitives SymbolAtomic property requirements single bond aliphatic directional single bond up 1 directional single bond down 1 directional bond up or unspecified directional bond down or unspecified double bond triple bond aromatic bond any bond wildcard any ring bond1 1 and introduced in v4 1 in v4 6 Examples C any aliphatic carbonccany pair of attached aromatic carbonsc caromatic carbons joined by an aromatic bondc caromatic carbons joined by a single bond e g biphenyl 4 3 Logical Operators Atom and bond primitive specifications may be combined to form expressions by using logical operators In the following table e is an atom or bond SMARTS expression which may be a primitive The logical operators are listed in order of decreasing precedence high precedence operators are evaluated first SMARTS Logical Operators SymbolExpressionMeaningexclamation e1not e1ampersande1 e2a1 and e2 high precedence commae1 e2e1 or e2semicolon e1 e2a1 and e2 low precedence All atomic expressions which are not simple primitives must be enclosed in brackets The default operation is high precedence and i e two adjacent primitives without an intervening logical operator must both be true for the expression or subexpression to be true The ability to form expressions gives the SMARTS user a great deal of power to specify exactly what is desired The two forms of the AND operator are used in SMARTS instead of grouping operators Examples CH2 aliphatic carbon with two hydrogens methylene carbon C R NOT aliphatic carbon AND in ring C R same as above R means not in zero rings n H1 H pyrrole nitrogen n H1 same as above nH1 same as above c n H1 any arom carbon OR H pyrrole nitrogen X3 H atom with 3 total bonds and no H s c n H1 arom carbon OR arom nitrogen and exactly one H Cl any chlorine atom 35 any atom of mass 35 35Cl chlorine atom of mass 35 F Cl Br I the 1st four halogens 4 4 Recursive SMARTS Any SMARTS expression may be used to define an atomic environment by writing a SMARTS starting with the atom of interest in this form SMARTS Such definitions may be considered atomic properties These expressions can be used in same manner as other atomic primitives also they can be nested Recursive SMARTS expressions are used in the following manner C atom connected to methyl or methylene carbon CCatom connected to ethyl carbon C CC atom in both above environments matches CCC The additional power of such expressions is illustrated by the following example which derives an expression for methyl carbons which are ortho to oxygen and meta to a nitrogen on an aromatic ring CaaOC ortho to OCaaaNC meta to NCaa O aNC ortho to O and meta to N but 2O 3N only Ca aO aaNC ortho to O and meta to N but 2O 5N only C aaO aaaN C ortho to O and meta to N all cases 4 5 Component level grouping of SMARTS SMARTS may contain zero level parentheses which can be used to group dot disconnected fragments This grouping operator allows SMARTS to express more powerful component queries In general a single set of parentheses may surround any legal SMARTS expression Two or more of these expressions may be combined into more complex SMARTS SMARTS SMARTS SMARTS SMARTS SMARTS The semantics of the zero level parentheses are that all of the atom and bond expressions within a set of zero level parentheses must match within a single component of the target SMARTSSMILESMatch behaviorC CCCCCyes no component level grouping specified C C CCCCyes both carbons in the query match the same component C C CCCCno the query must match carbons in two different components C C CCCC CCCCyes the query does match carbons in two different components C CCCCCyes both carbons in the query match the same component C C CCCCC CCCCyes the first two carbons match different components the third matches a carbon anywhere These component level grouping operators were added specifically for reaction processing Without this construct it is impossible to distinguish inter versus intramolecular reaction queries For example Reaction SMARTS expressionMatch behaviorC O O OCC C O OCC OMatches esterifications C O O OCC C O OCC OMatches intermolecular esterifications C O O OCC C O OCC OMatches intramolecular esterifications lactonizations 4 6 Reaction Queries Reaction queries are expressed using the SMARTS language SMARTS has been extended to handle reaction query features in much the same fashion as SMILES has been extended to handle reactions A reaction query may be composed of optional reactant agent and product parts which are separated by the character In this case the parts of the reaction query match against the corresponding roles within the reaction target as expected Note that it is also quite reasonable to search a set of reactions by giving a molecule query In this case the answer is a hit if the molecule SMARTS matches anywhere within the reaction target In effect matching a molecule SMARTS against a reaction target is a query where the role of the SMARTS is unspecified Example Reaction SMARTS Query Target Matches C CC CN2 C CC CN C CC CN 1 C CC CN 3 The atom mapping for a reaction query is optional When included in the definition of the pattern it is used for searching If atom maps are used for a SMARTS match their only effect is to potentially eliminate answers from the result Atom maps can never under any circumstance cause the addition of hits to an answer set Conceptually one can consider the atom map matching as a post processing step after a normal match Each of the hits is examined to make sure the atom map classes match on the reactant and product sides of the reaction In SMARTS the atom map has unusual semantics An atom map is a property which must be evaluated on a global scope during the match One can not know if the map is correct without considering every atom in the match in effect requiring the enumeration of every possible path before testing This is much more computationally expensive than the current SMARTS implementation which tests the paths as they are built and stops as soon as a path fails to match In order to avoid this computational trap the expressiveness of SMARTS for atom maps has been limited to a low precedence and operation That is only expressions of form expr n or expr n are allowed where expr is any legal atomic expression excluding atom maps and n is a map class value This expression is a low precedence logical AND between expr and the map expression n The following examples illustrate other nuances of the semantics Example Reaction SMARTS Query Target Matches Comment C CCC CC4No maps normal match C C CH3 7 CH3 8 CH3 7 CH3 8 4No maps in query maps in target are ignored C 1 C CH3 7 CH3 8 CH3 7 CH3 8 4Unpaired map in query ignored C 1 C 1 CC CC No maps in target hence no matches C 1 C 1 CC CC4Query says mapped as shown or not present C 1 C 1 CH3 7 CH3 8 CH3 7 CH3 8 2Matches for target 7 7 and 8 8 atom pairs C 1 C 2 CH3 7 CH3 8 CH3 7 CH3 8 4When a query class is not found on bothsides of the query it is ignored this query does NOT say that the atomsare in different classes C 1 C 1 C 1 CH3 7 CH3 7 CH3 7 CH3 7 4Atom maps match with or logic All atomsget bound to class 7 C 1 C 1 C 1 CH3 7 CH3 8 CH3 7 CH3 8 4The reactant atoms are bound to classes 7and 8 Note that having the first query atombound to class 7 does not precludebinding the second atom Next the productatom can bind to classes 7 or 8 C 1 C 1 C 1 CH3 7 CH3 7 CH3 7 CH3 8 2The reactants are bound to class 7 Theproduct atom can bind to class 7 only The last example is the most confusing Since there is no or logic for atom maps the behavior when checking the maps is as follows the query reactants can be bound to any classes in the target These bindings form the set of allowed product bindings The product query atoms are then tested against this list If all of the product atoms pass then the path is a match The effect of this procedure is to provide the logical OR semantics for atom maps within the simple implementation The downside of this implementation is that it can be confusing to the user Fortunately the simple pairwise atom maps will suffice for most users Finally atom map labels in molecule SMARTS and unpaired atom map labels in reaction SMARTS are ignored Stated another way since the atom maps express the idea of a global association of atoms across a reaction atom maps on a molecule query have no meaning Similarly a lone atom map on a reaction atom which doesn t correspond to any other atoms in the query has no meaning In both of these cases the query is identical to the query written without the meaningless atom maps In recursive SMARTS reaction expressions are not allowed The reasons for this are twofold first it isn t clear that the meaning of a recursive SMARTS for a reaction would have any useful expressiveness and second there is a practical problem with the lexical definitions of reactions given the strict left to right definition of reactant agent product how would one express a product atom in a vector binding Of course we can change the syntax for recursive SMARTS or reactions to accommodate this if it becomes clear that it is useful 4 7 SMARTS Versus SMILES All SMILES expressions are also valid SMARTS expressions but the semantics changes because SMILES describes molecules whereas SMARTS describes patterns The molecule represented by a SMILES string is usually but not always matched by the same string when used as a SMARTS SMILES is interpreted as a molecule and it is the resultant molecule not the SMILES string which is subject to searching Similarly SMARTS is interpreted as a pattern it is this pattern not the SMARTS string which is matched against molecules For instance the SMILES C1 CC CC C1 cyclohexatriene is interpreted as the benzene molecule This molecule will be matched by the SMARTS c1ccccc1 which is interpreted as the pattern 6 aromatic carbons in a ring The SMARTS C1 CC CC C1 makes a pattern six aliphatic carbons in a ring with alternating single and double bonds which will not match benzene It will however match the nonaromatic phenylate cation with SMILES C1 CC CC CH 1 When atoms are specified without brackets in SMILES default values are used in SMARTS unspecified properties are not defined to be part of the pattern For instance the SMILES O means an aliphatic oxygen with zero charge and two hydrogens i e water In SMARTS the same expression means any aliphatic oxygen regardless of charge hydrogen count etc e g it will match the oxygen in water but also those in ethanol acetone molecular oxygen hydroxy and hydronium ions etc Specifying OH2 limits the pattern to match only water this is also the fully specified SMILES for water There are a few anachronisms in most SMILES interpreters which can also lead to confusion Some SMILES interpreters allow implicit hydrogens to be added as explicit atoms on input as a shortcut E g the SMILES for 1H pyrrole is nH 1cccc1 which is matched by itself as SMARTS and by n1cccc1 The current Daylight SMILES interpreter will also accept Hn1cccc1 for not very good reasons of historical compatibility this generates the same hydrogen suppressed molecule as does nH 1cccc1 and is matched by the same SMARTS However the SMARTS Hn1cccc1 does not match this molecule Most SMARTS expressions are not valid SMILES expressions For instance the string cOc is a valid SMARTS matching an aliphatic oxygen connected to two aromatic carbons as part of a larger molecule e g diphenyl ether However cOc does not describe a molecule per se and is therefore not a valid SMILES 4 8 Efficiency Considerations The Daylight 4 x SMARTS Toolkit provides a function dt smarts opt which automatically optimizes a SMARTS by reordering expanding and or consolidating atom and bond expressions Programs which use this feature e g the Merlin program can be expected to be near optimal in terms of the time used to search typical organic structures When this optimization method is not used there are some things which can be done to facilitate efficient fast searching operations using SMARTS It is important to recognize that SMARTS target strings are processed in strictly left to right order For this reason substantial gains in speed can be achieved by following these guidelines Uncommon atoms or bond arrangements should be placed early in SMARTS targets In an and expression the less common atom or bond specifications should be placed early In an or expression the less common atom or bond specifications should be placed last 4 9 Examples ccany pair of attached aromatic carbonsc caromatic carbons joined by an aromatic bondc caromatic carbons joined by a single bond e g biphenyl Oany aliphatic oxygen O H1 simple hydroxy oxygen O D1 1 connected hydroxy or hydroxide oxygen O D2 2 connected etheric oxygen C c any carbonF Cl Br I the 1st four halogens N R must be aliphatic nitrogen AND in a ring C R NOTaliphatic carbon AND in a ring n H1 H pyrrole nitrogen n H1 same as above c n H1 any arom carbon OR H pyrrole nitrogen c n H1 arom carbon OR arom nitrogen and exactly one H two atoms connected by a non ringbond two atoms connected by a non aromatic ringbond C c C c two carbons connected by a double or triple bond Go To Next Chapter 5 SMIRKS A Reaction Transform Language Back to Table of Contents", "_id": "http://www.ics.uci.edu/~dock/manuals/DaylightTheoryManual/theory.smarts.html", "title": "daylight theory: smarts - a language for describing molecular \npatterns", "html": "<HTML><head> \n    <link rel=\"stylesheet\" href=\"/b.css\" type=\"text/css\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<TITLE>Daylight Theory: SMARTS - A Language for Describing Molecular \nPatterns</TITLE></HEAD>\ndy leftmargin=0 marginwidth=0 topmargin=0 marginheight=0>\n<table width=750 border=0 cellpadding=0 cellspacing=0>\n     <tr>\n     <td><iframe src=\"/iframes/header2.html\" name=\"iframe4\" width=\"745\" height=\"170\"\n     scrolling=\"no\" frameborder=0></iframe></td>\n     </tr>\n</table>\n<table width=750 cellpadding=15>\n     <tr><td class=\"border-bot\">\n<a name=\"Intro\"></a>\n\n\n<CENTER><H1>\n4.  SMARTS - A Language for Describing Molecular \nPatterns</CENTER></H1><P>\n\n<I>Substructure searching</I>, the process of finding a particular pattern\n(subgraph) in a molecule (graph), is one of the most important tasks for\ncomputers in chemistry.  It is used in virtually every application that employs\na digital representation of a molecule, including depiction (to highlight a\nparticular functional group), drug design (searching a database for similar\nstructures and activity), analytical chemistry (looking for\npreviously-characterized structures and comparing their data to that of an\nunknown), and a host of other problems.<P>\nSMARTS is a language that allows you to specify substructures using rules that\nare straightforward extensions of SMILES.  For example, to search a database\nfor phenol-containing structures, one would use the SMARTS string\n<b>[OH]c1ccccc1</b>, which should be familiar to those acquainted with SMILES.  In\nfact, almost all SMILES specifications are valid SMARTS targets.  Using  SMARTS, flexible and efficient substructure-search\nspecifications can be made in terms that are meaningful to chemists.<P>\nIn the SMILES language, there are two fundamental types of symbols:\n<I>atoms</I> and <I>bonds</I>.  Using these SMILES symbols, once can specify a\nmolecule's graph (its \"nodes\" and \"edges\") and assign \"labels\" to the\ncomponents of the graph (that is, say what type of atom each node represents,\nand what type of bond each edge represents).<P>\nThe same is true in SMARTS: One uses atomic and bond symbols to specify a\ngraph.  However, in SMARTS the labels for the graph's nodes and edges (its\n\"atoms\" and \"bonds\") are extended to include \"logical operators\" and special\natomic and bond symbols; these allow SMARTS atoms and bonds to be more general.\nFor example, the SMARTS atomic symbol <b>[C,N]</b> is an atom that can \nbe aliphatic <b>C</b> or aliphatic <b>N</b>; \nthe SMARTS bond symbol <b>~</b> (tilde) matches any bond.\n<H2>\n<A NAME=\"RTFToC35\"></a>4.1 Atomic Primitives</h2>\nSMARTS provides a number of primitive symbols describing atomic properties\nbeyond those used in SMILES (atomic symbol, charge, and isotopic\nspecifications).  The following tables list the atomic primitives used in\nSMARTS (all SMILES atomic symbols are also legal).  In these tables <b>&lt;n&gt;</b>\nstands for a digit, <b>&lt;c&gt;</b> for chiral class.<br><br>\nNote that atomic primitive <b>H</b> can \nhave two meanings, implying a property or the element itself. <b>[H]</b> means hydrogen atom. <b>[*H2]</b> means any atom with exactly two hydrogens attached<P><CENTER>\n<TABLE BORDER>\n<CAPTION><B>SMARTS Atomic Primitives</B></CAPTION>\n\n<TR>\n  <TH>Symbol</TH>\n  <TH>Symbol name</TH>\n  <TH>Atomic property requirements</TH>\n  <TH>Default</TH>\n</TR>\n\n<TR>\n  <TD>* </TD>\n  <TD>wildcard</TD>\n  <TD>any atom</TD>\n  <TD>(no default)</TD>\n</TR>\n\n<TR>\n  <TD>a</TD>\n  <TD>aromatic</TD>\n  <TD>aromatic</TD>\n  <TD>(no default)</TD>\n</TR>\n\n<TR>\n  <TD>A</TD>\n  <TD>aliphatic</TD>\n  <TD>aliphatic </TD>\n  <TD>(no default)</TD>\n</TR>\n\n<TR>\n  <TD>D&lt;n&gt;</TD>\n  <TD>degree</TD>\n  <TD>&lt;n&gt; explicit connections</TD>\n  <TD>exactly one</TD>\n</TR>\n\n<TR>\n  <TD>H&lt;n&gt;</TD>\n  <TD>total-H-count</TD>\n  <TD>&lt;n&gt; attached hydrogens</TD>\n  <TD>exactly one<SUP><SMALL>1</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>h&lt;n&gt;</TD>\n  <TD>implicit-H-count</TD>\n  <TD>&lt;n&gt; implicit hydrogens</TD>\n  <TD>exactly one</TD>\n</TR>\n\n<TR>\n  <TD>R&lt;n&gt;</TD>\n  <TD>ring membership</TD>\n  <TD>in &lt;n&gt; SSSR rings</TD>\n  <TD>any ring atom</TD>\n</TR>\n\n<TR>\n  <TD>r&lt;n&gt; </TD>\n  <TD>ring size</TD>\n  <TD>in smallest SSSR ring of size &lt;n&gt;</TD>\n  <TD>any ring atom<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>v&lt;n&gt;</TD>\n  <TD>valence</TD>\n  <TD>total bond order &lt;n&gt; </TD>\n  <TD>exactly one<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>X&lt;n&gt;</TD>\n  <TD>connectivity</TD>\n  <TD>&lt;n&gt; total connections</TD>\n  <TD>exactly one<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>x&lt;n&gt;</TD>\n  <TD>ring connectivity</TD>\n  <TD>&lt;n&gt; total ring connections</TD>\n  <TD>at least one<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>- &lt;n&gt;</TD>\n  <TD>negative charge</TD>\n  <TD>-&lt;n&gt; charge</TD>\n  <TD>-1 charge (-- is -2, etc)</TD>\n</TR>\n\n<TR>\n  <TD>+&lt;n&gt;</TD>\n  <TD>positive charge</TD>\n  <TD>+&lt;n&gt; formal charge</TD>\n  <TD>+1 charge (++ is +2, etc)</TD>\n</TR>\n\n<TR>\n  <TD>#n</TD>\n  <TD>atomic number</TD>\n  <TD>atomic number &lt;n&gt;</TD>\n  <TD>(no default)<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>@</TD>\n  <TD>chirality</TD>\n  <TD>anticlockwise</TD>\n  <TD>anticlockwise, default class<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>@@</TD>\n  <TD>chirality</TD>\n  <TD>clockwise</TD>\n  <TD>clockwise, default class<SUP><SMALL>2</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>@&lt;c&gt;&lt;n&gt;</TD>\n  <TD>chirality</TD>\n  <TD>chiral class &lt;c&gt; chirality &lt;n&gt;</TD>\n  <TD>(nodefault)</TD>\n</TR>\n\n<TR>\n  <TD>@&lt;c&gt;&lt;n&gt;?</TD>\n  <TD>chiral or unspec</TD>\n  <TD>chirality &lt;c&gt;&lt;n&gt; orunspecified</TD>\n  <TD>(no default)</TD\n</TR>\n\n<TR>\n  <TD>&lt;n&gt;</TD>\n  <TD>atomic mass</TD>\n  <TD>explicit atomic mass</TD>\n  <TD>unspecified mass</TD>\n</TR>\n</TABLE>\n</CENTER><P>\n\n<center>\n<SUP><SMALL>1</SMALL></SUP> Semantics of [H] changed in v4.5&nbsp;&nbsp;&nbsp;&nbsp;\n<SUP><SMALL>2</SMALL></SUP> @ and @@ introduced in v4.1; &nbsp;r, v, X, and \n# in v4.3; &nbsp;x in v4.9\n</center>\n\n<P>\n\n<CENTER>\n<TABLE BORDER>\n<B>Examples:</B><P>\n\n<TR>\n  <TD>C</TD>\n  <TD>aliphatic carbon atom</TD>\n</TR>\n\n<TR>\n  <TD>c</TD>\n  <TD>aromatic carbon atom</TD>\n</TR>\n\n<TR>\n  <TD>a</TD>\n  <TD>aromatic atom</TD>\n</TR>\n\n<TR>\n  <TD>[#6]</TD>\n  <TD>carbon atom</TD>\n</TR>\n\n<TR>\n  <TD>[Ca]</TD>\n  <TD>calcium atom</TD>\n</TR>\n\n<TR>\n  <TD>[++]</TD>\n  <TD>atom with a +2 charge</TD>\n  <TD>\n</TR>\n\n<TR>\n  <TD>[R]</TD>\n  <TD>atom in any ring</TD>\n</TR>\n\n<TR>\n  <TD>[D3]</TD>\n  <TD>atom with 3 explicit bonds (implicit H's don't count)</TD>\n</TR>\n\n<TR>\n  <TD>[X3]</TD>\n  <TD>atom with 3 total bonds (includes implicit H's)</TD>\n</TR>\n\n<TR>\n  <TD>[v3]</TD>\n  <TD>atom with bond orders totaling 3 (includes implicit H's)</TD>\n</TR>\n\n<TR>\n  <TD>C[C@H](F)O</TD>\n  <TD>match chirality (H-F-O anticlockwise viewed from C)</TD>\n</TR>\n\n<TR>\n  <TD>C[C@?H](F)O</TD>\n  <TD>matches if chirality is as specified or is not specified</TD>\n</TR>\n</TABLE>\n</CENTER>\n<P>\n<H2>\n<A NAME=\"RTFToC36\"></a>4.2 Bond Primitives</H2>\nVarious bond symbols are available to match connections between atoms.  A\nmissing bond symbol is interpreted as \"single or aromatic\".<P>\n<CENTER>\n<TABLE BORDER>\n<CAPTION><B>  SMARTS Bond Primitives</B></CAPTION><P>\n  <TH>Symbol</TH> \n  <TH>Atomic property requirements</TH>\n<TR>\n  <TD>- </TD>\n  <TD>single bond (aliphatic)</TD>\n</TR>\n\n<TR>\n  <TD>/</TD>\n  <TD>directional single bond \"up\"<SUP><SMALL>1</SMALL></SUP></TD>\n</TR>\n\n\n<TR>\n  <TD>\\</TD>\n  <TD>directional single bond \"down\"<SUP><SMALL>1</SMALL></SUP></TD>\n</TR>\n\n<TR>\n  <TD>/?</TD>\n  <TD>directional bond \"up or unspecified\"</TD>\n</TR>\n\n<TR>\n  <TD>\\?</TD>\n  <TD>directional bond \"down or unspecified\"</TD>\n</TR>\n\n<TR>\n  <TD>=</TD>\n  <TD>double bond</TD>\n</TR>\n\n<TR>\n  <TD># </TD>\n  <TD>triple bond</TD>\n</TR>\n\n<TR>\n  <TD>: </TD>\n  <TD>aromatic bond</TD>\n</TR>\n\n<TR>\n  <TD>~</TD>\n  <TD>any bond (wildcard)</TD>\n</TR>\n\n<TR>\n  <TD>@</TD>\n  <TD>any ring bond<SUP><SMALL>1</SMALL></SUP></TD>\n</TR>\n</TABLE></CENTER><P>\n<center>\n<SUP><SMALL>1</SMALL></SUP>/ and \\ introduced in v4.1; &nbsp@ in v4.6\n</center>\n<br>\n<CENTER>\n<TABLE BORDER><P>\n<B>Examples:</B><P>\n<TR>\n  <TD>C </TD>\n  <TD>any aliphatic carbon</TD>\n</TR>\n\n<TR>\n  <TD>cc</TD>\n  <TD>any pair of attached aromatic carbons</TD>\n</TR>\n\n<TR>\n  <TD>c:c</TD>\n  <TD>aromatic carbons joined by an aromatic bond</TD>\n</TR>\n\n<TR>\n  <TD>c-c</TD>\n  <TD>aromatic carbons joined by a single bond (e.g. biphenyl)</TD>\n</TR>\n<P>\n</TABLE>\n</CENTER><P>\n\n<H2>\n<A NAME=\"RTFToC37\"></a>4.3 Logical Operators</H2>\n Atom and bond primitive specifications may be combined to form expressions by\nusing logical operators.  In the following table, <b>e</b> is an atom or bond \nSMARTS expression (which may be a primitive).  The logical operators are listed in order of decreasing precedence (high precedence operators are evaluated \nfirst).<P>\n<CENTER>\n<TABLE BORDER>\n<CAPTION><B>  SMARTS Logical Operators</B></CAPTION><P>\n<TH>Symbol</TH>\n<TH>Expression</TH>\n<TH>Meaning</TH>\n\n<TR>\n  <TD>exclamation</TD>\n  <TD>!e1</TD>\n  <TD>not e1</TD>\n</TR>\n\n<TR>\n  <TD>ampersand</TD>\n  <TD>e1&amp;e2</TD>\n  <TD>a1 and e2 (high precedence)</TD>\n</TR>\n\n<TR>\n  <TD>comma</TD>\n  <TD>e1,e2</TD>\n  <TD>e1 or e2</TD>\n</TR>\n\n<TR>\n  <TD>semicolon </TD>\n  <TD>e1;e2</TD>\n  <TD>a1 and e2 (low precedence)</TD>\n</TR>\n</TABLE>\n</CENTER><P>\n\nAll atomic expressions which are not simple primitives must be enclosed in\nbrackets.  The default operation is <b>&</b> (high precedence \"and\"), i.e., two\nadjacent primitives without an intervening logical operator must both be true\nfor the expression (or subexpression) to be true.<P>\nThe ability to form expressions gives the SMARTS user a great deal of power to\nspecify exactly what is desired.  The two forms of the AND operator are used in\nSMARTS instead of grouping operators.<P>\n\n<CENTER>\n<TABLE BORDER><CAPTION><B>Examples:</B></CAPTION><P>\n\n<TR>\n  <TD>[CH2]</TD>\n  <TD>aliphatic carbon with two hydrogens (methylene carbon)</TD>\n</TR>\n\n<TR>\n  <TD>[!C;R]</TD>\n  <TD>( NOT aliphatic carbon ) AND in ring</TD>\n</TR>\n\n<TR>\n  <TD>[!C;!R0]</TD>\n  <TD>same as above (\"!R0\" means not in zero rings)</TD>\n</TR>\n\n<TR>\n  <TD>[n;H1]</TD>\n  <TD>H-pyrrole nitrogen</TD>\n</TR>\n\n<TR>\n  <TD>[n&amp;H1]</TD>\n  <TD>same as above</TD>\n</TR>\n\n<TR>\n  <TD>[nH1]</TD>\n  <TD>same as above</TD>\n</TR>\n\n<TR>\n  <TD>[c,n&amp;H1]</TD>\n  <TD>any arom carbon OR H-pyrrole nitrogen</TD>\n</TR>\n\n<TR>\n  <TD>[X3&amp;H0]</TD>\n  <TD>atom with 3 total bonds and no H's</TD>\n</TR>\n\n<TR>\n  <TD>[c,n;H1]</TD>\n  <TD>(arom carbon OR arom nitrogen)  and exactly one H</TD>\n</TR>\n\n<TR>\n  <TD>[Cl]</TD>\n  <TD>any chlorine atom</TD>\n</TR>\n\n<TR>\n  <TD>[35*]</TD>\n  <TD>any atom of mass 35</TD>\n</TR>\n\n<TR>\n  <TD>[35Cl]</TD>\n  <TD>chlorine atom of mass 35</TD>\n</TR>\n\n<TR>\n  <TD>[F,Cl,Br,I]</TD>\n  <TD>the 1st four halogens.</TD>\n</TR>\n</TABLE>\n</CENTER><P>\n\n\n<H2>\n<A NAME=\"RTFToC38\"></a>4.4 Recursive SMARTS</H2>\n\nAny SMARTS expression may be used to define an atomic environment by writing a\nSMARTS starting with the atom of interest in this form: <center><B>$(SMARTS)</B></center><p>Such definitions may be considered atomic properties.  These expressions can be\nused in same manner as other atomic primitives (also, they can be nested).\nRecursive SMARTS expressions are used in the following manner:<P>\n<CENTER>\n<TABLE BORDER>\n<TR>\n  <TD>*C </TD>\n  <TD>atom connected to methyl (or methylene) carbon</TD>\n</TR>\n\n<TR>\n  <TD>*CC</TD>\n  <TD>atom connected to ethyl carbon</TD>\n</TR>\n\n<TR>\n  <TD>[$(*C);$(*CC)]</TD>\n  <TD>atom in both above environments (matches CCC)</TD>\n</TR>\n\n</TABLE>\n</CENTER><P>\n\n\nThe additional power of such expressions is illustrated by the following\nexample which derives an expression for methyl carbons which are ortho to\noxygen and meta to a nitrogen on an aromatic ring.<P>\n<CENTER>\n<TABLE BORDER>\n<TR>\n  <TD>CaaO</TD>\n  <TD>C ortho to O</TD>\n</TR>\n\n\n<TR>\n  <TD>CaaaN</TD>\n  <TD>C meta to N</TD>\n</TR>\n\n<TR>\n  <TD>Caa(O)aN</TD>\n  <TD>C ortho to O and meta to N (but 2O,3N only)</TD>\n</TR>\n\n<TR>\n  <TD>Ca(aO)aaN</TD>\n  <TD>C ortho to O and meta to N (but 2O,5N only)</TD>\n</TR>\n\n<TR>\n  <TD>C[$(aaO);$(aaaN)]</TD>\n  <TD>C ortho to O and meta to N (all cases)</TD>\n</TR>\n\n</TABLE>\n</CENTER><P>\n\n\n<H2>\n<A NAME=\"RTF.4.6.\"></a>4.5 Component-level grouping of  SMARTS</H2>\n\nSMARTS may contain \"zero-level\" parentheses which can be used to group\ndot-disconnected fragments.  This grouping operator allows SMARTS to express\nmore powerful component queries.  In general, a single set of parentheses may\nsurround any legal SMARTS expression.  Two or more of these expressions may be\ncombined into more complex SMARTS:\n<P>\n<CENTER>\n<B>(SMARTS)</B><BR>\n<B>(SMARTS).(SMARTS)</B><BR>\n<B>(SMARTS).SMARTS</B><BR>\n</CENTER><P>\nThe semantics of the \"zero-level\" parentheses are that all of the atom and\nbond expressions within a set of zero-level parentheses must match within a\nsingle component of the target.\n<P>\n<CENTER>\n<TABLE BORDER>\n  <TR>\n    <TD><B>SMARTS</B></TD>\n    <TD><B>SMILES</B></TD>\n    <TD><B>Match behavior</B></TD>\n  </TR>\n  \n  <TR>\n    <TD>C.C</TD>\n    <TD>CCCC</TD>\n    <TD>yes, no component level grouping specified</TD>\n  </TR>\n\n  <TR>\n    <TD>(C.C)</TD>\n    <TD>CCCC</TD>\n    <TD>yes, both carbons in the query match the same component</TD>\n  </TR>\n\n  <TR>\n    <TD>(C).(C)</TD>\n    <TD>CCCC</TD>\n    <TD>no, the query must match carbons in two different components</TD>\n  </TR>\n\n  <TR>\n    <TD>(C).(C)</TD>\n    <TD>CCCC.CCCC</TD>\n    <TD>yes, the query does match carbons in two different components</TD>\n  </TR>\n\n  <TR>\n    <TD>(C).C</TD>\n    <TD>CCCC</TD>\n    <TD>yes, both carbons in the query match the same component</TD>\n  </TR>\n  <Tr>  \n    <TD>(C).(C).C</TD>\n    <TD>CCCC.CCCC</TD>\n    <TD>yes, the first two carbons match different components,<br>the third\n\tmatches a carbon anywhere</TD>\n  </TR>\n</TABLE>\n</CENTER>\n<P>\nThese component-level grouping operators were added specifically for reaction\nprocessing.  Without this construct, it is impossible to distinguish inter-\nversus intramolecular reaction queries.  For example:\n<P>\n<CENTER>\n<TABLE BORDER>\n  <TR>\n    <TD><B>Reaction SMARTS expression</B></TD>\n    <TD><B>Match behavior</B></TD>\n  </TR>\n  \n  <TR>\n    <TD>C(=O)O.OCC>>C(=O)OCC.O</TD>\n    <TD>Matches esterifications</TD>\n  </TR>\n  \n  <TR>\n    <TD>(C(=O)O).(OCC)>>C(=O)OCC.O</TD>\n    <TD>Matches intermolecular esterifications</TD>\n  </TR>\n  \n  <TR>\n    <TD>(C(=O)O.OCC)>>C(=O)OCC.O</TD>\n    <TD>Matches intramolecular esterifications (lactonizations)</TD>\n  </TR>\n</TABLE>\n</CENTER>\n\n<h2><a name=\"RTFrxn7\"></a>4.6 Reaction Queries</h2>\n</p>\n<p>\nReaction queries are expressed using the SMARTS language.  SMARTS has been\nextended to handle reaction query features in much the same fashion as SMILES\nhas been extended to handle reactions.  \n</p>\n<p>\nA reaction query may be composed of optional reactant, agent, and product\nparts, which are separated by the &quot;&gt;&quot; character.  In this case,\nthe parts of the reaction query match against the corresponding roles within\nthe reaction target, as expected.  Note that it is  also quite reasonable to\nsearch a set of reactions by giving a molecule query.  In this case, the\nanswer is a hit if the molecule SMARTS matches anywhere within the reaction\ntarget.  In effect, matching a molecule SMARTS against a reaction target\nis a query where the role of the SMARTS is unspecified.\n</p>\n<p>\n\n<center>\n<table border=\"1\">\n  <tr>\n    <td colspan=\"3\" align=\"center\">\n    <b>Example Reaction SMARTS:</b>\n    <tr>\n      <td align=\"center\">Query:</td>\n      <td align=\"center\">Target:</td>\n      <td align=\"center\">Matches:</td>\n    </tr>\n    <tr>\n      <td align=\"center\">C&gt;&gt;</td>\n      <td align=\"center\">CC&gt;&gt;CN</td>\n      <td align=\"center\">2</td>\n    </tr>\n    <tr>\n      <td align=\"center\">&gt;C&gt;\n      <td align=\"center\">CC&gt;&gt;CN\n      <td align=\"center\">0\n    </tr>\n    <tr>\n      <td align=\"center\">&gt;&gt;C\n      <td align=\"center\">CC&gt;&gt;CN\n      <td align=\"center\">1\n    </tr>\n    <tr>\n      <td align=\"center\">C\n      <td align=\"center\">CC&gt;&gt;CN\n      <td align=\"center\">3\n    </tr>\n </td>\n </tr>\n</table>\n</center>\n\n<p>\nThe atom mapping for a reaction query is optional.  When included in the\ndefinition of the pattern, it is used for searching.\n</p>\n<p>\nIf atom maps are used for a SMARTS match, their only effect is to potentially\neliminate answers from the result.  Atom maps can never, under any\ncircumstance cause the addition of hits to an answer set. Conceptually, one\ncan consider the atom map matching as a post-processing step after a\n&quot;normal&quot; match.  Each of the hits is examined to make sure the atom\nmap classes match on the reactant and product sides of the reaction.\n</p>\n<p>\nIn SMARTS, the atom map has unusual semantics.  An atom map is a property\nwhich must be evaluated on a global scope during the match.  One can not know\nif the map is correct without considering every atom in the match, in effect\nrequiring the enumeration of every possible path before testing.  This is much\nmore computationally expensive than the current SMARTS implementation, which\ntests the paths as they are built and stops as soon as a path fails to match.\n</p>\n<p>\nIn order to avoid this computational trap, the expressiveness of SMARTS for\natom maps has been limited to a low-precedence and operation.  That is, only\nexpressions of form: &quot;[expr:n]&quot; or &quot;[expr:?n]&quot; are\nallowed, where &quot;expr&quot; is any legal atomic expression excluding atom\nmaps and &quot;n&quot; is a map class value. This expression is a\nlow-precedence logical AND between &quot;expr&quot; and the map expression\n&quot;:n&quot;.  The following examples illustrate other nuances of the\nsemantics: \n</p>\n<p>\n\n<center>\n<table border=\"1\">\n  <tr>\n    <td colspan=\"4\" align=\"center\">\n    <b>Example Reaction SMARTS:</b>\n    <tr>\n      <td align=\"center\">Query:</td>\n      <td align=\"center\">Target:</td>\n      <td align=\"center\">Matches:</td>\n      <td align=\"center\">Comment:</td>\n    </tr>\n    <tr>\n      <td align=\"center\">C&gt;&gt;C</td>\n      <td align=\"center\">CC&gt;&gt;CC</td>\n      <td align=\"center\">4</td>\n      <td>No maps, normal match.</td>\n    </tr>\t  \n    <tr>\n      <td align=\"center\">C&gt;&gt;C</td>\n      <td align=\"center\">[CH3:7][CH3:8]&gt;&gt; [CH3:7][CH3:8]</td>\n      <td align=\"center\">4</td>\n      <td>No maps in query, maps in target are ignored.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1]&gt;&gt;C</td>\n      <td align=\"center\">[CH3:7][CH3:8]&gt;&gt; [CH3:7][CH3:8]</td>\n      <td align=\"center\">4</td>\n      <td>Unpaired map in query ignored.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1]&gt;&gt;[C:1]</td>\n      <td align=\"center\">CC&gt;&gt;CC</td>\n      <td align=\"center\">0</td>\n      <td>No maps in target, hence no matches.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:?1]&gt;&gt;[C:?1]</td>\n      <td align=\"center\">CC&gt;&gt;CC</td>\n      <td align=\"center\">4</td>\n      <td>Query says mapped as shown or not present.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1]&gt;&gt;[C:1]</td>\n      <td align=\"center\">[CH3:7][CH3:8]&gt;&gt;[CH3:7][CH3:8]</td>\n      <td align=\"center\">2</td>\n      <td>Matches for target 7,7 and 8,8 atom pairs.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1]&gt;&gt;[C:2]</td>\n      <td align=\"center\">[CH3:7][CH3:8]&gt;&gt; [CH3:7][CH3:8]</td>\n      <td align=\"center\">4</td>\n      <td>When a query class is not found on both<br>sides of the query, it is\n\t  ignored;<br>this query does NOT say that the atoms<br>are in different\n\t  classes. </td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1][C:1]&gt;&gt;[C:1]</td>\n      <td align=\"center\">[CH3:7][CH3:7]&gt;&gt; [CH3:7][CH3:7]</td>\n      <td align=\"center\">4</td>\n      <td>Atom maps match with &quot;or&quot; logic.  All atoms<br>get bound to\n\t  class 7.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1][C:1]&gt;&gt;[C:1]</td>\n      <td align=\"center\">[CH3:7][CH3:8]&gt;&gt; [CH3:7][CH3:8]</td>\n      <td align=\"center\">4</td>\n      <td>The reactant atoms are bound to classes 7<br>and 8. Note that having\n\t  the first query atom<br>bound to class 7 does not preclude<br>binding the\n\t  second atom. Next, the product<br>atom can bind to classes 7 or 8.</td>\n    </tr>\n    <tr>\n      <td align=\"center\">[C:1][C:1]&gt;&gt;[C:1]</td>\n      <td align=\"center\">[CH3:7][CH3:7]&gt;&gt; [CH3:7][CH3:8]</td>\n      <td align=\"center\">2</td>\n      <td>The reactants are bound to class 7.  The<br>product atom can bind to\n\t  class 7 only.</td>\n    </tr>\n  </td>\n </tr>\n</table>\n</center>   \n</p>\n<p>\nThe last example is the most confusing.  Since there is no &quot;or&quot\nlogic for atom maps, the behavior when checking the maps is as follows:\nthe query reactants can be bound to any classes in the target.  These\nbindings form the set of allowed product bindings.  The product query atoms\nare then tested against this list.  If all of the product atoms pass, then\nthe path is a match.  The effect of this procedure is to provide the\n&quot;logical-OR&quot; semantics for atom maps within the simple\nimplementation.  The downside of this implementation is that it can be\nconfusing to the user.  Fortunately, the simple pairwise atom maps will\nsuffice for most users.\n</p>\n<p>\nFinally, atom map labels in molecule SMARTS and unpaired atom map labels in\nreaction SMARTS are ignored.  Stated another way, since the atom maps express\nthe idea of a global association of atoms across a reaction, atom maps on a\nmolecule query have no meaning.  Similarly, a lone atom map on a reaction atom\nwhich doesn't correspond to any other atoms in the query has no meaning.  In\nboth of these cases, the query is identical to the query written without the\nmeaningless atom maps.\n</p>\n<p>\nIn recursive SMARTS, reaction expressions are not allowed.  The reasons for\nthis are twofold:  first, it isn't clear that the meaning of a recursive\nSMARTS for a reaction would have any useful expressiveness and second, there\nis a practical problem with the lexical definitions of reactions: given the\nstrict left-to-right definition of reactant-agent-product, how would one\nexpress a product atom in a vector binding??  Of course we can change the\nsyntax for recursive SMARTS or reactions to accommodate this if it becomes\nclear that it is useful.\n</p>\n\n\n<P>\n<H2>\n<A NAME=\"RTFToC39\"></a>4.7 SMARTS Versus SMILES</H2>\nAll SMILES expressions are also valid SMARTS expressions, but the semantics\nchanges because SMILES describes molecules whereas SMARTS describes patterns.\nThe molecule represented by a SMILES string is usually, but not always, matched\nby the same string when used as a SMARTS.\n</P>\n<P>\nSMILES is interpreted as a molecule, and it is the resultant molecule (not the\nSMILES string) which is subject to searching.  Similarly, SMARTS is\ninterpreted as a pattern; it is this pattern (not the SMARTS string) which is\nmatched against molecules.  For instance, the SMILES \"C1=CC=CC=C1\"\n(cyclohexatriene) is interpreted as the benzene molecule.  This molecule will\nbe matched by the SMARTS c1ccccc1, which is interpreted as the pattern \"6\naromatic carbons in a ring\".  The SMARTS \"C1=CC=CC=C1\" makes a pattern (\"six\naliphatic carbons in a ring with alternating single and double bonds\") which\nwill <I>not</I> match benzene.  It will, however, match the nonaromatic\nphenylate cation with SMILES C1=CC=CC=[CH+]1.\n</P>\n<P>\nWhen atoms are specified without brackets in SMILES, default values are used;\nin SMARTS, unspecified properties are not defined to be part of the pattern.\nFor instance, the SMILES O means an aliphatic oxygen with zero charge and two\nhydrogens, i.e. water.  In SMARTS, the same expression means any aliphatic\noxygen regardless of charge, hydrogen count, etc, e.g. it will match the oxygen\nin water, but also those in ethanol, acetone, molecular oxygen, hydroxy and\nhydronium ions, etc.  Specifying [OH2] limits the pattern to match only water\n(this is also the fully specified SMILES for water).\n</P>\n<P>\nThere are a few anachronisms in most SMILES interpreters which can also lead to\nconfusion.  Some SMILES interpreters allow implicit hydrogens to be added as\nexplicit atoms on input as a shortcut.  E.g., the SMILES for 1H-pyrrole is\n\"[nH]1cccc1\" which is matched by itself as SMARTS and by \"n1cccc1\".  The\ncurrent Daylight SMILES interpreter will also accept \"Hn1cccc1\" for (not very\ngood) reasons of historical compatibility; this generates the same\n(hydrogen-suppressed) molecule as does \"[nH]1cccc1\" and is matched by the same\nSMARTS.  However, the SMARTS \"Hn1cccc1\" does not match this molecule.<p>\nMost SMARTS expressions are not valid SMILES expressions.  For instance, the\nstring \"cOc\" is a valid SMARTS, matching an aliphatic oxygen connected to two\naromatic carbons as part of a larger molecule (e.g. diphenyl ether).  However,\n\"cOc\" does not describe a molecule per se, and is therefore not a valid SMILES.\n<H2>\n<A NAME=\"RTFToC40\"></a>4.8  Efficiency Considerations</H2>\nThe Daylight 4.x SMARTS Toolkit provides a function, <TT>dt_smarts_opt()</TT>,\nwhich automatically optimizes a SMARTS by reordering, expanding, and/or\nconsolidating atom and bond expressions.  Programs which use this feature (e.g.\nthe Merlin program) can be expected to be near optimal in terms of the time\nused to search typical organic structures.\n</P>\n<P>\nWhen this optimization method is not used, there are some things which can be\ndone to facilitate efficient (fast) searching operations using SMARTS.  It is\nimportant to recognize that SMARTS target strings are processed in strictly\nleft-to-right order.  For this reason, substantial gains in speed can be\nachieved by following these guidelines:\n</P>\n<P>\n\n<UL>\n  <LI>\n     Uncommon atoms or bond arrangements should be placed early in SMARTS\n     targets.\n  </LI>\n</P>\n<P>\n  <LI>\n     In an \"and-expression\", the less common atom or bond specifications\n     should be placed early.\n  </LI>\n</P>\n<P>\n<LI>\nIn an \"or-expression\", the less common atom or bond specifications\nshould be placed last.\n</LI>\n</UL>\n<P>\n\n\n<H2>\n<A NAME=\"RTFToC41\"></a>4.9 Examples</H2><P>\n\n<CENTER>\n<TABLE BORDER>\n<TR>\n  <TD>cc</TD>\n  <TD>any pair of attached aromatic carbons</TD>\n</TR>\n\n<TR>\n  <TD>c:c</TD>\n  <TD>aromatic carbons joined by an aromatic bond</TD>\n</TR>\n\n<TR>\n  <TD>c-c</TD>\n  <TD>aromatic carbons joined by a single bond (e.g. biphenyl).</TD>\n</TR>\n\n<TR>\n  <TD>O</TD>\n  <TD>any aliphatic oxygen</TD>\n</TR>\n\n<TR>\n  <TD>[O;H1]</TD>\n  <TD>simple hydroxy oxygen</TD>\n</TR>\n\n<TR>\n  <TD>[O;D1]</TD>\n  <TD>1-connected (hydroxy or hydroxide) oxygen</TD>\n</TR>\n\n<TR>\n  <TD>[O;D2]</TD>\n  <TD>2-connected (etheric) oxygen</TD>\n</TR>\n\n<TR>\n  <TD>[C,c]</TD>\n  <TD>any carbon</TD>\n</TR>\n\n<TR>\n  <TD>F,Cl,Br,I]</TD>\n  <TD>the 1st four halogens.</TD>\n</TR>\n\n<TR>\n  <TD>[N;R]</TD>\n  <TD>must be aliphatic nitrogen AND in a ring</TD>\n</TR>\n\n<TR>\n  <TD>[!C;R]</TD>\n  <TD>( NOTaliphatic carbon ) AND in a ring</TD>\n</TR>\n\n<TR>\n  <TD>[n;H1]</TD>\n  <TD>H-pyrrole nitrogen</TD>\n</TR>\n\n<TR>\n  <TD>[n&amp;H1]</TD>\n  <TD>same as above</TD>\n</TR>\n\n<TR>\n  <TD>[c,n&amp;H1]</TD>\n  <TD>any arom carbon OR H-pyrrole nitrogen</TD>\n</TR>\n\n<TR>\n  <TD>[c,n;H1]</TD>\n  <TD>(arom carbon OR arom nitrogen) and exactly one H</TD>\n</TR>\n\n<TR>\n  <TD>*!@*</TD>\n  <TD>two atoms connected by a non-ringbond</TD>\n</TR>\n\n<TR>\n  <TD>*@;!:*</TD>\n  <TD>two atoms connected by a non-aromatic ringbond</TD>\n</TR>\n\n<TR>\n  <TD>[C,c]=,#[C,c]</TD>\n  <TD>two carbons connected by a double or triple bond</TD>\n</TR>\n\n</TABLE>\n</CENTER><P>\n<BR><BR>\n<I>Go To Next Chapter...</I>\n<A HREF=\"theory.smirks.html\"> 5.  SMIRKS - A Reaction Transform Language</A><br>\n<i>Back to...</i>\n<a href=\"index.html\">Table of Contents</a>\n\n</P>\n\n\n    </td> \n    </tr> \n    <tr> \n    <td><iframe src=\"/iframes/footer.html\" name=\"iframe3\" width=\"350\" height=\"200\" \n       scrolling=\"no\" frameborder=\"0\"></iframe></td> \n    </tr> \n</table> \n</body> \n</html>\n", "id": 37292.0}