{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Pure Virtual Functions and Abstract Base Classes The moniker for this code example is PureVirtual Background When object oriented principles are taught it s not uncommon to see the example of different kinds of shapes circles rectangles right triangles etc to be used to illustrate the concept Different kinds of shapes might have similar abilities such as the ability to be drawn or the ability to tell you their area but would perform these similar operations in different ways Let s consider that same example but keep it simple shapes in our example will only have the ability to tell you their area Of course different kinds of shapes would calculate their area differently for example circles would square their radius and multiply it by while rectangles would multiply their width and height together Starting with Circle and Rectangle classes We could begin with relatively straightforward implementations of Circle and Rectangle classes and whatever other shapes we d like to implement feel free to practice by adding additional shapes to this example class Circle public double area const class Rectangle public double area const There is obvious value in giving each of the area members functions the same signature we d like at some point to be able to have a pointer that points to some kind of shape call area on it and have the right function be called One requirement if we want that kind of polymorphism is that all of the functions share the same signature But this example stops short of being complete in C If we wrote this same example in Python we might well be done from a design perspective We might write the two classes this way class Circle def init self radius self radius radius def area self return 3 1415927 self radius self radius class Rectangle def init self width height self width width self height height def area self return self width self height In Python what relates these classes together is that they share the same interface i e they both have area methods that have the same signature And that s all you need to achieve polymorphism because the notion of interface in Python is an implicit one if two classes have a set of methods with the same signatures they share an interface Because of that you would now be able to write something like this def print area some shape print some shape area then pass either a Circle or Rectangle object to this function Since method calls are resolved at run time in Python Python asks What kind of object is some shape Does that kind of object have an area method If so call it If not raise an exception it is actually legal to pass any kind of object as an argument to this function though only objects that have an area method will do anything other than fail i e raise an exception However C has a different point of view on the issue of type checking In particular C requires every variable to be declared with a particular type and then that variable will only be able to accept a value of a type that s compatible So how could we write a function in C that s equivalent to our print area function in Python First of all we d need a type for the function s parameter It would need to be a type that s compatible with any kind of shape i e we should be able to pass the function a Circle object or a Rectangle object So far there s no way to say that in C since the Circle and Rectangle classes are unrelated in any explicit way C considers them separate incompatible types To achieve our goal then we ll need to add a piece to the puzzle Adding an abstract base class One way to relate C classes that share the same interface i e that have one or more member functions with identical signatures and identical meanings is to make that relationship explicit using inheritance We do that by introducing a base class that s general not specific to any particular kind of shape and then derive our Circle and Rectangle classes from it A good name for that class might be Shape class Shape public virtual double area const class Circle public Shape public virtual double area const class Rectangle public Shape public virtual double area const The trouble though is that there is no reasonable implementation for Shape s area member function What does it mean to ask a shape for its area It depends on what kind of shape it is The Shape class represents the abstract notion of a shape without being any particular kind of shape And if we don t know what kind of shape we have we don t know how to calculate its area This issue arises in designs like this quite often so C offers a way to establish the important fact about our design namely that all shapes can calculate an area the same way while leaving the implementation details to be filled in by derived classes We do this by declaring area in the Shape class to be a pure virtual function by using the rather bizarre looking notation at the end of its signature You can read that as the word pure if it helps it to make more sense class Shape public virtual double area const Doing this has two consequences Shape area has no body It s not a function but merely a placeholder for functions that will be defined in derived classes Shape by virtue of having at least one pure virtual function is a class that has pieces missing It would be dangerous to have Shape objects because you might call one of these missing functions on it and the compiler wouldn t be able to prevent this from happening in all cases So as soon as a class has at least one pure virtual functions it becomes a special kind of class called an abstract base class It is not possible to create objects of an abstract base class to protect you from inadvertently calling a pure virtual function but it is possible to have pointers or references of these types which is what makes polymorphism possible The code The official moniker for this code example is PureVirtual so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code PureVirtual to download the code example into your project directory s src directory Alternatively you can click the link to the tarball below PureVirtual tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/PureVirtual/", "title": "ics 45c fall 2014, code example: pure virtual functions and abstract base classes", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Pure Virtual Functions and Abstract Base Classes</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Pure Virtual Functions and Abstract Base Classes</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>PureVirtual</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>When object-oriented principles are taught, it's not uncommon to see the example of different kinds of shapes &mdash; circles, rectangles, right triangles, etc. &mdash; to be used to illustrate the concept.  Different kinds of shapes might have similar abilities, such as the ability to be drawn or the ability to tell you their area, but would perform these similar operations in different ways.</p>\r\n\r\n<p>Let's consider that same example, but keep it simple: shapes, in our example, will only have the ability to tell you their area.  Of course, different kinds of shapes would calculate their area differently; for example, circles would square their radius and multiply it by &pi;, while rectangles would multiply their width and height together.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Starting with Circle and Rectangle classes</p>\r\n\r\n<p>We could begin with relatively straightforward implementations of <b>Circle</b> and <b>Rectangle</b> classes (and whatever other shapes we'd like to implement; feel free to practice by adding additional shapes to this example).</p>\r\n\r\n<blockquote><pre>\r\nclass Circle\r\n{\r\npublic:\r\n    double area() const;\r\n};\r\n\r\nclass Rectangle\r\n{\r\npublic:\r\n    double area() const;\r\n};\r\n</pre></blockquote>\r\n\r\n<p>There is obvious value in giving each of the <b>area()</b> members functions the same signature: we'd like, at some point, to be able to have a pointer that points to some kind of shape, call <b>area()</b> on it, and have the \"right\" function be called.  One requirement if we want that kind of polymorphism is that all of the functions share the same signature.</p>\r\n\r\n<p>But this example stops short of being complete in C++.  If we wrote this same example in Python, we might well be done, from a design perspective.  We might write the two classes this way.</p>\r\n\r\n<blockquote><pre>\r\nclass Circle:\r\n    def __init__(self, radius):\r\n        self._radius = radius\r\n\r\n    def area(self):\r\n        return 3.1415927 * self._radius * self._radius\r\n\r\n\r\nclass Rectangle:\r\n    def __init__(self, width, height):\r\n        self._width = width\r\n        self._height = height\r\n\r\n    def area(self):\r\n        return self._width * self._height\r\n</pre></blockquote>\r\n\r\n<p>In Python, what relates these classes together is that they share the same \"interface\" (i.e., they both have <b>area</b> methods that have the same signature).  And that's all you need to achieve polymorphism,  because the notion of \"interface\" in Python is an implicit one; if two classes have a set of methods with the same signatures, they share an interface.  Because of that, you would now be able to write something like this...</p>\r\n\r\n<blockquote><pre>\r\ndef print_area(some_shape):\r\n    print(some_shape.area())\r\n</pre></blockquote>\r\n\r\n<p>...then pass either a Circle or Rectangle object to this function.  Since method calls are resolved at run time in Python &mdash; Python asks \"What kind of object is <b>some_shape</b>?  Does that kind of object have an <b>area()</b> method?  If so, call it!  If not, raise an exception!\" &mdash; it is actually legal to pass any kind of object as an argument to this function, though only objects that have an <b>area()</b> method will do anything other than fail (i.e., raise an exception).</p>\r\n\r\n<p>However, C++ has a different point of view on the issue of type checking.  In particular, C++ requires every variable to be declared with a particular type, and then that variable will only be able to accept a value of a type that's compatible.  So how could we write a function in C++ that's equivalent to our <b>print_area</b> function in Python?</p>\r\n\r\n<p>First of all, we'd need a type for the function's parameter.  It would need to be a type that's compatible with any kind of shape (i.e., we should be able to pass the function a Circle object <i>or</i> a Rectangle object).  So far, there's no way to say that in C++; since the Circle and Rectangle classes are unrelated in any explicit way, C++ considers them separate, incompatible types.</p>\r\n\r\n<p>To achieve our goal, then, we'll need to add a piece to the puzzle.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Adding an abstract base class</p>\r\n\r\n<p>One way to relate C++ classes that share the same interface (i.e., that have one or more member functions with identical signatures and identical meanings) is to make that relationship explicit using inheritance.  We do that by introducing a base class that's general &mdash; not specific to any particular kind of shape &mdash; and then derive our Circle and Rectangle classes from it.  A good name for that class might be Shape.</p>\r\n\r\n<blockquote><pre>\r\nclass Shape\r\n{\r\npublic:\r\n    virtual double area() const;\r\n};\r\n\r\nclass Circle : public Shape\r\n{\r\npublic:\r\n    virtual double area() const;\r\n};\r\n\r\nclass Rectangle : public Shape\r\n{\r\npublic:\r\n    virtual double area() const;\r\n};\r\n</pre></blockquote>\r\n\r\n<p>The trouble, though, is that there is no reasonable implementation for <b>Shape</b>'s <b>area()</b> member function.  What does it mean to ask a shape for its area?  It depends on what kind of shape it is.  The Shape class represents the abstract notion of a shape without <i>being</i> any particular kind of shape.  And if we don't know what kind of shape we have, we don't know how to calculate its area.</p>\r\n\r\n<p>This issue arises in designs like this quite often, so C++ offers a way to establish the important fact about our design &mdash; namely, that all shapes can calculate an area the same way &mdash; while leaving the implementation details to be filled in by derived classes.  We do this by declaring <b>area()</b> in the <b>Shape</b> class to be a <i>pure virtual function</i>, by using the rather bizarre-looking <b>= 0</b> notation at the end of its signature.  (You can read that as the word \"pure\" if it helps it to make more sense.)</p>\r\n\r\n<blockquote><pre>\r\nclass Shape\r\n{\r\npublic:\r\n    virtual double area() const = 0;\r\n};\r\n</pre></blockquote>\r\n\r\n<p>Doing this has two consequences:</p>\r\n\r\n<ul>\r\n  <li><b>Shape::area()</b> has no body.  It's not a function, but merely a placeholder for functions that will be defined in derived classes.</li>\r\n  <li><b>Shape</b>, by virtue of having at least one pure virtual function, is a class that has pieces missing.  It would be dangerous to have <b>Shape</b> objects, because you might call one of these missing functions on it, and the compiler wouldn't be able to prevent this from happening in all cases.  So as soon as a class has at least one pure virtual functions, it becomes a special kind of class called an <i>abstract base class</i>.  It is not possible to create objects of an abstract base class &mdash; to protect you from inadvertently calling a pure virtual function &mdash; but it <i>is</i> possible to have pointers or references of these types, which is what makes polymorphism possible.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>PureVirtual</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code PureVirtual</b> to download the code example into your project directory's <b>src</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"PureVirtual.tar.gz\">PureVirtual.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 178.0}