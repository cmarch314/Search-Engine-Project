{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 472D Conforming Triangulations and Meshes Laurent Rineau This package implements Shewchuk s algorithm She to construct conforming triangulations and 2D meshes Conforming triangulations will be described in Section and meshes in Section 47 1 Conforming Triangulations 47 1 1 Definitions A triangulation is a Delaunay triangulation if the circumscribing circle of any facet of the triangulation contains no vertex in its interior A constrained Delaunay triangulation is a constrained triangulation which is a much Delaunay as possible The circumscribing circle of any facet of a constrained Delaunay triangulation contains in its interior no data point visible from the facet An edge is said to be a Delaunay edge if it is inscribed in an empty circle containing no data point in its interior It is said to be a Gabriel edge if its diametrical circle is empty A constrained Delaunay triangulation is said to be a conforming Delaunay triangulation if every constrained edge is a Delaunay edge Because any edge in a constrained Delaunay triangulation is either a Delaunay edge or a constrained edge a conforming Delaunay triangulation is in fact a Delaunay triangulation The only difference is that some of the edges are marked as constrained edges A constrained Delaunay triangulation is said to be a conforming Gabriel triangulation if every constrained edge is a Gabriel edge The Gabriel property is stronger than the Delaunay property and each Gabriel edge is a Delaunay edge Thus conforming Gabriel triangulations are also conforming Delaunay triangulations Any constrained Delaunay triangulation can be refined into a conforming Delaunay triangulation or a conforming Gabriel triangulation by adding vertices called Steiner vertices on constrained edges until they are cut into subconstraints small enough to be Delaunay or Gabriel edges 47 1 2 Building Conforming Triangulations Constrained Delaunay triangulations can be refined into conforming triangulations by two global functions template class CDT void make conforming Delaunay 2 CDT t and template class CDT void make conforming Gabriel 2 CDT t In both cases the template parameter CDT must be instantiated by a constrained Delaunay triangulation class Such a class must be a model of the concept ConstrainedDelaunayTriangulation 2 There are some requirements on the geometric traits of the constrained Delaunay triangulation used to instantiate the parameter CDT It has to be a model of the concept ConformingDelaunayTriangulationTraits 2 The constrained Delaunay triangulation t is passed by reference and is refined into a conforming Delaunay triangulation or a conforming Gabriel triangulation by adding vertices that is the triangulation is modified If the user needs to keep the original triangulation he or she has to make a copy of it The algorithm used by make conforming Delaunay 2 and make conforming Gabriel 2 builds internal data that would be computed twice if the two functions are called consecutively on the same triangulation In order to avoid these data to be constructed twice the advanced user can use the class Triangulation conformer 2 CDT to refine a constrained Delaunay triangulation into a conforming Delaunay triangulation and then into a conforming Gabriel triangulation That class provides also step by step functions Those functions insert one point at a time 47 1 3 Example Making a Triangulation Conforming Delaunay and Then Conforming Gabriel This example inserts several segments into a constrained Delaunay triangulation makes it conforming Delaunay and then conforming Gabriel At each step the number of vertices of the triangulation is printed file examples Mesh 2 conforming C include CGAL Exact predicates inexact constructions kernel h include CGAL Constrained Delaunay triangulation 2 h include CGAL Triangulation conformer 2 h include iostream struct K public CGAL Exact predicates inexact constructions kernel typedef CGAL Constrained Delaunay triangulation 2 K CDT typedef CDT Point Point typedef CDT Vertex handle Vertex handle int main CDT cdt construct a constrained triangulation Vertex handle va cdt insert Point 5 5 vb cdt insert Point 5 5 vc cdt insert Point 4 3 vd cdt insert Point 5 5 ve cdt insert Point 6 6 vf cdt insert Point 6 6 vg cdt insert Point 6 6 vh cdt insert Point 6 6 cdt insert constraint va vb cdt insert constraint vb vc cdt insert constraint vc vd cdt insert constraint vd va cdt insert constraint ve vf cdt insert constraint vf vg cdt insert constraint vg vh cdt insert constraint vh ve std cout Number of vertices before cdt number of vertices std endl make it conforming Delaunay CGAL make conforming Delaunay 2 cdt std cout Number of vertices after make conforming Delaunay 2 cdt number of vertices std endl then make it conforming Gabriel CGAL make conforming Gabriel 2 cdt std cout Number of vertices after make conforming Gabriel 2 cdt number of vertices std endl See figures and Figure Initial triangulation Figure The corresponding conforming Delaunay triangulation Figure The corresponding conforming Gabriel triangulation 47 2 Meshes 47 2 1 Definitions A mesh is a partition of a given region into simplices whose shapes and sizes satisfy several criteria The domain is the region that the user wants to mesh It has to be a bounded region of the plane The domain is defined by a planar straight line graph PSLG for short which is a set of segments such that two segments in the set are either disjoint or share an endpoint The segments of the PSLG are constraints that will be represented by a union of edges in the mesh The PSLG can also contain isolated points that will appear as vertices of the mesh The segments of the PSLG are either segments of the boundary or internals constraints The segments of the PSLG have to cover the boundary of the domain The PSLG divides the plane into several connected components By default the domain is the union of the bounded connected components The user can override this default by providing a set of seed points Either seed points mark components to be meshed or they mark components not to be meshed holes See figures and for an example of a domain defined without using seed points and a possible mesh of it See figure for another domain defined with the same PSLG and two seed points The two seed points define two holes in the domain In the corresponding mesh figure these two holes are triangulated but not meshed Figure A domain defined without seed points Figure A mesh of the domain defined without seed points Figure A domain with two seeds points defining holes Figure A mesh of the domain with seeds defining holes 47 2 2 Shape and Size Criteria The shape criterion on triangles is a lower bound B on the ratio between the circumradius and the shortest edge length Such a bound implies a lower bound of arcsin 1 2B on the minimum angle of the triangle and an upper bound of 2 arcsin 1 2B on the maximum angle Unfortunately the termination of the algorithm is guaranteed only if B sqrt 2 which corresponds to a lower bound of 2 7 degrees on the angles The size criterion can be any criterion that tends to prefer small triangles For example the size criterion can be an upper bound on the length of longest edge of triangles or an upper bound on the radius of the circumcircle The size bound can be varying over the domain For example the size criterion could impose a small size for the triangles intersecting a given line Both types of criteria are defined in an object criteria passed as parameter of the meshing functions 47 2 3 The Meshing Algorithm The input to a meshing problem is a PSLG and a set of seeds describing the domain to be meshed and a set of size and shape criteria The algorithm implemented in this package starts with a constrained Delaunay triangulation of the input PSLG and produces a mesh using the Delaunay refinement method That method inserts points into the triangulation as far as possible from other points and stops when the criteria are satisfied If all angles between incident segments of the input PSLG are greater than 6 degrees and if the bound on the circumradius edge ratio is greater than sqrt 2 the algorithm is guaranteed to end up with a mesh satisfying the size and shape criteria If some input angles are smaller than 6 degrees the algorithm will end up with a mesh in which some triangles near small input angles violate the criteria This is unavoidable since small angles formed by input segments cannot be suppressed Furthermore it has been proven She that some domains with small input angles cannot be meshed with angles even smaller than the small input angles Note that if the domain is a polygonal region the resulting mesh will satisfy size and shape criteria except for the small input angles In addition the algorithm may succeed in producing meshes with a lower angle bound greater than 2 7 degrees but there is no such guarantee 47 2 4 Building Meshes Meshes are obtained from constrained Delaunay triangulations by calling the global function template class CDT class Criteria void refine Delaunay mesh 2 CDT t typename CDT Geom traits gt The template parameter CDT must be instantiated by a constrained Delaunay triangulation class that is a model of the concept ConstrainedDelaunayTriangulation 2 In order to override the domain a version of this function has two more arguments that define a sequence of seed points The geometric traits class of CDT has to be a model of the concept DelaunayMeshTraits 2 This concept refines the concept ConformingDelaunayTriangulationTraits 2 adding the geometric predicates and constructors The template parameter Criteria must be a model of MeshingCriteria 2 This concept defines criteria that the triangles have to satisfy CGAL provides several models for this concept such as Delaunay mesh criteria 2 K that defines a shape criterion that bounds the minimum angle of triangles Delaunay mesh size criteria K that adds to the previous one a bound on the maximum edge length If the function refine Delaunay mesh 2 is called several times on the same triangulation with different criteria the algorithm will rebuild used internal data at every call In order to avoid that the advanced user can use the class Delaunay mesher 2 CDT That class provides also step by step functions Those functions insert one point at a time Any object of type Delaunay mesher 2 CDT is constructed from a reference to a CDT and it has several member functions to define the domain to be meshed and to mesh the CDT See the example given below and the reference manual for details Note that the CDT should not be externally modified during the life time of the Delaunay mesher 2 CDT object 47 2 5 Example Using the Global Function The following example inserts several segments into a constrained triangulation and then meshes it using the global function refine Delaunay mesh 2 The size and shape criteria are the defaults provided by the criteria class Delaunay mesh criteria 2 K No seeds are given meaning that the mesh domain covers the whole plane except for the unbounded component file examples Mesh 2 mesh global C include CGAL Exact predicates inexact constructions kernel h include CGAL Constrained Delaunay triangulation 2 h include CGAL Delaunay mesher 2 h include CGAL Delaunay mesh face base 2 h include CGAL Delaunay mesh size criteria 2 h include iostream struct K public CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vb typedef CGAL Delaunay mesh face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb Tds typedef CGAL Constrained Delaunay triangulation 2 K Tds CDT typedef CGAL Delaunay mesh size criteria 2 CDT Criteria typedef CDT Vertex handle Vertex handle typedef CDT Point Point int main CDT cdt Vertex handle va cdt insert Point 4 Vertex handle vb cdt insert Point 1 Vertex handle vc cdt insert Point 4 Vertex handle vd cdt insert Point 1 cdt insert Point 2 6 cdt insert constraint va vb cdt insert constraint vb vc cdt insert constraint vc vd cdt insert constraint vd va std cout Number of vertices cdt number of vertices std endl std cout Meshing the triangulation std endl CGAL refine Delaunay mesh 2 cdt Criteria 125 5 std cout Number of vertices cdt number of vertices std endl 47 2 6 Example Using the Class Delaunay mesher 2 CDT This example uses the class Delaunay mesher 2 CDT and calls the refine mesh member function twice changing the size and shape criteria in between In such a case using twice the global function refine Delaunay mesh 2 would be less efficient because some internal structures needed by the algorithm would be built twice file examples Mesh 2 mesh class C include CGAL Exact predicates inexact constructions kernel h include CGAL Constrained Delaunay triangulation 2 h include CGAL Delaunay mesher 2 h include CGAL Delaunay mesh face base 2 h include CGAL Delaunay mesh size criteria 2 h include iostream struct K public CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vb typedef CGAL Delaunay mesh face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb Tds typedef CGAL Constrained Delaunay triangulation 2 K Tds CDT typedef CGAL Delaunay mesh size criteria 2 CDT Criteria typedef CGAL Delaunay mesher 2 CDT Criteria Mesher typedef CDT Vertex handle Vertex handle typedef CDT Point Point int main CDT cdt Vertex handle va cdt insert Point 4 Vertex handle vb cdt insert Point 1 Vertex handle vc cdt insert Point 4 Vertex handle vd cdt insert Point 1 cdt insert Point 2 6 cdt insert constraint va vb cdt insert constraint vb vc cdt insert constraint vc vd cdt insert constraint vd va std cout Number of vertices cdt number of vertices std endl std cout Meshing the triangulation with default criterias std endl Mesher mesher cdt mesher refine mesh std cout Number of vertices cdt number of vertices std endl std cout Meshing with new criterias std endl 125 is the default shape bound It corresponds to abound 2 6 degree 5 is the upper bound on the length of the longuest edge See reference manual for Delaunay mesh size traits 2 K mesher set criteria Criteria 125 5 mesher refine mesh std cout Number of vertices cdt number of vertices std endl 47 2 7 Example Using Seeds This example uses the global function refine Delaunay mesh 2 but defines a domain by using one seed The size and shape criteria are the defaults provided by the criteria class Delaunay mesh criteria 2 K file examples Mesh 2 mesh with seeds C include CGAL Exact predicates inexact constructions kernel h include CGAL Constrained Delaunay triangulation 2 h include CGAL Delaunay mesher 2 h include CGAL Delaunay mesh face base 2 h include CGAL Delaunay mesh size criteria 2 h include iostream struct K public CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vb typedef CGAL Delaunay mesh face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb Tds typedef CGAL Constrained Delaunay triangulation 2 K Tds CDT typedef CGAL Delaunay mesh size criteria 2 CDT Criteria typedef CDT Vertex handle Vertex handle typedef CDT Point Point int main CDT cdt Vertex handle va cdt insert Point 2 Vertex handle vb cdt insert Point 2 Vertex handle vc cdt insert Point 2 Vertex handle vd cdt insert Point 2 cdt insert constraint va vb cdt insert constraint vb vc cdt insert constraint vc vd cdt insert constraint vd va va cdt insert Point 3 3 vb cdt insert Point 3 3 vc cdt insert Point 3 3 vd cdt insert Point 3 3 cdt insert constraint va vb cdt insert constraint vb vc cdt insert constraint vc vd cdt insert constraint vd va std list Point list of seeds list of seeds push back Point std cout Number of vertices cdt number of vertices std endl std cout Meshing the domain std endl CGAL refine Delaunay mesh 2 cdt list of seeds begin list of seeds end Criteria std cout Number of vertices cdt number of vertices std endl Next chapter 2D Conforming Triangulations and Meshes Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Mesh_2/Chapter_mesh_2_user.html", "title": "2d conforming triangulations and meshes", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Mesh_2/mesh_2_user.tex' -->\n<html> <head>  \n<title>2D Conforming Triangulations and Meshes</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_mesh_2_user.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_47\"></a>\n  \n<h1>Chapter 47<BR>2D Conforming Triangulations and Meshes</h1>\n\n<A NAME=\"user_chapter_2D_Meshes\"></A>\n<P>\n\n<EM>Laurent Rineau</EM><BR>\n\n\n<P>\n\nThis package implements Shewchuk's algorithm [<A HREF=\"../biblio.html#Biblio_s-mgdsa-00\">She00</A>] to construct\nconforming triangulations and 2D meshes. Conforming triangulations will be\ndescribed in Section&nbsp;<A HREF=\"Chapter_mesh_2_user.html#sec:Mesh_2_conforming_triangulation\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and\nmeshes in Section&nbsp;<A HREF=\"Chapter_mesh_2_user.html#sec:Mesh_2_meshes\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>47.1&nbsp;&nbsp;&nbsp;Conforming Triangulations</h2>\n\n<A NAME=\"sec:Mesh_2_conforming_triangulation\"></A>\n<P>\n\n<h3>47.1.1&nbsp;&nbsp;&nbsp;Definitions</h3>\n\n<A NAME=\"sec:Mesh_2_conforming_definitions\"></A>\n<P>\n\nA triangulation is a <I>Delaunay triangulation</I> if the circumscribing\ncircle of any facet of the triangulation contains no vertex in its\ninterior. A <I>constrained</I> Delaunay triangulation is a constrained\ntriangulation which is a much Delaunay as possible. The circumscribing\ncircle of any facet of a constrained Delaunay triangulation contains in its\ninterior no data point <I>visible</I> from the facet.\n<P>\n\nAn edge is said to be a <I>Delaunay edge</I> if it is inscribed in an empty\ncircle (containing no data point in its interior). It is said to be a\n<I>Gabriel edge</I> if its diametrical circle is empty.\n<P>\n\nA constrained Delaunay triangulation is said to be a <I>conforming\n  Delaunay triangulation</I> if every constrained edge is a Delaunay edge.\nBecause any edge in a constrained Delaunay triangulation is either a\nDelaunay edge or a constrained edge, a conforming Delaunay triangulation is\nin fact a Delaunay triangulation. The only difference is that some of the\nedges are marked as constrained edges.\n<P>\n\nA constrained Delaunay triangulation is said to be a <I>conforming\n  Gabriel triangulation</I> if every constrained edge is a Gabriel edge. The\nGabriel property is stronger than the Delaunay property and each Gabriel\nedge is a Delaunay edge. Thus conforming Gabriel triangulations are also\nconforming Delaunay triangulations.\n<P>\n\nAny constrained Delaunay triangulation can be refined into a\nconforming Delaunay triangulation or a conforming Gabriel\ntriangulation by adding vertices, called <I>Steiner vertices</I>, on\nconstrained edges until they are cut into subconstraints small enough\nto be Delaunay or Gabriel edges.\n<P>\n\n<h3>47.1.2&nbsp;&nbsp;&nbsp;Building Conforming Triangulations</h3>\n\n<A NAME=\"sec:Mesh_2_building_conforming\"></A>\n<P>\n\nConstrained Delaunay triangulations can be refined into\nconforming triangulations \nby two global functions:<BR>\n\n<I>template&lt;class CDT&gt; void <A HREF=\"../Mesh_2_ref/Function_make_conforming_Delaunay_2.html#Cross_link_anchor_1105\">make_conforming_Delaunay_2</A> (CDT&amp; t)</I>&nbsp;and<BR>\n\n<I>template&lt;class CDT&gt; void <A HREF=\"../Mesh_2_ref/Function_make_conforming_Gabriel_2.html#Cross_link_anchor_1107\">make_conforming_Gabriel_2</A> (CDT&amp; t)</I>.\n<P>\n\nIn both cases, the template parameter <I>CDT</I> must be instantiated\nby a constrained Delaunay triangulation class.  Such a class must be a\nmodel of the concept <I>ConstrainedDelaunayTriangulation_2</I>.\n<P>\n\nThere are some requirements on the geometric traits of the constrained\nDelaunay triangulation used to instantiate the parameter <I>CDT</I>.\nIt has to be a model of the concept\n<I><A HREF=\"../Mesh_2_ref/Concept_ConformingDelaunayTriangulationTraits_2.html#Cross_link_anchor_1085\">ConformingDelaunayTriangulationTraits_2</A></I>.\n<P>\n\nThe constrained Delaunay triangulation <I>t</I> is passed by reference\nand is refined into a conforming Delaunay triangulation or a\nconforming Gabriel triangulation by adding vertices, that is, the\ntriangulation is modified. If the user needs to keep the original\ntriangulation, he or she has to make a copy of it.\n<P>\n\nThe algorithm used by <I><A HREF=\"../Mesh_2_ref/Function_make_conforming_Delaunay_2.html#Cross_link_anchor_1105\">make_conforming_Delaunay_2</A></I> and\n<I><A HREF=\"../Mesh_2_ref/Function_make_conforming_Gabriel_2.html#Cross_link_anchor_1107\">make_conforming_Gabriel_2</A></I> builds internal data that would be\ncomputed twice if the two functions are called consecutively on the same\ntriangulation. In order to avoid these data to be constructed twice, the\nadvanced user can use the class <I><A HREF=\"../Mesh_2_ref/Class_Triangulation_conformer_2.html#Cross_link_anchor_1090\">Triangulation_conformer_2</A>&lt;CDT&gt;</I> to\nrefine a constrained Delaunay triangulation into a conforming Delaunay\ntriangulation and then into a conforming Gabriel triangulation. That class\nprovides also step by step functions. Those functions insert one point at a\ntime.\n<P>\n\n<h3>47.1.3&nbsp;&nbsp;&nbsp;Example: Making a Triangulation Conforming Delaunay and Then\n  Conforming Gabriel</h3>\n\n<A NAME=\"sec:Mesh_2_example_making_conforming\"></A>\n<P>\n\nThis example inserts several segments into a constrained Delaunay\ntriangulation, makes it conforming Delaunay, and then conforming\nGabriel. At each step, the number of vertices of the triangulation is\nprinted.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Mesh_2/conforming.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Triangulation_conformer_2.html#Cross_link_anchor_1090\">Triangulation_conformer_2</A>.h&gt;\n\n#include &lt;iostream&gt;\n\nstruct K : public <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K&gt; CDT;\ntypedef CDT::Point Point;\ntypedef CDT::Vertex_handle Vertex_handle;\n\nint main()\n{\n  CDT cdt;\n\n  // construct a constrained triangulation\n  Vertex_handle \n    va = cdt.insert(Point( 5., 5.)),\n    vb = cdt.insert(Point(-5., 5.)),\n    vc = cdt.insert(Point( 4., 3.)),\n    vd = cdt.insert(Point( 5.,-5.)),\n    ve = cdt.insert(Point( 6., 6.)),\n    vf = cdt.insert(Point(-6., 6.)),\n    vg = cdt.insert(Point(-6.,-6.)),\n    vh = cdt.insert(Point( 6.,-6.));\n\n  cdt.insert_constraint(va,vb);\n  cdt.insert_constraint(vb,vc);\n  cdt.insert_constraint(vc,vd);\n  cdt.insert_constraint(vd,va);\n  cdt.insert_constraint(ve,vf);\n  cdt.insert_constraint(vf,vg);\n  cdt.insert_constraint(vg,vh);\n  cdt.insert_constraint(vh,ve);\n\n  std::cout &lt;&lt; &quot;Number of vertices before: &quot;\n            &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n\n  // make it conforming Delaunay\n  <A HREF=\"../Mesh_2_ref/Function_make_conforming_Delaunay_2.html#Cross_link_anchor_1104\">CGAL::make_conforming_Delaunay_2</A>(cdt);\n\n  std::cout &lt;&lt; &quot;Number of vertices after <A HREF=\"../Mesh_2_ref/Function_make_conforming_Delaunay_2.html#Cross_link_anchor_1105\">make_conforming_Delaunay_2</A>: &quot;\n            &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n\n  // then make it conforming Gabriel\n  <A HREF=\"../Mesh_2_ref/Function_make_conforming_Gabriel_2.html#Cross_link_anchor_1106\">CGAL::make_conforming_Gabriel_2</A>(cdt);\n\n  std::cout &lt;&lt; &quot;Number of vertices after <A HREF=\"../Mesh_2_ref/Function_make_conforming_Gabriel_2.html#Cross_link_anchor_1107\">make_conforming_Gabriel_2</A>: &quot;\n            &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n}\n</pre>\n<P>\n\nSee figures&nbsp;<A HREF=\"Chapter_mesh_2_user.html#Conform-example-conform\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>,\n<A HREF=\"Chapter_mesh_2_user.html#Conform-example-conform-Delaunay\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\nand&nbsp;<A HREF=\"Chapter_mesh_2_user.html#Conform-example-conform-Gabriel\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Initial triangulation.\n<A NAME=\"Conform-example-conform\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./example-conform.png\"\n     align=center title=\"Initial triangulation.\">\n</center>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The corresponding conforming Delaunay triangulation.\n<A NAME=\"Conform-example-conform-Delaunay\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./example-conform-Delaunay.png\"\n     align=center title=\"The corresponding conforming Delaunay triangulation.\">\n</center>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The corresponding conforming Gabriel triangulation.\n<A NAME=\"Conform-example-conform-Gabriel\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./example-conform-Gabriel.png\"\n     align=center title=\"The corresponding conforming Gabriel triangulation.\">\n</center>\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>47.2&nbsp;&nbsp;&nbsp;Meshes</h2>\n\n<A NAME=\"sec:Mesh_2_meshes\"></A>\n<P>\n\n<h3>47.2.1&nbsp;&nbsp;&nbsp;Definitions</h3>\n\n<A NAME=\"sec:Mesh_2_meshes_definition\"></A>\n<P>\n\nA mesh is a partition of a given region into simplices whose shapes\nand sizes satisfy several criteria.\n<P>\n\nThe domain is the region that the user wants to mesh. It has to be\n  a bounded region of the plane. The domain is defined by a <I>planar\n  straight line graph</I>, P<SMALL>SLG</SMALL> for short, which is a set of segments\n  such that two segments in the set are either disjoint or share an\n  endpoint. The segments of the P<SMALL>SLG</SMALL> are constraints that will be\n  represented by a union of edges in the mesh. The P<SMALL>SLG</SMALL> can also\n  contain isolated points that will appear as vertices of the mesh.\n<P>\n\nThe segments of the P<SMALL>SLG</SMALL> are either segments of the\nboundary or internals constraints. The segments of the P<SMALL>SLG</SMALL> have to\ncover the boundary of the domain.\n<P>\n\nThe P<SMALL>SLG</SMALL> divides the plane into several connected components. By\ndefault, the domain is the union of the bounded connected components. The\nuser can override this default by providing a set of seed points. Either\nseed points mark components to be meshed or they mark components not to be\nmeshed (holes).\n<P>\n\nSee figures&nbsp;<A HREF=\"Chapter_mesh_2_user.html#Domain\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and&nbsp;<A HREF=\"Chapter_mesh_2_user.html#Domain-mesh\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for an example of a domain\ndefined without using seed points, and a possible mesh of it. See\nfigure&nbsp;<A HREF=\"Chapter_mesh_2_user.html#Domain-seeds\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for another domain defined with the same P<SMALL>SLG</SMALL> and two seed points. The two seed points define two holes in the\ndomain. In the corresponding mesh (figure&nbsp;<A HREF=\"Chapter_mesh_2_user.html#Domain-seeds-mesh\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>), these\ntwo holes are triangulated but not meshed.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A domain defined without seed points.\n<A NAME=\"Domain\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./domain.png\"\n     align=center title=\"A domain defined without seed points.\">\n</center>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A mesh of the domain defined without seed points.\n<A NAME=\"Domain-mesh\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./domain-mesh.png\"\n     align=center title=\"A mesh of the domain defined without seed points.\">\n</center>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A domain with two seeds points defining holes.\n<A NAME=\"Domain-seeds\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./domain-seeds.png\"\n     align=center title=\"A domain with two seeds points defining holes.\">\n</center>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A mesh of the domain with seeds defining holes.\n<A NAME=\"Domain-seeds-mesh\"></A>\n<P>\n\n<center>\n<img border=0 src=\"./domain-seeds-mesh.png\"\n     align=center title=\"A mesh of the domain with seeds defining holes.\">\n</center>\n<P>\n\n<h3>47.2.2&nbsp;&nbsp;&nbsp;Shape and Size Criteria</h3>\n\n<A NAME=\"sec:Mesh_2_criteria\"></A>\n<P>\n\nThe shape criterion on triangles is a lower bound <MATH><I>B</I></MATH> on the ratio\nbetween the circumradius and the shortest edge length.  Such a bound\nimplies a lower bound of <MATH><I></I></MATH>arcsin<MATH><I>(1)/(2B)</I></MATH> on the minimum <A HREF=\"../Kernel_23_ref/Function_angle.html#Cross_link_anchor_153\">angle</A>\nof the triangle and an upper bound of <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\">- 2* </I></MATH>arcsin<MATH><I>(1)/(2B)</I></MATH>\non the maximum <A HREF=\"../Kernel_23_ref/Function_angle.html#Cross_link_anchor_153\">angle</A>.  Unfortunately, the termination of the algorithm\nis guaranteed only if <MATH><I>B  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(2)</I></MATH> which corresponds to a lower\nbound of <MATH><I>20.7</I></MATH>&nbsp;degrees on the angles.\n<P>\n\nThe size criterion can be any criterion that tends to prefer small\ntriangles. For example, the size criterion can be an upper bound on the\nlength of longest edge of triangles, or an upper bound on the radius of the\ncircumcircle. The size bound can be varying over the domain. For example,\nthe size criterion could impose a small size for the triangles intersecting\na given line.\n<P>\n\nBoth types of criteria are defined in an object <I>criteria</I> passed as\nparameter of the meshing functions.\n<P>\n\n<h3>47.2.3&nbsp;&nbsp;&nbsp;The Meshing Algorithm</h3>\n<P>\n\nThe input to a meshing problem is a P<SMALL>SLG</SMALL> and a set of seeds\ndescribing the domain to be meshed, and a set of size and shape\ncriteria.  The algorithm implemented in this package starts with a\nconstrained Delaunay triangulation of the input P<SMALL>SLG</SMALL> and produces a\nmesh using the Delaunay refinement method. That method inserts points into\nthe triangulation, as far as possible from other points, and stops when the\ncriteria are satisfied.\n<P>\n\nIf all angles between incident segments of the input P<SMALL>SLG</SMALL>\nare greater than <MATH><I>60</I></MATH>&nbsp;degrees and if the bound on the\ncircumradius/edge ratio is greater than <MATH><I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(2)</I></MATH>,\nthe algorithm is guaranteed to end up with a mesh\nsatisfying the size and shape criteria.\n<P>\n\nIf some input angles are smaller than <MATH><I>60</I></MATH>&nbsp;degrees, the algorithm will\nend up with a mesh in which some triangles near small input angles\nviolate the criteria.  This is unavoidable since small angles formed\nby input segments cannot be suppressed. Furthermore, it has been\nproven ([<A HREF=\"../biblio.html#Biblio_s-mgdsa-00\">She00</A>]), that some domains with small input angles\ncannot be meshed with angles even smaller than the small input angles.\nNote that if the domain is a polygonal region, the resulting mesh will\nsatisfy size and shape criteria except for the small input angles.\nIn addition, the algorithm may succeed in producing meshes with a lower\n<A HREF=\"../Kernel_23_ref/Function_angle.html#Cross_link_anchor_153\">angle</A> bound greater than <MATH><I>20.7</I></MATH>&nbsp;degrees, but there is no such guarantee.\n<P>\n\n<h3>47.2.4&nbsp;&nbsp;&nbsp;Building Meshes</h3>\n\n<A NAME=\"sec:Mesh_2_building_meshes\"></A>\n<P>\n\nMeshes are obtained from\nconstrained Delaunay triangulations by calling the global function<BR>\n\n<I>template&lt;class CDT, class Criteria&gt; void <A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1109\">refine_Delaunay_mesh_2</A> (CDT   &amp;t, typename CDT::Geom_traits gt)</I>.<BR>\n\nThe template parameter <I>CDT</I> must be instantiated by a constrained\nDelaunay triangulation class that is a model of the concept\n<I>ConstrainedDelaunayTriangulation_2</I>. In order to override the domain,\na version of this function has two more arguments that define a sequence of\nseed points.\n<P>\n\nThe geometric traits class of <I>CDT</I> has to be a\nmodel of the concept <I><A HREF=\"../Mesh_2_ref/Concept_DelaunayMeshTraits_2.html#Cross_link_anchor_1086\">DelaunayMeshTraits_2</A></I>.  This concept\nrefines the concept <I><A HREF=\"../Mesh_2_ref/Concept_ConformingDelaunayTriangulationTraits_2.html#Cross_link_anchor_1085\">ConformingDelaunayTriangulationTraits_2</A></I>\nadding the geometric predicates and constructors. The template parameter\n<I>Criteria</I> must be a model of <I><A HREF=\"../Mesh_2_ref/Concept_MeshingCriteria_2.html#Cross_link_anchor_1087\">MeshingCriteria_2</A></I>. This concept\ndefines criteria that the triangles have to satisfy.\nC<SMALL>GAL</SMALL> provides several models for this concept such as:\n<UL>\n<LI><I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_criteria_2.html#Cross_link_anchor_1094\">Delaunay_mesh_criteria_2</A>&lt;K&gt;</I>, that defines a shape criterion\n  that bounds the minimum <A HREF=\"../Kernel_23_ref/Function_angle.html#Cross_link_anchor_153\">angle</A> of triangles, \n<LI><I>Delaunay_mesh_size_criteria&lt;K&gt;</I>, that adds to the previous one a\n  bound on the maximum edge length.\n</UL>\n<P>\n\nIf the function <I><A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1109\">refine_Delaunay_mesh_2</A></I> is called several times on the\nsame triangulation with different criteria, the algorithm will rebuild used\ninternal data at every call. In order to avoid that, the advanced user can\nuse the class <I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>&lt;CDT&gt;</I>. That class provides also step\nby step functions. Those functions insert one point at a time.\n<P>\n\nAny object of type <I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>&lt;CDT&gt;</I> is constructed from a\nreference to a <I>CDT</I> and it has several member functions to define the\ndomain to be meshed and to mesh the <I>CDT</I>. See the example given below\nand the reference manual for details. Note that the <I>CDT</I> should not be\nexternally modified during the life time of the <I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>&lt;CDT&gt;</I>\nobject.\n<P>\n\n<h3>47.2.5&nbsp;&nbsp;&nbsp;Example Using the Global Function</h3>\n<P>\n\nThe following example inserts several segments into a constrained\ntriangulation and then meshes it using the global function\n<I><A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1109\">refine_Delaunay_mesh_2</A></I>. The size and shape criteria are the defaults\nprovided by the criteria class <I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_criteria_2.html#Cross_link_anchor_1094\">Delaunay_mesh_criteria_2</A>&lt;K&gt;</I>. No seeds are\ngiven, meaning that the mesh domain covers the whole plane except for the\nunbounded component.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Mesh_2/mesh_global.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_face_base_2.html#Cross_link_anchor_1098\">Delaunay_mesh_face_base_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_size_criteria_2.html#Cross_link_anchor_1096\">Delaunay_mesh_size_criteria_2</A>.h&gt;\n\n#include &lt;iostream&gt;\n\nstruct K : public <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt; Vb;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_face_base_2.html#Cross_link_anchor_1097\">CGAL::Delaunay_mesh_face_base_2</A>&lt;K&gt; Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb, Fb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K, Tds&gt; CDT;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_size_criteria_2.html#Cross_link_anchor_1095\">CGAL::Delaunay_mesh_size_criteria_2</A>&lt;CDT&gt; Criteria;\n\ntypedef CDT::Vertex_handle Vertex_handle;\ntypedef CDT::Point Point;\n\nint main()\n{\n  CDT cdt;\n\n  Vertex_handle va = cdt.insert(Point(-4,0));\n  Vertex_handle vb = cdt.insert(Point(0,-1));\n  Vertex_handle vc = cdt.insert(Point(4,0));\n  Vertex_handle vd = cdt.insert(Point(0,1));\n  cdt.insert(Point(2, 0.6));\n\n  cdt.insert_constraint(va, vb);\n  cdt.insert_constraint(vb, vc);\n  cdt.insert_constraint(vc, vd);\n  cdt.insert_constraint(vd, va);\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; &quot;Meshing the triangulation...&quot; &lt;&lt; std::endl;\n  <A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1108\">CGAL::refine_Delaunay_mesh_2</A>(cdt, Criteria(0.125, 0.5));\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n}\n</pre>\n<P>\n\n<h3>47.2.6&nbsp;&nbsp;&nbsp;Example Using the Class <I>Delaunay_mesher_2&lt;CDT&gt;</I></h3>\n<P>\n\nThis example uses the class <I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>&lt;CDT&gt;</I> and calls\n  the <I>refine_mesh()</I> member function twice changing the size and\n  shape criteria in between. In such a case, using twice the global\n  function <I><A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1109\">refine_Delaunay_mesh_2</A></I> would be less efficient,\n  because some internal structures needed by the algorithm would be\n  built twice.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Mesh_2/mesh_class.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_face_base_2.html#Cross_link_anchor_1098\">Delaunay_mesh_face_base_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_size_criteria_2.html#Cross_link_anchor_1096\">Delaunay_mesh_size_criteria_2</A>.h&gt;\n\n#include &lt;iostream&gt;\n\nstruct K : public <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt; Vb;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_face_base_2.html#Cross_link_anchor_1097\">CGAL::Delaunay_mesh_face_base_2</A>&lt;K&gt; Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb, Fb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K, Tds&gt; CDT;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_size_criteria_2.html#Cross_link_anchor_1095\">CGAL::Delaunay_mesh_size_criteria_2</A>&lt;CDT&gt; Criteria;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1091\">CGAL::Delaunay_mesher_2</A>&lt;CDT, Criteria&gt; Mesher;\n\ntypedef CDT::Vertex_handle Vertex_handle;\ntypedef CDT::Point Point;\n\nint main()\n{\n  CDT cdt;\n\n  Vertex_handle va = cdt.insert(Point(-4,0));\n  Vertex_handle vb = cdt.insert(Point(0,-1));\n  Vertex_handle vc = cdt.insert(Point(4,0));\n  Vertex_handle vd = cdt.insert(Point(0,1));\n  cdt.insert(Point(2, 0.6));\n\n  cdt.insert_constraint(va, vb);\n  cdt.insert_constraint(vb, vc);\n  cdt.insert_constraint(vc, vd);\n  cdt.insert_constraint(vd, va);\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; &quot;Meshing the triangulation with default criterias...&quot;\n            &lt;&lt; std::endl;\n\n  Mesher mesher(cdt);\n  mesher.refine_mesh();\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; &quot;Meshing with new criterias...&quot; &lt;&lt; std::endl;\n  // 0.125 is the default shape bound. It corresponds to abound 20.6 degree.\n  // 0.5 is the upper bound on the length of the longuest edge.\n  // See reference manual for Delaunay_mesh_size_traits_2&lt;K&gt;.\n  mesher.set_criteria(Criteria(0.125, 0.5));\n  mesher.refine_mesh();\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n}\n</pre>\n<P>\n\n<h3>47.2.7&nbsp;&nbsp;&nbsp;Example Using Seeds</h3>\n<P>\n\nThis example uses the global function <I><A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1109\">refine_Delaunay_mesh_2</A></I> but\ndefines a domain by using one seed. The size and shape criteria are the\ndefaults provided by the criteria class <I><A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_criteria_2.html#Cross_link_anchor_1094\">Delaunay_mesh_criteria_2</A>&lt;K&gt;</I>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Mesh_2/mesh_with_seeds.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesher_2.html#Cross_link_anchor_1092\">Delaunay_mesher_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_face_base_2.html#Cross_link_anchor_1098\">Delaunay_mesh_face_base_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_size_criteria_2.html#Cross_link_anchor_1096\">Delaunay_mesh_size_criteria_2</A>.h&gt;\n\n#include &lt;iostream&gt;\n\nstruct K : public <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt; Vb;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_face_base_2.html#Cross_link_anchor_1097\">CGAL::Delaunay_mesh_face_base_2</A>&lt;K&gt; Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb, Fb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K, Tds&gt; CDT;\ntypedef <A HREF=\"../Mesh_2_ref/Class_Delaunay_mesh_size_criteria_2.html#Cross_link_anchor_1095\">CGAL::Delaunay_mesh_size_criteria_2</A>&lt;CDT&gt; Criteria;\n\ntypedef CDT::Vertex_handle Vertex_handle;\ntypedef CDT::Point Point;\n\nint main()\n{\n  CDT cdt;\n  Vertex_handle va = cdt.insert(Point(2,0));\n  Vertex_handle vb = cdt.insert(Point(0,2));\n  Vertex_handle vc = cdt.insert(Point(-2,0));\n  Vertex_handle vd = cdt.insert(Point(0,-2));\n\n  cdt.insert_constraint(va, vb);\n  cdt.insert_constraint(vb, vc);\n  cdt.insert_constraint(vc, vd);\n  cdt.insert_constraint(vd, va);\n\n  va = cdt.insert(Point(3,3));\n  vb = cdt.insert(Point(-3,3));\n  vc = cdt.insert(Point(-3,-3));\n  vd = cdt.insert(Point(3,0-3));\n\n  cdt.insert_constraint(va, vb);\n  cdt.insert_constraint(vb, vc);\n  cdt.insert_constraint(vc, vd);\n  cdt.insert_constraint(vd, va);\n\n  std::list&lt;Point&gt; list_of_seeds;\n\n  list_of_seeds.push_back(Point(0, 0));\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; &quot;Meshing the domain...&quot; &lt;&lt; std::endl;\n  <A HREF=\"../Mesh_2_ref/Function_refine_Delaunay_mesh_2.html#Cross_link_anchor_1108\">CGAL::refine_Delaunay_mesh_2</A>(cdt, list_of_seeds.begin(), list_of_seeds.end(),\n                               Criteria());\n\n  std::cout &lt;&lt; &quot;Number of vertices: &quot; &lt;&lt; cdt.number_of_vertices() &lt;&lt; std::endl;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Mesh_2_ref/Chapter_intro.html\">2D Conforming Triangulations and Meshes</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_47!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39249.0}