{"text": "Event Handling The problem connecting user events to code execution User events mouse click mouse down mouse up mouse drag mouse within a component focus key pressed particular key pressed etc Solution 1 have controls listen to all events check whether they should respond and then respond Roughly this was the JDK 1 model Solution 2 Tell controls what events they can respond to and have them direct messages to appropriate actions methods within object This is the delegation model of JDK 1 1 and is more efficient Model user action source object control target object listener What we need to do is identify turn on controls that will respond to events For these controls connect them to appropriate listeners This is called registration Note multiple actions can take place for each event and these are not synchronized Also any object can be a listener if it implements the appropriate interface So what do we need to do To the control c execute c addSomeListener some obj This makes c respond to the event by sending a message to the object Make obj an event listener i e by declaring that it implement the appropriate Listener Interface defining the methods of the Interface Abstract Example Making object c of Foo respond to Button b Foo c new Foo Button b new Button clear b addActionListener c buttons generate action events ActionListener has only 1 method actionPerformed class Foo implements ActionListener public void actionPerformed whatever foo should do when button is pressed Four Designs This program allows the user to draw lines clear the screen and change colors import java applet import java awt import java awt event Design 1 Everyone talks to applet and gets messages from applet Applet acts as god class This is usually the simpliest design class MyCanvas extends Canvas Color linecolor Color black public void paint Graphics g Dimension d getSize g drawRect 2 2 d width 4 d height 4 public void clear Graphics g getGraphics Dimension d getSize Color c getBackground g setColor c g fillRect d width d height repaint repaint schedules update update typically calls paint public void changeColor Color colors Color red Color black Color blue Color magenta linecolor colors random colors length public int random int i return int Math floor Math random i public void drawLine Point p Point q Graphics g getGraphics g setColor linecolor g drawLine p x p y q x q y g drawOval q x q y 2 2 public void drawOval Point p Graphics g getGraphics g drawOval p x p y 2 2 public class MouseTest extends Applet implements ActionListener MouseListener Panel top Button clear Button change MyCanvas mycanvas Point begin end public void init top new Panel clear new Button Clear clear addActionListener this change new Button Change Color change addActionListener this top add new Label Mouse click to draw lines top add clear top add change setLayout new BorderLayout add top North mycanvas new MyCanvas mycanvas addMouseListener this add mycanvas Center public void actionPerformed ActionEvent actevt Object arg actevt getSource if arg clear mycanvas clear else if arg change mycanvas changeColor public void mousePressed MouseEvent me begin me getPoint mycanvas drawOval begin public void mouseReleased MouseEvent me end me getPoint mycanvas drawLine begin end public void mouseClicked MouseEvent me public void mouseEntered MouseEvent me public void mouseExited MouseEvent me In the next design we group related activities more finely The code is longer but may allow easier changes Code is simpliest when its structure reflects the organization of the computation import java applet import java awt import java awt event class MyCanvas extends Canvas Color linecolor Color black public void paint Graphics g why doesn t this work Dimension d getSize g drawRect 2 2 d width 4 d height 4 public void clear Graphics g getGraphics Dimension d getSize Color c getBackground g setColor c g fillRect d width d height repaint public void changeColor Color colors Color red Color black Color blue Color magenta linecolor colors random colors length public int random int i return int Math floor Math random i public void drawLine Point p Point q Graphics g getGraphics g setColor linecolor g drawLine p x p y q x q y g drawOval q x q y 2 2 public void drawOval Point p Graphics g getGraphics g drawOval p x p y 2 2 class ClearButton extends Button ClearButton MouseTest mt super Clear addActionListener mt class ChangeButton extends Button ChangeButton MouseTest mt super Change Color addActionListener mt public class MouseTest extends Applet implements ActionListener MouseListener Panel top ClearButton clear ChangeButton change MyCanvas mycanvas Point begin end public void init top new Panel clear new ClearButton this change new ChangeButton this top add new Label Mouse click to draw lines top add clear top add change setLayout new BorderLayout add top North mycanvas new MyCanvas mycanvas addMouseListener this add mycanvas Center public void actionPerformed ActionEvent actevt Object arg actevt getSource if arg clear mycanvas clear else if arg change mycanvas changeColor public void mousePressed MouseEvent me begin me getPoint mycanvas drawOval begin public void mouseReleased MouseEvent me end me getPoint mycanvas drawLine begin end public void mouseClicked MouseEvent me public void mouseEntered MouseEvent me public void mouseExited MouseEvent me In this design we examine the interactions between the events import java applet import java awt import java awt event Design 2 here we analyze the objects and see where message are going The Listener for the message must be able to see the object generating the message Message Diagram clearbutton canvas changebutton canvas canvas mouse clicks canvas So the buttons will still need to be mediated by the applet while the canvas can talk to itself class MyCanvas extends Canvas implements MouseListener Color linecolor Color black ugh Point begin end public void paint Graphics g Dimension d getSize g drawRect 2 2 d width 4 d height 4 public void clear Graphics g getGraphics Dimension d getSize Color c getBackground g setColor c g fillRect d width d height repaint public void changeColor Color colors Color red Color black Color blue Color magenta Color green linecolor colors random colors length public int random int i return int Math floor Math random i public void drawLine Point p Point q Graphics g getGraphics g setColor linecolor g drawLine p x p y q x q y g drawOval q x q y 2 2 public void drawOval Point p Graphics g getGraphics g drawOval p x p y 2 2 public void mousePressed MouseEvent me begin me getPoint drawOval begin public void mouseReleased MouseEvent me end me getPoint drawLine begin end public void mouseClicked MouseEvent me public void mouseEntered MouseEvent me public void mouseExited MouseEvent me public class MouseTest extends Applet implements ActionListener Panel top Button clear Button change MyCanvas mycanvas public void init mycanvas new MyCanvas top new Panel clear new Button Clear clear addActionListener this change new Button Change Color change addActionListener this top add new Label Mouse click to draw lines top add clear top add change setLayout new BorderLayout add top North mycanvas addMouseListener mycanvas add mycanvas Center public void actionPerformed ActionEvent actevt Object arg actevt getSource if arg clear mycanvas clear else if arg change mycanvas changeColor Example redone with Inner Classes Inner classes are a recent addition to Java Each inner class is local to the class but has access to all the members of the class Inner classes seem to violate the principle of information hiding Inner classes are not the same as nested classes in C import java applet import java awt import java awt event Version using inner classes Arguable bad style public class MouseTest extends Applet Panel top Button clear Button change MyCanvas mycanvas public void init mycanvas new MyCanvas top new Panel clear new Button clear clear addActionListener mycanvas change new Button Change Color change addActionListener mycanvas top add new Label Mouse click to draw lines top add clear top add change setLayout new BorderLayout add top North mycanvas addMouseListener mycanvas add mycanvas Center class MyCanvas extends Canvas implements MouseListener ActionListener note inner class Color linecolor Color black Point begin end public void paint Graphics g Dimension d getSize g drawRect 2 2 d width 4 d height 4 public void clear Graphics g getGraphics Dimension d getSize Color c getBackground g setColor c g fillRect d width d height repaint public void changeColor Color colors Color red Color black Color blue Color magenta Color green linecolor colors random colors length public int random int i return int Math floor Math random i public void drawLine Point p Point q Graphics g getGraphics g setColor linecolor g drawLine p x p y q x q y g drawOval q x q y 2 2 public void drawOval Point p Graphics g getGraphics g drawOval p x p y 2 2 public void mousePressed MouseEvent me begin me getPoint drawOval begin public void mouseReleased MouseEvent me end me getPoint drawLine begin end public void mouseClicked MouseEvent me public void mouseEntered MouseEvent me public void mouseExited MouseEvent me public void actionPerformed ActionEvent actevt Object arg actevt getSource if arg clear clear else if arg change changeColor Event processing in review Event sources controls are objects that respond to user actions Examples are buttons scrollbars etc An event source sends a message to an event listener Any object can be an event listener if it implements the appropriate interface Several objects may respond to the same event but there is no stipulation about which will respond first Currently there are 11 types of event listeners Event sources registers its event listeners via the method add Listener e g addActionListener this Recipe for making object2 responds to events in object1 add to object1 source add Listener object2 The corresponds to the type of event object1 can respond to make object2 a Listener i e say implements Listener add the methods designated by Listener Or extend an Adapter for the Listener Some of these complications occur because Java does not support full multiple inheritance Controls Listeners and interface method Control Registers Interest Receives Event Button addActionListener actionPerformed List MenuItem TextField Checkbox addItemListener itemStateChanged Choice List CheckBoxMenuItem Dialog Frame addWindowListener windowClosing windowOpening windowIconified windowDeiconified windowClosed windowActivated windowDeactivated Dialog Frame addComponentListener componentMoved componentHidden componentResized componentShown ScrollBar addAdjustmentListener adjustmentValueChanged Canvas addMouseListener mousePressed Dialog mouseReleased Frame mouseEntered Panel mouseExited Window mouseClicked Canvas addMouseMotionListener mouseDragged Dialog mouseMoved Frame Panel Window Component addKeyListener keyPressed keyReleased keyTyped Component addFocusListener focusGained focusLost TextComponent addTextListener textValueChanged Table Use The first column names the control The second column tells how to awaken control on a particular event and who to send the message to when the event takes place The third column tells what method s needs to implemented by the object which is responded to the message Focus is the component that can accept user input ", "_id": "http://www.ics.uci.edu/~kibler/javacourse/event.html", "title": "  event handing ", "html": "<html>\n<head>\n<title>  Event Handing </title>\n</head>\n\n<h1> Event Handling </h1>\n<h2>The problem: connecting user events to code execution.</h2>\n<P> User events: mouse click, mouse down, mouse up, mouse drag, mouse\nwithin a component (focus), key pressed, particular key pressed, etc.\n<p> Solution 1: have controls listen to all events, check whether\n they should respond, and then respond. Roughly this was the\n JDK 1.0 model.\n<p> Solution 2: Tell controls what events they can respond to\nand have them direct messages to appropriate actions (methods within\nobject) . This is the \"delegation\" model of JDK 1.1 and is more efficient.\n<p> Model: <br>\n     user action --> source object (control) ----> target object (listener)\n<p> What we need to do is:\n <ol>\n  <li> identify (turn on) controls that will respond to events\n  <li> For these controls, connect them to appropriate listeners. \n      This is called registration. Note multiple actions can take place\n   for each event, and these are not synchronized. Also any object\n   can be a listener if it implements the appropriate interface.\n </ol>\n<p> So what do we need to do?\n   <ol>\n   <li> To the control c, execute  c.addSomeListener(some obj).\n <p> This makes c respond to the event by sending a message to the object.\n  <li> Make obj an event listener, i.e. by\n      <ol>\n       <li> declaring that it implement the appropriate Listener Interface\n       <li> defining the methods of the Interface.\n      </ol>\n</ol>\n</ul>\n<h3>Abstract Example: Making object c of  Foo  respond to Button b; </h3>\n\n<pre>\n      Foo c = new Foo();\n      Button b = new Button(\"clear\");\n      b.addActionListener(c);       //.. buttons generate action events\n     ...\n      // ActionListener has only 1 method, actionPerformed\n     ..\n      class Foo implements ActionListener\n\n   {\n    ...\n        public void  actionPerformed()\n     {\n        whatever foo should do when button is pressed\n     }\n    ...\n   }\n</pre>\n\n<h3> Four Designs </h3>\n\n<br> This program allows the user to draw lines, clear the screen, and\n change colors. \n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n// Design 1:  Everyone talks to applet and gets messages from applet.\n//   Applet acts as god class.  This is usually the simpliest design.\n\n\nclass MyCanvas extends Canvas\n{\n  Color linecolor= Color.black;  \n\n  public void paint(Graphics g)  \n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n   //.. repaint() schedules update(). update() (typically) calls paint().\n }\n\n  public void changeColor()\n {\n   Color[] colors ={Color.red,Color.black,Color.blue,Color.magenta};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n\n}\n\npublic class MouseTest extends Applet\n  implements ActionListener, MouseListener\n{\n  Panel top;\n  Button clear;\n  Button change;\n  MyCanvas mycanvas;\n  Point begin,end;\n\n  public void init()\n {\n   top = new Panel();\n   clear = new Button(\"Clear\");\n   clear.addActionListener(this);\n   change = new Button(\"Change Color\");\n   change.addActionListener(this);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas = new MyCanvas();\n   mycanvas.addMouseListener(this);\n   add(mycanvas,\"Center\");\n }\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear ) mycanvas.clear();\n    else if (arg == change) mycanvas.changeColor();\n }\n\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    mycanvas.drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n     mycanvas.drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n}\n</pre>\n\nIn the next design we group related activities more finely.\nThe code is longer, but may allow easier changes.\nCode is simpliest when its structure reflects\nthe organization of the computation. \n\n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n\nclass MyCanvas extends Canvas\n{\n  Color linecolor= Color.black;  \n\n\n  public void paint(Graphics g)  // why doesn't this work?\n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n }\n\n  public void changeColor()\n {\n   Color[] colors ={Color.red,Color.black,Color.blue,Color.magenta};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n\n}\n\nclass ClearButton extends Button\n{\n   ClearButton(MouseTest mt)\n  {\n    super(\"Clear\");\n    addActionListener(mt);\n  }\n\n}\nclass ChangeButton extends Button\n{\n   ChangeButton(MouseTest mt)\n  {\n   super(\"Change Color\");\n   addActionListener(mt);\n  }\n}\n\n\n\npublic class MouseTest extends Applet\n  implements ActionListener, MouseListener\n{\n  Panel top;\n  ClearButton clear;\n  ChangeButton change;\n  MyCanvas mycanvas;\n  Point begin,end;\n\n  public void init()\n {\n   top = new Panel();\n   clear = new ClearButton(this);\n   change = new ChangeButton(this);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas = new MyCanvas();\n   mycanvas.addMouseListener(this);\n   add(mycanvas,\"Center\");\n}\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear ) mycanvas.clear();\n    else if (arg == change) mycanvas.changeColor();\n }\n\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    mycanvas.drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n     mycanvas.drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n}\n\n</pre>\n\nIn this design we examine the interactions between the events.\n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n/* Design 2: here we analyze the objects and see where message are going\n The  Listener for the message must be able to see the object generating\n the message. \nMessage Diagram:\n                 clearbutton --> canvas  \n                  changebutton --> canvas\n                  canvas -->(mouse clicks) -->canvas\nSo the buttons will still need to be mediated by the applet, while\nthe canvas can talk to itself.\n*/\t\t  \n\n\nclass MyCanvas extends Canvas\n     implements  MouseListener\n{\n  Color linecolor= Color.black;  //ugh\n  Point begin,end;\n\n\n\n  public void paint(Graphics g)  \n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n }\n\n  public void changeColor()\n {\n   Color[] colors =\n            {Color.red,Color.black,Color.blue,Color.magenta,Color.green};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n    drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n\n}\n\n\npublic class MouseTest extends Applet\n  implements ActionListener\n{\n  Panel top;\n  Button clear;\n  Button change;\n  MyCanvas mycanvas;\n\n\n  public void init()\n {\n   mycanvas = new MyCanvas();  \n   top = new Panel();\n   clear = new Button(\"Clear\");\n   clear.addActionListener(this);\n   change = new Button(\"Change Color\");\n   change.addActionListener(this);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas.addMouseListener(mycanvas);\n   add(mycanvas,\"Center\");\n }\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear) mycanvas.clear();\n    else if (arg == change) mycanvas.changeColor();\n }\n}\n\n\n\n</pre>\n<h3> Example redone with Inner Classes </h3>\n Inner classes are a recent addition to Java.\n<br> Each inner class is local to the class but has access to all\n   the members of the class.\n<br> Inner classes seem to violate the principle of information hiding.\n<br> Inner classes are not the same as nested classes in C++.\n\n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n// Version using inner classes. Arguable bad style.\n\npublic class MouseTest extends Applet\n \n{\n  Panel top;\n  Button clear;\n  Button change;\n  MyCanvas mycanvas;\n\n  public void init()\n {\n   mycanvas = new MyCanvas();  \n   top = new Panel();\n   clear = new Button(\"clear\");\n   clear.addActionListener(mycanvas);\n   change = new Button(\"Change Color\");\n   change.addActionListener(mycanvas);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas.addMouseListener(mycanvas);\n   add(mycanvas,\"Center\");\n }\n\n\nclass MyCanvas extends Canvas\n     implements  MouseListener, ActionListener //.. note: inner class\n{\n  Color linecolor= Color.black; \n  Point begin,end;\n\n\n  public void paint(Graphics g)\n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n }\n\n  public void changeColor()\n {\n   Color[] colors =\n            {Color.red,Color.black,Color.blue,Color.magenta,Color.green};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n    drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear) clear();\n    else if (arg == change) changeColor();\n }\n}\n}\n\n</pre>\n\n<h3> Event processing, in review </h3>\n\n <ul>\n  <li> Event sources (controls) are objects that respond to user actions\n  Examples are buttons, scrollbars etc.\n  <li> An event source sends a message to an event listener.\n  <li> Any object can be an event listener, if it implements the\n   appropriate interface.\n  <li> Several objects may respond to the same event,\n   but there is no stipulation about  which will respond first.\n  <li> Currently there are 11 types of event listeners.\n  <li> Event sources registers its event listeners, via\n   the method add...Listener(..), e.g. addActionListener(this).\n </ul>\n<h3> Recipe for making object2 responds to events in object1 </h3>\n  <ul>\n   <li> add to object1 (source)  add...Listener(object2).\n      The ... corresponds to the type of event object1 can respond to.\n   <li> make object2 a Listener, i.e. say\n      <ul>\n         <li> implements ...Listener\n         <li> add the methods designated by ...Listener\n         <li> Or, extend an Adapter for the Listener\n      </ul>\n    <li> Some of these complications occur because Java does\n   not support full multiple inheritance.\n  </ul>\n\n<h3> Controls, Listeners, and interface method </h3> \n\n<table border>\n<tr>\n <td> <b> Control</b> </td>\n <td> <b>Registers Interest </b>  </td>\n <td> <b> Receives Event </b></td>\n</tr>\n<hr>\n<tr>\n <td>  Button </td>\n <td rowspan=4> addActionListener(..) </td>\n <td rowspan=4> actionPerformed </td>\n</tr>\n<tr> <td> List </td> </tr>\n<tr> <td> MenuItem </td> </tr>\n<tr> <td> TextField </td> </tr>\n<tr> \n <td> Checkbox </td>\n <td rowspan=4> addItemListener </td>\n <td rowspan=4> itemStateChanged </td>\n</tr>\n<tr>  <td> Choice </td> </tr>\n<tr>   <td> List </td> </tr>\n<tr> <td> CheckBoxMenuItem </td> </tr>\n<tr>\n  <td rowspan=7> Dialog Frame </td> \n  <td rowspan=7> addWindowListener </td>\n  <td> windowClosing </td>\n</tr>\n<tr> <td> windowOpening </td> </tr>\n<tr> <td> windowIconified </td> </tr>\n<tr> <td> windowDeiconified </td> </tr>\n<tr> <td> windowClosed </td> </tr>\n<tr> <td> windowActivated </td> </tr>\n<tr> <td> windowDeactivated </td> </tr>\n<tr>\n  <td rowspan=4> Dialog Frame </td> \n  <td rowspan=4> addComponentListener </td>\n  <td>componentMoved </td>\n</tr>\n<tr><td> componentHidden </td></tr>\n<tr><td> componentResized </td></tr>\n<tr><td> componentShown </td></tr>\n<tr>\n  <td> ScrollBar </td> \n  <td > addAdjustmentListener </td>\n  <td> adjustmentValueChanged </td>\n</tr>\n<tr>\n  <td> Canvas </td> \n  <td rowspan=5 > addMouseListener </td>\n  <td> mousePressed</td>\n</tr>\n<tr><td> Dialog </td> <td> mouseReleased </td> </tr>\n<tr><td> Frame </td> <td> mouseEntered </td> </tr>\n<tr><td> Panel </td> <td> mouseExited </td> </tr>\n<tr><td> Window </td> <td> mouseClicked </td> </tr>\n\n<tr>\n  <td> Canvas </td> \n  <td rowspan=5 > addMouseMotionListener </td>\n  <td> mouseDragged</td>\n</tr>\n<tr> <td> Dialog </td> <td rowspan=4> mouseMoved</td></tr>\n<tr> <td> Frame </td></tr>\n<tr> <td> Panel </td></tr>\n<tr> <td> Window </td></tr>\n\n<tr>\n  <td rowspan=3> Component </td> \n  <td  rowspan=3> addKeyListener </td>\n  <td> keyPressed</td>\n<tr> <td> keyReleased </td></tr>\n<tr> <td> keyTyped </td></tr>\n</tr>\n<tr>\n  <td rowspan=2> Component </td> \n  <td rowspan=2 > addFocusListener </td>\n  <td> focusGained</td>\n<tr> <td> focusLost </td></tr>\n</tr>\n<tr>\n  <td> TextComponent </td> \n  <td > addTextListener </td>\n  <td> textValueChanged</td>\n</tr>\n\n\n\n\n</table>\n\n<h3> Table Use </h3>\nThe  first column names the control.\n<br> The second column tells how to awaken control on\n  a particular event and who to send the message to when\n  the event takes place.\n<br> The third column tells what method(s) needs to implemented\n  by the object which is responded to the message.\n<br> Focus is the component that can accept user input.", "id": 1996.0}