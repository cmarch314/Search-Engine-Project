{"text": "Program 4 Checking Annotations ICS 33 Intermediate Programming Introduction This programming assignment is designed to show how we can get Python to check function annotations whenever annotated functions are called For each of Python s built in data types we will develop an interpretation and write code to check that interpretation of how the data type specifies type information that is checkable when a function is called For example we specified the main dict for the NDFA in Programming Assignment 1 by the notation dict str dict str set str Recall the outer dict associates a str state key with a value that is an inner dict and the inner dict associates a str transition with a value that is a set of str states In our annotation checker we will use an alternative notation to specify this type information equivalently and compactly str str str Note that this is an actual data structure in Python where str is a reference to the string class object It is an outer dict whose single key is str and whose associated value is an inner dict whose single key is a str and whose value is a set that contains just element str We will write the Check Annotation class and use it as a decorator for functions whose annotations we want to check each time the function is called Internally it will overload the call method to call the function only after checking its annotation by using mutual recursion not direct recursion in a natural way to process the nesting of data types inside data types illustrated in the notation above We will write code that ensures that this checking works for the standard classes defined in Python The code will also know how to process a special annotation checking protocol via the check annotation method that we can implement in any new classes that we write so that that class can become part of the annotation language I have done this for two classes you can do it for the Bag class for extra credit I suggest that you look at the code in the modules that appear in the project folder that you will download Then see the detailed instructions in this document we can add test debug capabilities for each of the built in data types we can use in the annotation language iteratively enhancing our code until we can use all the built in data types in annotations Once we do this for list about a dozen lines the biggest of my checking functions all the others are variants and therefore much easier to write but still with some interesting details Download the program4 project folder and use it to create an Eclipse project We can test our class put it in the checkannotation py module which already includes some useful code at the end of the class itself or in a special driver that is included which uses a batch file to test progressively more and more complex data types in the annotation language It is recommend that you work on this assignment in pairs with someone in your lab section Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early Only one student should submit all parts of the the assignment but both students UICnetID and name should appear in a comment at the top of each submitted py file A special grading program reads this information The format is a comment starting with Submitter and Partner when working with a partner followed by a colon followed by the student s UCInetID in all lower case followed by the student s name in parentheses last name comma first name capitalized appropriately If you omit this information or do not follow this exact form it will require extra work for us to grade your program so we will deduct points Note if you are submitting by yourself and do NOT have a partner you should OMIT the partner line For example if Romeo Montague whose UCInetID is romeo1 submitted a program that he worked on with his partner Juliet Capulet whose UCInetID is jcapulet the comment at the top of each py file would appear as Submitter romeo1 Montague Romeo Partner jcapulet Capulet Juliet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can more accurately assess the progress of the class as a whole during this assignment The different parts of this assignment will be worth different amounts of points You can implement each part independently so concentrate on the higher point targets first In total the assignment is worth 6 points Here is the breakdown and some commentary Most important stuff useful for writing later code 45 6 pts 75 5 annot is None simple code 15 annot is type important simple code 15 annot is list important interesting code for modeling later annotations 1 annot is dict important much like list part simpler part more complex Useful stuff all similar to list set frozenset are simpler 9 6 pts 15 3 annot is tuple 3 annot is set 3 annot is frozenset Different requires dealing with exceptions in a special way 6 6 1 3 annot is lambda 3 annot is a class whose check annotation method is called test by using Check All OK Check Any OK Extra credit 1 annot is str code is not terribly complex but is intricate a bit strange rewriting bag to implement the check annotation protocol see Check All OK Check Any OK So you can still get an C 75 by doing the first 4 an A 9 by doing the next 3 To get 1 requires doing all 9 Notice that the batch self check file tests all these in the general order stated above except it checks tuples before dicts Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files The code you write should be as compact and elegant as possible using appropriate Python idioms Problem 1 Check Annotation Problem Summary Write a class named Check Annotation that decorates a function such that when the decorated function is called the decorator class check s the decorated function s annotation using the annotation language described below in detail We can use this decorator by writing either def f params annotation result annotation f Check Annotation f or Check Annotation def f params annotation result annotation which is a special Python syntactic form that expands to the former assignment Thus when the decorated f is called Python calls Check Annotations call in the decorator which first checks the annotations and raises an exception if it is not met and second computes returns the decorated function f the original one written This class defines four major attributes the checking on instance name to turn off on annotation checking in all decorated functions it starts on the init method to remember the function being decorated and initialize a per function name that helps controls annotation checking it also starts on for a function call to check its annotation both checking on and its per function name must be True if either is False the annotation is not checked the call method that intercepts each call to the decorated function and decides whether to check the annotation and if so implements annotation checking both for parameters and returned results if they are specified if annotation checking succeeds this method computes returns the result of calling the decorated function the check method specified in more detail below that does the annotation checking it either succeeds silently or raises an AssertionError exception with useful information specified in the details below Note that the unconditional assertion assert False message is a simple way to raise AssertionError with a message I wrote many nested helper functions in check one for each data type annotation that can be checked e g check dict Details Let s explore the meaning of the call and check methods in more detail The call method intercepts calls to the decorated function it specifies args and kargs to handle all calls regardless of their parameter structure My method was about 4 lines but about 17 lines were comments blank and 7 comprise the param arg binding local function supplied in the download this function computes an ordereddict of the parameter names each associated to its argument in the order that the parameters are defined in the function The call method determines whether to check the annotations see above if not just call the decorated function and return its result determines the parameters of the function and the matching arguments they are bound to The param arg bindings function written locally in this method returns an ordered dictionary of parameter value bindings ordered means that when iterated keys always appear in the same order the order the parameters appear in in the function s definition It uses the various attributes in the inspect module to do the job You might be interested in reading the documentation for the inspect module it is quite interesting and many of its powerful features are new to Python determines the annotations of the parameters by using the annotations attribute of any function object This name is bound to a dictionary containing as keys every annotated parameter name the associated value for each parameter name is its annotation If we defined the function f using def f x int y z int str its annotations dictionary is x class int z class int return class str Notice that parameter y has no annotation so it does not appear as a key in this dictionary and the key return is associated with the annotation for the returned value after the If any checked annotations parameters or returned result raise the AssertionError handle it by printing the relevant source lines for the function see the getsourcelines function in the inspect module s documentation and reraise the exception skipping the rest of the code in this method Checks every parameter that has an annotation Call the decorated function to compute its returned result and save it If return is in the dictionary of annotions a add the result as the value associated with the key return in the dictionary of parameter and argument bindings b check the annotation for return Return the result The check method has the following header def check self param annot value check history where self is an instance of the Check Annotation class param is a string that specifies the name of the parameter being checked or return for checking the returned value annot is a data structure that specifies the annotation value is the value of param that the annotation should be checked against to ensure it is legal check history is a string that embodies the history of checking the annotation for the parameter to here it is extended by concatenation in each recursive call to provide context for any annotation violations to be checked later it is printed after the details of any annotation violation to suppy context for the failure Each call to check decodes the annot to check and checks it against the value check s body is one big if elif else determining which local function to call to check the specific annotation and letting that local function do the real work Most annotations are checked by calling a function defined locally in check that can use the parameters of check freely because these functions are defined in check s local scope in fact these local functions are often parameterless many get all the information they need from check s parameters The more complicated local functions also call check so check calls a local function which can call check this is indirect recursion My method was about 1 lines about 13 lines were comments blank and 6 more appeared in 5 locally declared functions including one to solve the extra credit part of this assignment so I had about a dozen lines per local function The annotation checking language comprises the following components for Python s built in types I strongly suggest writing testing each component before moving on to the next all are similar and understanding testing debugging list the first really interesting one will supply tremendous insight for writing all Write the required exception messages exactly to match the ones shown annot is None do nothing succeed silently note that def f x has no annotation to check for its parameter x but def f x None has an annotation to check for x but it never fails None has more interesting uses inside more complicated data types illustrated below see the last example for list annot is any type e g type annot is type fail if value is not an instance of the specified type with an exception messages matching the following examples The isinstance function covered in the inheritance lectures generalizes checking the type of an object Instead of writing type x is someclass we write isinstance x someclass it checks whether x s object is constructed from someclass or any base class of someclass which is the correct test to perform here For def f x int called as f abc or f x abc the exception message would be AssertionError x failed annotation check wrong type value abc was type str should be type int For def f x list called as f 1 2 the exception message would be AssertionError x failed annotation check wrong type value 1 2 was type set should be type list All exception messages described in the sections below follow this same general format although the more complicated ones supply extra context via the check history parameter annot is a list not the list class object but an instance of list a real list of one or more values see the examples below where each element in list is an annotation Fail if value is not a list annot has just one element annotation and any of the elements in the value list fails the element annotation check annot has more than one element annotation and the annot and value lists have a different number of elements or any element in the value list fails its corresponding element annotation check Here are some examples of failures For def f x int called as f 1 2 the exception message would be AssertionError x failed annotation check wrong type value 1 2 was type set should be type list For def f x int called as f 1 a the exception message would be AssertionError x failed annotation check wrong type value a was type str should be type int list 1 check ltclass int Note that when each element in the list is tested it appends the index it is checking and the annotation it is checking to the check history which prints after the actual annotation that fails here the line starting list 1 check it means the element at index did not fail this annotation but the element at index 1 did For def f x int str called as f 1 the exception message would be AssertionError x failed annotation check wrong number of elements value 1 annotation had 2 elements ltclass int ltclass str For def f x int str called as f 1 2 the exception message would be AssertionError x failed annotation check wrong type value 2 was type int should be type str list 1 check ltclass str Note that the annotation def f x list and the annotation def f x None have the same meaning but the former is faster to check the first checks only that x is an instance of list the second checks that x is an instance of list and then checks each of its values agains the annotation None which according to that rule s annotation does not checking and never fails so really the checks are the same Likewise note that for def f x int None called as f 1 a no exception is raised because the annotation for the list element at index 1 is None which according to that rule s annotation does no checking of the list s value at index 1 and never fails Note also that for def f x str called as f a b c d no exception is raised because the annotation says x is a list containing lists that contain only strings The code to check list annotations will indirectly call itself recursively in the process of checking this annotation Think about this now when there are few data types being processed it will be natural to perform other recursive annotation checks in the check method In fact spend a good amount of time simplifying the local function that performs this check because most of the other annotations listed below look very similar Finally note if we called f a 1 c d the exception message would be AssertionError x failed annotation check wrong type value 1 was type int should be type str list check class str list 1 check class str which indicates that the annotation of list was being checked when the annotation for list 1 was being checked each of its values should be a list of str when Python found a non string that violated the annotation annot is a tuple not the tuple class object but an instance of tuple a real tuple of values where each element in annot is an annotation Structurally checking tuples is equivalent to checking lists all 3 rules apply In fact I parameterized the local function that I originally wrote for checking lists to work for checking tuples as well Of course the error messages should use the word list and tuple where appropriate Caution remember for tuples of one value we must write f x int notice the comma after int annot is a dict not the dict class object but an instance of dict a real dictonary see the examples below with exactly one key both the key and its associated value are each an annotation Note this annotation should work for subclases of dict e g defaultdict Check it not by type annot is dict but using the isinstance function covered in the inheritance lectures isinstance annot dict Fail if value is not a dict or a subclass of dict annot has more than one key value association this is actually a bad illegal annotation not a failed annotation annot has one key value association and any key in the value dictionary fails the key annotation check or any value in the value dictionary fails the value annotation check Here are some examples of failures For def f x str int called as f a the exception message would be AssertionError x failed annotation check wrong type value a was type list should be type dict For def f x str int int int called as f a the exception message would be AssertionError x annotation inconsistency dict should have 1 item but had 2 annotation class str class int class int class int For def f x str int called as f 1 the exception message would be AssertionError x failed annotation check wrong type value 1 was type int should be type str dict key check class str For def f x str int called as f a b the exception message would be AssertionError x failed annotation check wrong type value b was type str should be type int dict value check class int Of course if a dictionary had many keys it would check the required annotations for each of its keys and their associated values annot is a set not the set class object but an instance of set a real set of values see the examples below where its has exactly one value that is an annotation Fail if value is not a set annot has more than one value this is actually a bad illegal annotation not a failed annotation annot has one value and any value in the value set fails the value annotation check Here are some examples of failures For def f x str called as f a b the exception message would be AssertionError x failed annotation check wrong type value a b was type list should be type set For def f x str int called as f a 1 the exception message would be AssertionError x annotation inconsistency set should have 1 value but had 2 annotation class str class int For def f x str called as f a 1 the exception message would be AssertionError x failed annotation check wrong type value 1 was type int should be type str set value check ltclass str annot is a frozenset not the frozenset class object but an instance of frozenset a real frozenset of values where its one value is an annotation Structurally checking frozensets are equivalent to checking sets all 3 rules apply In fact I parameterized the local function that I originally wrote for checking sets to work for checking frozensets as well similarly to the general function I wrote for checking lists tuple Of course the error messages should use the word set and frozenset where appropriate annot is a lambda or any function object that is a predicate with one parameter and returning a value that can be interpreted as a bool Fail if annot has zero more than one parameters this is actually a bad illegal annotation not a failed annotation Calling the lambda function on value returns False Calling the lambda function on value raises an exception Note that we can recognize a function lambda object by calling the inspect module s isfunction predicate we can determine the number of parameters in a function lambda object by accessing its code co varnames attribute You might be interested in reading the documentation for the inspect module it is quite interesting and many of its powerful features are new to Python Here are some examples of failures in the first two the argument fails the lambda directly in the others the argument is a list on which the lambda is checked for every value and fails for one For def f x lambda x y x called as f 1 the exception message would be AssertionError x annotation inconsistency predicate should have 1 parameter but had 2 predicate function lambda at x 2BDDC9 For def f x lambda x x called as f the exception message would be AssertionError x failed annotation check value predicate function lambda at x 2BDDC9 For def f x lambda x x called as f 1 the exception message would be AssertionError x failed annotation check value predicate function lambda at x 2BDDC9 list 1 check function lambda at x 2BDDC9 Note that in this example we are checking the lambda annotation for every value in a list just as the annotation int would check that every value in a list was an instance of the int class For def f x lambda x x called as f 1 a the exception message would be AssertionError x annotation predicate function lambda at x 2C9DC9 raised exception exception TypeError unorderable types str int list 1 check function lambda at x 2BDDC9 Note that for def f x lambda x isinstance x int and x called as f 1 a the exception message would be the more reasonable AssertionError x failed annotation check value a predicate function lambda at x 2BDDC9 list 1 check function lambda at x 2BDDC9 annot is not any of the above or specified in the extra credit part below Assume it is an object constructed from a class that supports annotation checking by that class defining the the check annotation method Fail if There is no check annotation method in the class e g calling the check annotation method raises the AttributeError exception the object was not constructed from a class that supports the annotation checking protocol this is actually a bad illegal annotation not a failed annotation calling its check annotation method fails calling its check annotation method raises any other exception Note that I have written the Check All OK and Check Any OK classes that support the annotation checking protocol check them out Here are some examples of failures The first assumes the Bag class does not support the annotation checking protocol the second assumes it does the third assumes it supports the protocol but raises some other exception not AssertionError For def f x Bag str called as f Bag a the exception message would be AssertionError x annotation undecipherable Bag class str 1 For def f x Bag str called as f Bag a 1 the exception message would be AssertionError x failed annotation check wrong type value 1 was type int should be type str Bag value check class str For def f x Bag lambda x x called as f Bag a 1 the exception message would be AssertionError x annotation predicate function lambda rt at x 2C5C39 raised exception exception TypeError unorderable types str int Bag value check function lambda at x 2C5C39 The checkannotation py module defines the Check All OK and Check Any OK classes which implement the check annotation protocol Note that with the Check Any OK class we can specify that every value in a list must contain a string or integer So for def f x Check Any OK str int called as f a 1 there is no exception raised Likewise with the Check All OK class we can specify that every value in a list must be an integer and must be bigger than So for def f x Check All OK int lambda x x called as f 1 2 there is no exception raised Extra credit Implement the following annotations as well annot is a str object which when evaluated using a dictionary in which all the parameters are defined and the returned result is the value of the key return returns a value that can be interpreted as a bool This specifiction is similar to lambdas functions but more general because the expressions can name multiple names not just the parameter Fail if Evaluating the string returns False Evaluating the string raises an exception Here are some examples of failures For def f x y y x called as f the exception message would be AssertionError y failed annotation check str predicate y x args for evaluation x y Notice that with this form of annotation we can check properties that depend on values of multiple parameters not just type information The values of all the parameters are included in the error message Likewise we can check properties that depend on the returned values For def f x y return x or return y return x y called as f 3 5 the exception message would be AssertionError return failed annotation check str predicate return x or return y args for evaluation x 3 y 5 return 8 Notice the value of return is listed with all the parameter values Of course such strings are easier to read than what Python prints for lambdas functions For def f x x called as f a the exception message would be AssertionError x annotation check str predicate x raised exception exception TypeError unorderable types str int Implement check annotation for the Bag class A Largish Example Full Output When I put the following code in the script before the driver in the checkannotation py module Check Annotation def f x int pass f 1 2 3 4 5 a the result printed was the following although I edited out some of the code that Python displays from my program lines that start with Check Annotation def f x int pass Traceback most recent call last File C Users Pattis workspace 33program4 checkannotationsolution py line 2 9 in module f 1 2 3 4 5 a File C Users Pattis workspace 33program4 checkannotationsolution py line 183 in call my call to self check File C Users Pattis workspace 33program4 checkannotationsolution py line 138 in check my call to check a list File C Users Pattis workspace 33program4 checkannotationsolution py line 7 in check sequence my call to check a value in the list File C Users Pattis workspace 33program4 checkannotationsolution py line 138 in check my call to check a list File C Users Pattis workspace 33program4 checkannotationsolution py line 7 in check sequence my call to check a value in the list File C Users Pattis workspace 33program4 checkannotationsolution py line 137 in check my call to check a type which failed the assertion causing the following exception AssertionError x failed annotation check wrong type value a was type str should be type int list 2 check class int list 1 check class int Feel free to put the small tests show in this document or in the bsc txt file in the same position before the driver to test the annotations as you write them Testing The sections above present various tests for elements of the annotation language they are easy to specify because the parameter annotations involve only the header the body can be pass when checking return annotations we can put one return statement in the body of the code to return a value that does doesn t satisfy the annotation I provided an if name main section in the checkannotation py module Again it is easy to test a simple function there by annotating it and then calling it described in the previous section I provided code to call driver driver which can be used to run individual and batch self check using the file bsc txt Here is an example of running individual tests After importing and abbreviating the name of the Check Annotation class it defines a simply annotated function decorates it and then calls the function with good and bad arguments which in the latter case rasise an exception because of an annotation failure Command from checkannotation import Check Annotation as ca Command from checkannotation import Check Annotation as ca def f x int pass Command def f x int pass f ca f Command f ca f f 1 Command f 1 f a Traceback most recent call last File C Users Pattis workspace courselib driver py line 225 in driver exec old local globl File string line 1 in module File C Users Pattis workspace 33program4 checkannotation py line 183 in call self check p annot p self args p File C Users Pattis workspace 33program4 checkannotation py line 137 in check n was type type as str value should be type str annot 8 2 n check history AssertionError x failed annotation check wrong type value a was type str should be type int Command f a When runing batch self check you might want to start by removing all but the earliest test or comment them out with as you start testing your code IMPORTANT for running batch self check To use the batch self check you must remove the part of your call method that prints out the source lines when an assertion exception is raised otherwise Python will raise a strange exception OSError which disrupts batch self check Comment out the following lines so that your code looks like except AssertionError print 8 for l in inspect getsourcelines self f ignore starting line print l rstrip print 8 raise IMPORTANT Comment out these lines in the code you submit to Checkmate ", "_id": "http://www.ics.uci.edu/~pattis/ICS-33/assignments/program4/program.html", "title": "program 4", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n<title>Program 4</title>\r\n</head>\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 4</h1>\r\n<h1>\r\nChecking Annotations\r\n</h1>\r\n<p>\r\n<h2>ICS-33: Intermediate Programming<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to show how we can get Python to check\r\n  function annotations whenever annotated functions are called.\r\nFor each of Python's built-in data types, we will develop an interpretation\r\n  (and write code to check that interpretation) of how the data type specifies\r\n  type information that is checkable when a function is called.\r\n<p>\r\n\r\nFor example, we specified the main <b>dict</b> for the NDFA in Programming\r\n  Assignment #1 by the notation\r\n<b><pre>  dict[str]->(dict[str]->set[str])</pre></b>\r\nRecall the outer-<b>dict</b> associates a <b>str state</b> key with a value\r\n  that is an inner-<b>dict</b>; and the inner-<b>dict</b> associates a \r\n <b>str transition</b> with a value that is a set of <b>str states</b>.\r\nIn our annotation checker, we will use an alternative notation to specify this\r\n  type information equivalently and compactly:\r\n<b><pre>  {str : {str : {str}}}</pre></b>\r\nNote that this is an actual data structure in Python, where <b>str</b> is\r\n  a reference to the string class object.\r\nIt is an outer-<b>dict</b> whose single key is <b>str</b> and whose associated\r\n  value is an inner-<b>dict</b> whose single key is a <b>str</b> and whose\r\n  value is a <b>set</b> that contains just element, <b>str</b>.\r\n<p>\r\n\r\nWe will write the <b>Check_Annotation</b> class and use it as a decorator for\r\n  functions whose annotations we want to check each time the function is called.\r\nInternally it will overload the <b>__call__</b> method to call the function only\r\n  after checking its annotation by using mutual recursion (not direct\r\n  recursion), in a natural way, to process the nesting of data types inside\r\n  data types illustrated in the notation above.\r\nWe will write code that ensures that this checking works for the standard\r\n  classes defined in Python.\r\nThe code will also know how to process a special annotation-checking protocol\r\n  (via the <b>__check_annotation__</b> method) that we can implement in any\r\n  new classes that we write, so that that class can become part of the\r\n  annotation language (I have done this for two classes; you can do it for the\r\n  <b>Bag</b> class for extra credit).\r\n<p>\r\n\r\nI suggest that you look at the code in the modules that appear in the project\r\n  folder that you will download.\r\nThen (see the detailed instructions in this document) we can add/test/debug\r\n  capabilities for each of the built-in data types we can use in the annotation\r\n  language, iteratively enhancing our code until we can use all the built-in\r\n  data types in annotations.\r\nOnce we do this for <b>list</b> (about a dozen lines; the biggest of my\r\n  checking functions), all the others are variants and therefore much easier to\r\n  write (but still with some interesting details).\r\n<p>\r\n\r\nDownload the \r\n  <a href=\"program4.zip\">program4</a> project folder and use it to create an\r\n  Eclipse project.\r\nWe can test our class (put it in the <b>checkannotation.py</b> module, which\r\n  already includes some useful code) at the end of the class itself, or in a\r\n  special driver that is included, which uses a batch file to test progressively\r\n  more and more complex data types in the annotation language.\r\n<p>\r\n\r\nIt is recommend that you work on this assignment in pairs, with someone in your\r\n  lab section.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<!---\r\nIf you believe that it is impossible for you to work with someone, because of\r\n  some special reason(s), you should send me email stating them and asking for\r\n  special permission to work alone (which I do grant, but not frequently).\r\n--->\r\n<p>\r\n\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  students' UICnetID and name should appear in a comment at the <b>top</b> of\r\n  <b>each submitted .py file</b>.\r\nA special grading program reads this information.\r\nThe format is a comment starting with <b>Submitter</b> and <b>Partner</b> (when\r\n  working with a partner), followed by a <b>colon</b>, followed by the student's\r\n  <b>UCInetID</b> (in all lower-case), followed by the student's <b>name in\r\n  parentheses</b> (last name, comma, first name -capitalized appropriately).\r\nIf you omit this information, or do not follow this exact form, it will require\r\n  extra work for us to grade your program, so we will deduct points.\r\nNote: if you are submitting by yourself, and do <b>NOT</b> have a partner, you\r\n  should <b>OMIT</b> the partner line.\r\n<p>\r\nFor example if Romeo Montague (whose UCInetID is romeo1) submitted a program\r\n  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)\r\n  the comment at the top of each .py file would appear as:\r\n<pre><b># Submitter: romeo1(Montague, Romeo)\r\n# Partner  : jcapulet(Capulet, Juliet)\r\n# We certify that we worked cooperatively on this programming\r\n#   assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  <b>before</b> starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can more\r\n  accurately assess the progress of the class as a whole during this assignment.\r\n\r\n<p>\r\nThe different parts of this assignment will be worth different amounts of\r\n  points.\r\nYou can implement each part independently, so concentrate on the higher-point\r\n  targets first.\r\nIn total, the assignment is worth 60 points.\r\nHere is the breakdown and some commentary.\r\n<p>\r\nMost important stuff, useful for writing later code: 45/60 pts (75%)\r\n<ul>\r\n<li> 5 annot is None (simple code)\r\n<li>15 annot is type (important; simple code)\r\n<li>15 annot is list (important; interesting code, for modeling later\r\n       annotations)\r\n<li>10 annot is dict (important; much like list, part simpler/part more complex)\r\n</ul>\r\nUseful stuff (all similar to list; set/frozenset are simpler): 9/60 pts (15%)\r\n<ul>\r\n<li> 3 annot is tuple\r\n<li> 3 annot is set\r\n<li> 3 annot is frozenset\r\n</ul>\r\nDifferent: requires dealing with exceptions in a special way: 6/60 (10%)\r\n<ul>\r\n<li> 3 annot is lambda\r\n<li> 3 annot is a class whose __check_annotation__ method is called\r\n     (test by using Check_All_OK/Check_Any_OK)\r\n</ul>\r\n\r\nExtra credit\r\n 1 annot is str (code is not terribly complex but is intricate/a bit strange)\r\n   rewriting bag to implement the check annotation protocol (see \r\n    Check_All_OK/Check_Any_OK)\r\n\r\nSo, you can still get an C (75%) by doing the first 4, an A (90%) by doing\r\nthe next 3. To get 100% requires doing all 9. Notice that the batch self check\r\nfile tests all these, in the general order stated above (except it checks tuples\r\nbefore dicts).\r\n\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nThe code you write should be as compact and elegant as possible, using \r\n  appropriate Python idioms.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Check_Annotation</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite a class named <b>Check_Annotation</b> that decorates a function, such\r\n  that when the decorated function is called, the decorator class check's the\r\n  decorated function's annotation, using the annotation language described\r\n  below in detail.\r\nWe can use this decorator by writing either\r\n<b><pre>  def f(params-annotation) -> result-annotation:\r\n      ...\r\n  f = Check_Annotation(f)</pre></b>\r\nor\r\n<b><pre>  @Check_Annotation\r\n  def f(params-annotation) -> result-annotation:\r\n      ...</pre></b>\r\nwhich is a special Python syntactic form that expands to the former assignment.\r\nThus, when the decorated <b>f</b> is called, Python calls\r\n  <b>Check_Annotations.__call__</b> in the decorator, which first checks the\r\n  annotations (and raises an exception if it is not met) and second\r\n  computes/returns the decorated function <b>f</b>: the original one written.\r\n<p>\r\nThis class defines four major attributes:\r\n<ul>\r\n<li>the <b>checking_on</b> instance name to turn off/on annotation checking in\r\n      all decorated functions; it starts on.\r\n<p>\r\n\r\n<li>the <b>__init__</b> method to remember the function being decorated and\r\n      initialize a per-function name that helps controls annotation checking;\r\n      it also starts on: for a function call to check its annotation, both\r\n      <b>checking_on</b> and its per-function name must be <b>True</b>: if\r\n      either is <b>False</b> the annotation is not checked.\r\n<p>\r\n\r\n<li>the <b>__call__</b> method that intercepts each call to the decorated\r\n      function and decides whether to check the annotation, and if so\r\n      implements annotation checking, both for parameters and returned results,\r\n      if they are specified; if annotation checking succeeds, this method\r\n      computes/returns the result of calling the decorated function.\r\n<p>\r\n\r\n<li>the <b>check</b> method (specified in more detail below) that does the\r\n       annotation checking: it either succeeds silently or raises an\r\n       <b>AssertionError</b> exception with useful information specified\r\n       in the details below.\r\n    Note that the unconditional assertion,\r\n      <b><pre>  assert False, message</pre></b>\r\n      is a simple way to raise <b>AssertionError</b> with a message.\r\n    I wrote many nested helper functions in <b>check</b>, one for each\r\n      data type annotation that can be checked: e.g., <b>check_dict</b>.\r\n</ul>\r\n<p>\r\n\r\n<h3>Details</h3>\r\n\r\nLet's explore the meaning of the <b>__call__</b> and <b>check</b> methods in \r\n  more detail.\r\n<ol type=\"I\">\r\n<li>\r\nThe <b>__call__</b> method intercepts calls to the decorated function;\r\n  it specifies <b>*args</b> and <b>**kargs</b> to handle all calls,\r\n  regardless of their parameter structure.\r\nMy method was about 40 lines (but about 17 lines were comments/blank, and\r\n  7 comprise the <b>param_arg_binding</b> local function supplied in the\r\n  download; this function computes an <b>ordereddict</b> of the parameter\r\n  names (each associated to its argument) in the order that the parameters\r\n  are defined in the function.\r\nThe <b>__call__</b> method\r\n<ul>\r\n<li>determines whether to check the annotations (see above); if not just\r\n       call the decorated function and return its result.\r\n<p>\r\n<li>determines the parameters of the function and the matching arguments\r\n      they are bound to.\r\n    The <b>param_arg_bindings</b> function (written locally in this method)\r\n       returns an ordered dictionary of parameter/value bindings; ordered means\r\n       that when iterated, keys always appear in the same order: the order the\r\n       parameters appear in in the function's definition.\r\n    It uses the various attributes in the <b>inspect</b> module to do the job.\r\n    You might be interested in reading the documentation for the <b>inspect</b>\r\n      module: it is quite interesting and many of its (powerful) features are\r\n      new to Python.\r\n<p>\r\n<li>determines the annotations of the parameters by using the\r\n      <b>__annotations__</b> attribute of any function object.\r\n    This name is bound to a dictionary containing as keys every annotated\r\n      parameter name; the associated value for each parameter name is its\r\n      annotation.\r\n    If we defined the function <b>f</b> using\r\n       <b>def f(x:int,y,z:int):->str...</b> its <b>__annotations__</b>\r\n      dictionary is\r\n<b><pre>\r\n{'x': &lt;class 'int'&gt;, 'z': &lt;class 'int'&gt;, 'return': &lt;class 'str'&gt;>}</pre></b>\r\nNotice that parameter <b>y</b> has no annotation so it does not appear as a key\r\n  in this dictionary, and the key <b>return</b> is associated with the\r\n  annotation for the returned value (after the <b>-&gt;</b>).\r\n<p>\r\n\r\n<li>If any checked annotations (parameters or returned result) raise the\r\n      <b>AssertionError</b> handle it by printing the relevant source lines\r\n      for the function (see the <b>getsourcelines</b> function in the \r\n      <b>inspect</b> module's documentation) and reraise the exception,\r\n      skipping the rest of the code in this method.\r\n  <ul>\r\n  <li>Checks every parameter that has an annotation\r\n  <p>\r\n  <li>Call the decorated function to compute its returned result (and save it).\r\n  <p>\r\n  <li>If <b>'return'</b> is in the dictionary of annotions:\r\n     (a) add the result as the value associated with the key <b>_return</b> in\r\n          the dictionary of parameter and argument bindings; (b) check the\r\n          annotation for <b>return</b>\r\n  <p>\r\n  <li>Return the result.    \r\n  </ul>\r\n</ul>\r\n<p>\r\n\r\n<li>\r\nThe <b>check</b> method has the following header\r\n<b><pre>  def check(self,param,annot,value,check_history=''):</pre></b>\r\nwhere\r\n<ul>\r\n<li><b>self</b>  is an instance of the <b>Check_Annotation</b> class\r\n<li><b>param</b> is a string that specifies the name of the parameter being\r\n        checked (or <b>'_return'</b> for checking the returned value</b>)\r\n<li><b>annot</b> is a data structure that specifies the annotation\r\n<li><b>value</b> is the value of <b>param</b> that the annotation should be\r\n        checked against (to ensure it is legal)\r\n<li><b>check_history</b> is a string that embodies the history of checking the\r\n       annotation for the parameter to here (it is extended by concatenation in\r\n       each recursive call to provide context for any annotation violations to\r\n       be checked later); it is printed after the details of any annotation\r\n       violation, to suppy context for the failure.\r\n</ul>\r\n<p>\r\n\r\nEach call to <b>check</b> decodes the <b>annot</b> to check, and checks it\r\n  against the <b>value</b>: <b>check</b>'s body is one big\r\n    <b>if/elif/.../else</b> determining which local function to call to check\r\n    the specific annotation (and letting that local function do the real work).\r\nMost annotations are checked by calling a function defined locally in\r\n  <b>check</b> that can use the parameters of <b>check</b> freely, because\r\n  these functions are defined in <b>check</b>'s local scope (in fact these local\r\n  functions are often parameterless: many get all the information they need\r\n  from check's parameters).\r\nThe more complicated local functions also call <b>check</b>; so <b>check</b>\r\n  calls a local function which can call <b>check</b>: this is indirect\r\n  recursion.\r\nMy method was about 100 lines: about 13 lines were comments/blank, and 60 more\r\n  appeared in 5 locally declared functions -including one to solve the extra\r\n  credit part of this assignment- so I had about a dozen lines per local\r\n  function.\r\n<p>\r\n\r\nThe annotation checking language comprises the following components\r\n  (for Python's built-in types).\r\nI <b>strongly</b> suggest writing/testing each component before moving on to\r\n  the next: all are similar and understanding/testing/debugging <b>list</b>\r\n  (the first really interesting one) will supply tremendous insight for writing\r\n  all.\r\n<b>Write the required exception messages exactly to match the ones shown.</b>\r\n\r\n<ul>\r\n<li><b>annot</b> is <b>None</b>: do nothing (succeed silently).\r\n    note that <b>def f(x):</b> has no annotation to check for its parameter\r\n    <b>x</b>, but <b>def f(x:None):</b> has an annotation to check for <b>x</b>,\r\n    but it never fails.\r\n    <b>None</b> has more interesting uses inside more complicated data types,\r\n      illustrated below (see the last example for <b>list</b>).\r\n<p>\r\n\r\n<li><b>annot</b> is any <b>type</b> (e.g., <b>type(annot) is type)</b>:\r\n    fail if <b>value</b> is not an instance of the specified type, with an\r\n       exception messages matching the following examples.\r\n    The <b>isinstance</b> function (covered in the inheritance lectures)\r\n       generalizes checking the type of an object.\r\n    Instead of writing <b>type(x) is someclass</b> we write\r\n       <b>isinstance(x,someclass)</b>: it checks whether <b>x</b>'s object is\r\n       constructed from <b>someclass</b> or any base class of\r\n       <b>someclass</b>, which is the correct test to perform here.\r\n<p>\r\n\r\nFor <b>def f(x:int):...</b> called as <b>f('abc')</b> or <b>f(x='abc')</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 'abc'\r\n  was type str ...should be type int</pre></b>\r\nFor <b>def f(x:list):...</b> called as <b>f({1,2})</b>\r\n the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = {1, 2}\r\n  was type set ...should be type list</pre></b>\r\n<p>\r\nAll exception messages described in the sections below follow this same general\r\n  format, although the more complicated ones supply extra context via the\r\n  <b>check_history</b> parameter.\r\n\r\n<li><b>annot</b> is a <b>list</b> (not the <b>list</b> class object, but an\r\n        instance of <b>list</b>: a real list of one or more values; see the\r\n       examples below) where each element in <b>list</b> is an annotation.\r\n    Fail if\r\n    <ol>\r\n    <li><b>value</b> is not a list\r\n    <li><b>annot</b> has just one element-annotation, and any of the elements in\r\n           the <b>value</b> list fails the element-annotation check\r\n    <li><b>annot</b> has more than one element-annotation, and\r\n        <ol type=\"a\">\r\n          <li>the <b>annot</b> and <b>value</b> lists have a different number\r\n               of elements, or\r\n          <li>any element in the <b>value</b> list fails its corresponding\r\n               element-annotation check\r\n        </ol>\r\n    </ol>\r\n<p>\r\n\r\nHere are some examples of failures:\r\n<ol>\r\n<li>For <b>def f(x:[int]):...</b> called as <b>f({1,2})</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = {1, 2}\r\n  was type set ...should be type list</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:[int]):...</b> called as <b>f([1,'a'])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 'a'\r\n  was type str ...should be type int\r\nlist[1] check: &ltclass 'int'&gt</pre></b>\r\nNote that when each element in the list is tested, it appends the index it is\r\n  checking and the annotation it is checking to the <b>check_history</b>\r\n  (which prints after the actual annotation that fails: here the line starting\r\n  <b>list[1] check: ...</b>): it means the element at index <b>0</b> did not\r\n  fail this annotation but the element at index <b>1</b> did.\r\n<p>\r\n\r\n<li>For <b>def f(x:[int,str]):...</b> called as <b>f([1])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong number of elements): value = [1]\r\n  annotation had 2 elements[&ltclass 'int'&gt, &ltclass 'str'&gt]</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:[int,str]):...</b> called as <b>f([1,2])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 2\r\n  was type int ...should be type str\r\nlist[1] check: &ltclass 'str'&gt</pre></b>\r\n</ol>\r\n<p>\r\n\r\nNote that the annotation <b>def f(x:list):...</b> and the annotation \r\n  <b>def f(x:[None]):...</b> have the same meaning (but the former is faster to\r\n  check): the first checks only that <b>x</b> is an instance of <b>list</b>;\r\n  the second checks that <b>x</b> is an instance of <b>list</b> and then checks\r\n  each of its values agains the annotation <b>None</b>, which according to that\r\n  rule's annotation does not checking and never fails -so really the checks are\r\n  the same.\r\n<p>\r\nLikewise note that for <b>def f(x:[int,None]):...</b> called as\r\n  <b>f([1,'a'])</b> no exception is raised, because the annotation for the list\r\n  element at index <b>1</b> is <b>None</b>, which according to that rule's\r\n  annotation does no checking of the list's value at index <b>1</b> and never\r\n  fails.\r\n<p>\r\n\r\nNote also that for <b>def f(x:[[str]]):...</b> called as\r\n  <b>f([['a','b'],['c','d']])</b> no exception is raised, because the annotation\r\n  says <b>x</b> is a list containing lists that contain only strings.\r\nThe code to check list annotations will indirectly call itself (recursively) in\r\n  the process of checking this annotation.\r\nThink about this now, when there are few data types being processed; it will be\r\n  natural to perform other recursive annotation checks in the <b>check</b>\r\n  method.\r\nIn fact, spend a good amount of time simplifying the local function that\r\n  performs this check, because most of the other annotations listed below look\r\n  very similar.\r\n<p>\r\n\r\nFinally, note if we called <b>f([['a',1],['c','d']])</b> the exception message\r\n  would be\r\n<pre><b>AssertionError: 'x' failed annotation check(wrong type): value = 1\r\n  was type int ...should be type str\r\nlist[0] check: [&lt;class 'str'&gt;]\r\nlist[1] check: &lt;class 'str'&gt;</b></pre>\r\nwhich indicates that the annotation of <b>list[0]</b> was being checked when the\r\n  annotation for <b>list[1]</b> was being checked (each of its values should be\r\n  a <b>list</b> of <b>str</b>), when Python found a non-string that violated\r\n  the annotation.\r\n<p>\r\n\r\n<li><b>annot</b> is a <b>tuple</b> (not the <b>tuple</b> class object, but an\r\n        instance of <b>tuple</b>: a real tuple of values), where each element\r\n        in <b>annot</b> is an annotation.\r\n<p>\r\n\r\nStructurally, checking tuples is equivalent to checking lists (all 3 rules\r\n   apply).\r\nIn fact, I parameterized the local function that I originally wrote for checking\r\n  lists to work for checking tuples as well).\r\nOf course, the error messages should use the word <b>list</b> and <b>tuple</b>\r\n  where appropriate.\r\n<b>Caution</b>: remember for tuples of one value we must write\r\n     f(x:(int,)):...</b>; notice the comma after <b>int</b>.\r\n<p>\r\n\r\n<li><b>annot</b> is a <b>dict</b> (not the <b>dict</b> class object, but an\r\n        instance of <b>dict</b>: a real dictonary; see the examples below),\r\n        with exactly one key: both the key and its associated value are each\r\n        an annotation.\r\n    Note, this annotation should work for subclases of <b>dict</b>, e.g.,\r\n       <b>defaultdict</b>.\r\n    Check it not by <b>type(annot) is dict</b> but using the <b>isinstance</b>\r\n       function (covered in the inheritance lectures):\r\n       <b>isinstance(annot,dict)</b>\r\n    Fail if\r\n    <ol>\r\n    <li><b>value</b> is not a <b>dict</b> or a subclass of <b>dict</b>\r\n    <li><b>annot</b> has more than one key/value association: this is actually\r\n           a bad/illegal annotation, not a failed annotation\r\n    <li><b>annot</b> has one key/value association, and\r\n           <ol type=\"a\">\r\n              <li> any key in the <b>value</b> dictionary fails the\r\n                     key-annotation check or\r\n              <li>any value in the <b>value</b> dictionary fails the\r\n                     value-annotation check\r\n           </ol>\r\n    </ol>\r\n<p>\r\n\r\nHere are some examples of failures:\r\n<ol>\r\n<li>For <b>def f(x:{str : int}):...</b> called as <b>f(['a',0])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = ['a', 0]\r\n  was type list ...should be type dict</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:{str : int, int : int}):...</b> called as <b>f({'a':0})</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' annotation inconsistency: dict should have 1 item but had 2\r\n  annotation = {&lt;class 'str'&gt;: &lt;class 'int'&gt;, &lt;class 'int'&gt;: &lt;class 'int'&gt;}</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:{str : int}):...</b> called as <b>f({1:0})</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 1\r\n  was type int ...should be type str\r\ndict key check: &lt;class 'str'&gt;</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:{str : int}):...</b> called as <b>f({'a':'b'})</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 'b'\r\n  was type str ...should be type int\r\ndict value check: &lt;class 'int'&gt;</pre></b>\r\n</ol>  \r\nOf course, if a dictionary had many keys, it would check the required\r\n  annotations for each of its keys and their associated values.\r\n<p>\r\n\r\n<li><b>annot</b> is a <b>set</b> (not the <b>set</b> class object, but an\r\n        instance of <b>set</b>: a real set of values; see the examples below)\r\n        where its has exactly one value that is an annotation.\r\n    Fail if\r\n    <ol>\r\n    <li><b>value</b> is not a <b>set</b>\r\n    <li><b>annot</b> has more than one value: this is actually\r\n           a bad/illegal annotation, not a failed annotation\r\n    <li><b>annot</b> has one value, and any value in the <b>value</b> set\r\n           fails the value-annotation check\r\n    </ol>\r\n<p>\r\n\r\nHere are some examples of failures:\r\n  \r\n<ol>\r\n<li>For <b>def f(x:{str}):...</b> called as <b>f(['a','b'])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = ['a', 'b']\r\n  was type list ...should be type set</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:{str,int}):...</b> called as <b>f({'a',1})</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' annotation inconsistency: set should have 1 value but had 2\r\n  annotation = {&lt;class 'str'&gt;, &lt;class 'int'&gt;}</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:{str}):...</b> called as <b>f({'a',1})</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 1\r\n  was type int ...should be type str\r\nset value check: &ltclass 'str'&gt</pre></b>\r\n</ol>  \r\n<p>\r\n<li><b>annot</b> is a <b>frozenset</b> (not the <b>frozenset</b> class object,\r\n        but an instance of <b>frozenset</b>: a real frozenset of values) where\r\n        its one value is an annotation.\r\n<p>\r\n\r\nStructurally, checking frozensets are equivalent to checking sets (all 3 rules\r\n   apply).\r\nIn fact, I parameterized the local function that I originally wrote for checking\r\n  sets to work for checking frozensets as well, similarly to the general\r\n  function I wrote for checking lists/tuple.\r\nOf course, the error messages should use the word <b>set</b> and\r\n  <b>frozenset</b> where appropriate.\r\n<p>\r\n\r\n<li><b>annot</b> is a <b>lambda</b> (or any function object) that is a\r\n      predicate with one parameter and returning a value that can be\r\n      interpreted as a <b>bool</b>.\r\n    Fail if\r\n    <ol>\r\n    <li><b>annot</b> has zero/more than one parameters: this is actually\r\n           a bad/illegal annotation, not a failed annotation\r\n    <li>Calling the lambda/function on <b>value</b> returns <b>False</b>\r\n    <li>Calling the lambda/function on <b>value</b> raises an exception\r\n    </ol>\r\n<p>\r\n\r\nNote that we can recognize a function/lambda object by calling the\r\n   <b>inspect</b> module's <b>isfunction</b> predicate; we can determine the\r\n   number of parameters in a function/lambda object by accessing its\r\n   <b>__code__.co_varnames</b> attribute.\r\nYou might be interested in reading the documentation for the <b>inspect</b>\r\n  module: it is quite interesting and many of its (powerful) features are new\r\n  to Python.\r\n<p>\r\n\r\nHere are some examples of failures:  in the first two, the argument fails the\r\n  <b>lambda</b> directly; in the others the argument is a list on which the\r\n  <b>lambda</b> is checked for every value and fails for one.\r\n\r\n<ol>\r\n<li>For <b>def f(x:lambda x,y : x>0):...</b> called as <b>f(1)</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' annotation inconsistency: predicate should have 1 parameter but had 2\r\n  predicate = &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:lambda x : x>0):...</b> called as <b>f(0)</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check: value = 0\r\n  predicate = &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:[lambda x : x>0]):...</b> called as <b>f([1,0])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check: value = 0\r\n  predicate = &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;\r\nlist[1] check: &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;</pre></b>\r\nNote that in this example we are checking the <b>lambda</b> annotation for\r\n  every value in a <b>list</b>, just as the annotation <b>[int]</b> would\r\n  check that every value in a <b>list</b> was an instance of the <b>int</b>\r\n  class.\r\n<p>\r\n\r\n<li>For <b>def f(x:[lambda x : x>0]):...</b> called as <b>f([1,'a'])</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' annotation predicate(&lt;function &lt;lambda&gt; at 0x02C9DC90&gt;) raised exception\r\n  exception = TypeError: unorderable types: str() > int()\r\nlist[1] check: &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;</pre></b>\r\n\r\nNote that for <b>def f(x:[lambda x : isinstance(x,int) and x>0]):...</b> called as\r\n   <b>f([1,'a'])</b> the exception message would be the more reasonable:\r\n<b><pre>AssertionError: 'x' failed annotation check: value = 'a'\r\n  predicate = &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;\r\nlist[1] check: &lt;function &lt;lambda&gt; at 0x02BDDC90&gt;</pre></b>\r\n</ol>\r\n<p>\r\n\r\n<li><b>annot</b> is not any of the above (or <str>, specified in the extra\r\n    credit part below).\r\n    Assume it is an object constructed from a class that supports annotation\r\n      checking, by that class defining the the <b>__check_annotation__</b>\r\n      method.\r\n    Fail if\r\n    <ol>\r\n    <li>There is no <b>__check_annotation__</b> method in the class: e.g., \r\n          calling the <b>__check_annotation__</b> method raises the\r\n          <b>AttributeError</b> exception (the object was not constructed from a\r\n          class that supports the annotation checking protocol): this is\r\n          actually a bad/illegal annotation, not a failed annotation\r\n    <li>calling its <b>__check_annotation__</b> method fails\r\n    <li>calling its <b>__check_annotation__</b> method raises any other\r\n         exception\r\n    </ol>\r\n<p>\r\n\r\nNote that I have written the <b>Check_All_OK</b> and <b>Check_Any_OK</b>\r\n  classes that support the annotation checking protocol; check them out.\r\n<p>\r\nHere are some examples of failures.\r\nThe first assumes the <b>Bag</b> class does not support the annotation\r\n  checking protocol; the second assumes it does; the third assumes it supports\r\n  the protocol but raises some other exception (not <b>AssertionError</b>).\r\n<ol>\r\n<li>For <b>def f(x:Bag([str])):...</b> called as <b>f(Bag('a'))</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' annotation undecipherable: Bag(&lt;class 'str'&gt;[1])</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:Bag([str])):...</b> called as <b>f(Bag(['a',1]))</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' failed annotation check(wrong type): value = 1\r\n  was type int ...should be type str\r\nBag value check: &lt;class 'str'&gt;</pre></b>\r\n<p>\r\n\r\n<li>For <b>def f(x:Bag([lambda x : x > 0)):...</b> called as\r\n  <b>f(Bag(['a',1]))</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'x' annotation predicate(&lt;function &lt;lambda&rt; at 0x02C5C390&gt;) raised exception\r\n  exception = TypeError: unorderable types: str() > int()\r\nBag value check: &lt;function &lt;lambda&gt; at 0x02C5C390&gt;</pre></b>\r\n<p>\r\n\r\nThe <b>checkannotation.py</b> module defines the <b>Check_All_OK</b> and\r\n  <b>Check_Any_OK</b> classes, which implement the check annotation protocol.\r\nNote that with the <b>Check_Any_OK</b> class, we can specify that every value in\r\n  a list must contain a string or integer.\r\nSo for <b>def f(x:[Check_Any_OK(str,int)]):...</b> called as\r\n  <b>f(['a',1])</b> there is no exception raised.\r\nLikewise with the <b>Check_All_OK</b> class, we can specify that every value in\r\n  a list must be an integer and must be bigger than 0.\r\nSo for <b>def f(x:[Check_All_OK(int,lambda x : x > 0)]:...</b> called as\r\n  <b>f([1,2])</b> there is no exception raised.\r\n</ol>\r\n</ul>\r\n\r\n<b>Extra credit</b>:\r\nImplement the following annotations as well.\r\n<ul>\r\n<li><b>annot</b> is a <b>str</b> object, which when <b>eval</b>uated using a \r\n      dictionary in which all the parameters are defined (and the returned \r\n      result is the value of the key <b>'_return'</b>) returns a value that can\r\n      be interpreted as a <b>bool</b>.\r\n    This specifiction is similar to lambdas/functions, but more general, because\r\n      the expressions can name multiple names, not just the parameter.\r\n       Fail if\r\n    <ol>\r\n    <li>Evaluating the string returns <b>False</b>\r\n    <li>Evaluating the string raises an exception\r\n    </ol>\r\n<p>\r\n\r\nHere are some examples of failures.\r\n<ol>\r\n<li>For <b>def f(x,y:'y>x'):...</b> called as <b>f(0,0)</b>\r\n  the exception message would be:\r\n<b><pre>AssertionError: 'y' failed annotation check(str predicate: 'y>x')\r\n  args for evaluation: x->0, y->0</pre></b>\r\nNotice that with this form of annotation, we can check properties that depend on\r\n  values of multiple parameters (not just type information).\r\nThe values of all the parameters are included in the error message.\r\nLikewise we can check properties that depend on the returned values.\r\nFor <b>def f(x,y)->'_return < x or _return < y': return x + y</b> called as\r\n  <b>f(3, 5)</b> the exception message would be:\r\n<b><pre>AssertionError: 'return' failed annotation check(str predicate: '_return < x or _return < y')\r\n  args for evaluation: x->3, y->5, _return->8</pre></b>\r\nNotice the value of <b>_return</b> is listed with all the parameter values.\r\nOf course, such strings are easier to read than what Python prints for \r\n  lambdas/functions.\r\n<p>\r\n\r\n<li>For <b>def f(x:'x>0'):...</b> called as <b>f('a')</b>\r\n  the exception message would be:\r\n<b><pre>\r\nAssertionError: 'x' annotation check(str predicate: 'x&gt;0') raised exception\r\n  exception = TypeError: unorderable types: str() &gt; int()</pre></b>\r\n</ol>\r\n<p>\r\n<li>Implement <b>__check_annotation__</b> for the <b>Bag</b> class.\r\n<!--- or the class produced by calling <b>pnamedtuple</b>--->.\r\n</ul>\r\n\r\n<h3>A Largish Example: Full Output</h3>\r\nWhen I put the following code in the script (before the driver) in the\r\n  <b>checkannotation.py</b> module).\r\n<b><pre>  @Check_Annotation\r\n  def f(x:[[int]]): pass\r\n    \r\n  f([[1,2],[3,4],[5,'a']])</pre></b>\r\nthe result printed was the following , although I edited out some of the code\r\n  that Python displays from my program: lines that start with ...\r\n<b><pre>--------------------------------------------------------------------------------\r\n    @Check_Annotation\r\n    def f(x:[[int]]): pass\r\n--------------------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 209, in &lt;module&gt;\r\n    f([[1,2],[3,4],[5,'a']])\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 183, in __call__\r\n    ...my call to self.check\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 138, in check\r\n    ...my call to check a list\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 70, in check_sequence\r\n    ...my call to check a value in the list\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 138, in check\r\n    ...my call to check a list\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 70, in check_sequence\r\n    ...my call to check a value in the list\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotationsolution.py\", line 137, in check\r\n    ...my call to check a type (which failed the assertion causing the following exception)\r\nAssertionError: 'x' failed annotation check(wrong type): value = 'a'\r\n  was type str ...should be type int\r\nlist[2] check: [&lt;class 'int'&gt;]\r\nlist[1] check: &lt;class 'int'&gt;</pre></b>\r\nFeel free to put the small tests show in this document (or in the <b>bsc.txt</b>\r\n  file) in the same position (before the driver) to test the annotations as you\r\n  write them.\r\n\r\n<h3>Testing</h3>\r\nThe sections above present various tests for elements of the annotation\r\n  language: they are easy to specify because the parameter annotations\r\n  involve only the header: the body can be <b>pass</b>; when checking return\r\n  annotations, we can put one return statement in the body of the code, to\r\n  return a value that does/doesn't satisfy the annotation.\r\n<p>\r\nI provided an <b>if __name__ == '__main__':</b> section in the\r\n  <b>checkannotation.py</b> module.\r\nAgain, it is easy to test a simple function there by annotating it and then\r\n  calling it (described in the previous section).\r\n<p>  \r\nI provided code to call <b>driver.driver()</b> which can be used to run\r\n  individual and <b>batch_self_check</b>, using the file <b>bsc.txt</b>.\r\n<p>\r\nHere is an example of running individual tests.\r\nAfter importing and abbreviating the name of the <b>Check_Annotation</b>\r\n  class it defines a simply annotated function, decorates it, and then calls\r\n  the function with good and bad arguments (which in the latter case rasise\r\n  an exception because of an annotation failure).\r\n<b><pre>Command[!]: from checkannotation import Check_Annotation as ca\r\nCommand[from checkannotation import Check_Annotation as ca]: def f(x:int): pass\r\nCommand[def f(x:int): pass]: f = ca(f)\r\nCommand[f = ca(f)]: f(1)\r\nCommand[f(1)]: f('a')\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\courselib\\driver.py\", line 225, in driver\r\n    exec(old,local,globl)\r\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotation.py\", line 183, in __call__\r\n    self.check(p,annot[p],self._args[p])\r\n  File \"C:\\Users\\Pattis\\workspace\\33program4\\checkannotation.py\", line 137, in check\r\n    '\\n  was type '+type_as_str(value)+' ...should be type '+str(annot)[8:-2]+'\\n'+check_history\r\nAssertionError: 'x' failed annotation check(wrong type): value = 'a'\r\n  was type str ...should be type int\r\nCommand[f('a')]:</pre></b>\r\n\r\nWhen runing <b>batch_self_check</b>, you might want to start by removing\r\n  all but the earliest test (or comment them out with <b>#</b>) as you start\r\n  testing your code).\r\n<p>\r\n<b>IMPORTANT for running batch-self-check:</b>\r\nTo use the <b>batch_self_check</b> you must remove the part of your\r\n   <b>__call__</b> method that prints out the source lines when an assertion\r\n   exception is raised: otherwise Python will raise a strange exception\r\n   (<b>OSError</b>), which disrupts <b>batch_self_check</b>.\r\nComment out the following lines so that your code looks like\r\n<b><pre>except AssertionError:\r\n#     print(80*'-')\r\n#     for l in inspect.getsourcelines(self._f)[0]: # ignore starting line #\r\n#     print(l.rstrip())\r\n#     print(80*'-')\r\n    raise</pre></b>\r\n<b>IMPORTANT:</b>\r\nComment-out these lines in the code you submit to Checkmate.\r\n<p>\r\n<p>\r\n</tbody>\r\n</table>\r\n\r\n</html>\r\n", "id": 10816.0}