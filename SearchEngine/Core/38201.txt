{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 332D Triangulation Data Structure Sylvain Pion and Mariette Yvinec 33 1 Definition A triangulation data structure is a data structure designed to handle the representation of a two dimensional triangulation The concept of triangulation data structure was primarily designed to serve as a data structure for CGAL 2D triangulation classes which are triangulations embedded in a plane However it appears that the concept is more general and can be used for any orientable triangulated surface without boundary whatever may be the dimensionality of the space the trianguation is embedded in 33 1 1 A data structure based on faces and vertices The representation of CGAL 2D triangulations is based on faces and vertices Edges are only implicitely represented trough the adjacency relations betwen two faces The triangulation data structure can be seen as a container for faces and vertices maintaining incidence and adjacency relations among them Each triangular face gives access to its three incident vertices and to its three adjacent faces Each vertex gives access to one of its incident faces and through that face to the circular list of its incident faces The three vertices of a face are indexed with 1 and 2 The neighbor of a face are also indexed with 1 2 in such a way that the neighbor indexed by i is opposite to the vertex with the same index See Figure the functions ccw i and cw i shown on this figure compute respectively i 1 and i 1 modulo 3 Each edge has two implicit representations the edge of a face f which is opposed to the vertex indexed i can be represented as well as an edge of the neighbor i of f Figure Vertices and neighbors This kind or representation of simplicial complexes extends in any dimension More precisely in dimension d the data structure will explicitely represents cells i e faces of maximal dimension and vertices i e faces of dimension All faces of dimension between 1 and d 1 will have an implicit representation The 2D triangulation data structure can represent simplicial complexes of dimension 2 1 or 33 1 2 The set of faces and vertices The set of faces maintained by a 2D triangulation data structure is such that each edge is incident to two faces In other words the set of maintained faces is topologically equivalent to a two dimensional triangulated sphere This rules extends to lower dimensional triangulation data structure arising in degenerate cases or when the triangulations have less than three vertices A one dimensional triangulation structure maintains a set of vertices and edges which forms a ring topologically equivalent to a 1 sphere A zero dimensional triangulation data structure only includes two adjacent vertices that is topologically equivalent to a sphere 33 2 The Concept of Triangulation Data Structure A model of TriangulationDataStructure 2 can be seen has a container for the faces and vertices of the triangulation This class is also responsible for the combinatorial integrity of the triangulation This means that the triangulation data structure maintains proper incidence and adjacency relations among the vertices and faces of a triangulation while combinatorial modifications of the triangulation are performed The term combinatorial modification refers to operations which do not involve any knowledge about the geometric embedding of the triangulation For example the insertion of a new vertex in a given face or in a given edge the suppression of a vertex of degree three the flip of two edge are examples of combinatorial operation performed at the data structure level The triangulation data structure is required to provide the types Vertex and Face for the the vertices and faces of the triangulations the type Vertex handle and Face handle which are models of the concept Handle and through which the vertices and faces are accessed iterators to visit all the vertices edges and faces of the triangulation circulators to visit all the vertices edges and faces incident to a given vertex The triangulation data structure is responsible for the creation and removal of faces and vertices memory management It provides function that gives the number of faces edges and vertices of the triangulation The triangulation data structure provides member functions to perform the following combinatorial transformation of the triangulation flip of two adjacent faces addition of a new vertex splitting a given face see Figure addition of a new vertex splitting a given edge addition of a new vertex raising by one the dimension of a degenerate lower dimensional triangulation removal of a vertex incident to three faces removal of a vertex lowering the dimension of the triangulation Figure Insertion of a new vertex splitting a face 33 3 The Default Triangulation Data Structure CGAL provides the class CGAL Triangulation data structure 2 Vb Fb as a default triangulation data structure 33 3 1 Flexibility In oder to provide flexibility the default triangulation data structure is templated by two parameters which stands respectively for a vertex base class and a face base class The concept TriangulationDSVertexBase 2 and TriangulationDSFaceBase 2 describe the requirements for the base vertex and face classes of a triangulation data structure The triangulation data structure derives from thoses base classes the vertex and face classes from thoses base classes This design allows the user to plug in the triangulation data structure his own base classes tuned for his application 33 3 2 The cyclic dependancy of template parameters Since adjacency and incidence relation are stored in vertices and faces the vertex and face base classes have to know the types of handles on faces and vertices provided by the triangulation data structure Therefore vertex and base classes need to be templated by the triangulation data structure Because the triangulation data structure is itself templated by the vertex and base classes this induces a cyclic dependancy See figure Figure The cyclic dependency in triangulations software design 33 3 3 The rebind mecanism The solution proposed by CGAL to resolve this cyclic dependency is based on a rebind mecanism similar to the mecanism used in the standard allocator class std allocator The vertex and face base classes plugged in the instantiation of a triangulation data structure are themselves instantiated with a fake data structure The triangulation data structure will then rebind these classes plugging itself at the place of the fake data structure before using them to derive the vertex and face classes The rebinding is performed through a nested template class Rebind TDS in the vertex and face base class which provide the rebound class as a type called Other Here is how it works schematically First here is the rebinding taking place in the triangulation data stucture template class Vb class Fb class Triangulation data structure typedef Triangulation data structure Vb Fb Self Rebind the vertex and face base to the actual TDS Self typedef typename Vb template Rebind TDS Self Other VertexBase typedef typename Fb template Rebind TDS Self Other FaceBase further internal machinery leads to the final public types public typedef Vertex typedef Face typedef Vertex handle typedef Face handle Then here is the vertex base class with its nested Rebind TDS template class and its template parameter set by default to an an internal type faking a triangulation data structure template class TDS an internal type faking a triangulation data structure class Vertex base public template class TDS2 struct Rebind TDS typedef Vertex base TDS2 Other Imagine an analog Face base class The triangulation data structure is then instantiate as follows typedef Triangulation data structure Vertex base Face base TDS 33 3 4 Making use of the flexibility There is several possibilities to make use of the flexibility offered by the triangulation data structure First when the user needs to have in vertices and faces additionnal informations which do not depend on types defined by the triangulated data structure predefined classes Triangulation vertex base with info and Triangulation face base with info can be plugged in Those classes have a template parameter Info to be instantiated by a user defined type They store a data member of this type and gives acces to it Second the user can derive his own base classes from the default base classes Triangulation ds vertex base 2 and Triangulation ds face base 2 are the default base classes to be plugged in a triangulation data structure used alone Triangulation classes requires a data strucure in which other base classes have been plugged it The default base classes for most of the triangulation classes are Triangulation vertex base 2 and Triangulation face base 2 are the default base classes to be used when the triangulation data structure is plugged in a triangulation class When derivation is used the rebind mecanism is slightly more involved because it is necessary to rebind the base class itself However the user will be able to use in his classes references to types provided by the triangulation data structure For example template class Gt class Vb CGAL Triangulation vertex base 2 Gt class My vertex base public Vb public template typename TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 typedef My vertex base Gt Vb2 Other typedef typename Vb Triangulation data structure Tds typedef typename Tds Vertex handle Vertex handle At last the user can write his own base classes If the triangulation data structure is used alone the requirements for the base classes are described by the concepts TriangulationDSVertexBase 2 and TriangulationDSFaceBase 2 If the triangulation data structure is plugged into a triangulation class the concepts for the vertex and base classes depends on the triangulation class The most basic concepts valid for basic and Delaunay triangulations are TriangulationVertexBase 2 and TriangulationFaceBase 2 See section for examples of using the triangulation data structure flexibility Next chapter 2D Triangulation Data Structure Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/TDS_2/Chapter_main.html", "title": "2d triangulation data structure", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './TDS_2/main.tex' -->\n<html> <head>  \n<title>2D Triangulation Data Structure</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_33\"></a>\n  \n<h1>Chapter 33<BR>2D Triangulation Data Structure</h1>\n \n<A NAME=\"user_chapter_2D_Triangulation_Data_Structure\"></A>\n<A NAME=\"Chapter_2D_Triangulation_Data_Structure\"></A>\n<EM>Sylvain Pion  and Mariette Yvinec</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>33.1&nbsp;&nbsp;&nbsp;Definition</h2>\n\n<A NAME=\"2D_TDS_Definition\"></A>\nA triangulation data structure is a data structure designed\nto handle the representation of a two dimensional\ntriangulation. The concept of triangulation data structure\nwas primarily designed to serve as a data structure\nfor C<SMALL>GAL</SMALL> 2D triangulation classes which are triangulations\nembedded in a plane.\nHowever it appears that the concept is more general\nand can be used for any  orientable triangulated surface\nwithout boundary, whatever may be the dimensionality\nof the space the trianguation is embedded in.\n<P>\n\n<h3>33.1.1&nbsp;&nbsp;&nbsp;A data structure based on faces and vertices</h3>\n<P>\n\nThe representation of C<SMALL>GAL</SMALL> 2D triangulations is based on faces and vertices,\nEdges are only implicitely \nrepresented trough the adjacency relations betwen two\nfaces.\n<P>\n\nThe triangulation data structure can be seen \nas a container for faces and vertices\nmaintaining incidence and adjacency relations\namong them.\n<P>\n\nEach triangular face gives access to its three incident vertices \nand to its three adjacent faces. \nEach vertex gives access to one of its incident faces\nand through that face to the circular list of its incident faces.\n<P>\n\nThe three vertices of a face are indexed with 0, 1 and 2.\nThe neighbor of a face are also \nindexed with 0,1,2 in such a way that the neighbor indexed by <I>i</I>\nis <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex with the same index.\nSee Figure&nbsp;<A HREF=\"Chapter_main.html#2D_TDS_Fig_neighbors1\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, \n the functions <I>ccw(i)</I>\nand <I>cw(i)</I> shown  on this figure\ncompute respectively <MATH><I>i+1</I></MATH> and <MATH><I>i-1</I></MATH> modulo 3\n<P>\n\nEach edge has two implicit representations : the edge\nof a face <I>f</I>  which is opposed to the vertex indexed <I>i</I>,\ncan be represented as well as an edge of the <I>neighbor(i)</I> of \n<I>f</I>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Vertices and neighbors. \n    <A NAME=\"2D_TDS_Fig_neighbors1\"></A>\n  \n<CENTER>\n<img border=0  src=\"./rep_bis.gif\" width=400 align=center alt=\"Neighbors\">\n</CENTER>\n<P>\n\nThis kind or representation of simplicial complexes extends in any\ndimension. More precisely, in dimension <MATH><I>d</I></MATH>, the data structure\nwill explicitely represents cells (i. e. faces of maximal dimension) \nand vertices (i. e. faces of dimension 0).\nAll faces of dimension between <MATH><I>1</I></MATH> and <MATH><I>d-1</I></MATH>\nwill have an implicit representation.\nThe 2D triangulation data structure can represent simplicial complexes\nof dimension 2, 1 or 0.\n<P>\n\n<h3>33.1.2&nbsp;&nbsp;&nbsp;The set of faces and vertices</h3>\n\n The set of faces  maintained by a 2D triangulation \ndata structure is such that each edge\nis incident to two faces. In other words,\nthe set of maintained faces \nis topologically\nequivalent to a two-dimensional triangulated sphere.\n<P>\n\nThis rules extends to  lower dimensional triangulation data structure\narising in degenerate cases or when the triangulations\nhave less than three vertices.\nA one dimensional triangulation structure maintains a set of vertices\n and edges which forms a ring \ntopologically equivalent to a <MATH><I>1</I></MATH>-sphere.\n<P>\n\nA zero dimensional triangulation data structure\nonly includes two adjacent vertices \nthat is\ntopologically equivalent to a <MATH><I>0</I></MATH>-sphere.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>33.2&nbsp;&nbsp;&nbsp;The Concept of Triangulation Data Structure</h2>\n\n<A NAME=\"2D_TDS_Concept\"></A>\nA model of <I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I>\ncan be seen has a container for the \nfaces and vertices of the triangulation.\nThis class is also responsible for the combinatorial\nintegrity of the triangulation. This means that\nthe triangulation data structure \nmaintains  proper incidence and adjacency relations among the vertices\nand faces of a triangulation while\ncombinatorial modifications\nof the triangulation are performed.\nThe term  combinatorial modification \nrefers to  operations which do not \ninvolve any knowledge about the geometric embedding of the triangulation.\nFor example, the  \ninsertion of a new vertex in a given face, or in a given edge,\nthe suppression\nof a vertex of degree three,  the flip of two edge are \nexamples of combinatorial operation performed at the data structure level.\n<P>\n\nThe triangulation data structure \nis required to provide :\n<UL>\n<LI>the types <I>Vertex</I> and <I>Face</I> for the the vertices\nand faces of the triangulations\n<LI>the type <I>Vertex_handle</I> and <I>Face_handle</I>\nwhich are models of the concept <I><A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A></I> and \nthrough which the vertices and faces are accessed.\n<LI>iterators to visit all the vertices, edges and faces\nof the triangulation,\n<LI>circulators to visit all the vertices, edges and faces\nincident to a given vertex\n</UL>\n<P>\n\nThe triangulation data structure is responsible \nfor the creation and removal of faces and vertices \n(memory management).\nIt provides function that gives the number of faces, edges and\nvertices\nof the triangulation.\n<P>\n\nThe triangulation data structure provides member functions\nto perform the following  combinatorial transformation of the triangulation:<BR>\n\n<UL>\n<DT><B>-</B><DD> flip of two adjacent faces,<BR>\n\n<DT><B>-</B><DD> addition  of a new vertex splitting a given face \nsee Figure&nbsp;<A HREF=\"Chapter_main.html#2D_TDS_Fig_insertion\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>,<BR>\n\n<DT><B>-</B><DD> addition  of a new vertex splitting a given edge,<BR>\n\n<DT><B>-</B><DD> addition of a new vertex raising by one the dimension of a degenerate\n- lower dimensional triangulation,<BR>\n\n<DT><B>-</B><DD> removal of a vertex incident to three faces,<BR>\n\n<DT><B>-</B><DD> removal of a vertex lowering the dimension of the triangulation<BR>\n\n</UL>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Insertion of a new vertex, splitting a face\n <A NAME=\"2D_TDS_Fig_insertion\"></A>\n\n<CENTER>\n<img border=0 src=\"Three.gif\" align=center alt=\"Insertion\">\n</CENTER>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>33.3&nbsp;&nbsp;&nbsp;The Default Triangulation Data Structure</h2>\n\n<A NAME=\"2D_TDS_default\"></A>\n<P>\n\nC<SMALL>GAL</SMALL> provides the class\n<I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I>\nas a default triangulation data structure.\n<P>\n\n<h3>33.3.1&nbsp;&nbsp;&nbsp;Flexibility</h3>\n\nIn oder to provide flexibility, the default triangulation data\nstructure is templated by two parameters \nwhich stands respectively for a vertex base class and a face base\nclass.\nThe concept \n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDSVertexBase_2.html#Cross_link_anchor_963\">TriangulationDSVertexBase_2</A></I> and \n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDSFaceBase_2.html#Cross_link_anchor_961\">TriangulationDSFaceBase_2</A></I> describe the requirements for the\nbase vertex and face classes of a triangulation data structure.\n<P>\n\nThe triangulation data structure \nderives from thoses base classes the\nvertex and face classes from thoses base classes.\nThis design  allows the user to plug in the\ntriangulation data structure\nhis own base classes tuned for  his application.\n<P>\n\n<h3>33.3.2&nbsp;&nbsp;&nbsp;The cyclic dependancy of template parameters</h3>\n\n Since adjacency and incidence relation are stored in vertices and\nfaces,\nthe vertex and face base classes have to know the types\nof handles on faces and vertices provided by the triangulation data\nstructure.\nTherefore , vertex and base classes need to be templated \nby the triangulation data structure. Because the triangulation\ndata structure \nis itself templated by the vertex and base classes this induces\na cyclic dependancy.\nSee figure&nbsp;<A HREF=\"Chapter_main.html#2D_TDS_Fig_three_levels_2\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The cyclic dependency in triangulations software design.\n<A NAME=\"2D_TDS_Fig_three_levels_2\"></A>\n\n<CENTER><BR>\n\n<img border=0 src=\"./threelevels2.gif\" align=center alt=\"Three_levels\">\n</CENTER>\n<P>\n\n<h3>33.3.3&nbsp;&nbsp;&nbsp;The rebind mecanism</h3>\n<P>\n\nThe solution proposed by C<SMALL>GAL</SMALL> to resolve this cyclic dependency\nis based on a rebind mecanism similar to the mecanism used in the \nstandard allocator class std::allocator.\nThe vertex and face base classes plugged in the instantiation of a\ntriangulation data structure are themselves instantiated with a\nfake data structure. The triangulation data structure\nwill then rebind  these classes, plugging itself\nat the place of the fake data structure, before using them\nto derive  the vertex and face classes. The rebinding is performed\nthrough a nested template class  <I>Rebind_TDS</I> in the vertex and\nface base class, which provide the rebound class\nas a type called  <I>Other</I>.\n<P>\n\nHere is how it works schematically. First, here is the rebinding\ntaking place in the triangulation data stucture.\n<pre class=\"ExampleCode\">\ntemplate &lt; class Vb, class Fb &gt;\nclass Triangulation_data_structure\n{\n  typedef Triangulation_data_structure&lt;Vb,Fb&gt;    Self;\n\n  // Rebind the vertex and face base to the actual TDS (Self).\n  typedef typename Vb::template Rebind_TDS&lt;Self&gt;::Other  VertexBase;\n  typedef typename Fb::template Rebind_TDS&lt;Self&gt;::Other  FaceBase;\n\n  // ... further internal machinery leads to the final public types:\npublic:\n  typedef ...  Vertex;\n  typedef ...  Face;\n  typedef ...  Vertex_handle;\n  typedef ...  Face_handle;\n};\n</pre>\n<P>\n\nThen, here is the vertex base class with its nested \n <I>Rebind_TDS</I> template class and its template parameter\nset by default to an an internal type faking a  triangulation data \nstructure.\n<pre class=\"ExampleCode\">\ntemplate &lt; class TDS = an internal type faking a triangulation data \nstructure &gt;\nclass Vertex_base\n{\npublic:\n  template &lt; class TDS2 &gt;\n  struct Rebind_TDS {\n    typedef Vertex_base&lt;TDS2&gt;    Other;\n  };\n...\n};\n</pre>\nImagine an analog <I>Face_base</I> class.\nThe triangulation data structure is then instantiate as follows&nbsp;:\n<pre class=\"ExampleCode\">\ntypedef Triangulation_data_structure&lt; Vertex_base&lt;&gt;, Face_base&lt;&gt; &gt; TDS;\n</pre>\n<P>\n\n<h3>33.3.4&nbsp;&nbsp;&nbsp;Making use of the flexibility</h3>\n<P>\n\nThere is several possibilities to make use\nof the flexibility offered by \nthe triangulation data structure.\n<UL>\n<LI> First, when the user needs to have,\nin vertices and faces, additionnal informations \nwhich do not depend on types defined by the\ntriangulated data structure,  predefined classes \n<I>Triangulation_vertex_base_with_info</I>\nand <I>Triangulation_face_base_with_info</I> can be plugged in.\nThose classes have a template parameter <I>Info</I> to be instantiated\nby a user defined type. They\nstore a data member of this type and gives acces to it.\n<LI> Second, the user  can derive \nhis own base classes from the default base\nclasses :\n<I><A HREF=\"../TDS_2_ref/Class_Triangulation_ds_vertex_base_2.html#Cross_link_anchor_970\">Triangulation_ds_vertex_base_2</A></I>, and\n<I><A HREF=\"../TDS_2_ref/Class_Triangulation_ds_face_base_2.html#Cross_link_anchor_968\">Triangulation_ds_face_base_2</A></I>\nare the default base classes to be plugged in a triangulation \ndata structure used alone.\nTriangulation classes requires a data strucure in which\nother base classes have been plugged it. The default base classes\nfor most of the triangulation classes are\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_955\">Triangulation_vertex_base_2</A></I>, and <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_2.html#Cross_link_anchor_947\">Triangulation_face_base_2</A></I>\nare the default base classes to be used when the triangulation data\nstructure is plugged in a triangulation class.\n<P>\n\nWhen derivation is used, the rebind mecanism is slightly\nmore involved, because it is necessary to rebind the  base class\nitself. However the user will be able to use in his classes\nreferences to types provided by the triangulation data structure.\nFor example,\n<pre class=\"ExampleCode\">\ntemplate &lt; class Gt, class Vb = <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;Gt&gt; &gt;\nclass My_vertex_base \n  : public  Vb\n{\npublic :\n  template &lt; typename TDS2 &gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other    Vb2;\n    typedef My_vertex_base&lt;Gt,Vb2&gt;                           Other;\n  };\n\n  typedef typename Vb::Triangulation_data_structure    Tds;\n  typedef typename Tds::Vertex_handle                  Vertex_handle;\n  ......\n};\n</pre>\n<P>\n\n<LI> At last the user can write his own base classes.\nIf the triangulation data structure is used alone, \nthe requirements for the base classes are described by the concepts\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDSVertexBase_2.html#Cross_link_anchor_963\">TriangulationDSVertexBase_2</A></I> \nand <I><A HREF=\"../TDS_2_ref/Concept_TriangulationDSFaceBase_2.html#Cross_link_anchor_961\">TriangulationDSFaceBase_2</A></I>.\nIf the triangulation data structure is plugged into a triangulation\nclass,\nthe concepts for the vertex and base classes depends on the\ntriangulation class. The most basic concepts, valid for\nbasic and Delaunay triangulations are <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationVertexBase_2.html#Cross_link_anchor_937\">TriangulationVertexBase_2</A></I> \nand <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationFaceBase_2.html#Cross_link_anchor_934\">TriangulationFaceBase_2</A></I>.\n</UL>\n<P>\n\nSee section&nbsp;<A HREF=\"../Triangulation_2/Chapter_main.html#Section_2D_Triangulations_Flexibility\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> \nfor examples of using the triangulation data structure flexibility.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../TDS_2_ref/Chapter_intro.html\">2D Triangulation Data Structure</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_33!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38201.0}