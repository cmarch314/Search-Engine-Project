{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL optimal convex partition 2 Function that produces a set of convex polygons that represent a partitioning of a polygon defined on a sequence of points The number of convex polygons produced is minimal include CGAL partition 2 h template class InputIterator class OutputIterator class Traits OutputIterator optimal convex partition 2 InputIterator first InputIterator beyond OutputIterator result Traits traits Default traits computes a partition of the polygon defined by the points in the range first beyond into convex polygons The counterclockwise oriented partition polygons are written to the sequence starting at position result The past the end iterator for the resulting sequence of polygons is returned Precondition The points in the range first beyond define a simple counterclockwise oriented polygon Requirements Traits is a model of the concept OptimalConvexPartitionTraits 2 For the purposes of checking the postcondition that the partition is valid Traits should also be a model of ConvexPartitionIsValidTraits 2 OutputIterator value type should be Traits Polygon 2 InputIterator value type should be Traits Point 2 which should also be the type of the points stored in an object of type Traits Polygon 2 The default traits class Default traits is Partition traits 2 with the representation type determined by InputIterator value type See AlsoCGAL approx convex partition 2 CGAL convex partition is valid 2 CGAL greene approx convex partition 2 CGAL partition is valid 2 CGAL Partition is valid traits 2 Traits PolygonIsValid ImplementationThis function implements the dynamic programming algorithm of Greene Gre83 which requires O n4 time and O n3 space to produce a partitioning of a polygon with n vertices Example The following program computes an optimal convex partitioning of a polygon using the default traits class and stores the partition polygons in the list partition polys It then asserts that the partition produced is valid The traits class used for testing the validity is derived from the traits class used to produce the partition with the function object class CGAL Is convex 2 used to define the required Is valid type Note that this assertion is superfluous unless the postcondition checking for optimal convex partition 2 has been turned off file examples Partition 2 optimal convex ex C include CGAL basic h include CGAL Exact predicates inexact constructions kernel h include CGAL Partition traits 2 h include CGAL Partition is valid traits 2 h include CGAL polygon function objects h include CGAL partition 2 h include CGAL point generators 2 h include CGAL random polygon 2 h include cassert include list typedef CGAL Exact predicates inexact constructions kernel K typedef CGAL Partition traits 2 K Traits typedef CGAL Is convex 2 Traits Is convex 2 typedef Traits Polygon 2 Polygon 2 typedef Traits Point 2 Point 2 typedef Polygon 2 Vertex const iterator Vertex iterator typedef std list Polygon 2 Polygon list typedef CGAL Partition is valid traits 2 Traits Is convex 2 Validity traits typedef CGAL Creator uniform 2 int Point 2 Creator typedef CGAL Random points in square 2 Point 2 Creator Point generator void make polygon Polygon 2 polygon polygon push back Point 2 391 374 polygon push back Point 2 24 431 polygon push back Point 2 252 34 polygon push back Point 2 374 32 polygon push back Point 2 289 214 polygon push back Point 2 134 39 polygon push back Point 2 68 186 polygon push back Point 2 154 259 polygon push back Point 2 161 1 7 polygon push back Point 2 435 1 8 polygon push back Point 2 2 8 148 polygon push back Point 2 295 16 polygon push back Point 2 421 212 polygon push back Point 2 441 3 3 int main Polygon 2 polygon Polygon list partition polys Traits partition traits Validity traits validity traits CGAL random polygon 2 5 std back inserter polygon Point generator 1 make polygon polygon CGAL optimal convex partition 2 polygon vertices begin polygon vertices end std back inserter partition polys partition traits assert CGAL partition is valid 2 polygon vertices begin polygon vertices end partition polys begin partition polys end validity traits return Next partition is valid 2 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Partition_2_ref/Function_optimal_convex_partition_2.html", "title": "optimal_convex_partition_2", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Partition_2_ref/optimal_convex_partition_2.tex' -->\n<html> <head>  \n<title>optimal_convex_partition_2</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_705\"></A>\n\n<A NAME=\"Cross_link_anchor_706\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_724\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Function.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::optimal_convex_partition_2\"></A>\n<h2><I>CGAL::optimal_convex_partition_2</I></h2>\n<P>\n\nFunction that produces a set of convex polygons \nthat represent a partitioning of a polygon defined on a sequence of \npoints. \nThe number of convex polygons produced is minimal.\n   \n     \n     \n     \n<A NAME=\"Index_anchor_725\"></A>\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/partition_2.h\">CGAL/partition_2.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator, class OutputIterator, class Traits&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_optimal_convex_partition_26InputIterator_first+_InputIterator_beyond+_OutputIterator_result+_const_Traits__traits_=_Default_traits9;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Function_optimal_convex_partition_2.html#Cross_link_anchor_706\">optimal_convex_partition_2</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator beyond,<BR>\n\nOutputIterator result,<BR>\n\nTraits traits = Default_traits)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    computes a partition of the polygon defined\nby the points in the range [<I>first</I>, <I>beyond</I>) into convex\npolygons. The counterclockwise-oriented partition polygons are written to\nthe sequence starting at position <I>result</I>.  The past-the-end iterator for\nthe resulting sequence of polygons is returned.<BR>\n\n<EM>Precondition: </EM>The points in the range [<I>first</I>, <I>beyond</I>) define a\nsimple, counterclockwise-oriented polygon.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Requirements</H3>\n<OL>\n    <LI><I>Traits</I> is a model of the concept <A HREF=\"Concept_OptimalConvexPartitionTraits_2.html#Cross_link_anchor_681\">OptimalConvexPartitionTraits_2</A>\n<A NAME=\"Index_anchor_726\"></A> \n.\n          For the purposes of checking the\n          postcondition that the partition is valid, <I>Traits</I> should\n          also be a model of <A HREF=\"Concept_ConvexPartitionIsValidTraits_2.html#Cross_link_anchor_679\">ConvexPartitionIsValidTraits_2</A>.\n          \n<A NAME=\"Index_anchor_727\"></A> \n\n    <LI><I>OutputIterator::value_type</I> should be\n          <I>Traits::<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A></I>.\n    <LI><I>InputIterator::value_type</I> should be <I>Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>,\n          which should also be the type of the points stored in an object\n          of type <I>Traits::<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A></I>.\n</OL>\n<P>\n\nThe default traits class <I>Default_traits</I> is <I><A HREF=\"Class_Partition_traits_2.html#Cross_link_anchor_690\">Partition_traits_2</A></I>,\nwith the representation type determined by <I>InputIterator::value_type</I>.\n<P>\n\n<H3>See Also</H3><I><A HREF=\"Function_approx_convex_partition_2.html#Cross_link_anchor_697\">CGAL::approx_convex_partition_2</A></I><BR>\n\n<I><A HREF=\"Function_convex_partition_is_valid_2.html#Cross_link_anchor_699\">CGAL::convex_partition_is_valid_2</A></I><BR>\n\n<I><A HREF=\"Function_greene_approx_convex_partition_2.html#Cross_link_anchor_701\">CGAL::greene_approx_convex_partition_2</A></I><BR>\n\n<I><A HREF=\"Function_partition_is_valid_2.html#Cross_link_anchor_707\">CGAL::partition_is_valid_2</A></I><BR>\n\n<I><A HREF=\"Class_Partition_is_valid_traits_2.html#Cross_link_anchor_687\">CGAL::Partition_is_valid_traits_2</A>&lt;Traits, <A HREF=\"FunctionObjectConcept_PolygonIsValid.html#Cross_link_anchor_686\">PolygonIsValid</A>&gt;</I>\n<P>\n\n<H3>Implementation</H3>This function implements the dynamic programming algorithm of Greene \n[<A HREF=\"../biblio.html#Biblio_g-dpcp-83\">Gre83</A>], which requires <MATH><I>O(n<SUP>4</SUP>)</I></MATH> time and <MATH><I>O(n<SUP>3</SUP>)</I></MATH> space to\nproduce a partitioning of a polygon with <MATH><I>n</I></MATH> vertices.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe following program computes an optimal\nconvex partitioning of a polygon using the default\ntraits class and stores the partition polygons in the list \n<I>partition_polys</I>.  \nIt then asserts that the partition produced is valid.  The\ntraits class used for testing the validity is derived from the\ntraits class used to produce the partition with the function object\nclass <I><A HREF=\"FunctionObjectClass_Is_convex_2.html#Cross_link_anchor_691\">CGAL::Is_convex_2</A></I>\n<A NAME=\"Index_anchor_728\"></A> \n used\nto define the required <I>Is_valid</I> type. \n(Note that this assertion is superfluous unless the \npostcondition checking for <I><A HREF=\"Function_optimal_convex_partition_2.html#Cross_link_anchor_706\">optimal_convex_partition_2</A></I> has been\nturned off.)\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Partition_2/optimal_convex_ex.C\n\n#include &lt;CGAL/basic.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Partition_traits_2.html#Cross_link_anchor_690\">Partition_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Partition_is_valid_traits_2.html#Cross_link_anchor_688\">Partition_is_valid_traits_2</A>.h&gt;\n#include &lt;CGAL/polygon_function_objects.h&gt;\n#include &lt;CGAL/partition_2.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../Generator_ref/Function_random_polygon_2.html#Cross_link_anchor_1686\">random_polygon_2</A>.h&gt;\n#include &lt;cassert&gt;\n#include &lt;list&gt;\n\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> K;\ntypedef <A HREF=\"Class_Partition_traits_2.html#Cross_link_anchor_689\">CGAL::Partition_traits_2</A>&lt;K&gt;                         Traits;\ntypedef <A HREF=\"FunctionObjectClass_Is_convex_2.html#Cross_link_anchor_691\">CGAL::Is_convex_2</A>&lt;Traits&gt;                           <A HREF=\"FunctionObjectClass_Is_convex_2.html#Cross_link_anchor_692\">Is_convex_2</A>;\ntypedef Traits::<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>                                   <A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                     <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef <A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>::Vertex_const_iterator                    Vertex_iterator;\ntypedef std::list&lt;<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&gt;                                Polygon_list;\ntypedef <A HREF=\"Class_Partition_is_valid_traits_2.html#Cross_link_anchor_687\">CGAL::Partition_is_valid_traits_2</A>&lt;Traits, <A HREF=\"FunctionObjectClass_Is_convex_2.html#Cross_link_anchor_692\">Is_convex_2</A>&gt;\n                                                            Validity_traits;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1565\">CGAL::Creator_uniform_2</A>&lt;int, <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&gt;               Creator;\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_in_square_2.html#Cross_link_anchor_1699\">CGAL::Random_points_in_square_2</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>, Creator&gt;   Point_generator;\n\nvoid make_polygon(<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&amp; polygon)\n{\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(391, 374));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(240, 431));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(252, 340));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(374, 320));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(289, 214));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(134, 390));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>( 68, 186));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(154, 259));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(161, 107));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(435, 108));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(208, 148));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(295, 160));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(421, 212));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(441, 303));\n}\n\nint main()\n{\n   <A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>             polygon;\n   Polygon_list          partition_polys;\n   Traits                partition_traits;\n   Validity_traits       validity_traits;\n\n/*\n   <A HREF=\"../Generator_ref/Function_random_polygon_2.html#Cross_link_anchor_1685\">CGAL::random_polygon_2</A>(50, std::back_inserter(polygon), \n                          Point_generator(100));\n*/\n   make_polygon(polygon);\n   <A HREF=\"Function_optimal_convex_partition_2.html#Cross_link_anchor_705\">CGAL::optimal_convex_partition_2</A>(polygon.vertices_begin(), \n                                    polygon.vertices_end(),\n                                    std::back_inserter(partition_polys),\n                                    partition_traits);\n   assert(<A HREF=\"Function_partition_is_valid_2.html#Cross_link_anchor_707\">CGAL::partition_is_valid_2</A>(polygon.vertices_begin(), \n                                     polygon.vertices_end(),\n                                     partition_polys.begin(), \n                                     partition_polys.end(),\n                                     validity_traits));\n   return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_partition_is_valid_2.html\"><I>partition_is_valid_2</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_10!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39489.0}