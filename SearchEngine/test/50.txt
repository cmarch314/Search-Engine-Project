{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example The C Standard Library The moniker for this code example is StandardLibrary Background Like most industrial strength programming languages C provides a standard library of tools that augment what is built directly into the language We ve already used some parts of the C Standard Library in our work this quarter we ve used I O tools like those declared in the iostream header the std string type and a small handful of others But the library is more extensive than the parts we ve seen so this example begins exploring parts of the library we ve yet to see One of the core parts of the C Standard Library is a set of commonly useful data structures and algorithms which are some of the most immediately valuable pieces of the library when you want to write programs in C more quickly The need for common data structures like array based sequences known in C as vectors linked lists known in C as lists or for common algorithms such as finding an object in a data structure that has a particular property or summing the numbers in a collection of numbers is pervasive it s hard to imagine very many interesting programs that don t require some kind of data structure or a common algorithm So C provides a collection of these right out of the box and that collection has gotten larger in recent years as C has undergone its C 11 and C 14 standardization efforts This code example focuses on data structures and algorithms in the C Standard Library Rather than exhaustively demonstrating all of them it aims to show the general design that is common to all of them once you understand how the parts of the library fit together you ll find yourself more easily able to look up the details in documentation when you need them Containers generic algorithms and iterators The C Standard Library provides its data structures and algorithms in a portion of the library that is split roughly into three interlocking parts Containers The C Standard Library provides a set of what are called containers or data structures such as std vector an array based sequence in the same spirit as the ArrayList class we wrote in a previous example std list a doubly linked list with head and tail pointers and std map a balanced binary search tree of key value pairs While each of these containers supports a slightly different set of operations there are similarities wherever such similarities make sense so you ll find it easier to learn about ones you haven t seen after you ve learned about one of them Interestingly inheritance is not used to enforce commonalities in other words not all container classes inherit from a common base class the way they do in some other object oriented implementations such as the Java Collections Framework that s included in Java s standard library Instead the containers are built substantially out of C templates which do not require inheritance as a mechanism to relate types that have syntactically similar features e g public member functions with the same name or similarly overloaded operators The containers are type generic meaning that different vectors can be specified to hold different kinds of elements though like everything else in C each one will be specified to hold a particular kind The syntax for this is generally driven by type parameters which become part of the container s type listed within angle brackets So for example a std vector int is a vector in which each element is an integer These type parameters are not optional each time you use the std vector type e g by declaring a variable that stores a vector you ll be required to pass at least a type parameter that configures the type of element to be stored in the vector In other words there s no such thing as a std vector there are only std vector int s std vector std string s and so on Each of these separate instantiations of the std vector template are separate incompatible types Generic algorithms In addition to containers the C Standard Library provides a set of generic algorithms which generalize commonly occurring operations that you might like to perform such as these Apply the same function to each of a range of valuesFind a value in a range of values that has a particular interesting property e g is a positive number is a student whose age is greater than 21 etc Remove from a range of values the ones that have a particular interesting propertyShuffle the values in a range of values randomly so they appear in a different randomly determined order than they did beforeSort the values in a range of values possibly given an arbitrary function to decide which of each pair of values should appear earlier in the sorted sequence Algorithms such as these would typically manifest themselves in your programs as loops or more complex functions that you might find yourself having to write The generic algorithms in the C Standard Library remove the need to write a lot of these kinds of things shortening and clarifying the programs you write so that you can not only write them more quickly but so that you can understand them better when you read them The algorithms generally are not aware of what kind of container they re operating on which means they generally work on all of the containers in the standard library except for those for which they don t make sense such as sorting the values in a std unordered set What s more if you write a container implementation yourself you can apply the generic algorithms in the standard library to your container provided that you follow the typical C design for a container if you write a generic algorithm yourself you can apply it to any of the containers in the standard library So how does an algorithm operate on the values in a container without depending on or even being aware of what kind of container it is The answer lies in the third of the interlocking parts iterators Iterators In the C Standard Library iterators form the glue between the containers and the generic algorithms An iterator is an abstraction for a position in a container whose main role is the provide access to the value stored in that position e g in a particular cell of a std vector while hiding all of the details about the container s underlying implementation Given an iterator a generic algorithm can access and potentially modify the values stored in a container without having to know what kind of container it is meaning that existing generic algorithms will work with new containers you build and that new generic algorithms can easily work with many of the existing containers This idea makes for quite a flexible arrangement which depends only on agreeing on how to manipulate iterators Syntactically iterators behave a lot like pointers In some cases that s what they actually are in others they re more complex But they support the same basic operators either way You can use the operator to dereference an iterator just like you can use the operator to dereference a pointer The effect is the same given an iterator i pointing to a position containing a value v i would give you access to the value v As with pointers you could do this on either side of an assignment so you could read the value of v or you could change it The operator moves an iterator forward i e to the next position in the container The operator moves an iterator backward i e to the previous position in the container You can sometimes use other kinds of arithmetic e g given an iterator i writing i 3 can be legal which mirrors the pointer arithmetic we ve seen previously Iterators support whichever operations are sensible for the kind of container they re iterating and they are categorized on the basis of which operations they support A few examples of those categorizations are Forward iterators which are able to iterate through a container in one direction forward one position at a time but no other This means they support dereferencing and iterating forward Bidirectional iterators which are able to do everything that forward iterators can do plus iterate backward i e they also support Random access iterators which are able to do everything that bidirectional iterators can do plus arbitrary jumps using pointer arithmetic like syntax Depending on what kind of container you re iterating you ll get a different kind of iterator back For example std vector provides random access iterators because arrays which underlie a vector provide constant time access to any cell given its index On the other hand std list a doubly linked list would provide only a bidirectional iterator and std forward list a singly linked list would provide only a forward iterator because other operations would be too expensive for an algorithm to reasonably rely on Finding out more After working through this code example it s not a bad idea to spend a little bit of time experimenting with a few of the containers and generic algorithms not discussed here such as the std map and std list containers and the std find and std sort algorithms so you can get a sense of how they work A lot of good information can be found online but as usual the trick is to separate what s useful from what s worthless I ve found that a good place to start is cppreference com which I find to be the most comprehensive and well written reference documentation for the C Standard Library online You may disagree and in general that s fine Use what you d like But if you re not sure where to start use cppreference com This will give you an idea of what s available and will show you the details of how it works underneath though you might also want to look in other places to see concrete examples of these details in action The code The official moniker for this code example is StandardLibrary so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code StandardLibrary to download the code example into your project directory s src directory Alternatively you can click the link to the tarball below StandardLibrary tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/StandardLibrary/", "title": "ics 45c fall 2014, code example: the c++ standard library", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: The C++ Standard Library</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: The C++ Standard Library</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>StandardLibrary</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Like most industrial-strength programming languages, C++ provides a <i>standard library</i> of tools that augment what is built directly into the language.  We've already used some parts of the C++ Standard Library in our work this quarter: we've used I/O tools like those declared in the <b>&lt;iostream&gt;</b> header, the <b>std::string</b> type, and a small handful of others.  But the library is more extensive than the parts we've seen, so this example begins exploring parts of the library we've yet to see.</p>\r\n\r\n<p>One of the core parts of the C++ Standard Library is a set of commonly-useful data structures and algorithms, which are some of the most immediately valuable pieces of the library when you want to write programs in C++ more quickly.  The need for common data structures like array-based sequences (known in C++ as <i>vectors</i>), linked lists (known in C++ as <i>lists</i>), or for common algorithms such as finding an object in a data structure that has a particular property, or summing the numbers in a collection of numbers, is pervasive; it's hard to imagine very many interesting programs that don't require some kind of data structure or a common algorithm.  So C++ provides a collection of these right out of the box &mdash; and that collection has gotten larger in recent years, as C++ has undergone its C++11 and C++14 standardization efforts.</p>\r\n\r\n<p>This code example focuses on data structures and algorithms in the C++ Standard Library.  Rather than exhaustively demonstrating all of them, it aims to show the general design that is common to all of them; once you understand how the parts of the library fit together, you'll find yourself more easily able to look up the details in documentation when you need them.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Containers, generic algorithms, and iterators</p>\r\n\r\n<p>The C++ Standard Library provides its data structures and algorithms in a portion of the library that is split, roughly, into three interlocking parts.</p>\r\n\r\n<p class=\"subtitle\">Containers</p>\r\n\r\n<p>The C++ Standard Library provides a set of what are called <i>containers</i> (or data structures), such as <b>std::vector</b> (an array-based sequence, in the same spirit as the ArrayList class we wrote in a previous example), <b>std::list</b> (a doubly-linked list with head and tail pointers), and <b>std::map</b> (a balanced binary search tree of key/value pairs).  While each of these containers supports a slightly different set of operations, there are similarities wherever such similarities make sense, so you'll find it easier to learn about ones you haven't seen after you've learned about one of them.</p>\r\n\r\n<p>Interestingly, inheritance is not used to enforce commonalities; in other words, not all container classes inherit from a common base class the way they do in some other object-oriented implementations (such as the Java Collections Framework that's included in Java's standard library).  Instead, the containers are built substantially out of C++ templates, which do not require inheritance as a mechanism to relate types that have syntactically similar features (e.g., public member functions with the same name or similarly overloaded operators).</p>\r\n\r\n<p>The containers are type-generic, meaning that different vectors can be specified to hold different kinds of elements, though, like everything else in C++, each one will be specified to hold a particular kind.  The syntax for this is generally driven by <i>type parameters</i> &mdash; which become part of the container's type &mdash; listed within angle brackets.  So, for example, a <b>std::vector&lt;int&gt;</b> is a vector in which each element is an integer.  These type parameters are not optional; each time you use the <b>std::vector</b> type (e.g., by declaring a variable that stores a vector), you'll be required to pass (at least) a type parameter that configures the type of element to be stored in the vector.  In other words, there's no such thing as a <b>std::vector</b>; there are only <b>std::vector&lt;int&gt;</b>s, <b>std::vector&lt;std::string&gt;</b>s, and so on.  Each of these separate <i>instantiations</i> of the <b>std::vector</b> template are separate, incompatible types.</p>\r\n\r\n<p class=\"subtitle\">Generic algorithms</p>\r\n\r\n<p>In addition to containers, the C++ Standard Library provides a set of <i>generic algorithms</i>, which generalize commonly-occurring operations that you might like to perform, such as these:</p>\r\n\r\n<ul>\r\n  <li>Apply the same function to each of a range of values</li>\r\n  <li>Find a value in a range of values that has a particular, interesting property (e.g., is a positive number, is a student whose age is greater than 21, etc.)</li>\r\n  <li>Remove from a range of values the ones that have a particular, interesting property</li>\r\n  <li>Shuffle the values in a range of values randomly, so they appear in a different (randomly-determined) order than they did before</li>\r\n  <li>Sort the values in a range of values, possibly given an arbitrary function to decide which of each pair of values should appear earlier in the sorted sequence</li>\r\n</ul>\r\n\r\n<p>Algorithms such as these would typically manifest themselves in your programs as loops or more complex functions that you might find yourself having to write.  The generic algorithms in the C++ Standard Library remove the need to write a lot of these kinds of things, shortening and clarifying the programs you write, so that you can not only write them more quickly, but so that you can understand them better when you read them.</p>\r\n\r\n<p>The algorithms generally are not aware of what kind of container they're operating on, which means they generally work on all of the containers in the standard library (except for those for which they don't make sense, such as sorting the values in a <b>std::unordered_set</b>).  What's more, if you write a container implementation yourself, you can apply the generic algorithms in the standard library to your container, provided that you follow the typical C++ design for a container; if you write a generic algorithm yourself, you can apply it to any of the containers in the standard library.</p>\r\n\r\n<p>So how does an algorithm operate on the values in a container without depending on &mdash; or even being aware of &mdash; what kind of container it is?  The answer lies in the third of the interlocking parts: iterators.</p>\r\n\r\n<p class=\"subtitle\">Iterators</p>\r\n\r\n<p>In the C++ Standard Library, <i>iterators</i> form the glue between the containers and the generic algorithms.  An iterator is an abstraction for a position in a container, whose main role is the provide access to the value stored in that position (e.g., in a particular cell of a <b>std::vector</b>), while hiding all of the details about the container's underlying implementation.</p>\r\n\r\n<p>Given an iterator, a generic algorithm can access (and potentially modify) the values stored in a container without having to know what kind of container it is, meaning that existing generic algorithms will work with new containers you build, and that new generic algorithms can easily work with many of the existing containers.  This idea makes for quite a flexible arrangement, which depends only on agreeing on how to manipulate iterators.</p>\r\n\r\n<p>Syntactically, iterators behave a lot like pointers.  In some cases, that's what they actually are; in others, they're more complex.  But they support the same basic operators either way.</p>\r\n\r\n<ul>\r\n  <li>You can use the <b>*</b> operator to dereference an iterator, just like you can use the <b>*</b> operator to dereference a pointer.  The effect is the same: given an iterator <b>i</b> pointing to a position containing a value <b>v</b>, <b>*i</b> would give you access to the value <b>v</b>.  As with pointers, you could do this on either side of an assignment, so you could read the value of <b>v</b> or you could change it.</li>\r\n  <li>The <b>++</b> operator moves an iterator forward (i.e., to the next position in the container).</li>\r\n  <li>The <b>--</b> operator moves an iterator backward (i.e., to the previous position in the container).</li>\r\n  <li>You can sometimes use other kinds of arithmetic (e.g., given an iterator <b>i</b>, writing <b>i + 3</b> can be legal), which mirrors the pointer arithmetic we've seen previously.</li>\r\n</ul>\r\n\r\n<p>Iterators support whichever operations are sensible for the kind of container they're iterating, and they are categorized on the basis of which operations they support.  A few examples of those categorizations are:</p>\r\n\r\n<ul>\r\n  <li><i>Forward iterators</i>, which are able to iterate through a container in one direction (forward, one position at a time) but no other.  This means they support <b>*</b> (dereferencing) and <b>++</b> (iterating forward).</li>\r\n  <li><i>Bidirectional iterators</i>, which are able to do everything that forward iterators can do, plus iterate backward (i.e., they also support <b>--</b>).</li>\r\n  <li><i>Random access iterators</i>, which are able to do everything that bidirectional iterators can do, plus arbitrary jumps using pointer-arithmetic-like syntax.</li>\r\n</ul>\r\n\r\n<p>Depending on what kind of container you're iterating, you'll get a different kind of iterator back.  For example, <b>std::vector</b> provides random-access iterators, because arrays (which underlie a vector) provide constant-time access to any cell given its index.  On the other hand, <b>std::list</b> (a doubly-linked list) would provide only a bidirectional iterator, and <b>std::forward_list</b> (a singly-linked list) would provide only a forward iterator, because other operations would be too expensive for an algorithm to reasonably rely on.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Finding out more</p>\r\n\r\n<p>After working through this code example, it's not a bad idea to spend a little bit of time experimenting with a few of the containers and generic algorithms not discussed here, such as the <b>std::map</b> and <b>std::list</b> containers and the <b>std::find</b> and <b>std::sort</b> algorithms, so you can get a sense of how they work.</p>\r\n\r\n<p>A lot of good information can be found online but, as usual, the trick is to separate what's useful from what's worthless.  I've found that a good place to start is <a href=\"http://cppreference.com/\">cppreference.com</a>, which I find to be the most comprehensive and well-written reference documentation for the C++ Standard Library online.  (You may disagree and, in general, that's fine.  Use what you'd like.  But if you're not sure where to start, use <a href=\"http://cppreference.com/\">cppreference.com</a>.)  This will give you an idea of what's available, and will show you the details of how it works underneath, though you might also want to look in other places to see concrete examples of these details in action.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>StandardLibrary</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code StandardLibrary</b> to download the code example into your project directory's <b>src</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"StandardLibrary.tar.gz\">StandardLibrary.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 50.0}