{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Triangulation 2 Traits Tds Definition The class Triangulation 2 Traits Tds is the basic class designed to handle triangulations of set of points A in the plane Such a triangulation has vertices at the points of A and its domain covers the convex hull of A It can be viewed as a planar partition of the plane whoses bounded faces are triangular and cover the convex hull of A The single unbounded face of this partition is the complementary of the convex hull of A In many applications it is convenient to deal only with triangular faces Therefore we add to the triangulation a fictitious vertex called the infinite vertex and we make each convex hull edge incident to an infinite face having as third vertex the infinite vertex In that way each edge is incident to exactly two faces and special cases at the boundary of the convex hull are simpler to deal with Figure The infinite vertex The class Triangulation 2 Traits Tds implements this point of view and therefore considers the triangulation of the set of points as a set of triangular finite and infinite faces Although it is convenient to draw a triangulation as in figure note that the infinite vertex has no significant coordinates and that no geometric predicate can be applied on it or on an infinite face A triangulation is a collection of vertices and faces that are linked together through incidence and adjacency relations Each face give access to its three incident vertices and to its three adjacent faces Each vertex give access to one of its incident faces The three vertices of a face are indexed with 1 and 2 in counterclockwise order The neighbor of a face are also indexed with 1 2 in such a way that the neighbor indexed by i is opposite to the vertex with the same index The triangulation class offer two functions int cw int i and int ccw int i which given the index of a vertex in a face compute the index of the next vertex of the same face in clockwise or counterclockwise order Thus for example the neighbor neighbor cw i is the neighbor of f which is next to neighbor i turning clockwise around f The face neighbor cw i is also the first face encountered after f when turning clockwise around vertex i of f see Figure Figure Vertices and neighbors include CGAL Triangulation 2 h ParametersThe class Triangulation 2 Traits Tds has two template parameters The first one Traits is the geometric traits it is to be instantiated by a model of the concept TriangulationTraits 2 The second parameter is the triangulation data structure it has to be instantiated by a model of the concept TriangulationDataStructure 2 By befault the triangulation data structure is instanciated by CGAL Triangulation data structure 2 CGAL Triangulation vertex base 2 Gt CGAL Triangulation face base 2 Gt Inherits FromTriangulation cw ccw 2 This class provides the functions cw i et ccw i Types typedef Traits Geom traits the traits class typedef Tds Triangulation data structure the triangulation data structure type typedef Traits Point 2t Point the point type typedef Traits Segment 2 Segment the segment type typedef Traits Triangle 2 Triangle the triangle type typedef Tds Vertex Vertex the vertex type typedef Tds Face Face the face type typedef Tds Edge Edge the edge type typedef Tds size type size type Size type an unsigned integral type typedef Tds difference type difference type Difference type a signed integral type The vertices and faces of the triangulations are accessed through handles iterators and circulators The handles are models of the concept Handle which basically offers the two dereference operators and The iterators and circulators are all bidirectional and non mutable The circulators and iterators are convertible to handles with the same value type so that whenever a handle appear in the parameter list of a function an appropriate iterator or circulator can be passed as well The edges of the triangulation can also be visited through iterators and circulators the edge circulators and iterators are also bidirectional and non mutable In the following we called infinite any face or edge incident to the infinite vertex and the infinite vertex itself Any other feature face edge or vertex of the triangulation is said to be finite Some iterators the All iterators allows to visit finite or infinite feature while others the Finite iterators visit only finite features Circulators visit infinite features as well as finite ones typedef Tds Vertex handle Vertex handle handle to a vertex typedef Tds Face handle Face handle handle to a face typedef Tds Face iterator All faces iterator iterator over all faces typedef Tds Edge iterator All edges iterator iterator over all edges typedef Tds Vertex iterator All vertices iterator iterator over all vertices Triangulation 2 Traits Tds Finite faces iterator iterator over finite faces Triangulation 2 Traits Tds Finite edges iterator iterator over finite edges Triangulation 2 Traits Tds Finite vertices iterator iterator over finite vertices Triangulation 2 Traits Tds Point iterator iterator over the points corresponding the finite vertices of the triangulation Triangulation 2 Traits Tds Line face circulator circulator over all faces intersected by a line Triangulation 2 Traits Tds Face circulator circulator over all faces incident to a given vertex Triangulation 2 Traits Tds Edge circulator circulator over all edges incident to a given vertex Triangulation 2 Traits Tds Vertex circulator circulator over all vertices incident to a given vertex The triangulation class also defines the following enum type to specify which case occurs when locating a point in the triangulation enum Locate type VERTEX EDGE FACE OUTSIDE CONVEX HULL OUTSIDE AFFINE HULL The locate type is OUTSIDE CONVEX HULL when the point is outside the convex hull but in the affine hull of the current triangulation The locate type is OUTSIDE AFFINE HULL when the point is outside the affine hull of the current triangulation Creation Triangulation 2 Traits Tds t default constructor Triangulation 2 Traits Tds t Traits gt Traits Introduces an empty triangulation t Triangulation 2 Traits Tds t Triangulation 2 tr Copy constructor All the vertices and faces are duplicated After the copy t and tr refer to different triangulations if tr is modified t is not Triangulation 2 t Triangulation 2 tr Assignement All the vertices and faces are duplicated After the assignement t and tr refer to different triangulations if tr is modified t is not void t swap Triangulation 2 tr The triangulations tr and t are swapped t swap tr should be preferred to t tr or to t tr if tr is deleted after that void t clear Deletes all faces and finite vertices resulting in an empty triangulation void Triangulation 2 Destructor All vertices and faces are deleted Access Functions Geom traits t geom traits Returns a const reference to the triangulation traits object TriangulationDataStructure 2 t tds Returns a const reference to the triangulation data structure advanced Non const access The responsibility of keeping a valid triangulation belongs to the user when using advanced operations allowing a direct manipulation of the tds TriangulationDataStructure 2 t tds Returns a reference to the triangulation data structure This method is mainly a help for users implementing their own triangulation algorithms advanced int t dimension Returns the dimension of the convex hull size type t number of vertices Returns the number of finite vertices size type t number of faces Returns the number of finite faces Face handle t infinite face a face incident to the infinite vertex Vertex handle t infinite vertex the infinite vertex Vertex handle t finite vertex a vertex distinct from the infinite vertex PredicatesThe class Triangulation 2 Traits Tds provides methods to test the finite or infinite character of any feature and also methods to test the presence in the triangulation of a particular feature edge or face bool t is infinite Vertex handle v true iff v is the infinite vertex bool t is infinite Face handle f true iff face f is infinite bool t is infinite Face handle f int i true iff edge f i is infinite bool t is infinite Edge e true iff edge e is infinite bool t is infinite Edge circulator ec true iff edge ec is infinite bool t is infinite Edge iterator ei true iff edge ei is infinite bool t is edge Vertex handle va Vertex handle vb true if there is an edge having va and vb as vertices bool t is edge Vertex handle va Vertex handle vb Face handle fr int i as above In addition if true is returned the edge with vertices va and vb is the edge e fr i where fr is a handle to the face incident to e and on the right side of e oriented from va to vb bool t includes edge Vertex handle va Vertex handle vb Face handle fr int i true if the line segment from va to vb includes an edge e incident to va If true vb becomes the other vertex of e e is the edge fr i where fr is a handle to the face incident to e and on the right side e oriented from va to vb bool t is face Vertex handle v1 Vertex handle v2 Vertex handle v3 true if there is a face having v1 v2 and v3 as vertices bool t is face Vertex handle v1 Vertex handle v2 Vertex handle v3 Face handle fr as above In addition if true is returned fr is a handle to the face with v1 v2 and v3 as vertices Queries The class Triangulation 2 Traits Tds provides methods to locate a given point with respect to a triangulation It also provides methods to locate a point with respect to a given finite face of the triangulation Face handle t locate Point query Face handle f Face handle If the point query lies inside the convex hull of the points a face that contains the query in its interior or on its boundary is returned If the point query lies outside the convex hull of the triangulation but in the affine hull the returned face is an infinite face which is a proof of the point s location for a two dimensional triangulation it is a face p q such that query lies to the left of the oriented line pq the rest of the triangulation lying to the right of this line for a degenerate one dimensional triangulation it is the degenarate one dimensional face p NULL such that query and the triangulation lie on either side of p If the point query lies outside the affine hull the returned Face handle is NULL The optional Face handle argument if provided is used as a hint of where the locate process has to start its search Face handle t locate Point query Locate type lt int li Face handle h Face handle Same as above Additionally the parameters lt and li describe where the query point is located The variable lt is set to the locate type of the query If lt VERTEX the variable li is set to the index of the vertex and if lt EDGE li is set to the index of the vertex opposite to the edge Be careful that li has no meaning when the query type is FACE OUTSIDE CONVEX HULL or OUTSIDE AFFINE HULL or when the triangulation is dimensional Oriented side t oriented side Face handle f Point p Returns on which side of the oriented boundary of f lies the point p Precondition f is finite Oriented side t side of oriented circle Face handle f Point p Returns on which side of the circumcircle of face f lies the point p The circle is assumed to be counterclockwisely oriented so its positive side correspond to its bounded side This predicate is available only if the corresponding predicates on points is provided in the geometric traits class Modifiers The following operations are guaranteed to lead to a valid triangulation when they are applied on a valid triangulation void t flip Face handle f int i Exchanges the edge incident to f and f neighbor i with the other diagonal of the quadrilateral formed by f and f neighbor i Precondition The faces f and f neighbor i are finite faces and their union form a convex quadrilateral Vertex handle t insert Point p Face handle f Face handle Inserts point p in the triangulation and returns the corresponding vertex If point p coincides with an already existing vertex this vertex is returned and the triangulation remains unchanged If point p is on an edge the two incident faces are split in two If point p is strictly inside a face of the triangulation the face is split in three If point p is strictly outside the convex hull p is linked to all visible points on the convex hull to form the new triangulation At last if p is outside the affine hull in case of degenerate 1 dimensional or dimensional triangulations p is linked all the other vertices to form a triangulation whose dimension is increased by one The last argument f is an indication to the underlying locate algorithm of where to start Vertex handle t insert Point p Locate type lt Face handle loc int li Same as above except that the location of the point p to be inserted is assumed to be given by lt loc i see the description of the locate method above Vertex handle t push back Point p Equivalent to insert p template class InputIterator int t insert InputIterator first InputIterator last Inserts the points in the range first last Returns the number of inserted points Precondition The value type of InputIterator is Point void t remove Vertex handle v Removes the vertex from the triangulation The created hole is retriangulated Precondition Vertex v must be finite Figure Insertion of a point on an edge Figure Insertion in a face Figure Insertion outside the convex hull Figure Removal advanced The following member functions offer more specialized versions of the insertion or removal operations to be used when one knows to be in the corresponding case Vertex handle t insert first Point p Inserts the first finite vertex Vertex handle t insert second Point p Inserts the second finite vertex Vertex handle t insert in face Point p Face handle f Inserts vertex v in face f Face f is modified two new faces are created Precondition The point in vertex v lies inside face f Vertex handle t insert in edge Point p Face handle f int i Inserts vertex v in edge i of f Precondition The point in vertex v lies on the edge opposite to the vertex i of face f Vertex handle t insert outside convex hull Point p Face handle f Inserts a point which is outside the convex hull but in the affine hull Precondition The handle f points to a face which is a proof of the location ofp see the description of the locate method above Vertex handle t insert outside affine hull Point p Inserts a point which is outside the affine hull void t remove degree 3 Vertex handle v Removes a vertex of degree three Two of the incident faces are destroyed the third one is modified Precondition Vertex v is a finite vertex with degree three void t remove second Vertex handle v Removes the before last finite vertex void t remove first Vertex handle v Removes the last finite vertex The following fonctions are mainly intended to be used in conjunction with the find conflicts member fonctions of Delaunay and constrained Delaunay triangulations to perform insertions template class EdgeIt Vertex handle t star hole Point p EdgeIt edge begin EdgeIt edge end creates a new vertex v and use it to star the hole whose boundary is described by the sequence of edges edge begin edge end Returns a handle to the new vertex template class EdgeIt class FaceIt Vertex handle t star hole Point p EdgeIt edge begin EdgeIt edge end FaceIt face begin FaceIt face end same as above except that the algorithm first recycles faces in the sequence face begin face end and create new ones only when the sequence is exhausted advanced Traversal of the Triangulation A triangulation can be seen as a container of faces and vertices Therefore the triangulation provides several iterators and circulators that allow to traverse it completely or partially Face Edge and Vertex Iterators The following iterators allow respectively to visit finite faces finite edges and finite vertices of the triangulation These iterators are non mutable bidirectional and their value types are respectively Face Edge and Vertex They are all invalidated by any change in the triangulation Finite vertices iterator t finite vertices begin Starts at an arbitrary finite vertex Finite vertices iterator t finite vertices end Past the end iterator Finite edges iterator t finite edges begin Starts at an arbitrary finite edge Finite edges iterator t finite edges end Past the end iterator Finite faces iterator t finite faces begin Starts at an arbitrary finite face Finite faces iterator t finite faces end Past the end iterator Point iterator t points begin Point iterator t points end Past the end iterator The following iterators allow respectively to visit all finite or infinite faces edges and vertices of the triangulation These iterators are non mutable bidirectional and their value types are respectively Face Edge and Vertex They are all invalidated by any change in the triangulation All vertices iterator t all vertices begin Starts at an arbitrary vertex All vertices iterator t all vertices end Past the end iterator All edges iterator t all edges begin Starts at an arbitrary edge All edges iterator t all edges end Past the end iterator All faces iterator t all faces begin Starts at an arbitrary face All faces iterator t all faces end Past the end iterator Line Face Circulator The triangulation defines a circulator that allows to visit all faces that are intersected by a line A face f is considered has being intersected by the oriented line l if either f is a finite face whose interior intersects l or f is a finite face with an edge collinear with l and lies to the left of l or f is an infinite face incident to a convex hull edge whose interior is intersected by l or f is an infinite face incident to a convex hull vertex lying on l and the finite edge of f lies to the left of l The circulator has a singular value if the line l intersect no finite face of the triangulation This circulator is non mutable and bidirectional Its value type is Face Line face circulator t line walk Point p Point q Face handle f Face handle This function returns a circulator that allows to visit the faces intersected by the line pq If there is no such face the circulator has a singular value The starting point of the circulator is the face f or if f is omitted the first finite face traversed by l The circulator wraps around the infinite vertex after the last traversed finite face it steps through the infinite face adjacent to this face then through the infinite face adjacent to the first traversed finite face then through the first finite traversed face again Precondition Points p and q must be different points Precondition If f NULL the point p must be inside or on the boundary of f Figure illustrates which finite faces are enumerated Lines l1 and l2 have no face to their left Lines l3 and l4 have faces to their left Note that the finite faces that are only vertex incident to lines l3 and l4 are not enumerated Figure The line face circulator A line face circulator is invalidated if the face the circulator refers to is changed Face Edge and Vertex Circulators The triangulation also provides circulators that allows to visit respectively all faces or edges incident to a given vertex or all vertices adjacent to a given vertex These circulators are non mutable and bidirectional The operator moves the circulator counterclockwise around the vertex while the operator moves clockwise A face circulator is invalidated by any modification of the face pointed to An edge or a vertex circulator are invalidated by any modification of one of the two faces incident to the edge pointed to Face circulator t incident faces Vertex handle v Starts at an arbitrary face incident to v Face circulator t incident faces Vertex handle v Face handle f Starts at face f Precondition Face f is incident to vertex v Edge circulator t incident edges Vertex handle v Starts at an arbitrary edge incident to v Edge circulator t incident edges Vertex handle v Face handle f Starts at the the first edge of f incident to v in counterclockwise order around v Precondition Face f is incident to vertex v Vertex circulator t incident vertices Vertex handle v Starts at an arbitrary vertex incident to v Vertex circulator t incident vertices Vertex handle v Face handle f Starts at the first vertex of f adjacent to v in counterclockwise order around v Precondition Face f is incident to vertex v Traversal of the Convex Hull Applied on the infinite vertex the above functions allow to visit the vertices on the convex hull and the infinite edges and faces Note that a counterclockwise traversal of the vertices adjacent to the infinite vertex is a clockwise traversal of the convex hull Face circulator t incident faces t infinite vertex Face circulator t incident faces t infinite vertex Face handle f Edge circulator t incident edges t infinite vertex Edge circulator t incident edges t infinite vertex Face handle f Vertex circulator t incident vertices t infinite vertex v Vertex circulator t incident vertices t infinite vertex Face handle f Miscellaneous int t ccw int i Returns i 1 modulo 3 Precondition i 2 int t cw int i Returns i 2 modulo 3 Precondition i 2 Triangle t triangle Face handle f Returns the triangle formed by the three vertices of f Precondition The face is finite Segment t segment Face handle f int i Returns the line segment formed by the vertices ccw i and cw i of face f Precondition i 2 The vertices ccw i and cw i of f are finite Segment t segment Edge e Returns the line segment corresponding to edge e Precondition e is a finite edge Segment t segment Edge circulator ec Returns the line segment corresponding to edge ec Precondition ec is a finite edge Segment t segment Edge iterator ei Returns the line segment corresponding to edge ei Precondition ei is a finite edge Point t circumcenter Face handle f Compute the circumcenter of the face pointed to by f This function is available only if the correspoding function is provided in the geometric traits advanced Setting void t set infinite vertex Vertex handle v Checking The responsibility of keeping a valid triangulation belongs to the users if advanced operations are used Obviously the advanced user who implements higher levels operations may have to make a triangulation invalid at some times The following method is provided to help the debugging bool t is valid bool verbose false int level Checks the combinatorial validity of the triangulation and also the validity of its geometric embedding This method is mainly a debugging help for the users of advanced features advanced I O The I O operators are defined for iostream The format for the iostream is an internal format ostream ostream os T Inserts the triangulation t into the stream os Precondition The insert operator must be defined for Point istream istream is T Reads a triangulation from stream is and assigns it to t Precondition The extract operator must be defined for Point The information ouput in the iostream is the dimension the number of vertices including the infinite one and the number of faces including infinite ones for each vertex except the infinite vertex the non combinatorial information stored in that vertex point etc for each faces the indices of its vertices and the non combinatorial information if any in this face for each face again the indices of the neighboring faces The index of an item vertex of face is the rank of this item in the ouput order When dimension 2 the same information is ouput for faces of maximal dimension instead of faces CGAL also provides stream operators to draw triangulations on CGAL Window stream the LEDA based graphic package and on CGAL Qt widget the Qt based graphic package These operators requires respectively the include statements include CGAL IO Window stream h include CGAL IO Qt widget Triangulation 2 h See the chapters on Window stream and on Qt widget in the Support Library manual Implementation Locate is implemented by a line walk from a vertex of the face given as optional parameter or from a finite vertex of infinite face if no optional parameter is given It takes time O n in the worst case but only O sqrt n on average if the vertices are distributed uniformly at random Insertion of a point is done by locating a face that contains the point and then splitting this face If the point falls outside the convex hull the triangulation is restored by flips Apart from the location insertion takes a time time O 1 This bound is only an amortized bound for points located outside the convex hull Removal of a vertex is done by removing all adjacent triangles and retriangulating the hole Removal takes time O d 2 in the worst case if d is the degree of the removed vertex which is O 1 for a random vertex The face edge and vertex iterators on finite features are derived from their counterparts visiting all finite and infinite features which are themselves derived from the corresponding iterators of the triangulation data structure See AlsoTriangulationTraits 2 TriangulationDataStructure 2 TriangulationDataStructure 2 Face TriangulationDataStructure 2 Vertex CGAL Triangulation data structure 2 Vb Fb CGAL Triangulation vertex base 2 Traits CGAL Triangulation face base 2 Traits Next Triangulation cw ccw 2 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Triangulation_2_ref/Class_Triangulation_2", "title": "triangulation_2&lt;traits,tds&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Triangulation_2_ref/Triangulation_2.tex' -->\n<html> <head>  \n<title>Triangulation_2&lt;Traits,Tds&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_938\"></A>\n\n<A NAME=\"Cross_link_anchor_939\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_896\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Triangulation_2<Traits,Tds>\"></A>\n<h2><I>CGAL::Triangulation_2&lt;Traits,Tds&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I> is the basic class \ndesigned to handle triangulations\nof set of points <MATH><I>  A</I></MATH> in the plane.\n<P>\n\nSuch a triangulation has vertices at the points of <MATH><I>  A</I></MATH>\nand its domain covers the convex hull of <MATH><I>  A</I></MATH>.\nIt can be viewed as a planar partition of the plane\nwhoses bounded faces are triangular and cover\nthe convex hull of <MATH><I>  A</I></MATH>. The single unbounded face of this partition\nis the complementary of the convex hull of <MATH><I>  A</I></MATH>.\n<P>\n\nIn many applications, it is convenient to\ndeal only with triangular faces. Therefore, we add to the\ntriangulation\na fictitious vertex, called the <I>infinite vertex</I>\nand we make each  convex hull edge incident \nto an <I>infinite</I> \nface having as third vertex  the <I>infinite vertex</I>.\n In that way, each edge is incident to exactly two faces\nand special cases at the\nboundary of the convex hull are simpler to deal with.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The infinite vertex.\n<A NAME=\"Triangulation_ref_Fig_infinite_vertex\"></A>\n\n<CENTER>\n<img border=0 src=\"./infinite_vertex.gif\" align=center alt=\"Vertices at\ninfinity\">\n</CENTER>\n<P>\n\nThe class <I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I> implements this point of view\nand therefore considers  the triangulation of the set of points \nas a set of  triangular,  finite and\ninfinite faces. \nAlthough it is convenient to draw a triangulation as in\nfigure&nbsp;<A HREF=\"Class_Triangulation_2.html#Triangulation_ref_Fig_infinite_vertex\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, note that\nthe <I>infinite vertex</I> has no significant\ncoordinates and that no geometric predicate can be applied on it\nor on an infinite face.\n<P>\n\nA triangulation is a collection of vertices and faces that\nare linked together through incidence and adjacency relations.\nEach face give access to its three incident vertices and to\nits \nthree adjacent faces. Each vertex give access to one of its  incident\nfaces.\n<P>\n\nThe three vertices of a face are indexed with 0, 1 and 2\nin counterclockwise order. The neighbor of a face are also \nindexed with 0,1,2 in such a way that the neighbor indexed by <MATH><I>i</I></MATH>\nis <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex with the same index.\n<P>\n\nThe triangulation class\noffer  two functions <I>int cw(int i)</I> and \n<I>int ccw(int i)</I> \nwhich given the index of a vertex in a face\ncompute the index of the next vertex  of the same face\nin clockwise\nor counterclockwise order.\n Thus, for example the neighbor \n<I>neighbor(cw(i))</I> is\n the\nneighbor of <I>f</I>  which is next to <I>neighbor(i)</I> turning clockwise\naround <I>f</I>. The face <I>neighbor(cw(i))</I>\nis also the first face encountered after <I>f</I> when\nturning clockwise around vertex <I>i</I>\nof&nbsp;<I>f</I> (see Figure&nbsp;<A HREF=\"Class_Triangulation_2.html#Triangulation_ref_Fig_neighbors\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Vertices and neighbors.\n    <A NAME=\"Triangulation_ref_Fig_neighbors\"></A>\n  \n<CENTER>\n<img border=0 src=\"./neighbors.gif\" align=center alt=\"Neighbors\">\n</CENTER>\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Triangulation_2.h\">CGAL/Triangulation_2.h</A>&gt;</I>\n<P>\n\n<H3>Parameters</H3>The class <I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I> has  two template parameters. The first one\n<I>Traits</I> is the geometric traits, it is to be instantiated by\n a model of the concept <I><A HREF=\"Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I>.\n<P>\n\nThe second parameter is the triangulation data structure,\nit has to be instantiated by a model of the concept\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I>.\nBy befault, the triangulation data structure  is instanciated by\n<I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A> &lt;                        <A HREF=\"Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;Gt&gt;, \t\t       <A HREF=\"Class_Triangulation_face_base_2.html#Cross_link_anchor_946\">CGAL::Triangulation_face_base_2</A>&lt;Gt&gt; &gt; &gt;</I>.\n<P>\n\n<H3>Inherits From</H3><I><A HREF=\"Class_Triangulation_cw_ccw_2.html#Cross_link_anchor_941\">Triangulation_cw_ccw_2</A></I>\nThis class provides the functions <I>cw(i)</I> et <I>ccw(i)</I>.\n<P>\n\n<H3>Types</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Geom_traits\"></A>\n<A NAME=\"Typedef_Geom_traits\"></A>\ntypedef Traits\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Geom_traits;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the traits class.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Triangulation_data_structure\"></A>\n<A NAME=\"Typedef_Triangulation_data_structure\"></A>\ntypedef Tds\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Triangulation_data_structure;\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the triangulation data structure type.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Point\"></A>\n<A NAME=\"Typedef_Point\"></A>\ntypedef Traits::Point_2t\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Point;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the point type\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Segment\"></A>\n<A NAME=\"Typedef_Segment\"></A>\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Segment;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the segment type\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Triangle\"></A>\n<A NAME=\"Typedef_Triangle\"></A>\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Triangle_2.html#Cross_link_anchor_58\">Triangle_2</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Triangle;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the triangle type\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex\"></A>\n<A NAME=\"Typedef_Vertex\"></A>\ntypedef Tds::Vertex\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Vertex;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the vertex type.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face\"></A>\n<A NAME=\"Typedef_Face\"></A>\ntypedef Tds::Face\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Face;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the face type.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge\"></A>\n<A NAME=\"Typedef_Edge\"></A>\ntypedef Tds::Edge\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Edge;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the edge type.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_size_type\"></A>\n<A NAME=\"Typedef_size_type\"></A>\ntypedef Tds::size_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    size_type;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Size type (an unsigned integral type)\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_difference_type\"></A>\n<A NAME=\"Typedef_difference_type\"></A>\ntypedef Tds::difference_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    difference_type;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Difference type (a signed integral type)\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe vertices and faces of the triangulations are accessed through \n<I>handles</I>, \n<I>iterators</I> and <I>circulators</I>. \nThe  handles are models of the concept <I><A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A></I> which basically\noffers the two dereference operators <I>*</I> and <I>-&gt;</I>.\nThe iterators and circulators\nare all bidirectional and non mutable.\nThe circulators and iterators are convertible  to handles with the\nsame value type, so that whenever a handle appear in the parameter \nlist of a function, an appropriate iterator or circulator can be passed\nas well.\n<P>\n\nThe edges of the triangulation can also be visited through iterators\nand circulators,\nthe edge circulators and iterators\nare also bidirectional and non mutable.\n<P>\n\nIn the following, we called <I>infinite</I> any face or edge \nincident  to the infinite vertex and the infinite vertex itself.\n Any other feature (face, edge or vertex) of the triangulation is said \nto be <I>finite</I>.\nSome iterators (the <I>All</I> iterators ) allows to visit finite or \ninfinite feature while others (the <I>Finite</I> iterators) visit only\nfinite features. Circulators visit infinite features as well as finite \nones.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle\"></A>\n<A NAME=\"Typedef_Vertex_handle\"></A>\ntypedef Tds::Vertex_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Vertex_handle;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    handle to a vertex\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle\"></A>\n<A NAME=\"Typedef_Face_handle\"></A>\ntypedef Tds::Face_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Face_handle;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    handle to a face\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_faces_iterator\"></A>\n<A NAME=\"Typedef_All_faces_iterator\"></A>\ntypedef Tds::Face_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    All_faces_iterator;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all faces.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_edges_iterator\"></A>\n<A NAME=\"Typedef_All_edges_iterator\"></A>\ntypedef Tds::Edge_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    All_edges_iterator;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all edges\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator\"></A>\n<A NAME=\"Typedef_All_vertices_iterator\"></A>\ntypedef Tds::Vertex_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    All_vertices_iterator;\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterator over all vertices\n        </TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Finite_faces_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite faces.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Finite_edges_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite edges.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Finite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over finite\nvertices.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    iterator over the points corresponding the\nfinite vertices of the triangulation.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Line_face_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator over all faces intersected by a line.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Face_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator over all faces incident to a given vertex.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Edge_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator over all  edges incident to a given vertex.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;::Vertex_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    circulator over all vertices incident to a given vertex.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\nThe triangulation class also defines the following <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> type to specify\nwhich case occurs when locating a point in the triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A NAME=\"Function_Locate_type\"></A>\n<A NAME=\"Enum_Locate_type\"></A>\n<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> <A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">Locate_type</A> { </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n    <A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">VERTEX</A>=0<A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">EDGE</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Triangulation_2#Enum_Locate_type\">FACE</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">OUTSIDE_CONVEX_HULL</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">OUTSIDE_AFFINE_HULL</A><A NAME=\"Function_Locate_type\"></A>\n};</TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    The locate type is <I><A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">OUTSIDE_CONVEX_HULL</A></I> when the point\nis  outside the convex hull but in the affine hull of the current triangulation.<BR>\n\nThe locate type is <I><A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">OUTSIDE_AFFINE_HULL</A></I> \nwhen the point is outside the affine hull\nof the current triangulation.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt; t;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    default constructor.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt; t (  Traits gt = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Introduces an empty triangulation <I>t</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt; t (  <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A> tr);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Copy constructor. All the vertices and faces are duplicated.\n After the copy, <I>t</I> and <I>tr</I>\nrefer to different triangulations&nbsp;: \n if <I>tr</I> is modified, <I>t</I> is not.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     t =  <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A> tr<A NAME=\"Function_Triangulation_2_operator=6const_Triangulation_2__tr9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Assignement. All the vertices and faces are duplicated.\n After the assignement, <I>t</I> and <I>tr</I>\nrefer to different triangulations&nbsp;: \n if <I>tr</I> is modified, <I>t</I> is not.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_swap6Triangulation_2__tr9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.swap ( <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&amp; tr)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The triangulations <I>tr</I> and <I>t</I> are swapped.\n<I>t.swap(tr)</I> should be preferred to <I>t</I> = <I>tr</I> or to\n<I>t(tr)</I> if <I>tr</I> is deleted after that.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Deletes all faces and finite vertices\nresulting\n in an\nempty triangulation.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_~Triangulation_269;\"></A>\nvoid ~\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A> ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Destructor. All vertices and faces are deleted.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Geom_traits__geom_traits69_const;\"></A>\n Geom_traits\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.geom_traits ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a const reference to the triangulation traits object.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_const_TriangulationDataStructure_2___tds69_const;\"></A>\n <A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.tds ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a const reference to the triangulation data structure.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Non const access</H3>\nThe responsibility of keeping a valid triangulation belongs to the user\nwhen using advanced operations allowing a direct manipulation of the <I>tds</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_TriangulationDataStructure_2___tds69;\"></A>\n<A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A> &amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.tds ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a reference to the triangulation data structure.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThis method is mainly a help for users implementing their own triangulation\nalgorithms.\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_dimension69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.dimension ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the dimension of the convex hull.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_vertices69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the number of finite vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_faces69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.number_of_faces ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the number of finite faces.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_infinite_face69_const;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.infinite_face ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a  face incident to the <I>infinite_vertex</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_infinite_vertex69;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.infinite_vertex ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    the <I>infinite_vertex</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_finite_vertex69_const;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.finite_vertex ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a vertex distinct from  the <I>infinite_vertex</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>The class <I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I> provides methods to test\nthe finite or infinite character of any feature,\nand also methods to test the presence in the triangulation\nof a particular feature (edge or face).\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff <I>v</I> is the <I>infinite_vertex</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6Face_handle_f9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff face <I>f</I> is infinite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6Face_handle_f+_int_i9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( Face_handle f,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff edge <I>(f,i)</I> is infinite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6Edge_e9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff edge <I>e</I> is infinite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6Edge_circulator_ec9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( Edge_circulator ec)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff edge <I>*ec</I> is infinite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_infinite6Edge_iterator_ei9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_infinite ( Edge_iterator ei)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> iff edge <I>*ei</I> is infinite.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_va+_Vertex_handle_vb9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_edge ( Vertex_handle va,  Vertex_handle vb)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> if there is an edge having <I>va</I> and <I>vb</I> as\nvertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_va+_Vertex_handle_vb+_Face_handle__fr+_int___i9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle va,<BR>\n\nVertex_handle vb,<BR>\n\nFace_handle&amp; fr,<BR>\n\nint &amp; i)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    as above. In addition, if <I>true</I> is returned,  the edge with\nvertices <I>va</I> and <I>vb</I> is the edge <I>e=(fr,i)</I> where\n<I>fr</I> is a handle to the face incident to <I>e</I> and \non the right side of  <I>e</I> oriented from <I>va</I> to <I>vb</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_includes_edge6Vertex_handle_va+_Vertex_handle___vb+_Face_handle__fr+_int___i9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.includes_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle va,<BR>\n\nVertex_handle &amp; vb,<BR>\n\nFace_handle&amp; fr,<BR>\n\nint &amp; i)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> if the line segment from <I>va</I> to <I>vb</I> includes\nan edge <I>e</I> incident to <I>va</I>. If <I>true</I>, <I>vb</I> becomes\nthe other vertex of <I>e</I>, <I>e</I> is the edge <I>(fr,i)</I> where\n<I>fr</I> is a handle to the face incident to <I>e</I> and \non the right side <I>e</I> oriented from <I>va</I> to <I>vb</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_face6Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v39;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> if there is a face having <I>v1</I>, <I>v2</I> and <I>v3</I> \nas vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_face6Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v3+_Face_handle__fr9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.is_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3,<BR>\n\nFace_handle &amp;fr)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    as above. In addition, if <I>true</I> is returned, fr is a handle\nto the face with  <I>v1</I>, <I>v2</I> and <I>v3</I> \nas vertices.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Queries</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I>  provides methods to locate\na given point with respect to a triangulation. It also provides\nmethods to locate a point with respect to\na given  finite face of the triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_locate6const_Point__query+_Face_handle_f_=_Face_handle699_const;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.locate (  Point query,  Face_handle f = Face_handle())\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    If the point <I>query</I> lies inside the convex hull of the points, a face \nthat contains the query in its interior or on its\n boundary is returned.<BR>\n\nIf the point <I>query</I> lies outside the convex hull of the\ntriangulation but in the affine hull,\nthe returned face is an infinite face which is a proof of the point's\nlocation :<BR>\n\n- for a two dimensional triangulation, it is a face <MATH><I>( <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> , p, q)</I></MATH> \nsuch that\n<I>query</I> lies to the left  of the oriented line <MATH><I>pq</I></MATH> \n(the rest of the triangulation lying to the right of this line).<BR>\n\n- for a degenerate one dimensional triangulation it is the (degenarate\none dimensional) face <MATH><I>( <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> , p, NULL)</I></MATH> such that <I>query</I>\nand the triangulation lie on either side of <I>p</I>.<BR>\n\nIf the point <I>query</I> lies outside the affine hull,\nthe returned <I>Face_handle</I> is <I>NULL</I>.<BR>\n\nThe optional <I>Face_handle</I> argument, if provided, is used as a hint\nof where the locate process has to start its search.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_locate6const_Point__query+_Locate_type__lt+_int__li+_Face_handle_h_=Face_handle69_9_const;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.locate ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point query,<BR>\n\n<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">Locate_type</A>&amp; lt,<BR>\n\nint&amp; li,<BR>\n\nFace_handle h =Face_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as above. Additionally, the parameters <I>lt</I>\n and <I>li</I>\ndescribe where the query point is located. \nThe variable <I>lt</I> is set to the locate type of the query.\nIf <I>lt==<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">VERTEX</A></I> \nthe variable <I>li</I>\nis set to the index of the vertex, and if <I>lt==<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">EDGE</A></I>\n<I>li</I>\nis set to the index \nof the vertex <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the\nedge. \nBe careful that <I>li</I>\nhas no meaning when the query type is <I><A HREF=\"Class_Triangulation_2#Enum_Locate_type\">FACE</A></I>, <I><A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">OUTSIDE_CONVEX_HULL</A></I>, \nor <I><A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">OUTSIDE_AFFINE_HULL</A></I> or when the\ntriangulation is <MATH><I>0</I></MATH>-dimensional.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Oriented_side_oriented_side6Face_handle_f+_const_Point__p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Oriented_side.html#Cross_link_anchor_116\">Oriented_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.oriented_side ( Face_handle f,  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns on which side of the oriented boundary of <I>f</I> lies \nthe point <I>p</I>.<BR>\n\n<EM>Precondition: </EM><I>f</I> is finite.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Oriented_side_side_of_oriented_circle6Face_handle_f+_const_Point___p9;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Oriented_side.html#Cross_link_anchor_116\">Oriented_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.<A HREF=\"../Kernel_23_ref/Function_side_of_oriented_circle.html#Cross_link_anchor_261\">side_of_oriented_circle</A> ( Face_handle f,  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns on which side of the circumcircle  of face <I>f</I> lies \nthe point <I>p</I>. The circle is assumed to be counterclockwisely\noriented, so its positive\nside correspond to its bounded side.\nThis predicate is available only if the corresponding predicates on\npoints is provided in the geometric traits class.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>\n<P>\n\nThe following operations are guaranteed to lead to a valid triangulation \nwhen they are applied on a valid triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip6Face_handle_f+_int_i9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.flip ( Face_handle f,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Exchanges the edge incident to\n<I>f</I> and <I>f-&gt;neighbor(i)</I> with the other\ndiagonal of the quadrilateral formed by <I>f</I> and  <I>f-&gt;neighbor(i)</I>.<BR>\n\n<EM>Precondition: </EM>The faces <I>f</I> and <I>f-&gt;neighbor(i)</I> are finite faces\nand their union form a convex quadrilateral.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Point__p+_Face_handle_f_=_Face_handle699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert (  Point p,  Face_handle f = Face_handle())\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in the triangulation and returns the corresponding\n vertex.<BR>\n\nIf point <I>p</I> coincides with an already existing vertex, this \nvertex is returned and the triangulation remains unchanged.<BR>\n\nIf point <I>p</I> is on an edge, the two incident faces are split \nin two.<BR>\n\nIf point <I>p</I> is strictly inside a face of the triangulation,\nthe face is split in three.<BR>\n\nIf point <I>p</I> is strictly outside the  convex hull, <I>p</I> is linked\nto all visible points on the convex hull to form the new\ntriangulation.<BR>\n\nAt last, if <I>p</I> is outside the affine hull (in case of degenerate\n1-dimensional or 0-dimensional triangulations), <I>p</I>\nis linked all the  other vertices to form a triangulation whose\ndimension is increased by one.\nThe last argument <I>f</I> is an indication to the underlying locate\nalgorithm of where to start.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Point__p+_Locate_type_lt+_Face_handle_loc+_int_li_9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\n<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">Locate_type</A> lt,<BR>\n\nFace_handle loc,<BR>\n\nint li)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as above except that the location of the point\n <I>p</I> to be inserted is assumed to be given by\n<I>(lt,loc,i)</I> (see the description of the <I>locate</I> method above.)\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_push_back6const_Point__p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.push_back (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Equivalent to <I>insert(p)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_insert6InputIterator_first+_InputIterator_last9;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert ( InputIterator first,  InputIterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the points in the range\n <MATH><I>[.</I></MATH><I>first</I>, <I>last</I><MATH><I>.)</I></MATH>.\n Returns the number of inserted points.<BR>\n\n<EM>Precondition: </EM>The <I>value_type</I> of <I>InputIterator</I>\n is <I>Point</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.remove ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the vertex from the triangulation. The created hole is \n retriangulated.<BR>\n\n<EM>Precondition: </EM>Vertex <I>v</I> must be finite.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Insertion of a point on an edge.\n<A NAME=\"Triangulation_ref_Fig_inser1t\"></A>\n<P>\n\n<CENTER>\n<img border=0 src=\"./insert1.gif\" align=center alt=\"Insertion in an edge\">\n</CENTER>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Insertion in a face.\n<A NAME=\"Triangulation_ref_Fig_insert2\"></A>\n<P>\n\n<CENTER>\n<img border=0 src=\"./insert2.gif\" align=center alt=\"Insertion in a Face\">\n</CENTER>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Insertion outside the convex hull.\n<A NAME=\"Triangulation_ref_Fig_insert3\"></A>\n<P>\n\n<CENTER>\n<img border=0 src=\"./insert3.gif\" align=center alt=\"Insertion outside the\nconvex hull\">\n</CENTER>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Removal\n<A NAME=\"Triangulation_ref_Fig_remove\"></A>\n<P>\n\n<CENTER>\n<img border=0 src=\"./remove.gif\" align=center alt=\"Remove\">\n</CENTER>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\nThe following member functions offer more specialized versions of the\ninsertion or removal operations to be used when one knows to be in the\ncorresponding case.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_first6const_Point__p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_first (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the first finite  vertex .\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_second6const_Point__p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_second (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the second finite  vertex .\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_face6const_Point__p+Face_handle_f9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_in_face (  Point p, Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts vertex <I>v</I> in face\n<I>f</I>. Face <I>f</I> is modified,\ntwo new faces are created.<BR>\n\n<EM>Precondition: </EM>The point in vertex <I>v</I> lies inside face <I>f</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_edge6const_Point__p+_Face_handle_f+_int_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_in_edge (  Point p,  Face_handle f,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts vertex v in edge <I>i</I> of <I>f</I>.<BR>\n\n<EM>Precondition: </EM>The point in vertex <I>v</I> lies on the edge <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to \nthe vertex <I>i</I> of face <I>f</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_outside_convex_hull6const_Point__p+_Face_handle_f9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_outside_convex_hull (  Point p,  Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts \n a point which is outside the convex hull  but in the affine hull.<BR>\n\n<EM>Precondition: </EM>\nThe handle <I>f</I> points to a face which is a proof  of the location\nof<I>p</I>, see the description of the\n<I>locate</I> method above.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_outside_affine_hull6const_Point__p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.insert_outside_affine_hull (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts \n a point which is outside the affine hull.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_degree_36Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.remove_degree_3 ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes a vertex of degree three. Two of the incident faces are destroyed,\nthe third one is modified.<BR>\n\n<EM>Precondition: </EM>Vertex\n<I>v</I> is a finite vertex with degree three.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_second6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.remove_second ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the before last finite vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_first6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.remove_first ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the last finite vertex.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following fonctions are mainly intended to be used in conjunction\nwith the <I>find_conflicts()</I> member fonctions of Delaunay and constrained \nDelaunay triangulations to perform insertions.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt;class EdgeIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_star_hole6_Point_p+_EdgeIt_edge_begin+_EdgeIt_edge_end9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.star_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nEdgeIt edge_begin,<BR>\n\nEdgeIt edge_end)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    creates a new vertex <I>v</I> and use it to star the hole \nwhose boundary is described  by the sequence of edges <I>[edge_begin,  edge_end[</I>. Returns a handle to the new vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt;class EdgeIt, class FaceIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_star_hole6_Point_p+_EdgeIt_edge_begin+_EdgeIt_edge_end+_FaceIt_face_begin+_FaceIt_face_end9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.star_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nEdgeIt edge_begin,<BR>\n\nEdgeIt edge_end,<BR>\n\nFaceIt face_begin,<BR>\n\nFaceIt face_end)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above, except that the  algorithm \nfirst recycles faces in the sequence <I>[face_begin,  face_end[</I> \nand create new ones only when the sequence is exhausted.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Traversal of the Triangulation</H3>\n<P>\n\nA triangulation can be seen as a container of faces and vertices.\nTherefore the triangulation provides several iterators and circulators\nthat allow to traverse it (completely or partially).\n<P>\n\n<H3>Face, Edge and Vertex Iterators</H3>\n<P>\n\nThe following iterators allow respectively to visit \nfinite faces,  finite edges and  finite vertices\nof the triangulation. These iterators are non mutable, bidirectional\nand their value types are respectively\n<I>Face</I>, <I>Edge</I> and <I>Vertex</I>. \nThey are all invalidated by any change in the triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_vertices_iterator_finite_vertices_begin69_const;\"></A>\nFinite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite vertex\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_vertices_iterator_finite_vertices_end69_const;\"></A>\nFinite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_edges_iterator_finite_edges_begin69_const;\"></A>\nFinite_edges_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_edges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite edge\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_edges_iterator_finite_edges_end69_const;\"></A>\nFinite_edges_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_edges_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_faces_iterator_finite_faces_begin69_const;\"></A>\nFinite_faces_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_faces_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary finite face\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_faces_iterator_finite_faces_end69_const;\"></A>\nFinite_faces_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.finite_faces_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_begin69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.points_begin ()\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_end69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.points_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following iterators allow respectively to visit all\n(finite or infinite) faces, edges and vertices\nof the triangulation. These iterators are non mutable, bidirectional\nand their value types are respectively\n<I>Face</I>, <I>Edge</I> and <I>Vertex</I>. \nThey are all invalidated by any change in the triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator_all_vertices_begin69_const;\"></A>\nAll_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary  vertex\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator_all_vertices_end69_const;\"></A>\nAll_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_edges_iterator_all_edges_begin69_const;\"></A>\nAll_edges_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_edges_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary edge\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_edges_iterator_all_edges_end69_const;\"></A>\nAll_edges_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.all_edges_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_faces_iterator_all_faces_begin69_const;\"></A>\nAll_faces_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.all_faces_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary face\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_All_faces_iterator_all_faces_end69_const;\"></A>\nAll_faces_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.all_faces_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Line Face Circulator</H3>\n<P>\n\nThe triangulation defines a circulator that allows\nto visit all faces that are intersected by a line. \nA  face  <I>f</I> is \nconsidered has being intersected by \n the oriented line <I>l</I> if either:\n<UL>\n<LI><I>f</I> is a finite face whose interior intersects <I>l</I>, or\n<LI><I>f</I> is a finite face with  an edge <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A> with <I>l</I> and lies\nto the left of <I>l</I>, or\n<LI><I>f</I> is an infinite face incident to a  convex hull edge \nwhose interior is intersected\nby <I>l</I>, or\n<LI><I>f</I> is an infinite face incident to a  convex hull vertex\nlying on  <I>l</I> and the finite edge of <I>f</I>\nlies to the left of <I>l</I>. \n</UL>\nThe circulator has a singular value if  the line <I>l</I>\nintersect no finite face of the triangulation.\nThis circulator is\nnon-mutable and bidirectional. Its value type is <I>Face</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Line_face_circulator_line_walk6const_Point__p+_const_Point__q+_Face_handle_f_=_Face_handle699_const;\"></A>\nLine_face_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.line_walk ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nPoint q,<BR>\n\nFace_handle f = Face_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    This function returns a circulator that allows to visit the \n faces intersected by the line <I>pq</I>. \nIf there is no such face the circulator has a singular value.<BR>\n\nThe starting point of the circulator is the face <I>f</I>, or, if\n <I>f</I> is omitted,  the first finite face traversed by <I>l</I>.<BR>\n\nThe circulator wraps around the <I>infinite_vertex</I> :\nafter the last traversed finite face, it steps through the infinite face adjacent\nto this face then through the infinite face adjacent to the first\ntraversed finite face then through the first finite traversed face\nagain.<BR>\n\n<EM>Precondition: </EM>Points <I>p</I> and <I>q</I> must be different points.<BR>\n\n<EM>Precondition: </EM>If <I>f != NULL</I>, the point <I>p</I> must be\ninside or on the boundary of <I>f</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nFigure&nbsp;<A HREF=\"Class_Triangulation_2.html#Triangulation_ref_Fig_Line_face_circulator\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> illustrates which finite faces are enumerated. Lines\n<MATH><I>l<SUB>1</SUB></I></MATH> and <MATH><I>l<SUB>2</SUB></I></MATH> have no face to their left. Lines <MATH><I>l<SUB>3</SUB></I></MATH> and <MATH><I>l<SUB>4</SUB></I></MATH>\nhave faces to their left. Note that the finite faces that are only vertex\nincident to lines <MATH><I>l<SUB>3</SUB></I></MATH> and  <MATH><I>l<SUB>4</SUB></I></MATH> are not enumerated.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The line face circulator.\n<A NAME=\"Triangulation_ref_Fig_Line_face_circulator\"></A>\n<P>\n\n<CENTER>\n<img border=0 src=\"./walk.gif\" align=center alt=\"The Infinite Vertex\">\n</CENTER>\n<P>\n\nA line face circulator is invalidated if the face the circulator refers\nto is changed.\n<P>\n\n<H3>Face, Edge and Vertex Circulators</H3>\n<P>\n\nThe triangulation also provides circulators that allows to visit \nrespectively all faces or edges incident to a given vertex\nor all vertices adjacent to a given vertex.\nThese circulators are\nnon-mutable\nand bidirectional.\n The <I>operator++</I> moves the circulator\ncounterclockwise around the vertex while\nthe <I>operator--</I> moves clockwise.\nA face circulator is invalidated by any modification of the face pointed to.\nAn edge or a vertex circulator are invalidated by any modification\nof one of the two faces incident to the edge pointed to.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_circulator_incident_faces6Vertex_handle_v9_const;\"></A>\nFace_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_faces ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary face incident\nto <I>v</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_circulator_incident_faces6Vertex_handle_v+_Face_handle_f9_const;\"></A>\nFace_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_faces ( Vertex_handle v,  Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at face <I>f</I>.<BR>\n\n<EM>Precondition: </EM>Face <I>f</I> is incident to vertex <I>v</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_circulator_incident_edges6Vertex_handle_v9_const;\"></A>\nEdge_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_edges ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary edge incident\nto <I>v</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_circulator_incident_edges6Vertex_handle_v+_Face_handle_f9_const;\"></A>\nEdge_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_edges ( Vertex_handle v,  Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at the the first edge of <I>f</I> incident to \n<I>v</I>, in counterclockwise order around <I>v</I>.<BR>\n\n<EM>Precondition: </EM>Face <I>f</I> is incident to vertex <I>v</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_circulator_incident_vertices6Vertex_handle_v9_const;\"></A>\nVertex_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_vertices ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary  vertex incident\nto <I>v</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_circulator_incident_vertices6Vertex_handle_v+_Face_handle_f9_;\"></A>\nVertex_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_vertices ( Vertex_handle v,  Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at the first vertex of <I>f</I> adjacent  to <I>v</I>\nin  counterclockwise order around <I>v</I>.<BR>\n\n<EM>Precondition: </EM>Face <I>f</I> is incident to vertex <I>v</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Traversal of the Convex Hull</H3>\n<P>\n\nApplied on the <I>infinite_vertex</I>\nthe above  functions  allow to visit the vertices on the convex hull and\nthe infinite edges and faces. Note that a counterclockwise\ntraversal of the vertices adjacent to the <I>infinite_vertex</I> is\na clockwise traversal of the convex hull.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_circulator_incident_faces6t+infinite_vertex699_const;\"></A>\nFace_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_faces ( t.infinite_vertex())\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_circulator_incident_faces6t+infinite_vertex69+_Face_handle_f9_const;\"></A>\nFace_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_faces ( t.infinite_vertex(),  Face_handle f)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_circulator_incident_edges6t+infinite_vertex699_const;\"></A>\nEdge_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_edges ( t.infinite_vertex())\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_circulator_incident_edges6t+infinite_vertex69+_Face_handle_f9;\"></A>\nEdge_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_edges ( t.infinite_vertex(),  Face_handle f)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_circulator_incident_vertices6t+infinite_vertex69_v9_;\"></A>\nVertex_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.incident_vertices ( t.infinite_vertex() v)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_circulator_incident_vertices6t+infinite_vertex69+_Face_handle_f9_;\"></A>\nVertex_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.incident_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    t.infinite_vertex(),<BR>\n\nFace_handle f)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_ccw6int_i9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.ccw ( int i)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <MATH><I>i+1</I></MATH> modulo 3.<BR>\n\n<EM>Precondition: </EM><MATH><I>0 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_cw6int_i9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    t.cw ( int i)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <MATH><I>i+2</I></MATH> modulo 3.<BR>\n\n<EM>Precondition: </EM><MATH><I>0 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Triangle_triangle6Face_handle_f9_const;\"></A>\nTriangle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.triangle ( Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the triangle formed by the three vertices of <I>f</I>.<BR>\n\n<EM>Precondition: </EM>The face is finite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_segment6Face_handle_f+_int_i9_const;\"></A>\nSegment\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.segment ( Face_handle f,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the line segment formed by the vertices <I>ccw(i)</I>\n and <I>cw(i)</I> of face <I>f</I>.<BR>\n\n<EM>Precondition: </EM><MATH><I>0 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 2</I></MATH>. The vertices <I>ccw(i)</I>\n and <I>cw(i)</I> of  <I>f</I>\n are finite.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_segment6const_Edge__e9_const;\"></A>\nSegment\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.segment (  Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the line segment corresponding to edge <I>e</I>.<BR>\n\n<EM>Precondition: </EM><I>e</I> is a finite edge\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_segment6const_Edge_circulator__ec9_const;\"></A>\nSegment\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.segment (  Edge_circulator ec)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the line segment corresponding to edge <I>*ec</I>.<BR>\n\n<EM>Precondition: </EM><I>*ec</I> is a finite edge.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_segment6const_Edge_iterator__ei9_const;\"></A>\nSegment\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.segment (  Edge_iterator ei)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the line segment corresponding to edge <I>*ei</I>.<BR>\n\n<EM>Precondition: </EM><I>*ei</I> is a finite edge.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_circumcenter6Face_handle_f9_const;\"></A>\nPoint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.<A HREF=\"../Kernel_23_ref/Function_circumcenter.html#Cross_link_anchor_165\">circumcenter</A> ( Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Compute the <A HREF=\"../Kernel_23_ref/Function_circumcenter.html#Cross_link_anchor_165\">circumcenter</A> of the face pointed to by f. This function\nis available only if the correspoding function is provided in the\ngeometric traits.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Setting</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set_infinite_vertex6const_Vertex_handle__v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.set_infinite_vertex (  Vertex_handle v)\n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\n<H3>Checking</H3>\nThe responsibility of keeping a valid triangulation\nbelongs to the users if advanced operations are used.\nObviously the advanced user, who implements higher levels operations\nmay have to make a triangulation invalid at some times. The following\nmethod is provided to help the debugging.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6bool_verbose_=_false+_int_level_=_09_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    t.is_valid ( bool verbose = false,  int level = 0)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Checks the combinatorial validity of the triangulation and\nalso the validity of its geometric embedding.\n This method is  mainly a debugging help\nfor the users of advanced features.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>I/O</H3>\n<P>\n\nThe I/O operators are defined for <I>iostream</I>.\nThe format for the iostream\nis an internal format.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     ostream&amp; os &lt;&lt;  T<A NAME=\"Function_ostream__operator666ostream__os+_const_Triangulation_26Traits+Tds9__T9;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the triangulation <I>t</I> into the stream <I>os</I>.<BR>\n\n<EM>Precondition: </EM>The insert operator must be defined for <I>Point</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     istream&amp; is &gt;&gt;  T<A NAME=\"Function_istream__operator996istream__is+_const_Triangulation_26Traits+Tds9__T9;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Reads a triangulation from stream <I>is</I> and assigns it\nto <I>t</I>.<BR>\n\n<EM>Precondition: </EM>The extract operator must be defined for <I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe information ouput  in the <I>iostream</I> is:<BR>\n\n- the dimension, the number of vertices (including the infinite one), \n and the number of faces (including infinite ones).<BR>\n\n- for each vertex (except the infinite vertex), \nthe non combinatorial information stored in  that vertex\n(point, etc.).<BR>\n\n- for each faces,  the indices of its vertices and \nthe non combinatorial information (if any) in  this face.\n- for each face again \n the indices of the neighboring faces.<BR>\n\nThe  index of an item  (vertex of face) is\nthe rank of this item in the ouput order.\nWhen dimension <MATH><I>&lt;</I></MATH> 2, the same information is ouput\nfor faces of maximal dimension instead of faces.\n<P>\n\nCGAL also provides  stream operators <I> &lt;&lt;</I>  to draw triangulations\non <I><A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1757\">CGAL::Window_stream</A></I>, the LEDA based graphic package,\nand on <I>CGAL::Qt_widget</I>, the Qt based graphic package.\nThese operators requires respectively  the include statements :<BR>\n\n<I>#include CGAL/IO/<A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1758\">Window_stream</A>.h</I><BR>\n\n<I>#include CGAL/IO/Qt_widget_Triangulation_2.h</I><BR>\n\nSee the chapters on <I><A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1758\">Window_stream</A></I> and on <I>Qt_widget</I> in\nthe Support Library manual.\n<P>\n\n<H3>Implementation</H3>\n<P>\n\nLocate is implemented by a line walk from a vertex of the face given\nas optional parameter (or from a finite vertex of\n<I>infinite_face()</I> if no optional parameter is given). It takes\ntime O(n) in the worst case, but only O(<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(n))\non average if the vertices are distributed uniformly at random.\n<P>\n\nInsertion of a point is done by locating a face that contains the\npoint, and then splitting this face.\nIf the point falls outside the convex hull, the triangulation\n is restored by flips.  Apart from the location, insertion takes a time \ntime O(1). This bound is only an amortized bound\nfor points located outside the convex hull.\n<P>\n\nRemoval of a vertex is done by removing all adjacent triangles, and\nretriangulating the hole. Removal takes time O(d^2) in the worst\ncase, if d is the degree of the removed vertex,\nwhich is O(1) for a random vertex.\n<P>\n\nThe face, edge, and vertex iterators on finite features\nare derived from their counterparts visiting all (finite and infinite)\nfeatures which are themselves derived from the corresponding iterators\nof the triangulation data structure.\n<P>\n\n<H3>See Also</H3><I><A HREF=\"Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I><BR>\n\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I><BR>\n\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2--Face.html#Cross_link_anchor_962\">TriangulationDataStructure_2::Face</A></I><BR>\n\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2--Vertex.html#Cross_link_anchor_964\">TriangulationDataStructure_2::Vertex</A></I><BR>\n\n<I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I><BR>\n\n<I><A HREF=\"Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Triangulation_face_base_2.html#Cross_link_anchor_946\">CGAL::Triangulation_face_base_2</A>&lt;Traits&gt;</I>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Triangulation_cw_ccw_2.html\"><I>Triangulation_cw_ccw_2</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_32!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 42237.0}