{"text": "About the assignments in ICS 141 This course teaches not only new concepts but also new ways of thinking Learning to think in new ways usually requires practice actually doing the new things a few times or more The homeworks are your opportunity to get that practice Don t just say to yourself Let me just get the answer down and turn it in I ll learn how to do it later Keep working by yourself with the instructor or TAs or with your classmates until you can produce the answers on your own without help It s no secret that some of the problems we assign this quarter are the same as we assigned last quarter It is entirely possible for you to find the answers from someone who took the course before and just copy them down and turn them in But besides being academically dishonest it also won t prepare you to do similar problems on the exams so your course grade will suffer Give the assignments the time and attention they require and enjoy stretching your mental muscles Due date This assignment is due on Monday January 24 by 3 PM Deposit your assignment in the locking drop box in room CS 189 The due date is closer than it seems be sure to get started this week so you can ask questions in discussion on Friday Summary For this assignment you will become acquainted with running the Scheme interpreter and the basic patterns of recursive list processing code in Scheme A few of the problems will seem familiar to those who took ICS 22 here from me I apologize for the repetition but your work back then will pay off now Part I Readings and review questions Each chapter of Sebesta ends with two sets of exercises one called review questions and one called problem set Each set is numbered starting from 1 so be careful to verify which set we re asking for on each assignment You should know the answers to the review questions listed below but you do not have to turn them in This list should help you identify some of the more important concepts in the text On the other hand don t infer that topics we skip or omit are entirely unimportant Chapter 1 1 11 13 15 17 19 25 27 32 Come back to these questions at the end of the course as you review for the final Chapter 2 8 14 17 21 26 3 35 38 42 43 46 Chapter 14 1 4 6 9 14 Part II In Chapter 2 of Sebesta answer in one or two brief sentences each of the following questions in the problem set on page 1 4 6 7 8 9 and 14 Note that these are questions from the problem set not from the review questions Feel free to try some of the exercises we don t assign but if you get stuck ask us before spending too much time on any problem not all of them address issues that will be important to us Part III We cover Scheme in ICS 141 for two main reasons To illustrate concepts of functional programming including higher order functions and to give you experience learning a new language that s significantly different from what you already know Learning to think in a new way isn t easy some frustration is inevitable as you stretch your mind in new directions But middle school and high school students learn this material see www schemers com and www cs rice edu CS PLT Teaching so you can too Scheme language details Writing textbooks is hard work so maybe we can forgive Sebesta missing a few details about the current status of the Scheme language standard The two boolean constants are t and f NIL is no longer used and while the empty list counts as false it s bad programming practice to use it that way Many Scheme implementations allow first and rest in place of the historically interesting but hopelessly non mnemonic car and cdr If yours doesn t you can just say define first car and define rest cdr Some Scheme implementations allow curly braces or square brackets instead of parentheses as a visual aid to matching pairs up That s not standard you should just use parentheses and let your environment do the matching for you There are two equivalent styles for defining functions which I ll call the prototype form and the lambda form Sebesta uses the prototype form which is shorter and which illustrates what a call might look like define cube x x x x I prefer the lambda form which doesn t hide the underlying lambda expression and which is consistent in form with other uses of define define cube lambda x x x x Scheme implementations The NT machines in the labs have an implementation of Scheme called EdScheme For use at home you can download a limited time version of EdScheme for free from www schemers com you can also purchase a copy for about 5 off see us for details We also recommend DrScheme another implementation from Rice University that s available entirely for free on most every platform www cs rice edu CS PLT packages drscheme Problems For most of these problems we ll ask you to print out the transcript window showing your interaction with the Scheme interpreter You ll probably want to produce a separate transcript for turning in rather than printing out pages and pages showing all your experimentation But don t worry if your transcript contains a few typos a Get used to the Scheme environment Try some expressions like 123 456 and expt 2 1 and 3 14159265 2 Type in some definitions of symbols in the global environment like define pi 3 14159265 and then try pi 2 Type in a function definition like this one define fact Compute n n factorial lambda n is 1 by definition cond The extra horizontal space n 1 isn t needed it just lines else n fact n 1 up the cond clause parts Notice how the environment indents and highlights blocks of code so you don t get the parentheses confused Make sure you know how to save your code in a file and load that file into Scheme for evaluation EdScheme doesn t automatically re evaluate changes you make in your code any more than Visual C does you have to recompile there too Try some compound expressions like gcd fact 1 expt 2 1 and fact fact 5 and first rest Huey Dewey Louie What is the value produced by fact 5 expt 7 2 This result is called exact representation it looks unusual to us but it s useful in further calculations because nothing is lost by rounding off to a decimal representation On the other hand evaluate output fixed point fact 5 expt 7 2 15 1 The 15 is the total size in characters of the result the 1 is the number of digits to the right of the decimal point The code for output fixed point is available on Masterhit the NT lab server What happens when you evaluate fact fact 5 Play around more with EdScheme trying other expressions Experiment with the list operators cons first rest list append null until you re comfortable with how they work You can look at the online help available under the Help menu or question mark button for some more information To understand what a function does be sure you understand what kinds of data it expects as its arguments atoms lists numbers and what kind of data it returns The function cons for example takes any expression as its first argument and a list as its second argument and it returns a list You don t have to turn anything in for this part III a of the lab But of course if you short change the time you spend building familiarity you ll have much more trouble later on b This function called Ackerman s function grows really fast define A lambda x y cond x 1 y y A x 1 1 else A x 1 A x y 1 b 1 Type it in and try it out with very small arguments Then print out the Transcript window showing what you did But you don t have to print out results that show pages and pages of solid digits b 2 Rewrite Ackerman s function on paper using standard mathematical notation c What s the longest number you can generate in the Scheme you re using without running out of memory and taking no more than 6 seconds of processor time Generating the big numbers is one part of the question counting the digits is another c 1 Try using string length number string your big number c 2 Try to approximate it using the log base 1 c 3 Try to do it using some tool s other than Scheme or any programming language c 4 Using your wristwatch or slow measured counting time how long it takes for Scheme to calculate and display your big number Now time how long it takes to calculate the big number and then its length by nesting the expression to generate the big number inside the length calculating expression from part c 1 or c 2 You d expect the second to take longer but on some Scheme systems it doesn t Does it on your system Why might the generate and calculate length task take less time c 5 Type up your answers to these questions and print a transcript showing what you did Again don t print more than a page or two of solid digits d Write each of the following functions in Scheme For each pay attention to the type of value that s returned Is it a list a single item a number a boolean If you re new to recursive thinking it will take you a while to start seeing the patterns that s why there are so many exercises and even this many may not be enough Go back and read what the course reference sheet says about collaboration It s good to work with your classmates but remember that the goal is that you be able to write routines like this independently member A B returns t true if A occurs in the list B and f false if it doesn t Sebesta solves this in the text but try it yourself first member a returns f member a b a t t y returns t member b c a b b c d b c returns t member b c a b c returns f find all evens A takes a list of numbers and returns a list containing all the numbers from the original list that are even The predefined predicate even is useful here find all evens returns find all evens 3 9 7 returns find all evens 1 2 3 4 5 returns 2 4 find all evens 3 2 7 2 6 returns 2 2 6 all even A takes a list of numbers and returns t if they re all even and f otherwise all even returns t all even 3 5 7 2 6 returns f all even 2 8 4 88 returns t count all matches A B returns the number of times A occurs in the list B count all matches a returns count all matches a a b a c a d returns 3 count all matches a a b a c a d returns 1 count all matches a b a b a b a b a b a b returns 2 subst A B C returns C with all occurrences of A changed to B subst x y returns subst a b a c e returns b c e subst a b b c d returns b c d subst a a b a b r a returns a b b r a b subst a b c abc w x a b c y a b c z returns w x abc y abc z first atom A returns the first atom in the list A no matter how deeply nested Use the predefined predicates pair and null to test whether something is an atom or not first atom returns first atom a b c returns a first atom a b c returns a first atom a b c returns which is easy because atom is t atomize A returns a list of all the atoms in A no matter how deeply nested Hint Use the predefined function append L1 L2 to join the atoms in first A with the atoms in rest A atomize returns atomize a b c returns a b c atomize a b c returns a b c atomize a b c d e returns a b c d e Again print out a transcript showing your definitions and some tests indicating that they re right ", "_id": "http://www.ics.uci.edu/~kay/courses/141/hw/hw1.html", "title": "asst. 1 * scheme introduction", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Wednesday, January 19, 2000 3:52 PM\">\n<TITLE>Asst. 1 * Scheme Introduction</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"644EC08E\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Programming languages, homework, Scheme\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Assignment 1, Scheme Introduction, for ICS 141, an undergraduate course in the concepts of programming languages taught by David G. Kay in the Department of Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2000 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"asst_1_scheme_introduc_files/sidebar_76.gif\" WIDTH=468 HEIGHT=78>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4><B>About the assignments in ICS 141:</B> \nThis course teaches not only new concepts but also new ways of thinking.\n Learning to think in new ways usually requires practice-- actually <I>doing</I>\nthe new things a few times (or more).  The homeworks are your opportunity\nto get that practice.  Don&#39;t just say to yourself, &quot;Let me just\nget the answer down and turn it in; I&#39;ll learn how to do it later.&quot;\n Keep working (by yourself, with the instructor or TAs, or with your classmates)\nuntil you can produce the answers on your own, without help.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>It&#39;s no secret that some of the problems\nwe assign this quarter are the same as we assigned last quarter.  It is\nentirely possible for you to find the answers from someone who took the\ncourse before and just copy them down and turn them in.  But besides being\nacademically dishonest, it also won&#39;t prepare you to do similar problems\non the exams, so your course grade will suffer.  Give the assignments the\ntime and attention they require, and enjoy stretching your &quot;mental\nmuscles.&quot;</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Due date:</B>  This assignment is due on\nMonday, January 24, by 3:00 PM.  Deposit your assignment in the locking\ndrop box in room CS 189.  The due date is closer than it seems; be sure\nto get started this week so you can ask questions in discussion on Friday.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Summary:</B>  For this assignment you will\nbecome acquainted with running the Scheme interpreter and the basic patterns\nof recursive list processing code in Scheme.  A few of the problems will\nseem familiar to those who took ICS 22 here from me; I apologize for the\nrepetition but your work back then will pay off now.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part I (Readings and review questions):</B>\n Each chapter of Sebesta ends with two sets of exercises, one called &quot;review\nquestions&quot; and one called &quot;problem set.&quot;  Each set is numbered\nstarting from 1, so be careful to verify which set we&#39;re asking for\non each assignment.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You should know the answers to the review\nquestions listed below, but you do not have to turn them in.  This list\nshould help you identify some of the more important concepts in the text.\n (On the other hand, don&#39;t infer that topics we skip or omit are entirely\n<I>un</I>important.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 1:  1-11, 13, 15-17, 19-25, 27-32.\n Come back to these questions at the end of the course, as you review for\nthe final.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 2:  8, 14-17, 21, 26-30, 35-38, 42,\n43, 46.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 14:  1, 4, 6-9, 14.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part II:</B>  In Chapter 2 of Sebesta,\nanswer in one or two brief sentences each of the following questions in\nthe problem set on page 104:  6, 7, 8, 9, and 14.  (Note that these are\nquestions from the &quot;problem set,&quot; not from the &quot;review questions.&quot;)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Feel free to try some of the exercises we\ndon&#39;t assign, but if you get stuck, ask us before spending too much\ntime on any problem; not all of them address issues that will be important\nto us.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part III:</B>  We cover Scheme in ICS 141\nfor two main reasons:  To illustrate concepts of functional programming,\nincluding higher-order functions, and to give you experience learning a\nnew language that&#39;s significantly different from what you already know.\n Learning to think in a new way isn&#39;t easy; some frustration is inevitable\nas you stretch your mind in new directions.  But middle school and high\nschool students learn this material (see </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.schemers.com\">www.schemers.com</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">www.cs.rice.edu/CS/PLT/Teaching/</FONT><FONT FACE=\"AGaramond\" SIZE=4>),\nso you can, too.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Scheme language details:</B>  Writing textbooks\nis hard work, so maybe we can forgive Sebesta missing a few details about\nthe current status of the Scheme language standard:\n<BR>\n-- The two boolean constants are </FONT><FONT FACE=\"Courier New\">#t</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">#f</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n </FONT><FONT FACE=\"Courier New\">NIL</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis no longer used, and while the empty list counts as false, it&#39;s bad\nprogramming practice to use it that way.\n<BR>\n-- Many Scheme implementations allow </FONT><FONT FACE=\"Courier New\">first</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">rest</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nin place of the historically interesting but hopelessly non-mnemonic </FONT><FONT FACE=\"Courier New\">car</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">cdr</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n If yours doesn&#39;t, you can just say </FONT><FONT FACE=\"Courier New\">(define\nfirst car)</FONT><FONT FACE=\"AGaramond\" SIZE=4> and </FONT><FONT FACE=\"Courier New\">(define\nrest cdr)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n<BR>\n-- Some Scheme implementations allow curly braces or square brackets instead\nof parentheses, as a visual aid to matching pairs up.  That&#39;s not standard;\nyou should just use parentheses and let your environment do the matching\nfor you.\n<BR>\n-- There are two equivalent styles for defining functions, which I&#39;ll\ncall the prototype form and the lambda form.  Sebesta uses the prototype\nform, which is shorter and which illustrates what a call might look like:\n</FONT><FONT FACE=\"Courier New\">(define (cube x) (* x x x))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n I prefer the lambda form, which doesn&#39;t hide the underlying lambda\nexpression and which is consistent in form with other uses of </FONT><FONT FACE=\"Courier New\">define</FONT><FONT FACE=\"AGaramond\" SIZE=4>:\n </FONT><FONT FACE=\"Courier New\">(define&#160;cube&#160;(lambda&#160;(x)\n(* x x x)))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Scheme implementations:</B>  The NT machines\nin the labs have an implementation of Scheme called EdScheme.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>For use at home, you can download a limited-time\nversion of EdScheme for free from </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.schemers.com\">www.schemers.com</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\nyou can also purchase a copy for about 50% off (see us for details).  We\nalso recommend DrScheme, another implementation from Rice University that&#39;s\navailable entirely for free on most every platform (</FONT><FONT FACE=\"Courier New\">www.cs.rice.edu/CS/PLT/packages/drscheme/</FONT><FONT FACE=\"AGaramond\" SIZE=4>).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Problems:</B>  For most of these problems,\nwe&#39;ll ask you to print out the transcript window showing your interaction\nwith the Scheme interpreter.  You&#39;ll probably want to produce a separate\ntranscript for turning in, rather than printing out pages and pages showing\nall your experimentation.  But don&#39;t worry if your transcript contains\na few typos.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  Get used to the Scheme environment.\n Try some expressions like </FONT><FONT FACE=\"Courier New\">(* 123 456)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">(expt 2 100)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">(/ 3.14159265 2)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Type in some definitions of symbols in the\nglobal environment, like </FONT><FONT FACE=\"Courier New\">(define pi 3.14159265)</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nand then try </FONT><FONT FACE=\"Courier New\">(/ pi 2)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Type in a function definition like this one:<A NAME=\"_14_5735\"></A></FONT></P>\n<P>\n<CODE><FONT FACE=\"Courier New\">(define fact                            \n     ; Compute n! (n factorial).\n<BR>\n&#160;&#160; (lambda (n)                                ; 0! is 1 by definition\n<BR>\n&#160;&#160;  &#160; (cond                                   ; The extra\nhorizontal space\n<BR>\n&#160;&#160;  &#160;  &#160; ((&lt;= n 0)  1 )                       ; isn&#39;t\nneeded; it just lines\n<BR>\n&#160;&#160;  &#160;  &#160; (else      (* n (fact (- n 1)))))))  ; up the\ncond clause parts.</FONT></CODE></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Notice how the environment indents and highlights\nblocks of code so you don&#39;t get the parentheses confused.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Make sure you know how to save your code in\na file and load that file into Scheme for evaluation.  EdScheme doesn&#39;t\nautomatically re-evaluate changes you make in your code, any more than Visual\nC++ does (you have to recompile there, too).\n<BR>\nTry some compound expressions, like </FONT><FONT FACE=\"Courier New\">(gcd\n(fact 100) (expt 2 1000))</FONT><FONT FACE=\"AGaramond\" SIZE=4> and</FONT><FONT>\n</FONT><FONT FACE=\"Courier New\">(fact (fact 5))</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">(first&#160;(rest &#39;(Huey Dewey Louie)))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>What is the value produced by </FONT><FONT FACE=\"Courier New\">(/\n(fact 5) (expt 7 2))</FONT><FONT FACE=\"AGaramond\" SIZE=4>?  This result\nis called &quot;exact representation&quot;--it looks unusual to us, but\nit&#39;s useful in further calculations because nothing is lost by rounding\noff to a decimal representation.  On the other hand, evaluate </FONT><FONT FACE=\"Courier New\">(output-fixed-point\n(/ (fact 5) (expt 7 2)) 15 10)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.  (The\n15 is the total size in characters of the result; the 10 is the number of\ndigits to the right of the decimal point.)  The code for </FONT><FONT FACE=\"Courier New\">output-fixed-point</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis available on Masterhit, the NT lab server.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>What happens when you evaluate</FONT><FONT>\n</FONT><FONT FACE=\"Courier New\">(fact (fact 500))</FONT><FONT FACE=\"AGaramond\" SIZE=4>?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Play around more with EdScheme, trying other\nexpressions.  Experiment with the list operators--</FONT><FONT FACE=\"Courier New\">cons</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nfirst</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nrest</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nlist</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nappend</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nnull?</FONT><FONT FACE=\"AGaramond\" SIZE=4>--until you&#39;re comfortable\nwith how they work.  You can look at the online help (available under the\nHelp menu or question-mark button) for some more information.  To understand\nwhat a function does, be sure you understand what kinds of data it expects\nas its arguments (atoms? lists? numbers?) and what kind of data it returns.\n The function </FONT><FONT FACE=\"Courier New\">cons</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nfor example, takes any expression as its first argument and a list as its\nsecond argument, and it returns a list.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You don&#39;t have to turn anything in for\nthis part (<B>III (a)</B>) of the lab.  But of course if you short-change\nthe time you spend building familiarity, you&#39;ll have much more trouble\nlater on.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  This function, called Ackerman&#39;s\nfunction, grows really fast:<A NAME=\"_14_8111\"></A>\n<BR>\n</FONT><CODE><FONT FACE=\"Courier New\">(define A\n<BR>\n&#160; (lambda (x y)\n<BR>\n&#160;   (cond ((= x 0) (+ 1 y))\n<BR>\n&#160;         ((= y 0) (A (- x 1) 1))\n<BR>\n&#160;         (else (A (- x 1)\n<BR>\n&#160;                  (A x (- y 1)))))))\n<BR>\n</FONT></CODE><FONT FACE=\"AGaramond\" SIZE=4><B>(b.1)  </B>Type it in and\ntry it out (with very small arguments).  Then print out the Transcript window\nshowing what you did.  (But you don&#39;t have to print out results that\nshow pages and pages of solid digits.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.2)</B>  Rewrite Ackerman&#39;s function\non paper using standard mathematical notation.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)</B>  What&#39;s the longest number\nyou can generate in the Scheme you&#39;re using, without running out of\nmemory and taking no more than 60 seconds of processor time?  Generating\nthe big numbers is one part of the question; counting the digits is another.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.1)</B>  Try using </FONT><FONT FACE=\"Courier New\">(string-length\n(number-&gt;string </FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>your-big-number</U></I></FONT><FONT FACE=\"Courier New\">))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.2)</B>  Try to approximate it using\nthe log base 10.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.3)</B>  Try to do it using some tool(s)\nother than Scheme (or any programming language).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.4)</B>  Using your wristwatch (or slow,\nmeasured counting), time how long it takes for Scheme to calculate and display\nyour big number.  Now, time how long it takes to calculate the big number\n<I>and then</I> its length (by nesting the expression to generate the big\nnumber inside the length-calculating expression from part <B>(c.1)</B> or\n<B>(c.2)</B>).  You&#39;d expect the second to take longer, but on some\nScheme systems it doesn&#39;t.  Does it on your system?  Why might the generate-and-calculate-length\ntask take <I>less</I> time?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.5)</B>  Type up your answers to these\nquestions and print a transcript showing what you did.  Again, don&#39;t\nprint more than a page or two of solid digits.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(d)</B>  Write each of the following functions\nin Scheme.  For each, pay attention to the type of value that&#39;s returned:\n Is it a list, a single item, a number, a boolean?  If you&#39;re new to\nrecursive thinking, it will take you a while to start seeing the patterns;\nthat&#39;s why there are so many exercises (and even this many may not be\nenough).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Go back and read what the course reference\nsheet says about collaboration.  It&#39;s good to work with your classmates,\nbut remember that the goal is that you be able to write routines like this\nindependently.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(member? A B)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\n(true) if </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\noccurs in the list </FONT><FONT FACE=\"Courier\" SIZE=2><TT>B</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nand</FONT><FONT FACE=\"AGaramond\"> </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\n(false) if it doesn't.  (Sebesta solves this in the text, but try it yourself\nfirst.)\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? 'a '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? 'a '(b a t t y))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? '(b (c)) '(a b (b (c)) d\n(b (c))))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? '(b (c)) '(a b (c)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\ntakes a list of numbers and returns a list containing all the numbers from\nthe original list that are even.  The predefined predicate </FONT><FONT FACE=\"Courier\" SIZE=2><TT>even?</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis useful here.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '(3 9 7))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '(1 2 3 4 5))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(2 4)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '(3 2 7 2 6))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(2 2 6)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(all-even? A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\ntakes a list of numbers and returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nif they're all even, and </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\notherwise.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(all-even? '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(all-even? '(3 5 7 2 6))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(all-even? '(2 8 0 4 88))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches A B)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns the number of times </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\noccurs in the list </FONT><FONT FACE=\"Courier\" SIZE=2><TT>B</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches 'a '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>0</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches 'a '(a b a c a\nd))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>3</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches 'a '(a b (a) c\n(a d)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>1</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches '(a (b)) '(a b\n(a (b)) a (b) (a (b)) ((a (b)))))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>2</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(subst A B C)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>C</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nwith all occurrences of </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nchanged to </FONT><FONT FACE=\"Courier\" SIZE=2><TT>B</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'x 'y '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'a 'b '(a c e))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(b c e)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'a 'b '(b c d))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(b c d)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'a '(a b) '(a b r a))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>((a b) b r (a b))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst '(a b c) 'abc '(w x (a b c)\ny (a b c) z))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(w\nx abc y abc z)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(first-atom A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns the first atom in the list </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nno matter how deeply nested.  Use the predefined predicates </FONT><FONT FACE=\"Courier\" SIZE=2><TT>pair?</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand</FONT><FONT FACE=\"Courier\" SIZE=2><TT> null?</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nto test whether something is an atom or not.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '(a b c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>a</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '(((a b) c)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>a</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '( () a b c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich is easy because </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atom? '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(atomize A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns a list of all the atoms in </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nno matter how deeply nested.  (Hint:  Use the predefined function </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(append\nL1 L2)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> to join the atoms in </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first\nA)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> with the atoms in </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(rest\nA)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.)\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '(a b c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(a b c)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '((a b) c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(a b c)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '(((a) () (b c)) (d e)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(a () b c d e)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Again, print out a transcript showing your\ndefinitions and some tests indicating that they&#39;re right.</FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "id": 11114.0}