{"text": " Grid Source Code Last updated 2 13 2 13 Introduction Our Grid code is a very fast and efficient implementation of a classic problem of handling continuous range queries on top of s large number of moving objects Even though the code has been implemented some time ago we are unaware of any other solution that is faster In the setup of the problem the assumption is that one or multiple servers track the locations of moving objects The number of objects can be very high e g millions The users issue on top of the spatial domain a large number of continuous monitoring queries Unlike one time queries continuous queries are executed over a certain period of time updating their results as the situation changes and objects move For location based serves continuous range query CRQ is one of the most important query types The main challenge is to develop an efficient and scalable CRQ solution The traditional approach for processing CRQs is to build an index on the objects data and utilize it for the query processing In a moving object environment that approach suffers from the need for frequent index updates and thereby often results in poor performance To solve the efficiency and scalability challenges of the problem we have proposed a novel algorithmic technique called Query Indexing QI Query Indexing relies on reversing the role of queries and data Namely a spatial index QIndex is built on the continuous queries and no index is built on the objects data The query results are computed by issuing point queries i e the object locations to the QIndex and finding matches between objects and queries We have realized that the CRQ problem can and should be solved in memory for moving objects This is since by keeping only the necessary info in main memory and the rest on disk the data fits into the memory of an average workstation We have showed that very different types of indexes perform better in memory Specifically we have developed the Grid indexing techniques for processing queries in moving object databases resulting in orders of magnitude of improvement over competing strategies Nowadays of course many research efforts use in memory grid based solutins as the norm An interesting aspect of our solution is that unlike many other techniques it does not impose many of the common constraints such as restriction on object speeds and trajectories making it of much wider applicability How to Cite When using our code please cite it as Main memory evaluation of monitoring queries over moving objects Dmitri V Kalashnikov S Prabhakar and S Hambrusch In Distributed and Parallel Databases An International Journal DAPD 15 2 117 135 March 2 4 Download Paper Efficient evaluation of continuous range queries on moving objects Dmitri V Kalashnikov Sunil Prabhakar Susanne Hambrusch and Walid Aref In Proc of Int l Conf on Database and Expert Systems Applications DEXA Sep 2 6 2 2 Download Paper The above publications describe our Grid based approach in detail BibTeX entries for these publications are article DAPD 4 dvk author Dmitri V Kalashnikov and Sunil Prabhakar and Susanne Hambrusch title Main memory evaluation of monitoring queries over moving objects journal Distributed and Parallel Databases An International Journal volume 15 number 2 pages 117 135 month mar year 2 4 inproceedings DEXA 2 dvk author Dmitri V Kalashnikov and Sunil Prabhakar and Susanne Hambrusch and Walid Aref title Efficient Evaluation of Continuous Range Queries on Moving Objects booktitle Proc of Int l Conf on Database and Expert Systems Applications DEXA 2 2 year 2 2 month September 2 6 address Aix en Provence France Downloading Code The code can de downloaded from here Grid code zip License The solution is implemented in C The code is designed for UNIX in general The code has been tested under Solaris Linux Mac OS X GCC has been used to compile the code last tested with GCC 4 7 We recommend using the latest version of GCC C as it is often generates faster code The code is single threaded and could be sped up by implementing a parallel multi threaded version The code will report the cycle time on each iteration The cycle time is the time needed to move all the objects and process all the queries The idea is to minimize the cycle time Compiling Code Unzip Grid code zip file The code is inside Code folder The main file is test cpp Code folder and its subfolders will contains mak batch files Edit those mak files change the path of GCC s C compiler g to where it is located in your system To compile run mak inside Code folder Compilation will produce executable file called index Running Code index nXcell nYcell query perc query sz skewed num point num query navq sz nav stepX Options nXcellThe number of cells per X dimension nXcell by nYcell grid Good values to try are 1 2 5 1 nYcellThe number of cells per Y dimension nXcell by nYcell grid Good value is nYcell nXcell query percNot used unless the moving query part is uncommented in code Needed to specify the percentage of queries that will move on each iteration Set it to zero query szSpecifies query size e g when it is set to 1 all queries will be of size 1 x 1 skewParameter skew can be set to 1 or 2 to mean see papers above for the exact meaning uniform code will generate points and queries that are distributed uniformly in 1 1 normal code will generate points and queries that are distributed normally in 1 2 hyper skew code will generate points and queries that are hyper skewed in 1 num pointThe number of points to generate in thousands e g 25 means 25 num queryThe number of queries to generate in thousands e g 15 means 15 navq szNot used unless the moving query part is uncommented in code Needed to specify the size of the navigational i e moving query Set it to 1 nav stepXNot used unless the moving query part is uncommented in code Needed to specify the step each navigational i e moving query makes Set it to 1 Examples 1 Running the code for 1 Million moving objects and 1 continuos range queries of size 1x 1 each using 1 x1 grid index 1 1 1 1 1 1 1 2 Running the code for 5 moving objects and 25 continuos range queries of size 1x 1 each using 1 x1 grid index 1 1 1 5 25 1 1 Back to Kalashnikov s homepage Copyright 2 13 Dmitri V Kalashnikov All Rights Reserved ", "_id": "http://www.ics.uci.edu/~dvk/code/Grid.html", "title": "source code | grid code", "html": "<html>\r\n<HEAD>\r\n<TITLE>Source Code | Grid Code</TITLE>\r\n<META NAME=\"description\"\r\n CONTENT = \"Grid Source Code, Continuous Range Queries, Moving Objects, Grid-based\">\r\n<META NAME=\"keywords\"\r\n CONTENT = \"Grid Source Code, Continuous Range Queries, Moving Objects, Grid-based\">\r\n\r\n<style type=\"text/css\">\r\ntable.sample {\r\n    border-width: 1px;\r\n    border-spacing: ;\r\n    border-style: solid;\r\n    border-color: grey;\r\n    border-collapse: collapse;\r\n    background-color: ;\r\n\r\n}\r\ntable.sample th {\r\n    border-width: 0px;\r\n    padding: 10px;\r\n    border-style: none;\r\n    border-color: blue;\r\n    background-color: #faf0e6;\r\n    -moz-border-radius: ;\r\n\r\n}\r\ntable.sample td {\r\n    border-width: 0px;\r\n    padding: 10px;\r\n    border-style: none;\r\n    border-color: blue;\r\n    background-color: ##f5f5f5;\r\n    -moz-border-radius: ;\r\n    font-family: Arial,Helvetica;\r\n    font-size: 11pt;\r\n}\r\n\r\nh2 {\r\nfont-family: \"Arial,Helvetica\";\r\ncolor: #818501;\r\n}\r\n\r\nh3 {\r\nfont-family: \"Arial,Helvetica\";\r\ncolor: #818501;\r\nfont-size: 16pt;\r\n}\r\n\r\nh4 {\r\nfont-family: \"Arial,Helvetica\";\r\nfont-weight: normal;\r\ncolor: #818501;\r\nfont-size: 14pt;\r\n}\r\n\r\nfont {\r\nfont-family: Arial,Helvetica;\r\nfont-size: 11pt;\r\n}\r\n</style>\r\n\r\n</HEAD>\r\n\r\n<body text=\"#000000\" vlink=\"#4f4f4f\" alink=\"#818501\" link=\"#818501\" bgcolor=\"#ffffff\">\r\n\r\n<p align=\"center\">\r\n        <TABLE width=\"800\" border=\"0\" bgcolor=\"#f5f5f5\" cellspacing=\"10\" ID=\"Table1\" class=\"sample\">\r\n        <TBODY>\r\n        <TR>\r\n        <TD>\r\n\r\n<H3>\"Grid\" Source Code</H3>\r\n\r\n<font color=\"grey\">Last updated: 2/13/2013</font> \r\n\r\n<H4>Introduction</H4>\r\n</center>\r\n\r\n<p align =justify >\r\n\r\nOur <font color=\"blue\">\"Grid\"</font> code is a very fast and efficient implementation of a classic problem of handling continuous range queries on top of s large number of moving objects. Even though the code has been implemented some time ago, we are unaware of any other solution that is faster.<br>\r\n<br>\r\nIn the setup of the problem, the assumption is that one or multiple servers track the locations of moving-objects. \r\nThe number of objects can be very high, e.g., millions. The users issue on top of \r\nthe spatial domain a large number of <em>continuous</em> (monitoring) queries. \r\nUnlike one-time queries, continuous queries are executed over a certain period of time, \r\nupdating their results as the situation changes and objects move. For location-based serves, \r\ncontinuous <em>range</em> query (CRQ) is one of the most important query types. \r\nThe main challenge is to develop an <em>efficient</em> and <em>scalable</em> CRQ solution.<br> \r\n<br>\r\nThe traditional approach for processing CRQs is to build an index on the objects (data) \r\nand utilize it for the query processing. In a moving object environment that approach \r\nsuffers from the need for frequent index updates and thereby often results in poor performance.<br>\r\n<br>\r\nTo solve the efficiency and scalability challenges of the problem, we have proposed a \r\nnovel algorithmic technique called Query Indexing (QI). Query Indexing relies on reversing \r\nthe role of queries and data. Namely, a spatial index (QIndex) is built on the continuous queries, \r\nand no index is built on the objects (data). The query results are computed by issuing \r\npoint-queries (i.e., the object locations) to the QIndex and finding matches between objects and queries.<br>\r\n<br>\r\nWe have realized that the CRQ problem can (and should) be solved in-memory for moving objects. \r\nThis is since by keeping only the necessary info in main memory and the rest on disk, \r\nthe data fits into the memory of an average workstation.  We have showed that very different \r\ntypes of indexes perform better in memory. Specifically, we have developed the <b>Grid</b> indexing \r\ntechniques for processing queries in moving object databases, resulting in \r\norders of magnitude of improvement over competing strategies. \r\nNowadays, of course, many research efforts use in-memory grid-based solutins as the norm.<br> \r\n<br>\r\nAn interesting aspect of our solution is that, unlike many other techniques, it does not \r\nimpose many of the common constraints, such as restriction on object speeds and trajectories, \r\nmaking it of much wider applicability.\r\n</p>\r\n\r\n<H4>How to Cite</H4>\r\nWhen using our code please cite it as:<br/>\r\n<br/>\r\n<ol>\r\n    <LI>\r\n      <B>Main memory evaluation of monitoring queries over moving objects.</B><BR>\r\n      <B>Dmitri V. Kalashnikov</B>, S. Prabhakar, and S. Hambrusch.<BR>\r\n      In <EM><font color=blue>Distributed and Parallel Databases</font>, An International Journal (DAPD)</EM>, 15(2):117-135, March 2004<BR>\r\n      [<A href=\"http://www.ics.uci.edu/~dvk/pub/DAPD04_dvk.html\">Download Paper</A>]<BR>\r\n      <BR>\r\n\r\n\r\n\t<LI>\r\n      <B>Efficient evaluation of continuous range queries on moving objects.</B><BR>\r\n      <B>Dmitri V. Kalashnikov</B>, Sunil Prabhakar, Susanne Hambrusch, and Walid Aref.<BR>\r\n      In <EM>Proc. of Int'l Conf. on Database and Expert Systems Applications (<font color=blue>DEXA</font>)</EM>,\r\n      Sep 2-6, 2002.<BR>\r\n      [<A href=\"http://www.ics.uci.edu/~dvk/pub/DEXA02_dvk.html\">Download Paper</A>]<BR>\r\n      <BR>\r\n\r\n</ol>\r\n<br/>\r\nThe above publications describe our Grid-based approach in detail. BibTeX entries for these publications are:\r\n\r\n<pre>\r\n@article{DAPD04::dvk,\r\n   author    = {Dmitri V. Kalashnikov and Sunil Prabhakar and Susanne Hambrusch},\r\n   title     = {Main memory evaluation of monitoring queries over moving objects},\r\n   journal   = {Distributed and Parallel Databases, An International Journal},\r\n   volume    = 15, number = 2, pages = {117--135}, month = mar, year = 2004\r\n} \r\n\r\n@inproceedings{DEXA02::dvk,\r\n   author    = {Dmitri V. Kalashnikov and Sunil Prabhakar and \r\n                Susanne Hambrusch and Walid Aref},\r\n   title     = {Efficient Evaluation of Continuous Range Queries on Moving Objects},\r\n   booktitle = {Proc. of Int'l Conf. on Database and Expert Systems \r\n                Applications (DEXA 2002)},\r\n   year      = {2002}, month = {September 2--6}, address = {Aix en Provence, France}\r\n}\r\n</pre>\r\n\r\n<H4>Downloading Code</H4>\r\n<list>\r\n\t<li>The code can de downloaded from here: \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/Grid_code.zip\">Grid_code.zip</A>] \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/License.txt\">License</A>] \r\n\t<li>The solution is implemented in C++.</li>\r\n\t<li>The code is designed for UNIX in general.</li> \r\n\t<li>The code has been tested under Solaris, Linux, Mac OS X.</li>\r\n\t<li>GCC has been used to compile the code (last tested with GCC 4.7).</li> \r\n\t<li>We recommend using the latest version of GCC C++, as it is often generates faster code.</li>\r\n\t<li>The code is single-threaded and could be sped up by implementing a parallel multi-threaded version.</li>\r\n\t<li>The code will report the <dfn>cycle time</dfn> on each iteration.</li> \r\n\t<li>The cycle time is the time needed to move all the objects and process all the queries.</li>\r\n\t<li>The idea is to minimize the cycle time.</li> \r\n</list>\r\n\r\n<H4>Compiling Code</H4>\r\n<list>\r\n\t<li>Unzip <tt>Grid_code.zip</tt> file. The code is inside <tt>Code</tt> folder. The main file is <tt>test.cpp</tt>.</li>\r\n\t<li><tt>Code</tt> folder and its subfolders will contains <tt>./mak</tt> batch files\r\n\t<li>Edit those <tt>./mak</tt> files: change the path of GCC's C++ compiler (<tt>g++</tt>) to where it is located in your system.</li>  \r\n\t<li>To compile, run <tt>./mak</tt> inside <tt>Code</tt> folder.</li>\r\n\t<li>Compilation will produce executable file called <tt>index</tt>.</li>\r\n\r\n            \r\n<H4>Running Code</H4>\r\n            \r\n<tt>./index nXcell nYcell query_perc query_sz skewed num_point num_query navq_sz nav_stepX</tt>\r\n\r\n            \r\n<H4>Options</H4>\r\n<table width=\"100%\">\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>nXcell</tt></td>\r\n\t\t<td width=\"75%\">The number of cells per X-dimension (nXcell by nYcell grid). Good values to try are: 100, 200, 500, 1000.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>nYcell</tt></td>\r\n\t\t<td width=\"75%\">The number of cells per Y-dimension (nXcell by nYcell grid). Good value is <tt>nYcell=nXcell</tt>.</td>\r\n\t</tr>\r\n\t\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>query_perc</tt></td>\r\n\t\t<td width=\"75%\">Not used, unless the moving-query part is uncommented in code. Needed to specify the percentage of queries that will move on each iteration. Set it to 0 (zero).</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>query_sz</tt></td>\r\n\t\t<td width=\"75%\">Specifies query size, e.g., when it is set to 0.01, all queries will be of size 0.01 x 0.01. </td>\r\n\t</tr>\r\n\t\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>skew</tt></td>\r\n\t\t<td width=\"75%\">Parameter <tt>skew</tt> can be set to 0, 1, or 2 to mean (see papers above for the exact meaning):<font size=4><br><br></font>\r\n\t\t\t<tt>0</tt> - uniform: code will generate points and queries that are distributed uniformly in [0,1].<br>\r\n\t\t\t<tt>1</tt> - normal : code will generate points and queries that are distributed normally in [0,1].<br>\r\n\t\t\t<tt>2</tt> - hyper-skew: code will generate points and queries that are hyper-skewed in [0,1].\r\n\t\t</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>num_point</tt></td>\r\n\t\t<td width=\"75%\">The number of points to generate in thousands, e.g. 25 means 25,000.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>num_query</tt></td>\r\n\t\t<td width=\"75%\">The number of queries to generate in thousands, e.g. 15 means 15,000.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>navq_sz</tt></td>\r\n\t\t<td width=\"75%\">Not used, unless the moving-query part is uncommented in code. Needed to specify the size of the navigational (i.e., moving) query. Set it to 0.01.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>nav_stepX</tt></td>\r\n\t\t<td width=\"75%\">Not used, unless the moving-query part is uncommented in code. Needed to specify the step each navigational (i.e., moving) query makes. Set it to 0.001.</td>\r\n\t</tr>\r\n</table>\r\n            \r\n            \r\n\r\n<H4>Examples</H4>\r\n1) Running the code for 1 Million moving objects and 100,000 continuos range queries of size 0.01x0.01 each using 1000x1000 grid.<br>  \r\n<br>\r\n<tt>./index 1000 1000 0 0.01 0 1000 100 0.001 0.0001</tt><br>\r\n            <br>\r\n            <br>\r\n<br>\r\n2) Running the code for 500,000 moving objects and 25,000 continuos range queries of size 0.01x0.01 each using 100x100 grid.<br>  \r\n<br>\r\n<tt>./index 100 100 0 0.01 0 500 25 0.001 0.0001</tt><br\r\n\r\n<IMG SRC=\"https://students.ics.uci.edu/~dvk/fig.cgi?Grid_code\" width=1 height=1>\r\n</p>\r\n<BR>\r\n<BR>\r\n<A href=\"http://www.ics.uci.edu/~dvk/index.html\">Back to Kalashnikov's homepage</A>\r\n<BR>\r\n<BR>\r\n<center><font face=\"Arial,Helvetica\" style=\"font-SIZE: 8pt\" color=\"gray\"> Copyright &copy; 2013 Dmitri V. Kalashnikov. All Rights Reserved.</font></center>\r\n</html> ", "id": 4565.0}