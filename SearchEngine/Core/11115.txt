{"text": "Program 4 Implementing Maps and Sets and their iterators with Hash Tables ICS 46 Data Strcuture Implementation and Analysis Introduction This programming assignment is designed to ensure that you know how to implement two templated classes Map and Set with Hash Tables Your implementations will also include fully functional iterators for these classes For the map you will be writing code that processes the underlying array storing a pointer to a trailer linked list of key value pairs For the set you will be writing simlar code that processes the underlying array storing a pointer to a trailer linked list of elements You can test these implementations by using the standard drivers provided with the download and GoogleTests that we will use when grading your code for correctness recall that you can augment the GoogleTest with whatever code you want to aid your debugging a GoogleTest is just a C program You can also test the code you wrote for Programming Assignment 1 using array implementations of these classes by substituting these hash table implementations typically by changing a few typedef statements and adding the hash function needed for their constructors Write and use the standard insertion operator and str method in the map and set classes for debugging For each return a std string that explicitly shows the trailer linked list in each bin along with the other instance variables so you can easily examine the structure of the BST To simplify the result represent the trailer node just by Note that there is no tested requirement for what these methods return but the versions above will make debugging easier Here is an example of what my str method returns for a HashMap with 3 bins and 3 key value pairs bin pair b 2 pair a 1 bin 1 bin 2 pair c 3 You should download the program4 project folder and use it to create an Eclipse project ultimately needing to connect it to both the courselib and googletest libraries You will write the required methods in the hash map hpp and hash set hpp files in this project and submit each separately in Checkmate The project folder also contains two pairs of hpp and cpp files a driver GoogleTest pair for each class that you will write and the driver cpp file which has a main function that can be made to run any of the two drivers Instead you can also use a existing working project folder that already is connected to both the courselib and googletest libraries remove but save all the files in its src folder and then put all the hpp and cpp files from the downloaded project s src folder into the existing working project s src folder Important Only one of the cpp files with a main method can be active compiling at any time In the download only the driver cpp file is active the GoogleTests are inactive To make a progam inactive select it in the editor tab use the Ctrl a command to select all its lines and then click Source at the top left of the menu and choose Toggle Comment ever line will now appear in a comment so the main function is commented out by using these same instructions you can toggle back those lines to not have comments I recommend that you work on this assignment in pairs with someone in your lab section Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early Only one student should submit all parts of the the assignment but both student s names along with their UniqueID should appear in the comments at the top of each submitted cpp file It should look something like Romeo Montague UniqueID from grades spreadsheet Juliet Capulet UniqueID from grades spreadsheet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files This assignment has 2 parts pairs should work on each part together not split them up and do them separately This is especially important in this assignment because once you have a working HashMap you can reuse many parts of its code in HashSet Part 1 is worth 6 points part 2 is worth 2 points Remember I m going to be running MOSS on the parts of this assignment IMPORTANT The courselib contains an array implementation for the map and set data types and you have written a BST version of map and a trailer linked list version of set although this assignment requires you to use hash tables with trailer linked lists there are still many strong similarities at a high level in all these implementations So I encourage you to examine these implementations closely and understand them possibly experiment with them using their drivers or GoogleTests while you are writing your hash table implementation this advice is especially true as you begin to study understand and implement iterators Please feel free about asking questions about these methods both their syntax and semantics Probaby the right way to design this assignment is to write a general HashTable class and then use it to implement both HashMap and HashSet But bacause of the complexity of using templated classes in C the shortness of time and the fact that hash tables are used slightly differently to implement maps and sets I have simplified the assignment by requiring you to implement hash tables in map and then reimplement them in set Maps Map can be implemented by a variety of data structures they all associate unique keys with values by storing an ics pair holding both the key and its value The data structure should allow us quickly to find the value associated with a key and possibly change update such a value Note that because we are using trailer linked lists for chaining no bin will be empty it will at least store a trailer This property is important when we create hash tables and when we double their number of bins see ensure load factor below We can implement maps efficiently by using a hash tables using a simple hashing function on only the key first part of the pair Most operations updating hash table O 1 When writing the copy constructor and operator use the fact that the hash table being copied already has all the pairs in the right bins to simplify these operations and avoiding rehashing the keys The file hash map hpp declares the appropriate constructors methods and instance variables Note the many helper methods that operate on hash tables most are easily implemented iteratively Many of the standard map methods call one or more of these helper methods to retrieve information from a hash table or change it e g add remove key value assocations These include int hash compress const KEY key const This method uses the hash function supplied by the constructor and the number of bins in the current hash table to compute the bin index of any given key Remember to compute the absoluate value of the hash function which can return a negative result and use the remainder operator to ensure a bin index in the range bins void ensure load factor int new used This method ensures that a hash table with new used values does not exceed the load factor based on this value and the number of bins currently in the hash table If this ratio compute it with doubles would exceed the load factor threshold it creates a new hash table with twice the number of bins and puts all the values in the original hash table into the new one which requires rehashing each since compression using a new number of bins can produce a different bin index from hash compress To be efficient we can reuse all the LN objects for the values in the original hash table rather than deallocating and creating a new LN for each value In such a case we could still create new trailers for all the bins in the new hash table and ultimately deallocate all trailers in the original hash table We typically call this method before adding a key value to the map and do not call it when changing the value associate with a key remember that calling this method can change how hash compress does its job in the future because the number of bins might change LN find key int bin const KEY key const This method attempts to find the LN storing key in the bin index of a hash table if successful it returns a pointer to that LN possibly to examine or update its associated value if unsuccessful it returns nullptr The caller of this function will determine what to do with the pointer returned bool find value const T value const This method traverses all the LNs in all the bins in a hash table attempting to to find any LN storing value if successful it returns true if unsuccessful it returns false LN copy list LN l const This method copies a linked list including the trailer node It is used in copy hash table LN copy hash table LN ht int bins const This method copies an entire hash table by allocating space for the bins and then copying the list nodes in each bin It does not need to call hash compress void delete hash table LN ht int bins This method deletes every LN used in the hash table and then deletes the hash table itself I have written boilerplate for all these methods I suggest examining code in the array map hpp or bst map files to help you understand some of the bookkeeping requirements of these methods Pay close attention to ensure all instance variables receive values in the constructors and are used set correctly in queries and commands Iterators We return to simpl ish efficient iterators for hash tables made even more simple by using trailer lists Note that map iterators produce Entry which is defined by typedef ics pair KEY T Entry Here are some useful to know use properties of cursors in hash tables We represent a cursor by ics pair of cursors where first is the bin index of the cursor and second points to an LN in the trailer linked list in that bin index We represent the end cursor for a hash table with first as 1 and second as nullptr special values for each part of the cursor The begin cursor in an empty hash table is the same as the end cursor The begin cursor in a non empty hash table stores in first the index of the first bin whose linked list stores more than just a trailer node and stores in second a pointer to the first LN in that linked list We advance a non end cursor by moving its second to the next LN in the linked list but if that is the trailer node by moving to higher bin indexes until we either a find a bin whose linked list stores more than just a trailer node or b run out of bins to check For a we used that bin index and a pointer to the first LN in that bin s linked list for b we use an end cursor 1 and nullptr I boiler plated an advance cursors helper method to peform this operation which can even be used to compute the begin cursor for a hash table Finally the iterator s erase method leverages the simple code to remove an LN from trailer linked list It also must update various bookkeeping instance variables and of course actually delete recycle the LN that is removed This approach makes the iterators fairly easy to write and efficient to use requiring little extra space Feel free to question discuss iterators for HashMap on the message boards so long as no code is posted or described in too much detail Sets Not much to say here Take all that you learned about the hash table implementation of map and apply it to the implementation of set I reused copy pasted unchanged all the helper methods discussed above For the actual set constructors and methods I wrote similar code The main difference between maps and sets is that values in maps are key value pairs and values in sets are just single values Testing There are various ways to test each of the classes you are writing in this programming assignment First though you should write all the methods paying careful attention to the array implementations and previously written linked list implementations For some you might just boiler plate simple code that is not correct but allows the methods to compile allowing other methods in the classes to be tested The easiest way to start testing debugging is by using the driver program It allows you to perform any method call supported by the templated classes and see the state of the class or view the debugger Of course you must get the insertion operator and str method to work before using it to debug the other methods After you debug your code with the driver try running the appropriate GoogleTest code Again this form of testing is useful only as you approach a finished solution We will use the GoogleTest and visual inspection to grade this assignment Important Note You can put std cout statements in the GoogleTest code but don t accidentally remove any of the assertions otherwise you won t be fully checking your code the way we will while you are debugging your classes All debugging std cout should end in std endl to flush the output stream ensure the output it displayed before executing the next statement When you run the GoogleTest choose small values for the first and third prompts just press return to the second prompt or comment out these prompts and assign small values to these variables instead Besides an indication of which tests pass and fail the console window will show a speed for the speed test which will vary depending on how fast a machine you run your code on don t worry about it When your code is passing all the tests put in values like 1 for these prompts Finally Eclipse shows errors in files that use of std hash but we can still compile link and run these files So the drivers for map and set each show one error and the GoogleTest for map and set show two errors and syntax errors for each TEST again we can still run all these programs ", "_id": "http://www.ics.uci.edu/~pattis/ICS-46/assignments/program4/program.html", "title": "program 4", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 4</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 4</h1>\r\n<h1>Implementing Maps and Sets<br>\r\n    (and their iterators) with Hash Tables\r\n</h1>\r\n<p>\r\n<h2>ICS-46: Data Strcuture Implementation and Analysis\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to\r\n  implement two templated classes (<b>Map</b> and <b>Set</b>) with Hash\r\n  Tables.\r\nYour implementations will also include fully-functional iterators for\r\n  these classes.\r\nFor the map you will be writing code that processes the underlying array\r\n  storing a pointer to a trailer linked-list of key-&gt;value pairs.\r\nFor the set you will be writing simlar code that processes the underlying array\r\n  storing a pointer to a trailer linked-list of elements.\r\n<p>\r\nYou can test these implementations by using the standard drivers (provided\r\n  with the download) and GoogleTests that we will use when grading your\r\n  code for correctness; recall that you can augment the GoogleTest with whatever\r\n  code you want, to aid your debugging: a GoogleTest is just a C++ program.\r\nYou can also test the code you wrote for Programming Assignment #1 (using\r\n  array implementations of these classes) by substituting these hash table\r\n  implementations -typically by changing a few <b>typedef</b> statements\r\n  and adding the hash function needed for their constructors.\r\n<p>\r\nWrite and use the standard <b>insertion</b> (<b>&lt;&lt;</b>) operator and\r\n  <b>str()</b> method in the map and set classes for debugging.\r\nFor each return a <b>std::string</b> that explicitly shows the trailer\r\n  linked-list in each bin, along with the other instance variables, so you can\r\n  easily examine the structure of the BST.\r\nTo simplify the result, represent the trailer node just by <b>#</b>.\r\nNote that there is no tested requirement for what these methods return, but\r\n  the versions above will make debugging easier.\r\nHere is an example of what my <b>str()</b> method returns for a <b>HashMap</b>\r\n  with 3 bins and 3 key-&gt;value pairs:<pre><b>\r\n  bin[0]: pair[b,2] -> pair[a,1] -> #\r\n  bin[1]: #\r\n  bin[2]: pair[c,3] -> #</b></pre>\r\n<p>\r\nYou should download the \r\n  <a href=\"program4.zip\">program4</a> project folder and use it to create an\r\n  Eclipse project (ultimately needing to connect it to both the\r\n  <b>courselib</b> and <b>googletest</b> libraries).\r\nYou will write the required methods in the <b>hash_map.hpp</b> and\r\n  <b>hash_set.hpp</b> files in this project, and submit each separately in\r\n  Checkmate.\r\nThe project folder also contains two pairs of <b>.hpp</b> and <b>.cpp</b>\r\n  files: a driver/GoogleTest pair for each class that you will write, and the\r\n  <b>driver.cpp</b> file which has a <b>main</b> function that can be made to\r\n  run any of the two drivers.\r\n<p>\r\nInstead, you can also use a existing/working project folder that already is\r\n connected to both the <b>courselib</b> and <b>googletest</b> libraries: remove\r\n  (but save) all the files in its <b>src</b> folder and then put all the\r\n  <b>.hpp</b> and <b>.cpp</b> files from the downloaded project's <b>src</b>\r\n  folder into the existing/working project's <b>src</b> folder.\r\n<p>\r\n<b>Important: Only one of the <b>.cpp</b> files with a <b>main</b> method can\r\n  be active/compiling at any time.</b>\r\nIn the download, only the <b>driver.cpp</b> file is active; the GoogleTests are\r\n  inactive.\r\nTo make a progam inactive, select it (in the editor tab), use the <b>Ctrl/a</b>\r\n  command to select all its lines, and then click <b>Source</b> at the top\r\n  left of the menu and choose <b>Toggle Comment</b>: ever line will now appear\r\n  in a comment (so the <b>main</b> function is commented-out; by using these\r\n  same instructions, you can toggle back those lines to not have comments.\r\n<p>\r\nI recommend that you work on this assignment in pairs, with someone in your lab\r\n  section.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  student's names (along with their UniqueID) should appear in the comments at\r\n  the top of <b>each submitted .cpp</b> file.\r\nIt should look something like\r\n<pre><b>\r\n//Romeo Montague(UniqueID from grades spreadsheet)\r\n//Juliet Capulet(UniqueID from grades spreadsheet)\r\n//We certify that we worked cooperatively on this programming\r\n//  assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  before starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can accurately\r\n  assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\n<p>\r\n<p>\r\nThis assignment has 2 parts: pairs should work on each part together, not split\r\n  them up and do them separately.\r\nThis is especially important in this assignment, because once you have a working\r\n  <b>HashMap</b>, you can reuse many parts of its code in <b>HashSet</b>.\r\nPart 1 is worth 60 points; part 2 is worth 20 points.\r\nRemember I'm going to be running MOSS on the parts of this assignment.\r\n<p>\r\nIMPORTANT: The courselib contains an array implementation for the map and set\r\n  data types (and you have written a BST version of map; and a trailer\r\n  linked-list version of set); although this assignment requires you to use\r\n  hash tables (with trailer linked-lists), there are still\r\n  <b>many strong similarities</b> at a high level in all these implementations.\r\nSo, I encourage you to examine these implementations closely, and understand\r\n  them; possibly, experiment with them (using their drivers or GoogleTests),\r\n  while you are writing your hash table implementation: this advice is\r\n  especially true as you begin to study, understand, and implement iterators.\r\nPlease feel free about asking questions about these methods: both their syntax\r\n  and semantics.\r\n<p>\r\nProbaby the right way to design this assignment is to write a general\r\n  <b>HashTable</b> class, and then use it to implement both <b>HashMap</b> and\r\n  <b>HashSet</b>.\r\nBut, bacause of the complexity of using templated-classes in C++, the shortness\r\n  of time, and the fact that hash tables are used slightly differently to\r\n  implement maps and sets, I have \"simplified\" the assignment by requiring you\r\n  to implement hash tables in map (and then reimplement them in set).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- map -->\r\n\r\n<a name=\"map\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Maps</b></td>\r\n<td width =\"80%\">\r\nMap can be implemented by a variety of data structures: they all associate\r\n  unique keys with values, by storing an <b>ics::pair</b> holding both the\r\n  key and its value.\r\nThe data structure should allow us quickly to find the value associated with\r\n  a key, and possibly change/update such a value.\r\n<p>\r\nNote that because we are using trailer linked-lists for chaining, no bin will\r\n  be empty: it will at least store a trailer.\r\nThis property is important when we create hash tables and when we double their\r\n  number of bins: see <b>ensure_load_factor</b> below.\r\n<p>\r\nWe can implement maps efficiently by using a hash tables using a simple hashing\r\n  function on only the key (<b>first</b>) part of the <b>pair</b>.\r\nMost operations updating hash table O(1).\r\nWhen writing the copy constructor and operator=, use the fact that \"the hash\r\n  table being copied already has all the pairs in the right bins\" to simplify\r\n  these operations (and avoiding rehashing the keys).\r\n<p>\r\nThe file <b>hash_map.hpp</b> declares the appropriate constructors, methods, and\r\n  instance variables.\r\nNote the many helper methods that operate on hash tables: most are easily\r\n  implemented iteratively.\r\nMany of the standard <b>map</b> methods call one or more of these helper\r\n  methods to retrieve information from a hash table or change it\r\n  (e.g., add/remove key-&gt;value  assocations).\r\nThese include:\r\n<ul>\r\n  <li><b>int hash_compress (const KEY& key) const;</b>\r\n      This method uses the hash function supplied by the constructor and the\r\n        number of bins in the current hash table, to compute the bin index of\r\n        any given key.\r\n      Remember to compute the absoluate value of the hash function (which can\r\n        return a negative result) and use the remainder operator (<b>%</b>) to\r\n        ensure a bin index in the range <b>[0,bins)</b>.\r\n  <p>\r\n  <li><b>void ensure_load_factor(int new_used);</b><br>\r\n      This method ensures that a hash table with <b>new_used</b> values\r\n        does not exceed the load factor (based on this value and the number of\r\n        bins currently in the hash table).\r\n      If this ratio (compute it with <b>double</b>s) would exceed the load\r\n        factor threshold, it creates a new hash table with twice the number of\r\n        bins and puts all the values in the original hash table into the new\r\n        one (which requires rehashing each, since compression using a new\r\n        number of bins can produce a different bin index from\r\n        <b>hash_compress</b>).\r\n      <p>\r\n      To be efficient, we can reuse all the <b>LN</b> objects for the values in\r\n        the original hash table, rather than deallocating and creating a new\r\n        <b>LN</b> for each value.\r\n      In such a case we could still create new trailers for all the bins in the\r\n        new hash table, and ultimately deallocate all trailers in the original\r\n        hash table.\r\n      <p>\r\n      We typically call this method before adding a key-&gt;value to the map\r\n        (and do not call it when changing the value associate with a key);\r\n        remember that calling this method can change how <b>hash_compress</b>\r\n        does its job in the future, because the number of bins might change.\r\n  <p>\r\n  <li><b>LN* find_key (int bin, const KEY& key) const;</b>\r\n      This method attempts to find the <b>LN</b> storing <b>key</b> in the\r\n         <b>bin</b> index of a hash table: if successful it returns a pointer\r\n         to that <b>LN</b> (possibly to examine or update its associated value);\r\n         if unsuccessful it returns <b>nullptr</b>.\r\n      The caller of this function will determine what to do with the pointer\r\n         returned.\r\n  <p>\r\n  <li><b>bool find_value (const T& value) const;</b>\r\n      This method traverses all the <b>LN</b>s in all the bins in a hash table\r\n        attempting to to find any <b>LN</b> storing <b>value</b>: if successful\r\n        it returns <b>true</b>; if unsuccessful it returns <b>false</b>.\r\n  <p>\r\n  <li><b>LN* copy_list(LN* l) const;</b>\r\n      This method copies a linked list, including the trailer node.\r\n      It is used in <b>copy_hash_table</b>.\r\n  <p>\r\n  <li><b>LN** copy_hash_table(LN** ht, int bins) const;</b>\r\n      This method copies an entire hash table, by allocating space for the\r\n        bins and then copying the list nodes in each bin.\r\n      It does not need to call <b>hash_compress</b>.\r\n  <p>\r\n  <li><b>void  delete_hash_table(LN**& ht, int bins);</b>\r\n      This method deletes every <b>LN</b> used in the hash table, and then\r\n        deletes the hash table itself.\r\n</ul>\r\n<p>\r\nI have written boilerplate for all these methods.\r\nI suggest examining code in the <b>array_map.hpp</b> or <b>bst_map</b> files to\r\n  help you understand some of the bookkeeping requirements of these methods.\r\nPay close attention to ensure <b>all instance variables</b> receive values in\r\n  the constructors and are used/set correctly in queries and commands.\r\n<p>\r\n<b>Iterators:</b>\r\nWe return to simpl-ish/efficient iterators for hash tables (made even more\r\n  simple by using trailer lists).\r\nNote that map iterators produce <b>Entry</b> which is defined by \r\n  <b>typedef ics::pair&lt;KEY,T&gt; Entry;</b>\r\nHere are some useful to know/use properties of cursors in hash tables.\r\n<ul>\r\n<li>\r\nWe represent a cursor by <b>ics::pair<int,LN*></b> of cursors: where\r\n  <b>first</b> is the bin index of the cursor and <b>second</b> points to an\r\n  <b>LN</b> in the trailer linked-list in that bin index.\r\nWe represent the \"<b>end</b>\" cursor for a hash table with <b>first</b> as\r\n  <b>-1</b> and <b>second</b> as <b>nullptr</b>: special values for each part\r\n  of the cursor.\r\n<p>\r\n<li>\r\nThe \"<b>begin</b>\" cursor in an <b>empty</b> hash table is the same as the\r\n  \"<b>end</b>\" cursor.\r\nThe \"<b>begin</b>\" cursor in a <b>non-empty</b> hash table stores in\r\n  <b>first</b> the index of the first bin whose linked-list stores more than\r\n  just a trailer node, and stores in <b>second</b> a pointer to the first\r\n  <b>LN</b> in that linked-list.\r\n<p>\r\n<li>\r\nWe advance a non-\"<b>end</b>\" cursor by moving its <b>second</b> to the next\r\n  <b>LN</b> in the linked-list, but if that is the trailer node, by moving to\r\n  higher bin indexes until we either (a) find a bin whose linked-list stores\r\n  more than just a trailer node or (b) run out of bins to check.\r\nFor (a) we used that bin index and a pointer to the first <b>LN</b> in that\r\n  bin's linked-list; for (b) we use an \"<b>end</b>\" cursor: <b>-1</b> and\r\n  <b>nullptr</b>.\r\nI boiler-plated an <b>advance_cursors</b> helper method to peform this\r\n  operation (which can even be used to compute the \"<b>begin</b>\" cursor\r\n  for a hash table).\r\n<p>\r\n<li>\r\nFinally, the iterator's <b>erase</b> method leverages the simple code to remove\r\n  an <b>LN</b> from trailer linked-list.\r\nIt also must update various bookkeeping instance variables and of course\r\n  actually delete/recycle the <b>LN</b> that is removed.\r\n</ul>\r\nThis approach makes the iterators fairly easy to write and efficient to use:\r\n  requiring little extra space.\r\n<p>\r\nFeel free to question/discuss iterators for <b>HashMap</b> on the\r\n  message boards, so long as no code is posted or described in too much detail.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n\r\n<!-- set -->\r\n\r\n<a name=\"set\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Sets</b></td>\r\n<td width =\"80%\">\r\nNot much to say here.\r\nTake all that you learned about the hash table implementation of map and apply\r\n  it to the implementation of set.\r\nI reused (copy/pasted unchanged) all the helper methods discussed above.\r\nFor the actual set constructors and methods, I wrote similar code.\r\nThe main difference between maps and sets is that \"values\" in maps are\r\n  key-&gt;value pairs and \"values\" in sets are just single values.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<!-- testing -->\r\n\r\n<a name=\"testing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Testing</b></td>\r\n<td width =\"80%\">\r\nThere are various ways to test each of the classes you are writing in this\r\n  programming assignment.\r\nFirst, though, you should write all the methods, paying careful attention to\r\n  the array implementations and previously written linked list implementations.\r\nFor some, you might just boiler-plate simple code that is not correct, but\r\n  allows the methods to compile, allowing other methods in the classes to be\r\n  tested.\r\n<p>\r\nThe easiest way to start testing//debugging is by using the driver program.\r\nIt allows you to perform any method call supported by the templated classes,\r\n  and see the state of the class (or view the debugger).\r\nOf course, \r\n<b>you must get the <b>insertion</b> (&lt;&lt;) operator and str() method to\r\n  work before using it to debug the other methods.</b>\r\n<p>\r\nAfter you debug your code with the driver, try running the appropriate\r\n  GoogleTest code.\r\nAgain, this form of testing is useful only as you approach a finished solution.\r\nWe will use the GoogleTest, and visual inspection, to grade this\r\n  assignment.\r\n<b>Important Note</b>: You can put <b>std::cout</b> statements in the GoogleTest\r\n  code (but don't accidentally remove any of the assertions, otherwise\r\n  you won't be fully checking your code the way we will) while you are\r\n  debugging your classes.\r\nAll debugging <b>std::cout</b> should end in <b>std::endl</b> to flush the\r\n  output stream: ensure the output it displayed before executing the next\r\n  statement\r\n<p>\r\nWhen you run the GoogleTest, choose small values for the first and\r\n  third prompts (just press return to the second prompt) or comment-out these\r\n  prompts and assign small values to these variables instead.\r\nBesides an indication of which tests pass and fail, the console window\r\n  will show a speed for the speed test (which will vary depending on how\r\n  fast a machine you run your code on): don't worry about it.\r\nWhen your code is passing all the tests, put in values like 10,000 for these\r\n  prompts.\r\n<p>\r\nFinally, Eclipse shows errors in files that use of <b>std::hash</b>, but we can\r\n  still compile, link and run these files.\r\nSo the drivers for map and set each show one error and the GoogleTest for map \r\n  and set show two errors and syntax errors for each TEST; again, we can still\r\n  run all these programs.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 11115.0}