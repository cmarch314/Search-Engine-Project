{"text": "Program 2 Implementing Queue Priority Queue Set and their iterators with Linked Lists ICS 46 Data Strcuture Implementation and Analysis Introduction This programming assignment is designed to ensure that you know how to implement three templated classes Queue Priority Queue and Set with linked lists Your implementations will also include fully functional iterators for these classes You will be writing lots of small code fragments that traverse and mutate linked lists You must write all your implementations using linked lists a linear linked list for LinkedQueue a header linked list for LinkedPriorityQueue and a trailer linked list for LinkedSet You can test these implementations by using the standard drivers and GoogleTests provided with the download that we will use when grading your code for correctness recall that you can augment the GoogleTest with whatever code you want to aid your debugging a GoogleTest is just a C program You can also test the code you wrote for Programming Assignment 1 using array implementations of these classes by substituting these linked list implementations typically by changing a few include and typedef statements Write and use the insertion operator and str method in each class for debugging In a header list we skip showing the value in the front header node as that node is not really in the collection represented by the list likewise in a trailer list we skip showing the value in the rear trailer node for the same reason Note that there is no tested requirement for what these methods return but the versions above will make debugging easier You should download the program2 project folder and use it to create an Eclipse project ultimately needing to connect it to both the courselib and googletest libraries You will write the required methods in the linked queue hpp linked priority queue hpp and linked set hpp files in this project and submit each separately in Checkmate The project folder also contains three pairs of hpp and cpp files a driver GoogleTest pair for each class that you will write and the driver cpp file which has a main function that can be made to run any of the three drivers Instead you can also use a existing working project folder that already is connected to both the courselib and googletest libraries remove but save all the files in its src folder and then put all the hpp and cpp files from the downloaded project s src folder into the existing working project s src folder finally right click the project and select Refresh F5 Important Only one of the cpp files with a main method can be active compiling at any time In the download only the driver cpp file is active the GoogleTests are inactive To make a progam inactive select it in the editor tab use the Ctrl a command to select all its lines and then click Source at the top left of the menu and choose Toggle Comment ever line will now appear in a comment so the main function is commented out by using these same instructions you can toggle back those lines to not have comments I recommend that you work on this assignment in pairs Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early Only one student should submit all parts of the the assignment but both student s names along with their UniqueID should appear in the comments at the top of each submitted cpp file It should look something like Romeo Montague UniqueID from grades spreadsheet Juliet Capulet UniqueID from grades spreadsheet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files This assignment has 3 parts pairs should work on each part together not split them up and do them separately Part 1 is worth 42 points part 2 is worth 9 points part 3 is worth 9 pts This skewing of points towards the simpler parts means students finishing the first part correctly will have a 7 average those finishing the first 2 parts correctly will have an 85 average but to get an A on this assignment requires solving all parts correctly Remember I m going to be running MOSS on the parts of this assignment to check for program similarity IMPORTANT The courselib contains array implementations for all these data types although this assignment requires you to use linked lists there are still many strong similarities at a high level in all these implementations So I encourage you to examine these implementations closely and understand them possibly experiment with them using their drivers or GoogleTests while you are writing your linked list implementations this advice is especially true as you begin to study understand and implement iterators Please feel free about asking questions about these methods both their syntax and semantics on the appropriate Messageboard Queues Queues are implemented by simple FIFO data structures adhering to the Fast In First Out order property We can implement queues efficiently by using two instance variables which refer to a linked list whose first value is the node at the front of the queue and whose last value is the node at the rear of the queue Nodes are removed from the front and added to the rear so these are the two hot spots for a queue The enqueue and dequeue operations should each be O 1 Although we can easily compute the number of values in linked list by traversing it instead we will declare and update an extra instance variable named used to cache the size incrementing and decrementing it as values are successfully added removed from the queue so we will not have to traverse the list to compute its size The file linked queue hpp declares the appropriate constructors methods and instance variables Notice how the LN class is first declared private before Iterator and then defined private inside LinkedQueue using the parameter T of that class I suggest copying pasting the methods from the array queue hpp file and then translating these methods from using arrays to using linked lists Pay close attention to ensure all instance variables receive values in the constructors and are used set correctly in queries and commands Use delete to recycle LN nodes To simplify the operator you can clear the queue and then enqueue the required values a faster way would be to clear the queue and copy the linked list an even faster way would reuse whate LN nodes are already there removing unneeded one or supplementing with more nodes Read the material in the Iterators section of this assignment which discusses the iterators needed for all the classes that you will write These iterators perform the the same operations in every class but they are implemented differently based on the kind of linked list implementation Finally read the testing section below as well Priority Queues Priority Queues can be implemented by a variety of data structures where the highest priority value is always removed first How does a specific priority queue determine which value has the highest priority When constructed we supply the priority queue with a gt greater than function that computes whether its first argument has a greater priority than its second argument So we cannot ask What is the priority of a value But we can ask Does the priority of a first value have a higher priority than a second value by calling the gt function For example we cannot ask for the priority of a std string value but we can determine whether one std string value has a higher priority than another std string value We can implement priority queues simple although not very efficiently with one instance variable which refers to a linked list whose first value is the one with the highest priority value and whose remaining values occur in order of decreasing priority when adding a value to a priority queue we insert it at the correct spot in the list keeping the list ordered from highest to lowest priority when removing the highest priority value from a priority queue we always remove it from the front Instead of a standard linked list you must implement the priority queue using a Header node at the front of the linked list Doing so should simplify writing the most complicated method enqueuing an element onto the priority queue try to write this method very simply Hint my enqueue method used four lines to put the element into an LN and insert it into the correct position in the header linked list followed by 3 more lines of booking code Although we can easily compute the number of values in linked list by traversing it instead we will declare and update an extra instance variable named used to cache the size incrementing and decrementing it as values are successfully added removed from the queue so we will not have to traverse the list to compute its size The enqueue operation is O N so enqueuing N values onto a priority queue is O N 2 When writing the copy constructor and operator use the fact that the linked lists being copied are already in order to make these operations O N To simplify operator you can clear the queue and then carefully add the required values in linear time The file linked priority queue hpp declares the appropriate constructors methods and instance variables Notice how the LN class is first declared private before Iterator and then defined private inside LinkedPriorityQueue using the parameter T of that class I suggest copying pasting the methods from the array priority queue hpp file and then translating these methods from using arrays to using linked lists in fact you might want to copy the linked queue hpp file you wrote in part 1 it has the same methods and it already does some linked list processing but doesn t use a header linked list Pay close attention to ensure all instance variables receive values in the constructors are are used set correctly in queries and commands Use delete to recycle LN nodes Read the material in the Iterators section of this assignment which discusses the iterators needed for all the classes that you will write These iterators perform the the same operations in every class but they are implemented differently based on the kind of linked list implementation Finally read the testing section below as well Sets Sets can be implemented by a variety of data structures We can implement sets simply although not very efficiently with one instance variable which refers to a linked list of values in the set Remember that a set s order is not important e g when we insert an element into a set we are free to put it anywhere in the linked list put it somewhere easy by using short efficient code Instead of a standard linked list you must implement the set using a Trailer node last in the linked list In fact it is useful to declare a trailer instance variable that always refers to this node be careful erasing the value in the node before the trailer node requires changing the trailer node also every linked list has its own different trailer node Having a trailer node should simplify erasing a value from the set in the class method but even more so in the iterator methods using the standard code trick covered in the discussion of trailer lists Although we can easily compute the number of values in linked list by traversing it instead we will declare and update an extra instance variable named used to cache the size incrementing and decrementing it as values are successfully added removed from the set so we will not have to traverse the list to compute this value The insert operation is O N because it must check if the element is already in the set so inserting N values into a set is O N 2 When writing the copy constructor and operator use the fact that the linked lists being copied are already sets with no duplicates to make these operations O N To simplify operator you can clear the set and then carefully add the required values in linear time The file linked set hpp declares the appropriate constructors methods and instance variables Notice how the LN class is first declared private before Iterator and then defined private inside LinkedSet using the parameter T of that class I suggest copying pasting the methods from the array set hpp file and then translating these methods from using arrays to using linked lists Pay close attention to ensure all instance variables receive values in the constructors are are used set correctly in queries and commands Use delete to recycle LN nodes Read the material in the Iterators section of this assignment which discusses the iterators needed for all the classes that you will write These iterators perform the the same operations in every class but they are implemented differently based on the kind of linked list implementation Finally read the testing section below as well Iterators Fundamentally iterators operate similarly for each data type they allow programmers to traverse the data type examining and even erasing the values inside the data type one after the other Each uses a cursor to remember its place inside the data type as it traverses it the array implementations used ints for cursors the linked list implementations use pointers for cursors Once iterators are created indexing the first value or if there is none indexing one beyond the last value we can use them to examine erase the current value increment them to access the next value and check whether a cursor has reached one beyond the last value We often do this with either explict for loops or with implicit for each loops we do the latter more frequently Note that if we erase a value the cursor will temporarily refer to its next value we must call one form of the operator to increment the cursor before we can examine erase another value but doing so does right after calling erase will not change the cursor because erase has already made the cursor refer to its next value In the linked queue hpp and linked priority queue hpp files I have implemented all Iterator methods fully except for the two forms of the operator and the erase method and for these I have even written some of the boiler plate code Each defines a prev and current instance variable of type LN to traverse their linked list along with a ref queue in the queue or a ref pq in the priority queue pointer referring to the object they are iterating over to access its current mod count and other instance variables as needed Each defines an expected mod count and can erase instance variable Note that can erase determines whether erase can function correctly and helps control the updating of prev and current after calling on an iterator Note that prev is useful when the current value must be erased All methods start with similar tests that determine whether to throw an exception Most compare mod count and expected mod count The and relational operators also ensure what is being compared are iterators from the same object The and operators ensure that current is legal to examine is not one beyond the last value Observe their similarity in all implementations among all the Iterator classes and their methods I recommend writing and testing the code for both operators before writing code for an iterator s erase method This will allow you to test loops using iterators so long as the body of the loop does not call erase on the iterator After your code for these operators is working correctly write code for calling erase on an iterator and update the code in the operators where necessary to work correctly with erase Note that iterators for these two classes produce values in the order that they would be dequeued FIFO for a queue and priority ordering for a priority queue Given how these linked lists represent these classes queue front to rear priority queue highest to lowest priority the order of iterating through these classses is the same as the order of traversing their linked list implementation from front to rear There are four GoogleTest functions that focus on iterators iterator plusplus focuses on the two forms of operators and does not call the iterator s erase iterator simple does not call the iterator s erase iterator erase does call the iterator s erase and iterator exception concurrent modification error ensures that mutating the data structure forces any active iterator to stop working unless the mutation was done by that iterator s erase For the linked set class you must write all the code for the iterator The use of a trailer list will often make such code easier to write it requires only a current instance variable not one for prev In general you should hand simulate debug your iterator code for the following cases erasing the first value maybe several in a row at the front erasing non consecutive values inside with multiple operators between calls erasing consecutive values with single operators between calls erasing the last value maybe several in a row at the end You can study how these semantics are coded in the array implementations of these data types which are similiar but simpler than how they are coded with linked lists because we can more easily manipulate int array cursors i 1 and i 1 For linked list implementations implementing erase on iterators is typically more complicated but more EFFICIENT values removed in the middle of arrays require shifting causing the complexity class of erase to be O N in arrays while being only O 1 in linked lists Testing There are various ways to test each of the classes you are writing in this programming assignment First though you should write all the methods paying careful attention to the array implementations and previously written linked list implementations For some you might just boiler plate simple code that is not correct but allows the methods to compile allowing other methods in the classes to be tested The easiest way to start testing debugging is by using the driver program It allows you to perform any method call supported by the templated classes and see the state of the class or view the debugger Of course you must get the insertion operator and str method to work before using it to debug the other methods After you test and debug your code with the driver try running the appropriate GoogleTest code Again this form of testing is useful only as you approach a finished solution We will use the GoogleTest and visual inspection to grade this assignment Important Note You can put std cout statements in the GoogleTest code but don t accidentally remove any of the assertions otherwise you won t be fully checking your code the way we will while you are debugging your classes All debugging std cout should end in std endl to flush the output stream taht ensures the output it displayed before executing the next statement which may throw an exception When you run the GoogleTest initially choose small values for the first and third prompts just press return to the second prompt or replace these prompts with small values in the code so the test will run fully automatically Besides an indication of which tests pass and fail the console window will show a speed for the speed test which will vary depending on how fast a machine you run your code on don t worry about it When your code is passing all the tests put in values like 1 for these prompts ", "_id": "http://www.ics.uci.edu/~pattis/ICS-46/assignments/program2/program.html", "title": "program 2", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 2</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 2</h1>\r\n<h1>Implementing Queue/Priority Queue/Set<br>\r\n    (and their iterators) with Linked Lists \r\n</h1>\r\n<p>\r\n<h2>ICS-46: Data Strcuture Implementation and Analysis\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to\r\n  implement three templated classes (<b>Queue</b>, <b>Priority Queue</b>,\r\n  and <b>Set</b>) with linked lists.\r\nYour implementations will also include fully-functional iterators for\r\n  these classes.\r\nYou will be writing lots of small code fragments that traverse and mutate\r\n  linked lists.\r\n<p>\r\nYou must write all your implementations using linked lists: a linear-linked\r\n  list for <b>LinkedQueue</b>, a header linked list for\r\n  <b>LinkedPriorityQueue</b>, and a trailer linked list for <b>LinkedSet</b>.\r\nYou can test these implementations by using the standard drivers and\r\n  GoogleTests (provided with the download) that we will use when grading your\r\n  code for correctness; recall that you can augment the GoogleTest with whatever\r\n  code you want, to aid your debugging: a GoogleTest is just a C++ program.\r\nYou can also test the code you wrote for Programming Assignment #1 (using\r\n  array implementations of these classes) by substituting these linked list\r\n  implementations -typically by changing a few <b>#include</b> and\r\n  <b>typedef</b> statements.\r\n<p>\r\nWrite and use the <b>insertion</b> (<b>&lt;&lt;</b>) operator and <b>str()</b>\r\n  method in each class for debugging.\r\nIn a header list, we skip showing the value in the front/header node, as that\r\n  node is not really <b>in</b> the collection represented by the list;\r\n  likewise, in a trailer list, we skip showing the value in the rear/trailer\r\n  node, for the same reason.\r\nNote that there is no tested requirement for what these methods return, but\r\n  the versions above will make debugging easier.\r\n<p>\r\nYou should download the \r\n  <a href=\"program2.zip\">program2</a> project folder and use it to create an\r\n  Eclipse project (ultimately needing to connect it to both the\r\n  <b>courselib</b> and <b>googletest</b> libraries).\r\n  You will write the required methods in the <b>linked_queue.hpp</b>, \r\n  <b>linked_priority_queue.hpp</b>, and <b>linked_set.hpp</b>, files in this\r\n  project, and submit each separately in Checkmate.\r\nThe project folder also contains three pairs of <b>.hpp</b> and <b>.cpp</b>\r\n  files: a driver/GoogleTest pair for each class that you will write, and the\r\n  <b>driver.cpp</b> file which has a <b>main</b> function that can be made to\r\n  run any of the three drivers.\r\n<p>\r\nInstead, you can also use a existing/working project folder that already is\r\n connected to both the <b>courselib</b> and <b>googletest</b> libraries: remove\r\n  (but save) all the files in its <b>src</b> folder and then put all the\r\n  <b>.hpp</b> and <b>.cpp</b> files from the downloaded project's <b>src</b>\r\n  folder into the existing/working project's <b>src</b> folder; finally,\r\n  right-click the project and select <b>Refresh</b> (F5).\r\n<p>\r\n<b>Important: Only one of the <b>.cpp</b> files with a <b>main</b> method can\r\n  be active/compiling at any time.</b>\r\nIn the download, only the <b>driver.cpp</b> file is active; the GoogleTests are\r\n  inactive.\r\nTo make a progam inactive, select it (in the editor tab), use the <b>Ctrl/a</b>\r\n  command to select all its lines, and then click <b>Source</b> at the top\r\n  left of the menu and choose <b>Toggle Comment</b>: ever line will now appear\r\n  in a comment (so the <b>main</b> function is commented-out); by using these\r\n  same instructions, you can toggle back those lines to not have comments.\r\n<p>\r\nI recommend that you work on this assignment in pairs.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  student's names (along with their UniqueID) should appear in the comments at\r\n  the top of <b>each submitted .cpp</b> file.\r\nIt should look something like\r\n<pre><b>\r\n//Romeo Montague(UniqueID from grades spreadsheet)\r\n//Juliet Capulet(UniqueID from grades spreadsheet)\r\n//We certify that we worked cooperatively on this programming\r\n//  assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  before starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can accurately\r\n  assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\n<p>\r\n<p>\r\nThis assignment has 3 parts: pairs should work on each part together, not split\r\n  them up and do them separately.\r\nPart 1 is worth 42 points; part 2 is worth 9 points; part 3 is worth 9 pts.\r\n\r\nThis skewing of points towards the simpler parts means students finishing the\r\n  first part correctly will have a 70% average; those finishing the first 2 \r\n  parts correctly will have an 85% average; but to get an A on this \r\n  assignment requires solving all parts correctly.\r\nRemember I'm going to be running MOSS on the parts of this assignment,\r\n  to check for program similarity.\r\n<p>\r\nIMPORTANT: The courselib contains array implementations for all these data\r\n  types; although this assignment requires you to use linked lists, there are\r\n  still <b>many strong similarities</b> at a high level in all these\r\n  implementations.\r\nSo, I encourage you to examine these implementations closely, and understand\r\n  them; possibly, experiment with them (using their drivers or GoogleTests),\r\n  while you are writing your linked list implementations: this advice is\r\n  especially true as you begin to study, understand, and implement iterators.\r\nPlease feel free about asking questions about these methods -both their syntax\r\n  and semantics- on the appropriate Messageboard.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- queue -->\r\n\r\n<a name=\"queue\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Queues</b></td>\r\n<td width =\"80%\">\r\nQueues are implemented by simple FIFO data structures (adhering to the\r\n  Fast-In/First-Out order property).\r\nWe can implement queues efficiently by using two instance variables, which\r\n  refer to a linked list (whose first value is the node at the <b>front</b>\r\n  of the queue and whose last value is the node at the <b>rear</b> of the\r\n  queue).\r\nNodes are removed from the front and added to the rear, so these are the\r\n  two \"hot spots\" for a queue.\r\nThe <b>enqueue</b> and <b>dequeue</b> operations should each be O(1).\r\n<p>\r\nAlthough we can easily compute the number of values in linked list by\r\n  traversing it, instead we will declare and update an extra instance variable \r\n  named <b>used</b> to cache the size (incrementing and decrementing it, as\r\n  values are successfully added/removed from the queue), so we will not have\r\n  to traverse the list to compute its size.\r\n<p>\r\nThe file <b>linked_queue.hpp</b> declares the appropriate constructors, methods,\r\n  and instance variables.\r\nNotice how the <b>LN</b> class is first declared <b>private</b> (before\r\n  <b>Iterator</b>) and then defined <b>private</b> inside <b>LinkedQueue</b>\r\n  using the parameter <b>&lt;T&gt;</b> of that class.\r\nI suggest copying/pasting the methods from the <b>array_queue.hpp</b>\r\n  file, and then translating these methods from using arrays to using linked\r\n  lists.\r\nPay close attention to ensure <b>all instance variables</b> receive values in\r\n  the constructors and are used/set correctly in queries and commands.\r\n<p>\r\nUse delete to recycle <b>LN</b> nodes.\r\nTo simplify the operator=, you can <b>clear</b> the queue and then\r\n  <b>enqueue</b> the required values: a faster way would be to clear the queue\r\n  and copy the linked list; an even faster way would reuse whate <b>LN</b>\r\n  nodes are already there, removing unneeded one or supplementing with more\r\n  nodes.\r\n<p>\r\nRead the material in the <b>Iterators</b> section of this assignment, which\r\n  discusses the iterators needed for all the classes that you will write.\r\nThese iterators perform the the same operations in every class, but they are\r\n  implemented differently based on the kind of linked list implementation.\r\nFinally, read the <b>testing</b> section below as well.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- priorityqueue -->\r\n\r\n<a name=\"priorityqueue\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Priority Queues</b></td>\r\n<td width =\"80%\">\r\nPriority Queues can be implemented by a variety of data structures (where the\r\n  highest priority value is always removed first).\r\nHow does a specific priority queue determine which value has the highest\r\n  priority?\r\nWhen constructed, we supply the priority queue with a <b>gt</b> (greater-than)\r\n  function that computes whether its first argument has a greater priority\r\n  than its second argument.\r\nSo, we cannot ask, \"What is the priority of a value.\" But, we can ask \"Does the\r\n  priority of a first value have a higher priority than a second value\", by\r\n  calling the <b>gt</b> function.\r\nFor example, we cannot ask for the priority of a <b>std::string</b> value, but\r\n  we can determine whether one <b>std::string</b> value has a higher\r\n  priority than another <b>std::string</b> value.\r\n<p>\r\nWe can implement priority queues simple (although not very efficiently) with\r\n  one instance variable, which refers to a linked list whose first value is the\r\n  one with the highest priority value, and whose remaining values occur in\r\n  order of decreasing priority; when adding a value to a priority queue, we\r\n  insert it at the correct spot in the list, keeping the list ordered from\r\n  highest to lowest priority; when removing the highest priority value from a\r\n  priority queue, we always remove it from the front.\r\n<p>\r\nInstead of a standard linked list, you must <b>implement the priority queue\r\n  using a \"Header node\" at the front of the linked list.</b>\r\nDoing so should simplify writing the most complicated method: enqueuing an\r\n  element onto the priority queue: try to write this method very simply.\r\nHint: my <b>enqueue</b> method used four lines to put the <b>element</b> into\r\n  an <b>LN</b> and insert it into the correct position in the header linked\r\n  list (followed by 3 more lines of booking code).\r\n<p>\r\nAlthough we can easily compute the number of values in linked list by\r\n  traversing it, instead we will declare and update an extra instance variable \r\n  named <b>used</b> to cache the size (incrementing and decrementing it, as\r\n  values are successfully added/removed from the queue), so we will not have\r\n  to traverse the list to compute its size.\r\n<p>\r\nThe <b>enqueue</b> operation is O(N), so enqueuing N values onto a priority\r\n  queue is O(N^2).\r\nWhen writing the copy constructor and operator=, use the fact that \"the linked\r\n  lists being copied are already in order\" to make these operations O(N).\r\nTo simplify operator=, you can <b>clear</b> the queue and then carefully add\r\n  the required values (in linear time).\r\n<p>\r\nThe file <b>linked_priority_queue.hpp</b> declares the appropriate constructors,\r\n  methods, and instance variables.\r\nNotice how the <b>LN</b> class is first declared <b>private</b> (before\r\n  <b>Iterator</b>) and then defined <b>private</b> inside\r\n  <b>LinkedPriorityQueue</b> using the parameter <b>&lt;T&gt;</b> of that class.\r\nI suggest copying/pasting the methods from the <b>array_priority_queue.hpp</b>\r\n  file, and then translating these methods from using arrays to using linked\r\n  lists; in fact, you might want to copy the <b>linked_queue.hpp</b> file you\r\n  wrote in part 1: it has the same methods and it already does some linked list\r\n  processing: but doesn't use a header linked list.\r\nPay close attention to ensure <b>all instance variables</b> receive values in\r\n  the constructors are are used/set correctly in queries and commands.\r\nUse delete to recycle <b>LN</b> nodes.\r\n<p>\r\nRead the material in the <b>Iterators</b> section of this assignment, which\r\n  discusses the iterators needed for all the classes that you will write.\r\nThese iterators perform the the same operations in every class, but they are\r\n  implemented differently based on the kind of linked list implementation.\r\nFinally, read the <b>testing</b> section below as well.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- set -->\r\n\r\n<a name=\"set\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Sets</b></td>\r\n<td width =\"80%\">\r\nSets can be implemented by a variety of data structures.\r\nWe can implement sets simply (although not very efficiently) with one instance\r\n  variable, which refers to a linked list of values in the set.\r\nRemember that a set's order is not important: e.g., when we <b>insert</b> an\r\n  <b>element</b> into a <b>set</b>, we are free to put it anywhere in the\r\n  linked list; put it somewhere easy by using short/efficient code.\r\n<p>\r\nInstead of a standard linked-list, you must <b>implement the set using a\r\n  \"Trailer node\" last in the linked list.</b>\r\nIn fact, it is useful to declare a <b>trailer</b> instance variable that always\r\n  refers to this node (be careful: erasing the value in the node before the\r\n  trailer node requires changing the trailer node; also, every linked list has\r\n  its own/different trailer node).\r\nHaving a trailer node should simplify erasing a value from the set (in the\r\n  class method, but even more so in the iterator methods, using the standard\r\n  code/trick covered in the discussion of trailer lists.\r\n<p>\r\nAlthough we can easily compute the number of values in linked list by\r\n  traversing it, instead we will declare and update an extra instance variable \r\n  named <b>used</b> to cache the size (incrementing and decrementing it, as\r\n  values are successfully added/removed from the set), so we will not have\r\n  to traverse the list to compute this value.\r\n<p>\r\nThe <b>insert</b> operation is O(N), because it must check if the element is\r\n  already in the set, so inserting N values into a set is O(N^2).\r\nWhen writing the copy constructor and operator=, use the fact that \"the linked\r\n  lists being copied are already sets with no duplicates\" to make these \r\n operations O(N).\r\nTo simplify operator=, you can <b>clear</b> the set and then carefully add\r\n  the required values (in linear time).\r\n<p>\r\nThe file <b>linked_set.hpp</b> declares the appropriate constructors,\r\n  methods, and instance variables.\r\nNotice how the <b>LN</b> class is first declared <b>private</b> (before\r\n  <b>Iterator</b>) and then defined <b>private</b> inside <b>LinkedSet</b>\r\n  using the parameter <b>&lt;T&gt;</b> of that class.\r\nI suggest copying/pasting the methods from the <b>array_set.hpp</b> file,\r\n  and then translating these methods from using arrays to using linked lists.\r\nPay close attention to ensure <b>all instance variables</b> receive values in\r\n  the constructors are are used/set correctly in queries and commands.\r\nUse delete to recycle <b>LN</b> nodes.\r\n<p>\r\nRead the material in the <b>Iterators</b> section of this assignment, which\r\n  discusses the iterators needed for all the classes that you will write.\r\nThese iterators perform the the same operations in every class, but they are\r\n  implemented differently based on the kind of linked list implementation.\r\nFinally, read the <b>testing</b> section below as well.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- iterators -->\r\n\r\n<a name=\"iterators\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Iterators</b></td>\r\n<td width =\"80%\">\r\nFundamentally, iterators operate similarly for each data type: they allow\r\n  programmers to traverse the data type, examining (and even erasing) the\r\n  values inside the data type, one after the other.\r\nEach uses a cursor to remember its place inside the data type, as it traverses\r\n  it: the array implementations used <b>int</b>s for cursors; the linked-list\r\n  implementations use pointers for cursors.\r\n<p>\r\nOnce iterators are created (indexing the first value, or if there is none,\r\n  indexing \"one beyond the last value\") we can use them to examine/erase the\r\n  current value, increment them (to access the next value),  and check whether\r\n  a cursor has reached \"one beyond the last value\".\r\nWe often do this with either explict <b>for</b> loops or with implicit\r\n  <b>for-each</b> loops (we do the latter more frequently).\r\n<p>\r\nNote that if we <b>erase</b> a value, the cursor will temporarily refer to\r\n  its next value: we <b>must call one form of the ++ operator to increment the\r\n  cursor</b> before we can examine/erase another value, but doing so does right\r\n  after calling <b>erase</b> will not change the cursor, because <b>erase</b>\r\n  has already made the cursor refer to its next value.\r\n<p>\r\nIn the <b>linked_queue.hpp</b> and <b>linked_priority_queue.hpp</b> files, I\r\n  have implemented all <b>Iterator</b> methods fully except for the two forms\r\n  of the <b>++</b> operator and the <b>erase</b> method, and for these I have\r\n  even written some of the boiler-plate code.\r\n<ol>\r\n<li>Each defines a <b>prev</b> and <b>current</b> instance variable of type\r\n  <b>LN*</b> (to traverse their linked list), along with a <b>ref_queue</b>\r\n  (in the queue) or a <b>ref_pq</b> (in the priority queue) pointer referring\r\n  to the object they are iterating over (to access its current <b>mod_count</b>\r\n  and other instance variables as needed).\r\n<p>\r\n<li>Each defines an <b>expected_mod_count</b> and <b>can_erase</b> instance\r\n  variable. Note that <b>can_erase</b> determines whether <b>erase</b> can\r\n  function correctly, and helps control the updating of <b>prev</b> and\r\n  <b>current</b> after calling <b>++</b> on an iterator.\r\n  Note that <b>prev</b> is useful when the <b>current</b> value must be erased.\r\n<p>\r\n<li>All methods start with similar tests that determine whether to throw an\r\n      exception. \r\n    Most compare <b>mod_count</b> and <b>expected_mod_count</b>.\r\n    The <b>==</b> and <b>!=</b> relational operators also ensure what is being\r\n      compared are iterators from the same object.\r\n    The <b>*</b> and <b>-&gt;</b> operators ensure that <b>current</b> is\r\n      legal to examine: is not one beyond the last value.\r\n</ol>  \r\nObserve their similarity in all implementations among all the <b>Iterator</b>\r\n  classes and their methods.\r\nI recommend writing and testing the code for both <b>++</b> operators before\r\n  writing code for an iterator's <b>erase</b> method.\r\nThis will allow you to test loops using iterators, so long as the body of the\r\n  loop does not call <b>erase</b> on the iterator.\r\nAfter your code for these operators is working correctly, write code for\r\n  calling <b>erase</b> on an iterator, and update the code in the <b>++</b>\r\n  operators where necessary, to work correctly with <b>erase</b>.\r\n<p>\r\nNote that iterators for these two classes produce values in the order that they\r\n  would be dequeued: FIFO for a queue and priority ordering for a priority\r\n  queue.\r\nGiven how these linked lists represent these classes (queue: front to rear;\r\n  priority queue: highest to lowest priority), the order of iterating through\r\n  these classses is the same as the order of traversing their linked list\r\n  implementation from front to rear.\r\n<p>\r\nThere are four GoogleTest functions that focus on iterators:\r\n<b>iterator_plusplus</b> focuses on the two forms of <b>++</b> operators\r\n  and does <b>not</b> call the iterator's <b>erase</b>;\r\n<b>iterator_simple</b> does <b>not</b> call the iterator's <b>erase</b>;\r\n<b>iterator_erase</b> does call the iterator's <b>erase</b>; and\r\n<b>iterator__exception_concurrent_modification_error</b> ensures that mutating\r\n  the data structure forces any active iterator to stop working (unless the\r\n  mutation was done by that iterator's <b>erase</b>).\r\n<p>\r\nFor the <b>linked_set</b> class you must write all the code for the iterator.\r\nThe use of a trailer list will often make such code easier to write: it\r\n  requires only a <b>current</b> instance variable, not one for <b>prev</b>.\r\nIn general, you should hand-simulate/debug your iterator code for the following\r\n  cases:\r\n<ol>\r\n  <li> erasing the first value (maybe several in a row at the front)\r\n  <li> erasing non-consecutive values inside (with multiple <b>++</b>\r\n         operators between calls)\r\n  <li> erasing consecutive values  (with single <b>++</b>\r\n         operators between calls)\r\n  <li> erasing the last value (maybe several in a row at the end)\r\n</ol>\r\n<p>\r\nYou can study how these semantics are coded in the array implementations of\r\n  these data types, which are similiar but simpler than how they are coded with\r\n  linked lists (because we can more easily manipulate <b>int</b> array cursors:\r\n   <b>i-1</b> and <b>i+1</b>).\r\nFor linked list implementations, implementing <b>erase</b> on iterators is\r\n  typically more complicated, but more EFFICIENT: values removed in the middle\r\n  of arrays require shifting, causing the complexity class of <b>erase</b>\r\n  to be O(N) in arrays while being only O(1) in linked lists.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- testing -->\r\n\r\n<a name=\"testing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Testing</b></td>\r\n<td width =\"80%\">\r\nThere are various ways to test each of the classes you are writing in this\r\n  programming assignment.\r\nFirst, though, you should write all the methods, paying careful attention to\r\n  the array implementations and previously written linked list implementations.\r\nFor some, you might just boiler-plate simple code that is not correct, but\r\n  allows the methods to compile, allowing other methods in the classes to be\r\n  tested.\r\n<p>\r\nThe easiest way to start testing//debugging is by using the driver program.\r\nIt allows you to perform any method call supported by the templated classes,\r\n  and see the state of the class (or view the debugger).\r\nOf course, \r\n<b>you must get the <b>insertion</b> (&lt;&lt;) operator and str() method to\r\n  work before using it to debug the other methods.</b>\r\n<p>\r\nAfter you test and debug your code with the driver, try running the appropriate\r\n  GoogleTest code.\r\nAgain, this form of testing is useful only as you approach a finished solution.\r\nWe will use the GoogleTest, and visual inspection, to grade this assignment.\r\n<b>Important Note</b>: You can put <b>std::cout</b> statements in the GoogleTest\r\n  code (but don't accidentally remove any of the assertions, otherwise\r\n  you won't be fully checking your code the way we will) while you are\r\n  debugging your classes.\r\nAll debugging <b>std::cout</b> should end in <b>std::endl</b> to flush the\r\n  output stream: taht ensures the output it displayed before executing the next\r\n  statement (which may throw an exception).\r\n<p>\r\nWhen you run the GoogleTest, initially choose small values for the first and\r\n  third prompts (just press return to the second prompt) or replace these\r\n  prompts with small values in the code (so the test will run fully\r\n  automatically).\r\nBesides an indication of which tests pass and fail, the console window\r\n  will show a speed for the speed test (which will vary depending on how\r\n  fast a machine you run your code on): don't worry about it.\r\nWhen your code is passing all the tests, put in values like <b>10,000</b> for\r\n  these prompts.\r\n<p>\r\n\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 11060.0}