{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 4Handles and Circulators Olivier Devillers Lutz Kettner Michael Seel and Mariette Yvinec 4 1 Handles Most data structures in CGAL use the concept of Handle in their user interface to refer to the elements they store This concept describes what is sometimes called a trivial iterator A Handle is akeen to a pointer to an object providing the dereference operator operator and member access operator but no increment or decrement operators like iterators A Handle is intended to be used whenever the referenced object is not part of a logical sequence Model for a handle A simple pointer T an iterator or a circulator with value type T are also handles 4 2 Circulators An introduction to the concept of circulators is given here A couple of adaptors are presented that convert between iterators and circulators Some useful functions for circulators follow This chapter concludes with a discussion of the design decisions taken For the full description of the circulator requirements the provided base classes the circulator tags and the support for generic algorithms that work for iterators as well as for circulators please refer to the reference pages Note that circulators are not part of STL but of CGAL 4 2 1 Introduction The concept of iterators in STL is tailored for linear sequences C 98 MS96 In contrast circular sequences occur naturally in many combinatorial and geometric structures Examples are polyhedral surfaces and planar maps where the edges emanating from a vertex or the edges around a facet form a circular sequence Since circular sequences do not allow for efficient iterators we have introduced the new concept of circulators They share most of the requirements of iterators while the main difference is the lack of a past the end position in the sequence Appropriate adaptors are provided between iterators and circulators to integrate circulators smoothly into the framework of STL An example of a generic contains function illustrates the use of circulators As usual for circular structures a do while loop is preferable such that for the specific input c d all elements in the sequence are reached template class Circulator class T bool contains Circulator c Circulator d const T value if c do if c value return true while c d return false Three circulator categories are defined forward bidirectional and random access circulators Given a circulator c the operation c denotes the item the circulator refers to The operation c advances the circulator by one item and c steps a bidirectional circulator one item backwards For random access circulators c n advances the circulator n steps Two circulators can be compared for equality Circulators have a different notion of reachability and ranges than iterators A circulator d is called reachable from a circulator c if c can be made equal to d with finitely many applications of the operator Due to the circularity of the sequence this is always true if both circulators refer to items of the same sequence In particular c is always reachable from c Given two circulators c and d the range c d denotes all circulators obtained by starting with c and advancing c until d is reached but does not include d for d c So far it is the same range definition as for iterators The difference lies in the use of c c to denote all items in the circular sequence whereas for an iterator i the range i i denotes the empty range As long as c d the range c d behaves like an iterator range and could be used in STL algorithms For circulators however an additional test c NULL is required that returns true if and only if the circular sequence is empty As for C we recommend the use of instead of NULL Besides the conceptual cleanness the main reason for inventing a new concept with a similar intent as iterators is efficiency An iterator is supposed to be a light weight object merely a pointer and a single indirection to advance the iterator Although iterators could be written for circular sequences we do not know of an efficient solution The missing past the end situation in circular sequences can be solved with an arbitrary sentinel in the cyclic order but this would destroy the natural symmetry in the structure which is in itself a bad idea and additional bookkeeping in the items and checking in the iterator advance method reduces efficiency Another solution may use more bookkeeping in the iterator e g with a start item a current item and a kind of winding number that is zero for the begin iterator and one for the past the end situation1 We have introduced the concept of circulators that allows light weight implementations and the CGAL support library provides adaptor classes that convert between iterators and circulators with the corresponding penalty in efficiency so as to integrate this new concept into the framework of STL A serious design problem is the slight change of the semantic for circulator ranges as compared to iterator ranges Since this semantic is defined by the intuitive operators and which we would like to keep for circulators as well circulator ranges can be used in STL algorithms This is in itself a useful feature if there would not be the definition of a full range c c that an STL algorithm will treat as an empty range However the likelihood of a mistake may be overestimated since for a container C supporting circulators there is no end member function and an expression such as std sort C begin C end will fail It is easy to distinguish iterators and circulators at compile time which allows for generic algorithms supporting both as arguments It is also possible to protect algorithms against inappropriate arguments using the same technique see the reference pages for circulators specifically the Assert iterator and is empty range functions Warning Please note that the definition of a range is different from that of iterators An interface of a data structure must declare whether it works with iterators circulators or both STL algorithms always specify only iterators in their interfaces A range c d of circulators used in an interface for iterators will work as expected as long as c d A range c c will be interpreted as the empty range like for iterators which is different than the full range that it should denote for circulators Requirements for Circulators 4 2 5 Adaptors Between Iterators and Circulators Algorithms working on iterator ranges can not be applied to circulator ranges in full generality only to subranges see the warning in Section The following adaptors convert circulators to iterators and vice versa with the unavoidable space and time penalty to reestablish this generality include CGAL circulator h Container from circulator container like class with iterators built from a circulator Circulator from iterator circulator over a range of two iterators Circulator from container circulator for a container The following example applies the generic std reverse algorithm from STL to a sequence given by a bidirectional circulator c It uses the Container from circulator adaptor Circulator c c must be at least bidirectional CGAL Container from circulator Circulator container c std reverse container begin container end Another example defines a circulator c for a vector of int s However since there are no elements in the vector the circulator denotes an empty sequence If there were elements in the vector the circulator would implement a random access modulus the size of the sequence std vector int v typedef CGAL Circulator from iterator std vector int iterator Circulator Circulator c v begin v end 4 2 6 Functions on Circulators A few functions deal with circulators and circulator ranges The type C denotes a circulator The type IC denotes either a circulator or an iterator More on algorithms that work with circulators as well with iterators can be found in the reference pages include CGAL circulator h circulator size C c size of the sequence reachable by c circulator distance C c C d number of elements in the range c d iterator distance IC ic1 IC ic2 number of elements in the range ic2 ic1 is empty range IC ic1 IC ic2 test the range ic2 ic1 for emptiness Footnotes 1 This is currently implemented as the adaptor class which provides a pair of iterators for a given circulator Next chapter Handles and Circulators Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Circulator/Chapter_main.html", "title": "handles and circulators", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Circulator/main.tex' -->\n<html> <head>  \n<title>Handles and Circulators</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_4\"></a>\n  \n<h1>Chapter 4<BR>Handles and Circulators</h1>\n\n<A NAME=\"chap:Handles_and_Circs\"></A>\n<A NAME=\"chapterCirculators\"></A>\n<EM>Olivier Devillers, Lutz Kettner, Michael Seel, and Mariette Yvinec</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>4.1&nbsp;&nbsp;&nbsp;Handles</h2>\n<P>\n\nMost data structures in C<SMALL>GAL</SMALL> use the concept of <I><A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A></I> in their user\ninterface to refer to the elements they store.  This concept describes what is\nsometimes called a trivial iterator.  A <I><A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A></I> is akeen to a pointer to\nan object providing the dereference operator <I>operator*()</I> and member\naccess <I>operator-&gt;()</I> but no increment or decrement operators like\niterators.  A <I><A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A></I> is intended to be used whenever the referenced\nobject is not part of a logical sequence.\n<P>\n\n<b>Model for a handle</b>\n\nA simple pointer <I>T*</I>, an iterator or a circulator with value type\n<I>T</I>, are also handles.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>4.2&nbsp;&nbsp;&nbsp;Circulators</h2>\n<P>\n\nAn introduction to the concept of circulators is given here. A couple\nof adaptors are presented that convert between iterators and\ncirculators. Some useful functions for circulators follow. This\nchapter concludes with a discussion of the design decisions taken. For\nthe full description of the circulator requirements, the provided base\nclasses, the circulator tags, and the support for generic algorithms\nthat work for iterators as well as for circulators please refer to the\nreference pages. Note that circulators are not part of STL, but of C<SMALL>GAL</SMALL>.\n<P>\n\n<h3>4.2.1&nbsp;&nbsp;&nbsp;Introduction</h3>\n\n<A NAME=\"sectionIntroduction\"></A>\n<A NAME=\"sectionCirculatorWarning\"></A>\n<P>\n\nThe concept of iterators in STL is tailored for linear\nsequences&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ansi-is14882-98\">C<TT>++</TT>98</A>, <A HREF=\"../biblio.html#Biblio_cgal:ms-strg-96\">MS96</A>].  In contrast, circular\nsequences occur naturally in many combinatorial and geometric\nstructures. Examples are polyhedral surfaces and planar maps, where\nthe edges emanating from a vertex or the edges around a facet form a\ncircular sequence.\n<P>\n\nSince circular sequences do not allow for efficient iterators, we have\nintroduced the new concept of <I>circulators</I>. They share most of\nthe requirements of iterators, while the main difference is the lack\nof a past-the-end position in the sequence. Appropriate adaptors are\nprovided between iterators and circulators to integrate circulators\nsmoothly into the framework of STL. An example of a generic <TT>contains</TT> function illustrates the use of circulators.  As usual for\ncircular structures, a <TT>do</TT>-<TT>while</TT> loop is preferable, such\nthat for the specific input, <TT>c == d</TT>, all elements in the\nsequence are reached.\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt;class <A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A>, class T&gt;\nbool contains( <A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A> c, <A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A> d, const T&amp; value) {\n    if (c != 0) {\n        do {\n            if (*c == value)\n                return true;\n        } while (++c != d);\n    }\n    return false;\n}\n</pre>\n<P>\n\nThree circulator categories are defined: forward, bidirectional and\nrandom-access circulators. Given a circulator <TT>c</TT>, the operation\n<TT>*c</TT> denotes the item the circulator refers to. The operation <TT>++c</TT> advances the circulator by one item and <TT>-c</TT> steps a\nbidirectional circulator one item backwards. For random-access\ncirculators <TT>c+n</TT> advances the circulator <TT>n</TT> steps.  Two\ncirculators can be compared for equality.\n<P>\n\nCirculators have a different notion of reachability and ranges than\niterators. A circulator <TT>d</TT> is called <I>reachable</I> from a\ncirculator <TT>c</TT> if <TT>c</TT> can be made equal to <TT>d</TT> with\nfinitely many applications of the operator <TT>++</TT>. Due to the\ncircularity of the sequence this is always true if both circulators\nrefer to items of the same sequence. In particular, <TT>c</TT> is always\nreachable from <TT>c</TT>. Given two circulators <TT>c</TT> and <TT>d</TT>, the\nrange <TT>[c,d)</TT> denotes all circulators obtained by starting with\n<TT>c</TT> and advancing <TT>c</TT> until <TT>d</TT> is reached, but does not\ninclude <TT>d</TT>, for <TT>d</TT> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <TT>c</TT>.  So far it is the same\nrange definition as for iterators.  The difference lies in the use of\n<TT>[c,c)</TT> to denote all items in the circular sequence, whereas for\nan iterator <TT>i</TT> the range <TT>[i,i)</TT> denotes the empty range.  As\nlong as <TT>c != d</TT> the range <TT>[c,d)</TT> behaves like an iterator\nrange and could be used in STL algorithms. For circulators however,\nan additional test <TT>c == NULL</TT> is required that returns true if\nand only if the circular sequence is empty.  As for\nC++, we recommend the use of 0 instead of <TT>NULL</TT>.\n<P>\n\nBesides the conceptual cleanness, the main reason for inventing a new\nconcept with a similar intent as iterators is efficiency. An iterator\nis supposed to be a light-weight object - merely a pointer and a\nsingle indirection to advance the iterator.  Although iterators could\nbe written for circular sequences, we do not know of an efficient\nsolution. The missing past-the-end situation in circular sequences can\nbe solved with an arbitrary sentinel in the cyclic order, but this\nwould destroy the natural symmetry in the structure (which is in\nitself a bad idea) and additional bookkeeping in the items and\nchecking in the iterator advance method reduces efficiency.  Another\nsolution may use more bookkeeping in the iterator, e.g.&nbsp;with a start\nitem, a current item, and a kind of winding-number that is zero for\nthe <TT>begin()</TT>-iterator and one for the past-the-end\nsituation<A HREF=\"#Footnote_1\"><SUP>1</SUP></A>.  We have introduced the concept of circulators\nthat allows light-weight implementations and the C<SMALL>GAL</SMALL> support\nlibrary provides adaptor classes that convert between iterators and\ncirculators (with the corresponding penalty in efficiency), so as to\nintegrate this new concept into the framework of STL.\n<P>\n\nA serious design problem is the slight change of the semantic for\ncirculator ranges as compared to iterator ranges. Since this semantic\nis defined by the intuitive operators <TT>++</TT> and <TT>==</TT>, which we\nwould like to keep for circulators as well, circulator ranges can be\nused in STL algorithms. This is in itself a useful feature, if there\nwould not be the definition of a full range <MATH><I>[c, c)</I></MATH> that\nan STL algorithm will treat as an empty range. However, the\nlikelihood of a mistake may be overestimated, since for a container\n<TT>C</TT> supporting circulators there is no <TT>end()</TT> member\nfunction, and an expression such as <TT>std::sort( C.begin(),\n  C.end())</TT> will fail.  It is easy to distinguish iterators and\ncirculators at compile time, which allows for generic algorithms\nsupporting both as arguments.  It is also possible to protect\nalgorithms against inappropriate arguments using the same technique,\nsee the reference pages for circulators, specifically the\n<I><A HREF=\"../Circulator_ref/Function_Assert_circulator.html#Cross_link_anchor_1596\">Assert_iterator</A></I> and <I><A HREF=\"../Circulator_ref/Function_is_empty_range.html#Cross_link_anchor_1665\">is_empty_range</A></I> functions.\n<P>\n\n<B>Warning:</B> Please note that the definition of a range is different\nfrom that of iterators. An interface of a data structure must declare\nwhether it works with iterators, circulators, or both. STL \nalgorithms always specify only iterators in their interfaces. A range\n<MATH><I>[c, d)</I></MATH> of circulators used in an interface for iterators\nwill work as expected as long as <MATH><I>c != d</I></MATH>. A range <MATH><I>[c,\n  c)</I></MATH> will be interpreted as the empty range like for iterators,\nwhich is different than the full range that it should denote for\ncirculators.\n<P>\n\n<UL><LI>\n<a href=\"Circulator.html\">Requirements for Circulators</a></UL>\n<P>\n\n<h3>4.2.5&nbsp;&nbsp;&nbsp;Adaptors Between Iterators and Circulators</h3>\n\n<A NAME=\"sectionCirculatorAdaptor\"></A>\n<P>\n\nAlgorithms working on iterator ranges can not be applied to circulator\nranges in full generality, only to subranges (see the warning in\nSection&nbsp;<A HREF=\"Chapter_main.html#sectionCirculatorWarning\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). The following adaptors\nconvert circulators to iterators and vice versa (with the unavoidable\nspace and time penalty) to reestablish this generality.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/circulator.h\">CGAL/circulator.h</A>&gt;</I>\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n  <I><A HREF=\"../Circulator_ref/Class_Container_from_circulator.html#Cross_link_anchor_1660\">Container_from_circulator</A></I>   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      container-like class with iterators built from a circulator\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I><A HREF=\"../Circulator_ref/Class_Circulator_from_iterator.html#Cross_link_anchor_1618\">Circulator_from_iterator</A></I>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      circulator over a range of two iterators\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I><A HREF=\"../Circulator_ref/Class_Circulator_from_container.html#Cross_link_anchor_1612\">Circulator_from_container</A></I> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      circulator for a container\n\n</TD></TR></TABLE>\n<P>\n\nThe following example applies the generic <TT>std::reverse()</TT> algorithm \nfrom STL to a sequence given by a bidirectional circulator <TT>c</TT>.\nIt uses the <I><A HREF=\"../Circulator_ref/Class_Container_from_circulator.html#Cross_link_anchor_1660\">Container_from_circulator</A></I> adaptor.\n<P>\n\n<pre class=\"ExampleCode\">\n<A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A> c;  // c must be at least bidirectional.\n<A HREF=\"../Circulator_ref/Class_Container_from_circulator.html#Cross_link_anchor_1659\">CGAL::Container_from_circulator</A>&lt;<A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A>&gt; container(c);\nstd::reverse( container.begin(), container.end());\n</pre>\n<P>\n\nAnother example defines a circulator <I>c</I> for a vector of\n<I>int</I>'s. However, since there are no elements in the vector, the\ncirculator denotes an empty sequence.  If there were elements in the\nvector, the circulator would implement a random access modulus the\nsize of the sequence.\n<P>\n\n<pre class=\"ExampleCode\">\nstd::vector&lt;int&gt; v;\ntypedef  <A HREF=\"../Circulator_ref/Class_Circulator_from_iterator.html#Cross_link_anchor_1617\">CGAL::Circulator_from_iterator</A>&lt; \n             std::vector&lt;int&gt;::iterator &gt; <A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A>;\n<A HREF=\"../Circulator_ref/Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A> c( v.begin(), v.end());\n</pre>\n<P>\n\n<h3>4.2.6&nbsp;&nbsp;&nbsp;Functions on Circulators</h3>\n\n<A NAME=\"sectionCirculatorFunctions\"></A>\n<P>\n\nA few functions deal with circulators and circulator ranges. The type\n<I>C</I> denotes a circulator. The type <I>IC</I> denotes either a circulator\nor an iterator. More on algorithms that work with circulators as well with\niterators can be found in the reference pages.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/circulator.h\">CGAL/circulator.h</A>&gt;</I>\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n  \n  <I><A HREF=\"../Circulator_ref/Function_circulator_size.html#Cross_link_anchor_1606\">circulator_size</A>(C c)</I> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      size of the sequence reachable by <I>c</I>\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I><A HREF=\"../Circulator_ref/Function_circulator_distance.html#Cross_link_anchor_1604\">circulator_distance</A>(C c, C d)</I> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      number of elements in the range <MATH><I>[c, d)</I></MATH> \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I><A HREF=\"../Circulator_ref/Function_iterator_distance.html#Cross_link_anchor_1667\">iterator_distance</A>(IC ic1, IC ic2)</I> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      number of elements in the range <MATH><I>[<I>ic2</I>, <I>ic1</I>)</I></MATH> \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<I><A HREF=\"../Circulator_ref/Function_is_empty_range.html#Cross_link_anchor_1665\">is_empty_range</A>( IC ic1, IC ic2)</I> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n      test the range <MATH><I>[<I>ic2</I>, <I>ic1</I>)</I></MATH> for emptiness\n\n</TD></TR></TABLE>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nThis is currently implemented as the\n  adaptor class which provides a pair of iterators for a given\n  circulator.\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Circulator_ref/Chapter_intro.html\">Handles and Circulators</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_4!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38948.0}