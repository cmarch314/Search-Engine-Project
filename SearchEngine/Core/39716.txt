{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Polygon 2 PolygonTraits 2 Container Definition The class Polygon 2 PolygonTraits 2 Container implements polygons The Polygon 2 PolygonTraits 2 Container is parameterised by a traits class and a container class The latter can be any class that fulfills the requirements for an STL container It defaults to the vector class Caching By default Polygon 2 PolygonTraits 2 Container does not use caching That means that every time that a member function like is simple is called the result is computed from scratch This behaviour can be changed by defining a macro define CGAL POLYGON 2 CACHED In the future this caching behavior will be the default The only reason that it is not at the moment is that some compilers have problems when the CGAL POLYGON 2 CACHED flag is set This can be fixed by setting a second preprocessor flag as well CGAL POLYGON 2 MOD ITER The drawback of setting this flag is that some illegal operations will be allowed which can lead to wrong results The iterators of the polygon are mutable in this case but modifying the polygon through them will not invalidate the cache include CGAL Polygon 2 h Types Polygon 2 PolygonTraits 2 Container Traits The traits type Polygon 2 PolygonTraits 2 Container Container The container type typedef Traits FT FT The number type which is the field type of the points of the polygon typedef Traits Point 2 Point 2 The point type of the polygon typedef Traits Segment 2 Segment 2 The type of a segment between two points of the polygon The following types denote iterators that allow to traverse the vertices and edges of a polygon Since it is questionable whether a polygon should be viewed as a circular or as a linear data structure both circulators and iterators are defined The circulators and iterators are non mutable 1 The iterator category is in all cases bidirectional except for Vertex iterator which has the same iterator category as Container iterator N B In fact all of them should have the same iterator category as Container iterator However due to compiler problems this is currently not possible For vertices we define Polygon 2 PolygonTraits 2 Container Vertex iterator Polygon 2 PolygonTraits 2 Container Vertex circulator Their value type is Point 2 For edges we define Polygon 2 PolygonTraits 2 Container Edge const circulator Polygon 2 PolygonTraits 2 Container Edge const iterator Their value type is Segment 2 Creation Polygon 2 PolygonTraits 2 Container pgn Traits p traits Traits Creates an empty polygon pgn template class InputIterator Polygon 2 PolygonTraits 2 Container pgn InputIterator first InputIterator last Traits p traits Traits Introduces a polygon pgn with vertices from the sequence defined by the range first last The value type of InputIterator must be Point 2 Modifiers void pgn set Vertex iterator pos Point 2 x Acts as pos x except that that would be illegal because the iterator is not mutable Vertex iterator pgn insert Vertex iterator i Point 2 q Inserts the vertex q before i The return value points to the inserted vertex template class InputIterator void pgn insert Vertex iterator i InputIterator first InputIterator last Inserts the vertices in the range first last before i The value type of points in the range first last must be Point 2 void pgn push back Point 2 q Has the same semantics as p insert p vertices end q void pgn erase Vertex iterator i Erases the vertex pointed to by i void pgn erase Vertex iterator first Vertex iterator last Erases the vertices in the range first last void pgn reverse orientation Reverses the orientation of the polygon The vertex pointed to by p vertices begin remains the same Access FunctionsThe following methods of the class Polygon 2 return circulators and iterators that allow to traverse the vertices and edges Vertex iterator pgn vertices begin Returns a constant iterator that allows to traverse the vertices of the polygon p Vertex iterator pgn vertices end Returns the corresponding past the end iterator Vertex circulator pgn vertices circulator Returns a mutable circulator that allows to traverse the vertices of the polygon p Edge const iterator pgn edges begin Returns a non mutable iterator that allows to traverse the edges of the polygon p Edge const iterator pgn edges end Returns the corresponding past the end iterator Edge const circulator pgn edges circulator Returns a non mutable circulator that allows to traverse the edges of the polygon p Predicates bool pgn is simple Returns whether p is a simple polygon bool pgn is convex Returns whether p is convex Orientation pgn orientation Returns the orientation of pgn If the number of vertices p size 3 then COLLINEAR is returned Precondition p is simple Oriented side pgn oriented side Point 2 q Returns POSITIVE SIDE or NEGATIVE SIDE or ON ORIENTED BOUNDARY depending on where point q is Precondition p is simple Bounded side pgn bounded side Point 2 q Returns the symbolic constant ON BOUNDED SIDE ON BOUNDARY or ON UNBOUNDED SIDE depending on where point q is Precondition p is simple Bbox 2 pgn bbox Returns the smallest bounding box containing pgn Traits FT pgn area Returns the signed area of the polygon pgn This means that the area is positive for counter clockwise polygons and negative for clockwise polygons Vertex iterator pgn left vertex Returns the leftmost vertex of the polygon p with the smallest y coordinate Vertex iterator pgn right vertex Returns the rightmost vertex of the polygon p with the largest y coordinate Vertex iterator pgn top vertex Returns topmost vertex of the polygon p with the largest x coordinate Vertex iterator pgn bottom vertex Returns the bottommost vertex of the polygon p with the smallest x coordinate For convenience we provide the following boolean functions bool pgn is counterclockwise oriented bool pgn is clockwise oriented bool pgn is collinear oriented bool pgn has on positive side Point 2 q bool pgn has on negative side Point 2 q bool pgn has on boundary Point 2 q bool pgn has on bounded side Point 2 q bool pgn has on unbounded side Point 2 q Random access methods These methods are only available for random access containers Point 2 pgn vertex int i Returns a const reference to the i th vertex Point 2 pgn int i Returns a const reference to the i th vertex Segment 2 pgn edge int i Returns a const reference to the i th edge Miscellaneous int pgn size Returns the number of vertices of the polygon pgn bool pgn is empty Returns p size Container pgn container Returns a const reference to the sequence of vertices of the polygon pgn Globally defined operators template class Traits class Container1 class Container2 bool Polygon 2 Traits Container1 p1 Polygon 2 Traits Container2 p2 Test for equality two polygons are equal iff there exists a cyclic permutation of the vertices of p2 such that they are equal to the vertices of p1 Note that the template argument Container of p1 and p2 may be different template class Traits class Container1 class Container2 bool Polygon 2 Traits Container1 p1 Polygon 2 Traits Container2 p2 Test for inequality template class Transformation class Traits class Container Polygon 2 Traits Container transform Transformation t Polygon 2 Traits Container p Returns the image of the polygon p under the transformation t Implementation The methods is simple is convex orientation oriented side bounded side bbox area left vertex right vertex top vertex and bottom vertex are all implemented using the algorithms on sequences of 2D points See the corresponding global functions for information about which algorithms were used and what complexity they have If caching is turned on all functions are cached except those that compute on which side of the polygon a point is situated The cache is invalidated after any operation that modifies the polygon Example The following code fragment creates a polygon and checks if it is convex file examples Polygon Polygon C include CGAL Cartesian h include CGAL Polygon 2 h include iostream typedef CGAL Cartesian double K typedef K Point 2 Point typedef CGAL Polygon 2 K Polygon using std cout using std endl int main Point points Point Point 5 1 Point 1 1 Point 5 6 Polygon pgn points points 4 check if the polygon is simple cout The polygon is pgn is simple not simple endl check if the polygon is convex cout The polygon is pgn is convex not convex endl return Footnotes 1 At least conceptually The enforcement depends on preprocessor flags Next polygon area 2 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Polygon_ref/Class_Polygon_2.html", "title": "polygon_2&lt;polygontraits_2, container&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Polygon_ref/Polygon_2.tex' -->\n<html> <head>  \n<title>Polygon_2&lt;PolygonTraits_2, Container&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_671\"></A>\n\n<A NAME=\"Cross_link_anchor_672\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_624\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Polygon_2<PolygonTraits_2, Container>\"></A>\n<h2><I>CGAL::Polygon_2&lt;PolygonTraits_2, Container&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;</I> implements polygons.\nThe <I><A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;</I> is parameterised by a traits class and a container class.\nThe latter can be any class that fulfills the requirements for an STL container.\nIt defaults to the vector class.\n<P>\n\n<H3>Caching</H3>\nBy default, <I><A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;</I> does not use caching. That means that every time that\na member function like <I>is_simple</I> is called, the result is computed from\nscratch.  This behaviour can be changed by defining a macro.\n<pre class=\"ExampleCode\">\n#define CGAL_POLYGON_2_CACHED\n</pre>\n<P>\n\nIn the future, this caching behavior will be the default. The only reason that\nit is not at the moment is that some compilers have problems when the\n<I>CGAL_POLYGON_2_CACHED</I> flag is set. This can be fixed by setting a second\npreprocessor flag as well:\n<pre class=\"ExampleCode\">\nCGAL_POLYGON_2_MOD_ITER\n</pre>\nThe drawback of setting this flag is that some illegal operations will be\nallowed which can lead to wrong results.\nThe iterators of the polygon are mutable in this case, but modifying the polygon\nthrough them will not invalidate the cache.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Polygon_2.h\">CGAL/Polygon_2.h</A>&gt;</I>\n<P>\n\n<H3>Types</H3>\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;::Traits\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    The traits type.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;::Container\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    The container type.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_FT\"></A>\n<A NAME=\"Typedef_FT\"></A>\ntypedef Traits::FT\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    FT;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number type, which is the <I>field type</I> of the points of the polygon.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Point_2\"></A>\n<A NAME=\"Typedef_Point_2\"></A>\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The point type of the polygon.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_2\"></A>\n<A NAME=\"Typedef_Segment_2\"></A>\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The type of a segment between two\n points \nof the polygon.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following types denote iterators that allow to traverse the vertices and\nedges of a polygon. \nSince it is questionable whether a polygon should be viewed as a circular or \nas a linear data structure both circulators and iterators are defined.\nThe circulators and iterators are non-mutable.<A HREF=\"#Footnote_1\"><SUP>1</SUP></A>\nThe iterator category is in all cases bidirectional, except for\n<I>Vertex_iterator</I>, which has the\nsame iterator category as <I>Container::iterator</I>.\n<B>N.B.</B> In fact all of them should have the same iterator category as\n<I>Container::iterator</I>. However, due to compiler problems this is currently\nnot possible.\n<P>\n\nFor vertices we define\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;::Vertex_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;::Vertex_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nTheir value type is <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>.\n<P>\n\nFor edges we define\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;::Edge_const_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt;::Edge_const_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nTheir value type is <I><A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A></I>.\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt; pgn ( Traits p_traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Creates an empty polygon <I>pgn</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;<A HREF=\"Concept_PolygonTraits_2.html#Cross_link_anchor_670\">PolygonTraits_2</A>, Container&gt; pgn ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\nTraits p_traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Introduces a polygon <I>pgn</I> with vertices from the sequence defined by\n      the range <I>[first,last)</I>.\n      The value type of <I>InputIterator</I> must be <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set6Vertex_iterator_pos+_const_Point_2__x9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.set ( Vertex_iterator pos,  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> x)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Acts as <I>*pos = x</I>, except that that would be illegal because the\n      iterator is not mutable.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_insert6Vertex_iterator_i+_const_Point_2__q9;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.insert ( Vertex_iterator i,  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the vertex <I>q</I> before <I>i</I>.\n      The return value points to the inserted vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6Vertex_iterator_i+_InputIterator_first+_InputIterator_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pgn.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_iterator i,<BR>\n\nInputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the vertices in the range <I>[first, last)</I> before\n      <I>i</I>.\n      The value type of points in the range <I>[first,last)</I> must be\n                 <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_push_back6const_Point_2__q9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.push_back (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Has the same semantics as <I>p.insert(p.vertices_end(), q)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase6Vertex_iterator_i9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.erase ( Vertex_iterator i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Erases the vertex pointed to by <I>i</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase6Vertex_iterator_first+_Vertex_iterator_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pgn.erase ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_iterator first,<BR>\n\nVertex_iterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Erases the vertices in the range <I>[first, last)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_reverse_orientation69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.reverse_orientation ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Reverses the <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of the polygon. The vertex pointed to by\n      <I>p.vertices_begin()</I> remains the same.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>The following methods of the class <I><A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A></I> return\ncirculators and iterators that allow to traverse the vertices and edges.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_begin69_const;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a constant iterator that allows to traverse the vertices of\n      the polygon <I>p</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_end69_const;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_circulator_vertices_circulator69_const;\"></A>\nVertex_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.vertices_circulator ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a mutable circulator that allows to traverse the vertices of\n      the polygon <I>p</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_const_iterator_edges_begin69_const;\"></A>\nEdge_const_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.edges_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a non-mutable iterator that allows to traverse the edges of\n      the polygon <I>p</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_const_iterator_edges_end69_const;\"></A>\nEdge_const_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.edges_end ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_const_circulator_edges_circulator69_const;\"></A>\nEdge_const_circulator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.edges_circulator ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a non-mutable circulator that allows to traverse the edges of\n      the polygon <I>p</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_simple69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.is_simple ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns whether <I>p</I> is a simple polygon.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_convex69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.is_convex ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns whether <I>p</I> is convex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Orientation_orientation69_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Orientation.html#Cross_link_anchor_114\">Orientation</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.<A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of <I>pgn</I>. If the number of vertices \n      <MATH><I><I>p.size()</I> &lt; 3</I></MATH> then <I><A HREF=\"../Kernel_23_ref/Constant_COLLINEAR.html#Cross_link_anchor_125\">COLLINEAR</A></I> is returned.<BR>\n\n<EM>Precondition: </EM><I>p.is_simple()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Oriented_side_oriented_side6const_Point_2__q9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Oriented_side.html#Cross_link_anchor_116\">Oriented_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.oriented_side (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <I>POSITIVE_SIDE</I>, or <I>NEGATIVE_SIDE</I>,\n       or <I><A HREF=\"../Kernel_23_ref/Enum_Oriented_side#Enum_Oriented_side\">ON_ORIENTED_BOUNDARY</A></I>, \n       depending on where point <I>q</I> is.<BR>\n\n<EM>Precondition: </EM><I>p.is_simple()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_bounded_side6const_Point_2__q9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.bounded_side (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the symbolic constant <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I>, \n      <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I>\n      or <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I>, depending on where point\n      <I>q</I> is.<BR>\n\n<EM>Precondition: </EM><I>p.is_simple()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bbox_2_bbox69_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_42\">Bbox_2</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.bbox ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the smallest bounding box containing <I>pgn</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Traits::FT_area69_const;\"></A>\nTraits::FT\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.<A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the signed <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> of the polygon <I>pgn</I>. This means that the <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> is\n      positive for counter clockwise polygons and negative for clockwise polygons.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_left_vertex69;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.left_vertex ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the leftmost vertex of the polygon <I>p</I> with the smallest\n     <I>y</I>-coordinate.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_right_vertex69;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.right_vertex ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the rightmost vertex of the polygon <I>p</I> with the largest\n     <I>y</I>-coordinate.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_top_vertex69;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.top_vertex ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns topmost vertex of the polygon <I>p</I> with the largest\n     <I>x</I>-coordinate.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_bottom_vertex69;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.bottom_vertex ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the bottommost vertex of the polygon <I>p</I> with the smallest\n     <I>x</I>-coordinate.\n        </TD></TR>\n        </TABLE>\n<P>\n\nFor convenience we provide the following boolean functions:\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_counterclockwise_oriented69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.is_counterclockwise_oriented ()\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_clockwise_oriented69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.is_clockwise_oriented ()\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_collinear_oriented69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.is_collinear_oriented ()\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_positive_side6const_Point_2__q9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.has_on_positive_side (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_negative_side6const_Point_2__q9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.has_on_negative_side (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_boundary6const_Point_2__q9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.has_on_boundary (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_bounded_side6const_Point_2__q9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.has_on_bounded_side (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_unbounded_side6const_Point_2__q9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.has_on_unbounded_side (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> q)\n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\n<H3>Random access methods</H3>\nThese methods are only available for random access containers.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Point_2__vertex6int_i9_const;\"></A>\n <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pgn.vertex ( int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a (const) reference to the <MATH><I>i</I></MATH>-th vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     pgn [ int i]<A NAME=\"Function_const_Point_2__operator696int_i9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a (const) reference to the <MATH><I>i</I></MATH>-th vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Segment_2_edge6int_i9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.edge ( int i)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a const reference to the <MATH><I>i</I></MATH>-th edge.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_size69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.size ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the number of vertices of the polygon <I>pgn</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_empty69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.is_empty ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <MATH><I><I>p.size()</I> == 0</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Container__container69_const;\"></A>\n Container\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    pgn.container ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a const reference to the sequence of vertices of the polygon \n      <I>pgn</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Globally defined operators</H3>\n<P>\n\n<I>template &lt;class Traits, class Container1, class Container2&gt;</I>\n  \n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n      <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;Traits,Container1&gt; p1 ==  <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;Traits,Container2&gt; p2<A NAME=\"Function_bool_operator==6const_Polygon_26Traits+Container19__p1+_const_Polygon_26Traits+Container29__p29;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Test for equality: two polygons are equal iff there exists a cyclic\n       permutation of the vertices of <I>p2</I> such that they are equal to the\n       vertices of <I>p1</I>. Note that the template argument\n       <I>Container</I> of <I>p1</I> and <I>p2</I> may be different.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<I>template &lt;class Traits, class Container1, class Container2&gt;</I>\n  \n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n      <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;Traits,Container1&gt; p1 !=  <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;Traits,Container2&gt; p2<A NAME=\"Function_bool_operator!=6const_Polygon_26Traits+Container19__p1+_const_Polygon_26Traits+Container29__p29;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Test for inequality.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<I>template &lt;class Transformation, class Traits, class Container&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Polygon_26Traits+Container9_transform6const_Transformation__t+_const_Polygon_26Traits+Container9__p9;\"></A>\n<A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;Traits,Container&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    transform ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Transformation t,<BR>\n\n<A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&lt;Traits,Container&gt; p)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the image of the polygon <I>p</I> under the transformation <I>t</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Implementation</H3>\n<P>\n\nThe methods\n<I>is_simple</I>,\n<I>is_convex</I>,\n<I><A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A></I>,\n<I>oriented_side</I>,\n<I>bounded_side</I>,\n<I>bbox</I>,\n<I><A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A></I>,\n<I>left_vertex</I>,\n<I>right_vertex</I>,\n<I>top_vertex</I> and\n<I>bottom_vertex</I>\nare all implemented using the algorithms on sequences of 2D points.\nSee the corresponding global functions for information about which algorithms\nwere used and what complexity they have.\n<P>\n\nIf caching is turned on, all functions are cached except those that compute on\nwhich side of the polygon a point is situated.\nThe cache is invalidated after any operation that modifies the polygon.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe following code fragment creates a polygon and checks if it is convex.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polygon/Polygon.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt; K;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> Point;\ntypedef <A HREF=\"Class_Polygon_2.html#Cross_link_anchor_671\">CGAL::Polygon_2</A>&lt;K&gt; Polygon;\nusing std::cout; using std::endl;\n\n\nint main()\n{\n  Point points[] = { Point(0,0), Point(5.1,0), Point(1,1), Point(0.5,6)};\n  Polygon pgn(points, points+4);\n\n  // check if the polygon is simple.\n  cout &lt;&lt; &quot;The polygon is &quot; &lt;&lt; \n    (pgn.is_simple() ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;simple.&quot; &lt;&lt; endl;\n\n  // check if the polygon is convex\n  cout &lt;&lt; &quot;The polygon is &quot; &lt;&lt; \n    (pgn.is_convex() ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;convex.&quot; &lt;&lt; endl;\n\n  return 0;\n}\n\n</pre>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nAt least conceptually.\nThe enforcement depends on preprocessor flags.\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_polygon_area_2.html\"><I>polygon_area_2</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_8!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39716.0}