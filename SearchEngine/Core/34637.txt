{"text": "Introducing Graphs Introduction to Computer Science III ICS 23 Introduction In this lecture we will continue our study of self referential data structures by examining graphs Like linked lists and trees graphs contain nodes these nodes are objects instantiated from a class that contains instance variables that refer to other nodes from this same class In some sense graphs are very easy to specify because unlike linked lists and trees there are no restrictions any node can refer to any other node In fact we can define a linear linked list as a restricted graph all nodes have an in degree and out degree of 1 except the first has an in degree and the last has out degree of trees can be similarly defined in terms of a restricted graph an acyclic graph in which every modes has in degree of 1 except the first which has an in degree of Both cycles and in dgree are technical terms defined below Here is a picture of a DAG directed acyclic graph which is halfway between a tree it has no cycles and a graph but it has a node with in degree two the common subexpression We can use graphs to model very many real world relationships Then we can use standard graph algorithms to process the graph producing answers to problems modeled via graphs There are entire books written on graph algorithms We will examine a few interesting graph algorithms again concentrating on the algorithms themselves not the methods that implement them in this lecture and the next one Terminology The mathematical theory of graphs was first developed by the famous mathematician Leonard Euler in 1735 It was motivated by a desire to solve the following problem taken from the web page The Beginning of Topology which also contains Euler s solution to this problem Euler proved that no such tour now called an Euler path was possible a similar problem is known as The Traveling Salesman problem in which the traveler must end up at the same place he started it also involves another criteria minmizing the distance traveled Using some of the terminology we will learn below the relevant theorems are Theorem If an undirected graph has more than two nodes with an odd degree it does not have an Euler path Theorem If an undirected graph has two nodes or fewer with an odd degree it has at least one Euler path It is interesting that local properties the degrees of the nodes determines whether or not a global property Euler paths are possible Graphs consist of a collection of nodes aka vertices each with a label it is known by Edges aka arcs occur between pair of nodes and each edge can have an associated value used to encode a variety of information often a number for the length of the edge the cost of the edge etc In a directed graph aka digraph the kind we will study edges have a distinguishable origin and destination node an edge is written as an arrow from its origin to its destination A graph might contain just one edge between two nodes or it might contain two one from the first to the second and one back from the second to the first with each edge associated with its own value A directed graph is weakly symmetric if when there is an edge from node1 to node2 then there also is an edge from node2 to node1 likewise a directed graph is strongly symmetric if when there is an edge from node1 to node2 then there also is an edge from node2 to node1 with the associated values for these edges equal In an undirected graph there can be only one edge between any pair of nodes each node serves as an origin and a destination A subgraph of a graph contains a subset of its nodes and edges The natural subgraph of a graph containing a certain subset of nodes includes all the edges in the graph that have a node in this subset as both an origin and destination node We have used graphs informally in the collection class problems There we represented a graph by a map whose key is the name of a node and whose value is the set of nodes that it reaches In this representation of a directed graph we omitted the value for the edge and the ability to find the nodes leading into a node easily Both of these deficiencies are removed in the actual graph classes we implement below A graph with N nodes can have between and N2 edges in this case every node has an edge leading to every other node including itself We call a graph sparse if it has O N edges likewise we call a graph dense if it has O N2 edges The in degree of a node is a count of the number of edges having this node as their destination likewise the out degree of a node is a count of the number of edges having this node as their origin The degree of a node is the sum of its in degree and out degree A node is considered a source in a graph if it has in degree of no nodes have a source as their destination likewise a node is considered a sink in a graph if it has out degree of no nodes have a sink as their source A path is a sequence of nodes a1 a2 an such that there is an edge from ai to ai 1 A graph is cyclic if it has some path that contains the same node twice Such a path is called a cycle Likewise if a graphy contains no cycles the graph is acyclic aka noncyclic A graph is connected if there is a path between any two nodes If a graph is not connected it can be decomposed into its connected components each is the largest subgraph that is connected Note that is two components both include the same node then the can be merged into a larger component For an acyclic graph each node appears in its own connected component A spanning tree is an acyclic subset of a graph that represents an N ary tree we can choose any node as the root Typically there are many spanning trees for a graph A minimum spanning tree is one that minimizes the sum of the values associated with all the edges contained in the spanning tree The transitive closure of a graph is a graph with no fewer nodes such that if there is a path from node1 to node2 in the original graph there is an edge from node1 to node2 in the transitive closure and its value is often related to the values on the path one useful way to do this is to assign the value of this edge to be the minimum sum of edge values on any path between the nodes Below is a directed graph in which the nodes represent airports and the edges represent flights from one airport to another The edge values represent the mileage for each flight or they could represent the cost of an airplane ticket for that flight the time of the flight etc This graph is strongly symmetic rather than showing to edges connecting each pair of nodes we show one double arrowed edge This graph is taken from the excellent book Goodrich and Tamassia Data Structures and Algorithms in Java John Wiley Sons 1998 Let s state some facts about this tree using some of the terminology defined above There is a node named SFO There is an edge from the node named SFO origin to the node named BOS destination and vice versa that has the value 27 4 The graph is stongly symmetric The graph is cyclic in fact not only does it have a cycle it is connected there is a path from every node to every other node It has a natural subgraph ORD PVD JFK that is is also connected it has a natural subgraph SFO MIA PVD that is not in fact such a subgraph contains no edges Another useful set of values for each edge might be the cost of taking each flight not the distance between its city of origin and its destination A similar but much more extensive graph is used as the underlying data structure in Mapquest a web site that plans travel routes including computing the amount of travel time Note that real graphs might model one way streets so there may be an edge a street that one can travel from corner1 to corner2 but not vice versa Also some roads may be partitioned into more lanes going one way than the other so although there are edges going each way their values might be different In the future programs such a Mapquest might take into account what time you are traveling in some places traffic patterns vary tremendously from the norm during rush hours in fact if billions of sensors are placed on roads throughout the US they could report traffic slowdowns to Mapquest which could contact you in your car via something like the Onstar system and automatically reroute you to avoid such delays Graphs can also easily model the servers nodes and transmission lines edges with their transmission speeds capacities bandwidth indicated by their values of the internet We can ask questions like what is the minimum time it would take to transmit a large number of web pages from one server to another using all the paths available not exceeding the bandwidth of any transmission line This problem a bit beyond the scope of this course was originally solved by the Ford Fulkerson algorithm and improved by the Edmonds Karp algorithm whose complexity class is O nm2 where n is the number of nodes and m is the number of edges respectively in the graph The Graph Interface Graphs are rich data structures We will use the following interface to define the methods that we can use to query and update any graph Note that just as the Map interface defines the nested Entry interface the Graph interface defines the nested Edge and EdgeValueIOinterface Some methods have an Edge as a parameter many methods return Iterable objectss where each value is a String or Edge public interface Graph E Mutators public Graph addNode String nodeName public Graph addEdge String origin String destination E edgeValue public Graph addEdge Edge ltE edge E edgeValue public Graph removeNode String nodeName public Graph removeEdge String origin String destination public Graph removeEdge Edge ltE edge public void clear Accessors public int getNodeCount public int getEdgeCount public boolean hasNode String nodeName public boolean hasEdge String origin String destination public boolean hasEdge Edge ltE edge public E getEdgeValue String origin String destination public E getEdgeValue Edge ltE edge public int inDegree String nodeName public int outDegree String nodeName public int degree String nodeName The returned iterators don t implement remove public Iterable ltString getAllNodes public Iterable ltEdge ltE getAllEdges public Iterable ltString getOutNodes String nodeName public Iterable ltString getInNodes String nodeName public Iterable ltEdge E getOutEdges String nodeName public Iterable ltEdge E getInEdges String nodeName I O public EdgeValueIO ltE getEdgeValueIO public Graph load TypedBufferReader input char tokenSeparator public void write TypedBufferWriter output char tokenSeparator Nested interfaces public interface EdgeValueIO ltE public E readEdgeValue String s public String writeEdgeValue E e public interface Edge ltE public String getOrigin public String getDestination public E getValue We will use objects constructed from classes implementing the EdgeValueIO interface when constructing a graph I have written simple useful The two methods specified in it are useful in the load and write methods for graphs when reading writing files they help convert edge values to Strings and vice versa Given all these interfaces we can use it to implement many general algorithms to process graphs One simple one is shown below Simple Algorithms In this section we will discuss topological sorting as an example of a simple graph algorithm Imagine we model a process by encoding nodes as tasks and edges specifying which tasks must come before which others if there is a directed edge from node 1 to node 2 then the task at node 1 must be completed before the task at node 1 we will associate no value with an edge For example we can simply model a cake making task as follows Other tasks like building a skyscraper can be modeled similarly but with much more complexity tens of thousand or hundreds of thousands of subtasks and ordering relationships The problem is to sort all the tasks into a linear sequence so that if we perform the tasks in that order all the ordering relationships are observed All the standard sorting algorithms do not work because they assume the law of trichotomy given two values the first is less than equal to or greater than the third In the example above the nodes labeled CDI and CWI cannot be compared either task can be completed before the other In such cases we must use topological sorting to solve the problem Note that this method works only on acyclical graphs if a graph has a cycle then we cannot require any node be listed first because each node has another one the precedes it in the cycle The algorithm for topological sorting is Repeatedly find any node that is a source print it and remove it and all its related edges from the graph When applied to the graph above it can produce two different orderings each legal acording to the ordering constraints modeled in the graph AI CDI CWI CI B as well as AI CWI CDI CI B We can implement this algorithm as follows Graph Object g new HashGraph Object new NoEdgeValue List String sorted new ArrayList String g load new TypedBufferReader Enter file with graph to sort for g getNodeCount for Iterator String nodes g getAllNodes iterator nodes hasNext String nodeName nodes next if g inDegree nodeName If node is a source sorted add nodeName Add it next in the list g removeNode nodeName Remove it from graph break Restart iterator if nodes hasNext Iterator about to finish throw new IllegalStateException No source must be cyclic System out println Order sorted In the outer loop we loop so long as there are nodes in the graph to process In the inner loop we iterate over all the nodes if we find one with an in degree of we add it to the sorted list and remove it by using the iterator both from the set of nodes and from the graph itself including all its in out edges enabling yet other nodes to reduce their in degree to We then must break because removing the node will cause the iterator to throw the ConcurrentModificationException Finally if iterating over the nodes none has in degree it means that the graph must be cyclic we recognize this case and throw an exception The complexity class of this algorithm is O N2 since the outer loop is executed at most N times at most once to remove each node from the graph and the inner loop is executed at most N times removing one node for each full iteration A similar problem in the C C programming languages involves compiling a system comprising very many files with constraints on which files must be compiled first this is not a problem in Java Often programmers create make files that contain such ordering information specifying that one file must be compiled before another We can create a graph based on the model above and then topologically sort it to determine a legal order in which to compile the files If there are multiple bakers or multiple computers we can modify the topological sorting algorithm on the graph to have as many tasks being simultaneously worked on as is allowed by the ordering constraints Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a CA or any other student None yet ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/lectures/graphs/lecture.html", "title": "introducing graphs", "html": "\r\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Introducing Graphs</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Introducing Graphs</h1>\r\n<p>\r\n<h2>Introduction to Computer Science III<br>\r\nICS-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture we will continue our study of self-referential data structures\r\n by examining graphs.\r\nLike linked lists and trees, graphs contain nodes: these nodes are objects\r\n  instantiated from a class that contains instance variables that refer to\r\n  other nodes from this same class.\r\nIn some sense, graphs are very easy to specify because, unlike linked lists and\r\n  trees, there are no restrictions: any node can refer to any other node.\r\n<p>\r\nIn fact, we can define a linear linked list as a restricted graph: all nodes\r\n  have an in-degree and out-degree of 1 (except the first has an in-degree 0\r\n  and the last has out-degree of 0); trees can be similarly defined in terms\r\n  of a restricted graph: an acyclic graph in which every modes has in-degree of\r\n  1 (except the first which has an in-degree of 0).\r\nBoth cycles and  in-dgree are technical terms defined below).\r\nHere is a picture of a DAG (directed acyclic graph) which is halfway between\r\n  a tree (it has no cycles) and a graph (but it has a node with in-degree two:\r\n  the common subexpression).\r\n</tbody>\r\n</table>\r\n  <img src=\"images/dag.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nWe can use graphs to model very many real-world relationships.\r\nThen, we can use standard graph algorithms to process the graph, producing\r\n  answers to problems modeled via graphs.\r\nThere are entire books written on graph algorithms.\r\nWe will examine a few interesting graph algorithms (again concentrating on the\r\n  algorithms themselves, not the methods that implement them) in this lecture\r\n  and the next one.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Terminology -->\r\n\r\n<a name=\"Terminology\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Terminology</b></td>\r\n<td width =\"80%\">\r\nThe mathematical theory of graphs was first developed by the famous\r\n  mathematician Leonard Euler in 1735.\r\nIt was motivated by a desire to solve the following problem (taken from the\r\n  web page\r\n  <a href=\"http://mathforum.org/isaac/problems/bridges1.html\">\r\n    The Beginning of Topology</a>,\r\n  which also contains Euler's solution to this problem).\r\n<p>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/konigsberg.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nEuler proved that no such tour (now called an Euler path) was possible\r\n(a similar problem is known as \"The Traveling Salesman\" problem, in which\r\n  the traveler must end up at the same place he started; it also involves\r\n  another criteria: minmizing the distance traveled)\r\nUsing some of the terminology we will learn below, the relevant theorems are:\r\n<ul>\r\n<li>Theorem: If an undirected graph has more than two nodes with an odd degree,\r\n      it does not have an Euler path. \r\n<li>Theorem: If an undirected graph has two nodes or fewer with an odd degree,\r\n      it has at least one Euler path. \r\n</ul>\r\nIt is interesting that local properties (the degrees of the nodes) determines\r\n  whether or not a global property (Euler paths) are possible.\r\n<p>\r\nGraphs consist of a collection of <b>nodes</b> (aka vertices), each with a \r\n  <b>label</b> it is known by.\r\n<b>Edges</b> (aka arcs) occur between pair of nodes, and each edge can have an\r\n  associated value (used to encode a variety of information: often a number,\r\n  for the length of the edge, the cost of the edge, etc).\r\nIn a <b>directed graph</b> (aka digraph, the kind we will study), edges have a\r\n  distinguishable <b>origin</b> and <b>destination</b> node; an edge is written\r\n  as an arrow from its origin to its destination.\r\nA graph might contain just one edge between two nodes, or it might contain two:\r\n  one from the first to the second, and one back from the second to the first\r\n (with each edge associated with its own value).\r\nA directed graph is <b>weakly-symmetric</b> if when there is an edge from node1\r\n  to node2, then there also is an edge from node2 to node1; likewise, a \r\n  directed graph is <b>strongly-symmetric</b> if when there is an edge from\r\n  node1 to node2, then there also is an edge from node2 to node1 with the\r\n  associated values for these edges equal.\r\nIn an <b>undirected graph</b>, there can be only one edge between any pair of\r\n  nodes: each node serves as an origin and a destination.\r\n<p>\r\nA <b>subgraph</b> of a graph contains a subset of its nodes and edges.\r\nThe <b>natural subgraph</b> of a graph (containing a certain subset of nodes)\r\n  includes all the edges in the graph that have a node in this subset as both\r\n  an origin and destination node.\r\n<p>\r\nWe have used graphs, informally, in the collection class problems.\r\nThere, we represented a graph by a map whose key is the name of a node and\r\n  whose value is the set of nodes that it reaches.\r\nIn this representation of a directed graph, we omitted the value for the\r\n  edge and the ability to find the nodes leading into a node easily.\r\nBoth of these deficiencies are removed in the actual graph classes we implement\r\n  below.\r\n<p>\r\nA graph with N nodes can have between 0 and N<sup>2</sup> edges (in this case,\r\n  every node has an edge leading to every other node, including itself.\r\n  We call a graph sparse if it has O(N) edges; likewise we call a graph dense\r\n  if it has O(N<sup>2</sup>) edges.\r\n<p>\r\nThe in-degree of a node is a count of the number of edges having this node as\r\n  their destination; likewise, the out-degree of a node is a count of the\r\n  number of edges having this node as their origin.\r\nThe degree of a node is the sum of its in-degree and out-degree.\r\nA node is considered a source in a graph if it has in-degree of 0 (no nodes\r\n  have a source as their destination); likewise, a node is considered a sink\r\n  in a graph if it has out-degree of 0 (no nodes have a sink as their source).\r\n<p>\r\nA <b>path</b> is a sequence of nodes a<sub>1</sub>, a<sub>2</sub>, ... \r\n  a<sub>n</sub>, such that there is an edge from a<sub>i</sub> to\r\n  a<sub>i+1</sub>.\r\nA graph is <b>cyclic</b> if it has some path that contains the same node twice.\r\nSuch a path is called a <b>cycle</b>.\r\nLikewise, if a graphy contains no cycles, the graph is <b>acyclic</b> (aka\r\n  noncyclic).\r\n<p>\r\nA graph is <b>connected</b> if there is a path between any two nodes.\r\nIf a graph is not connected, it can be decomposed into its <b>connected\r\n  components</b>: each is the largest subgraph that is connected.\r\nNote that is two components both include the same node, then the can be\r\n  merged into a larger component.\r\nFor an acyclic graph, each node appears in its own connected component.\r\n<p>\r\nA spanning tree is an acyclic subset of a graph that represents an N-ary tree;\r\n  we can choose any node as the root.\r\nTypically, there are many spanning trees for a graph.\r\nA minimum spanning tree is one that minimizes the sum of the values associated\r\n  with all the edges contained in the spanning tree.\r\n<p>\r\nThe transitive closure of a graph is a graph with no fewer nodes such that if\r\n  there is a path from node1 to node2 in the original graph, there is an edge\r\n  from node1 to node2 in the transitive closure (and its value is often related\r\n  to the values on the path: one useful way to do this is to assign the value\r\n  of this edge to be the minimum sum of edge values on any path between the\r\n  nodes).\r\n<p>\r\nBelow is a directed graph in which the nodes represent airports and the edges\r\n  represent flights from one airport to another.\r\nThe edge values represent the mileage for each flight (or, they could represent\r\n  the cost of an airplane ticket for that flight, the time of the flight,\r\n  etc).\r\nThis graph is strongly symmetic; rather than showing to edges connecting each\r\n  pair of nodes, we show one (double-arrowed) edge.\r\n<p>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/airline.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThis graph is taken from the excellent book: Goodrich and Tamassia,\r\n \" Data Structures and Algorithms in Java\", John Wiley & Sons, 1998.\r\n<p>\r\nLet's state some facts about this tree using some of the terminology defined\r\n  above.\r\n<ul>\r\n<li>There is a node named <b>SFO</b>.\r\n<li>There is an edge from the node named <b>SFO</b> (origin) to the node named\r\n      <b>BOS</b> (destination) -and vice versa- that has the value <b>2704</b>.\r\n<li>The graph is stongly symmetric.\r\n<li>The graph is cyclic; in fact, not only does it have a cycle, it is\r\n      connected: there is a path from every node to every other node.\r\n<li>It has a natural subgraph (<b>ORD</b>, <b>PVD</b>, <b>JFK</b>) that is\r\n      is also connected; it has a natural subgraph (<b>SFO</b>, <b>MIA</b>,\r\n      <b>PVD</b>) that is not: in fact, such a subgraph contains no edges.\r\n</ul>\r\nAnother useful set of values for each edge might be the cost of taking each\r\n  flight (not the distance between its city of origin and its destination).\r\n<p>\r\nA similar but much more extensive graph is used as the underlying data\r\n  structure in <b>Mapquest</b>, a web site that plans travel routes,\r\n  including computing the amount of travel time.\r\nNote that real graphs might model one-way streets (so there may be an edge\r\n  -a street that one can travel- from corner1 to corner2 but not vice versa).\r\nAlso, some roads may be partitioned into more lanes going one way than the\r\n  other, so although there are edges going each way, their values might be\r\n  different.\r\nIn the future, programs such a Mapquest might take into account what time you\r\n  are traveling (in some places, traffic patterns vary tremendously from the\r\n  norm during rush hours); in fact, if billions of sensors are placed on roads\r\n  throughout the US, they could report traffic slowdowns to Mapquest, which\r\n   could contact you in your car (via something like the <b>Onstar</b> system)\r\n   and automatically reroute you to avoid such delays.\r\n<p>\r\nGraphs can also easily model the servers (nodes) and transmission lines (edges,\r\n  with their transmission speeds/capacities -bandwidth- indicated by their\r\n  values) of the internet.\r\nWe can ask questions like what is the minimum time it would take to transmit a\r\n  large number of web pages from one server to another using all the paths\r\n  available, not exceeding the bandwidth of any transmission line.\r\nThis problem, a bit beyond the scope of this course, was originally solved by\r\n  the Ford-Fulkerson algorithm, and improved by the Edmonds-Karp algorithm,\r\n  whose complexity class is <b>O(nm<sup>2</sup>)</b>, where <b>n</b> is the\r\n  number of nodes and <b>m</b> is the number of edges respectively in the\r\n  graph. \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Graph Interface -->\r\n\r\n<a name=\"Interface\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Graph Interface</b></td>\r\n<td width =\"80%\">\r\nGraphs are rich data structures.\r\nWe will use the following interface to define the methods that we can use to\r\n  query and update any graph.\r\nNote that just as the <b>Map</b> interface defines the nested <b>Entry</b>\r\n  interface, the <b>Graph</b> interface defines the nested <b>Edge</b>\r\n  and <b>EdgeValueIO</b>interface.\r\nSome methods have an <b>Edge</b> as a parameter: many methods return\r\n  <b>Iterable</b> objectss, where each value is a <b>String</b> or <b>Edge</b>.\r\n<pre><b>  \r\n  public interface Graph&lt;E&gt; {\r\n\r\n    //Mutators\r\n \r\n    public Graph   addNode      (String nodeName);\r\n    public Graph   addEdge      (String origin, String destination, E edgeValue);\r\n    public Graph   addEdge      (Edge&ltE&gt; edge, E edgeValue);\r\n  \r\n    public Graph   removeNode   (String nodeName);\r\n    public Graph   removeEdge   (String origin, String destination);\r\n    public Graph   removeEdge   (Edge&ltE&gt; edge);\r\n  \r\n    public void    clear        ();\r\n\r\n\r\n    //Accessors\r\n  \r\n    public int     getNodeCount ();\r\n    public int     getEdgeCount ();\r\n\r\n    public boolean hasNode      (String nodeName);\r\n    public boolean hasEdge      (String origin, String destination);\r\n    public boolean hasEdge      (Edge&ltE&gt; edge);\r\n\r\n    public E       getEdgeValue (String origin, String destination);\r\n    public E       getEdgeValue (Edge&ltE&gt; edge);\r\n  \r\n    public int     inDegree     (String nodeName);\r\n    public int     outDegree    (String nodeName);\r\n    public int     degree       (String nodeName);\r\n  \r\n    //The returned iterators don't implement remove\r\n    public Iterable&ltString&gt;  getAllNodes ();\r\n    public Iterable&ltEdge&ltE&gt;&gt; getAllEdges ();\r\n  \r\n    public Iterable&ltString&gt;  getOutNodes  (String nodeName);\r\n    public Iterable&ltString&gt;  getInNodes   (String nodeName);\r\n    public Iterable&ltEdge&lt;E&gt;&gt; getOutEdges  (String nodeName);\r\n    public Iterable&ltEdge&lt;E&gt;&gt; getInEdges   (String nodeName);\r\n  \r\n  \r\n    // I/O\r\n  \r\n    public EdgeValueIO&ltE&gt; getEdgeValueIO ();\r\n    public Graph          load           (TypedBufferReader input , char tokenSeparator);\r\n    public void           write          (TypedBufferWriter output, char tokenSeparator);\r\n\r\n  \r\n    //Nested interfaces\r\n\r\n    public interface EdgeValueIO&ltE&gt; {\r\n      public E       readEdgeValue  (String s);\r\n      public String  writeEdgeValue (E e);\r\n    }\r\n\r\n    public interface Edge&ltE&gt; {\r\n      public String getOrigin();\r\n      public String getDestination();\r\n      public E      getValue();\r\n    }\r\n  \r\n  }</pre></b>\r\nWe will use objects constructed from classes implementing the\r\n  <b>EdgeValueIO</b> interface when constructing a graph: I have\r\n  written simple useful\r\nThe two methods specified in it are useful in the <b>load</b> and <b>write</b>\r\n  methods for graphs: when reading/writing files they help convert edge values\r\n  to <b>String</b>s and vice versa.\r\n<p>\r\nGiven all these interfaces, we can use it to implement many general\r\n  algorithms to process graphs.\r\nOne simple one is shown below.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Simple Algorithms -->\r\n\r\n<a name=\"Simple\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Simple Algorithms</b></td>\r\n<td width =\"80%\">\r\nIn this section we will discuss topological sorting as an example of a simple\r\n  graph algorithm.\r\nImagine we model a process by encoding nodes as tasks and edges specifying\r\n  which tasks must come before which others: if there is a directed edge from\r\n  node 1 to node 2, then the task at node 1 must be completed before the task\r\n  at node 1 (we will associate no value with an edge).\r\nFor example, we can simply model a cake-making task as follows.\r\n<p>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/topsort.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nOther tasks, like building a skyscraper, can be modeled similarly but with\r\n  much more complexity (tens of thousand or hundreds of thousands of subtasks\r\n  and ordering relationships).\r\n<p>\r\nThe problem is to sort all the tasks into a linear sequence, so that if we\r\n  perform the tasks in that order, all the ordering relationships are observed.\r\nAll the standard sorting algorithms do not work, because they assume the law of\r\n  trichotomy: given two values, the first is less than, equal to, or greater\r\n  than the third.\r\nIn the example above, the nodes labeled <b>CDI</b> and <b>CWI</b> cannot be\r\n  compared: either task can be completed before the other.\r\n<p>\r\nIn such cases, we must use topological sorting to solve the problem.\r\nNote that this method works only on acyclical graphs: if a graph has a cycle,\r\n  then we cannot require any node be listed first, because each node has\r\n  another one the precedes it in the cycle.\r\nThe algorithm for topological sorting is \r\n<ul>\r\n<li>Repeatedly find any node that is a source: print it and remove it (and\r\n      all its related edges) from the graph.\r\n</ul>\r\nWhen applied to the graph above, it can produce two different orderings, each\r\n  legal acording to the ordering constraints modeled in the graph: AI, CDI,\r\n  CWI, CI, B as well as AI, CWI, CDI, CI, B.\r\n<p>\r\nWe can implement this algorithm as follows\r\n<b><pre>  Graph&lt;Object&gt; g = new HashGraph&lt;Object&gt;(new NoEdgeValue());\r\n  List&lt;String&gt;  sorted = new ArrayList&lt;String&gt;();\r\n  g.load(new TypedBufferReader(\"Enter file with graph to sort\"), ' ');\r\n\r\n  for(;g.getNodeCount()&gt;0;) \r\n    for (Iterator&lt;String&gt; nodes=g.getAllNodes().iterator(); nodes.hasNext(); ) {\r\n       String nodeName = nodes.next();\r\n       if (g.inDegree(nodeName) == 0) {  //If node is a source\r\n         sorted.add(nodeName);           //Add it next in the list\r\n         g.removeNode(nodeName);         //Remove it from graph\r\n         break;                          //Restart iterator \r\n        }\r\n        if (!nodes.hasNext())       //Iterator about to finish?\r\n          throw new IllegalStateException(\"No source: must be cyclic!\");\r\n    }\r\n  System.out.println(\"Order = \" + sorted);</pre></b>\r\nIn the outer loop, we loop so long as there are nodes in the graph to process.\r\nIn the inner loop, we iterate over all the nodes;\r\n  if we find one with an in-degree of 0, we add it to the <b>sorted</b> list\r\n   and remove it (by using the iterator, both from the set of nodes and from\r\n   the graph itself, including all its in/out edges -enabling yet other nodes\r\n   to reduce their in-degree to 0).\r\nWe then must break, because removing the node will cause the iterator\r\n  to throw the <b>ConcurrentModificationException</b>.\r\nFinally, if iterating over the nodes none has in-degree 0, it means\r\n  that the graph must be cyclic; we recognize this case and\r\n  throw an exception.\r\n<p>\r\nThe complexity class of this algorithm is O(N<sup>2</sup>), since the\r\n  outer loop is executed at most N times (at most once to remove each node\r\n  from the graph) and the inner loop is executed at most N times (removing\r\n  one node for each full iteration).\r\n<p>\r\nA similar problem in the C/C++ programming languages involves compiling a\r\n  system comprising very many files, with constraints on which files must be\r\n  compiled first (this is not a problem in Java).\r\nOften programmers create \"make files\" that contain such ordering information,\r\n  specifying that one file must be compiled before another.\r\nWe can create a graph, based on the model above, and then topologically sort\r\n  it, to determine a legal order in which to compile the files.\r\n<p>\r\nIf there are multiple bakers (or multiple computers), we can modify the\r\n  topological sorting algorithm on the graph to have as many tasks being\r\n  simultaneously worked on as is allowed by the ordering constraints.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA,\r\n    or any other student.\r\n\r\n  <ol> \r\n     <li>None yet.\r\n  </ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 34637.0}