{"text": "Writing Classes and Javadoc Introduction to Computer Science I III ICS 21 22 23 Introduction We have already learned a lot about using classes from prewritten libraries and about reading their Javadoc to understand them In this lecture we will discuss the form and meaning of writing Java classes and Javadoc So we will examine the same language features that that we have already used but now from the perspective of writing classes The discussion starts by investigating methods in general We will discuss how to write static methods first and learn about the special main method in an application program and then in simple library classes such as Math and Prompt which programs can import We will learn about call frames pictures that illustrate the universal parameter passing mechanism in Java copy by value We will also learn how to write methods that throw exceptions if they are called with objects arguments that do not meet their preconditions Finally we will learn how to write more interesting classes focusing on declaring fields mostly instance variables and using them when writing constructors and methods During this process we will see how to use various features in the the Eclipse IDE edit view and debug perspective that facilitate the analyzing writing and debugging of classes Method Definitions and Parameter Initialization Let s start our discussing by examining a simple method that defines the min method inside the Math class It illustrates most interesting aspects of static method definitions Before reading this code quickly scan the EBNF for method definition public static int min int a int b if a We divide method definitions into two parts the header and the body The method header comprises the access modifiers public static return type int method name min and parameters int a int b if this method threw any exceptions they would be listed next We should be very familiar with reading method headers in Javadoc from previous lectures The method body is a block statement that immediately follows the method header In this lecture we will focus our attention on writing this block Its statements use the parameter names just like variable names in fact we often call them parameter variables to make this similarity explicit We have already discussed that when a method is called its parameter variables are always initialized by their matching arguments first Then the method body executes using these values to compute and return its result it can also use local variables declared and intialized in the block to help in its computation If we wrote the statement System out println Math min 3 5 it would display 3 If we had declared int x 3 y 8 and wrote the statement System out println Math min 3 x 5 y it would display 8 Generally We call a method by writing its name followed in parentheses by its arguments one for each parameter in the method s header As in the header where parameters are separated by commas arguments are are separated by commas as well When we call a method Java first evaluates each argument each can be a simple or complicated expression and transmits or passes it to its matching parameter this just means that Java uses each argument s value to initialize it matching parameter in the method It is equivalent to writing first parameter first argument then second parameter second argument etc Thus when calling Math max 3 x 5 y above the first parameter a is initialized by the value 14 3 x 5 the equivalent of a 3 x 5 Likewise the second parameter b is initialized by the value 8 y the equivalent of b y Then Java executes the body of the method which typically performs some computation using these initialized parameters It finally returns a result by a mechanism that we discuss in the next section The return Statement We will now discuss another Java statement the return statement whose EBNF is simply stated return is a keyword as return statement return expression As a syntax constraint Java requires that expression must be compatible with the return type specified in the method s header either be the same or be implicitily convertible In a void method or a constructor Java requires us to discard this option altogether Typically expression is a literal or a variable but sometimes it is a more general expression using operators method calls For example we will see methods that include the return statements return true return a return i divisor We use a return statement to terminate a method and specify what result if any it should return Whenever a method executes return no matter what else it is is doing i e inside loops or try catch or the method immediately terminates and returns to where the method was called its call site If the method returns a value it is as if the method call is replaced by the value that it returns as a result Ideally a method should contain just one return statement at its end In fact we can prove mathematically that there is always a way to write a method with one return statement But sometimes methods are easier to understand if they have multiple return statements Thus we will adopt a more pragmatic approach putting simplicity as the paramount aspect of the code that we write if multiple return statements make a method simpler and easier to understand use them But be able to argue why don t just use them because you are sloppy I would argue for example that the min method defined above which has two return statements is simpler than the one below which has only one return statement public static int min int a int b int answer if a Instead of one if statement this method s body is a sequence of three statements that declare a local variable decide how to initialize it and then return that value The original method just chose which of its parameters to returns without declaring any local variable I think that the original method is simpler and easier to understand In fact this method is actually defined in the Java library by using a single return of a conditional expression public static int min int a int b return a Sample Methods The following method definitions compute useful and interesting values In practice many useful methods are short like these study their headers and especially their bodies public static boolean isLeapyear int year return year 4 year 1 year 4 This method hides a very messy calculation inside a well named and easy to call method it just has one parameter the year to do the calculation on public static boolean isBetween int low int middle int high return low This method captures a common pattern that we have explored before and why low does NOT correctly compute the required value The correct way to perform this test is a bit verbose so calling this method can simplify our code public static double distance double x1 double y1 double x2 double y2 return Math sqrt x1 x2 x1 x2 y1 y2 y1 y2 This method computes the simple Euclidean distance between two points which must be specified as four parameters the X and Y coordinate of each point although a better method would use two parameters each an instance of a Point class to represent these four values Some methods have quite a few parameters see below for even more public static boolean inCircle double centerX double centerY double centerRadius double pointX double pointY return distance centerX centerY pointX pointY This method calls distance to compute whether a point whose coordinates are pointX and pointY falls within a circle whose center s coordinates are centerX and centerY and whose radius is centerRadius Note that four of the coordinate parameters to inCircle become arguments to the call of distance this role switch is common in methods calling other methods By layering methods on top of methods each is kept small but each new method accomplishes much more than the methods it calls by building on it this layer mechanism enables power programming public static int factorial int n int answer 1 for int i 2 i This method is interesting because it declares two local variables answer and i methods can declare and use local variables along with their parameters one of which is finally returned When writing methods beginners sometimes have difficulty determining when to declare parameter variables and when to declare local variables Here is where thinking about prototypes helps any information that must be communicated to the method by arguments must be stored in a parameter variable local variables help in the computation but do not need to be initialized by arguments we need n to specify the factorial we are computing but answer is always initialized to 1 and i is always initialized to 2 in the for loop Methods should have the fewest number of parameters possible if a variable can be declared locally it should be public static int forInt String message for try return Integer parseInt Prompt forString message catch NumberFormatException nfe System out println Enter an int please public static int forInt String message int low int high for int answer Prompt forInt message low high if Utility isBetween low answer high return answer System out println Entered value not in range low hight These overloaded forInt methods two different signatures are two of my favorites they are general purpose methods that we can use in many different programs In fact they are so useful that I have put these methods in the Prompt class so I can easily use them in any programs I write also one calls the other so it further illustrates the power of composing methods even the first calls two other methods Integer parseInt and Prompt forString The first forInt uses a try catch to ensure that the value entered by the user read as a String is in fact a legal int in which case it immediately returns that value if the user doesn t enter a legal value the Integer parseInt method instead throws NumberFormatException before the return can finish it is caught and processed by printing an error message and executing loop again prompting the user to enter a value The second forInt is passed three parameters which are used to coordinate prompting the user with a message to enter a value between a lower and higher bound the method rejects any entered values that are outside this range prompting the user until he she enters a value in this range By calling the previously defined forInt method this method doesn t have to worry about exceptions caused by incorrect data entry the other method handles those kinds of errors Again layering of methods very useful here Notice the sophisticated use of the return statements to terminate these method and return an answer There is no need for a break statement because by terminating the method the loop is terminated too public static int multiRoll DiceEnsemble d int times int sum for int i 1 i Finally this method rolls a DiceEnsemble object the required number of times returning the sum of all the pips seen during all the rolls So we can pass reference types as parameters to methods as easily as primitive types Here we use the generic identifier i as an index that counts the appropriate number of throws and is used nowhere else in the code we could have also written this as the countdown loop for parameter intialized times times noting that the parameter times is initialized when the method is called by its matching argument so the for loop doesn t need to initialize it In summary we can define a simply named method with the parameters needed to do the calculation and a body that hides the messy calculation Then we can debug it place it in a class and easily use it in any other software we write forgetting about all the code inside it We are always only one method name away from hiding whatever complexity a program requires By layering methods we can quickly amplify their powers Hand Simulation via Call Frames In this section we will begin to learn how to hand simulate method calls using the call frame mechanism which is mostly concerned with passing the arguments at the method call site to the parameters in the method definition We will expand upon this mechanism to show its real predictive power when we discuss passing references to objects into methods in the next section The general form of a call frame is always the same For a concrete example let s see how to write a call frame for the min method definition being called as Math min x y 1 First the parameter mechanism in Java is called copy by value With copy by value Java copies the value of each argument arguments are evaluated when a method is called at its call site into a parameter variable pictured as always a box labeled by its parameter s name and type So parameters are just special kinds of variables each is always initialized by the value of it matching argument from the call site There are no local variables here so we leave blank that part of the call frame After the call frame has been specified and the parameters have been initialized Java executes the body of the method which refers to the parameters to compute its value The result is that this method returns 5 which replaces the method call at the call site in the System out println statement so ultimately 5 is printed on the console For another example here is a call frame for the factorial method Note that after it returns to the call site the value that it returns as a result is stored into the variable y Besides its single parameter this method declares two local variables answer and i the for loop index variable which are initialized in their declarations to 1 and 2 respectively when Java executes the body of its method Note how state changes to variable are illustrated crossing out the old value and writing the new value after it Advanced Call Frames In this section we will explore call frames in a bit more detail looking closely at the difference between changing the state of a variable and changing the state of an object referred to by a variable Let s start by hand simulating a call to the following method public static void swap int a int b int temp a a b b temp Let s assume that this method is defined in a class named Utility and that we declare int x 5 y 8 and call Utility swap x y what values are ultimately stored in x and y Are these variables swapped or do they remain unchanged The call frame shows us IMPORTANT If we do not execute a return statement in a void method there is none in the code below Java automatically does the equivalent of return when it reaches the end of the block that is the body of the method Java DOES NOT allow an implicit return in a non void method becuase we MUST specify an expression that tells Java what value the method returns as its result but because void methods return nothing Java can reasonably include an implicit return at the end of the body It is important to note that although the values in the parameters a and b are exchanged by this code the values stored in the arguments x and y ARE NOT EXCHANGED The values stored in the arguments were copied to the parameters when the method was called but this transmission mechanism is ONE WAY ONLY FROM ARGUMENTS TO PARAMETERS Thus parameter transmission is asymmetrical If an argument is a variable the value stored in that variable always remains unchanged by a method call even if we change the value stored in its matching parameter The value in the box of the argument cannot be changed in a method call The situation gets a bit more complicated and interesting with references because everything is more complicated and interesting with references Recall how to copy a reference into a variable make the variable refer to the same object this describes how references are passed from arguments to parameters as well Although the value in the box of the argument cannot be changed in a method call it will still refer to the same object the state of the object that it refers to CAN BE CHANGED in the body of the method by calling mutators commands Let s look at the call frame for the multiRoll method to illustrate his behavior Assume again that this method is defined in a class named Utility and that we declare DiceEnsemble dice new DiceEnsemble 2 6 and call System out println Utility multiRoll dice 3 Java passes the argument to the parameter by copying its reference resulting in both the argument dice and the parameter d sharing the same object Then each time the multiRoll method calls d roll the state of the shared object changes see the rollCount and pips instance variables The different values returned by getPipSum 7 2 5 4 3 1 5 1 4 account for the state changes shown for the local variable sum So the first statement prints the returned value from sum 16 and the second prints the value of rollCount from the object now 3 In summary we cannot change arguments in a method call by changing the values stored in their matching parameters But if an argument and parameter share an object then we can change the state of that object by calling a mutator command method in the method Once the method returns its result the argument must refer to the same object but THAT OBJECT S STATE CAN BE CHANGED final parameters Finally here is an update to the EBNF rule for parameter It adds the option of specifying the keyword final before type parameter final type identifier If a parameter variable is declared final we must treat it like any other final variable we cannot change its state So throughout the method body it will always store the value to which it was initialized by its matching argument It is frequently but not always the case that a method examines but does not store into its parameters So most of the time we can specify that a parameter is final But most Java style standards DO NOT require specifying parameters as final even if they remain unchanged in the body of a method I m still deciding what I think is right in this case meanwhile you can choose either to include final in the code you write to emphasize that the parameter does not change or omit it whatever you choose be consistent Designing Methods When designing a method first think of a descriptive name for it then think about the other prototype information what its return type is if it is not void and what parameter types it needs in headers unlike prototypes we also should supply descriptive names for the parameters Parameter variables are used to convey special information to the method information that controls what a method computes Methods may also have declare local variables which are needed temporarily during the execution of a method but these values do not have to be initialized by arguments outside the method Finally and this is typically the easiest part write the statements that implement the method Most methods perform no input output unless that is the primary purpose of the method Notice above that except for the promptInt methods no others perform input or output In some sense methods get their inputs through their parameters they supply their output either through a returned result or by changing the state of the objects that their parameters refer to So do not write methods that perform input output unless that is their primary purpose EBNF for Defining Classes including Package and Imports Everything in Java is defined in a class simple programs as you have already written as well as library classes The EBNF for a class relies heavily on the definition of full member definition note package and class are keywords package declaration package package name class body full member definition class definition package statement import declaration access modifiers class identifier class body The braces in the last rule stand for themselves in the previous rules they stand for standard EBNF repetition Named classes in Java are defined in their own java file Let s examine the three major parts of a class definintion First the package statement Every class is defined in one package specified in the package statement if this option is omitted the class is said to be defined in the anonymous also known as default package the name of this package has no characters in it Whatever package this class is in all other classes in that package are automatically imported for use in it Second if this class must refer to any classes in other packages they must be imported explicitly in an import declarations Finally the class itself is defined it specifies its own access modifiers almost always jut public and includes any number of full member definitions Here is a trivial but complete class named Application It is defined in the anonymous package imports a neccessary class from the course library and has a main method that performs some trivial I O on the console import edu uci ics pattis introlib Prompt public class Application public static void main String args int input Prompt forInt Enter positive n System out println You entered n Typically such a class is stored in a file with the same first name as the class Application java After discussing main methods will see how to define complete classes for simple Java programs and libraries that define other methods The main Method Any Java class can define a special main method as one of its members but a method with this name is special only if it has exactly the following access modifiers and header This method specifies an array of String as its parameter although we will not use this parameter until we study how to use Java from a command line we will see below how to tell the Eclipse IDE which special main method to execute public static void main String args We can direct Java to start our program a collection of one or more classes automatically in any special main method In fact any project can include multiple classes and each class can have its own special main method this is actually quite useful and we will discuss this feature when we discuss testing classes in more detail In such a situation we must tell Java WHICH special main method to start with In Eclipse we specify the class whose main method is to be run by selecting the class either in the Package Explorer or in the Editor Methods in Applications We have seen how to declare one special static method in a class and have Java execute that method Now we will learn how to define and call other static methods in a class All we must do is place these other method definitions inside the class along with the main method Then we can call these method from main or from each other Any static method in a class can call any other static method in that same class just by using its name and supplying arguments that match its signature or if overloaded one of its signatures We can also be a bit more consistent and verbose and call a static method by prepending the class name to the method s name The following Application class shows a simple example of such code import edu uci ics pattis introlib Prompt public class Application public static int factorial int n int answer 1 for int i 2 i Date Calculator 1 program This program defines and used five static methods and twelve static fields Definition Order Java uses a multi pass compiler which means that the methods and fields in a program can be defined in any order Java first reads all the method headers and fields in the file then in reads all the bodies checking that they all use the types of these methods and fields correctly One standard way to write methods is in the natural order if the body of method b calls method a then method a is defined before method b For example we might have the following program form method a s header no method calls method b s header call to a method c s header no method calls method d s header calls to b and c main methods header calls to d and a In fact there may be many natural orders e g in this example we could also meet the natural criteria by defining method c before method b or even before method a The main method calls lots of other methods so it typically appears last in the file In the reverse natural order if the body of method a calls method a then method a is defined after method b In this case the main method calls lots of other methods so it typically appears first in the file main methods header calls to d and a method d s header calls to b and c method c s header no method calls method b s header call to a method a s header no method calls In this way the most powerful methods appear at the top we can read the details of how they work aftward Because Java uses a multi pass compiler these two orderings or any others are all legal When we discuss mutually recursive methods we will return to this topic again Now some words on divide and conquer and program complexity Up until now we have been putting all of our code in the main method some of which have been a hundred or more lines of code This practice is stopping here From now on we will be distributing complexity by writing methods and placing them in the application program or in class libraries We can write test and debug each method and each class independently Each method including main should not comprise more than one or two dozen statements when a method gets too complicated it does this and that then write a this method and a that method and have the original method call these two new methods to get its job done Another rule for keeping the complexity of each method small it to prohibit more than one loop the most complex Java statement to think about per method or allow multiple loops but not nested loops Notice how the complexity has been distibuted in the date calculator program in which each method even main contains only a small number of statements Throwing Exceptions an introduction We have already discussed how to handle thrown exceptions with try catch statements Now is an appropriate time to begin discussing the other end of exception processing how to throw them them after detecting a problem The EBNF rule for throwing an exception using the keyword throw is trivial throw statement throw expression where there is a syntax constraint that expression must refer to an object constructed from a class descended from the Throwable class We will discuss class hierarchies later for now we have seen the names of a variety of classes descended from Throwable EOFException NumberFormatException and most important for our current needs IllegalArgumentException and IllegalStateException Exceptions are represented by classes so throwing an exception requires us to construct a new instance of the class typically initializing its state by a String that describes the problem this String can be further examined and printed when the exception is caught Given that our factorial method only works for non negative integers we might modify it as follows to detect a bad argument and throw IllegalArgumentException with an appropriate message rather than just returning 1 Notice how throws IllegalArgumentException now appears in factorial s signature public static int factorial int n throws IllegalArgumentException if n throw new IllegalArgumentException factorial n n must be non negative int answer 1 for int i 2 i A simple if statement the first in the method determines whether or not the argument is bad and if so throws an exception It is common to check all the necessary preconditions on arguments at the start of a method s body grouping such code together and separating it from the code that actually performs the method s task which executes only after all the preconditions on the parameters have been checked In this example if the argument matching parameter n is a negative value Java constructs an instance of the IllegalArgumentException class initialized with an appropriate error message and throws that exception When a statement throws an exception Java abandons sequential execution and tries to locate a catch clause to handle the exception first inside the method in which it was thrown if the method itself doesn t have one Java goes back to the call site for the method which is the body of some other method and repeats this process there If by repeating this process Java eventually gets back to the special main method and if there is no matching catch clause to handle the exception Java prints the exception name the exception s message the String argument to the exceptions constructor and a trace of all the methods that were called leading up to the problem We will use throw statements as we continue to learn about writing constructors and methods in classes We will come back to the topic of throw statements and try catch statements and exception classes at least once more in the context of class hierarchies to help us further understand this complex error detection and recovery mechanism There we will learn how to write new exception classes and the difference between checked and unchecked exceptions Methods in Library Classes Although some static methods might be useful in just one application many are general enough to be used in other similar applications In Java we can easily collect these methods into a class of related methods all the source code in the same file which we can easily import and use in other programs The Math class in the standard Java library serves exactly this purpose as doe the Prompt class in the course library each collects together a group of math related or console i o related methods For example we ccould easily group together all of the static methods and fields from the date calculator program into a DateUtility class as is shown below Then we could use such a class library in any program that must deal with dates Examine the Date Calculator 2 program to see exactly how this mechanism works in a project public class DateUtility Returns whether year is a leap year public static boolean isLeapYear int year return year 4 year 1 year 4 Returns the number of days in month in year public static int daysIn int month int year throws IllegalArgumentException if year 1 throw new IllegalArgumentException daysIn year year not positive if month JANUARY month DECEMBER throw new IllegalArgumentException daysIn month month not in range 1 12 Thirty days hath September April June and November if month APRIL month JUNE month SEPTEMBER month NOVEMBER return 3 all the rest have thirty one else if month JANUARY month MARCH month MAY month JULY month AUGUST month OCTOBER month DECEMBER return 31 except February must be FEBRUARY in else see possible exception else if month FEBRUARY return 28 isLeapYear year 1 Returns the ordinal 1st 2nd 3rd etc representing month day year public static int ordinalDate int month int day int year int ordinal Scan every earlier month summing the of days in that month for int m JANUARY m month m ordinal daysIn m year and add day in the current month return ordinal day Returns a date as an American or European String e g for February 1 1954 these return 2 1 1954 and 1 2 1954 public static String americanFormat int month int day int year return month day year public static String europeanFormat int month int day int year return day month year Fields all public static final constants supplied by class These could be private for use only in this class but what the heck let programmers use them from this class with final there is nothing a programmer can do to change them public static final int JANUARY 1 public static final int FEBRUARY 2 public static final int MARCH 3 public static final int APRIL 4 public static final int MAY 5 public static final int JUNE 6 public static final int JULY 7 public static final int AUGUST 8 public static final int SEPTEMBER 9 public static final int OCTOBER 1 public static final int NOVEMBER 11 public static final int DECEMBER 12 Recall that final variables constants in Java are written as upper case identifiers If their name consists of multiple words separate them by underscores e g MAX CLASS SIZE Given the use of a library class the main method in the Application class must refer to its members by using both their class name and member name e g int ordinal DateUtility ordinalDate month day year Again observe that inside this class we refer to each member by just its name Outside the class in the Application class we must refer to each static member by its class name followed by its member name Finally note that there are no constructors for this class and likewise no instance variables We do not construct objects from this class we just use the class name directly to refer to the methods that we want to call from this class Methods Fields and the Eclipse IDE Methods are so common in programming various parts of the Eclipse IDE have been built to deal with them easily Here we will examine mechanisms in the Java and Debugger views that help us use methods in our programs The editor includes a mechanism to locate and display a method easily in a program or library class When a class is active in the editor the Outline window lists all the methods in the class We can easily view a method in the editor by clicking its name in the Outline window As the number of methods in a class grows this mechanism becomes more and more useful for quickly navigating files To the left of each method header is small shaded circle containing either a minus sign or a plus sign The minus sign means the method is fully disclosed the plus sign means the method body is non disclosed elided we see only its header Clicking the circle toggles between disclosed and elided method bodies We can also use the debugger to better understand methods and debug methods that we have written The options displayed when we are stepping through a program appear as Middle The Step Over button the arrow pointing over a bar as we have discussed executes a method as if it were a black box it does not show what happens inside a stepped over method it just executes its entire body in one fell swoop Left The Step Into button the arrow pointing down between two bars executes a method by first showing its parameters and local variables in the Variables tab Then we can step through each statement in the method and watch how it executes If we step through a return statement we will be returned to the code that called the method If the method we are stepping through calls another method we can choose to step into or step over that other call Right The Step Out button the arrow pointing up out of two bars executes all the remaining statements in the current method up to and including its return statement Note the single bar for the middle button represents an entire statement Stepping over it means ignoring the details of any methods that are called in that statement The double bars in the left and right buttons represent a block of code implementing a method We can step into a method start executing the first line of code in the methods and step out of a method finish executing the last line of code in the method When we step into a method its parameter and local variables appear in the Variables tab All its parameters will be intialized to the values of their matching arguments The name of the method will also appear underneath Thread main at in the Debug tab If it calls another method that method s name will appear above it now directly underneath Thread main whenever a method returns its name is removed from the Debug tab and control returns to the method that called it the one right below it in the Debug tab If you click any method name in the Debug tab it will show you the code that is executing in that method in the editor window and that method s parameters and local variables in the Variables tab In this way it is easy to shift focus among the methods that are currently executing The Application main method remains at the bottom of these method names in the Debug tab throughout the execution of the program In the example below we are looking at the bottom of the daysIn method note its parameters have been initialized month is 2 and year is 2 6 In fact this method has already called the isLeapYear method it is at the top of the methods so it is the one currently executing but we have refocused our attention back to the daysIn method that called it by selecting this method in the Debug tab After we select the isLeapYear method and continue single stepping we return to the ordinalDate method which shows the position it is executing in the body of the loop and all its parameters and local variables listed in the order they were declared in parameters month day and year local variables ordinal and m the loop index Practice using these three kinds of stepping using the two Date Calculator programs The time you spend becoming familiar with debugging features will pay for itself many times over during the semester debugging is hard and these tools help tremendously Defining Classes from which we Construct Objects We will now shift our focus from simple classes that have only static members towards more interesting and useful classes those from which we can construct and manipulate objects instances We will first examine why how these classes declare instance variables Although instance variables are declared to be private we wll learn that all other members in their class can manipulate them Then we will learn how to write constructors that help initialize these instance variables Finally we will build on our knowledge of methods to learn how to write methods that manipulate instance variables We will discuss multiple uses of the keyword this in the context of classes from which we construct objects Classes in Java combine elements of both state and behavior State is embodied in an object s private instance variables behavior is embodied in the class s public constructors and methods which manipulate these instance variables Programmers think about classes from three important and different viewpoints user implementor and designer When a programmer thinks about using a class he she is interested solely in its public members what constructors can be used to to build objects and what methods can be called to perform useful operations on these objects Such a programmer is interested in WHAT can be done but not HOW it is done so long as the implementation works and is efficient Reading Javadoc is the prime way to learn this information When a programmer thinks about implementing a class he she is interested first in what public members the class will supply again what programmers using the class will be able to do but in addition he she is also interested in HOW such members can be implemented Typically knowing WHAT requires reading Javadoc knowing HOW requires writing Java code that specifies what state each object will store and how its method bodies work to manipulate this state This programmer is often presented with many interesting decisions because there are many ways implement the same functionality When a programmer thinks about designing a class he she is again interested solely in what public members the class supplies This person must decide what members to include and then specify the semantics of each member so that a users understand WHAT to do with the class and b implementors understand HOW to implement it Designers do this by writing the public prototypes in a class and documenting them with Javadoc These three views are a bit of a simplification because often one person takes multiple roles even all three a programmer might need to use a a class for a specific application so he she designs a general class that will be usable for that application and hopefully others and then he she impelments the class and closing the circle he she uses it in the application Good design is hard A designer often needs lots of experience using implementing classes before he she can effective design them so others can use implement them easily In this course we will mostly take the roles of users as we have in previous lectures and implementors as we will in this one As implementors we will typically be given a design and then be required to implement it To accomplish this process we will have to indentify the state that each object stores then declare it and define the required constructors and methods Finally who tests classes We will see that classes may be tested from all three prespectives The designer tests a class by developing a test suite along with the Javadoc because the designer doesn t know anything about the implementation this is black box testing Some test suites are open ended a driver and some are closed we will learn about JUnit testing The implementor tests a class by running the designer s tests against the implementation fixing errors exposed by the testing The implementor might also develop further tests based on the actual implementation used this is white box testing The user of a class implicitly tests it in an application program if the application does not work as expected it may indicate that the class es he she is using are not correct or the user may just be using them incorrectly The situation of a non working application is interesting Whose fault is it the user of a class for using it incorrectly or the writer of a class for implementing it incorrectly We will examine this perspective at the end of the lecture when we summarize classes focusing on private members The most important thing to know about a class is that any member defined in a class can refer to any other member defined in that same class EVEN IF ITS ACCESS MODIFIER IS private So access modifiers restrict what members defined OUTSIDE a class can access they do not restrict what members defined INSIDE a class can access This rule allows a class implementor to declare instance variables private so they cannot be directly accessed by code OUTSIDE the class and still write constructors method INSIDE the class that access them in fact often accessor query methods just return the values stored in some private instance variable To illustrate all this material we will closely examine two classes and their drivers SimpleDiceEnsemble and Rational Instance Variables Let s start by looking at the implementation details for two sample classes The SimpleDiceEnsemble class must store information characterizing the ensemble number of dice and sides per die and information about its current state number of rolls pip sum whether all die show the same numer of pips It declares its instance variables as follows private int numberOfDice private int sidesPerDie private int rollCount private int pipSum private boolean allSame The Rational class is much simpler it must store only the numerator and denominator of the rational number fraction It declares its instance variables as follows private int numerator private int denominator Classes typically group the declarations of all their fields at the top or bottom although there are no rules requiring this placement Recall that Javadoc pages show fields first so declaring them at the top is reasonable Another perspective is that instance variables are private details so declaring them at the bottom out of the way is reasonable Whenever new constructs an object the first thing that it does is process all the field declarations in the class which includes reserving space for all these field and initializing them Unlike local variables ALL FIELDS ARE INITIALIZED when they are declared if we do not explicitly initialize them in their declarations then Java implicitly initializes them for the primitive types it uses for int for double false for boolean and the null character for char for all reference types it uses null meaning that they do not refer to any object In the examples above all instance variables are initialized to and false in SimpleDiceEnsemble it is as if we had explicitly written private int numberOfDice private int sidesPerDie private int rollCount private int pipSum private boolean allSame false We will soon see that constructors can and often do store more appropriate values in these variables based on the arguments that we supply to the constructor So technically when a constructor stores a value into an instance variable it is reinitialization not initialization because an initial value has already been stored there by Java when it executes its declaration Still we will speak about initializing instance variables in constructors and reinitialization if we want to be precise Constructors The main purpose of any constructor is to ensure that all the instance variables of the object being constructed are initialized correctly This is done in the body of the constructor which contains exactly the same statements that can appear inthe body of a void method For some instance variables a constructor may do nothing special it leaves them with the initial values they received when declared In other cases it initializes actually reinitializes given the discussion above instance variables using the arguments passed to the constructor s parameters the constructor often validates these arguments first throwing IllegalArgumentException if they are incorrect There are classes some quite complicated in which constructors take no arguments and reinitialize no fields In these cases the fields are initialized correctly in their declarations either explicitly or implicitly The Timer class is one example of this kind of class Its constructor looks like public Timer In fact if we fail to define any constructor for a class Java will automatically supply one that looks like this one with the appropriate class name But if we define even one constructor for a class Java will not overload the constructor s by defining this one Most classes define at least one constructor and many overload the constructor These constructors always have parameter that help reinitialize instance variables SimpleDiceEnsemble The first constructor defined in the SimpleDiceEnsemble class is public SimpleDiceEnsemble int numberOfDice int sidesPerDie throws IllegalArgumentException if numberOfDice 1 throw new IllegalArgumentException SimpleDiceEnsemble constructor Number of dice numberOfDice 1 if sidesPerDie 1 throw new IllegalArgumentException SimpleDiceEnsemble constructor Sides per die sidesPerDie 1 this numberOfDice numberOfDice this sidesPerDie sidesPerDie rollCount see declaration for implicit initializaton to pipSum and allSame indeterminate until roll It first validates the values of its two parameters if either does not make sense we must have at least one die and it must have at least one side the constructor throws an IllegalArgumentException with an appropriate message If the parameters do make sense it copies them into two of the instance variables reinitializing them The other three instance variables are not reinitialized the initial values they received when decared are correct rollCount should always start at zero and pipSum and allSame although they store zero false really represent nothing because the dice haven t been rolled yet so any values would work for these Interlude Variable Name Conflicts and Resolving them with this We must take a briefly diversion to discuss variable name conflicts and how to resolve them with the keyword this There are three kinds of variable names in Java The name of a parameter defined in the constructor method header The name of a local variable defined in the constructor method body The name of a field defined in its class The Java compiler automatically implements a syntax constraint that prohibits defining a parameter with the same name as a local variable So the compiler would detect and report an error in following code public static int returnIt int a int a 1 return a In fact Java points at the local variable declaration of a and says Variable a is already defined in this method But Java does allow instance variables to have the same names as parameters or local variables When this happens it is called a variable name conflict because when we use that common name there is a conflict as to what it means Whenever there is a variable name conflict the name by itself NEVER refers to the instance variable it ALWAYS refers to the parameter or local variable If instead we want to refer to the instance variable we must preface its name with this this is a keyword In a constructor this is a reference to the object being constructed and this numberOfDice refers to the numberOfDice instance variable defined inside the class In fact writing this numberOfDice is always a legal way to refer to the numberOfDice instance variable in the object being constructed whether or not there is a variable name conflict So in the constructor above both parameter variables have a name conflict with two of the instance variables The if statements which check numberOfDice and sidesPerDie are testing the parameter variables the statements this numberOfDice numberOfDice this sidesPerDie sidesPerDie store the values of the parameter variables which disappear when the constructor finishes executing into the instance variables which exist so long as the object they are in exists If we wrote numberOfDice numberOfDice then Java would just store the parameter s value back into the parameter variable it stores nothing into the instance variable Such a statement can cause a very hard to locate bug Another way around this whole name conflict problem is to change the parameter names e g use number and sides With no name conflicts so we can write just numberOfDice number and sidesPerDie sides But it is often the case that a well chosen name for an instance variable is replicated as a parameter name because it captures exactly the right description in such cases we must understand name conflicts and use this to resolve them To help avoid confusion some style guidelines for Java specify that every access to an instance variable should be prefixed by this to indicated explicitly it that is accessing a field I m still on the fence about this style rule Back to Discussing Constructors The second SimpleDiceEnsemble constructor has a much different form First it has no parameters second it does not throw any exceptions this information is all specified in the constructor s header We could have written this constructor as public SimpleDiceEnsemble numberOfDice 2 sidesPerDie 6 which initializes the two instance variables so that the object represents two six sided dice Note that because there are no parameter names in this constructor so there are no name conflicts therefore we can use the instance variables directly with the this prefix although we could include this prefix for stylistic reasons But Java provides an even simpler way to define this constructor even if it requires us to learn a new language feature a different context in which to use this The actual constructor appears as public SimpleDiceEnsemble this 2 6 In the constructor above this says to initialize the instance variables use another constructor from this class one taking two int arguments This is a common pattern where one general constructor with many parameters is used by one or more special constructors with fewer parameters to do the initializations Note that if we needed we could add more statements to the constuctor AFTER this one here none are needed In fact another way to handle all the initialization in this class is to declare private int numberOfDice 2 private int sidesPerDie 6 private int rollCount private int pipSum private boolean allSame The first constructor would work as before reinitializing numberOfDice and sidesPerDie using the parameters But the second constructor could be simplified to contain nothing in its body because now when the instance variables are declared they correctly represent two six sided dice Thus constructors act as middlemen they accept arguments check these values for correctness and ultimately use them to re initialize instance variables if they are correct Because instance variables are private they can be initialized only in the declaration themselves and reinitialized by a constructor defined inside the class Rational The first and most general constructor defined in the Rational class is public Rational int numerator int denominator throws IllegalArgumentException if denominator throw new IllegalArgumentException Rational Construtor denominator if numerator denominator 1 Ensure non negative denominator if a rational is negative its numerator is negative if denominator denominator denominator numerator numerator call gcd greatest commmon divisor a private static method defined in this class int common gcd numerator denominator or Rational gcd name conflict this numerator numerator common this denominator denominator common This constructor ultimately stores very special values into its two instance variables carefully checking altering its parameters before doing so First it cannot construct a rational value with a denominator or zero is if the parameter has this values it throws an exception For all other numerators and denominators it stores values according to the following rules Zero is always stored as 1 The denominator is always stored as a positive value The numerator and denominator are reduced to have no common factors So if we declare Rational x new Rational 2 4 then x refers to an object that stores 1 for the numerator and 2 for the denominator try some other examples The parameters are examined and changed as needed in all but the last two statements at the end this is used to resolve the name conflicts Note the call to the method gcd which is a static method defined in this class Any non static method can call a static method The following more special constructors create new objects by using this in the sense of using another constructor in this class to initialize the instance variables public Rational int numerator this numerator 1 public Rational this 1 In the first of these constructors we specify a only a numerator parameter and by using this construct a rational with that value over 1 in the case of a parameterless constuctor we construct a rational with the value over 1 we could also have written this Blank Final Recall that we can declare blank final local variables We can also declare blank final instance variables but we must follow and additional constraint Java allows us to declare an intance variable final and not initialize it in its declaration the definition of blank final But we must initialize this variable in EVERY constructor that we write otherwise the Java compiler will detect and report an error Of course the Java compiler will ensure that we never try to assign a second value to any final variable including final instance variables Methods Method bodies follow the same rules as constructor bodies in terms of their use of parameter variables local variables and instance variables and in terms of this variable name conflicts etc In fact when we illustrate the call frame for a non static method it will show an implicit parameter named this and we will see how this parameter gets initialized by an implicit argument when such a method is called Recall that methods are divided into two categories Mutator command methods can access and store into instance variables declared in the class they change the state of the object they are called on Accessor query methods can access instance variables declared in the class but not store into them they do not change the state of the object they are called on We cannot tell just by looking at a method header whether it defines an accessor or a mutator we must look at the method body or Javadoc Yet this is a fundamentally important piece of information about any method Often one can tell which it is by the name of the method accessor method names often begin with get Also void methods are almost always mutators if they don t return a result the only interesting thing they can do is change the state of the object they were called on Some methods like nextToken in the StringTokenizer clas act as both a mutator command and accessor query changing an object s state and returning some value SimpleDiceEnsemble The SimpleDiceEnsemble class defines the roll method to be both a mutator command and accessor query it is the only mutator in the class It is defined as follows public SimpleDiceEnsemble roll this rollCount int firstThrow this randomDie this pipSum firstThrow this allSame true for int i 2 i Here for clarity in the discussion to come I have prefaced each instance variable by this even though there are no name conflicts The roll method has no parameters it declares two local variables firstThrow and nextThrow that it uses to change the rollCount pipSum and allSame instance variables Methods often have few or no parameters because they primarily operate on the instance variables of an object The pips showing for each die are computed by the randomDie method which We will examine later Let us see how to hand simulate a call to this method by using a call frame Pay close attention to how this the implicit parameter is initialized by the implicit argument Assume that we have declared SimpleDiceEnsemble dice new SimpleDiceEnsemble 2 6 and now we execute the statement dice roll We illustrate the call of this method by the call frame below assume that we roll a 3 on the first die and a 5 on the second The implicit parameter this appears in every non static call frame roll declares no explicit parameters this is always initialized to refer to the object on which the method was called In this case the call was dice roll so dice is the implcit argument and this is initialized to refer to the same object as dice the equivalent of this dice which looks a lot like an argument initializing a parameter even though both are implicit This method then examines and changes the instance variables in this object as well as the local loop index variable i Hand simulate this code again assuming randomDie returns 3 when it is called the first time and 5 the second Note that by writing this rollCount we are explicitly showing which object is being referred to when the rollCount index variable is accessed As stated above even if we wrote just rollCount because there are no name conflicts the meaning of using this variable is exactly the same as this rollCount Notice too the call to this randomDie it means to call the randomDie method on the object that this refers to which is the same object on which roll is called Generally non static methods inside a class can call other non static methods in that same class to help them accomplish their task on an object As in the case of instance variables writing randomDie has exactly the same meaning here calling another method on the same object that roll was called on The randomDie method must be able to access the sidesPerDie instance variable to compute a random roll of a die with that many sides In the actual code for SimpleDiceEnsemble this is used only where necessary Finally the return statement returns the reference stored in this the code above does nothing with the returned result but if we had instead written System out Println dice roll getPipSum Java would have called the getPipSum method on the returned reference printing a value of 8 The SimpleDiceEnsemble class defines many accessor methods two of which are shown below public int getRollCount return rollCount public int getPipSum throws IllegalStateException if rollCount throw new IllegalStateException getPipSum dice not rolled return pipSum Accessors are often simpler than mutators The forms of many of these methods are actually quite common just returning the value stored in one of the private instance variables Note that by making the rollCount and pipSum instance variables private no code external to the class can directly examine or change these variables possibly trashing them yet such code can always determine the current values stored in these instance variables indirectly by calling their accessor query methods So accessor query methods allow any code to determine the value stored in a private instance variable without giving that code direct access to change that instance variable Note that the second method first checks that the pipSum instance variable actually stores a computed value before returning it if the dice have not yet been rolled it throws the IllegalStateException the object is not in a good state yet to call this method Rational The Rational class is immutable All its methods are accessors although many construct and return values of primitive types or references to new Rational objects the result of computing on the state s of old one s just as many String and BigInteger methods do In the Rational class I have adopted the style of always using this when accessing instance variables Two simple accessors that DO NOT construct objects are public int getNumerator return this numerator public boolean equals Rational other return this numerator other numerator this denominator other denominator The first method just returns the value stored in the private numerator instance variable but we could write just return numerator The second method returns whether or not a the object the method is called on and b the object the method is passed as a parameter are equal Given the canonical way Rational stores these objects zero as 1 denominators always positive no common factors they are equal if and only if both pairs of instance variables are equal Note that if we did not store these objects canonically then this method would not work e g comparing the rational 1 2 vs 2 4 the rational 1 vs 12 the rational 1 2 vs 1 2 Here using this adds a certain symmetry to our code but we could write just numerator other numerator and denominator other denominator Finally note that there is NOTHING SPECIAL about the parameter name other I ve known students to get superstitious about this parameter name so long as the parameter name appears identically in the code we can use any name we want We illustrate this method call by the call frame below Notice that the implicit parameter this refers to the object that a refers to the implicit argument the explicit parameter other refers to the object that the explicit argument b refers to Again there is nothing special about the parameter named other we can name this parameter anything we want If we called b equals a the references stored in the implicit and explicit parameters would be swapped This method call returns a result of false because although the numerators are the same the denominators are different Two more complicated accessors that DO construct objects are public Rational abs return new Rational Math abs this numerator this denominator public Rational add Rational other int a this numerator a c ad cb int b this denominator int c other numerator b d bd int d other denominator return new Rational a d c b b d The abs method constructs and returns a new Rational object whose state is the absolute value of the state of the object that this method was called on we know the denominator is always positive so we can use its value directly The return type of Rational means that this method returns a reference to an object that is an instance of the Rational class In the abs method we return a newly constructed Rational whose numerator is non negative all denominators are already positive The add method constructs and returns a new Rational object whose state is the sum the states of the object that this method was called on and the object passed as the explicit argument If we wrote Rational x new Rational 1 2 y new Rational 1 3 Rational z x add y We would illustrate these variable and method call by the call frame below note that for space reasons I have left out the four local variables a b c and d which store the values 1 2 1 and 3 respectively In this add method we return a newly constructed Rational whose numerator and denomiator are computed according to the standard algorithm for adding rational values Note that the code in the complicated constructor for this class will automatically reduce the results to lowest terms If we call x add y then this refers the state of the object that x refers to the object on which add is called and other refers to the state of the object that y refers to the object that is an argument to add Of course if we call y add x then this and other would refer to the opposite objects but since addition is symmetric it would return the same result Because this method returns a reference to a Rational object we can cascade our method calls If we wanted to compute the sum of the objects all three variables refer to we can write x add y add z which first creates an object containing the sum of x and y and then it adds this object to z producing an object storing the total sum We can also write x add y add z which produces the same result by adding objects in a different order Each of these classes include a toString method that returns a String catenating together all the state of the object which is used mostly for debugging purposes Such toString methods are often easy to write examine them Special Methods There are two kinds of special methods that we examine here briefly private and static Both kinds occur in classes that we will write but they do not occur frequently Private Methods First sometimes a class will define private methods Such a method is callable only from other methods defined in that class not from any methods outside the class to use Typically private methods are small helper methods they are useful for the implementor of the class but not useful or dangerous for someone outside the class like many methods they hide some details The SimpleDiceEnsemble defines the randomDie method which uses a random numuber generator to simulate throwing one die The roll method has two calls to this one one outside its loop and one inside the loop which may get executed multiple times private int randomDie return int Math round Math random sidesPerDie 5 Notice that this method uses the instance variable sidesPerDie The static method random defined in the Math class always returns a double result in the semiopen range 1 the expression transforms this value into an int between 1 and sidesPerDie with each value equally likely to occur Static Methods Second sometimes a class one with a constructor will define static methods either public or private The Rational class defines the prompt method as public static public static Rational prompt String s System out println s for try int numerator Prompt forInt Enter numerator int denominator Prompt forInt Enter denominator return new Rational numerator denominator catch Exception e System out println Illegal value entered try again Any class can call this method in its code as follows Rational x Rational prompt Enter x Recall that to use a static method outside a class we must prefix its name by the name of its class NOT A REFRENCE TO AN OBJECT OF THAT CLASS The console interaction would look like Enter x Enter numerator 1 Enter denominator 2 Why make this method static Because its sole purpose it to construct return a reference to an object If we made this method non static we would have to write something like get an object storing 1 to call prompt with Rational x new Rational store new value in x throwing away 1 that we just created x x prompt Enter x In this case we first construct an object to call the non static method on but we just throw away the original object replacing it by a reference to an object containing the user input rational Thus it is much simpler and easier to use this method if it is static The Rational class also defines the gcd method as private static private static int gcd int x int y lots of complicated code This method is called only in the first constructor to reduce to lowest terms the numerator and denominator by dividing out all common factors Because this method is defined in the Rational class we can call it as either gcd numerator denomiator or as Rational gcd numerator denomiator Note that because this method is private it cannot be called from anywhere but inside a constructor or method defined in this class Finally notice that the randomDie method cannot be static That is because it must refer to the instance variable sidesPerDie static methods can refer only their parameter variables and local variables see prompt and gcd The fact that we can call static methods without objects means that they have no guaranteed access any object s instance variables Of course we could have rewritten it as a static method if we added a parameter private static int randomDie int max return int Math round Math random max 5 and then called this method in roll as randomDie sidesPerDie but I thought the former way was simpler Static Fields There are two main uses of static fields The first and foremost is a place to declare constants using the final access modifier that other classes can use For example the DateUtility class declares final variables naming all the months The Rational class declares the constants ZERO and ONE both storing references to an object representing one of these values Recall that one can call mutator on final variables to change their states but one cannot store a new reference to a different object in a final variable Because Rational is an immutable class it contains no mutator methods the instance values stored in these objects always will remain the same The second use of static fields is more subtle we use them to store information shared by all objects in a class Normally each objects stores its own state in instance variables but static variables are stored in a special spot that all objects can access Suppose that we wanted to be able to know how many times objects were constructed from a class i e how many times new operated on a certain class We can declare private static int allocated in the class and then include the statement allocated in each constructor Now whenever an object is constructed the static variable shared by all the objects in the class is incremented Finally we could define public static int getAllocated return allocated to return its value So what would happen if we did not declare this field to be static If this information were stored in an instance variable the only other choice each object would store this value as part of its own state each time an object was constructed it would initialize this instance variable to zero and then increment it in the constructor Thus if we constructed n objects we would have n instance variables storing 1 not one static field storing n The final strangeness about static fields is that their declarations and intializations are done just once the first time Java needs to do something with a class Contrast this with instance variable declarations which are executed each time that new constructs an object Most fields in class with constructors are instance variables The ones that aren t are mostly the constants described above If you see other static fields study them careful to understand them Writing Javadoc Comments Java is the first popular programming language to come with a special program of course written in Java for documenting its classes This is important because most interesting programming involves locating a collection of useful classes and determining what constructors and methods they define and how to use them based on their syntax and semantics Having all this information stored indexed and viewable via standard web browsers with links has made a big difference in my programming efficiency We have already studied how to read web pages produced by Javadoc both for the standard Java library and classes that I have provided for this course Now we will begin to learn how to write our own Javadoc comments to document classes that we write ourselves We can run Javadoc on Java source code java files Even if we have added none of the special comments desrcribed below Javadoc still produces a skeletal web page listing all the fields constructors and methods in Summary and Detail tables Such web pages though won t have any commentary and none of the special parameter return and throws information In general we can further document our classes with comments Javadoc ignores general comments but reads and process comments written in a special form comments that start with These are called Javadoc comments Notice that a Javadoc comment is also a general comment starting with so it is also treated as whitespace by the Java compiler Here is the Javadoc commment prefacing the DiceEnsemble class View it along with the Javadoc pages it generates in the Javadoc of Course API Objects constructed from the code DiceEnsemble code class act as collections of dice The number of dice in an ensemble and the number of sides of each die can be controlled by the programmer The class models the basic operations need to roll the dice and determine the number of pips showing both for individual dice and for the entire ensemble author Richard E Pattis Javadoc copies the contents of this comment into the web page that it builds for this class it appears near the top right before the first Summary table I write such comments in the java file a special style for ease of editing each line is a sentence with sentences longer than one line indented The web browser renders this text as a nice paragraph Note that I said that Javadoc copies the contents of the message and the web browser renders the text This means that the comment can us embedded HTML markup tags these tags are copied into the web page and rendered by the browser just like normal HTML tags in text Notice the use of code DiceEnsemble code to render the name of this class in the code font in a multi paragraph description we use p to separate the paragraphs Generally use what HTML markup tags you are familiar with to format your documentation Finally note the special Javadoc markup tag author Javdoc makes special use of these tag often creating special HTML for them A typical constructor or method is documented by a Javadoc comment of the following form the comment appear in the file right before the member it documents One sentence More documentation param tag s return tag s throws tag s This section always begins with at least one sentence ended by a period other material e g More documentation can follow All information up to and including the first period appears in the Summary section it also appears in the Detail sections followed by any other material e g More documentation Again each appearance of something is a special Javadoc markup tag that Javadoc recognizes and processes by inserting special HTML markup commands to highlight the information coming after the tag We should include only those tags that are relevant a constructor method with no parameters has no param tags otherwise we use one tag per parameter A constructor or void method has no return tag otherwise we use only one tag A constructor method throwing no exceptions has no throws tags otherwise we use one tag per exception The information documented by all these tags appears in the Detail sections The words Parameters Returns and Throws are highlighted The first word after param should be the name of the parameter it automatically is rendered in the code font followed by a dash and then the rest the information we write The first word after throws should be the name of the exception it appears as a link to the class of that name followed by a dash and then the rest the information that we write Again we can embed any HTML markup tags directly in any comments processed by Javadoc it will just copy them to the web page where the browswer will interpret them Here are the Javadoc comment that precede the first constructor and the roll and getPips methods in the DiceEnsemble class Notice that the One sentence comment ends in a period while the tags don t words enclosed inside the code HTML commands are displayed in a special font I group all the parameter tags together separated by blank lines Constructs a code DiceEnsemble code object specifying the number of dice and the number of sides per die param numberOfDice specifies the number of dice in the ensemble param sidesPerDie specifies the number of sides on each and every die in the ensemble the pips showing are 1 2 3 code sidesPerDie code throws IllegalArgumentException if either parameter is less than 1 public DiceEnsemble int numberOfDice int sidesPerDie throws IllegalArgumentException Returns this code DiceEnsemble cod after rolling every die in it By using the return type DiceEnsemble instead of code void code we can cascade method calls writing expressions such as code d roll getPipSum code instead of writing roll as its own statement return the rolled dice ensemble public DiceEnsemble roll Returns the the number of pips showing on die code dieIndex code changed each time the ensemble is rolled param dieIndex specifies the index of the die whose pips are returned throws IllegalStateException if this ensemble has not been rolled throws IllegalArguementException if code dieIndex code is outside the range 1 getNumberOfDice return the the number of pips showing on die code dieIndex code public int getPips int dieIndex throws IllegalStateException IllegalArgumentException The documentation for Javadoc appears on the Sun Microsystems web site If you want to know more about Javadoc than this course covers start reading here I will partially describe two other very interesting Javadoc tags see and link Both tags are use to create links to other fields constructors or methods either on this page or any other page documenting another class The see tag collects the references and puts them in a special section the link tag embeds links in any documentation right where it appears A typical use is This method should never be called until first calling the link DiceEnsemble roll roll method to ensure the dice actually have some pips showing The first piece of information is the way to refer to some field constructor or method the second piece of information is what word the link should appear as The Javadoc web page has much more information about this interesting tag including the following general forms We can run the Javadoc program to produce Javadoc web pages from the cammand line it has many interesting options The standard way I run it is javadoc d publicdocs public java link http java sun com j2se 1 3 docs ap If you don t want to type all this information you can download the Generate Javadoc batch file which contains this command and another one to generate Javadoc from the perspective of an implememtor including all the private stuff This batch file is also available under Miscellaneous in the Online Resources web page Put this file in a folder that contains the java files that you want to run through Javadoc If you are runing under Windows double click the file named generatedocs bat and you will see a console window pop up this window shows the Javadoc utility running otherwise cut paste execute the lines from this file It creates a folder named publicdocs containing all the Javadoc comments related to public class members the ones we have been reading as class users and a folder named privatedocs containing all the Javadoc comments related to public and private class members the ones we would read as class implementors Each folder contains a file named index html which acts as the root for all the Javadoc web pages in that folder click on it to start viewing the Javadoc It can take a few seconds or so for each class that Javadoc examines and extracts into a web page For debugging purposes if your link tags contain errors twice you will be asked to press any key to continue so if there are errors you can stop and examine them instead of having them scroll by Instance Variables in the Eclipse Debugger The Eclipse debugger includes a few useful features to illustrate classes from which we construct objects All the material that we discussed previously in this lecture note about the editor and debugger concerning static methods works for non static methods as well We know that whenever a method is called the debugger displays all its its parameter variables and local variables in the Variables tab But in addition whenever a non static method is called on an object this pane also displays a special entry named this surprised it was the same in the call frames that refers to that object s instance variables so our call frames do accurately reflect the main aspect of this Suppose that we stop on the first line inside the roll method The full name of the method packageName ClassName methodName appears underneath Thread main recall that temp is the package name for this class Note that in the Variables tab this appears on a single line that is preceded by a box showing a and followed by an id number ignore the id number The box is is called a disclosure box it is currently in its non disclosing or elided state By clicking this box it toggles to it disclosing state its contents will be replaced by a and all the instance variables in the object this refers to will appear indented under this clicking this box again will return it to its non disclosing state This is the first time these two six sided dice are being rolled so the instance variables rollCount pipSum and allSame all display their initial values By watching these instance variables change while single stepping through the statements in this method we can see how this mutator command changes the state of the object When the last line of the method is reached the instance variables now display their new values Understanding how the debugger treats objects is crucial to being able to debug classes quickly Practice using these kinds of stepping and object observations using the drivers for the SimpleDiceEnsemble and Rational classes Summary and Class Invariants This has been a long lecture discussing many interesting language features and tons of technical terms It looked as classes from a new perspective that of a class implementor leveraging off all the information that we have learned previously as class users Let me try to review the most important ideas here briefly We began by studying the form and meaning of static method definitions along with the return and throw statements We learned how to hand simulate these methods in call frames and how to use them in programs in two ways directly in an application along with a main method and as definitions in a library class We examined how the Metrowerks IDE makes using methods easier in the editor and the debugger Then we discussed how to define instance variables in a class along with the related topics of how to write constructors that help initialize them and methods to manipulate them We learned that a private member can be accessed from any other members in the class it is defined in but not from members outside this class We found two interesting uses for the keyword this to specify instance variables in variable name conflicts and to help in constructors Finally we discussed writing Javadoc to document classes and their members Finally I would like to look one more time at constructors and methods as middlemen with respect to private instance variables An invariant is a statement about something that remains true while that something is manipulated if such a statement is true we say it is satisfied A class invariant is a set of statements about the instance variables of objects constructed from the class these statements must be true when an object is first constucted and they must remain true after each method is called Of course accessor queries do not change state so they can be ignored when discussing class invariants In fact many interesting class are immutable e g String BigInteger and Rational so their class invariants have to be true only after object construction The Rational class for example has three invariants Zero is stored with a numerator of zero and a denominator of one The denominator is always stored as a positive value The numerator and denominator are reduced to have no common factors The constructor carefully ensures that these are all true Various methods especially equals assume that invariants are true in order to operate correctly and sometimes efficiently The DiceEnsemble class for another example requires positive values for the number of dice and sides per die Its constructor also ensures this invariant and the only accessor roll does not change these instance variables Using private instance variables helps an implementor ensure class invariants By declaring instance variables to be private we know that the only place they can change is in the code for methods defined in that class Users of the class cannot change these variables directly and possibly make an invariant unsatisfied Imagine what would happen if we declared numerator or denominator to be public An incompetent or malicious programmer could store anything in such instance variables violating any or all of the invariants stated above Thus a class implementor prefers private instance variables and sometimes public final ones will work too so that users of the class cannot do bad things to its instances This access modfier ensures that the constructors and methods of the class have ultimate control over what state changes are made to objects Now we come to how this aids us when debugging Imagine a scenerio where the user of a class is getting bad results in an application program who is to blame the user or implementor of the class If an object s state ever doesn t satisfy its class invariants the implementor has definitely made a mistake If an object s state always satisfies its class invariants but the postcondition of a method is not satisifed then the implementor has also made a mistake All other mistakes are the result of the user of a class A well designed class is a cohesive collection of related instance variables the constructors that initialize them and the methods that manipulate them Each method performs some small well defined service Taken together these methods allow programmers to do everything needed to objects constructed from the class It is the composition of these coordinated services under control of the programmer that make well designed classes easy to reuse in many related applications So in a well designed class it is common to write many small methods the classes that we have seen are typical this is true even in more complicated classes which may have many more constructors methods and instance variables but whose method definitions are still quite small It is not a goal of ICS 21 nor 22 for that matter ICS 23 gets closer with collection classes to teach you how to design a re usable class It is a goal to teach you how to read and use classes it is also a goal for you to be able to implement write the java file for a well designed by someone else class Finally if you want to read the java source code files for any of Java s standard library classes you can find them in the src jar file in the jdk1 folder or whatever folder representes the top of your Java file system mine is C Program Files Java jdk1 Open this file with zip and you can select and examine any of the nearly 2 files it contains These files comprise industrial strength code written by excellent programmers don t expect to breeze through the code but it is remarkably readable say compared to C C libraries Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a CA or any other student Write a statement that calls any of the result returning methods maybe just display the returned result on the console and hand simulate its execution with a call frame Java allows methods to have no parameters such methods are defined and called by specifying their name followed and an empty argument list e g f Use your knowledge of the semantics of the return statement to explain what happens for the following method and its calls Don t get confused by what you think it does or want it to do follow the rules int f return 1 return 2 What is displayed by System out print 1st f f 2nd f f Write a method named characteristic which returns 1 if its parameter is true and if its parameter is false Write a method named abs which returns the absolute value of its int parameter it always returns the non negative magnitude of its parameter don t call the Math abs method Write a method named signum which returns 1 if its double parameter is negative if its parameter is zero and 1 if its parameter is positive Write a method named constrain Calling constrain 1 5 1 returns 5 because this middle value is between the first and third values Calling constrain 1 5 1 returns 1 because this middle value is smaller than the first value so the method returns the first value Calling constrain 1 15 1 returns 1 because this middle value is larger than the third value so the method returns the third value Thus this method returns the middle value but it is constrained to lie between the first and third values inclusize Write a method named forChar We could call the method as forChar Enter an Upper Case Letter A Z which always returns a char whose ASCII value is between A and Z or we could call the method as forChar Enter a Digit 9 which always returns a char whose ASCII value is between and 9 Why can t we write a simple method named makeChange which is supplied the amount of change to vend and returns the number of quarters dimes nickels and pennies needed to vend the required change How do you think we can write a method to solve such a problem Write a method named majority which returns the most frequently occuring value of its three boolean parameters no matter the values at two of three and possibly three of three will have the same value For example the call majority true false false returns false while the call majority true true true returns true Write a method named median which returns the middle value of its three arguments For example the call median 3 2 5 returns 3 because it is between 2 and 5 Assume that we declare char roman and store in it a character that is a roman numeral Write a method that returns the int equivalent of the Roman numeral I is 1 V is 5 X is 1 L is 5 C is 1 D is 5 M is 1 if it stores any other character return 1 Write a method named isPrime which returns whether or not its parameter is a prime number A prime number has only 1 and itself as divisors neither nor 1 are considered prime 2 is the smallest prime number then 3 5 7 11 etc Hint Use a for loop to check for possible divisors along with the operator Write a method named harmonic which takes one int parameter and returns a double value representing the harmonic series of that order harmonic n is defined as 1 1 2 1 3 1 n So harmonic 2 returns 1 5 and harmonic 4 returns 2 83333 Write a method named fw which returns the number of characters needed to print its integer parameter For example fw 5 returns 1 fw 5 returns 2 fw 453 returns 3 and fw 243 returns 4 Hint the number of digits in a number is related to how many times you can divide it by 1 and still have a non zero value treat negative numbers specially Write a method named block that has an int height and width parameter and a char parameter This method returns a String which when printed displays a rectangle of that the specified height and width consisting of the specified character Calling System out println block 5 2 would print Remember that catenating an escape sequence character n in a String causes a carriage return when that character is printed Suppose our program consists of the the methods main a b c d and e Also suppose main calls a b d and e a calls c b calls a c calls nothing else d calls a and e calls d and c Find two natural orders in which to write these methods in a file Find two reverse natural orders in which to write these methods in a file For all the sample methods in this lecture identify the ones in which it makes sense to throw IllegalArgumentExceptions and describe under what conditions Note that sometimes individual parameters will store reasonable values but pairs of parameters will have values that are incompatible As we saw in this lecture we can specify that a parameter variable is final For example we can rewrite factorial as public static int factorial final int n int answer 1 for int i 2 i What does final mean when added before a parameter Does the factorial method still work correctly if its parameter is specified final If it didn t would we find out at compile time or at run time Which methods in this lecture can have their parameters s declared to be final Which cannot Can any of the local variables in these methods be declared final Define a class with the following characteristics its name is Utility and it is in the cs2 package It contains two static methods both named factorial the first takes an int parameter and returns an int result the second takes a BigInteger parameter and returns a BigInteger result Important whatever classes are necessary to write the bodies of these methods successfully Explain why when defining a class we never need to write an import declaration for the Math class I predict that half the students in class will make the following mistake when they write one of their first few constructors Can you spot the mistake compare it to the correctly written constructor in this lecture What actually happens if we write this code Will Java detect report the error If so with what message If not what will Java do when it executes this code public SimpleDiceEnsemble int numberOfDice 2 int sidesPerDie 6 int rollCount If we wrote each of these like this numberOfDice would it help Explain how to simplify the following declarations and constructor I have used the style of always writing this to access instance variables private int a private int b private int c public C int a this a a this b 1 this c Examine the code for the SimpleDiceEnsemble class Assume that we decide to roll the dice automatically at the time when the ensemble is constructed to initialize them How could we modify the constructor to perform this task What changes if any could we make the method headers and bodies Assume that we want users of this class to be able to retrieve the minimum and maximum number of pips showing after each roll What extra instance variables should we declare What new methods should we write and what changes to old methods should we make Write a class named RangeTally Each instance of this class stores four fields the lower legal value the upper legal value the sum of all the int values in this range that it is has seen via the tally method and the total number of values that has seen whether they were in range or not Its constructor should initialize these fields appropriately its accessor getTally should return the sum of all values seen which were in range its accessor getCount should return a count of all of values that it has seen whether they were in range or not its mutator tally is passed an int parameter that is conditionally tallied into the sum it should change all fields as appropriate For example if we declare RangeTally t new RangeTally 1 1 and execute the statements t tally 5 t tally 8 t tally 15 and then System out println t getTally t getCount Java prints 13 3 the last value is counted but not summed because it is not in the range 1 to 1 specified in the constructor ", "_id": "http://www.ics.uci.edu/~pattis/ICS-21/lectures/writingclasses/lecture.html", "title": "writing methods", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Writing Methods</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Writing Classes and Javadoc</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  We have already learned a lot about using classes from prewritten libraries\r\n    and about reading their Javadoc to understand them.\r\n  In this lecture, we will discuss the form and meaning of writing Java\r\n     classes and Javadoc.\r\n  So, we will examine the same language features that that we have already\r\n    used, but now from the perspective of writing classes.\r\n  <p>\r\n  The discussion starts by investigating methods in general.\r\n  We will discuss how to write <b>static</b> methods first (and\r\n    learn about the special <b>main</b> method in an application program)\r\n     and then in simple library classes (such as <b>Math</b> and <b>Prompt</b>\r\n     which programs can import) .\r\n  We will learn about call frames: pictures that illustrate the universal\r\n    parameter passing mechanism in Java: copy by value.\r\n  We will also learn how to write methods that throw exceptions, if they are\r\n    called with objects/arguments that do not meet their preconditions.\r\n  <p>\r\n  Finally, we will learn how to write more interesting classes, focusing on\r\n    declaring fields (mostly instance variables) and using them when writing\r\n    constructors and methods.\r\n  During this process, we will see how to use various features in the the\r\n    Eclipse IDE (edit view and debug perspective) that facilitate the\r\n    analyzing, writing, and debugging of classes.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Method Definitions -->\r\n\r\n<a name=\"MethodDefinitions\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Method Definitions and Parameter Initialization</b></td>\r\n<td width =\"80%\">\r\n  Let's start our discussing by examining a simple method that defines the\r\n    <b>min</b> method inside the <b>Math</b> class.\r\n  It illustrates most interesting aspects of <b>static</b> method definitions.\r\n  Before reading this code, quickly scan the EBNF for\r\n    <a href=\"../usingclasses/lecture.html#MemberEBNF\">\r\n    <i>method-definition</i></a>.\r\n  <b><pre>  public static int min (int a, int b) {\r\n    if (a <= b)\r\n      return a;\r\n    else\r\n      return b;\r\n  }</pre></b>\r\n  We divide method definitions into two parts: the <b>header</b> and the\r\n    <b>body</b>.\r\n  <ul>\r\n    <li>The method header comprises the access modifiers\r\n          (<b>public static</b>), return type (<b>int</b>), method name\r\n          (<b>min</b>), and parameters (<b>int a, int b</b>); if this method\r\n          threw any exceptions, they would be listed next.\r\n        We should be very familiar with reading method headers in Javadoc from\r\n          previous lectures.\r\n    <p>\r\n    <li>The method body is a <b>block-statement</b> that immediately follows\r\n          the method header.\r\n        In this lecture we will focus our attention on writing this block.\r\n        Its statements use the parameter names just like variable names;\r\n        in fact, we often call them parameter variables to make this\r\n          similarity explicit.\r\n  </ul>\r\n  We have already discussed that when a method is called, its parameter\r\n     variables are always initialized by their matching arguments first.\r\n  Then, the method body executes, using these values to compute and return\r\n    its result; it can also use local variables, declared and intialized in\r\n    the block, to help in its computation.\r\n  <p>\r\n  If we wrote the statement\r\n    <b><pre>  System.out.println( Math.min(3,5) );</pre></b>\r\n  it would display <b>3</b>.\r\n  If we had declared <b>int x = 3, y = 8;</b> and wrote the statement\r\n    <b><pre>  System.out.println(Math.min (3*x+5,y) );</pre></b>\r\n    it would display <b>8</b>\r\n  <p>\r\n  Generally, We call a method by writing its name, followed in parentheses \r\n    by its arguments (one for each parameter in the method's header)\r\n  As in the header (where parameters are separated by commas), arguments are\r\n    are separated by commas as well.\r\n  When we call a method, Java first evaluates each argument (each can be a\r\n    simple or complicated expression) and <b>transmits</b> or <b>passes</b>\r\n    it to its matching parameter; this just means that Java uses each\r\n    argument's value to initialize it matching parameter in the method.\r\n  It is equivalent to writing\r\n    <b><i>first-parameter</i> = <i>first-argument</i></b>, then \r\n    <b><i>second-parameter</i> = <i>second-argument</i></b>, etc.\r\n  <p>\r\n  Thus, when calling <b>Math.max(3*x+5,y)</b> above, the first parameter\r\n    (<b>a</b>) is initialized by the value <b>14</b> (<b>3*x+5</b>: the\r\n    equivalent of <b>a = 3*x+5</b>).\r\n  Likewise,  the second parameter (<b>b</b>) is initialized by the value\r\n    <b>8</b> (<b>y</b>: the equivalent of <b>b = y</b>).\r\n  Then, Java executes the body of the method, which typically performs some\r\n    computation using these initialized parameters.\r\n  It finally returns a result, by a mechanism that we discuss in the next\r\n    section.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Return Statement -->\r\n\r\n<a name=\"ReturnStatement\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The return Statement</b></td>\r\n<td width =\"80%\">\r\n  We will now discuss another Java statement, the <i>return-statement</i>,\r\n    whose EBNF is simply stated (<b>return</b> is a keyword) as\r\n <p>\r\n  &nbsp &nbsp <i>return-statement</i> <= <b>return</b> [<i>expression</i>];\r\n <p>\r\n  As a syntax constraint, Java requires that <i>expression</i> must be\r\n    compatible with the <i>return-type</i> specified in the method's header\r\n   (either be the same, or be implicitily convertible).\r\n In a <b>void</b> method (or a constructor), Java requires us to discard\r\n     this option altogether.\r\n  Typically, <i>expression</i> is a literal or a variable, but sometimes it is\r\n    a more general expression using operators/method calls.\r\n  For example, we will see methods that include the return statements\r\n  <b><pre>  return true;        return a;        return i%divisor==0;</b></pre>\r\n  <p>\r\n  We use a <b>return</b> statement to terminate a method and specify what\r\n    result (if any) it should return\r\n  Whenever a method executes <b>return</b>, no matter what else it is is\r\n    doing (i.e., inside loops or <b>try-catch</b> or ...), the method\r\n    immediately terminates and returns to where the method was called (its\r\n    <b>call site</b>).\r\n  If the method returns a value, it is as if the method call is \"replaced\"\r\n    by the value that it returns as a result.\r\n  <p>\r\n  Ideally, a method should contain just one <b>return</b> statement, at its\r\n    end.\r\n  In fact, we can prove mathematically that there is always a way to write a\r\n    method with one <b>return</b> statement.\r\n  But sometimes methods are easier to understand if they have multiple\r\n    <b>return</b> statements.\r\n  <p>\r\n  Thus, we will adopt a more pragmatic approach, putting simplicity as the\r\n    paramount aspect of the code that we write: if multiple <b>return</b>\r\n    statements make a method simpler and easier to understand, use them.\r\n  But be able to argue why; don't just use them because you are sloppy.\r\n  I would argue, for example, that the <b>min</b> method defined above, which\r\n     has two <b>return</b> statements, is simpler than the one below, which\r\n     has only one <b>return</b> statement.\r\n  <b><pre>  public static int min (int a, int b) {\r\n    int answer;\r\n    if (a <= b)\r\n      answer = a;\r\n    else\r\n      answer = b;\r\n    return answer;\r\n  }</pre></b>\r\n  Instead of one <b>if</b> statement, this method's body is a sequence of \r\n    three statements that declare a local variable, decide how to initialize\r\n    it, and then return that value.\r\n  The original method just chose which of its parameters to returns, without\r\n    declaring any local variable.\r\n  I think that the original method is simpler and easier to understand.\r\n  <p>\r\n  In fact, this method is actually defined in the Java library by using\r\n    a single return of a conditional expression:\r\n  <b><pre>  public static int min (int a, int b)\r\n  {return (a <= b ? a : b);}</pre></b></td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Sample Methods -->\r\n\r\n<a name=\"SampleMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Sample Methods</b></td>\r\n<td width =\"80%\">\r\n  The following method definitions compute useful and interesting values.\r\n  In practice, many useful methods are short, like these; study their\r\n    headers and especially their bodies.\r\n  <b><pre>  public static boolean isLeapyear (int year)\r\n  {return  (year%4 == 0 && year%100 != 0) || year%400 == 0;}</pre></b>\r\n  This method hides a very messy calculation inside a well-named and easy to\r\n    call method: it just has one parameter: the year to do the calculation on.\r\n  <p>\r\n  <b><pre>  public static boolean isBetween(int low,\r\n                                  int middle,\r\n                                  int high)\r\n  {return low<=middle && middle<=high;}</pre></b>\r\n  This method captures a common pattern that we have explored before\r\n    (and why <b>low <= middle <= high</b> does NOT correctly compute the\r\n    required value).\r\n  The correct way to perform this test is a bit verbose, so calling this\r\n     method can simplify our code.\r\n  <p>\r\n  <b><pre>  public static double distance (double x1, double y1,\r\n                                 double x2, double y2)\r\n  {return Math.sqrt( (x1-x2)*(x1-x2) +  (y1-y2)*(y1-y2) );}</pre></b>\r\n  This method computes the simple Euclidean distance between two points,\r\n    which must be specified as four parameters: the X- and Y-coordinate of\r\n    each point (although a better method would use two parameters, each\r\n    an instance of a <b>Point</b> class, to represent these four values).\r\n  Some methods have quite a few parameters (see below for even more).\r\n  <p>\r\n  <b><pre>  public static boolean inCircle (double centerX, double centerY,\r\n                                  double centerRadius,\r\n                                  double pointX, double pointY)\r\n  {return distance(centerX,centerY,pointX,pointY) <= centerRadius;}</pre></b>\r\n  This method calls <b>distance</b> to compute whether a point\r\n   (whose coordinates are <b>pointX</b> and <b>pointY</b>) falls within a\r\n    circle (whose center's coordinates  are <b>centerX</b> and <b>centerY</b>,\r\n    and whose radius is <b>centerRadius</b>).\r\n  Note that four of the coordinate <b>parameters</b> to <b>inCircle</b> become\r\n    <b>arguments</b> to the call of <b>distance</b>; this role switch is common\r\n    in methods calling other methods.\r\n  By layering methods on top of methods, each is kept small, but each new \r\n    method accomplishes much more than the methods it calls, by building on it;\r\n    this layer mechanism enables power programming.\r\n  <p>\r\n  <b><pre>  public static int factorial (int n) {\r\n    int answer = 1;\r\n    for (int i=2; i<=n; i++)\r\n      answer *= i;\r\n    return answer;\r\n  }</pre></b>\r\n  This method is interesting because it declares two local variables\r\n   (<b>answer</b> and <b>i</b>; methods can declare and use local variables\r\n   along with their parameters), one of which is finally returned.\r\n  When writing methods, beginners sometimes have difficulty determining when to\r\n    declare parameter variables and when to declare local variables.\r\n  Here is where thinking about prototypes helps: any information that must be\r\n    communicated to the method by arguments must be stored in a parameter\r\n    variable; local variables help in the computation, but do not need to be\r\n    initialized by arguments: we need <b>n</b> to specify the factorial we are\r\n    computing, but <b>answer</b> is always initialized to <b>1</b>\r\n      and <b>i</b> is always initialized to <b>2</b> in the <b>for</b> loop.\r\n  Methods should have the fewest number of parameters possible; if a variable\r\n    can be declared locally, it should be.\r\n  <p>\r\n  <b><pre>  public static int forInt (String message) {\r\n    for (;;)\r\n      try {\r\n       return Integer.parseInt(Prompt.forString(message));\r\n     }\r\n     catch (NumberFormatException nfe)\r\n       {System.out.println(\"Enter an int please\");}\r\n  }\r\n\r\n  public static int forInt (String message, int low, int high) {\r\n    for (;;) {\r\n      int answer = Prompt.forInt(message + \"[\" + low + \"..\" + high + \"]\");\r\n      if ( Utility.isBetween(low, answer, high) )\r\n        return answer;\r\n      System.out.println(\"Entered value not in range [\" + \r\n                         + low + \"..\" + hight + \"]\");\r\n    }\r\n  }</pre></b>\r\n  These overloaded <b>forInt</b> methods (two different signatures) are two of\r\n      my favorites; they are general purpose methods that we can use in many\r\n      different programs.\r\n  In fact, they are so useful that I have put these methods in the\r\n     <b>Prompt</b> class, so I can easily use them in any programs I write;\r\n     also, one calls the other so it further illustrates the power of composing\r\n     methods (even the first calls two other methods: <b>Integer.parseInt</b>\r\n       and <b>Prompt.forString</b>).\r\n  <ul>\r\n    <li>The first <b>forInt</b> uses a <b>try-catch</b> to ensure that the\r\n          value entered by the user (read as a <b>String</b>) is in fact a\r\n          legal <b>int</b> (in which case it immediately returns that value);\r\n          if the user doesn't enter a legal value, the <b>Integer.parseInt</b>\r\n          method instead throws <b>NumberFormatException</b> before the\r\n          <b>return</b> can finish; it is caught and processed by printing an\r\n          error message and executing loop again, prompting the user to enter\r\n          a value.\r\n    <p>\r\n    <li>The second <b>forInt</b> is passed three parameters, which are used to\r\n          coordinate prompting the user with a message to enter a value between\r\n          a lower and higher bound; the method rejects any entered values that\r\n          are outside this range, prompting the user until he/she enters a\r\n          value in this range.\r\n        By calling the previously defined <b>forInt</b> method, this method\r\n          doesn't have to worry about exceptions caused by incorrect data\r\n          entry: the other method handles those kinds of errors.\r\n        Again, layering of methods very useful here.\r\n  </ul>\r\n  Notice the sophisticated use of the <b>return</b> statements to terminate \r\n    these method and return an answer.\r\n  There is no need for a <b>break</b> statement because by terminating the\r\n    method, the loop is terminated too.\r\n  <p>\r\n  <b><pre>  public static int multiRoll (DiceEnsemble d, int times) {\r\n    int sum = 0;\r\n    for (int i=1; i<=times; i++)\r\n      sum += d.roll().pipSum();     //cascaded method call\r\n    return sum;\r\n  }</pre></b>\r\n  Finally, this method rolls a <b>DiceEnsemble</b> object the required\r\n    number of times, returning the sum of all the pips seen during all the\r\n    rolls.\r\n  So, we can pass reference types as parameters to methods as easily as\r\n    primitive types.\r\n  Here we use the generic identifier <b>i</b> as an index that counts the\r\n    appropriate number of throws (and is used nowhere else in the code); we\r\n    could have also written this as the countdown loop<br>\r\n    &nbsp &nbsp<b>for (/*parameter intialized*/; times>0; times--) {...</b><br>\r\n    noting that the parameter <b>times</b> is initialized when the method is\r\n    called (by its matching argument), so the <b>for</b> loop doesn't need to\r\n    initialize it.\r\n  <p>\r\n  In summary, we can define a simply-named method (with the parameters needed\r\n    to do the calculation) and a body that hides the \"messy\" calculation. \r\n  Then we can debug it, place it in a class, and easily use it in any other\r\n    software we write (forgetting about all the code inside it).\r\n  We are always only one method name away from hiding whatever complexity a\r\n    program requires.\r\n  By layering methods, we can quickly amplify their powers.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Hand Simulation -->\r\n\r\n<a name=\"HandSimulation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Hand Simulation via Call Frames</b></td>\r\n<td width =\"80%\">\r\n  In this section we will begin to learn how to hand simulate method calls\r\n    using the <i>call frame</i> mechanism, which is mostly concerned with\r\n    passing the arguments at the method call site to the parameters in the\r\n     method definition.\r\n  We will expand upon this mechanism, to show its real predictive power,\r\n    when we discuss passing references to objects into methods in the next\r\n    section.\r\n  <p>\r\n  The general form of a call frame is always the same.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/callframe.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  For a concrete example, let's see how to write a call frame for the\r\n    <b>min</b> method definition, being called as <b>Math.min(x,y+1)</b>.\r\n  First, the parameter mechanism in Java is called <b>copy by value</b>.\r\n  With copy by value, Java copies the value of each argument (arguments are\r\n    evaluated when a method is called, at its call site) into a parameter\r\n    variable: pictured, as always, a box labeled  by its parameter's name\r\n    and type.\r\n  So, parameters are just special kinds of variables: each is always\r\n    initialized by the value of it matching argument from the call site.\r\n  <p> \r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/mincf.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  There are no local variables here, so we leave blank that part of the call\r\n     frame.\r\n  After the call frame has been specified, and the parameters have been \r\n    initialized, Java executes the body of the method, which refers to the\r\n     parameters to compute its value.\r\n  The result is that this method returns <b>5</b>, which replaces the method\r\n    call at the call site, in the <b>System.out.println</b> statement, so\r\n    ultimately <b>5</b> is printed on the console.\r\n  <p>\r\n  For another example, here is a call frame for the <b>factorial</b> method\r\n  Note that after it returns to the call site, the value that it returns as a\r\n     result is stored into the variable <b>y</b>.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/factcf.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Besides its single parameter, this method declares two local variables\r\n   (<b>answer</b> and <b>i</b>, the <b>for</b> loop index variable), which are\r\n    initialized in their declarations to <b>1</b> and <b>2</b> respectively\r\n    when Java executes the body of its method.\r\n  Note how state changes to variable are illustrated: crossing out the old\r\n   value and writing the new value after it.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Advanced Call Frames -->\r\n\r\n<a name=\"AdvancedCallFrames\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Advanced Call Frames</b></td>\r\n<td width =\"80%\">\r\n  In this section, we will explore call frames in a bit more detail, looking \r\n    closely at the difference between changing the state of a variable and \r\n    changing the state of an object (referred to by a variable).\r\n  Let's start by hand simulating a call to the following method\r\n  <pre><b>  public static void swap (int a, int b) {\r\n    int temp = a;\r\n    a = b;\r\n    b = temp;\r\n  }</b></pre>\r\n  Let's assume that this method is defined in a class named <b>Utility</b>\r\n    and that we declare <b>int x=5, y=8;</b> and call <b>Utility.swap(x,y);</b>\r\n    what values are ultimately stored in <b>x</b> and <b>y</b>?\r\n  Are these variables swapped, or do they remain unchanged?\r\n  The call frame shows us.\r\n  <p>\r\n  IMPORTANT: If we do not execute a <b>return;</b> statement in a <b>void</b>\r\n    method (there is none in the code below), Java automatically does the\r\n    equivalent of <b>return;</b> when it reaches the end of the block that\r\n    is the body of the method.\r\n  Java DOES NOT allow an implicit return in a non-<b>void</b> method, becuase\r\n    we MUST specify an expression that tells Java what value the method\r\n    returns as its result; but, because <b>void</b> methods return nothing,\r\n    Java can reasonably include an implicit <b>return;</b> at the end of the\r\n    body.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/swapcf.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  It is important to note that although the values in the parameters\r\n    (<b>a</b> and <b>b</b>) are exchanged by this code, the values stored in\r\n    the arguments (<b>x</b> and <b>y</b>) ARE NOT EXCHANGED.\r\n  The values stored in the arguments were copied to the parameters when the\r\n    method was called, but this transmission mechanism is ONE-WAY ONLY: FROM\r\n    ARGUMENTS TO PARAMETERS.\r\n  Thus, parameter transmission is asymmetrical.\r\n  If an argument is a variable, the value stored in that variable always\r\n    remains unchanged by a method call, even if we change the value stored in\r\n    its matching parameter.\r\n  The value in the box of the argument cannot be changed in a method call.\r\n  <p>\r\n  The situation gets a bit more complicated and interesting with references,\r\n    because everything is more complicated and interesting with references.\r\n  Recall how to copy a reference into a variable: make the variable refer to\r\n    the same object (this describes how references are passed from arguments to\r\n    parameters as well).\r\n  Although the value in the box of the argument cannot be changed in a method\r\n    call (it will still refer to the same object), the state of the object\r\n    that it refers to CAN BE CHANGED in the body of the method by calling\r\n    mutators/commands.\r\n  <p>\r\n  Let's look at the call frame for the <b>multiRoll</b> method to illustrate\r\n    his behavior.\r\n  Assume again that this method is defined in a class named <b>Utility</b> and\r\n    that we declare <b>DiceEnsemble dice = new DiceEnsemble(2,6);</b> and call \r\n    <b>System.out.println(Utility.multiRoll(dice,3));</b>\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/multithrowcf.gif\"></image>\r\n  <image src=\"images/multithrowcf2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Java passes the argument to the parameter by copying its reference, resulting\r\n    in both the argument <b>dice</b> and the parameter <b>d</b> sharing the\r\n    same object.\r\n  Then, each time the <b>multiRoll</b> method calls <b>d.roll();</b> the state\r\n    of the shared object changes (see the <b>rollCount</b> and <b>pips</b>\r\n    instance variables).\r\n  The different values returned by <b>getPipSum</b>\r\n   (<b>7=2+5</b>, <b>4=3+1</b>, <b>5=1+4</b>) account for the state changes\r\n     shown for the local variable <b>sum</b>.\r\n  So, the first statement prints the returned value from <b>sum</b>\r\n    (<b>16</b>), and the second prints the value of <b>rollCount</b> from the\r\n    object (now <b>3</b>)\r\n  <p>\r\n   In summary, we cannot change arguments in a method call by changing the\r\n     values stored in their matching parameters. \r\n   But, if an argument and parameter share an object, then we can change the\r\n     state of that object by calling a mutator/command method in the method.\r\n   Once the method returns its result, the argument must refer to the same\r\n     object, but THAT OBJECT'S STATE CAN BE CHANGED.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- final parameters -->\r\n\r\n<a name=\"final\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>final parameters</b></td>\r\n<td width =\"80%\">\r\n  Finally, here is an update to the EBNF rule for <i>parameter</i>.\r\n  It adds the option of specifying the keyword <b>final</b> before <i>type</i>.\r\n  <p>&nbsp &nbsp <i>parameter</i> <= [<b>final</b>] <i>type</i> <i>identifier</i><p>\r\n  If a parameter variable is declared <b>final</b>, we must treat it like\r\n    any other <b>final</b> variable: we cannot change its state.\r\n  So, throughout the method body it will always store the value to which it\r\n    was initialized by its matching argument.\r\n  It is frequently (but not always) the case that a method examines\r\n    but does not store into its parameters.\r\n  So, most of the time we can specify that a parameter is <b>final</b>.\r\n  But, most Java style standards DO NOT require specifying parameters as\r\n    <b>final</b>, even if  they remain unchanged in the body of a method.\r\n  I'm still deciding what I think is right in this case; meanwhile, you can\r\n    choose either to include <b>final</b> in the code you write, to emphasize\r\n    that the parameter does not change, or omit it; whatever you choose, be\r\n    consistent.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Design -->\r\n\r\n<a name=\"Design\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Designing Methods</b></td>\r\n<td width =\"80%\">\r\n  When designing a method, first think of a descriptive name for it;\r\n    then think about the other prototype information: what its return type is\r\n    (if it is not <b>void</b>) and what parameter types it needs.\r\n    (in headers, unlike prototypes, we also should supply descriptive names\r\n     for the parameters).\r\n  Parameter variables are used to convey special information to the method;\r\n    information that controls what a method computes.\r\n  Methods may also have declare local variables, which are needed temporarily\r\n    during the execution of a method; but these values do not have to be\r\n    initialized by arguments outside the method.\r\n  Finally, and this is typically the easiest part, write the statements that\r\n    implement the method.\r\n  <p>\r\n  Most methods perform no input/output (unless that is the primary purpose of\r\n    the method).\r\n  Notice above that except for the <b>promptInt</b> methods, no others\r\n    perform input or output.\r\n  In some sense, methods get their \"inputs\" through their parameters; they \r\n    supply their \"output\" either through a returned result or by changing the\r\n    state of the objects that their parameters refer to.\r\n  So, do not write methods that perform input/output unless that is their\r\n    primary purpose.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- EBNF Defining Classes-->\r\n\r\n<a name=\"EBNFDefiningClasses\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>EBNF for Defining Classes including Package and Imports</b></td>\r\n<td width =\"80%\">\r\n  Everything in Java is defined in a class: simple programs (as you have \r\n    already written), as well as library classes.\r\n  The EBNF for a class relies heavily on the definition of\r\n    <a href=\"../usingclasses/lecture.html#MemberEBNF\">\r\n    <i>full-member-definition</i></a> (note <b>package</b> and <b>class</b> are\r\n    keywords).\r\n  <p>\r\n&nbsp &nbsp <i>package-declaration</i> <= <b>package</b> <i>package-name</i>;<br>\r\n&nbsp &nbsp <i>class-body</i>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n  <= {<i>full-member-definition</i>}<p>\r\n&nbsp &nbsp <i>class-definition</i>\r\n&nbsp &nbsp &nbsp &nbsp <=&nbsp [<i>package-statement</i>]<br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp{<i>import-declaration</i>}<br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n   <i>access-modifiers</i> <b>class</b> <i>identifier</i> {<br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp\r\n   <i>class-body</i><br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp }<p>\r\n  The braces in the last rule stand for themselves (in the previous rules they\r\n    stand for standard EBNF repetition).\r\n  Named classes in Java are defined in their own <b>.java</b> file.\r\n  <p>\r\n  Let's examine the three major parts of a <i>class definintion</i>.\r\n  First, the <i>package-statement</i>.\r\n  Every class is defined in one package, specified in the\r\n     <i>package-statement</i>; if this option is omitted, the class is said to\r\n     be defined in the <b>anonymous</b> also known as <b>default</b> package\r\n    (the name of this package has no characters in it).\r\n  Whatever package this class is in, all other classes in that package are\r\n    automatically imported for use in it.\r\n  Second, if this class must refer to any classes in other packages, they must\r\n    be imported explicitly in an <i>import-declarations</i>.\r\n  Finally, the class itself is defined: it specifies its own access modifiers\r\n    (almost always jut <b>public</b>) and includes any number of\r\n    <i>full-member-definition</i>s.\r\n  <p>\r\n  Here is a trivial but complete class named <b>Application</b>.\r\n  It is defined in the anonymous package, imports a neccessary class from the\r\n    course library, and has a <b>main</b> method that performs some\r\n    trivial I/O on the console.\r\n<pre><b>  import edu.uci.ics.pattis.introlib.Prompt;\r\n\r\n  public class Application {\r\n\r\n    public static void main(String[] args) {\r\n      int input = Prompt.forInt(\"Enter positive n\");\r\n      System.out.println(\"You entered: \" + n);\r\n    }\r\n}</b></pre>\r\n  Typically, such a class is stored in a file with the same first name as\r\n     the class:  <b>Application.java</b>.\r\n  After discussing <b>main</b> methods, will see how to define complete\r\n    classes for simple Java programs and libraries that define other methods.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- main method -->\r\n\r\n<a name=\"mainMethod\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The main Method</b></td>\r\n<td width =\"80%\">\r\n  Any Java class can define a special <b>main</b> method as one of its members;\r\n     but, a method with this name is special only if it has exactly the\r\n     following access modifiers and header\r\n  (This method specifies an array of <b>String</b> as its parameter, although \r\n    we will not use this parameter until we study how to use Java from a\r\n    command line; we will see below how to tell the Eclipse IDE which\r\n    special <b>main</b> method to execute.)<p>\r\n    &nbsp &nbsp <b>public static void main(String[] args)</b><p>\r\n  <p>\r\n  We can direct Java to start our program (a collection of one or more classes)\r\n    automatically in any special <b>main</b> method.\r\n  In fact, any project can include multiple classes, and each class can\r\n    have its own special <b>main</b> method (this is actually quite useful,\r\n    and we will discuss this feature when we discuss testing classes in more\r\n    detail).\r\n  In such a situation, we must tell Java WHICH special <b>main</b> method to\r\n    start with.\r\n  <p>\r\n  In Eclipse, we specify the class whose <b>main</b> method is to be run\r\n    by selecting the class either in the <b>Package Explorer</b> or in the\r\n    Editor.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Application Methods -->\r\n\r\n<a name=\"ApplicationMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods in Applications</b></td>\r\n<td width =\"80%\">\r\n  We have seen how to declare one special <b>static</b> method in a class and\r\n    have Java execute that method.\r\n  Now we will learn how to define and call other <b>static</b> methods in a\r\n    class.\r\n  All we must do is place these other method definitions inside the \r\n    class, along with the <b>main</b> method.\r\n  Then, we can call these method from <b>main</b> or from each other.\r\n  <p>\r\n  Any <b>static</b> method in a class can call any other static method in that\r\n     same class, just by using its name and supplying arguments that match its\r\n     signature (or, if overloaded, one of its signatures).\r\n  We can also be a bit more consistent (and verbose) and call a <b>static</b>\r\n    method by prepending the class name to the method's name.\r\n  The following <b>Application</b> class shows a simple example of such code.\r\n<pre><b>  import edu.uci.ics.pattis.introlib.Prompt;\r\n\r\n  public class Application {\r\n\r\n    public static int factorial (int n) {\r\n      int answer = 1;\r\n      for (int i=2; i<=n; i++)\r\n        answer *= i;\r\n      return answer;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n      int input = Prompt.forInt(\"Enter positive n\");\r\n      System.out.println(input + \"! = \" + factorial(input));\r\n    }\r\n}</b></pre>\r\n  Here, <b>main</b> prompts the user for a value (using the <b>static</b> \r\n    <b>forInt</b> method in the imported <b>Prompt</b> class) and\r\n    then uses that value as an argument to call the <b>factorial</b> method\r\n    defined in this class.\r\n  We have always called <b>static</b> methods in the form\r\n    <b><i>ClassName</i>.<i>methodName</i></b>; and, in fact, we could write<br>\r\n    &nbsp &nbsp <b>System.out.println(n + \"! = \" + Application.factorial(input));</b><br>\r\n  But, if one method defined in a class calls another method defined in that\r\n   same class, then we can shorten the call to just the method's name.\r\n  Most programmers use this shortened form for method names.\r\n  <p>\r\n  Another way to think about this issue is to imagine that a class is like a\r\n    family: all members of the <b>Application</b> class belong to a family\r\n    with that last name.\r\n  Each defined member's name is like a first name.\r\n  Members of the same family (class) can refer to each other by their first\r\n    names only, without ambiguity.\r\n  This is why <b>main</b> can refer just to <b>factorial</b>; we do not need\r\n    to write <b>Application.factorial</b>.\r\n  But, when refering to some <b>static</b> member OUTSIDE your family (class)\r\n    you must use both its last and first name (separated, of course, by a\r\n    period).\r\n  This is why we write <b>Math.sqrt</b> and <b>Prompt.forInt</b> in \r\n     <b>main</b> methods in the <b>Application</b> class.\r\n  <p>\r\n  A more complicated and interesting example of <b>static</b> methods appears\r\n    in the\r\n    <a href=\"../../programs/datecalculator1.zip\">\r\n      Date Calculator #1</a> program.\r\n  This program defines and used five <b>static</b> methods (and twelve\r\n    <b>static</b> fields).\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Definition Order</b></td>\r\n<td width =\"80%\">\r\n  Java uses a <b>multi-pass</b> compiler, which means that the methods and\r\n    fields in a program can be defined in any order: Java first reads all\r\n    the method headers and fields in the file, then in reads all the bodies,\r\n    checking that they all use the types of these methods and fields correctly.\r\n  <p>\r\n  One standard way to write methods is in the \"natural\" order: if the body of\r\n    method <b>b</b> calls method <b>a</b>, then method <b>a</b> is defined\r\n    before method <b>b</b>.\r\n  For example, we might have the following program form\r\n  <b><pre>  method a's header\r\n  {...no method calls...}\r\n\r\n  method b's header\r\n  {...call to a...}\r\n\r\n  method c's header\r\n  {...no method calls...}\r\n\r\n  method d's header\r\n  {...calls to b and c...}\r\n\r\n  main methods' header\r\n  {...calls to d and a...}</b></pre>\r\n  <p>\r\n  In fact, there may be many natural orders: e.g., in this example we could\r\n   also meet the natural criteria by defining method <b>c</b> before\r\n    method <b>b</b> or even before method <b>a</b>.\r\n  The <b>main</b> method calls lots of other methods, so it typically appears\r\n    last in the file.\r\n  <p>\r\n  In the \"reverse natural\" order: if the body of method <b>a</b> calls method\r\n    <b>a</b>, then method  <b>a</b> is defined after method <b>b</b>.\r\n  In this case, the <b>main</b> method calls lots of other methods, so it\r\n   typically appears first in the file.\r\n  <b><pre>  main methods' header\r\n  {...calls to d and a...}\r\n\r\n  method d's header\r\n  {...calls to b and c...}\r\n\r\n  method c's header\r\n  {...no method calls...}\r\n\r\n  method b's header\r\n  {...call to a...}\r\n\r\n  method a's header\r\n  {...no method calls...}</b></pre>\r\n  In this way, the most powerful methods appear at the top; we can read the\r\n    details of how they work aftward.\r\n  Because Java uses a multi-pass compiler, these two orderings, or any others,\r\n    are all legal.\r\n  When we discuss mutually recursive methods, we will return to this topic\r\n    again.\r\n  <p>\r\n  Now, some words on divide and conquer, and program complexity.\r\n  Up until now, we have been putting all of our code in the <b>main</b> method,\r\n    some of which have been a hundred or more lines of code.\r\n  This practice is stopping here!\r\n  From now on, we will be distributing complexity by writing methods, and\r\n    placing them in the application program, or in class libraries.\r\n  We can write, test, and debug each method (and each class) independently.\r\n  <p>\r\n  Each method, including <b>main</b>, should not comprise more than one or two\r\n    dozen statements; when a method gets too complicated (it does \"this\" and\r\n    \"that\") then write a \"this\" method and a \"that\" method, and have the\r\n     original method call these two new methods to get its job done.\r\n  Another rule for keeping the complexity of each method small it to prohibit\r\n    more than one loop (the most complex Java statement to think about) per\r\n    method -or allow multiple loops, but not nested loops.\r\n  <p>\r\n  Notice how the complexity has been distibuted in the date calculator program,\r\n    in which each method, even <b>main</b> contains only a small number of \r\n    statements.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Throwing Exceptions -->\r\n\r\n<a name=\"ThrowingExceptions\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Throwing Exceptions<br>(an introduction)</b></td>\r\n<td width =\"80%\">\r\n  We have already discussed how to handle thrown exceptions with\r\n    <b>try-catch</b> statements.\r\n  Now is an appropriate time to begin discussing the other end of exception\r\n     processing: how to throw them them after detecting a problem.\r\n  The EBNF rule for throwing an exception (using the keyword <b>throw</b>) is\r\n    trivial:<p>\r\n    &nbsp &nbsp <i>throw-statement</i> <= <b>throw</b> <i>expression</i>;<p>\r\n  where there is a syntax constraint that <i>expression</i> must refer to an \r\n    object constructed from a class descended from the <b>Throwable</b> class.\r\n  We will discuss class hierarchies later; for now we have seen the names of a\r\n    variety of classes descended from <b>Throwable</b>: <b>EOFException</b>, \r\n    <b>NumberFormatException</b>, and most important for our current needs,\r\n    <b>IllegalArgumentException</b>, and <b>IllegalStateException</b>.\r\n  <p>\r\n  Exceptions are represented by classes; so, throwing an exception requires us\r\n    to construct a new instance of the class, typically initializing its state\r\n    by a <b>String</b> that describes the problem; this <b>String</b> can be\r\n    further examined and printed when the exception is caught.\r\n  <p>\r\n  Given that our <b>factorial</b> method only works for non-negative integers,\r\n    we might modify it as follows, to detect a bad argument and throw\r\n    <b>IllegalArgumentException</b> with an appropriate message (rather than\r\n    just returning <b>1</b>).\r\n  Notice how <b>throws IllegalArgumentException</b> now appears in \r\n   <b>factorial</b>'s signature.\r\n<pre><b>  public static int factorial (int n)\r\n      throws IllegalArgumentException {\r\n    if (n < 0)\r\n      throw new IllegalArgumentException\r\n        (\"factorial: n (\"+n+\") must be non-negative\");\r\n\r\n    int answer = 1;\r\n    for (int i=2; i<=n; i++)\r\n      answer *= i;\r\n    return answer;\r\n  }</b></pre>\r\n  A simple <b>if</b> statement, the first in the method, determines whether or\r\n    not the argument is bad, and if so throws an exception.\r\n  It is common to check all the necessary preconditions on arguments at the\r\n    start of a method's body, grouping such code together and separating \r\n    it from the code that actually performs the method's task (which executes\r\n    only after all the preconditions on the parameters have been checked).\r\n  In this example, if the argument matching parameter <b>n</b> is a negative\r\n    value, Java constructs an instance of the <b>IllegalArgumentException</b>\r\n    class (initialized with an appropriate error message), and throws that\r\n    exception.\r\n  <p>\r\n  When a statement throws an exception, Java abandons sequential execution and\r\n    tries to locate a <b>catch</b> clause to handle the exception, first\r\n    inside the method in which it was thrown; if the method itself doesn't have\r\n    one, Java goes back to the call site for the method (which is the body of\r\n    some other method) and repeats this process there.\r\n  If by repeating this process, Java eventually gets back to the special\r\n    <b>main</b> method, and if there is no matching <b>catch</b> clause to\r\n    handle the exception, Java prints the exception name, the exception's\r\n    message (the <b>String</b> argument to the exceptions constructor), and\r\n    a trace of all the methods that were called, leading up to the problem.\r\n  <p>\r\n  We will use <b>throw</b> statements as we continue to learn about writing\r\n    constructors and methods in classes.\r\n  We will come back to the topic of <b>throw</b> statements and\r\n    <b>try-catch</b> statements, and exception classes at least once more\r\n    (in the context of class hierarchies), to help us further understand this\r\n     complex error detection and recovery mechanism.\r\n  There we will learn how to write new exception classes and the difference\r\n    between checked and unchecked exceptions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Library Classes -->\r\n\r\n<a name=\"LibraryClasses\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods in Library Classes</b></td>\r\n<td width =\"80%\">\r\n  Although some <b>static</b> methods might be useful in just one application,\r\n    many are general enough to be used in other (similar) applications.\r\n  In Java, we can easily collect these methods into a class of related methods\r\n    (all the source code in the same file), which we can easily import and use\r\n    in other programs.\r\n  <p>\r\n  The <b>Math</b> class in the standard Java library serves exactly this\r\n    purpose, as doe the <b>Prompt</b> class in the course library: each\r\n    collects together a group of math-related or console i/o related methods.\r\n  For example, we ccould easily group together all of the <b>static</b> methods\r\n    and fields from the date calculator program into a <b>DateUtility</b>\r\n    class as is shown below.\r\n  Then, we could use such a class library in any program that must deal with\r\n    dates.\r\n  Examine the <a href=\"../../programs/datecalculator2.zip\">\r\n    Date Calculator #2</a> program to see exactly how this mechanism works in\r\n    a project.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<pre><b>public class DateUtility {\r\n\r\n  //Returns whether year is a leap year?\r\n\r\n  public static boolean isLeapYear (int year)\r\n  {return (year%4 == 0 && year%100 != 0) || year%400 == 0;}\r\n\r\n\r\n\r\n  //Returns the number of days in month (in year)\r\n\r\n  public static int daysIn (int month, int year)\r\n      throws IllegalArgumentException {\r\n    if (year < 1)\r\n      throw new IllegalArgumentException\r\n                 (\"daysIn: year (\"+year+\") not positive\");\r\n    if (month < JANUARY || month > DECEMBER)\r\n      throw new IllegalArgumentException\r\n                  (\"daysIn: month (\"+month+\") not in range [1,12]\");\r\n\t  \r\n    //Thirty days hath September, April, June and November...\r\n    if (month == APRIL     ||\r\n        month == JUNE      ||\r\n        month == SEPTEMBER ||\r\n        month == NOVEMBER)\r\n      return 30;\r\n\t    \r\n    //...all the rest have thirty one...\r\n    else if (month == JANUARY || \r\n             month == MARCH   ||\r\n             month == MAY     ||\r\n             month == JULY    ||\r\n             month == AUGUST  ||\r\n             month == OCTOBER ||\r\n             month == DECEMBER)\r\n      return 31;\r\n\t   \r\n    //...except February (must be FEBRUARY in else: see possible exception)\r\n    else /* if (month == FEBRUARY) */\r\n      return 28 + (isLeapYear(year) ? 1 : 0);\r\n  }\r\n\t\r\n\r\n\r\n  //Returns the ordinal (1st, 2nd, 3rd, etc) representing month, day, year\r\n\r\n  public static int ordinalDate (int month, int day, int year) {\r\n    int ordinal = 0;\r\n\t  \r\n    //Scan every earlier month, summing the # of days in that month...\r\n    for (int m=JANUARY;  m < month;  m++)\r\n      ordinal += daysIn(m, year);\r\n\t  \r\n    //...and add day in the current month\r\n    return ordinal + day;\r\n  }\r\n\r\n\r\n\r\n  //Returns a date as an American or European String\r\n  //e.g., for February 10, 1954 these return \"2/10/1954\" and \"10/2/1954\"\r\n\r\n  public static String americanFormat (int month, int day, int year)\r\n  {return month + \"/\" + day + \"/\" + year;}\r\n  \r\n  public static String europeanFormat (int month, int day, int year)\r\n  {return day + \"/\" + month + \"/\" + year;}\r\n  \r\n  \r\n   \r\n\r\n  //Fields: all public static final (constants supplied by class)\r\n  //These could be private, for use only in this class,\r\n  //  but what the heck, let programmers use them from this class\r\n  //  (with final, there is nothing a programmer can do to change them)\r\n\r\n  public static final int JANUARY   =  1;  \r\n  public static final int FEBRUARY  =  2;  \r\n  public static final int MARCH     =  3;  \r\n  public static final int APRIL     =  4;  \r\n  public static final int MAY       =  5;  \r\n  public static final int JUNE      =  6;  \r\n  public static final int JULY      =  7;  \r\n  public static final int AUGUST    =  8;  \r\n  public static final int SEPTEMBER =  9;  \r\n  public static final int OCTOBER   = 10;  \r\n  public static final int NOVEMBER  = 11;  \r\n  public static final int DECEMBER  = 12;  \r\n}</b></pre>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Recall that final variables (constants) in Java are written as\r\n    upper-case identifiers.\r\n  If their name consists of multiple words, separate them by underscores:\r\n     e.g., <b>MAX_CLASS_SIZE</b>.\r\n  <p>\r\n  Given the use of a library class, the <b>main</b> method in the\r\n    <b>Application</b> class must refer to its members by using both their\r\n    class name and member name: e.g., \r\n    <b>int ordinal = DateUtility.ordinalDate(month, day, year);</b>\r\n  <p>\r\n  Again, observe that inside this class, we refer to each member by just its\r\n     name.\r\n  Outside the class (in the <b>Application</b> class) we must refer to each\r\n    <b>static</b> member by its class name followed by its member name.\r\n  <p>\r\n  Finally, note that there are no constructors for this class (and likewise no\r\n    instance variables).\r\n  We do not construct objects from this class; we just use the class name\r\n    directly to refer to the methods that we want to call from this class.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Eclipse -->\r\n\r\n<a name=\"Eclipse1\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods/Fields and the Eclipse IDE</b></td>\r\n<td width =\"80%\">\r\n  Methods are so common in programming, various parts of the Eclipse IDE\r\n    have been built to deal with them easily.\r\n  Here we will examine mechanisms in the Java and Debugger views that help us\r\n    use methods in our programs.\r\n  <p>\r\n  The editor includes a mechanism to locate and display a method easily in a\r\n     program or library class.\r\n  When a class is active in the editor, the <b>Outline</b> window lists all\r\n    the methods in the class.\r\n  We can easily view a method in the editor by clicking its name in the\r\n    <b>Outline</b> window.\r\n\r\n  As the number of methods in a class grows, this mechanism becomes more\r\n    and more useful for quickly navigating files.\r\n  <p>\r\n  To the left of each method header is small shaded circle, containing either\r\n    a minus sign or a plus sign.\r\n   The minus sign means the method is fully disclosed; the plus sign means\r\n     the method body is non-disclosed/elided (we see only its header).\r\n   Clicking the circle toggles between disclosed and elided method bodies.\r\n  <p>\r\n  We can also use the debugger to better understand methods and debug methods\r\n    that we have written.\r\n  The options displayed when we are stepping through a program appear as\r\n  <p>\r\n  <image src=\"images/step.gif\"></image>\r\n  <ul>\r\n    <li>Middle: The <b>Step Over</b> button (the arrow pointing over a bar, as\r\n          we have discussed) executes a  method as if it were a black box:\r\n          it does not show what happens inside a stepped-over method, it just\r\n          executes its entire body in one fell swoop.\r\n    <li>Left: The <b>Step Into</b> button (the arrow pointing down between two\r\n          bars) executes a method by first showing its parameters and local\r\n          variables (in the <b>Variables</b> tab).\r\n        Then, we can step through each statement in the method and watch how it\r\n          executes.\r\n        If we step through a <b>return</b> statement, we will be returned to\r\n          the code that called the method.\r\n        If the method we are stepping through calls another method, we can\r\n          choose to step-into or step-over that other call.\r\n    <li>Right: The <b>Step Out</b> button (the arrow pointing up out of two\r\n          bars) executes all the remaining statements in the current method, up\r\n          to and including its <b>return</b> statement.\r\n  </ul>\r\n  Note, the single bar for the middle button represents an entire statement.\r\n  Stepping over it means ignoring the details of any methods that are called\r\n    in that statement.\r\n  The double bars in the left and right buttons represent a block of code\r\n    implementing a method.\r\n  We can step into a method (start executing the first line of code in the\r\n     methods) and step out of a method (finish executing the last line of\r\n     code in the method).\r\n  <p>\r\n  When we step into a method, its parameter and local variables appear in the\r\n    <b>Variables</b> tab.\r\n  All its parameters will be intialized to the values of their matching\r\n     arguments.\r\n  The name of the method will also appear underneath <b>Thread[main]</b> at\r\n     in the <b>Debug</b> tab.\r\n  If it calls another method, that method's name will appear above it (now\r\n    directly underneath <b>Thread[main]</b>); whenever a method returns, its\r\n    name is removed from the <b>Debug</b> tab and control returns to the\r\n    method that called it (the one right below it in the <b>Debug</b> tab).\r\n  <p>\r\n  If you click any method name in the <b>Debug</b> tab, it will show you\r\n    the code that is executing in that method (in the editor window) and that\r\n    method's parameters and local variables (in the <b>Variables</b> tab).\r\n  In this way, it is easy to shift focus among the methods that are currently\r\n    executing.\r\n  The <b>Application.main</b> method remains at the bottom of these method\r\n    names in the <b>Debug</b> tab, throughout the execution of the program.\r\n  <p>\r\n  In the example below, we are looking at the bottom of the <b>daysIn</b>\r\n    method; note its parameters have been initialized: <b>month</b> is\r\n    <b>2</b> and <b>year</b> is <b>2006</b>.\r\n  In fact, this method has already called the <b>isLeapYear</b> method (it is\r\n    at the top of the methods, so it is the one currently executing), but we\r\n    have refocused our attention back to the <b>daysIn</b> method that called\r\n    it, by selecting this method in the <b>Debug</b> tab.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/stack.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  After we select the <b>isLeapYear</b> method and continue single-stepping,\r\n    we return to the <b>ordinalDate</b> method, which shows the position it\r\n    is executing (in the body of the loop) and all its parameters and local\r\n    variables listed in the order they were declared in:\r\n    parameters <b>month</b>, <b>day</b>, and <b>year</b>; local variables\r\n     <b>ordinal</b> and <b>m</b> -the loop index.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/stack2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Practice using these three kinds of stepping using the two Date Calculator\r\n    programs.\r\n  The time you spend becoming familiar with debugging features will pay for\r\n    itself many times over during the semester: debugging is hard, and these\r\n    tools help tremendously.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Classes with Objects -->\r\n\r\n<a name=\"DefiningClasses\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Defining Classes from which we Construct Objects</b></td>\r\n<td width =\"80%\">\r\n  We will now shift our focus from simple classes that have only <b>static</b>\r\n    members towards more interesting and useful classes: those from which we\r\n    can construct and manipulate objects/instances.\r\n  We will first examine why/how these classes declare instance variables.\r\n  Although instance variables are declared to be <b>private</b>, we wll learn\r\n    that all other members in their class can manipulate them.\r\n  Then we will learn how to write constructors that help initialize these\r\n    instance variables.\r\n  Finally, we will build on our knowledge of methods to learn how to write\r\n    methods that manipulate instance variables.\r\n  We will discuss multiple uses of the keyword <b>this</b> in the context\r\n    of classes from which we construct objects\r\n  <p>\r\n  Classes in Java combine elements of both state and behavior.\r\n  State is embodied in an object's <b>private</b> instance variables;\r\n     behavior is embodied in the class's <b>public</b> constructors and\r\n     methods, which manipulate these instance variables.\r\n  Programmers think about classes from three important and different\r\n    viewpoints: user, implementor, and designer.\r\n  <ul>\r\n    <li>When a programmer thinks about using a class, he/she is interested\r\n          solely in its <b>public</b> members: what constructors can be used to\r\n          to build objects and what methods can be called to perform useful\r\n          operations on these objects.\r\n        Such a programmer is interested in WHAT can be done, but not HOW it is\r\n          done (so long as the implementation works and is efficient).\r\n        Reading Javadoc is the prime way to learn this information.\r\n    <p>\r\n    <li>When a programmer thinks about implementing a class, he/she is \r\n          interested first in what <b>public</b> members the class will supply\r\n          (again, what programmers using the class will be able to do); but in\r\n          addition, he/she is also interested in HOW such members can be\r\n          implemented.\r\n        Typically, knowing WHAT requires reading Javadoc; knowing HOW requires\r\n          writing Java code that specifies what state each object will store\r\n          and how its method bodies work to manipulate this state.\r\n        This programmer is often presented with many interesting decisions,\r\n          because there are many ways implement the same functionality.\r\n    <p>\r\n    <li>When a programmer thinks about designing a class, he/she is again\r\n          interested solely in what <b>public</b> members the class supplies.\r\n        This person must decide what members to include and then specify the\r\n          semantics of each member so that (a) users understand WHAT to do with\r\n          the class and (b) implementors understand HOW to implement it.\r\n        Designers do this by writing the <b>public</b> prototypes in a class\r\n          and documenting them with Javadoc.\r\n  </ul>\r\n  These three views are a bit of a simplification, because often one person\r\n    takes multiple roles, even all three: a programmer might need to use a\r\n    a class for a specific application, so he/she designs a general class that\r\n    will be usable for that application (and hopefully others), and then he/she\r\n    impelments the class; and closing the circle, he/she uses it in the\r\n    application.\r\n  Good design is hard.\r\n  A designer often needs lots of experience using/implementing classes before\r\n    he/she can effective design them (so others can use/implement them easily).\r\n  <p>\r\n  In this course we will mostly take the roles of users (as we have in \r\n    previous lectures) and implementors (as we will in this one).\r\n  As implementors, we will typically be given a design, and then be required\r\n    to implement it.\r\n  To accomplish this process, we will have to indentify the state that each\r\n    object stores, then declare it and define the required constructors and\r\n     methods.\r\n  <p>\r\n  Finally, who tests classes?\r\n  We will see that classes may be tested from all three prespectives.\r\n  <ul>\r\n    <li>The designer tests a class by developing a test suite along with\r\n           the Javadoc; because the designer doesn't know anything about the\r\n           implementation, this is  black-box testing.\r\n        Some test suites are open-ended (a driver) and some are closed\r\n           (we will learn about JUnit testing).\r\n    <p>\r\n    <li>The implementor tests a class by running the designer's tests against\r\n           the implementation, fixing errors exposed by the testing.\r\n        The implementor might also develop further tests based on the\r\n           actual implementation used (this is white-box testing).\r\n    <p>\r\n    <li>The user of a class implicitly tests it in an application program:\r\n          if the application does not work as expected, it may indicate that\r\n          the class(es) he/she is using are not correct (or, the user may\r\n          just be using them incorrectly).\r\n  </ul>\r\n  The situation of a non-working application is interesting.\r\n  Whose fault is it: the user of a class (for using it incorrectly) or\r\n    the writer of a class (for implementing it incorrectly)\r\n  We will examine this perspective at the end of the lecture, when we\r\n    summarize classes (focusing on <b>private</b> members).\r\n  <p>\r\n  The most important thing to know about a class is that any member defined\r\n   in a class can refer to any other member defined in that same class, EVEN IF\r\n   ITS ACCESS MODIFIER IS <b>private</b>.\r\n  So, access modifiers restrict what members defined OUTSIDE a class can\r\n    access; they do not restrict what members defined INSIDE a class can\r\n    access.\r\n  This rule allows a class implementor to declare instance variables\r\n    <b>private</b>, so they cannot be directly accessed by code OUTSIDE the\r\n    class, and still write constructors/method INSIDE the class that access\r\n    them; in fact, often accessor/query methods just return the values stored\r\n    in some <b>private</b> instance variable.\r\n  <p>\r\n  To illustrate all this material, we will closely examine two classes and\r\n    their drivers:\r\n    <a href=\"../../programs/simpledicedemo.zip\">\r\n      SimpleDiceEnsemble</a> and\r\n    <a href=\"../../programs/rationaldemo.zip\">Rational</a>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Fields -->\r\n\r\n<a name=\"Fields\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Instance Variables</b></td>\r\n<td width =\"80%\">\r\n  Let's start by looking at the implementation details for two sample classes.\r\n  The <b>SimpleDiceEnsemble</b> class must store information characterizing the\r\n    ensemble (number of dice and sides per die) and information about its\r\n    current state (number of rolls, pip sum, whether all die show the same\r\n    numer of pips).\r\n  It declares its instance variables as follows.\r\n  <b><pre>  private int     numberOfDice;\r\n  private int     sidesPerDie;\r\n  private int     rollCount;\r\n  private int     pipSum;\r\n  private boolean allSame;</pre></b>\r\n  <p>\r\n  The <b>Rational</b> class is much simpler: it must store only the numerator\r\n    and denominator of the rational number (fraction).\r\n  It declares its instance variables as follows.\r\n  <b><pre>  private int numerator;\r\n  private int denominator;</pre></b>\r\n  <p>\r\n  Classes typically group the declarations of all their fields at the top or\r\n     bottom (although there are no rules requiring this placement)\r\n  Recall that Javadoc pages show fields first, so declaring them at the top\r\n    is reasonable.\r\n  Another perspective is that instance variables are <b>private</b> details,\r\n     so declaring them at the bottom (out of the way) is reasonable.\r\n  <p>\r\n  Whenever <b>new</b> constructs an object, the first thing that it does is\r\n    process all the field declarations in the class, which includes reserving\r\n    space for all these field and initializing them.\r\n  Unlike local variables, ALL FIELDS ARE INITIALIZED when they are declared:\r\n    if we do not explicitly initialize them in their declarations, then Java\r\n    implicitly initializes them: for the primitive types, it uses <b>0</b> for\r\n     <b>int</b>, <b>0.</b> for <b>double</b>, <b>false</b> for\r\n    <b>boolean</b>, and the null character for <b>char</b>; for all reference\r\n    types  it uses <b>null</b> (meaning that they do not refer to any object).\r\n  <p>\r\n  In the examples above, all instance variables are initialized to <b>0</b>\r\n     and <b>false</b>; in <b>SimpleDiceEnsemble</b> it is as if we had \r\n     explicitly written\r\n  <b><pre>  private int     numberOfDice = 0;\r\n  private int     sidesPerDie  = 0;\r\n  private int     rollCount    = 0;\r\n  private int     pipSum       = 0;\r\n  private boolean allSame      = false;</pre></b>\r\n  We will soon see that constructors can (and often do) store more appropriate\r\n    values in these variables, based on the arguments that we supply to the\r\n    constructor.\r\n  So technically, when a constructor stores a value into an instance variable,\r\n    it is reinitialization, not initialization, because an initial value has \r\n    already been stored there by Java, when it executes its declaration.\r\n  Still, we will speak about initializing instance variables in constructors\r\n    (and reinitialization if we want to be precise).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Constructors -->\r\n\r\n<a name=\"Constructors\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n\r\n<td width =\"20%\"><b>Constructors</b></td>\r\n<td width =\"80%\">\r\n  The main purpose of any constructor is to ensure that all the instance\r\n    variables of the object being constructed are initialized correctly.\r\n  This is done in the body of the constructor, which contains exactly the\r\n   same statements that can appear inthe body of a <b>void</b> method.\r\n  <p>\r\n  For some instance variables a constructor may do nothing special: it leaves\r\n    them with the initial values they received when declared.\r\n  In other cases it initializes (actually reinitializes, given the\r\n    discussion above) instance variables using the arguments passed to the\r\n    constructor's parameters; the constructor often validates these arguments\r\n    first (throwing <b>IllegalArgumentException</b> if they are incorrect).\r\n  <p>\r\n  There are classes, some quite complicated, in which constructors take no\r\n    arguments and reinitialize no fields.\r\n  In these cases, the fields are initialized correctly in their declarations\r\n    (either explicitly or implicitly).\r\n  The <b>Timer</b> class is one example of this kind of class.\r\n  Its constructor looks like\r\n  <b><pre>  public Timer ()\r\n  {}</pre></b>\r\n  In fact, if we fail to define any constructor for a class, Java will\r\n    automatically supply one that looks like this one (with the appropriate\r\n    class name).\r\n  But, if we define even one constructor for a class, Java will not\r\n    overload the constructor(s) by defining this one.\r\n  <p>\r\n  Most classes define at least one constructor (and many overload the\r\n    constructor).\r\n  These constructors always have parameter that help reinitialize instance\r\n    variables.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>SimpleDiceEnsemble</b></td>\r\n<td width =\"80%\">\r\n  The first constructor defined in the <b>SimpleDiceEnsemble</b> class is\r\n<b><pre>  public SimpleDiceEnsemble (int numberOfDice, int sidesPerDie)\r\n      throws IllegalArgumentException {\r\n    if (numberOfDice < 1)\r\n      throw new IllegalArgumentException\r\n        (\"SimpleDiceEnsemble constructor: \" +\r\n         \"Number of dice (\"+numberOfDice+\") < 1\"); \r\n    if (sidesPerDie < 1)\r\n      throw new IllegalArgumentException\r\n        (\"SimpleDiceEnsemble constructor: \" +\r\n         \"Sides per die (\"+sidesPerDie+\") < 1\"); \r\n\r\n    this.numberOfDice = numberOfDice;\r\n    this.sidesPerDie  = sidesPerDie;\r\n    //rollCount: see declaration for implicit initializaton to 0\r\n    //pipSum and allSame indeterminate until roll\r\n  }</pre></b>\r\n  It first validates the values of its two parameters: if either does not make\r\n     sense (we must have at least one die, and it must have at least one side),\r\n     the constructor throws an <b>IllegalArgumentException</b> with an \r\n     appropriate message.\r\n  If the parameters do make sense, it copies them into two of the instance\r\n    variables (reinitializing them).\r\n  The other three instance variables are not reinitialized: the initial\r\n    values they received when decared are correct: <b>rollCount</b> should\r\n    always start at zero, and <b>pipSum</b> and <b>allSame</b>, although they\r\n    store zero/false, really represent nothing, because the dice haven't been\r\n    rolled yet (so any values would work for these).\r\n</td>\r\n</tbody>\r\n</table>\r\n<a name=\"NameConflicts\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Interlude: Variable Name Conflicts and Resolving\r\n                 them with \"this\"</b></td>\r\n<td width =\"80%\">\r\n  We must take a briefly diversion to discuss variable name conflicts and how \r\n    to resolve them with  the keyword <b>this</b>.\r\n  There are three kinds of variable names in Java.\r\n  <ol>\r\n    <li>The name of a parameter (defined in the constructor/method header)\r\n    <li>The name of a local variable (defined in the constructor/method body)\r\n    <li>The name of a field (defined in its class)\r\n  </ol>\r\n  The Java compiler automatically implements a syntax constraint that prohibits\r\n    defining a parameter with the same name as a local variable.\r\n  So, the compiler would detect and report an error in following code\r\n  <pre><b>  public static int returnIt (int a) {\r\n    int a = 1;\r\n    return a;\r\n  }</b></pre>\r\n  In fact, Java points at the local variable declaration of <b>a</b> and says,\r\n    \"Variable 'a' is already defined in this method\".\r\n  <p> \r\n  But, Java does allow instance variables to have the same names as parameters\r\n    or local variables.\r\n  When this happens, it is called a variable name conflict, because when we\r\n    use that common name, there is a conflict as to what it means.\r\n  Whenever there is a variable name conflict, the name by itself NEVER refers\r\n    to the instance variable; it ALWAYS refers to the parameter or local\r\n    variable.\r\n  If instead we want to refer to the instance variable, we must preface its\r\n   name with <b>this.</b> (<b>this</b> is a keyword).\r\n  In a constructor, <b>this</b> is a reference to the object being constructed;\r\n    and <b>this.numberOfDice</b> refers to the <b>numberOfDice</b> instance\r\n    variable defined inside the class.\r\n  In fact, writing <b>this.numberOfDice</b> is always a legal way to refer to\r\n    the <b>numberOfDice</b> instance variable in the object being constructed,\r\n    whether or not there is a variable name conflict.\r\n  <p>\r\n  So, in the constructor above, both parameter variables have a name conflict\r\n    with two of the instance variables.\r\n  The <b>if</b> statements, which check <b>numberOfDice</b> and\r\n    <b>sidesPerDie</b>, are testing the parameter variables; the statements\r\n<pre><b>  this.numberOfDice = numberOfDice;\r\n  this.sidesPerDie  = sidesPerDie;</pre></b>\r\n  store the values of the parameter variables (which disappear when the\r\n    constructor finishes executing) into the instance variables (which exist so\r\n    long as the object they are in exists).\r\n  If we wrote <b>numberOfDice = numberOfDice;</b> then Java would just store\r\n    the parameter's value back into the parameter variable: it stores nothing\r\n    into the instance variable!\r\n  Such a statement can cause a very hard to locate bug!\r\n  <p>\r\n  Another way around this whole \"name conflict\" problem is to change the\r\n    parameter names; e.g. use <b>number</b> and <b>sides</b>.\r\n  With no name conflicts, so we can write just <b>numberOfDice = number;</b>\r\n    and <b>sidesPerDie = sides</b>.\r\n  But, it is often the case that a well chosen name for an instance variable is\r\n    replicated as a parameter name, because it captures exactly the right\r\n    description; in such cases we must understand name conflicts and use\r\n    <b>this</b> to resolve them.\r\n  <p>\r\n  To help avoid confusion, some style guidelines for Java specify that every\r\n    access to an instance variable should be prefixed by <b>this.</b> to\r\n    indicated explicitly it that is accessing a field.\r\n  I'm still on the fence about this style rule.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Back to Discussing Constructors</b></td>\r\n<td width =\"80%\">\r\n  The second <b>SimpleDiceEnsemble</b> constructor has a much different form.\r\n  First, it has no parameters; second, it does not throw any exceptions\r\n   (this information is all specified in the constructor's header).\r\n  We could have written this constructor as\r\n<pre><b>  public SimpleDiceEnsemble () {\r\n    numberOfDice = 2;\r\n    sidesPerDie  = 6;\r\n  }</b></pre>\r\n  which initializes the two instance variables so that the object represents\r\n    two, six-sided dice.\r\n  Note that because there are no parameter names in this constructor, so there\r\n    are no name conflicts; therefore, we can use the instance variables\r\n    directly with the <b>this.</b> prefix (although we could include this\r\n    prefix for stylistic reasons).\r\n  <p>\r\n  But Java provides an even simpler way to define this constructor (even if \r\n    it requires us to learn a new language feature: a different context in\r\n    which to use <b>this</b>).\r\n  The actual constructor appears as\r\n  <pre><b>  public SimpleDiceEnsemble () \r\n  {this(2,6);}</b></pre>\r\n  In the constructor above <b>this</b> says \"to initialize the instance\r\n    variables, use another constructor from <b>this</b> class, one taking two\r\n    <b>int</b> arguments.\r\n  This is a common pattern, where one general constructor (with many\r\n    parameters) is used by one or more special constructors (with fewer\r\n    parameters) to do the initializations.\r\n  Note that if we needed, we could add more statements to the constuctor AFTER\r\n    this one (here, none are needed).\r\n  <p>\r\n  In fact, another way to handle all the initialization in this class is to\r\n    declare\r\n  <b><pre>  private int     numberOfDice = 2;\r\n  private int     sidesPerDie  = 6;\r\n  private int     rollCount;\r\n  private int     pipSum;\r\n  private boolean allSame;</pre></b>\r\n  The first constructor would work as before,  reinitializing\r\n    <b>numberOfDice</b> and <b>sidesPerDie</b> using the parameters.\r\n  But the second constructor could be simplified to contain nothing in its\r\n     body, because now when the instance variables are declared, they correctly\r\n     represent two, six-sided dice.\r\n  <p>\r\n  Thus, constructors act as middlemen: they accept arguments, check these\r\n    values for correctness, and ultimately use them to (re)initialize instance\r\n    variables (if they are correct).\r\n  Because instance variables are <b>private</b>, they can be initialized only\r\n    in the declaration themselves, and reinitialized by a constructor defined\r\n    inside the class.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Rational</b></td>\r\n<td width =\"80%\">\r\n  The first and most general constructor defined in the <b>Rational</b> class\r\n    is\r\n<pre><b>  public Rational (int numerator, int denominator)\r\n    throws IllegalArgumentException {\r\n    if (denominator == 0)\r\n      throw new IllegalArgumentException\r\n        (\"Rational Construtor: - denominator 0\");\r\n\r\n    if (numerator == 0)\r\n      denominator = 1;\r\n    \r\n    //Ensure non-negative denominator; if a rational is\r\n    // negative, its numerator is negative\r\n    if (denominator < 0) {\r\n      denominator = -denominator;\r\n      numerator   = -numerator;\r\n    }\r\n    \r\n    //call gcd (greatest commmon divisor)\r\n    //  a private static method defined in this class\r\n    int common = gcd(numerator,denominator);  //or ...Rational.gcd(...)\r\n    \r\n    //name conflict\r\n    this.numerator   = numerator  /common;\r\n    this.denominator = denominator/common;\r\n  }</b></pre>\r\n  This constructor ultimately stores very special values into its two\r\n    instance variables, carefully checking/altering its parameters before\r\n    doing so.\r\n  First, it cannot construct a rational value with a denominator or zero,\r\n    is if the parameter has this values, it throws an exception.\r\n  For all other numerators and denominators, it stores values according\r\n    to the following rules.\r\n  <ul>\r\n    <li>Zero is always stored as 0/1\r\n    <li>The denominator is always stored as a positive value\r\n    <li>The numerator and denominator are reduced to have no common factors\r\n  </ul>\r\n  So, if we declare <b>Rational x = new Rational(2,-4);</b> then <b>x</b>\r\n    refers to an object that stores -1 for the numerator and 2 for the\r\n    denominator (try some other examples).\r\n  The parameters are examined and changed as needed in all but the last two\r\n    statements; at the end, <b>this.</b> is used to resolve the name conflicts.\r\n  Note the call to the method <b>gcd</b>, which is a <b>static</b> method\r\n    defined in this class.\r\n  Any non-<b>static</b> method can call a <b>static</b> method.\r\n  <p>\r\n  The following more special constructors create new objects by using\r\n    <b>this</b> (in the sense of using another constructor in this class\r\n    to initialize the instance variables)\r\n<pre><b>  public Rational (int numerator)\r\n  {this(numerator, 1);}\r\n\r\n  public Rational ()\r\n  {this(0, 1);}</b></pre>\r\n  <p>\r\n  In the first of these constructors, we specify a only a numerator parameter\r\n   and by using <b>this</b> construct a rational with that value over <b>1</b>;\r\n   in the case of a parameterless constuctor, we construct a rational with the\r\n   value <b>0</b> over <b>1</b>; we could also have written <b>this(0);</b>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Blank Final</b></td>\r\n<td width =\"80%\">\r\n  Recall that we can declare \r\n    <a href=\"../morejava/lecture.html#Final\">blank final</a> local variables.\r\n  We can also declare blank final instance variables, but we must follow and\r\n    additional constraint.\r\n  Java allows us to declare an intance variable <b>final</b> and not initialize\r\n    it in its declaration (the definition of blank final)\r\n  But, we must initialize this variable in EVERY constructor that we write,\r\n    otherwise the Java compiler will detect and report an error.\r\n  Of course, the Java compiler will ensure that we never try to assign a\r\n    second value to any <b>final</b> variable, including <b>final</b> instance\r\n    variables.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Methods -->\r\n\r\n<a name=\"Methods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods</b></td>\r\n<td width =\"80%\">\r\n  Method bodies follow the same rules as constructor bodies, in terms of their\r\n    use of parameter variables, local variables, and instance variables\r\n    (and in terms of <b>this</b>, variable name conflicts, etc).\r\n  In fact, when we illustrate the call frame for a non-<b>static</b> method,\r\n    it will show an <b>implicit parameter</b> named <b>this</b> and we will see\r\n     how this parameter gets initialized by an <b>implicit argument</b> when\r\n     such a method is called.\r\n  <p>\r\n  Recall that methods are divided into two categories\r\n  <ul>\r\n    <li>Mutator/command methods can access and store into instance\r\n          variables declared in the class; they change the state of the\r\n          object they are called on.\r\n    <p>\r\n    <li>Accessor/query methods can access instance variables declared in the\r\n          class, but not store into them; they do not change the state of the\r\n          object they are called on.\r\n  </ul>\r\n  We cannot tell just by looking at a method header whether it defines an \r\n     accessor or a mutator (we must look at the method body or Javadoc).\r\n  Yet, this is a fundamentally important piece of information about any method.\r\n  <p>\r\n  Often, one can tell which it is by the name of the method: accessor method\r\n     names often begin with <b>get</b>.\r\n  Also, <b>void</b> methods are almost always mutators: if they don't return a\r\n    result, the only interesting thing they can do is change the state\r\n    of the object they were called on.\r\n  Some methods, like <b>nextToken</b> in the <b>StringTokenizer</b> clas act\r\n    as both a mutator/command and accessor/query: changing an object's state\r\n    and returning some value.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>SimpleDiceEnsemble</b></td>\r\n<td width =\"80%\">\r\n  The <b>SimpleDiceEnsemble</b> class defines the <b>roll</b> method to be\r\n    both a mutator/command and accessor/query (it is the only mutator in the\r\n    class).\r\n  It is defined as follows.\r\n<b><pre>  public SimpleDiceEnsemble roll () {\r\n    this.rollCount++;\r\n    int firstThrow = this.randomDie();\r\n    this.pipSum    = firstThrow;\r\n    this.allSame   = true;\r\n    for (int i=2; i<=this.numberOfDice; i++) {\r\n      int nextThrow =  this.randomDie();\r\n      this.pipSum += nextThrow;\r\n      this.allSame = this.allSame && (nextThrow == firstThrow);\r\n    }\r\n    return this;\r\n  }</pre></b>\r\n  Here, for clarity in the discussion to come, I have prefaced each instance\r\n    variable by <b>this.</b> (even though there are no name conflicts).\r\n  The <b>roll</b> method has no parameters; it declares two local variables\r\n    (<b>firstThrow</b> and <b>nextThrow</b>) that it uses to change the\r\n    <b>rollCount</b>, <b>pipSum</b>, and <b>allSame</b> instance variables\r\n  <p>\r\n  Methods often have few or no parameters, because they primarily operate on\r\n    the instance variables of an object.\r\n  The pips showing for each die are computed by the <b>randomDie</b> method,\r\n    which We will examine later.\r\n  <p>\r\n  Let us see how to hand simulate a call to this method by using a call frame.\r\n  Pay close attention to how <b>this</b>, the implicit parameter, is \r\n    initialized by the implicit argument.\r\n  Assume that we have declared\r\n  <b><pre>  SimpleDiceEnsemble dice = new SimpleDiceEnsemble(2,6);</pre></b>\r\n  and now we execute the statement\r\n  <b><pre>  dice.roll();</pre></b>\r\n  We illustrate the call of this method by the call frame below (assume that\r\n    we roll a <b>3</b> on the first die and a <b>5</b> on the second).\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thiscallframe.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  The implicit parameter <b>this</b> appears in every non-<b>static</b> call\r\n    frame; <b>roll</b> declares no explicit parameters.\r\n  <b>this is always initialized to refer to the object on which the\r\n    method was called.</b>\r\n  In this case, the call was <b>dice.roll()</b> so <b>dice</b> is the\r\n    implcit argument and <b>this</b> is initialized to refer to the same\r\n    object as <b>dice</b> (the equivalent of <b>this = dice</b>, which looks\r\n    a lot like an argument initializing a parameter, even though both are\r\n    implicit).\r\n  <p>\r\n  This method then examines and changes the instance variables\r\n    in this object, as well as the local loop index variable <b>i</b>. \r\n  Hand simulate this code, again assuming <b>randomDie</b>\r\n    returns <b>3</b> when it is called the first time and <b>5</b> the second.\r\n  <p>\r\n  Note that by writing <b>this.rollCount</b> we are explicitly showing which\r\n    object is being referred to when the <b>rollCount</b> index variable is\r\n    accessed.\r\n  As stated above, even if we wrote just <b>rollCount</b>, because there are\r\n    no name conflicts, the meaning of using this variable is exactly the same\r\n    as <b>this.rollCount</b>.\r\n  <p>\r\n  Notice too the call to <b>this.randomDie()</b>; it means to call the\r\n    <b>randomDie</b> method on the object that <b>this</b> refers to,\r\n    which is the same object on which <b>roll</b> is called.\r\n  Generally, non-<b>static</b> methods inside a class can call other\r\n    non-<b>static</b> methods in that same class, to help them accomplish\r\n    their task on an object.\r\n  As in the case of instance variables, writing <b>randomDie()</b> has\r\n    exactly the same meaning here: calling another method on the same object\r\n    that <b>roll</b> was called on.\r\n  The <b>randomDie</b> method must be able to access the <b>sidesPerDie</b>\r\n    instance variable to compute a random roll of a die with that many sides.\r\n  In the actual code for <b>SimpleDiceEnsemble</b>, <b>this</b> is used only\r\n    where necessary.\r\n  <p>\r\n  Finally, the <b>return</b> statement returns the reference stored in\r\n    <b>this</b>: the code above does nothing with the returned result, but\r\n    if we had instead written\r\n  <b><pre>  System.out.Println(dice.roll().getPipSum());</pre></b>\r\n    Java would have called the <b>getPipSum</b> method on the returned\r\n    reference, printing a value of <b>8</b>.\r\n  <p>\r\n  The <b>SimpleDiceEnsemble</b> class defines many accessor methods, two of\r\n   which are shown below.\r\n  <pre><b>  public int getRollCount ()\r\n  {return rollCount;}\r\n  \r\n\r\n  public int getPipSum () throws IllegalStateException {\r\n    if (rollCount == 0)\r\n      throw new IllegalStateException(\"getPipSum - dice not rolled\");\r\n\r\n    return pipSum;\r\n  }</b></pre>\r\n  Accessors are often simpler than mutators.\r\n  The forms of many of these methods are actually quite common: just\r\n    returning the value stored in one of the <b>private</b> instance variables.\r\n  Note that by making the <b>rollCount</b> and <b>pipSum</b> instance variables\r\n    <b>private</b>, no code external to the class can directly examine or\r\n     change these variables, possibly trashing them; yet such code can always\r\n     determine the current values stored in these instance variables\r\n     indirectly, by calling their accessor/query methods.\r\n  So, accessor/query methods allow any code to determine the value stored in a\r\n    <b>private</b> instance variable without giving that code direct access to\r\n    change that instance variable.\r\n  <p>\r\n  Note that the second method first checks that the <b>pipSum</b> instance\r\n    variable actually stores a computed value before returning it; if the dice\r\n    have not yet been rolled, it throws the <b>IllegalStateException</b>: the\r\n    object is not in a good state yet to call this method.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Rational</b></td>\r\n<td width =\"80%\">\r\n  The <b>Rational</b> class is immutable.\r\n  All its methods are accessors, although many construct and return values\r\n    of primitive types or  references to new <b>Rational</b> objects (the\r\n    result of computing on the state(s) of old one(s), just as many\r\n    <b>String</b> and <b>BigInteger</b> methods do).\r\n  In the <b>Rational</b> class, I have adopted the style of always using\r\n    <b>this.</b> when accessing instance variables.\r\n  Two simple accessors that DO NOT construct objects are\r\n  <pre><b>  public int getNumerator()\r\n  {return this.numerator;}\r\n\r\n\r\n  public boolean equals (Rational other)\r\n  {return this.numerator   == other.numerator && \r\n          this.denominator == other.denominator;}</b></pre>\r\n  The first method just returns the value stored in the\r\n     <b>private numerator</b> instance variable (but, we could write just\r\n     <b>return numerator;</b>).\r\n  <p>\r\n  The second method returns whether or not (a) the object the method is called\r\n    on, and (b) the object the method is passed as a parameter, are equal.\r\n  Given the canonical way <b>Rational</b> stores these objects (zero as\r\n     <b>0/1</b>; denominators always positive; no common factors), they are\r\n     equal if and only if both pairs of instance variables are equal.\r\n  Note that if we did not store these objects canonically, then this method\r\n    would not work: e.g., comparing the rational 1/2 vs 2/4; the rational 0/1\r\n     vs 0/12; the rational -1/2 vs 1/-2.\r\n  Here, using <b>this.</b> adds a certain symmetry to our code (but, we could\r\n    write just  <b>numerator == other.numerator</b> and\r\n     <b>denominator = other.denominator</b>).\r\n  <p>\r\n  Finally, note that there is NOTHING SPECIAL about the parameter name\r\n   <b>other</b> (I've known students to get superstitious about this\r\n   parameter name): so long as the parameter name appears identically in the\r\n   code, we can use any name we want.\r\n  <p>\r\n  We illustrate this method call by the call frame below.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/equals.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Notice that the implicit parameter, <b>this</b>, refers to the object that\r\n    <b>a</b> refers to: the implicit argument; the explicit parameter,\r\n    <b>other</b>, refers to the object that the explicit argument <b>b</b>\r\n    refers to. \r\n  Again, there is nothing special about the parameter named <b>other</b>; we\r\n    can name this parameter anything we want.\r\n  If we called <b>b.equals(a)</b> the references stored in the implicit and\r\n    explicit parameters would be swapped.\r\n  This method call returns a result of <b>false</b>, because although the\r\n    numerators are the same, the denominators are different.\r\n  <p>\r\n  Two more complicated accessors that DO construct objects are\r\n<pre><b>  public Rational abs()\r\n  {return new Rational(Math.abs(this.numerator),this.denominator);}\r\n\r\n\r\n  public Rational add (Rational other) { \r\n    int a = this.numerator;          //  a     c     ad + cb\r\n    int b = this.denominator;        // --- + --- = ---------\r\n    int c = other.numerator;         //  b     d        bd\r\n    int d = other.denominator;       //\r\n    \r\n    return new Rational(a*d + c*b, b*d);\r\n  }</b></pre>\r\n  The <b>abs</b> method constructs and returns a new <b>Rational</b> object,\r\n    whose state is the absolute value of the state of the object that this\r\n    method was called on; we know the <b>denominator</b> is always positive,\r\n    so we can use its value directly.\r\n  The return type of <b>Rational</b> means that this method returns a\r\n    reference to an object that is an instance of the <b>Rational</b> class.\r\n  In the <b>abs</b> method, we return a newly constructed <b>Rational</b>\r\n    whose numerator is non-negative (all denominators are already positive).\r\n  <p>\r\n  The <b>add</b> method constructs and returns a new <b>Rational</b> object,\r\n    whose state is the sum the states of the object that this\r\n    method was called on and the object passed as the explicit argument.\r\n  If we wrote\r\n    <b><pre>  Rational x = new Rational(1,2), y = new Rational(1,3);\r\n  Rational z = x.add(y);</pre></b>\r\n  We would illustrate these variable and method call by the call frame below\r\n  (note that for space reasons, I have left out the four local variables\r\n   <b>a</b>, <b>b</b>, <b>c</b>, and <b>d</b>, which store the values\r\n   <b>1</b>, <b>2</b>, <b>1</b>, and <b>3</b> respectively).\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/add.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  In this <b>add</b> method, we return a newly constructed <b>Rational</b>\r\n    whose numerator and denomiator are computed according to the standard\r\n    algorithm for adding rational values.\r\n  Note that the code in the complicated constructor for this class will\r\n    automatically reduce the results to lowest terms.\r\n  If we call <b>x.add(y)</b> then <b>this</b> refers the state of the object\r\n    that <b>x</b> refers to: the object on which <b>add</b> is called; and\r\n    <b>other</b> refers to the state of the object that <b>y</b> refers to:\r\n    the object that is an argument to <b>add</b>\r\n  Of course, if we call <b>y.add(x)</b> then <b>this</b> and <b>other</b>\r\n    would refer to the opposite objects (but since addition is symmetric, it\r\n    would return the same result).\r\n  <p>\r\n  Because this method returns a reference to a <b>Rational</b> object, we can\r\n    cascade our method calls. If we wanted to compute the sum of the objects\r\n    all three variables refer to, we can write\r\n  <b>x.add(y).add(z)</b> which first creates an object containing the sum\r\n   of <b>x</b> and <b>y</b>, and then it adds this object to <b>z</b>,\r\n   producing an object storing the total sum.\r\n  We can also write <b>x.add(y.add(z))</b>, which produces the same result\r\n    by adding objects in a different order.\r\n  <p>\r\n  Each of these classes include a <b>toString</b> method that returns a\r\n    <b>String</b> catenating together all the state of the object (which is\r\n    used mostly for debugging purposes).\r\n  Such <b>toString</b> methods are often easy to write; examine them.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Private & Static Methods -->\r\n\r\n<a name=\"SpecialMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Special Methods</b></td>\r\n<td width =\"80%\">\r\n  There are two kinds of special methods that we examine here briefly: \r\n    <b>private</b> and <b>static</b>.\r\n  Both kinds occur in classes that we will write, but they do not occur\r\n    frequently.\r\n</td>\r\n</tbody>\r\n</table>\r\n<a name=\"PrivateMethods\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Private Methods</b></td>\r\n<td width =\"80%\">\r\n  First, sometimes a class will define <b>private</b> methods.\r\n  Such a method is callable only from other methods defined in that class,\r\n    not from any methods outside the class to use.\r\n  Typically, <b>private</b> methods are small helper methods; they are useful\r\n    for the implementor of the class, but not useful (or dangerous) for someone\r\n    outside the class; like many methods, they hide some details.\r\n  The <b>SimpleDiceEnsemble</b> defines the <b>randomDie()</b> method, which\r\n    uses a random numuber generator to simulate throwing one die.\r\n  The <b>roll</b> method has two calls to this one: one outside its loop and\r\n    one inside the loop (which may get executed multiple times).\r\n<pre><b>  private int randomDie ()\r\n  {return (int)Math.round(Math.random()*sidesPerDie + .5);}</pre></b>\r\n  Notice that this method uses the instance variable <b>sidesPerDie</b>.\r\n  The <b>static</b> method <b>random</b> defined in the <b>Math</b> class \r\n   always returns a <b>double</b> result in the semiopen range <b>[0,1)</b>; \r\n   the expression transforms this value into an <b>int</b> between <b>1</b> and\r\n   <b>sidesPerDie</b>, with each value equally likely to occur.\r\n</td>\r\n</tbody>\r\n</table>\r\n<a name=\"StaticMethods\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Static Methods</b></td>\r\n<td width =\"80%\">\r\n  Second, sometimes a class (one with a constructor) will define <b>static</b>\r\n    methods, either <b>public</b> or <b>private</b>.\r\n  The <b>Rational</b> class defines the <b>prompt</b> method as\r\n    <b>public static</b>.\r\n<pre><b>  public static Rational prompt(String s) {\r\n    System.out.println(s);\r\n    for (;;)\r\n      try{\r\n        int numerator   = Prompt.forInt(\"  Enter numerator  \");\r\n        int denominator = Prompt.forInt(\"  Enter denominator\");\r\n        return new Rational(numerator,denominator);\r\n      }catch (Exception e)\r\n        {System.out.println(\"Illegal value entered; try again\");}\r\n  }</pre></b>\r\n  Any class can call this method in its code as follows.\r\n    <pre><b>  Rational x = Rational.prompt(\"Enter x\");</b></pre>\r\n  Recall that to use a <b>static</b> method outside a class, we must\r\n    prefix its name by the name of its class NOT A REFRENCE TO AN OBJECT\r\n    OF THAT CLASS.\r\n  The console interaction would look like\r\n  <pre><b>  Enter x\r\n    Enter numerator  : 1\r\n    Enter denominator: 2</b></pre>\r\n  <p>\r\n  Why make this method <b>static</b>?\r\n  Because its sole purpose it to construct/return a reference to an object.\r\n  If we made this method non-<b>static</b>, we would have to write something\r\n    like\r\n  <pre><b>  //get an object (storing 0/1) to call prompt with\r\n  Rational x = new Rational();\r\n \r\n  //store new value in x, throwing away 0/1 that we just created.\r\n  x = x.prompt(\"Enter x\");</b></pre>\r\n  In this case, we first construct an object to call the non-<b>static</b>\r\n    method on, but we just throw away the original object, replacing it by a\r\n    reference to an object containing the user-input rational.\r\n  Thus, it is much simpler and easier to use this method if it is \r\n     <b>static</b>.\r\n  <p>\r\n  The <b>Rational</b> class also defines the <b>gcd</b> method as\r\n    <b>private static</b>.\r\n<b><pre>  private static int gcd (int x, int y) {\r\n    ...lots of complicated code\r\n  }</b></pre>\r\n  This method is called only in the first constructor, to reduce to lowest\r\n    terms the numerator and denominator (by dividing-out all common factors).\r\n  Because this method is defined in the <b>Rational</b> class, we can call it\r\n   as either <b>gcd(numerator,denomiator)</b> or as\r\n    <b>Rational.gcd(numerator,denomiator)</b>.\r\n  Note that because this method is <b>private</b>, it cannot be called\r\n    from anywhere but inside a constructor or method defined in this class.\r\n  <p>\r\n  Finally, notice that the <b>randomDie</b> method cannot be <b>static</b>.\r\n  That is because it must refer to the instance variable <b>sidesPerDie</b>;\r\n    <b>static</b> methods can refer only their parameter variables and local\r\n     variables (see <b>prompt</b> and <b>gcd</b>).\r\n  The fact that we can call <b>static</b> methods without objects means\r\n    that they have no guaranteed access any object's instance variables.\r\n  Of course, we could have rewritten it as a <b>static</b> method if we added\r\n    a parameter:\r\n<pre><b>  private static int randomDie (int max)\r\n  {return (int)Math.round(Math.random()*max + .5);}</pre></b>\r\n  and then called this method in <b>roll</b> as <b>randomDie(sidesPerDie)</b>,\r\n  but I thought the former way was simpler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Static Fields -->\r\n\r\n<a name=\"StaticFields\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Static Fields</b></td>\r\n<td width =\"80%\">\r\n  There are two main uses of <b>static</b> fields.\r\n  The first and foremost is a place to declare constants (using the\r\n    <b>final</b> access modifier) that other classes can use.\r\n  For example, the <b>DateUtility</b> class declares <b>final</b> variables\r\n    naming all the months.\r\n  The <b>Rational</b> class declares the constants <b>ZERO</b> and <b>ONE</b>\r\n   (both storing references to an object representing one of these values).\r\n  Recall that one can call mutator on <b>final</b> variables to change their\r\n    states, but one cannot store a new reference (to a different object) in\r\n    a <b>final</b> variable.\r\n  Because <b>Rational</b> is an immutable class (it contains no mutator\r\n    methods) the instance values stored in these objects always will remain\r\n    the same.\r\n  <p>\r\n  The second use of <b>static</b> fields is more subtle: we use them to store\r\n    information shared by all objects in a class.\r\n  Normally, each objects stores its own state in instance variables; but\r\n   <b>static</b> variables are stored in a special spot that all objects\r\n   can access.\r\n  <p>\r\n  Suppose that we wanted to be able to know how many times\r\n    objects were constructed from a class (i.e., how many times <b>new</b> \r\n    operated on a certain class).\r\n  We can declare <b>private static int allocated = 0;</b> in the class, and\r\n    then include  the statement <b>allocated++;</b> in each constructor.\r\n  Now, whenever an object is constructed, the <b>static</b> variable shared\r\n    by all the objects in the class is incremented.\r\n  Finally, we could define \r\n    <pre><b>  public static int getAllocated ()\r\n  {return allocated;}</b></pre>\r\n    to return its value.\r\n  <p>\r\n  So, what would happen if we did not declare this field to be <b>static</b>.\r\n  If this information were stored in an instance variable (the only other\r\n    choice), each object would store this value as part of its own state; each\r\n    time an object was constructed it would initialize this instance variable\r\n    to zero and then increment it in the constructor.\r\n  Thus, if we constructed <b>n</b> objects, we would have <b>n</b> instance\r\n    variables storing <b>1</b>, not one <b>static</b> field storing <b>n</b>.\r\n  <p>\r\n  The final strangeness about <b>static</b> fields is that their declarations\r\n    (and intializations) are done just once, the first time Java needs to\r\n    do something with a class.\r\n  Contrast this with instance variable declarations which are executed each\r\n    time that <b>new</b> constructs an object.\r\n  <p>\r\n  Most fields in class with constructors are instance variables.\r\n  The ones that aren't are mostly the constants described above.\r\n  If you see other <b>static</b> fields, study them careful to understand them.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Writing Javadoc -->\r\n\r\n<a name=\"Javadoc\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Writing Javadoc Comments</b></td>\r\n<td width =\"80%\">\r\n  Java is the first popular programming language to come with a special\r\n    program (of course, written in Java) for documenting its classes.\r\n  This is important, because most interesting programming involves locating a\r\n    collection of useful classes and determining what constructors\r\n    and methods they define, and how to use them (based on their syntax and\r\n    semantics).\r\n  Having all this information stored, indexed, and viewable via standard web\r\n    browsers (with links), has made a big difference in my programming\r\n    efficiency.\r\n  <p>\r\n  We have already studied how to read web pages produced by Javadoc (both for\r\n    the standard Java library and classes that I have provided for this\r\n    course).\r\n  Now we will begin to learn how to write our own Javadoc comments, to document\r\n    classes that we write ourselves.\r\n  <p>\r\n  We can run Javadoc on Java source code (<b>.java</b> files).\r\n  Even if we have added none of the special comments desrcribed below,\r\n    Javadoc still produces a skeletal web page listing all the fields,\r\n    constructors, and methods in <b>Summary</b> and <b>Detail</b> tables.\r\n  Such web pages, though, won't have any commentary, and none of the \r\n   special <b>parameter</b>, <b>return</b>, and <b>throws</b> information.\r\n  <p>\r\n  In general, we can further document our classes with comments.\r\n  Javadoc ignores general comments, but reads and process comments written \r\n    in a special form: comments that start with <code><b>/**</b></code>.\r\n  These are called Javadoc comments.\r\n  Notice that a Javadoc comment is also a general comment (starting with\r\n    <b>/*</b>) so it is also treated as whitespace by the Java compiler.\r\n  <p>\r\n  Here is the Javadoc commment prefacing the <b>DiceEnsemble</b> class.\r\n  View it along with the Javadoc pages it generates in the\r\n    <a href=\"../../../common/classes/doc/index.html\" target=\"_blank\">\r\n    Javadoc of Course API</a>.\r\n  <pre><b>  /** \r\n   * Objects constructed from the &lt;code&gt;DiceEnsemble&lt;/code&gt;\r\n   *   class act as collections of dice.\r\n   * The number of dice in an ensemble (and the number of sides of\r\n   *   each die)  can be controlled by the programmer.\r\n   * The class models the basic operations need to roll the dice and\r\n   *   determine the number of pips showing -both for individual dice\r\n   *   and for the entire  ensemble.   \r\n   * \r\n   * @author Richard E. Pattis\r\n  */</b></pre>\r\n  Javadoc <b>copies</b> the contents of this comment into the web page that it\r\n    builds for this class; it appears near the top, right before the first\r\n    <b>Summary</b> table.\r\n  I write such comments in the <b>.java</b> file a special style, for ease of\r\n    editing; each line is a sentence, with sentences longer than one line\r\n    indented.\r\n  The web browser renders this text as a nice paragraph.\r\n  <p>\r\n  Note that I said that Javadoc <b>copies</b> the contents of the message...\r\n    and the web browser renders the text...\r\n  This means that the comment can us embedded HTML markup tags; these tags are\r\n    copied into the web page and rendered by the browser, just like normal\r\n    HTML tags in text.\r\n  Notice the use of <b>&lt;code&gt;DiceEnsemble&lt;/code&gt;</b> to render the\r\n    name of this class in the <b>code</b> font; in a multi-paragraph\r\n    description, we use <b>&lt;p&gt;</b> to separate the paragraphs.\r\n  Generally, use what HTML markup tags you are familiar with to format your\r\n    documentation.\r\n  <p>\r\n  Finally, note the special Javadoc markup tag <b>@author</b>; Javdoc makes\r\n    special use of these tag, often creating special HTML for them.\r\n  <p>\r\n  A typical constructor or method is documented by a Javadoc comment of the\r\n    following form; the comment appear in the <b.java</b> file right before\r\n    the member it documents.\r\n  <pre><b>  /**\r\n  * One sentence. More documentation\r\n  * @param  tag(s)\r\n  * @return tag(s)\r\n  * @throws tag(s)\r\n  */</b></pre>\r\n  This section always begins with at least one sentence ended by a period;\r\n    other material (e.g., <b>More documentation</b>) can follow.\r\n  All information up to and including the first period appears in the\r\n    <b>Summary</b> section; it also appears in the <b>Detail</b> sections,\r\n    followed by any other material (e.g., <b>More documentation</b>).\r\n  <p>\r\n  Again, each appearance of <b>@something</b> is a special Javadoc markup tag\r\n    that Javadoc recognizes and processes by inserting special HTML markup\r\n    commands to highlight the information coming after the tag.\r\n  We should include only those tags that are relevant: a constructor/method \r\n   with no parameters has no  <b>@param</b> tags; otherwise we use one tag per\r\n    parameter.\r\n  A constructor or <b>void</b> method has no <b>return</b> tag; otherwise we\r\n    use only one tag.\r\n  A constructor/method throwing no exceptions has no <b>@throws</b> tags;\r\n    otherwise we use one tag per exception. \r\n  <p> \r\n  The information documented by all these tags appears in the <b>Detail</b>\r\n    sections.\r\n  The words <b>Parameters</b>, <b>Returns</b>, and <b>Throws</b> are\r\n    highlighted.\r\n  The first word after <b>@param</b> should be the name of the parameter; it\r\n    automatically is rendered in the <b>code</b> font, followed by a dash, and\r\n    then the rest the information we write.\r\n  The first word after <b>@throws</b> should be the name of the exception; it\r\n    appears as a link to the class of that name, followed by a dash, and then\r\n    the rest the information that we write.\r\n  Again, we can embed any HTML markup tags directly in any comments processed\r\n    by Javadoc (it will just copy them to the web page, where the browswer will\r\n    interpret them).\r\n  <p>\r\n  Here are the Javadoc comment that precede the first constructor and the\r\n    <b>roll</b> and <b>getPips</b> methods in the <b>DiceEnsemble</b> class.\r\n  Notice that the <b>One sentence.</b> comment ends in a period, while the tags\r\n    don't; words enclosed inside the <b>code</b> HTML commands are displayed\r\n    in a special font.\r\n  I group all the parameter tags together, separated by blank lines.\r\n<pre><b>  /** \r\n  * Constructs a &lt;code&gt;DiceEnsemble&lt;/code&gt; object, specifying\r\n  *   the number of dice and the number of sides per die.\r\n  *\r\n  * @param  numberOfDice specifies the number of dice in the ensemble\r\n  * @param  sidesPerDie specifies the number of sides on each and every\r\n  *           die in the ensemble (the pips showing are 1, 2, 3, ...\r\n  *           &lt;code&gt;sidesPerDie&lt;/code&gt;)\r\n  *\r\n  * @throws IllegalArgumentException if either parameter is less than 1\r\n */\r\n  public DiceEnsemble (int numberOfDice, int sidesPerDie)\r\n    throws IllegalArgumentException\r\n  {...}\r\n\r\n\r\n\r\n  /** \r\n   * Returns this &lt;code&gt;DiceEnsemble&lt;/cod&gt; after rolling every\r\n   *   die in it.\r\n   * By using the return type <code>DiceEnsemble</code> instead of\r\n   *   &lt;code&gt;void&lt;/code&gt;, we can \"cascade\" method calls, writing\r\n   *   expressions such as: &lt;code&gt;d.roll().getPipSum()&lt;/code&gt;\r\n   *   instead of writing roll as its own statement.\r\n   *\r\n   * @return the rolled dice ensemble\r\n  */\r\n  public DiceEnsemble roll ()\r\n  {..}\r\n\r\n\r\n\r\n  /** \r\n   * Returns the the number of pips showing on die &lt;code&gt;dieIndex&lt;/code&gt;\r\n   *   (changed each time the ensemble is rolled).\r\n   *\r\n   * @param  dieIndex specifies the index of the die whose pips are\r\n   *           returned\r\n   *\r\n   * @throws IllegalStateException if this ensemble has not been rolled\r\n   * @throws IllegalArguementException if &lt;code&gt;dieIndex&lt;/code&gt;\r\n   *           is outside the range [1,getNumberOfDice()].\r\n   *\r\n   * @return the the number of pips showing on die &lt;code&gt;dieIndex&lt;/code&gt;.\r\n  */\r\n  public int getPips (int dieIndex)\r\n     throws IllegalStateException, IllegalArgumentException\r\n  {...}</b></pre>\r\n  <p>\r\n  The documentation for \r\n    <a href=\"http://java.sun.com/j2se/1.4/docs/tooldocs/win32/javadoc.html\"\r\n      target=\"_blank\">Javadoc</a>\r\n    appears on the Sun Microsystems web site. \r\n  If you want to know more about Javadoc than this course covers, start\r\n     reading here.\r\n  <p>\r\n  I will partially describe two other very interesting Javadoc tags:\r\n    <b>@see</b> and <b>@link</b>.\r\n  Both tags are use to create links to other fields, constructors, or methods\r\n    either on this page or any other page documenting another class.\r\n  The <b>@see</b> tag collects the references and puts them in a special\r\n    section; the <b>@link</b> tag embeds links in any documentation, right\r\n    where it appears.\r\n  A typical use is\r\n  <b><pre>  ...This method should never be called until first calling\r\n  <b>the {@link DiceEnsemble#roll roll}</b> method to ensure the dice\r\n  actually have some pips showing.</pre></b>\r\n  The first piece of information is the way to refer to some field,\r\n    constructor, or method; the second piece of information is what word the\r\n    link should  appear as.\r\n  The Javadoc web page has much more information about this interesting tag,\r\n    including the following general forms.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/linksyntax.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  <p>\r\n  We can run the Javadoc program (to produce Javadoc web pages) from the\r\n    cammand line; it has many interesting options.\r\n  The standard way I run it is\r\n<b><pre>  javadoc -d publicdocs -public *.java -link http://java.sun.com/j2se/1.3/docs/ap</pre></b>\r\n  If you don't want to type all this information, you can download the\r\n     <a href=\"../../../common/classes/generatedocs.bat\">\r\n       Generate Javadoc</a> batch file, which contains this command and another\r\n    (one to generate Javadoc from the perspective of an implememtor, including\r\n    all the <b>private</b> stuff).\r\n  This batch file is also available under <b>Miscellaneous</b> in the  \r\n     <a href=\"../../../common/online.html\">Online Resources</a> web page.\r\n  <p>\r\n  Put this file in a folder that contains the <b>.java</b> files that you want\r\n    to run through Javadoc.\r\n  If you are runing under Windows, double-click the file named\r\n    <b>generatedocs.bat</b>, and you will see a console window pop up; this\r\n    window shows the Javadoc utility running (otherwise, cut/paste/execute\r\n    the lines from this file).\r\n  It creates a folder named <b>publicdocs</b> containing all the Javadoc\r\n    comments related to public class members (the ones we have been reading as\r\n    class users); and a folder named <b>privatedocs</b> containing all the\r\n     Javadoc comments related to public and private class members (the ones\r\n     we would read as class implementors).\r\n  Each folder contains a file named <b>index.html</b>, which acts as the root\r\n    for all the Javadoc web pages in that folder; click on it to start viewing\r\n    the Javadoc\r\n  <p>\r\n  It can take a few seconds or so for each class that Javadoc examines\r\n    and extracts into a web page.\r\n  For debugging purposes (if your <b>@link</b> tags contain errors), twice\r\n    you will be asked to press any key to continue (so if there are errors,\r\n    you can stop and examine them, instead of having them scroll by).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Eclipse -->\r\n\r\n<a name=\"Eclipse2\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Instance Variables in the Eclipse Debugger</b></td>\r\n<td width =\"80%\">\r\n  The Eclipse debugger includes a few useful features to illustrate classes\r\n    from which we construct objects.\r\n  All the material that we discussed previously in this lecture note (about\r\n    the editor and  debugger) concerning <b>static</b> methods works for\r\n    non-<b>static</b>  methods as well.\r\n  We know that whenever a method is called, the debugger displays all its\r\n    its parameter variables and local variables in the <b>Variables</b> tab.\r\n  But in addition, whenever a non-<b>static</b> method is called on an object,\r\n    this pane also displays a special entry named <b>this</b> (surprised? it\r\n    was the same in the call frames) that refers to that object's instance\r\n    variables (so, our call frames do accurately reflect the main aspect of\r\n    <b>this</b>).\r\n  <p>\r\n  Suppose that we stop on the first line inside the <b>roll</b> method.\r\n  The full name of the method (<b>packageName.ClassName.methodName</b>)\r\n     appears  underneath<b> Thread[main]</b>); recall that <b>temp</b>\r\n     is the package name for this class.\r\n  Note that in the <b>Variables</b> tab </b>this</b> appears on a single line\r\n   that is preceded by a box showing a <b>+</b> and followed by an id\r\n   number (ignore the id number).\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thisvars1.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  The box is is called a <b>disclosure box</b>; it is currently in its\r\n    <b>non-disclosing</b> (or elided) state.\r\n  By clicking this box, it toggles to it <b>disclosing</b> state: its contents\r\n    will be replaced by a <b>-</b> and all the instance variables in the\r\n    object <b>this</b> refers to will appear, indented, under <b>this</b>.\r\n  (clicking this box again will return it to its non-disclosing state).\r\n  This is the first time these two, six-sided dice are being rolled, so\r\n    the instance variables <b>rollCount</b>, <b>pipSum</b>, and <b>allSame</b>\r\n    all display their initial values.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thisvars2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  By watching these instance variables change while single stepping through\r\n    the statements in this method, we can see how this mutator/command changes\r\n    the state of the object.\r\n  When the last line of the method is reached, the instance variables now\r\n   display their new values.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thisvars3.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Understanding how the debugger treats objects is crucial to being able to\r\n    debug classes quickly.\r\n  Practice using these kinds of stepping and object observations using the\r\n    drivers for the <b>SimpleDiceEnsemble</b> and <b>Rational</b> classes.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Class Roundup -->\r\n\r\n<a name=\"ClassRoundup\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Summary and Class Invariants</b></td>\r\n<td width =\"80%\">\r\n  This has been a long lecture, discussing many interesting language features,\r\n    and tons of technical terms.\r\n  It looked as classes from a new perspective -that of a class implementor-\r\n    leveraging off all the information that we have learned previously -as\r\n    class users.\r\n  Let me try to review the most important ideas here briefly.\r\n  <p>\r\n  We began by studying the form and meaning of <b>static</b> method\r\n    definitions, along with the <b>return</b> and <b>throw</b> statements.\r\n  We learned how to hand simulate these methods in call frames and how to\r\n    use them in programs -in two ways: directly in an application\r\n    (along with a <b>main</b> method) and as definitions in a library class.\r\n  We examined how the Metrowerks IDE makes using methods easier (in the editor\r\n    and the debugger).\r\n  <p>\r\n  Then we discussed how to define instance variables in a class, along with\r\n    the related topics of how to write constructors that help initialize them\r\n    and methods to manipulate them.\r\n  We learned that a <b>private</b> member can be accessed from any other\r\n    members in the class it is defined in (but not from members outside this\r\n    class).\r\n  We found two interesting uses for the keyword <b>this</b>: to specify\r\n   instance variables (in variable name conflicts) and to help in constructors.\r\n  Finally, we discussed writing Javadoc to document classes and their members.\r\n  <p>\r\n  Finally, I would like to look one more time at constructors and methods\r\n    as middlemen with respect to <b>private</b> instance variables.\r\n  An <b>invariant</b> is a statement about something that remains true while\r\n    that something is manipulated; if such a statement is true, we say it is\r\n    satisfied.\r\n  A <b>class invariant</b> is a set of statements about the instance variables\r\n    of objects constructed from the class: these statements must be true when\r\n    an object is first constucted, and they must remain true after each method\r\n    is called.\r\n  <p>\r\n  Of course, accessor/queries do not change state, so they can be ignored when\r\n    discussing class invariants.\r\n  In fact, many interesting class are immutable: e.g., <b>String</b>,\r\n    <b>BigInteger</b>, and <b>Rational</b>; so their class invariants have to\r\n    be true only after object construction.\r\n  The <b>Rational</b> class, for example, has three invariants.\r\n  <ul>\r\n    <li>Zero is stored with a numerator of zero and a denominator of one.\r\n    <li>The denominator is always stored as a positive value.\r\n    <li>The numerator and denominator are reduced to have no common factors.\r\n  </ul>\r\n  The constructor carefully ensures that these are all true.\r\n  Various methods (especially <b>equals</b>) assume that invariants are true\r\n    in order to operate correctly (and sometimes efficiently).\r\n  <p>\r\n  The <b>DiceEnsemble</b> class, for another example, requires positive values\r\n    for the number of dice and sides per die.\r\n  Its constructor also ensures this invariant and the only accessor,\r\n    <b>roll</b> does not change these instance variables.\r\n  <p>\r\n  Using <b>private</b> instance variables helps an implementor ensure class\r\n    invariants.\r\n  By declaring instance variables to be <b>private</b>, we know that the\r\n    only place they can change is in the code for methods defined in that\r\n    class. \r\n  Users of the class cannot change these variables directly and possibly\r\n    make an invariant unsatisfied.\r\n  <p>\r\n  Imagine what would happen if we declared <b>numerator</b> or\r\n    <b>denominator</b> to be <b>public</b>.\r\n  An incompetent or malicious programmer could store anything in such\r\n    instance variables, violating any or all of the invariants stated above.\r\n  Thus, a class implementor prefers <b>private</b> instance variables\r\n    (and sometimes <b>public final</b> ones will work too) so that users of the\r\n    class cannot do bad things to its instances.\r\n  This access modfier ensures that the constructors and methods of the class\r\n    have ultimate control over what state changes are made to objects.\r\n  <p>\r\n  Now we come to how this aids us when debugging.\r\n  Imagine a scenerio where the user of a class is getting bad results in \r\n    an application program; who is to blame, the user or implementor of the\r\n    class.\r\n  If an object's state ever doesn't satisfy its class invariants, the\r\n    implementor has definitely made a mistake.\r\n  If an object's state always satisfies its class invariants, but the\r\n    postcondition of a method is not satisifed, then the implementor has also\r\n    made a mistake.\r\n  All other mistakes are the result of the user of a class.\r\n  <p>\r\n  A well designed class is a cohesive collection of related instance\r\n    variables, the constructors that initialize them, and the methods that\r\n    manipulate them.\r\n  Each method performs some small, well-defined service.\r\n  Taken together, these methods allow programmers to do everything needed to\r\n    objects constructed from the class.\r\n  It is the composition of these coordinated services, under control of the\r\n    programmer, that make well-designed classes easy to reuse in many related\r\n    applications.\r\n  So, in a well-designed class, it is common to write many small methods (the\r\n    classes that we have seen are typical); this is true even in more \r\n    complicated classes, which may have many more constructors, methods, and\r\n     instance variables, but whose method definitions are still quite small.\r\n  <p>\r\n  It is not a goal of ICS-21 (nor 22 for that matter; ICS-23 gets closer with\r\n     collection classes) to teach you how to design a (re)usable class.\r\n  It is a goal to teach you how to read and use classes; it is also a goal for\r\n    you to be able to implement (write the <b>.java</b> file) for a\r\n    well-designed (by someone else) class.\r\n  <p>\r\n  Finally, if you want to read the <b>.java</b> source code files for any of\r\n    Java's standard library classes, you can find them in the <b>src.jar</b>\r\n    file in the <b>jdk1...</b> folder (or whatever folder representes the\r\n    top of your Java file system: mine is\r\n     <b>C:\\Program Files\\Java\\jdk1....</b>.\r\n  Open this file with <b>zip</b> and you can select and examine any of the\r\n    nearly 2,000 files it contains.\r\n  These files comprise industrial-strength code written by excellent\r\n    programmers: don't expect to breeze through the code, but it is\r\n    remarkably readable (say, compared to C/C++ libraries).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA,\r\n    or any other student.\r\n\r\n  <ol> \r\n     <li>Write a statement that calls any of the \"result-returning\" methods (maybe just\r\n           display the returned result on the console) and hand simulate its execution with\r\n           a call frame.\r\n     <p>\r\n     \r\n\r\n     <li>Java allows methods to have no parameters; such methods are defined and called by\r\n           specifying their name followed and an empty argument list: e.g., <b>f()</b>.\r\n         Use your knowledge of the semantics of the <b>return</b> statement to explain what\r\n           happens for the following method and its calls.\r\n         Don't get confused by what you think it does (or want it to do): follow the rules.\r\n         <b><pre>  int f()\r\n  {\r\n    return 1;\r\n    return 2;\r\n  }</pre></b>\r\n         What is displayed by <b>System.out.print(\"1st f = \" + f() + \" 2nd f = \" + f());</b>\r\n     <p>\r\n\r\n  <li>Write a  method named <b>characteristic</b>, which returns 1 if its parameter is <b>true</b>\r\n        and 0 if its parameter is <b>false</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>abs</b>, which returns the absolute value of its\r\n        <b>int</b> parameter (it always returns the non-negative magnitude of its parameter;\r\n        don't call the <b>Math.abs</b> method).\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>signum</b>, which returns <b>-1</b> if its <b>double</b> parameter\r\n        is negative, <b>0</b> if its parameter is zero, and <b>+1</b> if its parameter is positive.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>constrain</b>.\r\n      Calling <b>constrain(1,5,10)</b> returns <b>5</b> because this middle value is between the first\r\n         and third values.\r\n      Calling <b>constrain(1,-5,10)</b> returns <b>1</b> because this middle value is smaller than the first\r\n         value, so the method returns the first value.\r\n      Calling <b>constrain(1,15,10)</b> returns <b>10</b> because this middle value is larger than the third\r\n         value, so the method returns the third value.\r\n      Thus, this method returns the middle value, but it is constrained to lie between the first and\r\n        third values inclusize.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>forChar</b>.\r\n      We could call the method as <b>forChar(\"Enter an Upper-Case Letter\", 'A', 'Z')</b> which\r\n        always returns a <b>char</b> whose ASCII value is between <b>'A'</b> and <b>'Z'</b>; or\r\n      we could call the method as <b>forChar(\"Enter a Digit\", '0', '9')</b> which\r\n        always returns a <b>char</b> whose ASCII value is between <b>'0'</b> and <b>'9'</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Why can't we write a  simple method named <b>makeChange</b>, which is supplied the amount of change\r\n        to vend, and returns the number of quarters, dimes, nickels, and pennies needed to vend the\r\n        required change.\r\n      How do you think we can write a method to solve such a problem?\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>majority</b>, which returns the most frequently occuring value\r\n        of its three <b>boolean</b> parameters: no matter the values, at two of three (and possibly\r\n        three of three) will have the same value.\r\n      For example, the call <b>majority(true,false,false)</b> returns <b>false</b>, while\r\n        the call <b>majority(true,true,true)</b> returns <b>true</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>median</b>, which returns the middle value of its three arguments.\r\n      For example, the call <b>median(3,2,5)</b> returns <b>3</b> because it is between <b>2</b>\r\n        and <b>5</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Assume that we declare <b>char roman;</b> and store in it a character that is a\r\n        roman numeral.\r\n      Write a method that returns the <b>int</b> equivalent of the Roman numeral:\r\n        <b>I</b> is <b>1</b>, <b>V</b> is <b>5</b>, \r\n        <b>X</b> is <b>10</b>, <b>L</b> is <b>50</b>, <b>C</b> is <b>100</b>,\r\n        <b>D</b> is <b>500</b>, <b>M</b> is <b>1000</b>; if it stores any other character,\r\n        return <b>-1</b>.\r\n  <p> \r\n \r\n  <li>Write a  method named <b>isPrime</b>, which returns whether or not its parameter is a\r\n        prime number.\r\n      A prime number has only 1 and itself as divisors: neither 0 nor 1 are considered prime; 2 is\r\n       the smallest prime number, then 3, 5, 7, 11, etc.\r\n      Hint: Use a <b>for</b> loop to check for possible divisors, along with the <b>%</b> operator.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>harmonic</b>, which takes one <b>int</b> parameter and returns a\r\n        <b>double</b> value representing the harmonic series of that order.\r\n      <b>harmonic(n)</b> is defined as <b>1 + 1/2 + 1/3 + ... 1/n</b>.\r\n      So <b>harmonic(2)</b> returns <b>1.5</b>; and <b>harmonic(4)</b> returns <b>2.083333</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>fw</b>, which returns the number of characters needed to print its\r\n        integer parameter.\r\n      For example, <b>fw(5)</b> returns <b>1</b>; <b>fw(-5)</b> returns <b>2</b>;\r\n        <b>fw(453)</b> returns <b>3</b>; and <b>fw(-243)</b> returns <b>4</b>.\r\n      Hint: the number of digits in a number is related to how many times you can divide it\r\n        by <b>10</b> and still have a non-zero value; treat negative numbers specially.\r\n  <p>\r\n     \r\n\r\n  <li>Write a method named <b>block</b> that has an <b>int</b> height and width parameter, and a\r\n      <b>char</b> parameter.\r\n      This method returns a <b>String</b> which when printed displays a rectangle of that the specified \r\n      height and width, consisting of the specified character.\r\n      Calling <b>System.out.println(block(5,20,'*'));</b> would print.\r\n      <b><pre>  ******************** \r\n  ******************** \r\n  ******************** \r\n  ******************** \r\n  ********************</pre></b>\r\n      Remember that catenating an escape sequence character (<b>'\\n'</b>) in a <b>String</b> causes\r\n        a carriage return when that character is printed.\r\n   <p>\r\n\r\n     <li>Suppose our program consists of the the methods <b>main</b>, <b>a</b>,\r\n           <b>b</b>, <b>c</b>, <b>d</b>, and <b>e</b>.\r\n         Also suppose <b>main</b> calls <b>a</b>, <b>b</b>, <b>d</b>, and <b>e</b>,\r\n           <b>a</b> calls <b>c</b>, <b>b</b> calls <b>a</b>, <b>c</b> calls nothing else,\r\n           <b>d</b> calls <b>a</b>, and <b>e</b> calls <b>d</b> and <b>c</b>.\r\n         <ul>\r\n            <li>Find two \"natural orders\" in which to write these methods in a file \r\n            <li>Find two \"reverse natural orders\" in which to write these methods in a file \r\n         </ul>     \r\n\r\n      <p>\r\n      <li>For all the sample methods in this lecture, identify the ones in\r\n            which it makes sense to throw <b>IllegalArgumentExceptions</b> and\r\n            describe under what conditions.\r\n          Note that sometimes individual parameters will store reasonable\r\n            values, but pairs of parameters will have values that are\r\n            incompatible.\r\n\r\n      <p>\r\n\r\n      <li>As we saw in this lecture, we can specify that a parameter variable\r\n            is <b>final</b>.\r\n          For example, we can rewrite <b>factorial</b> as\r\n<pre><b>  public static int factorial (final int n)\r\n  {\r\n    int answer = 1;\r\n    for (int i=2; i<=n; i++)\r\n      answer *= i;\r\n    return answer;\r\n  }</b></pre>\r\n  What does <b>final</b> mean when added before a parameter?\r\n  Does the <b>factorial</b> method still work correctly if its parameter is specified <b>final</b>?\r\n  If it didn't, would we find out at compile-time or at run-time?\r\n  Which methods in this lecture can have their parameters(s) declared to be\r\n     <b>final</b>? Which cannot?\r\n  Can any of the local variables in these methods be declared <b>final</b>?\r\n<p>\r\n\r\n<li>Define a class with the following characteristics:\r\n      its name is <b>Utility</b> and\r\n      it is in the <b>cs200</b> package.\r\n    It contains two <b>static</b> methods, both named <b>factorial</b>: the\r\n      first takes an <b>int</b> parameter and returns an <b>int</b> result;\r\n      the second takes a <b>BigInteger</b> parameter and returns a\r\n      <b>BigInteger</b> result.\r\n    Important whatever classes are necessary to write the bodies of these\r\n      methods successfully.\r\n<p>\r\n\r\n<li>Explain why when defining a class, we never need to write an import\r\n       declaration for the <b>Math</b> class.\r\n<p>\r\n\r\n     <li>I predict that half the students in class will make the following mistake when\r\n           they write one of their first few constructors.\r\n         Can you spot the mistake (compare it to the correctly written constructor in this lecture)?\r\n         What actually happens if we write this code?\r\n         Will Java detect/report the error? If so, with what message? If not, what will Java do when\r\n           it executes this code?\r\n<pre><b>  public SimpleDiceEnsemble () \r\n  {\r\n    int numberOfDice = 2;\r\n    int sidesPerDie  = 6;\r\n    int rollCount    = 0;\r\n  }</b></pre>\r\n  If we wrote each of these like <b>this.numberOfDice</b>, would it help?\r\n<p>\r\n\r\n<li>Explain how to simplify the following declarations and constructor.\r\nI have used the style of always writing <b>this.</b> to access instance\r\n  variables.\r\n<pre><b>  private int a;\r\n  private int b;\r\n  private int c;\r\n\r\n  public C (int a) \r\n  {\r\n    this.a = a;\r\n    this.b = 10;\r\n    this.c = 0;\r\n  }</b></pre><p>\r\n<p>\r\n\r\n     <li>Examine the code for the <b>SimpleDiceEnsemble</b> class.\r\n     <ul>\r\n       <li>Assume that we decide to roll the dice automatically, at the time\r\n             when the ensemble is constructed, to initialize them.\r\n           How could we modify the constructor to perform this task?\r\n           What changes (if any) could we make the method headers and bodies?\r\n       <li>Assume that we want users of this class to be able to retrieve the\r\n             minimum and maximum number of pips showing after each roll.\r\n           What extra instance variables should we declare?\r\n           What new methods should we write and what changes to old methods\r\n             should we make?\r\n     </ul>\r\n<p>\r\n<li>\r\nWrite a class named <b>RangeTally</b>.\r\nEach instance of this class stores four fields: the lower legal value, the\r\n  upper legal value, the sum of all the int values in this range that it is\r\n  has seen (via the <b>tally</b> method), and the total number of values that\r\n  has seen (whether they were in range or not).\r\nIts constructor should initialize these fields appropriately; its accessor,\r\n  <b>getTally</b>, should return the sum of all values seen which were in\r\n  range; its accessor, <b>getCount</b>, should return a count of all of values\r\n   that it has seen (whether they were in range or not); its mutator,\r\n  <b>tally</b>, is passed an <b>int</b> parameter that is conditionally tallied\r\n  into the sum; it should change all fields as appropriate\r\nFor example, if we declare <b>RangeTally t = new RangeTally(1,10);</b> and\r\n   execute the statements <b>t.tally(5); t.tally(8); t.tally(15);</b>\r\n   and then <b>System.out.println(t.getTally()+\":\"+t.getCount());</b> Java\r\n    prints </b>13:3</b> -the last value is counted, but not summed, because it\r\n    is not in the range <b>1</b> to <b>10</b>, specified in the constructor.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 30669.0}