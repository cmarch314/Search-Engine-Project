{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Regular triangulation 2 Traits Tds Definition The class Regular triangulation 2 Traits Tds is designed to maintain the regular triangulation of a set of weighted points Let PW pi wi i 1 n be a set of weighted points where each pi is a point and each wi is a scalar called the weight of point pi Alternatively each weighted point pi wi can be regarded as a two dimensional sphere with center pi and radius ri sqrt wi The power diagram of the set PW is a planar partition such that each cell corresponds to sphere pi wi of PW and is the locus of points p whose power with respect to pi wi is less than its power with respect to any other sphere pj wj in PW The dual of this diagram is a triangulation whose domain covers the convex hull of the set P pi i 1 n of center points and whose vertices are a subset of P Such a triangulation is called a regular triangulation The three points pi pj and pk of P form a triangle in the regular triangulation of PW iff there is a point p of the plane whose powers with respect to pi wi pj wj and pk wk are equal and less than the power of p with respect to any other sphere in PW Let us defined the power product of two weighted points pi wi and pj wj as pi wi pj wj pipj 2 wi wj pi wi pj is simply the power of point pj with respect to the sphere pi wi and two weighted points are said to be orthogonal if their power product is null The power circle of three weighted points pi wi pj wj and pk wk is defined as the unique circle orthogonal to pi wi pj wj and pk wk The regular triangulation of the sets PW satisfies the following regular property which just reduces to the Delaunay property when all the weights are null a triangle pipjpk of the regular triangulation of PW is such that the power product of any weighted point pl wl of PW with the power circle of pi wi pj wj is pk wk is positive or null We call power test of the weighted point pl wl with respect to the face pipjpk the predicates testing the sign of the power product of pl wl with respect to the power circle of pi wi pj wj is pk wk This power product is given by the following determinant 1 xi yi xi 2 yi 2 wi 1 xj yj xj 2 yj 2 wj 1 xk yk xk 2 yk 2 wk 1 xl yl xl 2 yl 2 wl A pair of neighboring faces pipjpk and pipjpl is said to be locally regular with respect to the weights in PW if the power test of pl wl with respect to pipjpk is positive A classical result of computational geometry establishes that a triangulation of the convex hull of P such that any pair of neighboring faces is regular with respect to PW is a regular triangulation of PW Alternatively the regular triangulation of the weighted points set PW can be obtained as the projection on the two dimensional plane of the convex hull of the set of three dimensional points P pi pi 2 wi i 1 n The vertices of the regular triangulation of a set of weighted points PW form only a subset of the set of center points of PW Therefore the insertion of a weighted point in a regular triangulation does not necessarily imply the creation of a new vertex If the new inserted point does not appear as a vertex in the regular triangulation it is said to be hidden Hidden points are stored in special vertices called hidden vertices A hidden point is considered as hidden by the facet of the triangulation where its point component is located in fact the hidden point can appear as vertex of the triangulation only if this facet is removed Each face of a regular triangulation stores the list of hidden vertices whose points are located in the facet When a facet is removed points hidden by this facet are reinserted in the triangulation include CGAL Regular triangulation 2 h ParametersThe geometric traits parameter Traits has to be instantiated with a model of the concept RegularTriangulationTraits 2 The concept RegularTriangulationTraits 2 refines the concept TriangulationTraits 2 by adding the type Weighted point 2 to describe weighted points and the type Power test 2 to perform power tests on weighted points The Tds parameter has to be instantiated by a model of TriangulationDataStructure 2 The face base of a regular triangulation has to be a model of the concept RegularTriangulationFaceBase 2 while the vertex base class has to be a model of RegularTriangulationVertexBase 2 CGAL provides a default instantiation for the Tds parameter by the class CGAL Triangulation data structure 2 CGAL Reugular triangulation vertex base 2 Traits CGAL Regular Triangulation face base 2 Traits Inherits FromTriangulation 2 Traits Tds Types typedef Traits Distance Distance typedef Traits Line Line typedef Traits Ray Ray typedef Traits Bare point Bare point typedef Traits Weighted point Weighted point Regular triangulation 2 Traits Tds All vertices iterator An iterator that allows to enumerate the vertices that are not hidden Regular triangulation 2 Traits Tds Finite vertices iterator An iterator that allows to enumerate the finite vertices that are not hidden Regular triangulation 2 Traits Tds Hidden vertices iterator An iterator that allows to enumerate the hidden vertices Creation Regular triangulation 2 Traits Tds rt Traits gt Traits Introduces an empty regular triangulation rt Regular triangulation 2 Traits Tds rt Regular triangulation 2 rt Copy constructor Insertion and Removal Vertex handle rt insert Weighted point p Face handle f Face handle inserts weighted point p in the regular triangulation If the point p does not appear as a vertex of the triangulation the returned vertex is a hidden vertex If given the parameter f is used as an hint for the place to start the location process of point p Vertex handle rt insert Weighted point p Locate type lt Face handle loc int li insert a weighted point p whose bare point is assumed to be located in lt loc li Vertex handle rt push back Point p Equivalent to insert p template class InputIterator int rt insert InputIterator first InputIterator last inserts the weighted points in the range first last Returns the number of created vertices Precondition The value type of first and last is Weighted point void rt remove Vertex handle v removes the vertex from the triangulation Queries template class OutputItFaces class OutputItBoundaryEdges class OutputItHiddenVertices CGAL Triple OutputItFaces OutputItBoundaryEdges OutputItHiddenVertices rt get conflicts and boundary and hidden vertices Weighted point p OutputItFaces fit OutputItBoundaryEdges eit OutputItHiddenVertices vit Face handle start OutputItFaces is an output iterator with Face handle as value type OutputItBoundaryEdges stands for an output iterator with Edge as value type OutputItHiddenVertices is an output iterator with Vertex handle as value type This member function outputs in the container pointed to by fit the faces which are in conflict with point p i e the faces whose power circles have negative power wrt p It outputs in the container pointed to by eit the boundary of the zone in conflict with p It inserts the vertices that would be hidden by p into the container pointed to by vit The boundary edges of the conflict zone are ouput in counter clockwise order and each edge is described through its incident face which is not in conflict with p The function returns in a CGAL Triple the resulting output iterators template class OutputItFaces class OutputItBoundaryEdges std pair OutputItFaces OutputItBoundaryEdges rt get conflicts and boundary Weighted point p OutputItFaces fit OutputItBoundaryEdges eit Face handle start same as above except that only the faces in conflict with p and the boundary edges of the conflict zone are output via the corresponding output iterators The function returns in a std pair the resulting output iterators template class OutputItFaces class OutputItHiddenVertices std pair OutputItFaces OutputItHiddenVertices rt get conflicts and hidden vertices Weighted point p OutputItFaces fit OutputItHiddenVertices vit Face handle start same as above except that only the faces in conflict with p and the vertices that would be hidden by p are output via the corresponding output iterators The function returns in a std pair the resulting output iterators template class OutputItBoundaryEdges class OutputItHiddenVertices std pair OutputItBoundaryEdges OutputItHiddenVertices rt get boundary of conflicts and hidden vertices Weighted point p OutputItBoundaryEdges eit OutputItHiddenVertices vit Face handle start same as above except that only the the vertices that would be hidden by p and the boundary of the zone in conflict with p are output via the corresponding output iterators The boundary edges of the conflict zone are ouput in counterclockwise order and each edge is described through the incident face which is not in conflict with p The function returns in a std pair the resulting output iterators template class OutputItFaces OutputItFaces rt get conflicts Point p OutputItFaces fit Face handle start same as above except that only the faces in conflict with p are output The function returns the resulting output iterator template class OutputItBoundaryEdges OutputItBoundaryEdges rt get boundary of conflicts Point p OutputItBoundaryEdges eit Face handle start same as above except that only the boundary edges of the conflict zone are ouput in counterclockwise order where each edge is described through the incident face which is not in conflict with p The function returns the resulting output iterator template class OutputItHiddenVertices OutputItHiddenVertices rt get hidden vertices Point p OutputItHiddenVertices vit Face handle start same as above except that only the vertices that would be hidden by p are output The function returns the resulting output iterator Access functions int rt number of vertices returns the number of finite vertices that are not hidden int rt number of hidden vertices returns the number of hidden vertices Hidden vertices iterator rt hidden vertices begin starts at an arbitrary hidden vertex Hidden vertices iterator rt hidden vertices end past the end iterator for the sequence of hidden vertices Finite vertices iterator rt finite vertices begin starts at an arbitrary unhidden finite vertex Finite vertices iterator rt finite vertices end Past the end iterator All vertices iterator rt all vertices end starts at an arbitrary unhidden vertex All vertices iterator rt all vertices begin past the end iterator Dual power diagram The following member functions provide the elements of the dual power diagram Point rt weighted circumcenter Face handle f returns the center of the circle orthogonal to the three weighted points corresponding to the vertices of face f Precondition f is not infinite Point rt dual Face handle f same as weighted circumcenter Object rt dual Edge e If both incident faces are finite returns a segment whose endpoints are the duals of each incident face If only one incident face is finite returns a ray whose endpoint is the dual of the finite incident face and supported by the line which is the bisector of the edge s endpoints If both incident faces are infinite returns the line which is the bisector of the edge s endpoints otherwise Object rt dual Edge circulator ec Idem Object rt dual Edge iterator ei Idem template class Stream Stream rt draw dual Stream ps output the dual power diagram to stream ps Predicates Oriented side rt power test Face handle f Weighted point p Returns the power test of p with respect to the power circle associated with f advanced Miscellaneous bool rt is valid bool verbose false int level Tests the validity of the triangulation as a Triangulation 2 and additionally test the regularity of the triangulation This method is useful to debug regular triangulation algorithms implemented by the user advanced See AlsoCGAL Triangulation 2 Traits Tds TriangulationDataStructure 2 RegularTriangulationTraits 2 RegularTriangulationFaceBase 2 RegularTriangulationVertexBase 2 CGAL Regular triangulation face base 2 Traits CGAL Regular triangulation vertex base 2 Traits Next Regular triangulation euclidean traits 2 K Weight Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Triangulation_2_ref/Class_Regular_triangulation_2.html", "title": "regular_triangulation_2&lt;traits,tds&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Triangulation_2_ref/Regular_triangulation_2.tex' -->\n<html> <head>  \n<title>Regular_triangulation_2&lt;Traits,Tds&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_926\"></A>\n\n<A NAME=\"Cross_link_anchor_927\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_887\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Regular_triangulation_2<Traits,Tds>\"></A>\n<h2><I>CGAL::Regular_triangulation_2&lt;Traits,Tds&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits,Tds&gt;</I> \nis designed to maintain the\nregular triangulation of a set of weighted points.\n<P>\n\nLet <MATH><I>  PW = {(p<SUB>i</SUB>, w<SUB>i</SUB>), i = 1, ..., n }</I></MATH> be a set of \nweighted points where each <MATH><I>p<SUB>i</SUB></I></MATH> is a point and each <MATH><I>w<SUB>i</SUB></I></MATH>\nis a scalar called the weight of point <MATH><I>p<SUB>i</SUB></I></MATH>.\nAlternatively, each weighted point <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH> can be regarded\nas a two dimensional sphere with center <MATH><I>p<SUB>i</SUB></I></MATH> and radius <MATH><I>r<SUB>i</SUB>=<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(w<SUB>i</SUB>)</I></MATH>.\n<P>\n\nThe power diagram of the set <MATH><I>  PW</I></MATH> is a planar partition \nsuch that each cell corresponds to sphere <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH> of <MATH><I>  PW</I></MATH>\nand is the locus of points  <MATH><I>p</I></MATH> whose power with respect to <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>\nis less than its power with respect to any other sphere <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nin <MATH><I>  PW</I></MATH>. \nThe dual of this diagram is a triangulation \nwhose domain covers the convex hull of the set \n<MATH><I>  P= { p<SUB>i</SUB>, i = 1, ..., n }</I></MATH> of center points\nand whose vertices are a subset of <MATH><I>  P</I></MATH>.\nSuch a triangulation is called a regular triangulation.\nThe  three points <MATH><I>p<SUB>i</SUB>, p<SUB>j</SUB></I></MATH> and <MATH><I>p<SUB>k</SUB></I></MATH> of <MATH><I>  P</I></MATH>\nform a triangle in the regular triangulation of <MATH><I>  PW</I></MATH>\niff there is a point <MATH><I>p</I></MATH> of the plane whose\npowers with respect to <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nand <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH> are equal and less than the power of <MATH><I>p</I></MATH>\nwith respect to any other sphere in  <MATH><I>  PW</I></MATH>.\n<P>\n\nLet us defined the power product of two weighted points\n<MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH> and <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH> as:\n<P ALIGN=CENTER>\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUB>i</SUB>, w<SUB>i</SUB>,p<SUB>j</SUB>, w<SUB>j</SUB>) = p<SUB>i</SUB>p<SUB>j</SUB> <SUP>2</SUP> - w<SUB>i</SUB>  - w<SUB>j</SUB>  .</I></MATH>\n<P>\n\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUB>i</SUB>, w<SUB>i</SUB>,p<SUB>j</SUB>, 0)</I></MATH> is simply the power of point <MATH><I>p<SUB>j</SUB></I></MATH>\nwith respect to the sphere <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, and two weighted points \nare said to be orthogonal if their power product is null.\nThe power circle of three weighted points\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nand <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH> is defined as the unique circle\n<MATH><I>(<IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\">, <IMG BORDER=0 WIDTH=10 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_omega.gif\">)</I></MATH>  orthogonal to\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nand <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH>.\n<P>\n\nThe regular triangulation of the sets <MATH><I>  PW</I></MATH>\nsatisfies the following <I>regular property</I> (which just reduces to the \nDelaunay property when all the weights are null):\na triangle <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB></I></MATH> of the regular triangulation\nof <MATH><I>  PW</I></MATH> is such that the power product of any weighted point\n <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH> of <MATH><I>  PW</I></MATH> with the power circle of\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH> is <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH> is positive or null.\nWe call  power test of the weighted point <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH> with respect\nto the face  <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB></I></MATH>, the predicates testing\nthe <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of \nthe power product of <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH> with respect to\nthe power circle of\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH> is <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH>. This power product\nis given by the following\ndeterminant\n<P ALIGN=CENTER>\n<MATH><I>| \n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>i</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>i</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>i</SUB> <SUP>2</SUP> + y<SUB>i</SUB> <SUP>2</SUP> - w<SUB>i</SUB>  \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>j</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>j</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>j</SUB> <SUP>2</SUP> + y<SUB>j</SUB> <SUP>2</SUP> - w<SUB>j</SUB>  \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>k</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>k</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>k</SUB> <SUP>2</SUP> + y<SUB>k</SUB> <SUP>2</SUP> - w<SUB>k</SUB>  \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>l</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>l</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>l</SUB> <SUP>2</SUP> + y<SUB>l</SUB> <SUP>2</SUP> - w<SUB>l</SUB>\n\n</TD></TR></TABLE>\n\n|\n</I></MATH>\n<P>\n\nA pair of neighboring faces <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB></I></MATH>\nand <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>l</SUB></I></MATH> is said to be locally regular\n(with respect to  the weights in <MATH><I>  PW</I></MATH>)\nif the power test of <MATH><I>(p<SUB>l</SUB>,w<SUB>l</SUB>)</I></MATH> with respect to\n<MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB></I></MATH> is positive.\nA classical  result of computational geometry\nestablishes that a triangulation of the convex hull of <MATH><I>  P</I></MATH>\nsuch that any pair of neighboring faces is regular with respect\nto <MATH><I>  PW</I></MATH>, is a\n regular triangulation of <MATH><I>  PW</I></MATH>.\n<P>\n\nAlternatively, the regular triangulation\nof the weighted points set <MATH><I>  PW</I></MATH>\ncan be obtained as the projection\non the two dimensional plane of the convex hull of the set of three\ndimensional points \n<MATH><I>  P'= { (p<SUB>i</SUB>,p<SUB>i</SUB> <SUP>2</SUP> - w<SUB>i</SUB> ), i = 1, ..., n }</I></MATH>.\n<P>\n\nThe vertices of the regular triangulation\nof a set of weighted points <MATH><I>  PW</I></MATH> form only a subset\nof the set of center points of <MATH><I>   PW</I></MATH>.\nTherefore the  insertion of a weighted point  in a regular triangulation\ndoes not necessarily imply the creation of a new vertex.\nIf the new inserted point does not appear as a vertex in the\nregular triangulation, it is said to be hidden.\n<P>\n\nHidden points\nare  stored in special vertices called hidden vertices.\nA hidden point is considered as hidden by\nthe facet of the triangulation where its point component is located :\nin fact, the hidden point \ncan appear as vertex of the triangulation\nonly if this facet is removed.\nEach  face of a regular triangulation stores\nthe list of hidden vertices whose points are located in the facet.\nWhen a facet is removed, \npoints hidden by this facet are reinserted in the triangulation.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Regular_triangulation_2.h\">CGAL/Regular_triangulation_2.h</A>&gt;</I>\n<P>\n\n<H3>Parameters</H3>The geometric traits parameter <I>Traits</I>  has \nto be instantiated with a model of the concept\n<I><A HREF=\"Concept_RegularTriangulationTraits_2.html#Cross_link_anchor_924\">RegularTriangulationTraits_2</A></I>. \nThe concept <I><A HREF=\"Concept_RegularTriangulationTraits_2.html#Cross_link_anchor_924\">RegularTriangulationTraits_2</A></I> refines the\nconcept <I><A HREF=\"Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I> by adding the type\n<I>Weighted_point_2</I> to describe weighted points\nand the type <I>Power_test_2</I> to perform\npower tests on weighted points.\n<P>\n\nThe <I>Tds</I> parameter has to be instantiated by a model of\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I>. The face base of a regular\ntriangulation has to be a model of the concept\n<I><A HREF=\"Concept_RegularTriangulationFaceBase_2.html#Cross_link_anchor_923\">RegularTriangulationFaceBase_2</A></I>.  while\nthe vertex base class has to be a model\nof <I><A HREF=\"Concept_RegularTriangulationVertexBase_2.html#Cross_link_anchor_925\">RegularTriangulationVertexBase_2</A></I>.\nC<SMALL>GAL</SMALL> provides a default\ninstantiation for the <I>Tds</I> parameter by the class\n<I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A> &lt;                        CGAL::Reugular_triangulation_vertex_base_2&lt;Traits&gt;,                        CGAL::Regular_Triangulation_face_base_2&lt;Traits&gt; &gt;</I>.\n<P>\n\n<H3>Inherits From</H3><I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I>\n<P>\n\n<H3>Types</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Distance\"></A>\n<A NAME=\"Typedef_Distance\"></A>\ntypedef Traits::Distance\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Distance;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Line\"></A>\n<A NAME=\"Typedef_Line\"></A>\ntypedef Traits::Line\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Line;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Ray\"></A>\n<A NAME=\"Typedef_Ray\"></A>\ntypedef Traits::Ray\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Ray;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Bare_point\"></A>\n<A NAME=\"Typedef_Bare_point\"></A>\ntypedef Traits::Bare_point\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Bare_point;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Weighted_point\"></A>\n<A NAME=\"Typedef_Weighted_point\"></A>\ntypedef Traits::<A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits,Tds&gt;::All_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    An iterator that allows to enumerate the\nvertices that are not hidden.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits,Tds&gt;::Finite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    An iterator that allows to enumerate the\nfinite vertices that are not hidden.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits,Tds&gt;::Hidden_vertices_iterator;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    An iterator that allows to enumerate the\nhidden vertices.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits,Tds&gt; rt (  Traits gt = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Introduces an empty regular triangulation <I>rt</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits,Tds&gt; rt (  <A HREF=\"Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A> rt);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Copy constructor.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Insertion and Removal</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Weighted_point__p+_Face_handle_f=Face_handle699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p,<BR>\n\nFace_handle f=Face_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts  weighted point <I>p</I> in the regular triangulation.\nIf the point <I>p</I>  does not appear as a vertex of the triangulation,\nthe returned vertex is  a hidden vertex.\nIf given the parameter <I>f</I> is used as an hint\nfor the place to start the location process of point <I>p</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Weighted_point__p+_Locate_type_lt+_Face_handle_loc+_int_li_9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p,<BR>\n\n<A HREF=\"Enum_Triangulation_2-Traits-Tds---Locate_type#Enum_Locate_type\">Locate_type</A> lt,<BR>\n\nFace_handle loc,<BR>\n\nint li)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    insert a weighted point <I>p</I> whose bare-point is assumed to be\nlocated in  <I>lt,loc,li</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_push_back6const_Point__p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.push_back (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Equivalent to <I>insert(p)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_insert6InputIterator_first+_InputIterator_last9;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.insert ( InputIterator first,  InputIterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the weighted points in the range\n <MATH><I>[.</I></MATH><I>first</I>, <I>last</I><MATH><I>.)</I></MATH>.\n Returns the number of created vertices.<BR>\n\n<EM>Precondition: </EM>The <I>value_type</I> of <I>first</I> and <I>last</I>\n is <I><A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.remove ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the vertex from the triangulation.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Queries</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItFaces, class OutputItBoundaryEdges, class OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_CGAL::Triple6OutputItFaces+OutputItBoundaryEdges+OutputItHiddenVertices9_get_conflicts_and_boundary_and_hidden_vertices6const_Weighted_point__p+_OutputItFaces_fit+_OutputItBoundaryEdges_eit+_OutputItHiddenVertices_vit+_Face_handle_start9_const;\"></A>\n<A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1583\">CGAL::Triple</A>&lt;OutputItFaces,OutputItBoundaryEdges,OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_conflicts_and_boundary_and_hidden_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p,<BR>\n\nOutputItFaces fit,<BR>\n\nOutputItBoundaryEdges eit,<BR>\n\nOutputItHiddenVertices vit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>OutputItFaces</I> is an output iterator with <I>Face_handle</I> as\n  value type.  <I>OutputItBoundaryEdges</I> stands for an output\n  iterator with <I>Edge</I> as value type.\n  <I>OutputItHiddenVertices</I> is an output iterator with\n  <I>Vertex_handle</I> as value type.  This member function outputs in\n  the container pointed to by <I>fit</I> the faces which are in\n  conflict with point <I>p</I> i. e. the faces whose power circles\n  have negative power wrt. <I>p</I>.  It outputs in the container\n  pointed to by <I>eit</I> the boundary of the zone in conflict\n  with <I>p</I>.  It inserts the vertices that would be hidden by <I>p</I> \n  into the container pointed to by <I>vit</I>.  The boundary edges of\n  the conflict zone are ouput in counter-clockwise order and each edge\n  is described through its incident face which is not in conflict with\n  <I>p</I>.  The function returns in a <A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1583\">CGAL::Triple</A> the resulting output\n  iterators.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItFaces, class OutputItBoundaryEdges&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_std::pair6OutputItFaces+OutputItBoundaryEdges9_get_conflicts_and_boundary6const_Weighted_point__p+_OutputItFaces_fit+_OutputItBoundaryEdges_eit+_Face_handle_start9_const;\"></A>\nstd::pair&lt;OutputItFaces,OutputItBoundaryEdges&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_conflicts_and_boundary ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p,<BR>\n\nOutputItFaces fit,<BR>\n\nOutputItBoundaryEdges eit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above except that only the faces in conflict with <I>p</I> and \n  the boundary edges of the conflict zone \n  are output via the corresponding output iterators. The function returns \n  in a std::pair the resulting output iterators.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItFaces, class OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_std::pair6OutputItFaces+OutputItHiddenVertices9_get_conflicts_and_hidden_vertices6const_Weighted_point__p+_OutputItFaces_fit+_OutputItHiddenVertices_vit+_Face_handle_start9_const;\"></A>\nstd::pair&lt;OutputItFaces,OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_conflicts_and_hidden_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p,<BR>\n\nOutputItFaces fit,<BR>\n\nOutputItHiddenVertices vit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above except that only the faces in conflict with <I>p</I> and \n  the vertices that would be hidden by <I>p</I>\n  are output via the corresponding output iterators. The function returns \n  in a std::pair the resulting output iterators.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItBoundaryEdges, class OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_std::pair6OutputItBoundaryEdges+OutputItHiddenVertices9_get_boundary_of_conflicts_and_hidden_vertices6const_Weighted_point__p+_OutputItBoundaryEdges_eit+_OutputItHiddenVertices_vit+_Face_handle_start9_const;\"></A>\nstd::pair&lt;OutputItBoundaryEdges,OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_boundary_of_conflicts_and_hidden_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p,<BR>\n\nOutputItBoundaryEdges eit,<BR>\n\nOutputItHiddenVertices vit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above except that only the the vertices that would be hidden\n  by <I>p</I> and the boundary of the zone in conflict with <I>p</I> are\n  output via the corresponding output iterators. The boundary edges of\n  the conflict zone are ouput in counterclockwise order and each edge\n  is described through the incident face which is not in conflict with\n  <I>p</I>. The function returns in a std::pair the resulting output\n  iterators.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItFaces&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputItFaces_get_conflicts_6const_Point__p+_OutputItFaces_fit+_Face_handle_start9_const;\"></A>\nOutputItFaces\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_conflicts ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nOutputItFaces fit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above except that only the faces in conflict with <I>p</I>\nare output. The function returns the resulting output iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItBoundaryEdges&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_OutputItBoundaryEdges_get_boundary_of_conflicts6const_Point__p+_OutputItBoundaryEdges_eit+_Face_handle_start9_const;\"></A>\nOutputItBoundaryEdges\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_boundary_of_conflicts ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nOutputItBoundaryEdges eit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above except that only the boundary edges\nof the conflict zone are ouput in counterclockwise order\nwhere each edge is described  through the incident face\nwhich is not in conflict with <I>p</I>.\nThe function returns the resulting output iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputItHiddenVertices&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_OutputItHiddenVertices_get_hidden_vertices6const_Point__p+_OutputItHiddenVertices_vit+_Face_handle_start9_const;\"></A>\nOutputItHiddenVertices\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    rt.get_hidden_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nOutputItHiddenVertices vit,<BR>\n\nFace_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above except that only the vertices that would be hidden by  <I>p</I>\n          are output. The function returns the resulting output iterator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access functions</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_vertices69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.number_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of finite vertices that are not hidden.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_hidden_vertices69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.number_of_hidden_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of hidden vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Hidden_vertices_iterator_hidden_vertices_begin69_const;\"></A>\nHidden_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.hidden_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    starts at an arbitrary hidden vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Hidden_vertices_iterator_hidden_vertices_end69_const;\"></A>\nHidden_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.hidden_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past the end iterator for the sequence of hidden vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_vertices_iterator_finite_vertices_begin69_const;\"></A>\nFinite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.finite_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    starts at an arbitrary unhidden finite vertex\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Finite_vertices_iterator_finite_vertices_end69_const;\"></A>\nFinite_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.finite_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Past-the-end iterator\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator_all_vertices_end69_const;\"></A>\nAll_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.all_vertices_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    starts at an arbitrary unhidden vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_All_vertices_iterator_all_vertices_begin69_const;\"></A>\nAll_vertices_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.all_vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    past the end iterator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Dual power diagram</H3>\n \n     \n<A NAME=\"Index_anchor_888\"></A> \n \n   \n\nThe following member functions provide the elements of the\ndual power diagram.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_weighted_circumcenter6const_Face_handle__f9_const;\"></A>\nPoint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.weighted_circumcenter (  Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the center of the circle orthogonal to the three weighted\npoints corresponding to the vertices of face <I>f</I>.<BR>\n\n<EM>Precondition: </EM><I>f</I> is not infinite\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_dual6const_Face_handle__f9_const;\"></A>\nPoint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.dual (  Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as weighted_circumcenter\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Object_dual6const_Edge__e9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    rt.dual (  Edge e)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    If both incident faces are finite, returns a segment whose endpoints are the\nduals of each incident face. If only one incident face is finite, returns a\nray whose endpoint is the dual of the finite incident face and supported by\nthe line which is the <A HREF=\"../Kernel_23_ref/Function_bisector.html#Cross_link_anchor_161\">bisector</A> of the edge's endpoints. If both incident faces\nare infinite, returns the line which is the <A HREF=\"../Kernel_23_ref/Function_bisector.html#Cross_link_anchor_161\">bisector</A> of the edge's endpoints\notherwise.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Object_dual6const_Edge_circulator__ec9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.dual (  Edge_circulator ec)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Idem\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Object_dual6const_Edge_iterator__ei9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.dual (  Edge_iterator ei)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Idem\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class Stream&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Stream__draw_dual6Stream___ps9;\"></A>\nStream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.draw_dual ( Stream &amp; ps)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    output the dual power diagram to stream ps.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Oriented_side_power_test6Face_handle_f+_const_Weighted_point__p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Oriented_side.html#Cross_link_anchor_116\">Oriented_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.power_test ( Face_handle f,  <A HREF=\"Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the power test of  <I>p</I> with respect to the \npower circle  associated with <I>f</I>\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Miscellaneous</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6bool_verbose_=_false+_int_level_=_09_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    rt.is_valid ( bool verbose = false,  int level = 0)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests the validity of the triangulation as a <I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A></I>\nand additionally test the regularity of the triangulation. This method is\nuseful to debug regular triangulation algorithms implemented by\n the user.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>See Also</H3><I><A HREF=\"Class_Triangulation_2.html#Cross_link_anchor_938\">CGAL::Triangulation_2</A>&lt;Traits,Tds&gt;</I>,<BR>\n\n<I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I>,<BR>\n\n<I><A HREF=\"Concept_RegularTriangulationTraits_2.html#Cross_link_anchor_924\">RegularTriangulationTraits_2</A></I><BR>\n\n<I><A HREF=\"Concept_RegularTriangulationFaceBase_2.html#Cross_link_anchor_923\">RegularTriangulationFaceBase_2</A></I><BR>\n\n<I><A HREF=\"Concept_RegularTriangulationVertexBase_2.html#Cross_link_anchor_925\">RegularTriangulationVertexBase_2</A></I><BR>\n\n<I><A HREF=\"Class_Regular_triangulation_face_base_2.html#Cross_link_anchor_930\">CGAL::Regular_triangulation_face_base_2</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Regular_triangulation_vertex_base_2.html#Cross_link_anchor_932\">CGAL::Regular_triangulation_vertex_base_2</A>&lt;Traits&gt;</I>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Regular_triangulation_euclidean_traits_2.html\"><I>Regular_triangulation_euclidean_traits_2&lt;K,Weight&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_32!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39059.0}