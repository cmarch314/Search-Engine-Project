{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 57Intersecting Sequences of Iso oriented Boxes Lutz Kettner Andreas Meyer and Afra Zomorodian 57 1 Introduction Simple questions on geometric primitives such as intersection and distance computations can themselves become quite expensive if the primitives are not so simple anymore for example three dimensional triangles and facets of polyhedral surfaces Thus algorithms operating on these primitives tend to be slow in practice A common heuristic optimization approximates the geometric primitives with their axis aligned bounding boxes runs a suitable modification of the algorithm on the boxes and whenever a pair of boxes has an interesting interaction only then the exact answer is computed on the complicated geometric primitives contained in the boxes We provide an efficient algorithm ZE 2 for finding all intersecting pairs for large numbers of iso oriented boxes i e typically these will be such bounding boxes of more complicated geometries One immediate application of this algorithm is the detection of all intersections and self intersections for polyhedral surfaces i e applying the algorithm on a large set of triangles in space we give an example program later in this chapter Not so obvious applications are proximity queries and distance computations among such surfaces see Section for an example and ZE 2 for more details 57 2 Definition A d dimensional iso oriented box is defined as the Cartesian product of d intervals We call the box half open if the d intervals loi hii i d are half open intervals and we call the box closed if the d intervals loi hii i d are closed intervals Note that closed boxes support zero width boxes and they can intersect at their boundaries while non empty half open boxes always have a positive volume and they only intersect iff their interiors overlap The distinction between closed and half open boxes does not require a different representation of boxes just a different interpretation when comparing boxes which is selected with the two possible values for the topology parameter CGAL Box intersection d HALF OPEN and CGAL Box intersection d CLOSED The number type of the interval boundaries must be one of the builtin types int unsigned int double or float In addition a box has an unique id number It is used to order boxes consistently in each dimension even if boxes have identical coordinates In consequence the algorithm guarantees that a pair of intersecting boxes is reported only once Note that boxes with equal id number are not reported since they obviously intersect trivially The box intersection algorithm comes in two flavors One algorithm works on a single sequence of boxes and computes all pairwise intersections which is called the complete case and used for example in the self intersection test The other algorithm works on two sequences of boxes and computes the pairwise intersections between boxes from the first sequence with boxes from the second sequence which is called the bipartite case For each pairwise intersection found a callback function is called with two arguments the first argument is a box from the first sequence and the second argument a box from the second sequence In the complete case the second argument is a box from an internal copy of the first sequence 57 3 Software Design The box intersection algorithm is implemented as a family of generic functions the functions for the complete case accept one iterator range and the functions for the bipartite case accept two iterator ranges The callback function for reporting the intersecting pairs is provided as a template parameter of the BinaryFunction concept The two principle function calls utilizing all default arguments look as follows include CGAL box intersection d h template class RandomAccessIterator class Callback void box intersection d RandomAccessIterator begin RandomAccessIterator end Callback callback template class RandomAccessIterator1 class RandomAccessIterator2 class Callback void box intersection d RandomAccessIterator1 begin1 RandomAccessIterator1 end1 RandomAccessIterator2 begin2 RandomAccessIterator2 end2 Callback callback Additional parameters to the functions calls are a cutoff value to adjust performance tradeoffs and a topology parameter selecting between topologically closed boxes the default and topologically half open boxes The algorithm reorders the boxes in the course of the algorithm Now depending on the size of a box it can be faster to copy the boxes or to work with pointers to boxes and copy only pointers We offer automatic support for both options To simplify the description let us call the value type of the iterator ranges box handle The box handle can either be our box type itself or a pointer or const pointer to the box type these choices represent both options from above In general the algorithms treat the box type as opaque type and just assume that they are models of the Assignable concept so that the algorithms can modify the input sequences and reorder the boxes The access to the box dimension and box coordinates is mediated with a traits class of the BoxIntersectionTraits d concept A default traits class is provided that assumes that the box type is a model of the BoxIntersectionBox d concept and that the box handle i e the iterators value type is identical to the box type or a pointer to the box type see the previous paragraph for the value versus pointer nature of the box handle Two implementations of iso oriented boxes are provided CGAL Box intersection d Box d as a plain box and CGAL Box intersection d Box with handle d as a box plus a handle that can be used to point to the full geometry that is approximated by the box Both implementations have template parameters for the number type used for the interval bounds for the fixed dimension of the box and for a policy class Ale 1 selecting among several solutions for providing the id number The function signatures for the bipartite case look as follows The signatures for the complete case with the box self intersection d function look the same except for the single iterator range include CGAL box intersection d h template class RandomAccessIterator1 class RandomAccessIterator2 class Callback void box intersection d RandomAccessIterator1 begin1 RandomAccessIterator1 end1 RandomAccessIterator2 begin2 RandomAccessIterator2 end2 Callback callback std ptrdiff t cutoff 1 Box intersection d Topology topology Box intersection d CLOSED Box intersection d Setting setting Box intersection d BIPARTITE template class RandomAccessIterator1 class RandomAccessIterator2 class Callback class BoxTraits void box intersection d RandomAccessIterator1 begin1 RandomAccessIterator1 end1 RandomAccessIterator2 begin2 RandomAccessIterator2 end2 Callback callback BoxTraits box traits std ptrdiff cutoff 1 Box intersection d Topology topology Box intersection d CLOSED Box intersection d Setting setting Box intersection d BIPARTITE 57 4 Minimal Example for Intersecting Boxes The box implementation provided with CGAL Box intersection d Box d double 2 has a dedicated constructor for the CGAL bounding box type CGAL Bbox 2 similar for dimension 3 We use this in our minimal example to create easily nine two dimensional boxes in a grid layout of 3 3 boxes Additionally we pick the center box and the box in the upper right corner as our second box sequence query The default policy of the box type implements the id number with an explicit counter in the boxes which is the default choice since it always works but it costs space that could potentially be avoided see the example in the next section We use the id number in our callback function to report the result of the intersection algorithm The result will be that the first query box intersects all nine boxes and the second query box intersects the four boxes in the upper right quadrant See Section for the change of the topology parameter and its effect file examples Box intersection d minimal C include CGAL box intersection d h include CGAL Bbox 2 h include iostream typedef CGAL Box intersection d Box d double 2 Box typedef CGAL Bbox 2 Bbox 9 boxes of a grid Box boxes 9 Bbox 1 1 Bbox 1 2 1 Bbox 2 3 1 low Bbox 1 1 2 Bbox 1 1 2 2 Bbox 2 1 3 2 middle Bbox 2 1 3 Bbox 1 2 2 3 Bbox 2 2 3 3 upper 2 selected boxes as query center and upper right Box query 2 Bbox 1 1 2 2 Bbox 2 2 3 3 void callback const Box a const Box b std cout box a id intersects box b id std endl int main CGAL box intersection d boxes boxes 9 query query 2 callback return 57 5 Example for Finding Intersecting 3D Triangles The conventional application of the axis aligned box intersection algorithm will start from complex geometry here 3D triangles approximate them with their bounding box compute the intersecting pairs of boxes and check only for those if the original triangles intersect as well We start in the main function and create ten triangles with endpoints chosen randomly in a cube 1 1 3 We store the triangles in a vector called triangles Next we create a vector for the bounding boxes of the triangles called boxes For the boxes we choose the type Box with handle d double 3 Iterator that works nicely together with the CGAL bounding boxes of type CGAL Bbox 3 In addition each box stores the iterator to the corresponding triangle The default policy of this box type uses for the id number the address of the value of the iterator i e the address of the triangle This is a good choice that works correctly iff the boxes have unique iterators i e there is a one to one mapping between boxes and approximated geometry which is the case here It saves us the extra space that was needed for the explicit id number in the previous example We run the self intersection algorithm with the report inters function as callback This callback reports the intersecting boxes It uses the handle and the global triangles vector to calculate the triangle numbers Then it checks the triangles themselves for intersection and reports if not only the boxes but also the triangles intersect We take some precautions before the intersection test in order to avoid problems although unlikely with degenerate triangles that we might have created with the random process This example can be easily extended to test polyhedral surfaces of the Polyhedron 3 class for self intersections The main difference are the numerous cases of incidences between triangles in the polyhedral surface that should not be reported as intersections see the examples Polyhedron polyhedron self intersection C example program in the CGAL distribution file examples Box intersection d triangle self intersect C include CGAL Exact predicates inexact constructions kernel h include CGAL intersections h include CGAL point generators 3 h include CGAL Bbox 3 h include CGAL box intersection d h include CGAL function objects h include CGAL Join input iterator h include CGAL copy n h include vector typedef CGAL Exact predicates inexact constructions kernel Kernel typedef Kernel Point 3 Point 3 typedef Kernel Triangle 3 Triangle 3 typedef std vector Triangle 3 Triangles typedef Triangles iterator Iterator typedef CGAL Box intersection d Box with handle d double 3 Iterator Box Triangles triangles global vector of all triangles callback function that reports all truly intersecting triangles void report inters const Box a const Box b std cout Box a handle triangles begin and b handle triangles begin intersect if a handle is degenerate b handle is degenerate CGAL do intersect a handle b handle std cout and the triangles intersect also std cout std endl int main Create 1 random triangles typedef CGAL Random points in cube 3 Point 3 Pts typedef CGAL Creator uniform 3 Point 3 Triangle 3 Creator typedef CGAL Join input iterator 3 Pts Pts Pts Creator Triangle gen Pts points 1 in centered cube 1 1 3 Triangle gen triangle gen points points points CGAL copy n triangle gen 1 std back inserter triangles Create the corresponding vector of bounding boxes std vector Box boxes for Iterator i triangles begin i triangles end i boxes push back Box i bbox i Run the self intersection algorithm with all defaults CGAL box self intersection d boxes begin boxes end report inters return 57 6 Example for Using Pointers to Boxes We modify the previous example finding intersecting 3D triangles and add an additional vector ptr that stores pointers to the bounding boxes so that the intersection algorithm will work on a sequence of pointers and not on a sequence of boxes The change just affects the preparation of the additional vector and the call of the box intersection function The box intersection function actually its default traits class detects automatically that the value type of the iterators is a pointer type and not a class type Create the corresponding vector of pointers to bounding boxes std vector Box ptr for std vector Box iterator i boxes begin i boxes end i ptr push back i Run the self intersection algorithm with all defaults on the indirect pointers to bounding boxes Avoids copying the boxes CGAL box self intersection d ptr begin ptr end report inters In addition the callback function report inters needs to be changed to work with pointers to boxes See the following file for the full example program examples Box intersection d triangle self intersect pointers C A note on performance The algorithm sorts and partitions the input sequences It is clearly costly to copy a large box compared to a simple pointer However the algorithm benefits from memory locality in the later stages when it copies the boxes while the pointers would refer to boxes that become wildly scattered in memory These two effects copying costs and memory locality counteract each other For small box sizes i e small dimension memory locality wins and one should work with boxes while for larger box sizes one should work with pointers The exact threshold depends on the memory hierarchy caching of the hardware platform and the size of the boxes most notably the type used to represent the box coordinates A concrete example on a laptop with an Intel Mobile Pentium4 running at 1 8 GHz with 512KB cache and 254MB main memory under Linux this version with pointers was 2 faster than the version above that copies the boxes for 1 boxes but the picture reversed for 1 boxes where the version above that copies the boxes becomes 3 faster Note that switching to the builtin type float is supported by the box intersection algorithm but the interfacing with the CGAL bounding box CGAL Bbox 3 would not be that easy In particular just converting from the double to the float representation incurs rounding that needs to be controlled properly otherwise the box might shrink and one might miss intersections 57 7 Example Using the topology and the cutoff Parameters Boxes can be interpreted by the box intersection algorithm as closed or as half open boxes see also Section Closed boxes support zero width boxes and they can intersect at their boundaries while half open boxes always have a positive volume and they only intersect iff their interiors overlap The choice between closed or half open boxes is selected with the topology parameter and its two values CGAL Box intersection d HALF OPEN and CGAL Box intersection d CLOSED The example program uses a two dimensional box with int coordinates and id numbers that are by default explicitly stored We create the same boxes as in the minimal example in Section We create a 3 3 grid of boxes and two boxes for the query sequence namely the box at the center and the box from the upper right corner of the grid We write a more involved callback function object Report that stores an output iterator and writes the id number of the box in the first argument to the output iterator We also provide a small helper function report that simplifies the use of the function object We call the box intersection algorithm twice once for the default topology which is the closed box topology and once for the half open box topology We sort the resulting output for better readability and verify its correctness with the check1 and check2 data For the closed box topology the center box in query intersects all boxes and the upper right box in query intersects the four boxes of the upper right quadrant in boxes Almost all intersections are with the box boundaries thus for the half open topology only one intersection remains per query box namely its corresponding box in boxes So the output of the algorithm will be 1 2 3 4 4 5 5 6 7 7 8 8 4 8 For the second box intersection function call we have to specify the cutoff parameter explicitly See the Section below for a detailed discussion file examples Box intersection d box grid C include CGAL box intersection d h include vector include algorithm include iterator include assert h typedef CGAL Box intersection d Box d int 2 Box coordinates for 9 boxes of a grid int p 9 4 1 1 1 2 1 2 3 1 lower 1 1 2 1 1 2 2 2 1 3 2 middle 2 1 3 1 2 2 3 2 2 3 3 upper 9 boxes Box boxes 9 Box p p 2 Box p 4 p 6 Box p 8 p 1 Box p 12 p 14 Box p 16 p 18 Box p 2 p 22 Box p 24 p 26 Box p 28 p 3 Box p 32 p 34 2 selected boxes as query center and upper right Box query 2 Box p 16 p 18 Box p 32 p 34 callback function object writing results to an output iterator template class OutputIterator struct Report OutputIterator it Report OutputIterator i it i store iterator in object We write the id number of box a to the output iterator assuming that box b the query box is not interesting in the result void operator const Box a const Box it a id template class Iter helper function to create the function object Report Iter report Iter it return Report Iter it int main run the intersection algorithm and store results in a vector std vector std size t result CGAL box intersection d boxes boxes 9 query query 2 report std back inserter result sort check and show result std sort result begin result end std size t check1 13 1 2 3 4 4 5 5 6 7 7 8 8 assert result size 13 std equal check1 check1 13 result begin std copy result begin result end std ostream iterator std size t std cout std cout std endl run it again but for different cutoff value and half open boxes result clear CGAL box intersection d boxes boxes 9 query query 2 report std back inserter result std ptrdiff t 1 CGAL Box intersection d HALF OPEN sort check and show result std sort result begin result end std size t check2 2 4 8 assert result size 2 std equal check2 check2 2 result begin std copy result begin result end std ostream iterator std size t std cout std cout std endl return 57 8 Runtime Performance The implemented algorithm is described in ZE 2 as version two Its performance depends on a cutoff parameter When the size of both iterator ranges drops below the cutoff parameter the function switches from the streamed segment tree algorithm to the two way scan algorithm see ZE 2 for the details The streamed segment tree algorithm needs O n logd n k worst case running time and O n space where n is the number of boxes in both input sequences d the constant dimension of the boxes and k the output complexity i e the number of pairwise intersections of the boxes The two way scan algorithm needs O n log n l worst case running time and O n space where l is the number of pairwise overlapping intervals in one dimensions the dimension where the algorithm is used instead of the segment tree Note that l is not necessarily related to k and using the two way scan algorithm is a heuristic Unfortunately we have no general method to automatically determine an optimal cutoff parameter since it depends on the used hardware the runtime ratio between callback runtime and segment tree runtime and of course the number of boxes to be checked and their distribution In cases where the callback runtime is dominant it may be best to make the threshold parameter small Otherwise a cutoff sqrt n can lead to acceptable results For well distributed boxes the original paper ZE 2 gives optimal cutoffs in the thousands Anyway for optimal runtime some experiments to compare different cutoff parameters are recommended To demonstrate that box intersection can be done quite fast different box sequences are intersected in the range between 4 and 8 boxes total We use three dimensional default boxes of closed topology with float coordinates and without additional data fields The algorithm works directly on the boxes not on pointer to boxes Each box intersection is reported to an empty dummy callback For each box set a near optimal cutoff parameter is determined using an adaptive approximation The runtime required for streaming is compared against usual scanning Results on a Xeon 2 4GHz with 4GB main memory can be seen in Figure For a small number of boxes pure scanning is still faster than streaming with optimal cutoff which would just delegate the box sets to the scanning algorithm As there are more and more boxes the overhead becomes less important Figure Runtime comparison between the scanning and the streaming algorithm 57 9 Example Using a Custom Box Implementation The example in the previous Section uses an array to provide the coordinates and then creates another array for the boxes In the following example we write our own box class Box that we can initialize directly with the four coordinates and create the array of boxes directly We also omit the explicitly stored id number and use the address of the box itself as id number This works only if the boxes do not change their position i e we work with pointers to the boxes in the intersection algorithm We follow with our own box class Box the BoxIntersectionBox d concept which allows us to reuse the default traits implementation i e we can use the same default function call to compute all intersections See the example in the next section for a self written traits class So in principle the remainder of the example stays the same and we omit the part from the previous example for brevity that illustrates the half open box topology The requirements for the box implementation are best studied on page in the Reference Manual In a nutshell we have to define the type NT for the box coordinates and the type ID for the id number Member functions give access to the coordinates and the id number A static member function returns the dimension file examples Box intersection d custom box grid C include CGAL box intersection d h include vector include algorithm include iterator include assert h struct Box typedef int NT typedef std ptrdiff t ID int x 2 y 2 Box int x int x1 int y int y1 x x x 1 x1 y y y 1 y1 static int dimension return 2 int min coord int dim const return x dim int max coord int dim const return y dim id function using address of current box requires to work with pointers to boxes later std ptrdiff t id const return std ptrdiff t this 9 boxes of a grid Box boxes 9 Box 1 1 Box 1 2 1 Box 2 3 1 low Box 1 1 2 Box 1 1 2 2 Box 2 1 3 2 middle Box 2 1 3 Box 1 2 2 3 Box 2 2 3 3 upper 2 selected boxes as query center and upper right Box query 2 Box 1 1 2 2 Box 2 2 3 3 With the special id function we need to work on box pointers Box b ptr 9 boxes boxes 1 boxes 2 boxes 3 boxes 4 boxes 5 boxes 6 boxes 7 boxes 8 Box q ptr 2 query query 1 callback function object writing results to an output iterator template class OutputIterator struct Report OutputIterator it Report OutputIterator i it i store iterator in object We write the position with respect to boxes to the output iterator assuming that box b the query box is not interesting in the result void operator const Box a const Box it reinterpret cast Box a id boxes template class Iter helper function to create the function object Report Iter report Iter it return Report Iter it int main run the intersection algorithm and store results in a vector std vector std size t result CGAL box intersection d b ptr b ptr 9 q ptr q ptr 2 report std back inserter result std ptrdiff t sort and check result std sort result begin result end std size t chk 13 1 2 3 4 4 5 5 6 7 7 8 8 assert result size 13 std equal chk chk 13 result begin return 57 1 Example for Point Proximity Search with a Custom Traits Class Given a set of 3D points we want to find all pairs of points that are less than a certain distance apart We use the box intersection algorithm to find good candidates namely those that are less than this specified distance apart in the L norm which is a good approximation of the Euclidean norm We use an unusual representation for the box namely pointers to the 3D points themselves We implement a special box traits class that interprets the point as a box of the dimensions eps eps 3 centered at this point The value for eps is half the specified distance from above i e points are reported if their distance is smaller than 2 eps The requirements for the box traits class are best studied on page in the Reference Manual In a nutshell we have to define the type NT for the box coordinates the type ID for the id number and the type Box parameter similar to the box handle here Point 3 since we work with the pointers All member functions in the traits class are static Two functions give access to the max and min coordinates that we compute from the point coordinates plus or minus the eps value respectively For the id number function the address of the point itself is sufficient since the points stay stable Another function returns the dimension The report callback function computes than the Euclidean distance and prints a message for points that are close enough Note that we need to reserve sufficient space in the points vector to avoid reallocations while we create the points vector and the boxes vector in parallel since otherwise the points vector might reallocate and invalidate all pointers stored in the boxes so far file examples Box intersection d proximity custom box traits C include CGAL Simple cartesian h include CGAL box intersection d h include CGAL point generators 3 h include CGAL copy n h include vector include algorithm include iterator typedef CGAL Simple cartesian float Kernel typedef Kernel Point 3 Point 3 typedef CGAL Random points on sphere 3 Point 3 Points on sphere std vector Point 3 points std vector Point 3 boxes boxes are just pointers to points const float eps 1 finds point pairs of distance 2 eps Boxes are just pointers to 3d points The traits class adds the eps size to each interval around the point effectively building on the fly a box of size 2 eps centered at the point struct Traits typedef float NT typedef Point 3 Box parameter typedef std ptrdiff t ID static int dimension return 3 static float coord Box parameter b int d return d b x d 1 b y b z static float min coord Box parameter b int d return coord b d eps static float max coord Box parameter b int d return coord b d eps id function using address of current box requires to work with pointers to boxes later static std ptrdiff t id Box parameter b return std ptrdiff t b callback function reports pairs in close proximity void report const Point 3 a const Point 3 b float dist sqrt CGAL squared distance a b if dist 2 eps std cout Point a points front and Point b points front have distance dist std endl int main create some random points on the sphere of radius 1 Points on sphere generator 1 points reserve 5 for int i i 5 i points push back generator boxes push back points back run the intersection algorithm and report proximity pairs CGAL box self intersection d boxes begin boxes end report Traits return 57 11 Design and Implementation History Lutz Kettner and Andreas Meyer implemented the algorithms starting from the publication ZE 2 We had access to the original C implementation of Afra Zomorodian which helped clarifying some questions and we are grateful to the help of Afra Zomorodian in answering our questions during his visit We thank Steve Robbins for an excellent review for this package Steve Robbins provided an independent and earlier implementation of this algorithm however we learned too late about this implementation Next chapter Intersecting Sequences of Iso oriented Boxes Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Box_intersection_d/Chapter_main.html", "title": "intersecting sequences of iso-oriented boxes", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Box_intersection_d/main.tex' -->\n<html> <head>  \n<title>Intersecting Sequences of Iso-oriented Boxes</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_57\"></a>\n  \n<h1>Chapter 57<BR>Intersecting Sequences of Iso-oriented Boxes</h1>\n\n<A NAME=\"chapterBoxIntersection\"></A>\n\n<EM>Lutz Kettner, Andreas Meyer, and Afra Zomorodian</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>57.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nSimple questions on geometric primitives, such as <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> and\ndistance computations, can themselves become quite expensive if the\nprimitives are not so simple anymore, for example, three-dimensional\ntriangles and facets of polyhedral surfaces. Thus algorithms operating\non these primitives tend to be slow in practice. A common (heuristic)\noptimization approximates the geometric primitives with their\naxis-aligned bounding boxes, runs a suitable modification of the\nalgorithm on the boxes, and whenever a pair of boxes has an\ninteresting interaction, only then the exact answer is computed on the\ncomplicated geometric primitives contained in the boxes.\n<P>\n\n<CENTER>\n        <img src=\"./fig/box_inters.gif\" alt=\"Two intersecting curves with\n        approximating boxes.\">\n<P>\n\n</CENTER>\n<P>\n\nWe provide an efficient algorithm&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>] for finding all\nintersecting pairs for large numbers of iso-oriented boxes, i.e.,\ntypically these will be such bounding boxes of more complicated geometries.\nOne immediate application of this algorithm is the detection of all\nintersections (and self-intersections) for polyhedral surfaces, i.e.,\napplying the algorithm on a large set of triangles in space, we give\nan example program later in this chapter. Not so obvious applications\nare proximity queries and distance computations among such surfaces,\nsee Section&nbsp;<A HREF=\"Chapter_main.html#sec:box_inters_example_proximity\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for an example\nand&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>] for more details.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>57.2&nbsp;&nbsp;&nbsp;Definition</h2>\n<A NAME=\"sec:box-inters-def\"></A>\n<P>\n\nA <MATH><I>d</I></MATH>-dimensional iso-oriented box is defined as the <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> product\nof <MATH><I>d</I></MATH> intervals. We call the box <I>half-open</I> if the <MATH><I>d</I></MATH>\nintervals <MATH><I>{ [lo<SUB>i</SUB>,hi<SUB>i</SUB>) | 0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i &lt; d}</I></MATH> are half-open intervals,\nand we call the box <I>closed</I> if the <MATH><I>d</I></MATH> intervals <MATH><I>{ [lo<SUB>i</SUB>,hi<SUB>i</SUB>]\n| 0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i &lt; d}</I></MATH> are closed intervals. Note that closed boxes support\nzero-width boxes and they can intersect at their boundaries, while\nnon-empty half-open boxes always have a positive <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> and they only\nintersect iff their interiors overlap.  The distinction between closed\nand half-open boxes does not require a different representation of\nboxes, just a different interpretation when comparing boxes, which is\nselected with the two possible values for the <I>topology</I> parameter:\n<P>\n\n<UL>\n  <LI><I>CGAL::Box_intersection_d::HALF_OPEN</I> and\n  <LI><I>CGAL::Box_intersection_d::CLOSED</I>.\n</UL>\n<P>\n\nThe number type of the interval boundaries must be one of the builtin\ntypes <TT>int</TT>, <TT>unsigned int</TT>, <TT>double</TT> or\n<TT>float</TT>.\n<P>\n\nIn addition, a box has an unique <I>id</I>-number. It is used to order\nboxes consistently in each dimension even if boxes have identical\ncoordinates. In consequence, the algorithm guarantees that a pair of\nintersecting boxes is reported only once. Note that boxes with equal\n<I>id</I>-number are not reported since they obviously intersect trivially.\n<P>\n\nThe box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm comes in two flavors: One algorithm\nworks on a single sequence of boxes and computes all pairwise\nintersections, which is called the <I>complete</I> case, and used,\nfor example, in the self-<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> test. The other algorithm works\non two sequences of boxes and computes the pairwise intersections\nbetween boxes from the first sequence with boxes from the second\nsequence, which is called the <I>bipartite</I> case. For each\npairwise <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> found a callback function is called with two\narguments; the first argument is a box from the first sequence and the\nsecond argument a box from the second sequence. In the complete case,\nthe second argument is a box from an internal copy of the first\nsequence.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>57.3&nbsp;&nbsp;&nbsp;Software Design</h2>\n<P>\n\nThe box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm is implemented as a family of generic\nfunctions; the functions for the complete case accept one iterator\nrange, and the functions for the bipartite case accept two iterator\nranges. The callback function for reporting the intersecting pairs is\nprovided as a template parameter of the <I>BinaryFunction</I> concept.\nThe two principle function calls utilizing all default arguments look\nas follows:\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/box_intersection_d.h\">CGAL/box_intersection_d.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator, class Callback &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_intersection_d6_RandomAccessIterator_begin+_RandomAccessIterator_end+_Callback_callback9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator begin,<BR>\n\nRandomAccessIterator end,<BR>\n\nCallback callback)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator1, class RandomAccessIterator2, class Callback &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_intersection_d6_RandomAccessIterator1_begin1+_RandomAccessIterator1_end1+_RandomAccessIterator2_begin2+_RandomAccessIterator2_end2+_Callback_callback9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator1 begin1,<BR>\n\nRandomAccessIterator1 end1,<BR>\n\nRandomAccessIterator2 begin2,<BR>\n\nRandomAccessIterator2 end2,<BR>\n\nCallback callback)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\nAdditional parameters to the functions calls are a <I>cutoff</I>\nvalue to adjust performance tradeoffs, and a <I>topology</I> parameter\nselecting between topologically closed boxes (the default) and\ntopologically half-open boxes.\n<P>\n\nThe algorithm reorders the boxes in the course of the algorithm. Now,\ndepending on the size of a box it can be faster to copy the boxes, or\nto work with pointers to boxes and copy only pointers. We offer\nautomatic support for both options. To simplify the description, let us\ncall the <I>value_type</I> of the iterator ranges <I>box handle</I>.\nThe <I>box handle</I> can either be our box type itself or a\npointer (or const pointer) to the box type; these choices represent\nboth options from above.\n<P>\n\nIn general, the algorithms treat the box type as opaque type and just\nassume that they are models of the <I>Assignable</I> concept, so that\nthe algorithms can modify the input sequences and reorder the boxes.\nThe access to the box dimension and box coordinates is mediated with a\ntraits class of the <I><A HREF=\"../Box_intersection_d_ref/Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I> concept. A default\ntraits class is provided that assumes that the box type is a model of\nthe <I><A HREF=\"../Box_intersection_d_ref/Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I> concept and that the box handle, i.e.,\nthe iterators value type, is identical to the box type or a pointer\nto the box type (see the previous paragraph for the value versus\npointer nature of the box handle).\n<P>\n\nTwo implementations of iso-oriented boxes are provided;\n<I><A HREF=\"../Box_intersection_d_ref/Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A></I> as a plain box, and\n<I><A HREF=\"../Box_intersection_d_ref/Class_Box_intersection_d--Box_with_handle_d.html#Cross_link_anchor_1247\">CGAL::Box_intersection_d::Box_with_handle_d</A></I> as a box plus a\nhandle that can be used to point to the full geometry that is\napproximated by the box. Both implementations have template parameters\nfor the number type used for the interval bounds, for the fixed\ndimension of the box, and for a policy class&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:a-mcdgp-01\">Ale01</A>]\nselecting among several solutions for providing the <I>id</I>-number.\n<P>\n\nThe function signatures for the bipartite case look as follows. The \nsignatures for the complete case with the <I><A HREF=\"../Box_intersection_d_ref/Function_box_self_intersection_d.html#Cross_link_anchor_1238\">box_self_intersection_d</A></I>\nfunction look the same except for the single iterator range.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/box_intersection_d.h\">CGAL/box_intersection_d.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator1, class RandomAccessIterator2, class Callback &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_intersection_d6_RandomAccessIterator1_begin1+_RandomAccessIterator1_end1+_RandomAccessIterator2_begin2+_RandomAccessIterator2_end2+_Callback_callback+_std::ptrdiff_t_cutoff_=_10+_Box_intersection_d::Topology_topology_=_Box_intersection_d::CLOSED+_Box_intersection_d::Setting_setting_=_Box_intersection_d::BIPARTITE9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator1 begin1,<BR>\n\nRandomAccessIterator1 end1,<BR>\n\nRandomAccessIterator2 begin2,<BR>\n\nRandomAccessIterator2 end2,<BR>\n\nCallback callback,<BR>\n\nstd::ptrdiff_t cutoff = 10,<BR>\n\nBox_intersection_d::Topology topology = Box_intersection_d::CLOSED,<BR>\n\nBox_intersection_d::Setting setting = Box_intersection_d::BIPARTITE)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator1, class RandomAccessIterator2, class Callback, class BoxTraits &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_intersection_d6_RandomAccessIterator1_begin1+_RandomAccessIterator1_end1+_RandomAccessIterator2_begin2+_RandomAccessIterator2_end2+_Callback_callback+_BoxTraits_box_traits+_std::ptrdiff_cutoff_=_10+_Box_intersection_d::Topology_topology_=_Box_intersection_d::CLOSED+_Box_intersection_d::Setting_setting_=_Box_intersection_d::BIPARTITE9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator1 begin1,<BR>\n\nRandomAccessIterator1 end1,<BR>\n\nRandomAccessIterator2 begin2,<BR>\n\nRandomAccessIterator2 end2,<BR>\n\nCallback callback,<BR>\n\nBoxTraits box_traits,<BR>\n\nstd::ptrdiff cutoff = 10,<BR>\n\nBox_intersection_d::Topology topology = Box_intersection_d::CLOSED,<BR>\n\nBox_intersection_d::Setting setting = Box_intersection_d::BIPARTITE)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>57.4&nbsp;&nbsp;&nbsp;Minimal Example for Intersecting Boxes</h2>\n\n<A NAME=\"sec:box-intersect-minimal\"></A>\n<P>\n\nThe box implementation provided with\n<I><A HREF=\"../Box_intersection_d_ref/Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;double,2&gt;</I> has a dedicated\nconstructor for the C<SMALL>GAL</SMALL> bounding box type <I><A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_41\">CGAL::Bbox_2</A></I>\n(similar for dimension 3). We use this in our minimal example to\ncreate easily nine two-dimensional <I>boxes</I> in a grid layout of <MATH><I>3\n &times; 3</I></MATH> boxes. Additionally we pick the center box and the box in\nthe upper-right corner as our second box sequence <I>query</I>.\n<P>\n\nThe default policy of the box type implements the <I>id</I>-number with\nan explicit counter in the boxes, which is the default choice since it\nalways works, but it costs space that could potentially be avoided,\nsee the example in the next section. We use the <I>id</I>-number in our\ncallback function to report the result of the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm.\nThe result will be that the first <I>query</I> box intersects all nine\n<I>boxes</I> and the second <I>query</I> box intersects the four boxes\nin the upper-right quadrant. See Section&nbsp;<A HREF=\"Chapter_main.html#sec:box-inters-params\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\nfor the change of the <I>topology</I> parameter and its effect.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/minimal.C\n#include &lt;CGAL/<A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_42\">Bbox_2</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Box_intersection_d_ref/Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;double,2&gt; Box;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_41\">CGAL::Bbox_2</A>                              Bbox;\n                                                     // 9 boxes of a grid\nBox boxes[9] = { Bbox( 0,0,1,1), Bbox( 1,0,2,1), Bbox( 2,0,3,1), // low\n                 Bbox( 0,1,1,2), Bbox( 1,1,2,2), Bbox( 2,1,3,2), // middle\n                 Bbox( 0,2,1,3), Bbox( 1,2,2,3), Bbox( 2,2,3,3)};// upper\n// 2 selected boxes as query; center and upper right\nBox query[2] = { Bbox( 1,1,2,2), Bbox( 2,2,3,3)};\n\nvoid callback( const Box&amp; a, const Box&amp; b ) {\n    std::cout &lt;&lt; &quot;box &quot; &lt;&lt; a.id() &lt;&lt; &quot; intersects box &quot; &lt;&lt; b.id() &lt;&lt; std::endl;\n}\nint main() {\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A>( boxes, boxes+9, query, query+2, callback);\n    return 0;\n}\n\n</pre>\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>57.5&nbsp;&nbsp;&nbsp;Example for Finding Intersecting 3D Triangles</h2>\n<P>\n\nThe conventional application of the axis-aligned box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\nalgorithm will start from complex geometry, here 3D triangles,\napproximate them with their bounding box, compute the intersecting\npairs of boxes, and check only for those if the original triangles\nintersect as well.\n<P>\n\nWe start in the <I>main</I> function and create ten triangles with\nendpoints chosen randomly in a cube <MATH><I>[-1,+1)<SUP>3</SUP></I></MATH>. We store the\ntriangles in a vector called <I>triangles</I>.\n<P>\n\nNext we create a vector for the bounding boxes of the triangles called\n<I>boxes</I>. For the boxes we choose the type\n<I>Box_with_handle_d&lt;double,3,Iterator&gt;</I> that works nicely together\nwith the C<SMALL>GAL</SMALL> bounding boxes of type <I><A HREF=\"../Kernel_23_ref/Class_Bbox_3.html#Cross_link_anchor_61\">CGAL::Bbox_3</A></I>. In\naddition, each box stores the iterator to the corresponding triangle.\n<P>\n\nThe default policy of this box type uses for the <I>id</I>-number the \naddress of the value of the iterator, i.e., the address of the\ntriangle. This is a good choice that works correctly iff the boxes\nhave unique iterators, i.e., there is a one-to-one mapping between\nboxes and approximated geometry, which is the case here. It saves us\nthe extra space that was needed for the explicit <I>id</I>-number in\nthe previous example.\n<P>\n\nWe run the self <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm with the <I>report_inters</I>\nfunction as callback. This callback reports the intersecting boxes. It\nuses the <I>handle</I> and the global <I>triangles</I> vector to\ncalculate the triangle numbers. Then it checks the triangles\nthemselves for <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> and reports if not only the boxes but also\nthe triangles intersect. We take some precautions before the\n<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> test in order to avoid problems, although unlikely, with\ndegenerate triangles that we might have created with the random\nprocess.\n<P>\n\nThis example can be easily extended to test polyhedral surfaces of the\n<I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> class for (self-) intersections. The main\ndifference are the numerous cases of incidences between triangles in\nthe polyhedral surface that should not be reported as intersections,\nsee the <TT>examples/Polyhedron/polyhedron_self_intersection.C</TT>\nexample program in the C<SMALL>GAL</SMALL> distribution.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/triangle_self_intersect.C\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/intersections.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Bbox_3.html#Cross_link_anchor_62\">Bbox_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;CGAL/function_objects.h&gt;\n#include &lt;CGAL/Join_input_iterator.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n#include &lt;vector&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A>   <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                                       <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Triangle_3.html#Cross_link_anchor_472\">Kernel::Triangle_3</A>                                    <A HREF=\"../Kernel_23_ref/Class_Triangle_3.html#Cross_link_anchor_84\">Triangle_3</A>;\ntypedef std::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Triangle_3.html#Cross_link_anchor_84\">Triangle_3</A>&gt;                               Triangles;\ntypedef Triangles::iterator                                   Iterator;\ntypedef <A HREF=\"../Box_intersection_d_ref/Class_Box_intersection_d--Box_with_handle_d.html#Cross_link_anchor_1247\">CGAL::Box_intersection_d::Box_with_handle_d</A>&lt;double,3,Iterator&gt; Box;\n\nTriangles triangles; // global vector of all triangles\n\n// callback function that reports all truly intersecting triangles\nvoid report_inters( const Box&amp; a, const Box&amp; b) {\n    std::cout &lt;&lt; &quot;Box &quot; &lt;&lt; (a.handle() - triangles.begin()) &lt;&lt; &quot; and &quot;\n              &lt;&lt; (b.handle() - triangles.begin()) &lt;&lt; &quot; intersect&quot;;\n    if ( ! a.handle()-&gt;is_degenerate() &amp;&amp; ! b.handle()-&gt;is_degenerate()\n         &amp;&amp; <A HREF=\"../Kernel_23_ref/Function_do_intersect.html#Cross_link_anchor_204\">CGAL::do_intersect</A>( *(a.handle()), *(b.handle()))) {\n        std::cout &lt;&lt; &quot;, and the triangles intersect also&quot;;\n    }\n    std::cout &lt;&lt; '.' &lt;&lt; std::endl;\n}\n\nint main() {\n    // Create 10 random triangles\n    typedef <A HREF=\"../Generator_ref/Class_Random_points_in_cube_3.html#Cross_link_anchor_1693\">CGAL::Random_points_in_cube_3</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;           Pts;\n    typedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_3.html#Cross_link_anchor_1567\">CGAL::Creator_uniform_3</A>&lt; <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>, <A HREF=\"../Kernel_23_ref/Class_Triangle_3.html#Cross_link_anchor_84\">Triangle_3</A>&gt;    Creator;\n    typedef CGAL::Join_input_iterator_3&lt;Pts,Pts,Pts,Creator&gt; Triangle_gen;\n    Pts    points( 1); // in centered cube [-1,1)^3\n    Triangle_gen triangle_gen( points, points, points);\n    <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( triangle_gen, 10, std::back_inserter(triangles));\n\n    // Create the corresponding vector of bounding boxes\n    std::vector&lt;Box&gt; boxes;\n    for ( Iterator i = triangles.begin(); i != triangles.end(); ++i)\n        boxes.push_back( Box( i-&gt;bbox(), i));\n    \n    // Run the self <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm with all defaults\n    <A HREF=\"../Box_intersection_d_ref/Function_box_self_intersection_d.html#Cross_link_anchor_1237\">CGAL::box_self_intersection_d</A>( boxes.begin(), boxes.end(), report_inters);\n    return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>57.6&nbsp;&nbsp;&nbsp;Example for Using Pointers to Boxes</h2>\n<P>\n\nWe modify the previous example, finding intersecting 3D triangles,\nand add an additional vector <I>ptr</I> that stores pointers to the bounding\nboxes, so that the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm will work on a sequence of\npointers and not on a sequence of boxes. The change just affects the\npreparation of the additional vector and the call of the box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\nfunction. The box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> function (actually its default traits\nclass) detects automatically that the value type of the iterators is a\npointer type and not a class type.\n<P>\n\n<pre class=\"ExampleCode\">\n    // Create the corresponding vector of pointers to bounding boxes\n    std::vector&lt;Box *&gt; ptr;\n    for ( std::vector&lt;Box&gt;::iterator i = boxes.begin(); i != boxes.end(); ++i)\n        ptr.push_back( &amp;*i);\n    \n    // Run the self <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm with all defaults on the \n    // indirect pointers to bounding boxes. Avoids copying the boxes.\n    <A HREF=\"../Box_intersection_d_ref/Function_box_self_intersection_d.html#Cross_link_anchor_1237\">CGAL::box_self_intersection_d</A>( ptr.begin(), ptr.end(), report_inters);\n</pre>\n<P>\n\nIn addition, the callback function <I>report_inters</I> needs to be\nchanged to work with pointers to boxes. See the following file for the\nfull example program.\n<P>\n\n<pre class=\"ExampleCode\">\n    examples/Box_intersection_d/triangle_self_intersect_pointers.C\n</pre>\n<P>\n\nA note on performance: The algorithm sorts and partitions the input\nsequences. It is clearly costly to copy a large box compared to a\nsimple pointer. However, the algorithm benefits from memory locality\nin the later stages when it copies the boxes, while the pointers would\nrefer to boxes that become wildly scattered in memory.  These two\neffects, copying costs and memory locality, counteract each other. For\nsmall box sizes, i.e., small dimension, memory locality wins and one\nshould work with boxes, while for larger box sizes one should work\nwith pointers. The exact threshold depends on the memory hierarchy\n(caching) of the hardware platform and the size of the boxes, most\nnotably the type used to represent the box coordinates. A concrete\nexample; on a laptop with an Intel Mobile Pentium4 running at 1.80GHz\nwith 512KB cache and 254MB main memory under Linux this version with\npointers was 20% faster than the version above that copies the boxes\nfor 10000 boxes, but the picture reversed for 100000 boxes, where the\nversion above that copies the boxes becomes 300% faster.\n<P>\n\nNote that switching to the builtin type <I>float</I> is supported by\nthe box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm, but the interfacing with the C<SMALL>GAL</SMALL> \nbounding box <I><A HREF=\"../Kernel_23_ref/Class_Bbox_3.html#Cross_link_anchor_61\">CGAL::Bbox_3</A></I> would not be that easy. In particular,\njust converting from the <I>double</I> to the <I>float</I>\nrepresentation incurs rounding that needs to be controlled properly,\notherwise the box might shrink and one might miss intersections.\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>57.7&nbsp;&nbsp;&nbsp;Example Using the <I>topology</I> and the <I>cutoff</I> \nParameters</h2>\n<A NAME=\"sec:box-inters-params\"></A>\n<P>\n\nBoxes can be interpreted by the box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm as closed\nor as half-open boxes, see also Section&nbsp;<A HREF=\"Chapter_main.html#sec:box-inters-def\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.  Closed\nboxes support zero-width boxes and they can intersect at their\nboundaries, while half-open boxes always have a positive <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> and\nthey only intersect iff their interiors overlap.  The choice between\nclosed or half-open boxes is selected with the <I>topology</I>\nparameter and its two values:\n<P>\n\n<UL>\n  <LI><I>CGAL::Box_intersection_d::HALF_OPEN</I> and\n  <LI><I>CGAL::Box_intersection_d::CLOSED</I>.\n</UL>\n<P>\n\nThe example program uses a two-dimensional box with <I>int</I>\ncoordinates and <I>id</I>-numbers that are by default explicitly\nstored. We create the same boxes as in the minimal example in\nSection&nbsp;<A HREF=\"Chapter_main.html#sec:box-intersect-minimal\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. We create a <MATH><I>3  &times; 3</I></MATH> grid\nof <I>boxes</I>, and two boxes for the <I>query</I> sequence, namely the\nbox at the center and the box from the upper-right corner of the grid.\n<P>\n\nWe write a more involved callback function object <I>Report</I> that\nstores an output iterator and writes the <I>id</I>-number of the \nbox in the first argument to the output iterator. We also provide a\nsmall helper function <I>report</I> that simplifies the use of the function\nobject.\n<P>\n\nWe call the box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm twice; once for the default\n<I>topology</I>, which is the closed box topology, and once for the\nhalf-open box topology. We sort the resulting output for better\nreadability and verify its correctness with the <I>check1</I> and\n<I>check2</I> data.  For the closed box topology, the center box in\n<I>query</I> intersects all <I>boxes</I>, and the upper-right box in\n<I>query</I> intersects the four boxes of the upper-right quadrant in\n<I>boxes</I>. Almost all intersections are with the box boundaries,\nthus, for the half-open topology only one <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> remains per\n<I>query</I> box, namely its corresponding box in <I>boxes</I>. So, the\noutput of the algorithm will be:\n<P>\n\n<pre class=\"Verbatim\">\n    0 1 2 3 4 4 5 5 6 7 7 8 8 \n    4 8 \n</pre>\n<P>\n\nFor the second box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> function call we have to specify the\n<I>cutoff</I> parameter explicitly. See the\nSection&nbsp;<A HREF=\"Chapter_main.html#sec:box-inters-performance\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> below for a detailed\ndiscussion.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/box_grid.C\n#include &lt;CGAL/<A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;assert.h&gt;\n\ntypedef <A HREF=\"../Box_intersection_d_ref/Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;int,2&gt; Box;\n\n// coordinates for 9 boxes of a grid\nint p[9*4]   = { 0,0,1,1,  1,0,2,1,  2,0,3,1, // lower\n                 0,1,1,2,  1,1,2,2,  2,1,3,2, // middle\n                 0,2,1,3,  1,2,2,3,  2,2,3,3};// upper\n// 9 boxes\nBox boxes[9] = { Box( p,    p+ 2),  Box( p+ 4, p+ 6),  Box( p+ 8, p+10),\n                 Box( p+12, p+14),  Box( p+16, p+18),  Box( p+20, p+22),\n                 Box( p+24, p+26),  Box( p+28, p+30),  Box( p+32, p+34)};\n// 2 selected boxes as query; center and upper right\nBox query[2] = { Box( p+16, p+18),  Box( p+32, p+34)};\n\n// callback function object writing results to an output iterator\ntemplate &lt;class OutputIterator&gt;\nstruct Report {\n    OutputIterator it;\n    Report( OutputIterator i) : it(i) {} // store iterator in object\n    // We write the id-number of box a to the output iterator assuming\n    // that box b (the query box) is not interesting in the result.\n    void operator()( const Box&amp; a, const Box&amp;) { *it++ = a.id(); }\n};\ntemplate &lt;class Iter&gt; // helper function to create the function object\nReport&lt;Iter&gt; report( Iter it) { return Report&lt;Iter&gt;(it); }\n\nint main() {\n    // run the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm and store results in a vector\n    std::vector&lt;std::size_t&gt; result;\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A>( boxes, boxes+9, query, query+2, \n                              report( std::back_inserter( result)));\n    // sort, check, and show result\n    std::sort( result.begin(), result.end());\n    std::size_t check1[13] = {0,1,2,3,4,4,5,5,6,7,7,8,8};\n    assert(result.size() == 13 &amp;&amp; std::equal(check1,check1+13,result.begin()));\n    std::copy( result.begin(), result.end(), \n               std::ostream_iterator&lt;std::size_t&gt;( std::cout, &quot; &quot;));\n    std::cout &lt;&lt; std::endl;\n\n    // run it again but for different cutoff value and half-open boxes\n    result.clear();\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A>( boxes, boxes+9, query, query+2, \n                              report( std::back_inserter( result)),\n                              std::ptrdiff_t(1), \n                              CGAL::Box_intersection_d::HALF_OPEN);\n    // sort, check, and show result\n    std::sort( result.begin(), result.end());\n    std::size_t check2[2]  = {4,8};\n    assert(result.size() == 2 &amp;&amp; std::equal(check2, check2+2, result.begin()));\n    std::copy( result.begin(), result.end(), \n               std::ostream_iterator&lt;std::size_t&gt;( std::cout, &quot; &quot;));\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_8\"></a>\n        \n<h2>57.8&nbsp;&nbsp;&nbsp;Runtime Performance</h2>\n<A NAME=\"sec:box-inters-performance\"></A>\n<P>\n\nThe implemented algorithm is described in&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>] as\nversion two.  Its performance depends on a <I>cutoff</I> parameter.\nWhen the size of both iterator ranges drops below the <I>cutoff</I>\nparameter the function switches from the streamed segment-tree\nalgorithm to the two-way-scan algorithm, see&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>]\nfor the details.\n<P>\n\nThe streamed segment-tree algorithm needs <MATH><I>O(n </I></MATH>log<MATH><I><SUP>d</SUP> (n) + k)</I></MATH>\nworst-case running time and <MATH><I>O(n)</I></MATH> space, where <MATH><I>n</I></MATH> is the number of\nboxes in both input sequences, <MATH><I>d</I></MATH> the (constant) dimension of the\nboxes, and <MATH><I>k</I></MATH> the output complexity, i.e., the number of pairwise\nintersections of the boxes. The two-way-scan algorithm needs <MATH><I>O(n </I></MATH>log<MATH><I>(n) + l)</I></MATH> worst-case running time and <MATH><I>O(n)</I></MATH> space, where <MATH><I>l</I></MATH> is the\nnumber of pairwise overlapping intervals in one dimensions (the\ndimension where the algorithm is used instead of the segment tree).\nNote that <MATH><I>l</I></MATH> is not necessarily related to <MATH><I>k</I></MATH> and using the\ntwo-way-scan algorithm is a heuristic.\n<P>\n\nUnfortunately, we have no general method to automatically determine an\noptimal cutoff parameter, since it depends on the used hardware, the\nruntime ratio between callback runtime and segment-tree runtime, and\nof course the number of boxes to be checked and their distribution. In\ncases where the callback runtime is dominant, it may be best to make\nthe threshold parameter small. Otherwise a <I>cutoff</I><MATH><I>=<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(n)</I></MATH> can\nlead to acceptable results. For well distributed boxes the original\npaper&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>] gives optimal cutoffs in the thousands.\nAnyway, for optimal runtime some experiments to <A HREF=\"../NumberTypeSupport_ref/Function_compare.html#Cross_link_anchor_1339\">compare</A> different\ncutoff parameters are recommended.\n<P>\n\nTo demonstrate that box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> can be done quite fast, different\nbox sequences are intersected in the range between 4 and 800000 boxes\ntotal.  We use three-dimensional default boxes of closed topology with\n<I>float</I> coordinates and without additional data fields.  The\nalgorithm works directly on the boxes, not on pointer to boxes. Each\nbox <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> is reported to an empty dummy callback.\n<P>\n\nFor each box set, a near-optimal cutoff parameter is determined using\nan adaptive approximation. The runtime required for streaming is\ncompared against usual scanning.  Results on a Xeon 2.4GHz with 4GB\nmain memory can be seen in Figure <A HREF=\"Chapter_main.html#fig_benchmark\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. For a small\nnumber of boxes, pure scanning is still faster than streaming with\noptimal cutoff, which would just delegate the box sets to the scanning\nalgorithm. As there are more and more boxes, the overhead becomes less\nimportant.\n<P>\n\n<center>\n\n  <B>Figure:&nbsp;&nbsp;</B>Runtime comparison between the scanning and the streaming algorithm.\n  <A NAME=\"fig_benchmark\"></A>\n<P>\n\n<img border=\"0\" src=\"./fig/benchmark.gif\" align=\"center\" alt=\"benchmark plot\">\n</center>\n<P>\n\n<a name=\"Section_9\"></a>\n        \n<h2>57.9&nbsp;&nbsp;&nbsp;Example Using a Custom Box Implementation</h2>\n<P>\n\nThe example in the previous Section&nbsp;<A HREF=\"Chapter_main.html#sec:box-inters-params\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> uses\nan array to provide the coordinates and then creates another array for\nthe boxes. In the following example we write our own box class\n<I>Box</I> that we can initialize directly with the four coordinates and\ncreate the array of boxes directly. We also omit the explicitly stored\n<I>id</I>-number and use the address of the box itself as\n<I>id</I>-number. This works only if the boxes do not change their\nposition, i.e., we work with pointers to the boxes in the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\nalgorithm.\n<P>\n\nWe follow with our own box class <I>Box</I> the\n<I><A HREF=\"../Box_intersection_d_ref/Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I> concept, which allows us to reuse the\ndefault traits implementation, i.e., we can use the same default\nfunction call to compute all intersections. See the example in the\nnext section for a self-written traits class. So, in principle, the\nremainder of the example stays the same and we omit the part from the\nprevious example for brevity that illustrates the half-open box topology.\n<P>\n\nThe requirements for the box implementation are best studied on\npage&nbsp;<A HREF=\"../Box_intersection_d_ref/Concept_BoxIntersectionBox_d.html#ccRef_BoxIntersectionBox_d\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> in the Reference Manual. In a\nnutshell, we have to define the type <I>NT</I> for the box coordinates\nand the type <I>ID</I> for the <I>id</I>-number. Member functions\ngive access to the coordinates and the <I>id</I>-number. A static\nmember function returns the dimension.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/custom_box_grid.C\n#include &lt;CGAL/<A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;assert.h&gt;\n\nstruct Box {\n    typedef int            NT;\n    typedef std::ptrdiff_t ID;\n    int x[2], y[2];\n    Box( int x0, int x1, int y0, int y1) { x[0]=x0; x[1]=x1; y[0]=y0; y[1]=y1;}\n    static int dimension() { return 2; }\n    int min_coord(int dim) const { return x[dim]; }\n    int max_coord(int dim) const { return y[dim]; }\n    // id-function using address of current box,\n    // requires to work with pointers to boxes later\n    std::ptrdiff_t id() const { return (std::ptrdiff_t)(this); }\n};\n\n// 9 boxes of a grid\nBox boxes[9] = { Box( 0,0,1,1),  Box( 1,0,2,1),  Box( 2,0,3,1), // low\n                 Box( 0,1,1,2),  Box( 1,1,2,2),  Box( 2,1,3,2), // middle\n                 Box( 0,2,1,3),  Box( 1,2,2,3),  Box( 2,2,3,3)};// upper\n// 2 selected boxes as query; center and upper right\nBox query[2] = { Box( 1,1,2,2),  Box( 2,2,3,3)};\n\n// With the special id-function we need to work on box pointers\nBox* b_ptr[9] = { boxes,   boxes+1, boxes+2, boxes+3, boxes+4, boxes+5, \n                  boxes+6, boxes+7, boxes+8};\nBox* q_ptr[2] = { query,   query+1};\n\n// callback function object writing results to an output iterator\ntemplate &lt;class OutputIterator&gt;\nstruct Report {\n    OutputIterator it;\n    Report( OutputIterator i) : it(i) {} // store iterator in object\n    // We write the position with respect to 'boxes' to the output iterator\n    // assuming that box b (the query box) is not interesting in the result.\n    void operator()( const Box* a, const Box*) {\n        *it++ = ( reinterpret_cast&lt;Box*&gt;(a-&gt;id()) - boxes);\n    }\n};\ntemplate &lt;class Iter&gt; // helper function to create the function object\nReport&lt;Iter&gt; report( Iter it) { return Report&lt;Iter&gt;(it); }\n\nint main() {\n    // run the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm and store results in a vector\n    std::vector&lt;std::size_t&gt; result;\n    <A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A>( b_ptr, b_ptr+9, q_ptr, q_ptr+2, \n                              report( std::back_inserter( result)), \n                              std::ptrdiff_t(0));\n    // sort and check result\n    std::sort( result.begin(), result.end());\n    std::size_t chk[13] = {0,1,2,3,4,4,5,5,6,7,7,8,8};\n    assert( result.size()==13 &amp;&amp; std::equal(chk,chk+13,result.begin()));\n    return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_10\"></a>\n        \n<h2>57.10&nbsp;&nbsp;&nbsp;Example for Point Proximity Search with a Custom Traits Class</h2>\n\n<A NAME=\"sec:box_inters_example_proximity\"></A>\n<P>\n\nGiven a set of 3D points, we want to find all pairs of points that are\nless than a certain distance apart. We use the box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\nalgorithm to find good candidates, namely those that are less than\nthis specified distance apart in the <MATH><I>L<SUB> <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </SUB></I></MATH> norm, which is a good\napproximation of the Euclidean norm.\n<P>\n\nWe use an unusual representation for the box, namely pointers to the 3D points\nthemselves. We implement a special box traits class that interprets\nthe point as a box of the dimensions <MATH><I>[-</I></MATH><I>eps</I><MATH><I>,+</I></MATH><I>eps</I><MATH><I>]<SUP>3</SUP></I></MATH>\ncentered at this point. The value for <I>eps</I> is half the specified distance\nfrom above, i.e., points are reported if their distance is smaller\nthan <I>2*eps</I>.\n<P>\n\nThe requirements for the box traits class are best studied on\npage&nbsp;<A HREF=\"../Box_intersection_d_ref/Concept_BoxIntersectionTraits_d.html#ccRef_BoxIntersectionTraits_d\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> in the Reference Manual. In a\nnutshell, we have to define the type <I>NT</I> for the box coordinates,\nthe type <I>ID</I> for the <I>id</I>-number, and the type <I>Box_parameter</I>\nsimilar to the box handle, here <I><A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>*</I> since we work with the pointers.\nAll member functions in the traits class are static. Two functions give\naccess to the <A HREF=\"../NumberTypeSupport_ref/Function_max.html#Cross_link_anchor_1392\">max</A> and <A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A> coordinates that we compute from the point\ncoordinates plus or minus the <I>eps</I> value, respectively. For the\n<I>id</I>-number function the address of the point itself is\nsufficient, since the points stay stable. Another function\nreturns the dimension.\n<P>\n\nThe <I>report</I> callback function computes than the Euclidean\ndistance and prints a message for points that are close enough.\n<P>\n\nNote that we need to reserve sufficient space in the <I>points</I>\nvector to avoid reallocations while we create the <I>points</I> vector\nand the <I>boxes</I> vector in <A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A>, since otherwise the\n<I>points</I> vector might reallocate and invalidate all pointers\nstored in the <I>boxes</I> so far.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/proximity_custom_box_traits.C\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Box_intersection_d_ref/Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;float&gt;             <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                           <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_on_sphere_3.html#Cross_link_anchor_1705\">CGAL::Random_points_on_sphere_3</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;  Points_on_sphere;\n\nstd::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;  points;\nstd::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>*&gt; boxes;     // boxes are just pointers to points\nconst float           eps = 0.1; // finds point pairs of distance &lt; 2*eps\n\n// Boxes are just pointers to 3d points. The traits class adds the \n// +- eps size to each interval around the point, effectively building\n// on the fly a box of size 2*eps centered at the point.\nstruct Traits {\n    typedef float          NT;\n    typedef <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>*       Box_parameter;\n    typedef std::ptrdiff_t ID;\n\n    static int   dimension() { return 3; }\n    static float coord( Box_parameter b, int d) {\n        return (d == 0) ? b-&gt;x() : ((d == 1) ? b-&gt;y() : b-&gt;z());\n    }\n    static float min_coord( Box_parameter b, int d) { return coord(b,d)-eps;}\n    static float max_coord( Box_parameter b, int d) { return coord(b,d)+eps;}\n    // id-function using address of current box,\n    // requires to work with pointers to boxes later\n    static std::ptrdiff_t id(Box_parameter b) { return (std::ptrdiff_t)(b); }\n};\n\n// callback function reports pairs in close proximity\nvoid report( const <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>* a, const <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>* b) {\n    float dist = <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>( <A HREF=\"../Kernel_23_ref/Function_squared_distance.html#Cross_link_anchor_264\">CGAL::squared_distance</A>( *a, *b));\n    if ( dist &lt; 2*eps) {\n        std::cout &lt;&lt; &quot;Point &quot; &lt;&lt; (a - &amp;(points.front())) &lt;&lt; &quot; and Point &quot;\n                  &lt;&lt; (b - &amp;(points.front())) &lt;&lt; &quot; have distance &quot; &lt;&lt; dist\n                  &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n    // create some random points on the sphere of radius 1.0\n    Points_on_sphere generator( 1.0);\n    points.reserve( 50);\n    for ( int i = 0; i != 50; ++i) {\n        points.push_back( *generator++);\n        boxes.push_back( &amp; points.back());\n    }\n    \n    // run the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm and report proximity pairs\n    <A HREF=\"../Box_intersection_d_ref/Function_box_self_intersection_d.html#Cross_link_anchor_1237\">CGAL::box_self_intersection_d</A>( boxes.begin(), boxes.end(), \n                                   report, Traits());\n    return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_11\"></a>\n        \n<h2>57.11&nbsp;&nbsp;&nbsp;Design and Implementation History</h2>\n<P>\n\nLutz Kettner and Andreas Meyer implemented the algorithms starting\nfrom the publication&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>]. We had access to the\noriginal C implementation of Afra Zomorodian, which helped clarifying\nsome questions, and we are grateful to the help of Afra Zomorodian in\nanswering our questions during his visit. We thank Steve Robbins for\nan excellent review for this package. Steve Robbins provided an\nindependent and earlier implementation of this algorithm,\nhowever, we learned too late about this implementation.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Box_intersection_d_ref/Chapter_intro.html\">Intersecting Sequences of Iso-oriented Boxes</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_57!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38532.0}