{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Min sphere d Traits Definition An object of the class Min sphere d Traits is the unique sphere of smallest volume enclosing a finite multi set of points in d dimensional Euclidean space d For a set P we denote by ms P the smallest sphere that contains all points of P ms P can be degenerate i e ms P if P and ms P p if P p An inclusion minimal subset S of P with ms S ms P is called a support set the points in S are the support points A support set has size at most d 1 and all its points lie on the boundary of ms P In general neither the support set nor its size are unique The algorithm computes a support set S which remains fixed until the next insert or clear operation Please note This class is almost obsolete The class CGAL Min sphere of spheres d Traits solves a more general problem and is faster then Min sphere d Traits even if used only for points as input Most importantly CGAL Min sphere of spheres d Traits has a specialized implementation for floating point arithmetic which ensures correct results in a large number of cases including highly degenerate ones In contrast Min sphere d Traits is not reliable under floating point computations The only advantage of Min sphere d Traits over CGAL Min sphere of spheres d Traits is that the former can deal with points in homogeneous coordinates in which case the algorithm is division free Thus Min sphere d Traits might still be an option in case your input number type cannot efficiently divide include CGAL Min sphere d h Requirements The class Min sphere d Traits expects a model of the concept OptimisationDTraits as its template argument We provide the models CGAL Optimisation d traits 2 CGAL Optimisation d traits 3 and CGAL Optimisation d traits d for two three and d dimensional points respectively Types Min sphere d Traits Traits Min sphere d Traits FT typedef to Traits FT Min sphere d Traits Point typedef to Traits Point Min sphere d Traits Point iterator non mutable model of the STL concept BidirectionalIterator with value type Point Used to access the points used to build the smallest enclosing sphere Min sphere d Traits Support point iterator non mutable model of the STL concept BidirectionalIterator with value type Point Used to access the support points defining the smallest enclosing sphere Creation Min sphere d Traits min sphere Traits traits Traits creates a variable of type Min sphere d Traits and initializes it to ms If the traits parameter is not supplied the class Traits must provide a default constructor template class InputIterator Min sphere d Traits min sphere InputIterator first InputIterator last Traits traits Traits creates a variable min sphere of type Min sphere d Traits It is initialized to ms P with P being the set of points in the range first last Requirement The value type of first and last is Point If the traits parameter is not supplied the class Traits must provide a default constructor Precondition All points have the same dimension int min sphere number of points returns the number of points of min sphere i e P int min sphere number of support points returns the number of support points of min sphere i e S Point iterator min sphere points begin returns an iterator referring to the first point of min sphere Point iterator min sphere points end returns the corresponding past the end iterator Support point iterator min sphere support points begin returns an iterator referring to the first support point of min sphere Support point iterator min sphere support points end returns the corresponding past the end iterator int min sphere ambient dimension returns the dimension of the points in P If min sphere is empty the ambient dimension is 1 Point min sphere center returns the center of min sphere Precondition min sphere is not empty FT min sphere squared radius returns the squared radius of min sphere Precondition min sphere is not empty Predicates By definition an empty Min sphere d Traits has no boundary and no bounded side i e its unbounded side equals the whole space d Bounded side min sphere bounded side Point p returns CGAL ON BOUNDED SIDE CGAL ON BOUNDARY or CGAL ON UNBOUNDED SIDE iff p lies properly inside on the boundary or properly outside of min sphere resp Precondition if min sphere is not empty the dimension of p equals ambient dimension bool min sphere has on bounded side Point p returns true iff p lies properly inside min sphere Precondition if min sphere is not empty the dimension of p equals ambient dimension bool min sphere has on boundary Point p returns true iff p lies on the boundary of min sphere Precondition if min sphere is not empty the dimension of p equals ambient dimension bool min sphere has on unbounded side Point p returns true iff p lies properly outside of min sphere Precondition if min sphere is not empty the dimension of p equals ambient dimension bool min sphere is empty returns true iff min sphere is empty this implies degeneracy bool min sphere is degenerate returns true iff min sphere is degenerate i e if min sphere is empty or equal to a single point equivalently if the number of support points is less than 2 Modifiers void min sphere clear resets min sphere to ms template class InputIterator void min sphere set InputIterator first InputIterator last sets min sphere to the ms P where P is the set of points in the range first last Requirement The value type of first and last is Point Precondition All points have the same dimension void min sphere insert Point p inserts p into min sphere If p lies inside the current sphere this is a constant time operation otherwise it might take longer but usually substantially less than recomputing the smallest enclosing sphere from scratch Precondition The dimension of p equals ambient dimension if min sphere is not empty template class InputIterator void min sphere insert InputIterator first InputIterator last inserts the points in the range first last into min sphere and recomputes the smallest enclosing sphere by calling insert for all points in the range Requirement The value type of first and last is Point Precondition All points have the same dimension If min sphere is not empty this dimension must be equal to ambient dimension Validity Check An object min sphere is valid iff min sphere contains all points of its defining set P min sphere is the smallest sphere containing its support set S and S is minimal i e no support point is redundant Note Under inexact arithmetic the result of the validation is not realiable because the checker itself can suffer from numerical problems bool min sphere is valid bool verbose false int level returns true iff min sphere is valid If verbose is true some messages concerning the performed checks are written to standard error stream The second parameter level is not used we provide it only for consistency with interfaces of other classes Miscellaneous const Traits min sphere traits returns a const reference to the traits class object I O std ostream std ostream os min sphere writes min sphere to output stream os Requirement The output operator is defined for Point std istream std istream is min sphere reads min sphere from input stream is Requirement The input operator is defined for Point See Also CGAL Optimisation d traits 2 K ET NT CGAL Optimisation d traits 3 K ET NT CGAL Optimisation d traits d K ET NT OptimisationDTraits CGAL Min circle 2 Traits CGAL Min sphere of spheres d Traits CGAL Min annulus d Traits Implementation We implement the algorithm of Welzl with move to front heuristic Wel91 for small point sets combined with a new efficient method for large sets which is particularly tuned for moderately large dimension d 2 G r99 The creation time is almost always linear in the number of points Access functions and predicates take constant time inserting a point might take up to linear time but substantially less than computing the new smallest enclosing sphere from scratch The clear operation and the check for validity each take linear time Example include CGAL Cartesian d h include iostream include cstdlib include CGAL Random h include CGAL Optimisation d traits d h include CGAL Min sphere d h typedef CGAL Cartesian d double K typedef CGAL Optimisation d traits d K Traits typedef CGAL Min sphere d Traits Min sphere typedef K Point d Point const int n 1 number of points const int d 5 dimension of points int main Point P n n points double coord d d coordinates CGAL Random r random number generator for int i i n i for int j j d j coord j r get double P i Point d coord coord d random point Min sphere ms P P n smallest enclosing sphere CGAL set pretty mode std cout std cout ms output the sphere return Next Min annulus d Traits Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Optimisation_ref/Class_Min_sphere_d.html", "title": "min_sphere_d&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Optimisation_ref/Min_sphere_d.tex' -->\n<html> <head>  \n<title>Min_sphere_d&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1162\"></A>\n\n<A NAME=\"Cross_link_anchor_1163\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1127\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Min_sphere_d<Traits>\"></A>\n<h2><I>CGAL::Min_sphere_d&lt;Traits&gt;</I></h2>\n\n\n    \n   \n     \n     \n<A NAME=\"Index_anchor_1128\"></A> \n\n   \n\n    \n   \n     \n     \n<A NAME=\"Index_anchor_1129\"></A> \n\n   \n\n    \n   \n     \n     \n<A NAME=\"Index_anchor_1130\"></A> \n\n   \n\n    \n   \n   \n     \n     \n<A NAME=\"Index_anchor_1131\"></A> \n\n   \n\n   \n\n    \n   \n   \n     \n     \n<A NAME=\"Index_anchor_1132\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nAn object of the class <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> is the unique sphere of\nsmallest <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> enclosing a finite (multi)set of points in <MATH><I>d</I></MATH>-dimensional\nEuclidean space <MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>d</SUB></I></MATH>. For a set <MATH><I>P</I></MATH> we denote by <MATH><I>ms(P)</I></MATH> the\nsmallest sphere that contains all points of <MATH><I>P</I></MATH>. <MATH><I>ms(P)</I></MATH> can\nbe degenerate, i.e. <MATH><I>ms(P)=</I></MATH>&Oslash;<MATH><I></I></MATH>\nif <MATH><I>P=</I></MATH>&Oslash;<MATH><I></I></MATH> and <MATH><I>ms(P)={p}</I></MATH> if\n<MATH><I>P={p}</I></MATH>.\n<P>\n\nAn inclusion-minimal subset <MATH><I>S</I></MATH> of <MATH><I>P</I></MATH> with <MATH><I>ms(S)=ms(P)</I></MATH> is called a\n<I>support set</I>, the points in <MATH><I>S</I></MATH> are the <I>support points</I>.\nA support set has size at most <MATH><I>d+1</I></MATH>, and all its points lie on the\nboundary of <MATH><I>ms(P)</I></MATH>. In general, neither the support set nor its size\nare unique.\n<P>\n\nThe algorithm\ncomputes a support set <MATH><I>S</I></MATH> which remains fixed until the next insert\nor clear operation.\n<P>\n\n<B>Please note:</B> This class is (almost) obsolete. The class\n<I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> solves a more general problem\nand is faster then <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> even if used only for points\nas input. Most importantly, <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> has\na specialized implementation for floating-point arithmetic which\nensures correct results in a large number of cases (including\nhighly degenerate ones). In contrast, <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> is not reliable\nunder floating-point computations. The only advantage of \n<I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> over <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> is that the\nformer can deal with points in homogeneous coordinates, in which \ncase the algorithm is division-free. Thus, <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> might still\nbe an option in case your input number type cannot (efficiently) \ndivide.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Min_sphere_d.h\">CGAL/Min_sphere_d.h</A>&gt;</I>\n<P>\n\n<H3>Requirements</H3>   \n     \n     \n<A NAME=\"Index_anchor_1133\"></A>\n<P>\n\nThe class <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> expects a model of the concept\n    <I><A HREF=\"Concept_OptimisationDTraits.html#Cross_link_anchor_1181\">OptimisationDTraits</A></I> as its template argument.\n      We provide the models <I><A HREF=\"Class_Optimisation_d_traits_2.html#Cross_link_anchor_1175\">CGAL::Optimisation_d_traits_2</A></I>,\n      <I><A HREF=\"Class_Optimisation_d_traits_3.html#Cross_link_anchor_1177\">CGAL::Optimisation_d_traits_3</A></I> and \n<I><A HREF=\"Class_Optimisation_d_traits_d.html#Cross_link_anchor_1179\">CGAL::Optimisation_d_traits_d</A></I>\n    for two-, three-, and <MATH><I>d</I></MATH>-dimensional points respectively.\n<P>\n\n<H3>Types</H3>   \n     \n     \n<A NAME=\"Index_anchor_1134\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;::Traits\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n<TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;::FT\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::FT</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;::Point\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::Point</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL\n    concept <I>BidirectionalIterator</I> with value type <I>Point</I>. Used\n    to access the points used to build the smallest enclosing sphere.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;::Support_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL\n    concept <I>BidirectionalIterator</I> with value type <I>Point</I>. Used\n    to access the support points defining the smallest enclosing sphere.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1135\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt; min_sphere (  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable of type <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> and\n        initializes it to <MATH><I>ms(</I></MATH>&Oslash;<MATH><I>)</I></MATH>.\n          If the traits parameter is not supplied, the class <I>Traits</I>\n          must provide a default constructor.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt; min_sphere ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable <I>min_sphere</I> of type <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I>.\n        It is initialized to <MATH><I>ms(P)</I></MATH> with <MATH><I>P</I></MATH> being the set of points\n        in the range [<I>first</I>,<I>last</I>).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I>\n        is <I>Point</I>. If the traits parameter is not supplied,\n        the class <I>Traits</I> must provide a default constructor.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<A NAME=\"Index_anchor_1136\"></A> \n\n   \n\n\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1137\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1138\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.number_of_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of points of <I>min_sphere</I>, i.e. <MATH><I>|P|</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_support_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.number_of_support_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of support points of <I>min_sphere</I>, i.e. <MATH><I>|S|</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_begin69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.points_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first point of <I>min_sphere</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_end69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.points_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_begin69_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.support_points_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first support point of <I>min_sphere</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_end69_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.support_points_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_ambient_dimension69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.ambient_dimension ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the dimension of the points in <MATH><I>P</I></MATH>. If <I>min_sphere</I>         is empty, the ambient dimension is <MATH><I>-1</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Point__center6_9_const;\"></A>\n Point\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.center ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the center of <I>min_sphere</I>.<BR>\n\n<EM>Precondition: </EM><I>min_sphere</I> is not empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_FT_squared_radius6_9_const;\"></A>\nFT\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.<A HREF=\"../Kernel_23_ref/Function_squared_radius.html#Cross_link_anchor_267\">squared_radius</A> ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the squared radius of <I>min_sphere</I>.<BR>\n\n<EM>Precondition: </EM><I>min_sphere</I> is not empty.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1139\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1140\"></A>\n<P>\n\nBy definition, an empty <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>&lt;Traits&gt;</I> has no boundary and no\nbounded side, i.e. its unbounded side equals the whole space <MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>d</SUB></I></MATH>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_bounded_side6_const_Point__p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.bounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>CGAL::<A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I>, <I>CGAL::<A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I>, or\n        <I>CGAL::<A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> iff <I>p</I> lies properly inside,\n        on the boundary, or properly outside of <I>min_sphere</I>, resp.<BR>\n\n<EM>Precondition: </EM>if <I>min_sphere</I> is not empty, the dimension of <MATH><I>p</I></MATH>\n        equals <I>ambient_dimension()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_bounded_side6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.has_on_bounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies properly inside <I>min_sphere</I>.<BR>\n\n<EM>Precondition: </EM>if <I>min_sphere</I> is not empty, the dimension of <MATH><I>p</I></MATH>\n        equals <I>ambient_dimension()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_boundary6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.has_on_boundary (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies on the boundary\n        of <I>min_sphere</I>.<BR>\n\n<EM>Precondition: </EM>if <I>min_sphere</I> is not empty, the dimension of <MATH><I>p</I></MATH>\n        equals <I>ambient_dimension()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_unbounded_side6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.has_on_unbounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies properly outside of <I>min_sphere</I>.<BR>\n\n<EM>Precondition: </EM>if <I>min_sphere</I> is not empty, the dimension of <MATH><I>p</I></MATH>\n        equals <I>ambient_dimension()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_empty6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.is_empty ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_sphere</I> is empty (this implies\n        degeneracy).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_degenerate6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.is_degenerate ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_sphere</I> is degenerate, i.e. if\n        <I>min_sphere</I> is empty or equal to a single point, equivalently if\n        the number of support points is less than 2.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1141\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1142\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear_69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.clear ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    resets <I>min_sphere</I> to <MATH><I>ms(</I></MATH>&Oslash;<MATH><I>)</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set6_InputIterator_first+_InputIterator_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_sphere.set ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets <I>min_sphere</I> to the <MATH><I>ms(P)</I></MATH>, where <MATH><I>P</I></MATH> is the set of points\n        in the range [<I>first</I>,<I>last</I>).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n        <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_const_Point__p9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.insert (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts <I>p</I> into <I>min_sphere</I>. If <I>p</I> lies inside the\n        current sphere, this is a constant-time operation, otherwise\n        it might take longer, but usually substantially less than\n        recomputing the smallest enclosing sphere from scratch.<BR>\n\n<EM>Precondition: </EM>The dimension of <I>p</I> equals <I>ambient_dimension()</I>\n        if <I>min_sphere</I> is not empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_InputIterator_first+_InputIterator_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_sphere.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the points in the range [<I>first</I>,<I>last</I>)\n        into <I>min_sphere</I> and recomputes the smallest enclosing sphere, by\n        calling <I>insert</I> for all points in the range.<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n      <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension. If\n        <I>min_sphere</I> is not empty, this dimension must be equal to\n        <I>ambient_dimension()</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Validity Check</H3>\n       \n     \n     \n     \n<A NAME=\"Index_anchor_1143\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1144\"></A> \n\n   \n \n   \n\n  \n  An object <I>min_sphere</I> is valid, iff\n  <UL>\n    <LI><I>min_sphere</I> contains all points of its defining set <MATH><I>P</I></MATH>,\n    <LI><I>min_sphere</I> is the smallest sphere containing its support set <MATH><I>S</I></MATH>, and\n    <LI><MATH><I>S</I></MATH> is minimal, i.e. no support point is redundant.\n  </UL>\n<P>\n\n<I>Note:</I> Under inexact arithmetic, the result of the\n  validation is not realiable, because the checker itself can suffer\n  from numerical problems.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6_bool_verbose_=_false+_int_level_=_0_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_sphere.is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    bool verbose = false,<BR>\n\nint level = 0)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_sphere</I> is valid. If <I>verbose</I>\n        is <I>true</I>, some messages concerning the performed checks\n        are written to standard error stream. The second parameter\n        <I>level</I> is not used, we provide it only for consistency\n        with interfaces of other classes.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1145\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1146\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Traits__traits6_9_const;\"></A>\nconst Traits&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_sphere.traits ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a const reference to the traits class object.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>I/O</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1147\"></A>\n<P>\n\n<A NAME=\"Index_anchor_1148\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1149\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::ostream&amp; os &lt;&lt;  min_sphere<A NAME=\"Function_std::ostream__operator_66_6_std::ostream__os+_const_Min_sphere_d6Traits9__min_sphere9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>min_sphere</I> to output stream <I>os</I>.<BR>\n\n<EM>Requirement: </EM>The output operator is defined for <I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<A NAME=\"Index_anchor_1150\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1151\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::istream&amp; is &gt;&gt;  min_sphere&amp;<A NAME=\"Function_std::istream__operator_99_6_std::istream__is+_Min_sphere_d6Traits9_min_sphere_9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads <I>min_sphere</I> from input stream <I>is</I>.<BR>\n\n<EM>Requirement: </EM>The input operator is defined for <I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Optimisation_d_traits_2.html#Cross_link_anchor_1175\">CGAL::Optimisation_d_traits_2</A>&lt;K,ET,NT&gt;</I><BR>\n\n<I><A HREF=\"Class_Optimisation_d_traits_3.html#Cross_link_anchor_1177\">CGAL::Optimisation_d_traits_3</A>&lt;K,ET,NT&gt;</I><BR>\n\n<I><A HREF=\"Class_Optimisation_d_traits_d.html#Cross_link_anchor_1179\">CGAL::Optimisation_d_traits_d</A>&lt;K,ET,NT&gt;</I><BR>\n\n<I><A HREF=\"Concept_OptimisationDTraits.html#Cross_link_anchor_1181\">OptimisationDTraits</A></I><BR>\n\n<I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1138\">CGAL::Min_circle_2</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_annulus_d.html#Cross_link_anchor_1164\">CGAL::Min_annulus_d</A>&lt;Traits&gt;</I>\n<P>\n\n<H3>Implementation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1152\"></A>\n<P>\n\nWe implement the algorithm of Welzl with move-to-front\nheuristic&nbsp;[<A HREF=\"../biblio.html#Biblio_w-sedbe-91a\">Wel91</A>] for small point sets, combined with a new\nefficient method for large sets, which is particularly tuned for\nmoderately large dimension (<MATH><I>d  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 20</I></MATH>) [<A HREF=\"../biblio.html#Biblio_cgal:g-frseb-99\">G&auml;r99</A>].\nThe creation time is almost\nalways linear in the number of points. Access functions and predicates\ntake constant time, inserting a point might take up to linear time,\nbut substantially less than computing the new smallest enclosing\nsphere from scratch. The clear operation and the check for validity\n    each take linear time.\n<P>\n\n<H3>Example</H3><pre class=\"ExampleCode\">\n#include &lt;CGAL/Cartesian_d.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;CGAL/Random.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Optimisation_d_traits_d.html#Cross_link_anchor_1180\">Optimisation_d_traits_d</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1163\">Min_sphere_d</A>.h&gt;\n\ntypedef CGAL::Cartesian_d&lt;double&gt;              K;\ntypedef <A HREF=\"Class_Optimisation_d_traits_d.html#Cross_link_anchor_1179\">CGAL::Optimisation_d_traits_d</A>&lt;K&gt;       Traits;\ntypedef <A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;             Min_sphere;\ntypedef K::<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>                             Point;\n\nconst int n = 10;                        // number of points\nconst int d = 5;                         // dimension of points\n\nint main ()\n{\n    Point         P[n];                  // n points\n    double        coord[d];              // d coordinates\n    CGAL::Random  r;                     // random number generator\n\n    for (int i=0; i&lt;n; ++i) {\n        for (int j=0; j&lt;d; ++j)\n            coord[j] = r.get_double();\n        P[i] = Point(d, coord, coord+d); // random point\n    }\n\n    Min_sphere  ms (P, P+n);             // smallest enclosing sphere\n\n    <A HREF=\"../IOstream_ref/Function_set_pretty_mode.html#Cross_link_anchor_1749\">CGAL::set_pretty_mode</A> (std::cout);\n    std::cout &lt;&lt; ms;                     // output the sphere\n\n    return 0;\n}\n\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Min_annulus_d.html\"><I>Min_annulus_d&lt;Traits&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_52!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39006.0}