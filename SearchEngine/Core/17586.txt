{"text": "some implementation details Two cards X and Y of the same suit in one hand are rank equivalent if none of the other 3 players have any cards in that suit with rank in between those of X and Y Dynamic rank equivalence can be implemented by maintaining an array of length 52 one cell for each of the cards in the deck with each cell containing a value from the set N E W S none indicating which if any of the players holds that card in his hand For purposes of determining equivalence it is important that this array is not updated at the time a player plays a card The array must be updated only at the conclusion of a trick Node isomorphism refers to the situation in which two nodes correspond to identical hand configurations with equal number of tricks taken by N S Node isomorphism can be implemented by maintaining a list of configurations and their associated values indicating which partnership N S or E W will prevail starting from that configuration When encountering a configuration C the list is checked to determine whether C is listed If it is then the value of configuration C can be obtained from the stored value thereby avoiding the necessity of expanding the entire tree of possibilities If it is not then the pair C unknown is entered onto the list and after C has been evaluated say to find that N S will prevail then this entry is updated to become C N S For difficult problems the number of encountered configurations can be so large that there will not be enough space to store all of them In that situation it is effective to store the configurations that will have the most impact in avoiding tree expansion Also for speed considerations it is important that the list be searchable very rapidly These various concerns can be addressed efficiently and effectively by using a variant of Robin Hood hashing For very difficult problems additional speed enhancements might be possible by use of a Bloom filter To obtain the greatest benefit it is best that the hash table have the largest size possible The size of the table is not the number of bytes stored in the table it is the maximum number of entries that can be stored in the table It is true that increasing the number of bytes available for the table will increase the number of entries But equally effective and even more important for speed considerations is the fact that decreasing the number of bytes required for one entry will increase the maximum number of entries that can be held by a table having capacity of a fixed number of bytes I encode a configuration in 8 bytes When it is possible that an output tree will be produced each configuration requires an additional 4 bytes Also producing an output tree necessitates the use of a rather large stack typically allowed 1 2 Megs The stack contains the body of what will ultimately be the tree file The tree file format is roughly as follows There is a primary header which describes the initial state of the program number of cards per player who are the goodguys etc a secondary header which describes the contents of the 4 hands and the body which contains one word that gives the number of words in the rest of the body and then a series of cells that are stored in depth first search order A cell describes a trick It contains For Versions 1 2 in one word the round number the leader the winner the 4 cards if a duplicate position has been reached then the next 2 words contain ZERO pointer to identical position cell For Versions 3 4 in one word the round number the leader the 4 card equivalents and indication as to whether a duplicate position has been reached if a duplicate position has been reached then the next word contains pointer to identical position cell Dan Hirschberg Computer Science Department University of California Irvine CA 92697 3425 dan at ics uci edu Last modified July 1 1996", "_id": "http://www.ics.uci.edu/~dan/bridge/implement.html", "title": "implementation details", "html": "<HTML><HEAD>\n<TITLE>implementation details</TITLE>\n</HEAD><BODY>\n<H2>some implementation details</H2>\n\nTwo cards, X and Y, of the same suit in one hand are\n<I>rank-equivalent</I>\nif none of the other 3 players have any cards in that\nsuit with rank in between those of X and Y.\nDynamic rank equivalence can be implemented by maintaining an\narray of length 52, one cell for each of the cards in the deck,\nwith each cell containing a value from the set {N,E,W,S,none}\nindicating which (if any) of the players holds that card in his hand.\nFor purposes of determining equivalence, it is important\nthat this array is not updated at the time a player plays a card!\nThe array must be updated only at the conclusion of a trick.\n<P>\n<I>Node isomorphism</I> refers to the situation in which\ntwo nodes correspond to identical hand configurations\nwith equal number of tricks taken by N/S.\nNode isomorphism can be implemented by maintaining a list\nof configurations and their associated values,\nindicating which partnership, N/S or E/W, will prevail\nstarting from that configuration.\nWhen encountering a configuration, C, the list is checked\nto determine whether C is listed.\nIf it is, then the value of configuration C\ncan be obtained from the stored value, thereby avoiding the\nnecessity of expanding the entire tree of possibilities.\nIf it is not, then the pair [C,unknown] is entered onto the list\nand, after C has been evaluated (say, to find that N/S will prevail)\nthen this entry is updated (to become [C,N/S]).\n<P>\nFor difficult problems, the number of encountered configurations\ncan be so large that there will not be enough space to store\nall of them.  In that situation, it is effective to store\nthe configurations that will have the most impact in avoiding\ntree expansion.   Also, for speed considerations, it is important\nthat the list be searchable very rapidly.  These various concerns\ncan be addressed efficiently and effectively by using a variant\nof <I>Robin Hood hashing</I>.  For very difficult problems,\nadditional speed enhancements might be possible by use of a\n<I>Bloom filter</I>.\n<P>\nTo obtain the greatest benefit,\nit is best that the hash table have the largest size possible.\nThe size of the table is not the number of bytes stored\nin the table -- it is the maximum number of entries that can\nbe stored in the table.  It is true that increasing the number of bytes\navailable for the table will increase the number of entries.\nBut equally effective, and even more important for speed considerations,\nis the fact that decreasing the number of bytes required for one\nentry will increase the maximum number of entries that can be held\nby a table having capacity of a fixed number of bytes.\n<P>\nI encode a configuration in 8 bytes.\nWhen it is possible that an output tree will be produced,\neach configuration requires an additional 4 bytes.\nAlso, producing an output tree necessitates the use of\na rather large stack, typically allowed 1-2 Megs.\n<P>\nThe stack contains the body of what will ultimately be the tree file.\nThe tree file format is roughly as follows.\nThere is a primary header,\nwhich describes the initial state of the program\n(number of cards per player, who are the \"goodguys\",etc.)\na secondary header,\nwhich describes the contents of the 4 hands,\nand the body, which contains one word that gives the number of\nwords in the rest of the body and then a series of cells\nthat are stored in depth-first search order.\nA cell describes a trick.  It contains:\n<UL> For Versions 1,2:  \n <LI> in one word: the round number, the leader, the winner, the 4 cards\n <LI> if a duplicate position has been reached then the next 2 words\n      contain:  ZERO,  pointer to identical position cell\n</UL>\n<UL> For Versions 3,4:\n <LI> in one word: the round number, the leader, the 4 card equivalents,\n      and indication as to whether a duplicate position has been reached\n <LI> if a duplicate position has been reached then\n      the next word contains:   pointer to identical position cell\n<P>\n<HR>\n<ADDRESS>\nDan Hirschberg<BR>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3425<BR>\n</ADDRESS>\n<tt>dan at ics.uci.edu</tt><br>\nLast modified: July 1, 1996\n</BODY></HTML>\n", "id": 17586.0}