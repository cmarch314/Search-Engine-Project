{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Structs The moniker for this code example is Structs Background Just as we have a need for homogeneous data structures collections of some number of elements of the same type there is also a common need for heterogeneous data structures where we bring together multiple values of potentially different types into a single entity Ideally these values have names to differentiate them from one another in a readable meaningful way though there are sometimes other ways to access them e g tuples in Python whose values are accessed by an index Once we pull together related data into a single package we can now store all of the data in a single variable pass it to a function with a single parameter and so on This can be a very big benefit relative to the alternative of storing many variables and passing many parameters a program is more readable if we can establish a single simple name for a concept even one that s more complex than built in types like ints or doubles Structures The simplest solution to a problem like this in C is to use something called a structure generally called a struct in line with the syntax used to declare them There are fuller solutions to this problem which we ll see soon but we re starting with the raw materials and working our way up so structures are a good place for us to start A struct brings together a set of members or more specifically member variables Each member has both a name and a type with the names specifying how each member is to be accessed or modified and the types specifying what can and can t be stored in and done to each member As a quick example consider the following struct that represents a calendar date Aside I wouldn t generally implement dates this way except perhaps in last mile code in a user interface because dates are somewhat more complicated than just being three integers This is a declaration of that struct remember that declarations specify the existence of something in this case a type called Date which is a struct containing three unsigned integers without concretely giving it life i e without creating a variable of the new type struct Date unsigned int year unsigned int month unsigned int day Note the semicolon at the end of the declaration That s no joke it has to be there Without it you may find yourself getting some fairly strange looking error messages out of a C compiler which may be focused on the things that directly follow the struct declaration rather than the source of the problem The reason why the semicolon has to be there is a bit of a long story due to the history of the syntax of C which allowed a struct declaration to be followed directly by the name of one or more variables that would take on that struct s type The semicolon is necessary so the compiler knows that you don t intend to do that Before we go too far with this it s important to reiterate that this is one way in C to create a new data type There is a new type in our program called Date and C doesn t draw a serious distinction between built in types like int and the types we create all data types are on a fairly equal playing field This is different than you might expect especially if you ve programmed in Java before where objects are distinguished clearly from values of primitive types C lacks this distinction altogether even ints are objects in the C sense Statically allocating a struct Once you ve declared a struct you ve created a new data type which means that you should now be able to instantiate it meaning that you should be able to create variables of the new type As with variables of built in types like int you have your choice about where the variables should be allocated the most common two choices being statically allocated on the run time staack or dynamically allocated on the heap Given that Date structs are relatively small we should tend to prefer them to be statically allocated though it s sometimes unavoidable that we ll need them to be dynamically allocated instead e g when their lifetime doesn t match the lifetime of some function so we should know how to do both Statically allocating a Date struct on the run time stack is just like declaring an int variable void foo Date d The compiler is able to detemrine how much memory is required for the struct by deciding on a layout of its members The members are laid out in sequence one after another though sometimes with empty space called padding intentionally left between them On the ICS 45C VM unsigned integers are four bytes so we might expect a Date struct to be 12 bytes four for each of the unsigned integer members Because of this the struct is no more expensive in terms of time or memory than having three separate unsigned int variables which means we don t have to worry that we re costing ourselves performance to achieve an abstraction that otherwise simplifies our program Being able to do this is all upside Having declared a Date variable as above its members values will be initialized in whatever way is normal for the members types A Date contains three unsigned integers unsigned integers are not initialized automatically they take on whatever value was in memory previously so the Date begins its life with garbage values stored in it We can set the members to new values individually by name using the operator void foo Date today today year 2 14 today month 1 today day 28 We can read the to mean The thing on the left has members and I d like to access the member named on the right So for example today year indicates that we believe today to be an object with members it is and that we d like to access its year member which it has Since the compiler is aware of the layout of the struct not only the names of the members but their relative positions in memory inside of it it will know precisely where to go Alternatively we can initialize a struct s members at the point where we create it using C s uniform initialization syntax which as we ll see standardizes the way that objects of most types can be initialized void foo Date today 2 14 1 28 The construct 2 14 1 28 is called an initializer list which specifies a sequence of values that are to be used to initialize today Using an initializer list with a struct causes the struct s members to be initialized in the order they re declared in the struct declaration so year then month then day Note that there are a couple of consequences of using initializer lists in this way One consequence is that a change in the order of the members in the struct declaration might radically change how your code behaves without you receiving a compile time error Another is that you ve removed the members names from your point in your code where initialization happens which can sometimes make it harder for a program to read you could argue that it s fairly clear what 2 14 1 and 28 are intended to be here but even a simple case like this isn t entirely obvious since dates are typically written with their components in different orders in different parts of the world When a statically allocated struct falls out of scope it is destroyed automatically taking its members with it Note though that if its members are pointers the pointers will be destroyed but the objects the pointers point to will not Dynamically allocating a struct Structs can also be allocated dynamically as well using the same new operator that we ve seen previously As before the new operator returns a pointer to the newly allocated struct Date d new Date In this case 12 bytes will be allocated on the heap and a pointer to the 12 byte block will be returned Accessing the members of a struct through a pointer is a little bit trickier d year 2 5 Illegal because d is a pointer it has no member called year d year 2 5 Also illegal because has a higher precedence than d year 2 5 Legal but ugly as sin Only the last of these says what we actually mean Go to where d a Date pointer points and then access its year member But it s a really unfortunate piece of syntax because it s ugly and error prone So C includes another operator the arrow operator that means the same thing The thing on the left is a pointer to an object with members Go to where it points and then access the member named on the right d year 2 5 Much nicer Similar to statically allocated structs you can use an initializer list to give values to the struct s members at the time of creation Date d new Date 2 14 1 28 As with other dynamically allocated objects we ll need to deallocate the struct when we re done with it We do this the same way that we deallocate other dynamically allocated objects by using the delete operator delete d The Date object will be deleted taking its members with it but note again that if any members are pointers the pointers will be destroyed but the objects the pointers point to will not Passing structs as parameters A struct can be passed to a function in the same ways that an int can by value meaning that a copy of the struct is passed by reference meaning that a reference to the struct is passed so changes to the struct inside the function take effect in the caller and so on Pass by value offers the guarantee of value semantics changes inside the function do not affect the caller though this can be expensive if the struct is large so in those cases we might prefer passing the struct by reference with const if we want to protect the caller s struct from being changed Syntactically passing a struct as a parameter is unsurprising void foo Date d d is a copy of the struct passed as a parameter void bar Date d modifications to d take effect in the caller A disclaimer about structs The actual rules in C differ a bit from what I ve said here Structs are more capable than this and as we ll see they are technically indistinguishable from classes except in only the most minor ways but as a practical matter structs are most often used in the way we ve seen here they provide the ability to bring a set of public members together and nothing else We ll only be using structs in this way this quarter whenever we want something more full featured we ll use classes instead Note too that this is all structs can do historically in C there are no classes and structs are limited to what you see here The code The official moniker for this code example is Structs so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code Structs to download the code example into your project directory s app directory Alternatively you can click the link to the tarball below Structs tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/Structs/", "title": "ics 45c fall 2014 code example: structs", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014 Code Example: Structs</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Structs</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>Structs</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Just as we have a need for <i>homogeneous data structures</i> &mdash; collections of some number of elements of the same type &mdash; there is also a common need for <i>heterogeneous data structures</i>, where we bring together multiple values of potentially different types into a single entity.  Ideally, these values have names to differentiate them from one another in a readable, meaningful way, though there are sometimes other ways to access them (e.g., tuples in Python, whose values are accessed by an index).</p>\r\n\r\n<p>Once we pull together related data into a single package, we can now store all of the data in a single variable, pass it to a function with a single parameter, and so on.  This can be a very big benefit, relative to the alternative of storing many variables and passing many parameters; a program is more readable if we can establish a single, simple name for a concept, even one that's more complex than built-in types like <b>int</b>s or <b>double</b>s.</p>\r\n\r\n<p class=\"subtitle\">Structures</p>\r\n\r\n<p>The simplest solution to a problem like this in C++ is to use something called a <i>structure</i> &mdash; generally called a <b>struct</b>, in line with the syntax used to declare them.  (There are fuller solutions to this problem, which we'll see soon, but we're starting with the raw materials and working our way up, so structures are a good place for us to start.)  A struct brings together a set of <i>members</i> (or, more specifically, <i>member variables</i>).  Each member has both a name and a type, with the names specifying how each member is to be accessed or modified, and the types specifying what can and can't be stored in (and done to) each member.</p>\r\n\r\n<p>As a quick example, consider the following struct that represents a calendar date.  (Aside: I wouldn't generally implement dates this way, except perhaps in \"last mile\" code in a user interface, because dates are somewhat more complicated than just being three integers.)  This is a <i>declaration</i> of that struct; remember that declarations specify the existence of something (in this case, a type called Date, which is a struct containing three unsigned integers) without concretely giving it life (i.e., without creating a variable of the new type).</p>\r\n\r\n<blockquote><pre>\r\n<b>struct</b> Date\r\n{\r\n    unsigned int year;\r\n    unsigned int month;\r\n    unsigned int day;\r\n};\r\n</pre></blockquote>\r\n\r\n<p>Note the semicolon at the end of the declaration.  That's no joke; it has to be there!  Without it, you may find yourself getting some fairly strange-looking error messages out of a C++ compiler, which may be focused on the things that directly follow the struct declaration rather than the source of the problem.  (The reason why the semicolon has to be there is a bit of a long story, due to the history of the syntax of C, which allowed a struct declaration to be followed directly by the name of one or more variables that would take on that struct's type.  The semicolon is necessary so the compiler knows that you don't intend to do that.)</p>\r\n\r\n<p>Before we go too far with this, it's important to reiterate that this is one way in C++ to create a new data type.  There is a new type in our program called <b>Date</b>, and C++ doesn't draw a serious distinction between built-in types like <b>int</b> and the types we create; all data types are on a fairly equal playing field.  (This is different than you might expect, especially if you've programmed in Java before, where \"objects\" are distinguished clearly from values of \"primitive types.\"  C++ lacks this distinction altogether; even <b>int</b>s are \"objects\" in the C++ sense.)</p>\r\n\r\n<p class=\"subtitle\">Statically allocating a struct</p>\r\n\r\n<p>Once you've declared a struct, you've created a new data type, which means that you should now be able to instantiate it &mdash; meaning that you should be able to create variables of the new type.  As with variables of built-in types like <b>int</b>, you have your choice about where the variables should be allocated, the most common two choices being statically-allocated on the run-time staack or dynamically-allocated on the heap.  Given that Date structs are relatively small, we should tend to prefer them to be statically allocated, though it's sometimes unavoidable that we'll need them to be dynamically allocated instead (e.g., when their lifetime doesn't match the lifetime of some function), so we should know how to do both.</p>\r\n\r\n<p>Statically allocating a Date struct on the run-time stack is just like declaring an <b>int</b> variable.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    Date d;\r\n    ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The compiler is able to detemrine how much memory is required for the struct by deciding on a <i>layout</i> of its members.  The members are laid out in sequence, one after another (though sometimes with empty space called <i>padding</i> intentionally left between them).  On the ICS 45C VM, unsigned integers are four bytes, so we might expect a Date struct to be 12 bytes, four for each of the unsigned integer members.  Because of this, the struct is no more expensive &mdash; in terms of time or memory &mdash; than having three separate unsigned int variables, which means we don't have to worry that we're costing ourselves performance to achieve an abstraction that otherwise simplifies our program.  Being able to do this is all upside.</p>\r\n\r\n<p>Having declared a Date variable as above, its members' values will be initialized in whatever way is normal for the members' types.  A Date contains three unsigned integers; unsigned integers are not initialized automatically (they take on whatever value was in memory previously) so the Date begins its life with \"garbage\" values stored in it.  We can set the members to new values individually by name, using the \".\" operator.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    Date today;\r\n    today.year = 2014;\r\n    today.month = 10;\r\n    today.day = 28;\r\n    ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>We can read the \".\" to mean \"The thing on the left has members and I'd like to access the member named on the right.\"  So, for example, <b>today.year</b> indicates that we believe <b>today</b> to be an object with members (it is!) and that we'd like to access its <b>year</b> member (which it has!).  Since the compiler is aware of the layout of the struct &mdash; not only the names of the members, but their relative positions in memory inside of it &mdash; it will know precisely where to go.</p>\r\n\r\n<p>Alternatively, we can initialize a struct's members at the point where we create it using C++'s <i>uniform initialization</i> syntax &mdash; which, as we'll see, standardizes the way that objects of most types can be initialized.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    Date today{2014, 10, 28};\r\n    ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The construct <b>{2014, 10, 28}</b> is called an <i>initializer list</i>, which specifies a sequence of values that are to be used to initialize <b>today</b>.  Using an initializer list with a struct causes the struct's members to be initialized in the order they're declared in the struct declaration &mdash; so, <b>year</b>, then <b>month</b>, then <b>day</b>.\r\n\r\n<p>(Note that there are a couple of consequences of using initializer lists in this way.  One consequence is that a change in the order of the members in the struct declaration might radically change how your code behaves without you receiving a compile-time error.  Another is that you've removed the members' names from your point in your code where initialization happens, which can sometimes make it harder for a program to read; you could argue that it's fairly clear what \"2014\", \"10\", and \"28\" are intended to be here, but even a simple case like this isn't entirely obvious, since dates are typically written with their components in different orders in different parts of the world.)</p>\r\n\r\n<p>When a statically-allocated struct falls out of scope, it is destroyed automatically, taking its members with it.  Note, though, that if its members are pointers, the pointers will be destroyed, <i>but the objects the pointers point to will not!</i></p>\r\n\r\n<p class=\"subtitle\">Dynamically allocating a struct</p>\r\n\r\n<p>Structs can also be allocated dynamically, as well, using the same <b>new</b> operator that we've seen previously.  As before, the <b>new</b> operator returns a pointer to the newly-allocated struct.</p>\r\n\r\n<blockquote><pre>\r\nDate* d = new Date;\r\n</pre></blockquote>\r\n\r\n<p>In this case, 12 bytes will be allocated on the heap and a pointer to the 12-byte block will be returned.</p>\r\n\r\n<p>Accessing the members of a struct through a pointer is a little bit trickier.</p>\r\n\r\n<blockquote><pre>\r\nd.year = 2005;     // Illegal, because d is a pointer; it has no member called <b>year</b>\r\n*d.year = 2005;    // Also illegal, because \".\" has a higher precedence than \"*\"\r\n(*d).year = 2005;  // Legal, but ugly as sin!\r\n</pre></blockquote>\r\n\r\n<p>Only the last of these says what we actually mean: \"Go to where <b>d</b> (a Date pointer) points and <i>then</i> access its <b>year</b> member.\"  But it's a really unfortunate piece of syntax, because it's ugly and error-prone.  So C++ includes another operator, the \"arrow\" operator (-&gt;) that means the same thing: \"The thing on the left is a pointer to an object with members.  Go to where it points and <i>then</i> access the member named on the right.\"</p>\r\n\r\n<blockquote><pre>\r\nd-&gt;year = 2005;  // Much nicer!\r\n</pre></blockquote>\r\n\r\n<p>Similar to statically-allocated structs, you can use an initializer list to give values to the struct's members at the time of creation.</p>\r\n\r\n<blockquote><pre>\r\nDate* d = new Date{2014, 10, 28};\r\n</pre></blockquote>\r\n\r\n<p>As with other dynamically-allocated objects, we'll need to deallocate the struct when we're done with it.  We do this the same way that we deallocate other dynamically-allocated objects, by using the <b>delete</b> operator.</p>\r\n\r\n<blockquote><pre>\r\ndelete d;\r\n</pre></blockquote>\r\n\r\n<p>The Date object will be deleted, taking its members with it, but note again that if any members are pointers, the pointers will be destroyed, but <i>the objects the pointers point to will not!</i></p>\r\n\r\n<p class=\"subtitle\">Passing structs as parameters</p>\r\n\r\n<p>A struct can be passed to a function in the same ways that an <b>int</b> can: by value (meaning that a <i>copy</i> of the struct is passed), by reference (meaning that a reference to the struct is passed, so changes to the struct inside the function take effect in the caller), and so on.  Pass by value offers the guarantee of <i>value semantics</i> (changes inside the function do not affect the caller), though this can be expensive if the struct is large, so in those cases, we might prefer passing the struct by reference (with <b>const</b>, if we want to protect the caller's struct from being changed).</p>\r\n\r\n<p>Syntactically, passing a struct as a parameter is unsurprising.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo(Date d)\r\n{\r\n    // d is a copy of the struct passed as a parameter\r\n}\r\n\r\nvoid bar(Date& d)\r\n{\r\n    // modifications to d take effect in the caller\r\n}\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">A disclaimer about structs</p>\r\n\r\n<p>The actual rules in C++ differ a bit from what I've said here.  Structs are more capable than this &mdash; and, as we'll see, they are technically indistinguishable from classes, except in only the most minor ways &mdash; but, as a practical matter, structs are most often used in the way we've seen here; they provide the ability to bring a set of public members together and nothing else.</p>\r\n\r\n<p>We'll only be using structs in this way this quarter; whenever we want something more full-featured, we'll use classes instead.  (Note, too, that this is all structs can do historically; in C, there are no classes, and structs are limited to what you see here.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>Structs</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code Structs</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"Structs.tar.gz\">Structs.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 10021.0}