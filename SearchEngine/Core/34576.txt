{"text": "Self Referential Classes Linked Objects Introduction to Computer Science II ICS 22 Introduction In this lecture we will begin studying self referential classes which leaded to linked objects Initially we will discuss in great detail the simplest kind of linked objects linear linked lists Later this week we will discuss more advanced linked list lists with header trailer nodes circular lists doubly linked lists etc By the end of the quarter we will have also fully discussed more generally non linear self referential structures trees and graphs Linear linked structures are used like arrays to store a sequence of values We will soon examine how to use all kinds of linked structures to implement a many different collection classes We have also already seen implementations for some of these same collection classes using arrays Deciding whether to use an array or linked structure when implementing a class depends on its ease of implementation and performance time and space so complexity classes expressed as big O notation will make a come back The LN Class The major topic of discussion for the next few days is how to use a slight generalization private static instead of public with Object replacing int of the following class public class LN public LN int i LN n value i next n public int value public LN next Read LN as an abbreviation for List Node It may seem odd to make such a fuss about such a simple class one that contains only a constructor along with two public instance variables so no accessors or mutators are needed to retrieve or alter their contents The key to all its interestingness is that every object constructed from the LN contains a next instance variable that stores null or a reference to another object from this class The value null is used to indicate the last node in the list there is no list node following it Thus null references serve an important purpose here before now about the only use of null was when Java reported NullPointerException when trying to call a method on a variable typically a member of an array that stored null i e did not refer to an object The data structures that arise from repeatedly constructing objects from this class are similar in content to arrays they store some sequence of values An example of one such structure is shown below Notice that the last next instance variables stores a null Although this picture is accurate it is also cumbersome to draw Instead we will often abbreviate such pictures as shown below Notice that the picture below blurs the important distinction between an object and its instance variables and in addition the value null appears just as a a slash in the final object Ensure that you know how to draw the real pictures before adopting this shorthand Note that the placement of the LN objects on the page and the exact places that the arrows point to in the LN object really they refer to the whole object is irrelevant What is relevant is being able to follow references from one object to the next one etc As with all pictorial representations of data these will be important when we need to visualize complicated data structures and the operations we perform on them Note the following accesses and their classes and values Any cascaded access chain ending in value specifies some instance variable storing an int any cascaded access chain ending in next specifies some instance variable storing null or a reference to the next LN object x specifies a variable that stores a reference to the first object of class LN x value specifies an instance variable in the first object that stores the int 5 x next specifies an instance variable in the first object that stores a reference to the second object of class LN x next value specifies an instance variable in the second object that stores the int 3 x next next specifies an instance variable in the second object that stores a reference to the third object of class LN x next next value specifies an instance variable in the third object that stores the int 8 x next next next next next next specifies an instance variable in the sixth object that stores null Only the last object can store null otherwise a link is broken Traversing Linked Lists via Cursors As with arrays the main processing that we do with linked lists is to traverse them visiting and somehow processing every value that they store For example the following code computes the sum of all the values contained in a linked list Note the similarity to a for loop for processing a sequence of integers stored in an array int sum for LN r x r null r r next sum r value System out println Sum sum The for loop s parts initialize the reference r to refer to the first object in the linked list using the standard semantics for copying references test r to ensure that it still refers to some object in the linked list e g its values is not null advance r to refer to the next object in the linked list or possibly null when there are no more objects to refer to Tthe statement r r next is the key to understanding how to traverse linked lists it is the linked list equivalent of i when processing arrays The following picture is a hand simulation that illustrates how r takes on successive references to the objects in the linked list summing the value instance variable of each Compare this loop with the equivalent loop for adding up all the values in an array Each uses a special variable which we shall now call a cursor to step through every value in their respective data structures Generally a cursor is is a small value that refers to a specific location in a data structure that can store many values The most often use of the term cursor refers to the one seen in a text editor there the cursor refers to the location where characters will be entered deleted among the many characters in a file For arrays the cursor is an int index for linked lists the cursor is a reference to some object in a linked list We check array cursors numerically to determine whether they are still small enough to refer to index a value in an array we check linked list cursors against null to determine whether they still refer to some object in the linked list We advance array cursors by incrementing them we advance linked list cursors via a statement like r r next which updates r to refer to the next value beyond the one r current refers to The for loop in Java is thus general enough to compactly specify all the information needed for traversing lists More Examples of Code for Linked List Processing Here are some more examples of processing linked list code via traversals I encourage you to hand simulate this code until you become comfortable with processing linked lists by traversals While I can often look at array code and figure it out often with linked list code especially if it is subtle I need to perform a hand simuation to understand or debug it The first code fragments prints all the values stored in a linked list with commas between the values for LN r x r null r r next System out println r value r next null Next let s assume that we declare DecisionInt criteria and store into it a reference to some object constructed from a class that implements the DecisionInt interface We can modify the code above to print only the OK values in this linked list we cannot put commas after values do you see why so we use a commas before values approach boolean first true for LN r x r null r r next if criteria isOK r value System out println first r value first false Next is a static method for computing the length of a linked list public static int length LN l int answer for LN r l r null r r next answer return answer The following picture illustrates a hand simulation of this method using a static call frame first transmitting the argument reference to the parameter reference We can simplify the code in this method by using the parameter itself to traverse the list public static int length LN l int answer for l null l l next answer return answer Executing this code sill leaves x refering to the list and still returns a value of 4 The parameter changes but not its matching argument which just receives its initial value from the argument In many cases such methods are written inside classes to use one of their instance variables referring to the beginning of a linked list and we need to write a for loop that declares a new variable for traversing the list leaving the instance variable unchanged Next another static method this time for computing the number of times that some int value occurs in the list public static int countOccurences LN l int toCheck int answer for LN r l r null r r next if r value toCheck answer return answer So it is frequently the case with for loops traversing linked lists as was the case with for loops traversing arrays that the same pattern for initializing testing and advancing is used But as also seen with arrays some code does have slight variants as is illustrated below in code that computes whether a linked list is sorted in ascending actually non descending order public static boolean isSorted LN l for LN r l r null r next null r r next if r value r next value return false return true Notice the more complicated test for continuation termination if either r stores null or it refers to an object whose next instance variables stores null Examine how this method works carefully when passed an empty list null as a parameter and a reference to a linked list that contains just one object in both cases the linked is sorted because we cannot find a pair of values out of order Here short circuit evaluation is critical if r null is is false evaluating r next null would throw NullPointerException if it were evaluated Building Linked Lists It is easy to update the variable x from null refering to an empty list to refer to a list with one value say 5 x new LN 5 null Likewise we can extend this list to a second value say 2 by writing x next new LN 2 null And we can extend this list to a third value say 7 by writing x next next new LN 7 null We can continue in this manner to build a linked list manually In fact we can even write this as one complicated assignment x new LN 5 new LN 2 new LN 7 null But this method requires us to write code manually for every linked list that we must build Now let us examine ways to build lists automatically say by reading values from a file The following simple code reads all the values from a file assume TypedBufferReader tbr has been declared and intialized and places them in a linked list for try x new LN tbr readInt x catch EOFException eofe break Note the x on both size of the equal sign Generally the code x new LN someValue x adds someValue at the front of the list whether the list is originally empty or not try both ways making its next refer to the original linked list Note that executing the statement x new LN tbr readInt x is in the complexity class O 1 no matter how big of a list x refers to this operation is completed in constant time independent of the list size Thus since this operation is executed N times the complexity class of reading in a list is O N The only drawback of this code is that the values appear in the linked list in the reverse of the order in which they appear in the file which may or may not be a problem depending on how we want to process the data hand simulate this code for reading a file with just a few values in it to verify this statement If we need the sequence of values stored in the same order as they appeared in the file we have many possible ways to accomplish this task First we can reverse the list see the next lecture or make the code more complicated Below let s examine the code needed to place a new list node at the rear of a linked list The strategy for doing so can be easily described If the list is empty change x to refer to the new list node If the list is not empty locate its last list node the only one currently storing null in its next instance variable then store a reference to the new list node in that next field In both cases the new list node stores null in its next instance variable because it is becoming the new last node in the list Assume that int someValue stores the value we want to add at the end of the list We can translate this description into the following Java code if x null x new LN someValue null else LN r x for r next null r r next r next new LN someValue null There are a few interesting aspects of this code The cursor r must be declared outside the for loop not inside it The reason is that r which is made to refer to the current last node in the list must be altered after the loop terminates any variable declared inside the loop would not be usable outside the loop body The purpose of the loop is to store into r a reference to the current last node in the list so all it does is advance r until it refers to a list node whose next stores null So note that the body of the loop is just this empty block statement could be replaced by just the empty statement but we prefer to emphasize this lack of actions with an empty block Some programmers would even write nothing as the body of the loop The continuation test is only r next null the first time we check this test we know that r stores a non null reference see the if statement Likewise for each subsequent loop we know that r when updated to r next will also store a non null value Thus this code will never throw a NullPointerException An alternative way to write this code less elegant in my opinion but possibly easier to understand is if x null x new LN someValue null else for LN r x r r next Continuation test is always true if r next null r next new LN someValue null break Given this code for adding a new value at the end of a linked list we can now write code that reads all the values from a file and places them in a linked list in the correct order using two nested loops for try int someValue tbr readInt if x null x new LN someValue null else LN r x for r next null r r next r next new LN someValue null catch EOFException eofe break Although this code is correct it can be very inefficient its complexity class if N is the number of values read is O N2 The source of the inefficiency is repeatedly scanning the linked list to find its end The first time requires scanning past nodes the second time requires scanning past 1 node the third time requires scanning past 2 nodes the Nth time requires scanning past N 1 nodes So to insert N nodes into this list requires scanning 1 2 N 1 nodes We have seen this before and should memorize if we haven t already the general formula for 1 2 N is N N 1 2 so in this case the result is N 1 N 1 1 2 N N 1 2 Of course this is in the complexity class O N2 For inserting 1 nodes in a list requires scanning 499 5 nodes for inserting 1 nodes in a list requires scanning about 5 nodes Even at 1 billon scans per second that would take 8 minutes Everett Dirkson an ancient Senator from Illinois was once quoted as A billion dollars here a billion dollars there pretty soon it adds up to real money A later day Dirkson one in computer science might say the same about nanoseconds adding up to real time We can drastically speed up this process changing its complexity class back to O N by caching a reference to the last node in a list and updating it whenever a new node is added at the end In this way we can eliminate scanning altogether or another way to look at it is scanning each newly added list node once and remembering it this is similar to amortized complexity computations The technique of caching is a wonderful example of a space for time tradeoff by increasing the amount of space by storing an extra reference we can decrease the amount of running time The code to accomplish this same task more efficiently in time a bit less in space is LN lastCache null for try int someValue tbr readInt if lastCache null lastCache x new LN someValue null else lastCache next new LN someValue null lastCache lastCache next catch EOFException eofe break In fact as an extra bonus this code is even simpler less confusing than the code shown above if we understand how the lastCache is initialized and used Java masochists could simplify the else block by writing the single statement similarly to what appears before the else lastCache lastCache next new LN someValue null whose double assignment does the job of both statements in the block Notice that lastCache next lastCache new LN someValue null with the order of the two values receiving the assignment FAILS TO DO THE JOB Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a TA or any other student Hand simulate the following code fragment on an empty list first on a list containing one object x refers to it and on the linked lists illustrate at the beginning of this lecture LN answer null for x null LN toMove x x x next toMove next answer answer toMove x answer Describe the result of using the incorrect statement lastCache next lastCache new LN someValue null in the code above that reads values from a file and puts them in a list in the same sequential order For a file of 3 values does this code throw an exception If not what does the final list look like ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/lectures/linkedlists/lecture.html", "title": "self-referential classes/linked objects", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Self-Referential Classes/Linked Objects</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Self-Referential Classes/Linked Objects</h1>\r\n<p>\r\n<h2>Introduction to Computer Science II<br>\r\nICS-22<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture we will begin studying self-referential classes, which\r\n  leaded to linked objects.\r\nInitially we will discuss in great detail the simplest kind of linked\r\n  objects: linear linked lists.\r\nLater this week, we will discuss more advanced linked list: lists with\r\n  header/trailer nodes, circular lists, doubly-linked lists, etc.\r\nBy the end of the quarter we will have also fully discussed more generally,\r\n  non-linear, self-referential structures (trees and graphs).\r\n<p>\r\nLinear linked structures are used, like arrays, to store a sequence of values.\r\nWe will soon examine how to use all kinds of linked structures to implement a\r\n  many different collection classes.\r\nWe have also already seen implementations for some of these same collection\r\n  classes, using arrays.\r\nDeciding whether to use an array or linked structure when implementing a class\r\n  depends on its ease of implementation and performance (time and space):\r\n  so, complexity classes expressed as big O notation will make a come-back.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- The LN Class -->\r\n\r\n<a name=\"Class\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The LN Class</b></td>\r\n<td width =\"80%\">\r\nThe major topic of discussion for the next few days is how to use a slight\r\n  generalization (<b>private static</b> instead of <b>public</b>, with\r\n  <b>Object</b> replacing <b>int</b>) of the following class:\r\n<pre><b>  public class LN {\r\n    public LN (int i, LN n)\r\n    {value = i; next = n;}\r\n\r\n    public int value;\r\n    public LN  next;\r\n  }</b></pre>\r\nRead <b>LN</b> as an abbreviation for List Node.\r\nIt may seem odd to make such a fuss about such a simple class: one that\r\n  contains only a constructor, along with two <b>public</b> instance variables\r\n  (so no accessors or mutators are needed to retrieve or alter their contents).\r\nThe key to all its interestingness is that every object constructed from the\r\n  <b>LN</b> contains a <b>next</b> instance variable that stores <b>null</b> or\r\n  a reference to another object from this class.\r\n<p>\r\nThe value <b>null</b> is used to indicate the last node in the list (there is\r\n  no list node following it).\r\nThus, <b>null</b> references serve an important purpose here; before now,\r\n  about the only use of <b>null</b> was when Java reported\r\n  <b>NullPointerException</b> when trying to call a method on a variable\r\n  (typically a member of an array) that stored <b>null</b>; i.e., did not\r\n   refer to an object.\r\n<p>\r\nThe data structures that arise from repeatedly constructing objects from this\r\n  class are similar in content to arrays: they store some sequence of values.\r\nAn example of one such structure is shown below.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/linkedlist.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNotice that the last <b>next</b> instance variables stores a <b>null</b>.\r\nAlthough this picture is accurate, it is also cumbersome to draw.\r\nInstead, we will often abbreviate such pictures as shown below.\r\nNotice that the picture below blurs the important distinction between an object\r\n  and its instance variables, and in addition the value <b>null</b> appears\r\n  just as a <b>/</b> (a slash) in the final object.\r\nEnsure that you know how to draw the real pictures before adopting this\r\n  shorthand.\r\n<p>\r\n<img src=\"images/linkedlist2.gif\"></image>\r\n<p>\r\nNote that the placement of the <b>LN</b> objects on the page and the exact \r\n places that the arrows point to \"in\" the <b>LN</b> object (really they refer\r\n  to the whole object) is irrelevant.\r\nWhat is relevant is being able to follow references from one object to the\r\n  next one, etc.\r\nAs with all pictorial representations of data, these will be important when\r\n  we need to visualize complicated data structures and the operations we\r\n  perform on them.\r\n<p>\r\nNote the following accesses and their classes and values.\r\nAny cascaded access chain ending in <b>.value</b> specifies some instance\r\n  variable storing an <b>int</b>; any cascaded access chain ending in\r\n  <b>.next</b> specifies some instance variable storing <b>null</b> or\r\n  a reference to the next <b>LN</b> object.\r\n<ul>\r\n<li><b>x</b> specifies a variable that stores a reference to the first object\r\n  of class <b>LN</b>\r\n<li><b>x.value</b> specifies an instance variable (in the first object) that\r\n  stores the <b>int</b> 5\r\n<li><b>x.next</b> specifies an instance variable (in the first object) that\r\n  stores a reference to the second object of class <b>LN</b>\r\n<li><b>x.next.value</b> specifies an instance variable (in the second object)\r\n  that stores the <b>int</b> 3\r\n<li><b>x.next.next</b> specifies an instance variable (in the second object)\r\n  that stores a reference to the third object of class <b>LN</b>\r\n<li><b>x.next.next.value</b> specifies an instance variable (in the third\r\n  object) that stores the <b>int</b> 8\r\n<li>...\r\n<li><b>x.next.next.next.next.next.next</b> specifies an instance variable (in\r\n  the sixth object) that stores <b>null</b>\r\nOnly the last object can store <b>null</b>, otherwise a link is broken.\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Traversals -->\r\n\r\n<a name=\"Traversals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Traversing Linked Lists via Cursors</b></td>\r\n<td width =\"80%\">\r\nAs with arrays, the main processing that we do with linked lists is to traverse\r\n  them, visiting (and somehow processing) every value that they store.\r\nFor example, the following code computes the sum of all the values contained\r\n  in a linked list.\r\nNote the similarity to a <b>for</b> loop for processing a sequence of integers\r\n  stored in an array.\r\n<pre><b>  int sum = 0;\r\n  for (LN r=x; r!=null; r=r.next)\r\n    sum += r.value;\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\nThe <b>for</b> loop's parts\r\n<ul>\r\n<li>initialize the reference <b>r</b> to refer to the first object in the\r\n  linked list (using the standard semantics for copying references)\r\n<li>test <b>r</b> to ensure that it still refers to some object in the linked\r\n  list (e.g., its values is not <b>null</b>)\r\n<li>advance <b>r</b> to refer to the next object in the linked list (or\r\n  possibly <b>null</b>, when there are no more objects to refer to)\r\nTthe statement <b>r=r.next</b> is the key to understanding how to traverse\r\n  linked lists: it is the linked-list equivalent of <b>i++</b> when processing\r\n  arrays.\r\n</ul>\r\nThe following picture is a hand simulation that illustrates how <b>r</b> takes\r\n  on successive references to the objects in the linked list, summing the\r\n  <b>value</b> instance variable of each.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/sumup.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nCompare this loop with the equivalent loop for adding up all the values in an\r\n  array.\r\nEach uses a special variable (which we shall now call a cursor) to step through\r\n  every  value in their respective data structures.\r\nGenerally, a cursor is is a small value that refers to a specific location in a\r\n  data structure that can store many values.\r\nThe most often use of the term cursor refers to the one seen in a text editor:\r\n  there the cursor refers to the location where characters will be\r\n  entered/deleted among the many characters in a file.\r\n<p>\r\nFor arrays, the cursor is an <b>int</b> index; for linked lists, the cursor is\r\n  a reference to some object in a linked list.\r\nWe check array cursors numerically to determine whether they are still small\r\n  enough to refer to index a value in an array; we check linked list cursors\r\n  against <b>null</b> to determine whether they still refer to some object in\r\n  the linked list.\r\nWe advance array cursors by incrementing them; we advance linked list cursors\r\n  via a statement like <b>r = r.next;</b> which updates <b>r</b> to refer to\r\n  the next value beyond the one <b>r</b> current refers to.\r\nThe <b>for</b> loop in Java is thus general enough to compactly specify all\r\n  the information needed for traversing lists.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- More Examples -->\r\n\r\n<a name=\"Examples\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>More Examples of Code for Linked List Processing</b></td>\r\n<td width =\"80%\">\r\nHere are some more examples of processing linked list code via traversals.\r\nI encourage you to hand simulate this code until you become comfortable with\r\n  processing linked lists by traversals.\r\nWhile I can often look at array code and figure it out, often with linked list\r\n  code, especially if it is subtle, I need to perform a hand simuation to\r\n  understand or debug it.\r\n<p>\r\nThe first code fragments prints all the values stored in a linked list, with\r\n  commas  between the values.\r\n<pre><b>  for (LN r=x; r!=null; r=r.next)\r\n    System.out.println(r.value + (r.next!=null ? \",\" : \"\"));</b></pre>\r\nNext, let's assume that we declare <b>DecisionInt criteria;</b> and store into\r\n  it a reference to some object constructed from a class that implements the\r\n  <b>DecisionInt</b> interface.\r\nWe can modify the code above to print only the OK values in this linked list\r\n  (we cannot put commas after values -do you see why- so we use a\r\n  commas-before-values approach.\r\n  <pre><b>  boolean first = true;\r\n  for (LN r=x; r!=null; r=r.next)\r\n    if (criteria.isOK(r.value)) {\r\n       System.out.println( (first ? \"\" : \",\") + r.value);\r\n       first = false;\r\n    }</b></pre>\r\nNext is a <b>static</b> method for computing the length of a linked list.\r\n<pre><b>  public static int length (LN l)\r\n  {\r\n    int answer = 0;\r\n    for (LN r=l; r!=null; r=r.next)\r\n      answer++;\r\n    return answer;\r\n   }</b></pre>\r\nThe following picture illustrates a hand simulation of this method using a \r\n <b>static</b> call frame, first transmitting the argument reference to the\r\n  parameter reference.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/length.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nWe can \"simplify\" the code in this method by using the parameter itself to\r\n  traverse the list.\r\n<pre><b>  public static int length (LN l)\r\n  {\r\n    int answer = 0;\r\n    for (; l!=null; l=l.next)\r\n      answer++;\r\n    return answer;\r\n   }</b></pre>\r\nExecuting this code sill leaves <b>x</b> refering to the list and still returns\r\n  a value of <b>4</b>.\r\nThe parameter changes, but not its matching argument (which just receives its\r\n  initial value from the argument).\r\nIn many cases, such methods are written inside classes to use one of their\r\n  instance variables (referring to the beginning of a linked list) and we need\r\n  to write a <b>for</b> loop that declares a new variable for traversing the\r\n  list (leaving the instance variable unchanged).\r\n<p>\r\nNext, another <b>static</b> method, this time for computing the number of\r\n  times that some <b>int</b>  value occurs in the list.\r\n<pre><b>  public static int countOccurences (LN l, int toCheck)\r\n  {\r\n    int answer = 0;\r\n    for (LN r=l; r!=null; r=r.next)\r\n      if (r.value == toCheck)\r\n        answer++;\r\n    return answer;\r\n   }</b></pre>\r\n  <p>\r\nSo, it is frequently the case with <b>for</b> loops traversing linked lists (as\r\n  was the case with <b>for</b> loops traversing arrays), that the same pattern\r\n  for initializing, testing, and advancing is used.\r\nBut as also seen with arrays, some code does have slight variants, as is \r\n illustrated below in code  that computes whether a linked list is sorted in\r\n  ascending (actually non-descending) order.\r\n<pre><b>  public static boolean isSorted (LN l)\r\n  {\r\n    for (LN r=l; r!=null && r.next!=null; r=r.next)\r\n      if (r.value > r.next.value)\r\n        return false;\r\n    return true;\r\n   }</b></pre>\r\nNotice the more complicated test for continuation/termination: if either\r\n  <b>r</b> stores <b>null</b>, or it refers to an object whose <b>next</b>\r\n  instance variables stores <b>null</b>.\r\nExamine how this method works carefully when passed an empty list\r\n  (<b>null</b>) as a parameter and a reference to a linked list that contains\r\n  just one object: in both cases the linked is sorted because we cannot find a\r\n  pair of values out of order.    \r\nHere, short-circuit evaluation is critical: if <b>r!=null</b> is is\r\n  <b>false</b> evaluating <b>r.next!=null</b> would throw\r\n  <b>NullPointerException</b>, if it were evaluated.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Building Linked Lists -->\r\n\r\n<a name=\"Building\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Building Linked Lists</b></td>\r\n<td width =\"80%\">\r\nIt is easy to update the variable <b>x</b> from <b>null</b> (refering to an\r\n  empty list) to refer to a list with one value, say <b>5</b>:\r\n   <b>x = new LN(5,null);</b>\r\nLikewise, we can extend this list to a second value, say <b>2</b> by writing\r\n  <b>x.next = new LN(2,null);</b>\r\nAnd, we can extend this list to a third value, say <b>7</b> by writing\r\n    <b>x.next.next = new LN(7,null);</b>\r\nWe can continue in this manner to build a linked list manually.\r\nIn fact, we can even write this as one complicated assignment:\r\n    <b>x = new LN (5, new LN (2, new LN(7, null)));</b>\r\nBut, this method requires us to write code manually for every linked list that\r\n  we must build.\r\n<p>\r\nNow let us examine ways to build lists automatically, say by reading values\r\n  from a file.\r\nThe following simple code reads all the values from a file (assume\r\n  <b>TypedBufferReader tbr</b> has been declared and intialized) and places\r\n  them in a linked list.\r\n<pre><b>  for (;;)\r\n    try {\r\n      x = new LN(tbr.readInt(), x);\r\n    }catch (EOFException eofe) {break;}</b></pre>\r\nNote the <b>x</b> on both size of the equal sign.\r\nGenerally, the code <b>x = new LN (someValue, x);</b> adds <b>someValue</b> at\r\n  the front of the list (whether the list is originally empty or not: try both\r\n  ways) making its <b>next</b> refer to the original linked list.\r\n<p>\r\nNote that executing the statement <b>x = new LN(tbr.readInt(),x);</b> is in\r\n  the complexity class O(1): no matter how big of a list <b>x</b> refers to,\r\n  this operation is completed in constant time (independent of the list size).\r\nThus, since this operation is executed N times, the complexity class of reading\r\n  in a list is O(N).\r\n<p>\r\nThe only drawback of this code is that the values appear in the linked list in\r\n  the reverse of the order in which they appear in the file (which may or may\r\n  not be a problem depending on how we want to process the data); hand simulate\r\n  this code for reading a file with just a few values in it to verify this\r\n  statement.\r\nIf we need the sequence of values stored in the same order as they appeared in\r\n  the file, we have many possible ways to accomplish this task.\r\nFirst, we can reverse the list (see the next lecture), or make the code more\r\n  complicated.\r\n<p>\r\nBelow, let's examine the code needed to place a new list node at the rear of a\r\n  linked list.\r\nThe strategy for doing so can be easily described:\r\n<ul>\r\n<li>If the list is empty, change <b>x</b> to refer to the new list node\r\n<li>If the list is not empty, locate its last list node (the only one\r\n  currently storing <b>null</b> in its <b>next</b> instance variable), then\r\n  store a reference to the new list node in that <b>next</b> field.\r\n</ul>\r\nIn both cases, the new list node stores <b>null</b> in its <b>next</b>\r\n  instance variable, because it is becoming the \"new\" last node in the list.\r\nAssume that <b>int someValue</b> stores the value we want to add at the end of\r\n  the list.\r\nWe can translate this description into the following Java code.\r\n  <pre><b>  if (x == null)\r\n    x = new LN (someValue,null);\r\n  else {\r\n    LN r = x;\r\n    for (; r.next!=null; r=r.next)\r\n      {}\r\n    r.next = new LN(someValue,null);\r\n  }</b></pre>\r\nThere are a few interesting aspects of this code.\r\n  <ul>\r\n<li>The cursor <b>r</b> must be declared outside the <b>for</b> loop, not\r\n      inside it.\r\n    The reason is that <b>r</b> (which is made to refer to the current last\r\n      node in the list) must be altered after the loop terminates; any\r\n      variable declared inside the loop would not be usable outside the loop\r\n      body.\r\n<li>The purpose of the loop is to store into <b>r</b> a reference to the\r\n      current last node in the list: so all it does is advance <b>r</b> until\r\n       it refers to a list node whose <b>next</b> stores <b>null</b>.\r\n    So note that the body of the loop is just <b>{}</b>: this empty block\r\n       statement could be replaced by just the empty statement <b>;</b> but\r\n       we prefer to emphasize this \"lack of actions\" with an empty block.\r\n    Some programmers would even write <b>{\\*nothing*\\}</b> as the body of the\r\n       loop.\r\n<li>The continuation test is only <b>r.next!=null</b>; the first time we check\r\n       this test we know that <b>r</b> stores a non-null reference (see the\r\n       <b>if</b> statement).\r\n     Likewise, for each subsequent loop we know that <b>r</b>, when updated to\r\n        <b>r.next</b> will also store a non-null value.\r\n     Thus, this code will never throw a <b>NullPointerException</b>.\r\n</ul>\r\nAn alternative way to write this code (less elegant, in my opinion, but\r\n  possibly easier to understand) is\r\n  <pre><b>  if (x == null)\r\n    x = new LN (someValue,null);\r\n  else {\r\n    for (LN r=x ;; r=r.next)  //Continuation test is always true\r\n      if (r.next == null) {\r\n         r.next = new LN(someValue,null);\r\n         break;\r\n      }\r\n  }</b></pre>\r\nGiven this code for adding a new value at the end of a linked list, we can now\r\n  write code that reads all the values from a file and places them in a linked\r\n  list in the correct order, using two nested loops.\r\n<pre><b>  for (;;)\r\n    try {\r\n      int someValue = tbr.readInt();\r\n      if (x == null)\r\n        x = new LN (someValue,null);\r\n      else {\r\n        LN r = x;\r\n        for (; r.next!=null; r=r.next)\r\n          {}\r\n        r.next = new LN(someValue,null);\r\n      }\r\n    }catch (EOFException eofe) {break;}</b></pre>\r\nAlthough this code is correct, it can be very inefficient: its complexity\r\n  class, if N is the number of values read, is O(N<sup>2</sup>).\r\nThe source of the inefficiency is repeatedly scanning the linked list to find\r\n  its end.\r\nThe first time requires scanning past 0 nodes; the second time requires\r\n  scanning past 1 node, the third time requires scanning past 2 nodes, ... the\r\n  Nth time requires scanning past N-1 nodes.\r\nSo, to insert N nodes into this list requires scanning 0+1+2+...+N-1 nodes.\r\n<p>\r\nWe have seen this before (and should memorize if we haven't already): the\r\n  general formula for 1+2+...+N is N(N+1)/2, so in this case the result is\r\n  (N-1)(N-1+1)/2 = N(N-1)/2.\r\nOf course, this is in the complexity class O(N<sup>2</sup>).\r\nFor inserting 1,000 nodes in a list requires scanning 499,500 nodes;\r\n  for inserting 1,000,000 nodes in a list requires scanning about\r\n  500,000,000,000 nodes!\r\nEven at 1 billon scans per second, that would take 8 minutes.\r\nEverett Dirkson, an ancient Senator from Illinois, was once quoted as\r\n  \"A billion dollars here, a billion dollars there, pretty soon it adds\r\n  up to real money\".\r\nA later day Dirkson, one in computer science, might say the same about\r\n  nanoseconds adding up to real time.\r\n  <p>\r\nWe can drastically speed-up this process (changing its complexity class back\r\n  to O(N)) by \"caching\" a reference to the last node in a list (and updating\r\n  it whenever a new node is added at the end).\r\nIn this way we can eliminate scanning altogether (or another way to look at it\r\n  is scanning each newly added list node once, and remembering it: this is\r\n  similar to amortized complexity computations).\r\nThe technique of caching is a wonderful example of a space for time tradeoff:\r\n  by increasing the amount of space (by storing an extra reference) we can\r\n  decrease the amount of running time.\r\nThe code to accomplish this same task more efficiently (in time; a bit less in\r\n  space) is\r\n<pre><b>  LN lastCache = null;\r\n  for (;;)\r\n    try {\r\n      int someValue = tbr.readInt();\r\n      if (lastCache == null)\r\n        lastCache = x = new LN (someValue,null);\r\n      else {\r\n        lastCache.next = new LN(someValue,null);\r\n        lastCache      = lastCache.next;\r\n      }\r\n    }catch (EOFException eofe) {break;}</b></pre>\r\nIn fact, as an extra bonus this code is even simpler (less confusing) than the\r\n  code shown above, if we understand how the <b>lastCache</b> is initialized\r\n  and used.\r\nJava masochists could \"simplify\" the <b>else</b> block by writing the single\r\n  statement (similarly to what appears before the <b>else</b>)\r\n    <pre><b> lastCache = lastCache.next = new LN(someValue,null);</b></pre>\r\n  whose double assignment does the job of both statements in the block.\r\nNotice that\r\n    <pre><b> lastCache.next = lastCache = new LN(someValue,null);</b></pre>\r\nwith the order of the two values receiving the assignment, FAILS TO DO THE\r\n  JOB.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n  <ol> \r\n<li>Hand simulate the following code fragment on an empty list, first on a list\r\n  containing one object (<b>x</b> refers to it), and on the linked lists\r\n  illustrate at the beginning of this lecture.\r\n<pre><b>  LN answer = null;\r\n  for (;x!=null;) {\r\n    LN toMove   = x;\r\n    x           = x.next;\r\n    toMove.next = answer;\r\n    answer      = toMove; \r\n  }\r\n    \r\n  x = answer;</b></pre>\r\n<p>\r\n<li>Describe the result of using the incorrect statement\r\n<pre><b> lastCache.next = lastCache = new LN(someValue,null);</b></pre>\r\n  in the code above that reads values from a file and puts them in a list, in\r\n    the same sequential order.\r\n  For a file of 3 values does this code throw an exception? If not, what does\r\n    the final list look like?\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 34576.0}