{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL HalfedgeDS decorator HDS Definition The classes CGAL HalfedgeDS items decorator HDS CGAL HalfedgeDS decorator HDS and CGAL HalfedgeDS const decorator HDS provide additional functions to examine and to modify a halfedge data structure HDS The class CGAL HalfedgeDS items decorator HDS provides additional functions for vertices halfedges and faces of a halfedge data structure without knowing the containing halfedge data structure The class CGAL HalfedgeDS decorator HDS stores a reference to the halfedge data structure and provides functions that modify the halfedge data structure for example Euler operators The class CGAL HalfedgeDS const decorator HDS stores a const reference to the halfedge data structure It contains non modifying functions for example the test for validness of the data structure All these additional functions take care of the different capabilities a halfedge data structure may have or may not have The functions evaluate the type tags of the halfedge data structure to decide on the actions If a particular feature is not supported nothing is done Note that for example the creation of new halfedges is mandatory for all halfedge data structures and will not appear here again include CGAL HalfedgeDS decorator h Inherits From CGAL HalfedgeDS items decorator HDS Creation HalfedgeDS decorator HDS D HDS hds keeps internally a reference to hds Creation of New Items Vertex handle D vertices push back Vertex v appends a copy of v to hds if vertices are supported Returns a handle of the new vertex or Vertex handle otherwise Face handle D faces push back Face f appends a copy of f to hds if faces are supported Returns a handle of the new face or Face handle otherwise Creation of New Composed Items Halfedge handle D create loop returns handle of a halfedge from a newly created loop in hds consisting of a single closed edge one vertex and two faces if supported respectively Halfedge handle D create segment returns a halfedge from a newly created segment in hds consisting of a single open edge two vertices and one face if supported respectively Removal of Elements The following member functions do not update affected incidence relations except if mentioned otherwise void D vertices pop front removes the first vertex if vertices are supported Requirement Supports removal CGAL Tag true void D vertices pop back removes the last vertex if vertices are supported void D vertices erase Vertex handle v removes the vertex v if vertices are supported Requirement Supports removal CGAL Tag true void D vertices erase Vertex handle first Vertex handle last removes the range first last if vertices are supported Requirement Supports removal CGAL Tag true void D faces pop front removes the first face if faces are supported Requirement Supports removal CGAL Tag true void D faces pop back removes the last face if faces are supported void D faces erase Face handle f removes the face f if faces are supported Requirement Supports removal CGAL Tag true void D faces erase Face handle first Face handle last removes the range first last if faces are supported Requirement Supports removal CGAL Tag true void D erase face Halfedge handle h removes the face incident to h from hds and changes all halfedges incident to the face into border edges or removes them from the halfedge data structure if they were already border edges If this creates isolated vertices they get removed as well See make hole h for a more specialized variant Precondition h is border false Requirement If faces are supported Supports removal CGAL Tag true void D erase connected component Halfedge handle h removes the vertices halfedges and faces that belong to the connected component of h Precondition For all halfedges g in the connected component g next Halfedge handle Requirement Supports removal CGAL Tag true Modifying Functions For Border Halfedges Halfedge handle D make hole Halfedge handle h removes the face incident to h from hds and creates a hole Precondition h Halfedge handle and h is border Requirement If faces are supported Supports removal CGAL Tag true Halfedge handle D fill hole Halfedge handle h fills the hole incident to h with a new face from hds Returns h Precondition h Halfedge handle and h is border Halfedge handle D fill hole Halfedge handle h Face f fills the hole incident to h with a copy of face f Returns h Precondition h Halfedge handle and h is border Halfedge handle D add face to border Halfedge handle h Halfedge handle g extends the surface with a new face from hds into the hole incident to h and g It creates a new edge connecting the vertex denoted by g with the vertex denoted by h and fills this separated part of the hole with a new face such that the new face is incident to g Returns the new halfedge that is incident to the new face Precondition h Halfedge handle g Halfedge handle h is border g is border and g can be reached along the hole starting with h Halfedge handle D add face to border Halfedge handle h Halfedge handle g Face f extends the surface with a copy of face f into the hole incident to h and g It creates a new edge connecting the tip of g with the tip of h and fills this separated part of the hole with a copy of face f such that the new face is incident to g Returns the new halfedge that is incident to the new face Precondition h Halfedge handle g Halfedge handle h is border g is border and g can be reached along the hole starting with h Modifying Functions Euler Operators The following Euler operations modify consistently the combinatorial structure of the halfedge data structure The geometry remains unchanged Note that well known graph operations are also captured with these Euler operators for example an edge contraction is equal to a join vertex operation or an edge removal to join face Given a halfedge data structure hds and a halfedge handle h four special applications of the Euler operators are worth mentioning split vertex h h results in an antenna emanating from the tip of h split vertex h h next opposite results in an edge split of the halfedge h next with a new vertex in between split face h h results in a loop directly following h and split face h h next results in a bridge parallel to the halfedge h next with a new face in between Halfedge handle D split face Halfedge handle h Halfedge handle g splits the face incident to h and g into two faces with a new diagonal between the two vertices denoted by h and g respectively The second new face obtained from hds is a copy of the first face Returns h next after the operation i e the new diagonal The new face is to the right of the new diagonal the old face is to the left The time is proportional to the distance from h to g around the face Halfedge handle D join face Halfedge handle h joins the two faces incident to h The face incident to h opposite gets removed from hds Both faces might be holes Returns the predecessor of h around the face The invariant join face split face h g returns h and keeps the data structure unchanged The time is proportional to the size of the face removed and the time to compute h prev Requirement Supports removal CGAL Tag true Halfedge handle D split vertex Halfedge handle h Halfedge handle g splits the vertex incident to h and g into two vertices and connects them with a new edge The second new vertex obtained from hds is a copy of the first vertex Returns h next opposite after the operation i e the new edge in the orientation towards the new vertex The time is proportional to the distance from h to g around the vertex Halfedge handle D join vertex Halfedge handle h joins the two vertices incident to h The vertex denoted by h opposite gets removed by hds Returns the predecessor of h around the vertex i e h opposite prev The invariant join vertex split vertex h g returns h and keeps the polyhedron unchanged The time is proportional to the degree of the vertex removed and the time to compute h prev and h opposite prev Requirement Supports removal CGAL Tag true Halfedge handle D create center vertex Halfedge handle h barycentric triangulation of h face Creates a new vertex a copy of h vertex and connects it to each vertex incident to h face splitting h face into triangles h remains incident to the original face all other triangles are copies of this face Returns the halfedge h next after the operation i e a halfedge pointing to the new vertex The time is proportional to the size of the face Precondition h is not a border halfedge Halfedge handle D erase center vertex Halfedge handle g reverses create center vertex Erases the vertex pointed to by g and all incident halfedges thereby merging all incident faces Only g face remains The neighborhood of g vertex may not be triangulated it can have larger faces Returns the halfedge g prev Thus the invariant h erase center vertex create center vertex h holds if h is not a border halfedge The time is proportional to the sum of the size of all incident faces Precondition None of the incident faces of g vertex is a hole There are at least two distinct faces incident to the faces that are incident to g vertex This prevents the operation from collapsing a volume into two faces glued together with opposite orientations such as would happen with any vertex of a tetrahedron Requirement Supports removal CGAL Tag true Halfedge handle D split loop Halfedge handle h Halfedge handle i Halfedge handle j cuts the halfedge data structure into two parts along the cycle h i j Three new vertices one copy for each vertex in the cycle and three new halfedges one copy for each halfedge in the cycle and two new triangles are created h i j will be incident to the first new triangle The return value will be the halfedge incident to the second new triangle which is the copy of h opposite Precondition h i j denote distinct consecutive vertices of the halfedge data structure and form a cycle i e h vertex i opposite vertex j vertex h opposite vertex Halfedge handle D join loop Halfedge handle h Halfedge handle g glues the boundary of the two faces denoted by h and g together and returns h Both faces and the vertices along the face denoted by g gets removed Both faces may be holes The invariant join loop h split loop h i j returns h and keeps the data structure unchanged Precondition The faces denoted by h and g are different and have equal degree i e number of edges Requirement Supports removal CGAL Tag true Validness Checks These operations are the same as for CGAL HalfedgeDS const decorator HDS bool D is valid bool verbose false int level bool D normalized border is valid bool verbose false Miscellaneous void D inside out reverses face orientations Precondition is valid of level three See Also CGAL HalfedgeDS items decorator HDS CGAL HalfedgeDS const decorator HDS Example The following program fragment illustrates the implementation of the Euler operator split vertex for a simplified polyhedron class template class Traits namespace CGAL class Polyhedron typedef HalfedgeDS default Traits HDS HDS hds public Halfedge handle split vertex Halfedge handle h Halfedge handle g HalfedgeDS decorator HDS D hds Stricter preconditions than for HalfedgeDS only CGAL precondition D get vertex h D get vertex g CGAL precondition h g return D split vertex h g Next HalfedgeDS default Traits HalfedgeDSItems Alloc Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/HalfedgeDS_ref/Class_HalfedgeDS_decorator.html", "title": "halfedgeds_decorator&lt;hds&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './HalfedgeDS_ref/HalfedgeDS_decorator.tex' -->\n<html> <head>  \n<title>HalfedgeDS_decorator&lt;HDS&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_880\"></A>\n\n<A NAME=\"Cross_link_anchor_881\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_857\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::HalfedgeDS_decorator<HDS>\"></A>\n<h2><I>CGAL::HalfedgeDS_decorator&lt;HDS&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe classes <I><A HREF=\"Class_HalfedgeDS_items_decorator.html#Cross_link_anchor_895\">CGAL::HalfedgeDS_items_decorator</A>&lt;HDS&gt;</I>,\n<I><A HREF=\"Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt;</I>, and\n<I><A HREF=\"Class_HalfedgeDS_const_decorator.html#Cross_link_anchor_878\">CGAL::HalfedgeDS_const_decorator</A>&lt;HDS&gt;</I> provide additional functions\nto examine and to modify a halfedge data structure <I>HDS</I>. The class\n<I><A HREF=\"Class_HalfedgeDS_items_decorator.html#Cross_link_anchor_895\">CGAL::HalfedgeDS_items_decorator</A>&lt;HDS&gt;</I> provides additional functions\nfor vertices, halfedges, and faces of a halfedge data structure\nwithout knowing the containing halfedge data structure. The class\n<I><A HREF=\"Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt;</I> stores a reference to the halfedge\ndata structure and provides functions that modify the halfedge data\nstructure, for example Euler-operators. The class\n<I><A HREF=\"Class_HalfedgeDS_const_decorator.html#Cross_link_anchor_878\">CGAL::HalfedgeDS_const_decorator</A>&lt;HDS&gt;</I> stores a const reference to\nthe halfedge data structure. It contains non-modifying functions, for\nexample the test for validness of the data structure.\n<P>\n\nAll these additional functions take care of the different capabilities\na halfedge data structure may have or may not have.  The functions\nevaluate the type tags of the halfedge data structure to decide on the\nactions. If a particular feature is not supported nothing is done.\nNote that for example the creation of new halfedges is mandatory for\nall halfedge data structures and will not appear here again.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/HalfedgeDS_decorator.h\">CGAL/HalfedgeDS_decorator.h</A>&gt;</I>\n<P>\n\n<H3>Inherits From</H3>\n<P>\n\n<I><A HREF=\"Class_HalfedgeDS_items_decorator.html#Cross_link_anchor_895\">CGAL::HalfedgeDS_items_decorator</A>&lt;HDS&gt;</I>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>&lt;HDS&gt; D ( HDS&amp; hds);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    keeps internally a reference to <I>hds</I>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation of New Items</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_vertices_push_back6_const_Vertex__v9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.vertices_push_back (  Vertex v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    appends a copy of <MATH><I>v</I></MATH> to <I>hds</I> if vertices are supported.\n    Returns a handle of the new vertex, or <I>Vertex_handle()</I> otherwise.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_faces_push_back6_const_Face__f9;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.faces_push_back (  Face f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    appends a copy of <MATH><I>f</I></MATH> to <I>hds</I> if faces are supported.\n    Returns a handle of the new face, or <I>Face_handle()</I> otherwise.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation of New Composed Items</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_create_loop69;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    D.create_loop ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns handle of a halfedge from a newly created loop in <I>hds</I>\n    consisting of a single closed edge, one vertex and two faces (if\n    supported respectively).\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_create_segment69;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.create_segment ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a halfedge from a newly created segment in <I>hds</I>\n    consisting of a single open edge, two vertices and one face (if\n    supported respectively).\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Removal of Elements</H3>\n<P>\n\nThe following member functions do <I>not</I> update affected\nincidence relations except if mentioned otherwise.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_vertices_pop_front69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.vertices_pop_front ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the first vertex if vertices are supported.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_vertices_pop_back69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.vertices_pop_back ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the last vertex if vertices are supported.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_vertices_erase6_Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.vertices_erase ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the vertex <MATH><I>v</I></MATH> if vertices are supported.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_vertices_erase6_Vertex_handle_first+_Vertex_handle_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    D.vertices_erase ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle first,<BR>\n\nVertex_handle last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the range <MATH><I>[<I>first</I>,<I>last</I>)</I></MATH> if vertices \n    are supported.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> \n    <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_faces_pop_front69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.faces_pop_front ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the first face if faces are supported.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_faces_pop_back69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.faces_pop_back ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the last face if faces are supported.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_faces_erase6_Face_handle_f9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.faces_erase ( Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the face <MATH><I>f</I></MATH> if faces are supported.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH>\n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_faces_erase6_Face_handle_first+_Face_handle_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.faces_erase ( Face_handle first,  Face_handle last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the range <MATH><I>[<I>first</I>,<I>last</I>)</I></MATH> if faces are \n    supported.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I>\n    <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase_face6_Halfedge_handle_h9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.erase_face ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the\n   face incident to <I>h</I> from <I>hds</I> and changes all halfedges\n   incident to the face into border edges or removes them from the\n   halfedge data structure if they were already border edges. If this\n   creates isolated vertices they get removed as well. See\n   <I>make_hole(h)</I> for a more specialized variant.<BR>\n\n<EM>Precondition: </EM><I>h-&gt;is_border() == false</I>.<BR>\n\n<EM>Requirement: </EM> If faces are supported,\n   <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase_connected_component6_Halfedge_handle_h9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.erase_connected_component ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the  vertices, halfedges, and faces that belong to the \n     connected component of <MATH><I>h</I></MATH>.<BR>\n\n<EM>Precondition: </EM>For all halfedges <MATH><I>g</I></MATH> in the \n     connected component <I>g.next() != Halfedge_handle()</I>.<BR>\n\n<EM>Requirement: </EM>  <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH>\n     <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifying Functions (For Border Halfedges)</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_make_hole6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.make_hole ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the face incident to <I>h</I> from <I>hds</I> and creates a hole.<BR>\n\n<EM>Precondition: </EM><I>h != Halfedge_handle()</I> and <I>!(h-&gt;is_border())</I>.<BR>\n\n<EM>Requirement: </EM> If faces are supported,  \n    <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_fill_hole6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.fill_hole ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    fills the hole incident to <I>h</I> with a new face from <I>hds</I>.\n    Returns <I>h</I>.<BR>\n\n<EM>Precondition: </EM><I>h != Halfedge_handle()</I> and <I>h-&gt;is_border()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_fill_hole6_Halfedge_handle_h+_const_Face__f9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.fill_hole ( Halfedge_handle h,  Face f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    fills the hole incident to <I>h</I> with a copy of face <MATH><I>f</I></MATH>.\n    Returns <I>h</I>.<BR>\n\n<EM>Precondition: </EM><I>h != Halfedge_handle()</I> and <I>h-&gt;is_border()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_add_face_to_border6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    D.add_face_to_border ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle h,<BR>\n\nHalfedge_handle g)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    extends the surface with a new face from <I>hds</I> into the hole \n    incident to <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH>. It creates a new edge connecting the vertex\n    denoted by <MATH><I>g</I></MATH> with the vertex denoted by <MATH><I>h</I></MATH> and fills this separated \n    part of the hole with a new face, such that the new face is incident \n    to <MATH><I>g</I></MATH>. Returns the new halfedge that is incident to the new face.<BR>\n\n<EM>Precondition: </EM><I>h != Halfedge_handle()</I>, <I>g != Halfedge_handle()</I>,\n    <I>h-&gt;is_border()</I>, <I>g-&gt;is_border()</I> and <MATH><I>g</I></MATH> can be reached \n    along the hole starting with <MATH><I>h</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_add_face_to_border6_Halfedge_handle_h+_Halfedge_handle_g+_const_Face__f9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    D.add_face_to_border ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle h,<BR>\n\nHalfedge_handle g,<BR>\n\nFace f)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    extends the surface with a copy of face <MATH><I>f</I></MATH> into the hole \n    incident to <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH>. It creates a new edge connecting the tip of\n    <MATH><I>g</I></MATH> with the tip of <MATH><I>h</I></MATH> and fills this separated part of the hole with a\n    copy of face <MATH><I>f</I></MATH>, such that the new face is incident to <MATH><I>g</I></MATH>. Returns \n    the new halfedge that is incident to the new face.<BR>\n\n<EM>Precondition: </EM><I>h != Halfedge_handle()</I>, <I>g != Halfedge_handle()</I>,\n    <I>h-&gt;is_border()</I>, <I>g-&gt;is_border()</I> and <MATH><I>g</I></MATH> can be reached \n    along the hole starting with <MATH><I>h</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifying Functions (Euler Operators)</H3>\n<P>\n\nThe following Euler operations modify consistently the combinatorial\nstructure of the halfedge data structure. The geometry remains unchanged.\nNote that well known graph operations are also captured with these \nEuler operators, for example an edge contraction is equal to a\n<I>join_vertex()</I> operation, or an edge removal to <I>join_face()</I>.\n<P>\n\nGiven a halfedge data structure <I>hds</I> and a halfedge handle <MATH><I>h</I></MATH>\nfour special applications of the Euler operators are worth mentioning:\n<I>split_vertex(h,h)</I> results in an antenna emanating from the tip\nof <I>h</I>; <I>split_vertex(h,h-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>())</I> results in an edge \nsplit of the halfedge <I>h-&gt;next</I> with a new vertex in-between;\n<I>split_face(h,h)</I> results in a loop directly following <I>h</I>;\nand <I>split_face(h,h-&gt;next())</I> results in a bridge <A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A> to\nthe halfedge <I>h-&gt;next</I> with a new face in-between.\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_face.gif\" alt=\"Euler Operator: Face\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_face6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.split_face ( Halfedge_handle h,  Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    splits the face incident to <I>h</I> and <I>g</I> into two faces\n     with a new diagonal between the two vertices denoted by <I>h</I> and\n     <I>g</I> respectively. The second (new) face obtained from\n     <I>hds</I> is a copy of the first face. Returns <I>h-&gt;next()</I> after the\n     operation, i.e., the new diagonal. The new face is to the right of the \n     new diagonal, the old face is to the left. The time is proportional \n     to the distance from <I>h</I> to <I>g</I> around the face.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_join_face6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.join_face ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    joins the two faces incident to <MATH><I>h</I></MATH>. The face incident to\n      <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> gets removed from <I>hds</I>. Both faces might be\n    holes. Returns the <A HREF=\"../STL_Extension_ref/Function_predecessor.html#Cross_link_anchor_1442\">predecessor</A> of <MATH><I>h</I></MATH> around the face. The invariant\n    <I>join_face( split_face( h, g))</I> returns <MATH><I>h</I></MATH> and keeps\n    the data structure unchanged. The time is proportional to the size\n    of the face removed and the time to compute <I>h-&gt;prev()</I>.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH>\n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_vertex.gif\" alt=\"Euler Operator: Vertex\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_vertex6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.split_vertex ( Halfedge_handle h,  Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    splits the vertex incident to <I>h</I> and <I>g</I> into two vertices\n     and connects them with a new edge. The second (new) vertex\n     obtained from <I>hds</I> is a copy of the first vertex. Returns\n     <I>h-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> after the operation, i.e., the new edge\n     in the <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> towards the new vertex. The time is proportional \n     to the distance from <I>h</I> to <I>g</I> around the vertex.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_join_vertex6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.join_vertex ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    joins the two vertices incident to <MATH><I>h</I></MATH>. The vertex denoted by\n     <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> gets removed by <I>hds</I>. Returns the <A HREF=\"../STL_Extension_ref/Function_predecessor.html#Cross_link_anchor_1442\">predecessor</A> of\n     <MATH><I>h</I></MATH> around the vertex, i.e., <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;prev()</I>. The invariant \n     <I>join_vertex( split_vertex( h, g))</I> returns <MATH><I>h</I></MATH>\n     and keeps the polyhedron unchanged. \n     The time is proportional to the degree of the vertex removed and \n     the time to compute <I>h-&gt;prev()</I> and <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;prev()</I>.<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH>\n     <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_center.gif\" alt=\"Euler Operator: Center Vertex\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_create_center_vertex6_Halfedge_handle_h9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.create_center_vertex ( Halfedge_handle h)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    barycentric triangulation of <I>h-&gt;face()</I>. Creates a new vertex,\n     a copy of <I>h-&gt;vertex()</I>, and connects it to each vertex incident \n     to <I>h-&gt;face()</I> splitting <I>h-&gt;face()</I> into triangles. \n     <I>h</I> remains incident to the original face, all other triangles \n     are copies of this face. Returns the halfedge <I>h-&gt;next()</I>\n     after the operation, i.e., a halfedge pointing to the new vertex. \n     The time is proportional to the size of the face.<BR>\n\n<EM>Precondition: </EM><I>h</I> is not a border halfedge.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_erase_center_vertex6_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.erase_center_vertex ( Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reverses <I>create_center_vertex</I>. Erases the\n     vertex pointed to by <I>g</I> and all incident halfedges thereby\n     merging all incident faces. Only <I>g-&gt;face()</I> remains. \n     The neighborhood of <I>g-&gt;vertex()</I> may not be triangulated,\n     it can have larger faces. Returns the halfedge <I>g-&gt;prev()</I>.\n     Thus, the invariant <I>h == erase_center_vertex(       create_center_vertex(h))</I> holds if <I>h</I> is not a border halfedge.\n     The time is proportional to the sum of the size of all incident faces.<BR>\n\n<EM>Precondition: </EM>None of the incident faces of <I>g-&gt;vertex()</I> is \n     a hole. There are at least two distinct faces incident\n     to the faces that are incident to <I>g-&gt;vertex()</I>. (This \n     prevents the operation from collapsing a <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> into two faces\n     glued together with <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations, such as would\n     happen with any vertex of a tetrahedron.)<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n     <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n    <img src=\"fig/euler_loop.gif\" alt=\"Euler Operator: Loop\">\n<P>\n\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_loop6_Halfedge_handle_h+_Halfedge_handle_i+_Halfedge_handle_j9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    D.split_loop ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle h,<BR>\n\nHalfedge_handle i,<BR>\n\nHalfedge_handle j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    cuts the halfedge data structure into two parts along the cycle <MATH><I>(h,i,j)</I></MATH>.\n    Three new vertices (one copy for each vertex in the cycle) and three \n    new halfedges (one copy for each halfedge in the cycle), and two new \n    triangles are created. <MATH><I>h,i,j</I></MATH> will be incident to the first new triangle.\n    The return value will be the halfedge incident to the second new triangle \n    which is the copy of <I>h-<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I>.<BR>\n\n<EM>Precondition: </EM><MATH><I>h,i,j</I></MATH> denote distinct, consecutive vertices of the\n    halfedge data structure and form a cycle: i.e., <I>h-&gt;vertex() ==     i-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()</I>, ..., <I>j-&gt;vertex() ==     h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_join_loop6_Halfedge_handle_h+_Halfedge_handle_g9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.join_loop ( Halfedge_handle h,  Halfedge_handle g)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    glues the boundary of the two faces denoted by <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH> together \n    and returns <MATH><I>h</I></MATH>. Both faces and the vertices along the face denoted\n    by <MATH><I>g</I></MATH> gets removed. Both faces may be holes. The invariant \n    <I>join_loop( h, split_loop( h, i, j))</I> returns <MATH><I>h</I></MATH> and keeps the \n    data structure unchanged.<BR>\n\n<EM>Precondition: </EM>The faces denoted by <MATH><I>h</I></MATH> and <MATH><I>g</I></MATH> are different and have\n    equal degree (i.e., number of edges).<BR>\n\n<EM>Requirement: </EM> <I>Supports_removal</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> \n    <I><A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Validness Checks</H3>\n<P>\n\nThese operations are the same as for \n<I><A HREF=\"Class_HalfedgeDS_const_decorator.html#Cross_link_anchor_878\">CGAL::HalfedgeDS_const_decorator</A>&lt;HDS&gt;</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6_bool_verbose_=_false+_int_level_=_09_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.is_valid ( bool verbose = false,  int level = 0)\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_normalized_border_is_valid6_bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    D.normalized_border_is_valid ( bool verbose = false)\n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_inside_out69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    D.inside_out ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reverses face orientations.<BR>\n\n<EM>Precondition: </EM><I>is_valid()</I> of level three.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_HalfedgeDS_items_decorator.html#Cross_link_anchor_895\">CGAL::HalfedgeDS_items_decorator</A>&lt;HDS&gt;</I><BR>\n\n<I><A HREF=\"Class_HalfedgeDS_const_decorator.html#Cross_link_anchor_878\">CGAL::HalfedgeDS_const_decorator</A>&lt;HDS&gt;</I>\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe following program fragment illustrates the implementation of the\nEuler operator <I>split_vertex()</I> for a simplified polyhedron class.\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt;class Traits&gt;\nnamespace CGAL {\n    class Polyhedron {\n        typedef <A HREF=\"Class_HalfedgeDS_default.html#Cross_link_anchor_883\">HalfedgeDS_default</A>&lt;Traits&gt; HDS;\n        HDS hds;\n    public:\n        // ...\n        Halfedge_handle split_vertex( Halfedge_handle h, Halfedge_handle g) {\n            <A HREF=\"Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>&lt;HDS&gt; D(hds);\n            // Stricter preconditions than for <A HREF=\"Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A> only.\n            CGAL_precondition( D.get_vertex(h) == D.get_vertex(g));\n            CGAL_precondition( h != g);\n            return D.split_vertex( h, g);\n        }\n    };\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_HalfedgeDS_default.html\"><I>HalfedgeDS_default&lt;Traits,HalfedgeDSItems,Alloc&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_30!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38870.0}