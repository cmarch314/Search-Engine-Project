{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 4Predicates and Constructions 4 1 Predicates Predicates are at the heart of a geometry kernel They are basic units for the composition of geometric algorithms and encapsulate decisisons Hence their correctness is crucial for the control flow and hence for the correctness of an implementation of a geometric algorithm CGAL uses the term predicate in a generalized sense Not only components returning a Boolean value are called predicates but also components returning an enumeration type like a Comparison result or an Orientation We say components because predicates are implemented both as functions and function objects provided by a kernel class CGAL provides predicates for the orientation of point sets orientation leftturn rightturn collinear coplanar for comparing points according to some given order especially for comparing Cartesian coordinates e g lexicographically xy smaller in circle and in sphere tests and predicates to compare distances 4 2 Constructions Functions and function objects that generate objects that are neither of type bool nor enum types are called constructions Constructions involve computation of new numerical values and may be imprecise due to rounding errors unless a kernel with an exact number type is used Affine transformations Aff transformation 2 Kernel Aff transformation 3 Kernel allow to generate new object instances under arbitrary affine transformations These transformations include translations rotations in 2D only and scaling Most of the geometric objects in a kernel have a member function transform Aff transformation t which applies the transformation to the object instance CGAL also provides a set of functions that detect or compute the intersection between objects of the 2D kernel and many objects in the 3D kernel and functions to calculate their squared distance Moreover some member functions of kernel objects are constructions So there are routines that compute the square of the Euclidean distance but no routines that compute the distance itself Why First of all the two values can be derived from each other quite easily by taking the square root or taking the square So supplying only the one and not the other is only a minor inconvenience for the user Second often either value can be used This is for example the case when squared distances are compared Third the library wants to stimulate the use of the squared distance instead of the distance The squared distance can be computed in more cases and the computation is cheaper We do this by not providing the perhaps more natural routine The problem of a distance routine is that it needs the sqrt operation This has two drawbacks The sqrt operation can be costly Even if it is not very costly for a specific number type and platform avoiding it is always cheaper There are number types on which no sqrt operation is defined especially integer types and rationals 4 3 Polymorphic Return Values Some functions can return different types of objects A typical C solution to this problem is to derive all possible return types from a common base class to return a pointer to this class and to perform a dynamic cast on this pointer The class Object provides an abstraction An object obj of the class Object can represent an arbitrary class The only operations it provides is to make copies and assignments so that you can put them in lists or arrays Note that Object is NOT a common base class for the elementary classes Therefore there is no automatic conversion from these classes to Object Rather this is done with the global function make object This encapsulation mechanism requires the use of assign to use the functionality of the encapsulated class ExampleIn the following example the object class is used as return value for the intersection computation as there are possibly different return values Point 2 Cartesian double point Segment 2 Cartesian double segment segment 1 segment 2 std cin segment 1 segment 2 Object obj intersection segment 1 segment 2 if assign point obj do something with point else if assign segment obj do something with segment there was no intersection The intersection routine itself looks roughly as follows template class Kernel Object intersection Segment 2 Kernel s1 Segment 2 Kernel s2 if intersection in a point Point 2 Kernel p return make object p else if intersection in a segment Segment 2 Kernel s return make object s return Object 4 4 Constructive Predicates For testing where a point p lies with respect to a plane defined by three points q r and s one may be tempted to construct the plane Plane 3 Kernel q r s and use the method oriented side p This may pay off if many tests with respect to the plane are made Nevertheless unless the number type is exact the constructed plane is only approximated and round off errors may lead oriented side p to return an orientation which is different from the orientation of p q r and s In CGAL we provide predicates in which such geometric decisions are made directly with a reference to the input points p q r s without an intermediary object like a plane For the above test the recommended way to get the result is to use orientation p q r s For exact number types like leda real the situation is different If several tests are to be made with the same plane it pays off to construct the plane and to use oriented side p Next chapter Extensible Kernel Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Kernel_23/Chapter_predicates_constructions.html", "title": "predicates and constructions", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Kernel_23/predicates_constructions.tex' -->\n<html> <head>  \n<title>Predicates and Constructions</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_predicates_constructions.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_4\"></a>\n  \n<h1>Chapter 4<BR>Predicates and Constructions</h1>\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>4.1&nbsp;&nbsp;&nbsp;Predicates</h2>\n\nPredicates are at the heart of a geometry kernel. They are basic units\nfor the composition of geometric algorithms and encapsulate decisisons. \nHence their correctness is crucial for the control flow and hence for\nthe correctness of an implementation of a geometric algorithm. C<SMALL>GAL</SMALL> uses\nthe term predicate in a generalized sense. Not only components returning a\nBoolean value are called predicates but also components returning an \nenumeration type like a <I><A HREF=\"../Kernel_23_ref/Enum_Comparison_result.html#Cross_link_anchor_104\">Comparison_result</A></I> or an <I><A HREF=\"../Kernel_23_ref/Enum_Orientation.html#Cross_link_anchor_114\">Orientation</A></I>.\nWe say components, because predicates are implemented both as functions and \nfunction objects (provided by a kernel class).\n<P>\n\nC<SMALL>GAL</SMALL> provides predicates for the \n<!-- REMOVE_LINKS_BEGIN -->\norientation\n<!-- REMOVE_LINKS_END -->\n of point \nsets (<I><A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A></I>, <I>leftturn</I>, <I>rightturn</I>, <I><A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A></I>,\n<I><A HREF=\"../Kernel_23_ref/Function_coplanar.html#Cross_link_anchor_197\">coplanar</A></I>), for comparing points according to some given order, \nespecially for comparing \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates\n(e.g.&nbsp;<I><A HREF=\"../Kernel_23_ref/Function_lexicographically_xy_smaller.html#Cross_link_anchor_233\">lexicographically_xy_smaller</A></I>), in-circle and in-sphere tests,\nand predicates to <A HREF=\"../NumberTypeSupport_ref/Function_compare.html#Cross_link_anchor_1339\">compare</A> distances.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>4.2&nbsp;&nbsp;&nbsp;Constructions</h2>\n\nFunctions and function objects that generate objects that are neither \nof type <I>bool</I> nor <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> types are called constructions.\nConstructions involve computation of new numerical values and may be\nimprecise due to rounding errors unless a kernel with an exact number type is \nused.\n<P>\n\nAffine transformations (<I><A HREF=\"../Kernel_23_ref/Class_Aff_transformation_2.html#Cross_link_anchor_40\">Aff_transformation_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I>, \n<I><A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I>) allow to generate new object instances under\narbitrary affine transformations. These transformations include translations,\nrotations (in 2D only) and scaling. Most of the geometric objects in a\nkernel have a member function <I>transform(Aff_transformation t)</I> \nwhich applies the transformation to the object instance.\n<P>\n\nC<SMALL>GAL</SMALL> also provides a set of functions that detect or compute the \n\n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n \n     \n<A NAME=\"Index_anchor_16\"></A> \n \n   \n\nbetween objects of the 2D kernel, and many objects in the 3D kernel,\nand functions to calculate their \nsquared distance \n     \n<A NAME=\"Index_anchor_17\"></A> \n \n   \n   \n     \n     \n<A NAME=\"Index_anchor_18\"></A> \n\n   \n.\nMoreover, some member functions of kernel objects are constructions.\n<P>\n\nSo there are routines that compute the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> of the Euclidean distance, but no\nroutines that compute the distance itself. Why?\nFirst of all, the two values can be derived from each other quite easily (by\ntaking the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> root or taking the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A>). So, supplying only the one and\nnot the other is only a minor inconvenience for the user.\nSecond, often either value can be used. This is for example the case when\n(squared) distances are compared.\nThird, the library wants to stimulate the use of the squared distance instead\nof the distance. The squared distance can be computed in more cases and the\ncomputation is cheaper.\nWe do this by not providing the perhaps more natural routine,\nThe problem of a distance routine is that it needs the <I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A></I>\noperation.\nThis has two drawbacks:\n<UL>\n<LI>The <I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A></I> operation can be costly. Even if it is not very costly for\na specific number type and platform, avoiding it is always cheaper.\n<LI>There are number types on which no <I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A></I> operation is defined,\nespecially integer types and rationals.\n</UL>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>4.3&nbsp;&nbsp;&nbsp;Polymorphic Return Values</h2>\n\nSome functions can return different types of objects. A typical\nC++ solution to this problem is to derive all possible return\ntypes from a common base class, to return a pointer to this \nclass and to perform a dynamic cast on this pointer. The class\n<I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> provides an abstraction.\nAn object <I>obj</I> of the class <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> can\nrepresent an arbitrary class. The only operations it provides is\nto make copies and assignments, so that you can put them in lists\nor arrays. Note that <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> is NOT a common base class for the\nelementary classes. Therefore, there is no \nautomatic conversion from these classes to <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I>. Rather \nthis is done with the global function <I><A HREF=\"../Kernel_23_ref/Function_make_object.html#Cross_link_anchor_92\">make_object</A>()</I>. This \nencapsulation mechanism requires the use of <I><A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90\">assign</A></I> to use \nthe functionality of the encapsulated class.\n<P>\n\n<H3>Example</H3>In the following example, the object class is used as return value for the \n\n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n computation, as there are possibly different return values.\n<P>\n\n<PRE>\n{\n    <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&lt; <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;double&gt; &gt; point;\n    <A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>&lt; <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;double&gt; &gt; segment,  segment_1, segment_2;\n\n    std::cin &gt;&gt; segment_1 &gt;&gt; segment_2;\n\n    <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> obj = <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>(segment_1, segment_2);\n\n    if (<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90\">assign</A>(point, obj)) {\n        /* do something with point */\n    } else if ((<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90\">assign</A>(segment, obj)) {\n        /* do something with segment*/\n    }\n</PRE>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<PRE>\n    /*  there was no intersection */\n}\n</PRE>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\n<BR>\n\n<BR>\n\nThe \n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n routine itself looks roughly as follows:\n<P>\n\n<PRE>\n\ntemplate &lt; class <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A> &gt;\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>  <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>(<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; s1, <A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; s2)\n{\n</PRE> \n\n<!-- REMOVE_LINKS_BEGIN -->\n<PRE>\n    if (/* intersection in a point */ ) {\n</PRE> \n\n<!-- REMOVE_LINKS_END -->\n<PRE>\n       <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; p = ... ;\n       return <A HREF=\"../Kernel_23_ref/Function_make_object.html#Cross_link_anchor_92\">make_object</A>(p);\n</PRE> \n\n<!-- REMOVE_LINKS_BEGIN -->\n<PRE>\n    } else if (/* intersection in a segment */ ) {\n</PRE> \n\n<!-- REMOVE_LINKS_END -->\n<PRE>\n       <A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; s = ... ;\n       return <A HREF=\"../Kernel_23_ref/Function_make_object.html#Cross_link_anchor_92\">make_object</A>(s);\n    }\n    return <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>();\n}\n</PRE>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>4.4&nbsp;&nbsp;&nbsp;Constructive Predicates</h2>\n\nFor testing where a point <MATH><I>p</I></MATH> lies with respect to a plane defined by three\npoints <MATH><I>q</I></MATH>, <MATH><I>r</I></MATH> and <MATH><I>s</I></MATH>, one may be tempted to construct the plane\n<I><A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;(q,r,s)</I> and use the method <I>oriented_side(p)</I>. \nThis may pay off if many tests with respect to the plane are made. \nNevertheless, unless the number type is exact, the constructed plane \nis only approximated, and round-off errors may lead \n<I>oriented_side(p)</I> to return an \n<!-- REMOVE_LINKS_BEGIN -->\norientation\n<!-- REMOVE_LINKS_END -->\n \nwhich is different from the \n<!-- REMOVE_LINKS_BEGIN -->\norientation\n<!-- REMOVE_LINKS_END -->\n of <MATH><I>p</I></MATH>, <MATH><I>q</I></MATH>, <MATH><I>r</I></MATH>, \nand <MATH><I>s</I></MATH>.\n<P>\n\nIn C<SMALL>GAL</SMALL>, we provide predicates in which such\ngeometric decisions are made directly with a reference to the input points\n<MATH><I>p</I></MATH>, <MATH><I>q</I></MATH>, <MATH><I>r</I></MATH>, <MATH><I>s</I></MATH>, without an intermediary object like a plane. \nFor the above test, the recommended way to get the result is to use\n<I><A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>(p,q,r,s)</I>. For exact number types like <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>,\nthe situation is different. If several tests are to be made with the same\nplane, it pays off to construct the plane and to use <I>oriented_side(p)</I>.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"Chapter_extensible_kernel.html\">Extensible Kernel</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_4!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39228.0}