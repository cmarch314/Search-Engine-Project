{"text": "Navigation Up Table of Contents Bibliography Index Title Page Circulator Definition Note This specification is a revised version based on the C Standard C 98 which is available now In particular iterator traits are now assumed and required Iterators in the STL were tailored for linear sequences The specialization for circular data structures leads to slightly different requirements which we will summarize in the circulators concept The main difference is that a circular data structure has no natural past the end value As a consequence a container supporting circulators will not have an end member function The semantic of a circulator range differs from the semantic of an iterator range For a circulator c the range c c denotes the sequence of all elements in the data structure For iterators this range defines the empty sequence A separate test for an empty sequence has been added to the circulator requirements A comparison c NULL for a circulator c is true for an empty sequence As for C we recommend the use of instead of NULL Similar to STL iterators we distinguish between forward bidirectional and random access circulators1 Most requirements for circulators are equal to those for iterators We present the changes please refer to MS96 chapter 18 or C 98 for the iterator requirements Past the end value There is no past the end value for circulators Singular values There are no singular values for circulators2 Empty sequence The comparison c NULL or c for a circulator c is true if c denotes an empty sequence and false otherwise Dereferenceable values A circulator that does not denote an empty sequence is dereferenceable Reachability Each dereferenceable circulator can reach itself with a finite and non empty sequence of applications of operator Ranges For any circulator c the range c c is a valid range If the circulator refers to an empty sequence the range c c denotes the empty range Otherwise the circulator is dereferenceable and the range c c denotes the sequence of all elements in the data structure Remark When a circulator is used in a place of an iterator as for example with an STL algorithm it will work as expected with the only exception that in STL algorithms the range c c denotes always the empty range This is not a requirement but a consequence of the requirements stated here and the fact that the STL requirements for iterator ranges are based on the operator and the operator which we use for circulators as well In principle we face here the difference between a while loop and a do while loop Types For a circulator of type C the following local types are required C value type value type the circulator refers to C reference reference type used for the return type of C operator C pointer pointer type used for the return type of C operator C size type unsigned integral type that can hold the size of a sequence C difference type signed integral type that can hold the distance between two circulators C iterator category circulator category Forward Circulators In the following we assume that a and b are circulators of type C r is of type C is assignable and T denotes the value type of C Let D be the distance type of C As for C we recommend the use of instead of NULL C a circulator equal to NULL denoting an empty sequence a NULL Returns true if a denotes an empty sequence false otherwise For simplicity NULL a is not required The behavior for comparisons with pointer like values different than NULL is undefined A runtime assertion is recommended a NULL Returns a NULL r Like for forward iterators but a dereferenceable circulator r will always be dereferenceable after r no past the end value Precondition r does not denote an empty sequence r Same as for r C iterator category circulator category CBP Forward circulator tag Bidirectional Circulators The same requirements as for the forward circulators hold for bidirectional iterators with the following change of the iterator category C iterator category circulator category CBP Bidirectional circulator tag Random Access Circulators The same requirements as for the bidirectional circulators hold for random access iterators with the following changes and extensions The idea of random access extends naturally to circulators using equivalence classes modulus the length of the sequence With this in mind the additional requirements for random access iterators hold also for random access circulators The only exception is that the random access iterator is required to provide a total order on the sequence which a circulator cannot provide3 The difference of two circulators is not unique as for iterators A reasonable requirement demands that the result is in a certain range 1 size size 1 where size is the size of the sequence and that whenever a circulator a is fixed that the differences with all other circulators of the sequence form a consistent ordering For the adaptor to iterators a minimal circulator dmin is required for which the difference c dmin to all other circulators c is non negative b a limited range and consistent ordering as explained above a min circulator returns the minimal circulator from the range a a C iterator category circulator category CBP Random access circulator tag Const Circulators As with iterators we distinguish between circulators and const circulators The expression a t with t of type T is valid for mutable circulators It is invalid for const circulators Circulators in Container Classes For a container x of type X that supports circulators c the following naming convention is recommended X Circulator the type of the mutable circulator X Const circulator the type of the const circulator c x begin the start circulator of the sequence It is of type X Circulator for a mutable container or X Const circulator for a const container There must not be an end member function If a container will support iterators and circulators the member function circulator begin is proposed However the support of iterators and circulators simultaneously is not recommended since it would lead to fat interfaces The natural choice should be supported the other concept will be available through adaptors Example A generic contains function accepts a range of circulators and a value It returns true if the value is contained in the sequence of items denoted by the range of circulators As usual for circular structures a do while loop is preferable such that for the specific input c d all elements in the sequence are reached Note that the example simplifies if the sequence is known to be non empty which is for example the common case in polyhedral surfaces where vertices and facets have at least one incident edge template class Circulator class T bool contains Circulator c Circulator d const T value if c do if c value return true while c d return false Footnotes 1 Input circulators are a contradiction since any circulator is supposed to return once to itself Output circulators are not supported since they would be indistinguishable from output iterators 2 Since circulators must be implemented as classes anyway there is no need to allow singular values for them An un initalized circulator does not have a singular value but is supposed to refer to an empty sequence 3 One might define an order by splitting the circle at a fixed point e g the start circulator provided from the data structure This is what the adaptor to iterators will do Nonetheless we do not require this for circulators Next Circulator from container C Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Circulator_ref/Concept_Circulator.html", "title": "circulator", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Circulator_ref/Circulator.tex' -->\n<html> <head>  \n<title>Circulator</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1607\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1506\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Concept.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_Circulator\"></A>\n<h2><I>Circulator</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\n<A NAME=\"Cross_link_anchor_1608\"></A>\n\n\n<A NAME=\"Cross_link_anchor_1609\"></A>\n\n\n<A NAME=\"Cross_link_anchor_1610\"></A>\n\n\n<A NAME=\"Index_anchor_1507\"></A> \n\n\n<A NAME=\"Index_anchor_1508\"></A> \n\n\n<A NAME=\"Index_anchor_1509\"></A>\n<P>\n\nNote: This specification is a revised version based on the C++ \nStandard&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ansi-is14882-98\">C<TT>++</TT>98</A>], which is available now. In particular,\niterator traits are now assumed and required.\n<P>\n\nIterators in the STL were tailored for linear sequences. The\nspecialization for circular data structures leads to slightly\ndifferent requirements which we will summarize in the <I>circulators</I> concept. The main difference is that a circular data\nstructure has no natural past-the-end value. As a consequence, a\ncontainer supporting circulators will not have an <TT>end()</TT>-member\nfunction. The semantic of a circulator range differs from the semantic\nof an iterator range. For a circulator <MATH><I>c</I></MATH> the range <MATH><I>[c,\n  c)</I></MATH> denotes the sequence of all elements in the data\nstructure. For iterators, this range defines the empty sequence. A\nseparate test for an empty sequence has been added to the circulator\nrequirements: A comparison <MATH><I>c ==</I></MATH> <TT>NULL</TT> for a circulator <MATH><I>c</I></MATH> is\ntrue for an empty sequence. As for C++, we recommend the use of 0\ninstead of <TT>NULL</TT>.\n<P>\n\nSimilar to STL iterators, we distinguish between forward,\nbidirectional, and random access circulators<A HREF=\"#Footnote_1\"><SUP>1</SUP></A>. Most\nrequirements for circulators are equal to those for iterators. We\npresent the changes, please refer to [<A HREF=\"../biblio.html#Biblio_cgal:ms-strg-96\">MS96</A>, chapter 18] or\n[<A HREF=\"../biblio.html#Biblio_cgal:ansi-is14882-98\">C<TT>++</TT>98</A>] for the iterator requirements.\n<P>\n\n<B>Past-the-end value:</B> There is no past-the-end value for circulators.\n<P>\n\n<B>Singular values:</B> There are no singular values for\n circulators<A HREF=\"#Footnote_2\"><SUP>2</SUP></A>\n<P>\n\n<B>Empty sequence:</B> The comparison <MATH><I>c ==</I></MATH> <TT>NULL</TT> (or <MATH><I>c == 0</I></MATH>)\nfor a circulator <MATH><I>c</I></MATH> is <TT>true</TT> if <MATH><I>c</I></MATH> denotes an empty sequence,\nand <TT>false</TT> otherwise.\n<P>\n\n<B>Dereferenceable values:</B> A circulator that does not denote an\nempty sequence is dereferenceable.\n<P>\n\n<B>Reachability:</B> Each dereferenceable circulator can reach itself\nwith a finite and non-empty sequence of applications of <I>operator++</I>.\n<P>\n\n<B>Ranges:</B> For any circulator <MATH><I>c</I></MATH> the range <MATH><I>[c, c)</I></MATH> is\na valid range. If the circulator refers to an empty sequence, the range\n<MATH><I>[c, c)</I></MATH> denotes the empty range. Otherwise the circulator\nis dereferenceable and the range <MATH><I>[c, c)</I></MATH> denotes the\nsequence of all elements in the data structure. <I>Remark:</I> When a\ncirculator is used in a place of an iterator, as, for example, with an STL \nalgorithm, it will work as expected with the only exception that,\nin STL algorithms,\nthe range <MATH><I>[c, c)</I></MATH> denotes always the empty range.\nThis is\nnot a requirement, but a consequence of the requirements\nstated here and the fact that the STL requirements for iterator\nranges are based on the <TT>operator++</TT> and the <TT>operator==</TT>,\nwhich we use for circulators as well. In principle, we face here the \ndifference between a <TT>while</TT> loop and a <TT>do-while</TT> loop.\n<P>\n\n<B>Types:</B> For a circulator of type <MATH><I>C</I></MATH> the following local types\nare required:\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n    \n    <TT>C::value_type</TT>        \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  value type the circulator refers to.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::reference</TT>          \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  reference type used for the return type\n                                    of <TT>C::operator*()</TT>.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::pointer</TT>            \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  pointer type used for the return type of \n                                    <TT>C::operator-&gt;()</TT>.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::size_type</TT>         \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  unsigned integral type that can hold \n                                    the size of a sequence\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::difference_type</TT>   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  signed integral type that can hold \n                                    the distance between two circulators.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::iterator_category</TT> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  circulator category.\n\n</TD></TR></TABLE>\n<P>\n\n<h3>Forward Circulators</h3>\n<P>\n\nIn the following, we assume that <TT>a</TT> and <TT>b</TT> are circulators\nof type <TT>C</TT>, <TT>r</TT> is of type <TT>C&amp;</TT> (is assignable), and\n<TT>T</TT> denotes the value type of <TT>C</TT>.  Let <TT>D</TT> be the\ndistance type of <TT>C</TT>.  As for C++, we recommend the use of 0\ninstead of <TT>NULL</TT>.\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n    \n    <TT>C()</TT>         \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n a circulator equal to <I>NULL</I> denoting an \n                         empty sequence.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>a == NULL</TT>   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n Returns <TT>true</TT> if <TT>a</TT> denotes an empty\n                         sequence, <TT>false</TT> otherwise. \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n For simplicity, <TT>NULL == a</TT> is not required. The\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n behavior for comparisons with pointer-like \n                         values different than <TT>NULL</TT> \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n is undefined. A runtime assertion is \n                         recommended.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>a != NULL</TT>   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n Returns <TT>!(a == NULL)</TT>. \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>++r</TT>         \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n Like for forward iterators, but a dereferenceable\n                         circulator <TT>r</TT> will always\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n be dereferenceable after <TT>++r</TT> (no\n                         past-the-end value). <I>Precondition:</I> <TT>r</TT> \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n does not denote an empty sequence.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>r++</TT>         \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n Same as for <TT>++r</TT>.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::iterator_category</TT> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  circulator category <TT>CBP_Forward_circulator_tag</TT>.\n\n</TD></TR></TABLE>\n<P>\n\n<h3>Bidirectional Circulators</h3>\n<P>\n\nThe same requirements as for the forward circulators hold for\nbidirectional iterators with the following change of the iterator\ncategory:\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n    \n    <TT>C::iterator_category</TT> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  circulator category <TT>CBP_Bidirectional_circulator_tag</TT>.\n\n</TD></TR></TABLE>\n<P>\n\n<h3>Random Access Circulators</h3>\n\n<A NAME=\"sectionMinCircleRequ\"></A>\n<P>\n\nThe same requirements as for the bidirectional circulators hold for\nrandom access iterators with the following changes and extensions.\n<P>\n\nThe idea of random access extends naturally to circulators using\nequivalence classes modulus the length of the sequence. With this in\nmind, the additional requirements for random access iterators hold\nalso for random access circulators. The only exception is that the\nrandom access iterator is required to provide a total order on the\nsequence, which a circulator cannot provide<A HREF=\"#Footnote_3\"><SUP>3</SUP></A>.\n<P>\n\nThe difference of two circulators is not unique as for iterators. A\nreasonable requirement demands that the result is in a certain range\n<MATH><I>[1-</I></MATH><I>size, size</I><MATH><I>-1]</I></MATH>, where <I>size</I> is the size of the\nsequence, and that whenever a circulator <TT>a</TT> is fixed that\nthe differences with all other circulators of the sequence form a\nconsistent ordering.\n<P>\n\nFor the adaptor to iterators a minimal circulator\n<MATH><I>d<SUB></I></MATH><SMALL><SMALL><A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A></SMALL></SMALL><MATH><I></SUB></I></MATH> is required for which the difference <MATH><I>c\n- d<SUB></I></MATH><SMALL><SMALL><A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A></SMALL></SMALL><MATH><I></SUB></I></MATH> to all other circulators <MATH><I>c</I></MATH> is non\nnegative.\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n    \n    <TT>b - a</TT>   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n limited range and consistent ordering \n                       as explained above.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>a.min_circulator()</TT>   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  returns the minimal circulator from the \n                       range <MATH><I>[a,a)</I></MATH>.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>C::iterator_category</TT> \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n  circulator category <TT>CBP_Random_access_circulator_tag</TT>.\n\n</TD></TR></TABLE>\n<P>\n\n<h3>Const Circulators</h3>\n<P>\n\nAs with iterators, we distinguish between circulators and const\ncirculators. The expression <TT>*a = t</TT> with <TT>t</TT> of type <TT>T</TT>\nis valid for mutable circulators. It is invalid for const circulators.\n<P>\n\n<h3>Circulators in Container Classes</h3>\n<P>\n\nFor a container <TT>x</TT> of type <TT>X</TT> that supports circulators\n<TT>c</TT> the following naming convention is recommended:\n<P>\n\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n    \n    <TT>X::<A HREF=\"Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A></TT>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n the type of the mutable circulator.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>X::Const_circulator</TT>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n the type of the const circulator.\n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n<TT>c = x.begin()</TT>         \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n the start circulator of the sequence.\n        It is of type <TT>X::<A HREF=\"Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A></TT> for a \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n mutable container or <TT>X::Const_circulator</TT> for\n         a const container. There \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n\n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n must not be an <TT>end()</TT> member function.\n\n</TD></TR></TABLE>\n<P>\n\nIf a container will support iterators and circulators, the member\nfunction <TT>circulator_begin()</TT> is proposed. However, the support\nof iterators and circulators simultaneously is not recommended, since\nit would lead to fat interfaces. The natural choice should be\nsupported, the other concept will be available through adaptors.\n<P>\n\n<h3>Example</h3>\n<P>\n\nA generic <TT>contains</TT> function accepts a range of circulators and a\nvalue. It returns <I>true</I> if the value is contained in the sequence\nof items denoted by the range of circulators.  As usual for circular\nstructures, a <TT>do</TT>-<TT>while</TT> loop is preferable, such that for\nthe specific input, <TT>c == d</TT>, all elements in the sequence are\nreached. Note that the example simplifies if the sequence is known to\nbe non-empty, which is for example the common case in polyhedral\nsurfaces where vertices and facets have at least one incident edge.\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt;class <A HREF=\"Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A>, class T&gt;\nbool contains( <A HREF=\"Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A> c, <A HREF=\"Concept_Circulator.html#Cross_link_anchor_1607\">Circulator</A> d, const T&amp; value) {\n    if (c != 0) {\n        do {\n            if (*c == value)\n                return true;\n        } while (++c != d);\n    }\n    return false;\n}\n</pre>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nInput\n  circulators are a contradiction, since any circulator is supposed to\n  return once to itself.  Output circulators are not supported since\n  they would be indistinguishable from output iterators.\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_2\">&nbsp;<SUP>2</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nSince circulators must be implemented as classes\n  anyway, there is no need to allow singular values for them. An\n  un-initalized circulator does not have a singular value, but is\n  supposed to refer to an empty sequence.\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_3\">&nbsp;<SUP>3</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nOne might define\n  an order by splitting the circle at a fixed point, e.g.&nbsp;the start\n  circulator provided from the data structure. This is what the\n  adaptor to iterators will do. Nonetheless, we do not require this\n  for circulators.\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Circulator_from_container.html\"><I>Circulator_from_container&lt;C&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_5!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39153.0}