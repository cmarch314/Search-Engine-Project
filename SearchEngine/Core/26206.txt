{"text": "HW2 Morphing Due Wednesday Febuary 5th in EEE DropBox at 11 59 pm In this assignment you will produce a morph animation of your face into another student s face We will combine the sequence of morphs into a final video which will morph through everyone in the class After taking photos in class I will post all the photos here http www ics uci edu fowlkes class cs116 hwk2 faces You need to find the photo of your face and produce a morph from it to the next highest numbered file If your photo is the last one then create a morph from it back to the first photo downloads contains some skeleton code for you to start with Programming 9 points Write the following 3 functions each in their own file with the following prototypes to perform the morph REMINDER you need to comment your code if you want the grader to be able to understand it and give you full credit 3 points This function computes the affine transformation which maps points from tri1 to tri2 You will use this to map pixels inside each triangle of your mesh NOTE do not use maketform or other MATLAB functions just basic math operations function T tform tri1 tri2 compute the transformation T which maps points of triangle1 to triangle2 tri1 2x3 matrix containing coordinates of triangle 1 tri2 2x3 matrix containing coordinates of triangle 2 T the resulting transformation should be a 3x3 matrix which operates on points described in homogeneous coordinates 3 points This function computes a warped image starting from a source image and a set of triangulated keypoints You will want to use MATLAB s built in function for interpolation interp2 and the provided function mytsearch for finding which triangle each point lies in function I target warp I source pts source pts target tri I source color source image HxWx3 pts source coordinates of keypoints in the source image 2xN pts target coordinates of where the keypoints end up after the warp 2xN tri list of triangles triples of indices into pts source Kx3 for example the coordinates of the Tth triangle should be given by the expression pts source tri T I target resulting warped image same size as source image HxWx3 3 points Write a script morph m that loads in the source and target image and produces a morph between them The script should let the user click on keypoints in each image to indicate correspondences It should then triangulate the set of points using delaunay m and then produce a morph sequence by repeatedly warping the source and target images to an intermediate image and blending them NOTE you may want to save user clicks out to a file and just load them in so that you don t have to keep recreating them while testing your other code morphing script load in two images get user clicks on keypoints generate triangulation tri now produce the frames of the morph sequenceA for fnum 1 61 t fnum 1 61 pts target 1 t pts img1 t pts img2 intermediate key point locations I1 warp warp I1 pts img1 pts target tri warp image 1 I2 warp warp image 2 Iresult 1 t I1 warp t I2 warp blend the two warped images imwrite Iresult sprintf frame 2 2d jpg fnum jpg end Writeup and Results 1 points There is no writeup required but you should generate the sequence of 61 frames of the morph and upload them in a zip file to the dropbox along with your code I will assemble the frames from everyone s submission into a final video sequence Hints and More Discussion You will need to define pairs of corresponding points on the two images by hand the more points the better the morph generally The simplest way is probably to use the cpselect tool or write your own tool using ginput and plot commands with hold on and hold off Now you need to provide a triangulation of these points that will be used for morphing You can compute a triangulation any way you like or even define it by hand A Delaunay triangulation see delaunay m and related functions is a good choice since it does not produce overly skinny triangles You can compute the Delaunay triangulation on either of the point sets but not both the triangulation has to be the same throughout the morph But the best approach would probably be to compute the triangulation at midway shape i e mean of the two point sets to lessen the potential triangle deformations In order to get nice looking results you will probably want to click on lots of corresponding points 2 You should also add the 4 corners of the image to your list of source and target points so that the background gets mapped appropriately MATLAB has a function tsearch which takes a set of points and a set of triangles and returns a vector indicating which triangle each point lies in type help tsearch The only problem is that it requires the triangulation to be Delaunay and it may be the case that our triangulation is no longer Delaunay at some point during the morphing For this reason I would suggest you use the mytsearch function included in the downloads directory There is also a version written in C which you can compile by typing mex mytsearch cc at the MATLAB prompt The compiled version should run faster Extra credit As detailed in the guidelines any project handed by 11 59 pm on the previous day will receive 5 extra credit Assignment code originally prepared by Dave Martin Boston College and Alyosha Efros CMU", "_id": "http://www.ics.uci.edu/~dramanan/teaching/cs116_winter15/hw/fowlkes_morph.html", "title": "hw2: ", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n  <head>\n    <title>HW2: </title>\n  </head>\n\n  <body>\n  <table><tr><td width=600>\n     \n    <h1>HW2: Morphing</h1>\n    <h3> Due Wednesday, Febuary 5th in EEE DropBox at 11:59 pm </h3>\n    <hr>\n\n    In this assignment you will produce a \"morph\" animation of your face\n    into another student's face.  We will combine the sequence of morphs\n    into a final video which will morph through everyone in the class.\n\n    After taking photos in class, I will post all the photos here:\n    <a href=\"http://www.ics.uci.edu/~fowlkes/class/cs116/hwk2/faces/\">http://www.ics.uci.edu/~fowlkes/class/cs116/hwk2/faces/</a>\n    You need to find the photo of your face and produce a morph from\n    it to the next highest numbered file.  If your photo is the last\n    one, then create a morph from it back to the first photo.\n\n    <ul>\n      <li><a href=\"downloads/\">downloads</a> contains some skeleton code for you to start with\n    </ul>\n \n    <h4>Programming [90 points]</h4>\n\n    Write the following 3 functions (each in their own file) with the following\n    prototypes to perform the morph.  <b>REMINDER: you need to comment your code \n    if you want the grader to be able to understand it and give you full credit</b>\n    \n    <blockquote><tt><pre>\n      </pre></tt></blockquote>\n    <ol>\n      \n\t<hr>\n\t<p><li><b>[30 points]</b> \n  This function computes the affine transformation which maps points from tri1\n  to tri2.  You will use this to map pixels inside each triangle of your mesh.\n\n  NOTE: do not use maketform or other MATLAB functions, just basic math operations.\n\n\t<blockquote><tt><pre>\n  function T = tform(tri1,tri2)\n  %\n  % compute the transformation T which maps points\n  % of triangle1 to triangle2 \n  %\n  %  tri1 : 2x3 matrix containing coordinates of triangle 1\n  %  tri2 : 2x3 matrix containing coordinates of triangle 2\n  %\n  %  T : the resulting transformation, should be a 3x3\n  %      matrix which operates on points described in \n  %      homogeneous coordinates \n  %\n\t</pre></tt></blockquote>\n\t<hr>\n\n\t<p><li><b>[30 points]</b> \n  This function computes a warped image starting from a source image and a\n  set of triangulated keypoints.  You will want to use MATLAB's built in\n  function for interpolation <b>interp2</b> and the provided function\n  <b>mytsearch</b> for finding which triangle each point lies in.\n\t<blockquote><tt><pre>\n  function I_target = warp(I_source,pts_source,pts_target,tri)\n  %\n  % I_source : color source image  (HxWx3)\n  % pts_source : coordinates of keypoints in the source image  (2xN)\n  % pts_target : coordinates of where the keypoints end up after the warp (2xN)\n  % tri : list of triangles (triples of indices into pts_source)  (Kx3)\n  %       for example, the coordinates of the Tth triangle should be \n  %       given by the expression:\n  %\n  %           pts_source(:,tri(T,:))\n  % \n  %\n  % I_target : resulting warped image, same size as source image (HxWx3)\n  %\n</pre></tt></blockquote>\n  <hr>\n\n\t<p><li><b>[30 points]</b> \n  Write a script <b>morph.m</b> that loads in the source and target image\n  and produces a morph between them.  The script should let the user click on \n  keypoints in each image to indicate correspondences.  It should then triangulate\n  the set of points (using <b>delaunay.m</b>) and then produce a morph \n  sequence by repeatedly warping the source and target images to an intermediate\n  image and blending them.\n\n  NOTE: you may want to save user clicks out to a file and just load them\n  in so that you don't have to keep recreating them while testing your other \n  code.\n\n\t<blockquote><tt><pre>\n  %\n  % morphing script\n  %\n\n  % load in two images...\n\n  % get user clicks on keypoints\n\n  % generate triangulation \n  tri = ...\n\n  % now produce the frames of the morph sequenceA\n  for fnum = 1:61\n    t = (fnum-1)/61;\n    pts_target = (1-t)*pts_img1 + t*pts_img2;                % intermediate key-point locations\n    I1_warp = warp(I1,pts_img1,pts_target,tri);              % warp image 1\n    I2_warp = ...                                            % warp image 2\n    Iresult = (1-t)*I1_warp + t*I2_warp;                     % blend the two warped images\n    imwrite(Iresult,sprintf('frame_%2.2d.jpg',fnum),'jpg')\n  end\n  </pre></tt></blockquote>\n\t<hr>\n\n    </ol>\n\n    <h4>Writeup and Results [10 points]</h4>\n    There is no writeup required but you should generate the sequence of 61 frames\n    of the morph and upload them in a zip file to the dropbox along with your code.\n    I will assemble the frames from everyone's submission into a final video sequence.\n    </ol>\n    \n    <h4>Hints and More Discussion</h4>\n    You will need to define pairs of corresponding points on the two\n    images by hand (the more points, the better the morph, generally). The\n    simplest way is probably to use the <em>cpselect</em> tool or write your own \n    tool using ginput and plot commands (with hold on and hold off ). Now, you\n    need to provide a triangulation of these points that will be used for\n    morphing. You can compute a triangulation any way you like, or even define\n    it by hand. A Delaunay triangulation (see delaunay.m and related functions)\n    is a good choice since it does not produce overly skinny triangles. You can\n    compute the Delaunay triangulation on either of the point sets (but not\n    both -- the triangulation has to be the same throughout the morph!). But\n    the best approach would probably be to compute the triangulation at midway\n    shape (i.e. mean of the two point sets) to lessen the potential triangle\n    deformations. <p> \n\n    In order to get nice looking results you will probably want to click on\n    lots of corresponding points (~20).  You should also add the 4 corners\n    of the image to your list of source and target points so that the background\n    gets mapped appropriately.<p>\n\n    MATLAB has a function <b>tsearch</b> which takes a set of points and a set\n    of triangles and returns a vector indicating which triangle each point lies\n    in (type <b>help tsearch</b>).  The only problem is that it requires the \n    triangulation to be Delaunay and it may be the case that our triangulation\n    is no longer Delaunay at some point during the morphing.  For this reason\n    I would suggest you use the <b>mytsearch</b> function included in the \n    downloads directory.  There is also a version written in C++ which you can \n    compile by typing <b>>>mex mytsearch.cc</b> at the MATLAB prompt.  The \n    compiled version should run faster.<p>\n\n\n    <h4>Extra-credit</h4>\n    As detailed in the <a href=\"../hw_guide.html\">guidelines</a>, any project handed by 11:59 pm on the previous day, will receive 5% extra credit.\n    <br>\n    <br>\n  Assignment/code originally prepared by Dave Martin @ Boston College and Alyosha Efros @ CMU<br>\n  </tr></td></table>\n  </body>\n</html>\n", "id": 26206.0}