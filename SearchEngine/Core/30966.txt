{"text": "Tokens and Java Programs Introduction to Computer Science I III ICS 21 22 23 Introduction In this lecture we will learn about the lowest level of the Java language its tokens We will learn how to recognize and classify every category of token which is like classifying English words into their parts of speech Towards this end we will employ ourly new learned EBNF skilss to write and analyze descriptions for each category of token In later lectures we will learn about a programming language s higher level structures phrases expressions sentences statements paragraphs blocks methods chapters classes and books packages The Family History of Java Before going on to study Java let s take a brief look through quotes at the languages on which Java was based traveling back over 3 years to do so Where it starts C The earliest precursor of Java is C a language developed by Ken Thompson at Bell Labs in the early 197 s C was used as a system programming language for the DEC PDP 7 C began achieving its widespread popularity when Bell s Unix operating system was rewritten in C Unix was the first operating system written in a high level language it was distributed to universities for free where it became popular Linux is currently a popular it is still free variant of Unix C is a general purpose programming language which features economy of expression modern control flow and data structures and a rich set of operators C is not a very high level language nor a big one and is not specialized to any particular area of application B Kernighan D Ritchie The C Programming Language Kernighan Ritchie designed and implemented C From C to C A programming language serves two related purposes it provides a vehicle for the programmer to specify actions to be executed and it provides a set of concepts for the programmer to use when thinking about what can be done The first aspect ideally requires a language that is close to the machine so that all important aspects of a machine are handled simply and efficiently in a way that is reasonably obvious to the programmer The C language was primarily designed with this in mind The second aspect ideally requires a language that is close to the problem to be solved so that the concepts of a solution can be expressed directly and concisely The facilities added to C to create C were primarily designed with this in mind B Stroustrup The C Programming Language 2nd Ed Stroustrup designed and implemented C Java as a Successor to C The Java programming language is a general purpose concurrent class based object oriented language It is designed to be simple enough that many programmer can achieve fluency in the language The Java programming language is related to C and C but it is organized rather differently with a number of aspects of C and C omitted and a few ideas from other languages included It is intended to be a production language not a research language and so as C A R Hoare suggested in his classic paper on language design the design has avoided including new and untested features The Java programming language is a relatively high level language in that details of the machine representation are not available through the language It includes automatic storage management typically using a garbage collector to avoid the safety problems of explicit deallocation as in C s free or C s delete High performance garbage collected implementations can have bounded pauses to support systems programming and real time applications The language does not include any unsafe constructs such as array accesses without index checking since such unsafe constructs would cause a program to behave in an unspecified way J Gosling B Joy G Steele G Bracha The Java Language Specification Overview of Tokens in Java The Big 6 In a Java program all characters are grouped into symbols called tokens Larger language features are built from the first five categories of tokens the sixth kind of token is recognized but is then discarded by the Java compiler from further processing We must learn how to identify all six kind of tokens that can appear in Java programs In EBNF we write one simple rule that captures this structure token identifier keyword separator operator literal comment We will examine each of these kinds of tokens in more detail below again using EBNF For now we briefly describe in English each token type Identifiers names the programmer chooses Keywords names already in the programming language Separators also known as punctuators punctuation characters and paired delimiters Operators symbols that operate on arguments and produce results Literals specified by their type Numeric int and double Logical boolean Textual char and String Reference null Comments LineBlock Finally we will also examine the concept of white space which is crucial to understanding how the Java compiler separates the characters in a program into a list of tokens it sometimes helps decide where one token ends and where the next token starts The Java Character Set The full Java character set includes all the Unicode characters there are 216 65 536 unicode characters Since this character set is very large and its structure very complex in this class we will use only the subset of unicode that includes all the ASCII pronounced Ask E characters there are 28 256 ASCII characters of which we will still use a small subset containing alphabetic numeric and some special characters We can describe the structure of this character set quite simply in EBNF using only alternatives in the right hand sides lower case upper case alphabetic lower case upper case numeric alphanumeric alphabetic numeric special graphic alphanumeric special In the special rule the bracket brace characters stand for themselves not EBNF options nor repetitions and one instance of the vertical bar stands for itself too this is the problem one has when the character set of the language includes special characters that also have meanings in EBNF White space consists of spaces from the space bar horizontal and vertical tabs line terminators newlines and formfeeds all are non printing characters so we must describe them in English White space and tokens are closely related we can use white space to force the end of one token and the start of another token i e white space is used to separate tokens For example XY is considered to be a single token while X Y is considered to be two tokens The white space separates tokens rule is inoperative inside String char literals and comments which are all discussed later Adding extra white space e g blank lines spaces in a line often for indenting to a program changes its appearance but not its meaning to Java it still comprises exactly the same tokens in the same order Programmers mostly use white space for purely stylistic purposes to isolate emphasize parts of programs and to make them easier to read and understand Just as a good comedian know where to pause when telling a joke a good programmer knows where to put white space when writing code Identifiers The first category of token is an Identifier Identifiers are used by programmers to name things in Java things such as variables methods fields classes interfaces exceptions packages etc The rules for recognizing forming legal identifiers can be easily stated in EBNF id start alphabetic identifier id start id start numeric Although identifiers can start with and contain the character we should never include a in identifiers that we write such identifiers are reserved for use by the compiler when it needs to name a special symbol that will not conflict with the names we write Semantically all characters in an identifier are significant including the case upper lower of the alphabetic characters For example the identifier Count and count denote different names in Java likewise the identifier R2D2 and R2 D2 denote different names When you read programs that I have written and write your own program think carefully about the choices made to create identifiers Choose descriptive identifiers mostly starting with lower case letters Separate different words in an identfier with a case change e g idCount this is called camel style with each capital letter representing a hump Apply the Goldilocks Principle not too short not too long just right During our later discussions of programming style we will examine the standard naming conventions that are recommend for use in Java code Carefully avoid identifiers that contain dollar signs avoid homophones sound alike aToDConvertor a2DConvertor homoglyphs look alike allOs vs all s and Allls vs All1s which contain the letter capital O number letter small l letter capital I and number 1 mirrors xCount countX Keywords The second category of token is a Keyword sometimes called a reserved word Keywords are identifiers that Java reserves for its own use These identifiers have built in meanings that cannot change Thus programmers cannot use these identifiers for anything other than their built in meanings Technically Java classifies identifiers and keywords as separate categories of tokens The following is a list of all 49 Java keywords we will learn the meaning of many but not all of them in this course It would be an excellent idea to print this table and then check off the meaning of each keyword when we learn it some keywords have multiple meanings determined by the context in which they are used abstractcontinuegotopackageswitchassertdefaultifprivatethisbooleandoimplementsprotectedthrowbreakdoubleimportpublicthrowsbyteelseinstanceofreturntransientcaseextendsintshorttrycatchfinalinterfacestaticvoidcharfinallylongstrictfpvolatileclassfloatnativesuperwhileconstfornewsynchronized Notice that all Java keywords contain only lower case letters and are at least 2 characters long therefore if we choose identifiers that are very short one character or that have at least one upper case letter in them we will never have to worry about them clashing with accidentally being mistaken for a keyword Also note that in the Metrowerks IDE if you use my color preferences keywords always appear in yellow while identifiers and many other tokens appear in white We could state this same tabular information as a very long and thus harder to read EBNF rule of choices and we really would have to specify each of these keywords and not use looking like keyword Finally assert was recently added in Java 1 4 to the original 48 keywords in Java Separators The third category of token is a Separator also known as a punctuator There are exactly nine single character separators in Java shown in the following simple EBNF rule separator In the separator rule the bracket brace characters stand for themselves not EBNF options or repetitions Note that the first three separators are tokens that separate punctuate other tokens The last six separators 3 pairs of 2 each are also known as delimiters wherever a left delimiter appears in a correct Java program its matching right delimiter appears soon afterwards they always come in matched pairs Together these each pair delimits some other entity For example the Java code Math max count limit contains nine tokens an identifier Math followed by a separator a period followed by another identifier max followed by a separator the left parenthesis delimiter followed by an identfier count followed by a separator a comma followed by another identifier limit followed by a separator the right parenthesis delimiter followed by a separator a semicolon Operators The fourth category of token is an Operator Java includes 37 operators that are listed in the table below each of these operators consist of 1 2 or at most 3 special characters The keywords instanceof and new are also considered operators in Java This double classification can be a bit confusing but by the time we discuss these operators you ll know enough about programmig to take them in stride It is important to understand that Java always tries to construct the longest token from the characters that it is reading So is read as one token not as the three tokens and and nor as the two tokens and nor even as the two tokens and Of course we can always use white space to force Java to recognize separate tokens of any combination of these characters writing is the two tokens and We could state this same tabular information as a very long and thus harder to read EBNF rule of choices and we really would have to specify each of these operators and not use looking like operator Types and Literals The fifth and most complicated category of tokens is the Literal All values that we write in a program are literals each belongs to one of Java s four primitive types int double boolean char or belongs to the special reference type String All primitive type names are keywords in Java the String reference type names a class in the standard Java library which we will learn much more about soon A value of any type written in a Java program is called a literal and each written literal belongs in or is said to have exactly one type literal integer literal floating point literal boolean literal character literal string literal null literal Here are some examples of literals of each of these types Literaltype1int3 14double 1 is a double too trueboolean 3 char P and are char too UCI ID Stringnullany reference type The next six sections discuss each of these types of literals in more detail int Literals Literals of the primitive type int represent countable discrete quantities values with no fractions nor decimal places possible necessary We can specify the EBNF for an int literal in Java as non zero digit digit non zero digit digits digit digit decimal numeral non zero digit digits integer literal decimal numeral octal numeral hexidecimal numeral This EBNF specifies only decimal base 1 literals In Java literals can also be written in ocal base 8 and hexidecimal base 16 I have omitted the EBNF rules for forming these kinds of numbers because we will use base 1 exclusively Thus the rules shown above are correct but not complete By the EBNF rules above note that the symbol 15 does not look like a legal integer literal it is certainly not a decimal numeral because it starts with a zero But in fact it is an octal numeral whose EBNF is not shown Never start an integer literal with a unless its value is zero because starting with a in Java signifies the literal is being written as an octal base 8 number e g writing 15 refers to an octal value whose decimal base 1 value is 13 So writing a leading zero in an integer can get you very confused about what you said to the computer Finally note that there are no negative literals we will see soon how to compute such values from the negate arithmetic operator and a positive literal writing 1 is exactly such a construct This is a detail a distinction without much difference double Literals Literals of the primtive type double represent measureable quantities Like real numbers in mathematics they can represent fractions and numbers with decimal places We can specify the EBNF for a double literal in Java as exponent indicator exponent part exponent indicator digits floating point literal digits exponent part digits digits exponent part digits exponent part This EBNF specifies a floating point literal to contain various combinations of a decimal point and exponent so long as one or both are present if neither is present then the literal must be classified as an int literal The exponent indicator E or e should be read to mean times 1 raised to the power of Like literals of the type int all double literals are non negative although they may contain negative exponents Using E or e means that we can specify very large or small values easily 3 518E 15 is equivalent to 3 518 times 1 raised to the power of 15 or 3518 and 3 518E 15 is equivalent to 3 518 times 1 raised to the power of 15 or 3518 In fact any literal with an exponent part is a double so even writing 1E3 is equivalent to writing 1 E3 which are both equivalent to writing 1 Note this does not mean the int literal 1 Finally all double literals must be written in base 1 unlike int literals which can be written in octal or hexadecimal boolean Literals The type name boolean honors George Boole a 19th century English mathematician who revolutionized the study of logic by making it more like arithmetic He invented a method for calculating with truth values and an algebra for reasoning about these calculations Boole s methods are used extensively today in the engineering of hardware and software systems Literals of the primitive type boolean represent on off yes no present absent data There are only two values of this primtive type so its ENBF rule is trivially written as boolean literal In Java although these values look like identifiers they are classified as literal tokens just as all the keywords also look like identifiers but are classified differently Therefore 1 and true are both literal tokens in Java of type int and boolean respectively Students who are familiar with numbers sometimes have a hard time accepting true as a value but that is exactly what it is in Java We will soon learn logical operators that compute with these values of the type boolean just as arithmetic operators compute with values of the type int char Literals The first type of text literal is a char This word can be pronounced in many ways care car or as in charcoal I ll use this last pronunciation Literals of this primitive type represent exactly one character inside single quotes Its EBNF rule is written character literal graphic space escape sequence where the middle option is a space between single quotes Examples are X or x or or or n etc see below for a list of some useful escape sequences Note that X is classified just as a literal token of the primitive type char it is NOT classified as an identifier token inside two separator tokens String Literals The second type of text literal is a String Literals of this reference type the only one in this bunch it is not a primitive type represent zero one or more characters Its EBNF is written string literal graphic space escape sequence Examples are n nEnter your SSN or the empty String or X a one character String which is different from a char Note that UCI is classified just as a literal token of the reference type String it is NOT classified as an identifier token inside two separator tokens Escape Sequences Sometimes you will see an escape sequence inside the single quotes for a character literal or one or more inside double quotes for a string literal see above each escape sequence is translated into a character that prints in some special way Some commonly used escape sequences are Escape SequenceMeaning nnew line thorizontal tab vvertical tab bbackspace rcarriage return fform feed abell needed to denote in a text literal does not act as the right of a char literal does not act as the right of a String literal So in the String literal He said Hi neither escape sequence acts to end the String literal each represents a double quote that is part of the String literal which displays as He said Hi If we output Pack nage Java would print on the consolePack age with the escape sequence n causing Java to immediately terminate the current line and start at the beginning of a new line There are other ways in Java to write escape sequences dealing with unicode represented by octal numbers that we will not cover here nor need in the course The only escape sequence that we wil use with any frequency is n The null Reference Literal There is a very simple special kind of literal that is used to represent a special value with every reference type in Java so far we know only one the type String For completeness we will list it here and learn about its use a bit later Its trivial EBNF rule is written null literal So as we learned with boolean literals null is a literal in Java not an identifier Bounded Numeric Types Although there are an infinite number of integers in mathematics values in the int type are limited to the range from 2 147 483 648 to 2 147 483 647 We will explore this limitation later in the course but for now we will not worry about it Likewise although there are an infinite number of reals in mathematics values in the double type are limited to the range from 1 7976931348623157 x1 3 8 to 1 7976931348623157 x1 3 8 the smallest non zero positive value is 4 94 65645841246544x1 324 Values in this type can have up to about 15 significant digits For most engineering and science calculations this range and precision are adequate In fact there are other primitive numeric types which are also keywords short long and float These types are variants of int and double and are not as widely useful as these more standard types so we will not cover them in this course Finally there is a reference type named BigInteger which can represent any number of digits in an integer up to the memory capacity of the machine Such a type is very powerful because it can represent any integer but costly to use in execution time and computer space compared to int Most programs can live with the small integer values specified above but we will also study this reference type soon and write programs using it Comments The sixth and final category of tokens is the Comment Comments allow us to place any form of documentation inside our Java code They can contain anything that we can type on the keyboard English mathematics even low resolution pictures In general Java recognizes comments as tokens but then excludes these tokens from further processing technically it treats them as white space when it is forming tokens Comments help us capture aspects of our programs that cannot be expressed as Java code Things like goals specification design structures time space tradeoffs historical information advice for using modifying this code etc Programmers intensely study their own code or the code of others when maintaining it testing debugging or modifying it Good comments in code make all these tasks much easier Java includes two style for comments Line Oriented begins with and continues until the end of the line Block Oriented begins with and continues possibly over many lines until is reached So we can use block oriented comments to create multiple comments within a line display Value x on device d In contrast once a line oriented comment starts everything afterward on its line is included in the comment We can also use block oriented comments to span multiple lines This is a multi line comment No matter home many lines it includes only one pair of delimiters are needed In contrast a line oriented comment stops at the end of the line it starts on Technically both kinds of comments are treated as white space so writing X comment Y has the same meaning in Java as writing the tokens X and Y not the single token XY Typically Java comments are line oriented we will save block oriented comments for a special debugging purpose discussed later The EBNF rule for comments is more complicated than insightful so we will not study here This happens once in a while Program are a Sequence of Tokens built from Characters The first phase a Java compiler tokenizes a program by scanning its characters left to right top to bottom there is a hidden end of line character at the end of each line recall that it is equivalent to white space and combining selected characters into tokens It works by repeating the following algorithm an algorithm is a precise set of instructions Skip any white space if the next character is an underscore dollar or alphabetic character it builds an identifier token Except for recognizing keywords and certain literals true false null which all share the form of identifiers but are not themselves identifiers if the next character is a numeric character or it builds a literal token if the next character is a period that is a seperator unless the character after it is a numeric character in which case it builds a double literal if the next two characters are a or starting a comment it builds a comment token if the next character is anything else it builds a separator or operator token trying to build the longest token given that white space separates tokens except in a char or String literal Recall that white space except when inside a textual literal or comment separates tokens Also the Java compiler uses the longest token rule it includes characters in a token until it reaches a character that cannot be included Finally after building and recognizing each token the Java compiler passes all tokens except for comments which are ignored after being tokenized on to the next phase of the compiler Common Mistakes I have seen the following mistakes made repeatedly by beginning students trying to tokenize programs Try to understand each of these subtle points Tokenizing x as a char literal it is an identifier Tokenizing 1 5 as two int literals separated by a period it is a double literal Tokenizing int as a literal it is a keyword that happens to name a type in Java Tokens like 1 are literals whose type is int the token int is a keyword Tokenizing Hi as two separators with the identifier Hi in between it is a single String literal Tokenizing something like as one separator token it is really two separate separators Tokenizing something like as two separate operator tokens because and are operators it is really one large token because is an operator Forgetting to tokenize parentheses semicolons and other separators everything except white space belongs in some token Creaing tokens inside comments each comment is one big token that includes all the characters in the comment A Simple Program The following program will serve as a model of Input Calculate Output programs in Java Here are some highlights A large multi line oriented comment appears at the top of the program Line oriented comments appear at various other locations in the program The Prompt class is imported from the edu uci ics pattis introlib package The Application class is declared Its main method is declared its body the statements it executes is placed between the and delimiters Each simple statement in the body is ended by a semicolon separator Three variables storing double values are declared The user is prompted for the value to store in the first two variables The third variable s value is computed and stored The third variable s value is printed after printing a blank line Besides just reading this program practice tokenzing it Description This program computes the time it take to drop an object in a vacuum form an arbitrary height in an arbitrary gravitational field so it can be used to calculate drop times on other planets It models a straight input calculate output program the user enters the gravitation field and then the height it calculates thd drop time and then prints in on the console import edu uci ics pattis introlib Prompt public class Application public static void main String args double gravity meter sec sec double height meters double time sec Input gravity Prompt forDouble Enter gravitational acceleration in meters sec sec height Prompt forDouble Enter height of drop in meters Calculate time Math sqrt 2 height gravity Output System out println nDrop time time secs How Experts See Programs In the 194 s a Dutch psychologist named DeGroot was doing research on chess experts He performed the following experiment He sat chess experts down in front of an empty chessboard all the chess pieces and a curtain Behind the curtain was a chessboard with its pieces arranged about 35 moves into a game The curtain was raised for one minute and then lowered The chess experts were asked to reconstruct what they remembered from seeing the chessboard behind the curtain In most cases the chess experts were able to completely reconstruct the board that they saw The same experiment was conducted with chess novices but most were able to remember only a few locations of the pieces These results could be interpreted as Chess experts have much better memories than novices So DeGroot performed a second similar experiment In the second experiment the board behind the curtain had the same number of chess pieces but they were randomly placed on the board they did not represent an ongoing game In this modified experiment the chess experts did only marginally better than the novices DeGroot s conclusion was that chess experts saw the board differently than novices they saw not only pieces but attacking and defending structures board control etc In this class I am trying to teach you how to see programs as a programmer sees them not as a sequence of characters but at a higher structural level Tokens is where we start this process For another example on what the mind sees when it reads look at the following document Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a CA a Tutor or any other student Classify each of the following as a legal or illegal identifier If it is illegal propose a legal identifier that can take its place a homophone or homoglyph packAgex122LipsxOrYsum of squares RaisetermInAteu235 Billx 1x Y1derBoys What tokens does Java build from the characters ab c d e Be sure that you know your Operators Classify each of the following numeric literals as int or double or illegal neither write the equivalent value of each double without using E notation for each illegal literal write a legal one with the same value 5 3 14151717 1E31 E3 5E 35 4x1 35 E 11 24 87 87 What is the difference between 5 5 five 5 and 5 What is the difference between true and true Write a String literal that includes the characters I ve said a million times Do not exaggerate How does Java classify each of the following lines To be or not to be To be or not to be Does the following line contain one comment or two A comment Another comment Explain whether X Y is equivalent to XY or X Y Tokenize the following Java Code be careful 15 Tokenize the following line of Java code identify every Java token as either an Identifier Keyword Separator Operator Literal for any literal also specify its type or Comment Which if any identifiers are keywords int X Prompt forInt SSN 999999999 Filter use Choose an appropriate type to represent each of the following pieces of information the number of characters in a file a time of day accurate to 1 second the middle initial in a name whether the left mouse button is currently pushed the position of a rotary switch with 5 positions the temperature of a blast furnace an indication of whether one quantity is less than equal to or greater than another the name of a company This problem it is tricky so do it carefully shows a difficulty with using Block Oriented comments Tokenize the following two lines of Java code identify every token as either an Identifier Keyword Separator Operator Literal or Comment What problem arises x Initialize x and y to y 1 their starting values Rewrite the code shown above with Line Oriented comments instead to avoid this problem How can our use of my Java preferences help us avoid this error This problem it is tricky so do it carefully shows another difficulty with using Block Oriented comments Tokenize the following Java code identify every token as either an Identifier Keyword Separator Operator Literal or Comment What problem arises here is an outer comment with an inner comment inside and the finish of the outer comment at the end Rewrite the code shown above with Line Oriented comments instead to avoid this problem How can our use of my Java preferences help us avoid this error Explain why language designers are very reluctant to add new keywords to a programming language Hint what problem might this cause in already written programs ", "_id": "http://www.ics.uci.edu/~pattis/ICS-21/lectures/tokens/lecture.html", "title": "tokens in java programs", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Tokens in Java Programs</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Tokens and Java Programs</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III\r\n<br>\r\nICS-21/-22/-23\r\n<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will learn about the lowest level of the Java language:\r\n    its tokens.\r\n  We will learn how to recognize and classify every category of token \r\n    (which is like classifying English words into their parts of speech).\r\n  Towards this end, we will employ ourly new learned EBNF skilss to write and\r\n    analyze descriptions for each category of token.\r\n  In later lectures we will learn about a programming language's higher level\r\n    structures: phrases (expressions), sentences (statements),\r\n    paragraphs (blocks/methods), chapters (classes), and books (packages).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Historical Context -->\r\n\r\n<a name=\"Historical\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Family History of Java</b></td>\r\n<td width =\"80%\">\r\n  Before going on to study Java, let's take a brief look, through quotes,\r\n    at the languages on which Java was based, traveling back over 30 years\r\n    to do so.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<a name=\"C\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Where it starts: C <b></td>\r\n<td width =\"80%\">\r\n  The earliest precursor of Java is C: a language developed  by Ken Thompson\r\n    at Bell Labs in the early 1970s.\r\n  C was used as a system programming language for the DEC PDP-7.\r\n  C began achieving its widespread popularity when Bell's Unix operating \r\n     system was  rewritten in C.\r\n  Unix was the first operating system written in a high-level language;\r\n    it was distributed to universities for free, where it became popular.\r\n  Linux is currently a popular (it is still free!) variant of Unix.\r\n  <p>\r\n  \"C is a general-purpose programming language which features economy of\r\n     expression, modern control flow and data structures, and a rich set of\r\n     operators.\r\n   C is not a \"very high level\" language, nor a \"big\" one, and is not\r\n     specialized to any particular area of application.\"\r\n  <br>\r\n  <div align=\"right\">- B. Kernighan/D. Ritchie: The C Programming Language<br>\r\n    (Kernighan & Ritchie designed and implemented C)\r\n  </div>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Philosophical Context -->\r\n\r\n<a name=\"Philosophy\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>From C to C++</b></td>\r\n<td width =\"80%\">\r\n  \"A programming language serves two related purposes: it provides a vehicle\r\n     for the programmer to specify actions to be executed, and it provides a\r\n     set of concepts for the programmer to use when thinking about what can\r\n     be done.\r\n   The first aspect ideally requires a language that is \"close to the\r\n      machine,\" so that all important aspects of a machine are handled simply\r\n      and efficiently in a way that is reasonably obvious to the programmer.\r\n   The C language was primarily designed with this in mind.\r\n   The second aspect ideally requires a language that is \"close to the\r\n     problem to be solved\" so that the concepts of a solution can be expressed\r\n    directly and concisely.\r\n   The facilities added to C to create C++ were primarily designed with this\r\n     in mind\"\r\n  <div align=\"right\">\r\n    - B. Stroustrup: The C++ Programming Language (2nd Ed)<br>\r\n    (Stroustrup designed and implemented C++)\r\n  </div>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Java -->\r\n\r\n<a name=\"NewJava\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Java as a Successor to C++</b></td>\r\n<td width =\"80%\">\r\n  \"The Java programming language is a general-purpose, concurrent, class-based,\r\n    object-oriented language.\r\n   It is designed to be simple enough that many programmer can achieve fluency\r\n      in the language.\r\n   The Java programming language is related to C and C++ but it is organized \r\n     rather differently, with a number of aspects of C and C++ omitted and a\r\n      few ideas from other languages included.\r\n   It is intended to be a production language, not a research language, and\r\n     so, as C.A.R. Hoare suggested in his classic paper on language design,\r\n     the design has avoided including new and untested features.\r\n   <br>\r\n   ...\r\n   <br>\r\n   The Java programming language is a relatively high-level language, in that\r\n     details of the machine representation are not available through the\r\n     language.\r\n   It includes automatic storage management, typically using a garbage\r\n     collector, to avoid the safety problems of explicit deallocation (as in\r\n     C's <b>free</b> or C++'s  <b>delete</b>).\r\n   High-performance garbage-collected implementations can have bounded pauses\r\n     to support systems programming and real-time applications.\r\n   The language does not include any unsafe constructs, such as array accesses\r\n     without index checking, since such unsafe constructs would cause a\r\n     program to behave in an unspecified way.\"\r\n   <div align=\"right\">\r\n    - J. Gosling, B. Joy, G. Steele, G. Bracha: The Java Language Specification\r\n  </div>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Tokens -->\r\n\r\n<a name=\"Tokens\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Overview of Tokens in Java: The Big 6</b></td>\r\n<td width =\"80%\">\r\n  In a Java program, all characters are grouped into symbols called\r\n    <b>tokens</b>.\r\n  Larger language features are built from the first five categories of tokens\r\n   (the sixth kind of token is recognized, but is then discarded by the Java\r\n   compiler from further processing).\r\n  We must learn how to identify all six kind of tokens that can appear in\r\n    Java programs.\r\n  In EBNF we write one simple rule that captures this structure:\r\n  <p>\r\n  <i>token</i> <= <i>identifier</i> | <i>keyword</i> | <i>separator</i> | <i>operator</i> | <i>literal</i> | <i>comment</i> \r\n  <p> \r\n  We will examine each of these kinds of tokens in more detail below, again\r\n    using EBNF.\r\n  For now, we briefly describe in English each token type.\r\n  <p>\r\n  <ol>\r\n    <li>Identifiers: names the programmer chooses\r\n    <li>Keywords: names already in the programming language\r\n    <li>Separators (also known as punctuators): punctuation characters and\r\n          paired-delimiters \r\n    <li>Operators: symbols that operate on arguments and produce results\r\n    <li>Literals (specified by their <b>type</b>)\r\n      <ul>\r\n        <li>Numeric: <b>int</b> and <b>double</b>\r\n        <li>Logical: <b>boolean</b>\r\n        <li>Textual: <b>char</b> and <b>String</b>\r\n        <li>Reference: <b>null</b>\r\n      </ul>\r\n    <li>Comments\r\n      <ul><li>Line<li>Block</ul>\r\n  </ol>\r\n  Finally, we will also examine the concept of <b>white space</b> which is\r\n    crucial to understanding how the Java compiler separates the characters\r\n     in a program into a list of tokens; it sometimes helps decide where one\r\n     token ends and where the next token starts.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Characters -->\r\n\r\n<a name=\"Characters\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Java Character Set</b></td>\r\n<td width =\"80%\">\r\n  The full Java character set includes all the \r\n    <a href=\"http://www.unicode.org\" target=\"_blank\">Unicode</a>\r\n    characters; there are 2<sup>16</sup> = 65,536 unicode characters.\r\n  Since this character set is very large and its structure very complex, in\r\n   this class  we will use only the subset of unicode that includes all the\r\n   <b>ASCII</b> (pronounced \"Ask E\") characters; there are 2<sup>8</sup> = 256\r\n   ASCII characters, of which we will still use a small subset containing\r\n   alphabetic, numeric, and some special characters.\r\n<p>\r\n  We can describe the structure of this character set quite simply in EBNF,\r\n   using only alternatives in the right hand sides.\r\n  <p>\r\n  <i>lower-case</i> <= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z<br>\r\n  <i>upper-case</i> <= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z<br> \r\n  <i>alphabetic</i> <= <i>lower-case</i> | <i>upper-case</i><br> \r\n  <i>numeric</i> &nbsp &nbsp <= 0|1|2|3|4|5|6|7|8|9<br> \r\n  <i>alphanumeric</i> <= <i>alphabetic</i> | <i>numeric</i><br> \r\n  <i>special</i> &nbsp &nbsp &nbsp <= !|%|^|&|*|(|)|-|+|=|{|}|||~|[|]|\\|;|'|:|\"|<|>|?|,|.|/|#|@|`|_<br>\r\n  <i>graphic</i> &nbsp &nbsp <= <i>alphanumeric</i> | <i>special</i>\r\n  <p>\r\n  In the <i>special</i> rule, the bracket/brace characters stand for themselves\r\n    (not EBNF options nor repetitions) and one instance of the vertical bar \r\n    stands for itself too: this is the problem one has when the character set\r\n    of the language includes special characters that also have meanings in\r\n    EBNF.\r\n  <p>\r\n  White space consists of spaces (from the space bar), horizontal and vertical\r\n    tabs, line terminators (newlines and formfeeds): all are non-printing\r\n    characters, so we must describe them in English.\r\n  White space and tokens are closely related: we can use white space to force\r\n    the end of one token and the start of another token (i.e., white space is\r\n    used to separate tokens).\r\n  For example <b>XY</b> is considered to be a single token, while <b>X Y</b>\r\n    is considered to be two tokens.\r\n  The \"white space separates tokens\" rule is inoperative inside\r\n     <b>String</b>/<b>char</b> literals, and comments (which are all discussed\r\n     later).\r\n  <p>\r\n  Adding extra white space (e.g., blank lines, spaces in a line -often for\r\n    indenting) to a program changes its appearance but not its meaning to Java:\r\n    it still comprises exactly the same tokens in the same order.\r\n  Programmers mostly use white space for purely stylistic purposes: to\r\n    isolate/emphasize parts of programs and to make them easier to read and\r\n    understand.\r\n  Just as a good comedian know where to pause when telling a joke; a good\r\n    programmer knows where to put white space when writing code. \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Identifiers -->\r\n\r\n<a name=\"Identifiers\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Identifiers</b></td>\r\n<td width =\"80%\">\r\n  The first category of token is an <b>Identifier</b>.\r\n  Identifiers are used by programmers to name things in Java: things such as\r\n    variables, methods, fields, classes, interfaces, exceptions, packages, etc.\r\n  The rules for recognizing/forming legal identifiers can be easily stated in\r\n    EBNF.\r\n  <p>\r\n  <i>id-start</i> &nbsp &nbsp<= <i>alphabetic</i> | $ | _<br> \r\n  <i>identifier</i> <= <i>id-start</i>{<i>id-start</i> | <i>numeric</i> }<br> \r\n  <p>\r\n  Although identifiers can start with and contain the <b>$</b> character,\r\n    we should never include a <b>$</b> in identifiers that we write;\r\n    such identifiers are reserved for use by the compiler, when it needs to\r\n    name a special symbol that will not conflict with the names we write.\r\n  <p>\r\n  Semantically, all characters in an identifier are significant, including the\r\n    case (upper/lower) of the alphabetic characters.\r\n  For example, the identifier <b>Count</b> and <b>count</b> denote different\r\n    names in Java; likewise, the identifier <b>R2D2</b> and <b>R2_D2</b>\r\n    denote different names.\r\n  <p>\r\n  When you read programs that I have written, and write your own program,\r\n    think carefully about the choices made to create identifiers.\r\n  <ul>\r\n    <li>Choose descriptive identifiers (mostly starting with lower-case\r\n          letters).\r\n    <li>Separate different words in an identfier with a case change:\r\n          e.g., <b>idCount</b>; this is called \"camel style\", with each\r\n          capital letter representing a hump.\r\n    <li>Apply the \"Goldilocks Principle\": not too short, not too long, just\r\n          right.\r\n   </ul>\r\n  During our later discussions of programming style, we will examine the\r\n    standard naming conventions that are recommend for use in Java code.\r\n<p>\r\n  Carefully avoid identifiers that contain dollar signs; avoid\r\n   <ul>\r\n     <li>homophones (sound alike): <b>aToDConvertor</b> &nbsp <b>a2DConvertor</b>\r\n     <li>homoglyphs (look alike): <b>allOs</b> vs. <b>all0s</b> and\r\n          <b>Allls</b> vs <b>All1s</b> \r\n       <ul>which contain the letter (capital) O, number 0, letter (small) l,\r\n             letter (capital) I, and number 1</ul>\r\n     <li>mirrors: <b>xCount</b> &nbsp <b>countX</b>\r\n   </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Keywords -->\r\n\r\n<a name=\"Keywords\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Keywords</b></td>\r\n<td width =\"80%\">\r\n  The second category of token is a <b>Keyword</b>, sometimes called a\r\n    reserved word.\r\n  Keywords are identifiers that Java reserves for its own use.\r\n  These identifiers have built-in meanings that cannot change.\r\n  Thus, programmers cannot use these identifiers for anything other than their\r\n    built-in meanings.\r\n  Technically, Java classifies identifiers and keywords as separate categories\r\n    of tokens.\r\n  <p>\r\n  The following is a list of all 49 Java keywords we will learn the meaning\r\n    of many, but not all,of them in this course.\r\n  It would be an excellent idea to print this table, and then check off the\r\n    meaning of each keyword when we learn it; some keywords have multiple\r\n    meanings, determined by the context in which they are used.\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<tbody >\r\n<tr><td>abstract</td><td>continue</td><td>goto</td><td>package</td><td>switch</td>\r\n<tr><td>assert</td><td>default</td><td>if</td><td>private</td><td>this</td>\r\n<tr><td>boolean</td><td>do</td><td>implements</td><td>protected</td><td>throw</td>\r\n<tr><td>break</td><td>double</td><td>import</td><td>public</td><td>throws</td>\r\n<tr><td>byte</td><td>else</td><td>instanceof</td><td>return</td><td>transient</td>\r\n<tr><td>case</td><td>extends</td><td>int</td><td>short</td><td>try</td>\r\n<tr><td>catch</td><td>final</td><td>interface</td><td>static</td><td>void</td>\r\n<tr><td>char</td><td>finally</td><td>long</td><td>strictfp</td><td>volatile</td><tr><td>class</td><td>float</td><td>native</td><td>super</td><td>while</td>\r\n<tr><td>const</td><td>for</td><td>new</td><td>synchronized</td><td>&nbsp</td>\r\n\r\n<tr>\r\n</table>\r\n  <p>\r\n  Notice that all Java keywords contain only lower-case letters and are at\r\n    least 2 characters long; therefore, if we choose identifiers that are very\r\n    short (one character) or that have at least one upper-case letter in them,\r\n    we will never have to worry about them clashing with (accidentally being\r\n    mistaken for) a keyword.\r\n  Also note that in the Metrowerks IDE (if you use my color preferences),\r\n    keywords always appear in yellow (while identifiers, and many other tokens,\r\n    appear in white).\r\n  <p>\r\n  We could state this same tabular information as a very long (and thus harder\r\n    to read) EBNF rule of choices (and we really would have to specify \r\n    each of these keywords, and not use \"...\") looking like\r\n  <p>\r\n  <i>keyword</i> <= abstract | boolean | ... | while \r\n  <p>\r\n  Finally, <b>assert</b> was recently added (in Java 1.4) to the original 48\r\n    keywords in Java.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Separators -->\r\n\r\n<a name=\"Separators\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Separators</b></td>\r\n<td width =\"80%\">\r\n  The third category of token is a <b>Separator</b> (also known as a\r\n    punctuator).\r\n  There are exactly nine, single character separators in Java, shown in the\r\n     following simple EBNF rule.\r\n  <p>\r\n  <i>separator</i> <= ; | , | . | ( | ) | { | } | [ | ]  \r\n  <p>\r\n  In the <i>separator</i> rule, the bracket/brace characters stand for\r\n    themselves (not EBNF options or repetitions).\r\n  <p>\r\n  Note that the first three separators are tokens that separate/punctuate\r\n    other tokens.\r\n  The last six separators (3 pairs of 2 each) are also known as delimiters:\r\n    wherever a left delimiter appears in a correct Java program, its matching\r\n    right delimiter appears soon afterwards (they always come in matched\r\n    pairs).\r\n  Together, these each pair delimits some other entity.\r\n  <p>\r\n  For example the Java code <b>Math.max(count,limit);</b> contains nine\r\n   tokens\r\n  <ol>\r\n    <li> an identifier (<b>Math</b>), followed by\r\n    <li> a separator (a period), followed by \r\n    <li> another identifier (<b>max</b>), followed by\r\n    <li> a separator (the left parenthesis delimiter), followed by\r\n    <li> an identfier (<b>count</b>), followed by\r\n    <li> a separator (a comma), followed by\r\n    <li> another identifier(<b>limit</b>), followed by\r\n    <li> a separator (the right parenthesis delimiter), followed by\r\n     <li> a separator (a semicolon)\r\n </ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Operators -->\r\n\r\n<a name=\"Operators\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Operators</b></td>\r\n<td width =\"80%\">\r\n  The fourth category of token is an <b>Operator</b>.\r\n  Java includes 37 operators that are listed in the table below;\r\n    each of these operators consist of 1, 2, or at most 3 <i>special</i> \r\n    characters.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n    <tbody>\r\n    <tr align=\"center\"><td>=</td><td>&gt</td><td>&lt</td><td>!</td><td>~</td><td>?</td><td>:</td><td>&nbsp</td>\r\n        <td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n    <tr align=\"center\"><td>==</td><td>&lt=</td><td>&gt=</td><td>!=</td><td>&&</td><td>||</td><td>++</td><td>--</td>\r\n        <td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n    <tr align=\"center\"><td>+</td><td>-</td><td>*</td><td>/</td><td>&</td><td>|</td><td>^</td><td>%</td>\r\n        <td>&lt&lt</td><td>&gt&gt</td><td>&gt&gt&gt</td>\r\n    <tr align=\"center\"><td>+=</td><td>-=</td><td>*=</td><td>/=</td><td>&=</td><td>|=</td><td>^=</td><td>%=</td>\r\n        <td>&lt&lt=</td><td>&gt&gt=</td><td>&gt&gt=</td>\r\n    </table>\r\n  <p>\r\n  The keywords <b>instanceof</b> and <b>new</b> are also considered operators\r\n    in Java.\r\n  This double classification can be a bit confusing; but by the time we\r\n    discuss these operators, you'll know enough about programmig to take them\r\n    in stride.\r\n  <p>\r\n  It is important to understand that Java always tries to construct the\r\n    <b>longest</b> token from the characters that it is reading.\r\n  So, <b>&gt&gt=</b> is read as one token, not as the three tokens <b>&gt</b>\r\n     and <b>&gt</b> and <b>=</b>, nor as the two tokens <b>&gt&gt</b> and\r\n     <b>=</b>, nor even as the two tokens <b>&gt</b> and <b>&gt=</b>.\r\n  <p>\r\n  Of course, we can always use white space to force Java to recognize separate\r\n    tokens of any combination of these characters:\r\n    writing <b>&gt &nbsp &gt=</b> is the two tokens <b>&gt</b> and <b>&gt=</b>.\r\n  <p>\r\n  We could state this same tabular information as a very long (and thus harder\r\n    to read) EBNF rule of choices (and we really would have to specify each of\r\n    these operators, and not use \"...\") looking like\r\n  <p>\r\n  <i>operator</i> <= &nbsp = | &gt | ... | &gt&gt= | instanceof | new\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Types and Literals -->\r\n\r\n<a name=\"TypesLiterals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Types and Literals</b></td>\r\n<td width =\"80%\">\r\n  The fifth, and most complicated category of tokens is the <b>Literal</b>.\r\n  All values that we write in a program are literals: each belongs to one of\r\n     Java's four primitive types (<b>int</b>, <b>double</b>, <b>boolean</b>,\r\n     <b>char</b>) or belongs to the special reference type <b>String</b>.\r\n  All primitive type names are keywords in Java; the <b>String</b> reference\r\n    type names a class in the standard Java library, which we will learn much\r\n    more about soon.\r\n  A value (of any type) written in a Java program is called a <b>literal</b>;\r\n    and, each written literal belongs in (or is said to have) exactly one type.\r\n  <p>\r\n  <i>literal</i> <= <i>integer-literal</i> | <i>floating-point-literal</i> | <i>boolean-literal</i><br>\r\n    &nbsp  &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp \r\n    | <i>character-literal</i>\r\n    | <i>string-literal</i>\r\n    | <i>null-literal</i>\r\n  <p>\r\n  Here are some examples of literals of each of these types.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr><th>Literal</th><th>type</th>\r\n  </thead>\r\n  <tbody >\r\n  <tr><td><b>1</b></td><td><b>int</b></td>\r\n  <tr><td><b>3.14</b></td><td><b>double</b> (<b>1.</b> is a <b>double</b> too)</td>\r\n  <tr><td><b>true</b></td><td><b>boolean</b></td>\r\n  <tr><td><b>'3'</b></td><td><b>char</b> (<b>'P'</b> and <b>'+'</b> are <b>char</b> too)</td>\r\n  <tr><td><b>\"UCI ID\"</b></td><td><b>String</b></td>\r\n  <tr><td><b>null</b></td><td>any reference type</td>\r\n  </table>\r\n  <p>\r\n  The next six sections discuss each of these types of literals, in more detail.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- int Literals -->\r\n\r\n<a name=\"IntLiterals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>int Literals</b></td>\r\n<td width =\"80%\">\r\n  Literals of the primitive type <b>int</b> represent countable, discrete\r\n    quantities (values with no fractions nor decimal places\r\n    possible/necessary).\r\n  We can specify the EBNF for an <b>int</b> literal in Java as\r\n  <p>\r\n  <i>non-zero-digit</i> &nbsp &nbsp <= 1|2|3|4|5|6|7|8|9<br> \r\n  <i>digit</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= 0 | <i>non-zero-digit</i><br> \r\n  <i>digits</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>digit</i>{<i>digit</i>}<br> \r\n  <i>decimal-numeral</i> <= 0 | <i>non-zero-digit</i>[<i>digits</i>]<br>\r\n  <i>integer-literal</i> &nbsp &nbsp &nbsp<= <i>decimal-numeral</i><br> \r\n   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp | <i>octal-numeral</i><br>\r\n   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp | <i>hexidecimal-numeral</i>\r\n  <p>\r\n  This EBNF specifies only decimal (base 10) literals. \r\n  In Java literals can also be written in ocal (base 8) and hexidecimal\r\n    (base 16).\r\n  I have omitted the EBNF rules for forming these kinds of numbers, because we\r\n    will use base 10 exclusively.\r\n  Thus, the rules shown above are correct, but not complete.\r\n  <p>\r\n  By the EBNF rules above, note that the symbol <b>015</b> does not look like a\r\n     legal <i>integer-literal</i>; it is certainly not a\r\n     <i>decimal-numeral</i>, because it starts with a zero.\r\n  But, in fact, it is an <i>octal-numeral</i> (whose EBNF is not shown).\r\n  Never start an <i>integer-literal</i> with a <b>0</b> (unless its value is\r\n    zero), because starting with a <b>0</b> in Java signifies the literal is\r\n    being written as an octal (base 8) number: e.g., writing <b>015</b> refers\r\n    to an octal value, whose decimal (base 10) value is 13!\r\n  So writing a leading zero in an integer can get you very confused about what\r\n    you said to the computer.\r\n  <p>\r\n  Finally, note that there are no negative literals: we will see soon how to\r\n    compute such values from the negate arithmetic operator and a positive\r\n    literal (writing <b>-1</b> is exactly such a construct).\r\n  This is a detail: a distinction without much difference.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- double Literals -->\r\n\r\n<a name=\"DoubleLiterals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>double Literals</b></td>\r\n<td width =\"80%\">\r\n  Literals of the primtive type <b>double</b> represent measureable quantities.\r\n  Like real numbers in mathematics, they can represent fractions and numbers\r\n     with decimal places.\r\n  We can specify the EBNF for a <b>double</b> literal in Java as\r\n  <p>\r\n  <i>exponent-indicator</i> &nbsp <= e | E <br> \r\n  <i>exponent-part</i> &nbsp &nbsp &nbsp &nbsp &nbsp  <= <i>exponent-indicator</i> [+|-]<i>digits</i><br> \r\n  <i>floating-point-literal</i> <= <i>digits</i> <i>exponent-part</i><br>\r\n    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n    &nbsp &nbsp &nbsp &nbsp &nbsp\r\n     | <i>digits</i>.[<i>digits</i>][<i>exponent-part</i>]<br>\r\n    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n    &nbsp &nbsp &nbsp &nbsp &nbsp\r\n     | .<i>digits</i>[<i>exponent-part</i>]\r\n  <p>\r\n  This EBNF specifies a <i>floating-point-literal</i> to contain various\r\n    combinations of a decimal point and exponent (so long as one -or both- are\r\n    present); if neither is present then the literal must be classified as an\r\n    <i>int-literal</i>.\r\n  The <i>exponent-indicator</i> (<b>E</b> or <b>e</b>) should be read to mean\r\n    \"times 10 raised to the power of\".\r\n  <p>\r\n  Like literals of the type <b>int</b>, all <b>double</b> literals are\r\n    non-negative (although they may contain negative exponents).\r\n  Using <b>E</b> or <b>e</b> means that we can specify very large or small\r\n    values easily\r\n   (<b>3.518E+15</b> is equivalent to <b>3.518</b> times 10 raised to the\r\n    power of <b>15</b>, or <b>3518000000000000.</b>; and <b>3.518E-15</b> is\r\n    equivalent to <b>3.518</b> times 10 raised to the power of <b>-15</b>, or\r\n    <b>.000000000000003518</b>) \r\n  In fact, any literal with an <i>exponent-part</i> is a <b>double</b>: so even\r\n    writing <b>1E3</b> is equivalent to writing <b>1.E3</b>, which are both\r\n    equivalent to writing </b>1000.</b>\r\n  Note this does not mean the <b>int</b> literal <b>1000</b>!\r\n  <p>\r\n  Finally, all <b>double</b> literals must be written in base 10 (unlike\r\n    <b>int</b> literals, which can be written in octal or hexadecimal) \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Boolean Literals -->\r\n\r\n<a name=\"BooleanLiterals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>boolean Literals</b></td>\r\n<td width =\"80%\">\r\n  The type name <b>boolean</b> honors George Boole, a 19th century English\r\n    mathematician who revolutionized the study of logic by making it more\r\n    like arithmetic.\r\n  He invented a method for calculating with truth values and an algebra for\r\n    reasoning about these calculations.\r\n  Boole's methods are used extensively today in the engineering of hardware\r\n     and software systems.\r\n  <p>\r\n  Literals of the primitive type <b>boolean</b> represent on/off, yes/no,\r\n     present/absent, ... data.\r\n  There are only two values of this primtive type, so its ENBF rule is\r\n    trivially written as\r\n  <p>\r\n  <i>boolean-literal</i> <= true | false<br> \r\n  <p>\r\n  In Java, although these values look like identifiers, they are classified as\r\n    literal tokens (just as all the keywords also look like identifiers, but\r\n    are classified differently).\r\n  Therefore, <b>100</b> and <b>true</b> are both literal tokens in Java (of\r\n    type <b>int</b> and <b>boolean</b> respectively).\r\n  <p>\r\n  Students who are familiar with numbers sometimes have a hard time accepting\r\n    <b>true</b> as a value; but that is exactly what it is in Java. \r\n  We will soon learn logical operators that compute with these values of the\r\n    type <b>boolean</b> just as arithmetic operators compute with values of\r\n    the type <b>int</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Character Literals -->\r\n\r\n<a name=\"CharLiterals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>char Literals</b></td>\r\n<td width =\"80%\">\r\n  The first type of text literal is a <b>char</b>.\r\n  This word can be pronounced in many ways: <i>care</i>, <i>car</i>, or as in\r\n    <i>char</i>coal \r\n  (I'll use this last pronunciation).\r\n  Literals of this primitive type represent exactly one character inside\r\n   single quotes.\r\n  Its EBNF rule is written\r\n  <p>\r\n  <i>character-literal</i> <= '<i>graphic</i>' | '<i>space</i>' | '<i>escape-sequence</i>' \r\n  <p>\r\n  where the middle option is a space between single quotes.\r\n  Examples are <b>'X'</b>, or <b>'x'</b>, or <b>'?'</b>, or <b>'&nbsp'</b>, or\r\n   <b>'\\n'</b>, etc. (see below for a list of some useful escape sequences).\r\n  <p>\r\n  Note that <b>'X'</b> is classified just as a literal token (of the primitive\r\n    type <b>char</b>); it is NOT classified as an identifier token inside two\r\n    separator tokens!\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- String Literals -->\r\n\r\n<a name=\"StringLiterals\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>String Literals</b></td>\r\n<td width =\"80%\">\r\n  The second type of text literal is a <b>String</b>.\r\n  Literals of this reference type (the only one in this bunch; it is not a\r\n    primitive type) represent zero, one, or more characters:\r\n  Its EBNF is written\r\n  <p>\r\n  <i>string-literal</i> <= \"{<i>graphic</i> | <i>space</i> | <i>escape-sequence</i>}\" \r\n  <p>\r\n  Examples are: <b>\"\\n\\nEnter your SSN:\"</b>, or\r\n   <b>\"\"</b> (the empty String), or\r\n   <b>\"X\"</b> (a one character <b>String</b>, which is different from a\r\n   <b>char</b>).\r\n  <p>\r\n  Note that <b>\"UCI\"</b> is classified just as a literal token (of the\r\n    reference type <b>String</b>); it is NOT classified as an identifier token\r\n    inside two separator tokens!\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Escape Sequences -->\r\n\r\n<a name=\"EscapeSequences\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Escape Sequences</b></td>\r\n<td width =\"80%\">\r\n  Sometimes you will see an <i>escape-sequence</i> inside the single-quotes\r\n    for a <i>character-literal</i> or one or more inside double-quotes for a\r\n    <i>string-literal</i> (see above);\r\n    each escape sequence is translated into a character that prints in some\r\n    \"special\" way.\r\n  Some commonly used escape sequences are\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr><th>Escape Sequence</th><th>Meaning</th>\r\n  </thead>\r\n  <tbody >\r\n  <tr><td><b>\\n</b></td><td><b>new line</b></td>\r\n  <tr><td><b>\\t</b></td><td><b>horizontal tab</b></td>\r\n  <tr><td><b>\\v</b></td><td><b>vertical tab</b></td>\r\n  <tr><td><b>\\b</b></td><td><b>backspace</b></td>\r\n  <tr><td><b>\\r</b></td><td><b>carriage return</b></td>\r\n  <tr><td><b>\\f</b></td><td><b>form feed</b></td>\r\n  <tr><td><b>\\a</b></td><td><b>bell</b></td>\r\n  <tr><td><b>\\\\</b></td><td><b>\\</b> (needed to denote \\ in a text literal)</td>\r\n  <tr><td><b>\\'</b></td><td><b>'</b> (does not act as the right <b>'</b> of a char literal)</td>\r\n  <tr><td><b>\\\"</b></td><td><b>\"</b> (does not act as the right <b>\"</b> of a String literal)</td>\r\n  </table>\r\n  <p>\r\n  So, in the <b>String</b> literal <b>\"He said, \\\"Hi.\\\"\"</b> neither escape\r\n    sequence <b>\\\"</b> acts to end the <b>String</b> literal: each represents\r\n    a double-quote that is part of the <b>String</b> literal, which displays\r\n    as <b>He said, \"Hi.\"</b>\r\n  <p>\r\n  If we output <b>\"Pack\\nage\"</b>, Java would print on the console<pre>Pack\r\nage</pre>\r\n  with the escape sequence <b>\\n</b> causing Java to immediately terminate the\r\n   current line and start at the beginning of a new line.\r\n  <p>\r\n  There are other ways in Java to write escape sequences (dealing with unicode\r\n    represented by octal numbers) that we will not cover here, nor need in the\r\n    course.\r\n  The only escape sequence that we wil use with any frequency is <b>\\n</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Null Literals -->\r\n\r\n<a name=\"NullLiteral\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The null Reference Literal</b></td>\r\n<td width =\"80%\">\r\n  There is a very simple, special kind of literal that is used to represent a\r\n    special value with every reference type in Java (so far we know only one,\r\n    the type <b>String</b>).\r\n  For completeness we will list it here, and learn about its use a bit later.\r\n  Its trivial EBNF rule is written\r\n  <p>\r\n  <i>null-literal</i> <= null \r\n  <p>\r\n  So, as we learned with <b>boolean</b> literals, <b>null</b> is a literal in\r\n    Java, not an identifier.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Bounded Numerics -->\r\n\r\n<a name=\"BoundedNumeric\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Bounded Numeric Types</b></td>\r\n<td width =\"80%\">\r\n  Although there are an infinite number of integers in mathematics, values in\r\n    the <b>int</b> type are limited to the range from -2,147,483,648 to\r\n    2,147,483,647.\r\n  We will explore this limitation later in the course, but for now we will not\r\n    worry about it.\r\n  <p>\r\n  Likewise, although there are an infinite number of reals in mathematics,\r\n    values in the <b>double</b> type are limited to the range from<br> \r\n    -1.79769313486231570x10<sup>308</sup>\r\n    to\r\n    1.79769313486231570x10<sup>308</sup>; the smallest non-zero, positive value\r\n    is\r\n    4.94065645841246544x10<sup>-324</sup>.\r\n  Values in this type can have up to about 15 significant digits.\r\n  For most engineering and science calculations, this range and precision are\r\n    adequate.\r\n  <p>\r\n  In fact, there are other primitive numeric types (which are also keywords):\r\n    <b>short</b>, <b>long</b>, and <b>float</b>.\r\n  These types are variants of <b>int</b> and <b>double</b> and are not as \r\n   widely useful as these more standard types, so we will not cover them in\r\n   this course.\r\n  <p>\r\n  Finally, there is a reference type named <b>BigInteger</b>, which can\r\n    represent any number of digits in an integer (up to the memory capacity of\r\n     the machine).\r\n  Such a type is very powerful (because it can represent any integer), but\r\n   costly to use (in execution time and computer space) compared to <b>int</b>.\r\n  Most programs can live with the \"small\" integer values specified above; but,\r\n    we will also study this reference type soon, and write programs using it.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Comments -->\r\n\r\n<a name=\"Comments\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Comments</b></td>\r\n<td width =\"80%\">\r\n  The sixth and final category of tokens is the <b>Comment</b>.\r\n  Comments allow us to place any form of documentation inside our Java code.\r\n  They can contain anything that we can type on the keyboard: English,\r\n    mathematics, even low-resolution pictures.\r\n  In general, Java recognizes comments as tokens, but then excludes these\r\n    tokens from further processing; technically, it treats them as white space\r\n    when it is forming tokens.\r\n  <p>\r\n  Comments help us capture aspects of our programs that cannot be expressed as\r\n     Java code.\r\n  Things like goals, specification, design structures, time/space tradeoffs,\r\n    historical information, advice for using/modifying this code, etc.\r\n  Programmers intensely study their own code (or the code of others) when\r\n     maintaining it  (testing, debugging or modifying it).\r\n  Good comments in code make all these tasks much easier.\r\n  <p>\r\n  Java includes two style for comments.\r\n  <ul>\r\n     <li>Line-Oriented: begins with <b>//</b> and continues until the end of\r\n           the line.\r\n     <li>Block-Oriented: begins with <b>/*</b> and continues (possibly over\r\n           many lines) until <b>*/</b> is reached. \r\n     <ul>\r\n       <li>So, we can use block-oriented comments to create multiple comments\r\n           within a line<br>\r\n           <b>&nbsp &nbsp display(/*Value*/ x, /*on device*/ d);</b><br>\r\n           In contrast, once a line-oriented comment starts, everything \r\n             afterward on its line is included in the comment.\r\n       <li>We can also use block-oriented comments to span multiple lines<br>\r\n           <b>/*<br>\r\n              &nbsp &nbsp This is a multi-line comment.<br>\r\n              &nbsp &nbsp No matter home many lines<br>\r\n              &nbsp &nbsp it includes, only one pair<br>\r\n              &nbsp &nbsp of delimiters are needed.<br>\r\n              */</b><br>\r\n           In contrast, a line-oriented comment stops at the end of the line\r\n             it starts on.\r\n     </ul>\r\n   </ul>     \r\n   Technically, both kinds of comments are treated as white space, so writing\r\n     <b>X/*comment*/Y</b> has the same meaning in Java as writing the tokens\r\n     <b>X</b> and <b>Y</b>, not the single token <b>XY</b>.\r\n   <p>\r\n   Typically Java comments are line-oriented; we will save block-oriented\r\n      comments for a special debugging purpose (discussed later).\r\n   <p>\r\n   The EBNF rule for comments is more complicated than insightful, so we will\r\n     not study here.\r\n   This happens once in a while.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Programs -->\r\n\r\n<a name=\"Programs\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Program are a Sequence of Tokens built from Characters</b></td>\r\n<td width =\"80%\">\r\n  The first phase, a Java compiler tokenizes a program by scanning its\r\n    characters left to right, top to bottom (there is a hidden end-of-line\r\n    character at the end of each line; recall that it is equivalent to white\r\n    space), and combining selected characters into tokens.\r\n  It works by repeating the following algorithm (an algorithm is a precise set\r\n    of instructions):\r\n  <ul>\r\n    <li>Skip any white space...\r\n    <li>...if the next character is an underscore, dollar, or alphabetic\r\n          character, it builds an identifier token.\r\n    <ul>\r\n      <li>Except for recognizing keywords and certain literals (<b>true</b>,\r\n            <b>false</b>, <b>null</b>) which all share the form of identifiers,\r\n            but are not themselves identifiers\r\n    </ul>\r\n    <li>...if the next character is a numeric character, ' or \", it builds a\r\n          literal token.\r\n    <li>...if the next character is a period, that is a seperator unless the\r\n          character after it is a numeric character (in which case it builds a\r\n           <b>double</b> literal).\r\n    <li>...if the next two characters are a // or /* starting a comment, it\r\n           builds a comment token.\r\n    <li>...if the next character is anything else, it builds a separator or\r\n          operator token (trying to build the longest token, given that white\r\n          space separates tokens, except in a <b>char</b> or <b>String</b>\r\n          literal).\r\n  </ul>\r\n  Recall that white space (except when inside a textual literal or comment)\r\n    separates tokens.\r\n  <p>\r\n  Also, the Java compiler uses the \"longest token rule\": it includes characters\r\n    in a token until it reaches a character that cannot be included.\r\n  <p>\r\n  Finally, after building and recognizing each token, the Java compiler passes\r\n    all tokens (except for comments, which are ignored after being tokenized)\r\n    on to the next phase of the compiler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Common Mistakes -->\r\n\r\n<a name=\"CommonMistakes\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Common Mistakes</b></td>\r\n<td width =\"80%\">\r\n  I have seen the following mistakes made repeatedly by beginning students\r\n    trying to tokenize programs.\r\n  Try to understand each of these subtle points.\r\n  <ul>\r\n    <li>Tokenizing <b>x</b> as a <b>char</b> literal: it is an identifier.\r\n    <li>Tokenizing <b>10.5</b> as two <b>int</b> literals separated by a\r\n          period: it is a <b>double</b> literal.\r\n    <li>Tokenizing <b>int</b> as a literal: it is a keyword, that happens to\r\n          name a type in Java.\r\n        Tokens like <b>1</b> are literals whose type is <b>int</b>; the token\r\n          <b>int</b> is a keyword.\r\n    <li>Tokenizing <b>\"Hi\"</b> as two <b>separator</b>s with the identifier\r\n          <b>Hi</b> in between: it is a single <b>String</b> literal.\r\n    <li>Tokenizing something like <b>};</b> as one separator token: it is\r\n          really two separate separators.\r\n    <li>Tokenizing something like <b>+=</b> as two separate operator tokens\r\n          (because <b>+</b> and <b>=</b> are operators): it is really one\r\n          large token (because <b>+=</b> is an operator).\r\n    <li>Forgetting to tokenize parentheses, semicolons, and other separators:\r\n          everything except white space belongs in some token.\r\n    <li>Creaing tokens inside comments: each comment is one big token that\r\n          includes all the characters in the comment.\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- A Simple Program -->\r\n\r\n<a name=\"SimpleProgram\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Simple Program</b></td>\r\n<td width =\"80%\">\r\n  The following program will serve as a model of Input/Calculate/Output\r\n     programs in Java.\r\n  Here are some highlights\r\n  <ul>\r\n    <li>A large, multi-line (oriented) comment appears at the top of the\r\n          program.\r\n        Line-oriented comments appear at various other locations in the\r\n           program.\r\n    <li>The <b>Prompt</b> class is imported from the\r\n           <b>edu.uci.ics.pattis.introlib</b> package.\r\n    <li>The <b>Application</b> class is declared.\r\n    <li>Its <b>main</b> method is declared; its body (the statements it\r\n          executes) is  placed between the <b>{</b> and <b>}</b> delimiters.\r\n    <li>Each simple statement in the body is ended by a semicolon (<b>;</b>)\r\n           separator.\r\n    <li>Three variables storing <b>double</b> values are declared.\r\n    <li>The user is prompted for the value to store in the first two variables.\r\n    <li>The third variable's value is computed and stored.\r\n    <li>The third variable's value is printed (after printing a blank line).\r\n  </ul>\r\n  Besides just reading this program, practice tokenzing it.\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\n<pre>\r\n//////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Description:\r\n//\r\n//   This program computes the time it take to drop an object (in a vacuum)\r\n// form an arbitrary height in an arbitrary gravitational field (so it can\r\n// be used to calculate drop times on other planets). It models a straight\r\n// input/calculate/output program: the user enters the gravitation field\r\n// and then the height; it calculates thd drop time and then prints in on\r\n// the console.\r\n//\r\n//////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nimport edu.uci.ics.pattis.introlib.Prompt;\r\n\r\n\r\npublic class Application {\r\n\r\n\r\n  public static void main(String[] args) {\r\n    double gravity;        //meter/sec/sec\r\n    double height;         //meters\r\n    double time;           //sec\r\n\t\t  \r\n\t\t  \r\n    //Input\r\n\t\t  \r\n    gravity = Prompt.forDouble(\"Enter gravitational acceleration (in meters/sec/sec)\");\r\n    height  = Prompt.forDouble(\"Enter height of drop (in meters)\");\r\n\t\t  \r\n\t\t  \r\n    //Calculate\r\n  \r\n    time = Math.sqrt(2.*height/gravity);\r\n\t\t  \r\n\t\t  \r\n    //Output\r\n\r\n    System.out.println(\"\\nDrop time = \" + time + \" secs\");\r\n  }\r\n}\r\n</pre>\r\n\r\n\r\n<!-- How Experts See Programs -->\r\n\r\n<a name=\"SeePrograms\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>How Experts See Programs</b></td>\r\n<td width =\"80%\">\r\n  In the 1940s, a Dutch psychologist named DeGroot was doing research on chess\r\n     experts.\r\n  He performed the following experiment: He sat chess experts down in front of\r\n    an empty chessboard, all the chess pieces, and a curtain.\r\n  Behind the curtain was a chessboard with its pieces arranged about 35 moves\r\n     into a game.\r\n  The curtain was raised for one minute and then lowered.\r\n  The chess experts were asked to reconstruct what they remembered from seeing\r\n    the chessboard behind the curtain.\r\n  <p>\r\n  In most cases, the chess experts were able to completely reconstruct the\r\n    board that they saw.\r\n  The same experiment was conducted with chess novices, but most were able to\r\n    remember only a few locations of the pieces. \r\n  These results could be interpreted as, \"Chess experts have much better\r\n     memories than novices.\"\r\n  <p>\r\n  So, DeGroot performed a second (similar) experiment.\r\n  In the second experiment, the board behind the curtain had the same number\r\n    of chess pieces, but they were randomly placed on the board; they did not\r\n    represent an ongoing game.\r\n  In this modified experiment, the chess experts did only marginally better\r\n    than the novices.\r\n  DeGroot's conclusion was that chess experts saw the board differently than\r\n    novices: they saw not only pieces, but attacking and defending structures,\r\n    board control, etc.\r\n  <p>\r\n  In this class, I am trying to teach you how to see programs as a programmer\r\n    sees them: not as a sequence of characters, but at a higher structural\r\n    level.\r\n  Tokens is where we start this process.\r\n  For another example on what the mind sees when it reads, look at the\r\n    following <a href=\"understanding.docx\">document</a>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, a Tutor,\r\n    or any other student.\r\n  <ol>\r\n    <li>Classify each of the following as a legal or illegal identifier.\r\n        If it is illegal, propose a legal identifier that can take its place\r\n        (a homophone or homoglyph)\r\n    <table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"all\" width =\"100%\">\r\n    <tbody > \r\n    <tr> <td><b>packAge</b></td>  <td><b>x12</b></td>  <td><b>2Lips</b></td>\r\n    <tr> <td><b>xOrY</b></td>      <td><b>sum of squares</b></td>  <td><b>%Raise</b></td>\r\n    <tr> <td><b>termInAte</b></td>  <td><b>u235</b></td>  <td><b>$Bill</b></td>\r\n    <tr> <td><b>x_1</b></td>  <td><b>x&Y</b></td>  <td><b>1derBoys</b></td>\r\n    </table>\r\n    <p>\r\n\r\n    <li> What tokens does Java build from the characters <b>ab=c+++d==e</b>.\r\n         Be sure that you know your <a href=\"#Operators\">Operators</a>.\r\n    <p>\r\n\r\n    <li>Classify each of the following numeric literals as <b>int</b>, or <b>double</b>, or\r\n       illegal (neither); write the equivalent value of each <b>double</b> without using \r\n       E notation; for each illegal literal, write a legal one with the \"same\" value.\r\n    <table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"all\" width =\"100%\">\r\n    <tbody > \r\n    <tr> <td><b>5.</b></td>  <td><b>3.1415</b></td>  <td><b>17</b></td>\r\n    <tr> <td><b>17.0</b></td>      <td><b>1E3</b></td>  <td><b>1.E3</b></td>\r\n    <tr> <td><b>.5E-3</b></td>  <td><b>5.4x10<sup>3</sup></b></td>  <td><b>50E-1</b></td>\r\n    <tr> <td><b>1,024</b></td>  <td><b>0.087</b></td>  <td><b>.087</b></td>\r\n    </table>\r\n    <p>\r\n\r\n    <li>What is the difference between <b>5</b>, <b>5.</b>, <b>five</b>, \r\n         <b>'5'</b>, and <b>\"5\"</b>?\r\n        What is the difference between <b>true</b> and <b>\"true\"</b>?\r\n    <p>\r\n\r\n    <li>Write a <b>String</b> literal that includes the characters\r\n        <b>I've said a million times, \"Do not exaggerate!\"</b>\r\n    <p>\r\n\r\n    <li> How does Java classify each of the following lines<br>\r\n    &nbsp &nbsp <b>\"//To be or not to be\"</b><br>\r\n    &nbsp &nbsp <b>//\"To be or not to be\"</b>\r\n    <p>\r\n\r\n    <li>Does the following line contain one comment or two?<br> \r\n    &nbsp &nbsp<b>//A comment //Another comment?</b>\r\n    <p>\r\n\r\n    <li>Explain whether <b>X/**/Y</b> is equivalent to <b>XY</b> or <b>X &nbsp Y</b>.\r\n    <p>\r\n\r\n    <li>Tokenize the following Java Code (be careful): <b>-15</b>\r\n    <p>\r\n\r\n    <li>Tokenize the following line of Java code: identify every Java token as either an \r\n        Identifier, Keyword, Separator, Operator, Literal (for any literal, also specify its type), or Comment.\r\n        Which (if any) identifiers are keywords?<br>\r\n        <tt><nobr>int X = Prompt.forInt(\"SSN\",0,999999999);  //Filter && use</nobr></tt>\r\n    <p>\r\n\r\n    <li>Choose an appropriate type to represent each of the following pieces of information\r\n      <ul>\r\n        <li>the number of characters in a file\r\n        <li>a time of day (accurate to 1 second)\r\n        <li>the middle initial in a name\r\n        <li>whether the left mouse button is currently pushed\r\n        <li>the position of a rotary switch (with 5 positions)\r\n        <li>the temperature of a blast furnace\r\n        <li>an indication of whether one quantity is less than, equal to or greater than another\r\n        <li>the name of a company\r\n      </ul>\r\n    <p>\r\n\r\n    <li>This problem (it is tricky, so do it carefully) shows a difficulty with using\r\n         Block-Oriented comments.\r\n        Tokenize the following two lines of Java code: identify every token as either an\r\n          Identifier, Keyword, Separator, Operator, Literal, or Comment. What problem arises?<br>\r\n<pre>  x = 0;  /* Initialize x and y to\r\n  y = 1;     their starting values */</pre>\r\n        Rewrite the code shown above with Line-Oriented comments instead, to avoid this problem.\r\n        How can our use of my Java preferences help us avoid this error?\r\n    <p>\r\n\r\n    <li>This problem (it is tricky, so do it carefully) shows another difficulty with using\r\n         Block-Oriented comments.\r\n        Tokenize the following Java code: identify every token as either an\r\n          Identifier, Keyword, Separator, Operator, Literal, or Comment. What problem arises?<br>\r\n        <pre>  /*\r\n    here is an outer\r\n    comment with an\r\n    /* inner comment inside */\r\n    and the finish of the outer\r\n    comment at the end\r\n  */</pre>\r\n        Rewrite the code shown above with Line-Oriented comments instead, to avoid this problem.\r\n        How can our use of my Java preferences help us avoid this error?\r\n\r\n    <p>\r\n\r\n    <li>Explain why language designers are very reluctant to add new keywords\r\n          to a programming language.\r\n        Hint: what problem might this cause in already-written programs?\r\n  </ol>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 30966.0}