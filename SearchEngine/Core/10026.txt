{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Inheritance and Polymorphism The moniker for this code example is InheritanceAndPolymorphism Background While C is not solely an object oriented programming language C is a language that decidedly supports it In C object oriented features are a tool that is available to you if you feel you need it to express your design better but not compulsory And importantly as with most features in C the object oriented features cost you nothing if you choose not to use them and in fact they don t cost you very much if you use them carefully So they are a good choice when they let you express your design more clearly It s often said that object oriented programming is characterized by three main features Classes which give you the ability to describe new kinds of objects which encapsulate a set of data along with a set of operations that safely manipulate that data Inheritance which gives you the ability to describe new classes that are extensions or updates of existing ones allowing you to write many similar classes without having to manually duplicate code between them Polymorphism which broadly gives you the ability to write code that can take on different meanings at run time depending on context Most notably in object oriented languages this means that calls to member functions on objects will be resolved in favor of the kind of object the function was called on In short when you ask a particular object to do a job the right thing happens automatically All three of these features are available in C We ve seen the first of these in some detail already This code example explores the other two An overview of inheritance in C We can introduce an inheritance relationship between two classes X and Y in which Y is said to be a derived class of X and in turn X is said to be a base class of Y The way you introduce that relationship is to describe it in the declaration of the derived class like this class X class Y public X The operator in this context can be read as derives from or inherits from The word public in this context means that the inheritance relationship is known throughout the program i e code anywhere in the program can make use of this fact while there are other ways to express inheritance relationships ours will be public more often than not so we ll reserve a conversation about other kinds until a later example Conceptually inheritance indicates what we often call an is a relationship i e a Y object is an X This concept makes more sense given a specific example like a Student class that inherits from Person in that case we would be saying logically that a Student is a Person which makes good conceptual sense Almost everything that s true of a person is also true of a student but students have additional qualities and are in certain ways different from other people Once this relationship is introduced in C it has a few effects The class Y automatically has all of the members e g member functions member variables declared in the class X except for constructors and destructors This is where the inheritance comes in Y is said to inherit these things from X so that we don t have to rewrite them in Y You can introduce additional members into Y different from the ones inherited from X by simply declaring them within Y s class declaration and separately defining them if necessary You can replace existing member functions inherited from X with new implementations that are specific to Y by re declaring them in Y s class declaration with the same signature as those inherited from X and then defining the new member function i e giving it a body This is called overriding one of X s member functions In short the class Y can be written primarily in terms of what makes it different from X rather than having to duplicate everything within X manually And what s more a change in the class X will have a corresponding automatic effect on the class Y An overview of polymorphism in C Given the relationship between the classes X and Y above certain things become legal and certain others become illegal In general the fact that a Y is an X is respected by the compiler and manifests itself in the ways you might expect given that basic philosophy First of all we ll be able to declare and define objects of each of these classes X and Y X x Y y These are both legal since X and Y are both classes We ll assume that these classes both have constructors that take no arguments which would be required in order for those statements to be legal We ll also be able to dynamically allocate objects of both classes and point like typed pointers to them as you would with any other class X px new X Y py new Y And similarly we ll be able to use like typed references to refer to these objects I m assuming all of the code in this section is part of the same function X rx x Y ry y So far there haven t been any surprises The more interesting effects come when we mix types in cases like these Assigning objects of one type into variables of different but related types Using pointers or references of one type to point refer to objects of different but related types Given a pointer or reference of one type pointing referring to an object of a different type and calling one of its member functions Slice assignment Our first attempt at mixing types is to assign or copy construct a value of one type into a variable of a related type Consider these possibilities again assuming that the code earlier in this section has already executed Y y2 x X x2 y Which of these do we expect will be legal Let s consider them in turn We should expect that assigning x into y2 will fail because an X object does not contain enough information to properly initialize a Y object Or spoken more simply X s aren t necessarily kinds of Y s On the other hand we should expect that assigning y into x2 could succeed Based on the notion of inheritance as an is a relationship a Y is an X Y objects are kinds of X s so it makes at least some sense that it should be possible to assign a Y object into an X variable It does bring up an interesting question though What happens An X object is only big enough to store all of the member variables declared in the X class A Y object is bigger assuming that it contains additional member variables in addition to the ones inherited from X The answer is what s called slicing The member variables that Y inherited from X would be copied into the variable x2 while the others would be sliced away i e they would be lost Notably when all is said and done in this case x2 contains an X object not a Y object albeit one that was sliced from a Y originally Using pointers and references to mix types Pointers and references make for some more interesting behavior Which of these do we expect will be legal X xx Y yy X rxx yy Y ryy xx X px new X Y py new Y X px2 py Y py2 px The answer lies in the basic philosophical assumption that a Y is an X We expect in general that X pointers and X references can legally point to objects that are X s But because of the inheritance relationship between the two classes Y s are X s So we can reasonably expect X pointers and X references to be able to point to Y objects However we don t expect the reverse to be true An X is not necessarily a Y so we don t expect to be able to point Y pointers or Y references to X objects If we have a pointer of one type pointing to an object of a different type we have another interesting question to consider Suppose that the following member function is declared in both X and Y i e Y has a version that overrides the version from X class X public void foo class Y public X public void foo Given the declarations above what do we expect will happen in these cases rxx foo px2 foo There are two possibilities X s version of foo will be called because the pointer and reference have type X Y s version of foo will be called because the objects are actually Y objects Which of these possibilities holds true depends on how the foo function is declared The latter behavior determining the version based on the type of the object is an example of what s called polymorphism where the same pointer might be used to call different versions of foo at run time depending on the kind of object the pointer points to But polymorphism has a run time cost i e the cost of looking up the appropriate version of the function at run time based on the type of the object so this behavior is not the default in C You have to opt in on a member function by member function basis by declaring particular member functions to be virtual We declare a member function to be virtual by putting the keyword virtual at the beginning of its signature in the class declaration class X public virtual void foo class Y public X public virtual void foo Note that declaring foo to be a virtual function in the class X automatically makes it virtual in all of the classes derived from X though it s still useful from a code readability standpoint to carry that declaration down into Y as well If foo is virtual then our calls to foo using rxx and px2 will both call Y s version of foo If foo is not virtual then they would call X s version i e the version corresponding to the pointer s or reference s type instead The code This code example demonstrates many of the principles behind inheritance and polymorphism using the Person and Student classes that we wrote in lecture The official moniker for this code example is InheritanceAndPolymorphism so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code InheritanceAndPolymorphism to download the code example into your project directory s src directory Alternatively you can click the link to the tarball below InheritanceAndPolymorphism tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/InheritanceAndPolymorphism/", "title": "ics 45c fall 2014, code example: inheritance and polymorphism", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Inheritance and Polymorphism</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Inheritance and Polymorphism</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>InheritanceAndPolymorphism</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>While C++ is not solely an object-oriented programming language, C++ is a language that decidedly supports it.  In C++, object-oriented features are a tool that is available to you if you feel you need it to express your design better, but not compulsory.  And, importantly, as with most features in C++, the object-oriented features cost you nothing if you choose not to use them &mdash; and, in fact, they don't cost you very much if you use them carefully.  So they are a good choice when they let you express your design more clearly.</p>\r\n\r\n<p>It's often said that object-oriented programming is characterized by three main features:</p>\r\n\r\n<ul>\r\n  <li><i>Classes</i>, which give you the ability to describe new kinds of objects, which encapsulate a set of data along with a set of operations that safely manipulate that data.</li>\r\n  <li><i>Inheritance</i>, which gives you the ability to describe new classes that are extensions or updates of existing ones, allowing you to write many similar classes without having to manually duplicate code between them.</li>\r\n  <li><i>Polymorphism</i>, which, broadly, gives you the ability to write code that can take on different meanings at run-time depending on context.  Most notably, in object-oriented languages, this means that calls to member functions on objects will be resolved in favor of the kind of object the function was called on.  (In short, when you ask a particular object to do a job, the \"right thing\" happens automatically.)</li>\r\n</ul>\r\n\r\n<p>All three of these features are available in C++.  We've seen the first of these in some detail already.  This code example explores the other two.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">An overview of inheritance in C++</p>\r\n\r\n<p>We can introduce an inheritance relationship between two classes X and Y, in which Y is said to be a <i>derived class</i> of X and, in turn, X is said to be a <i>base class</i> of Y.  The way you introduce that relationship is to describe it in the declaration of the derived class, like this:</p>\r\n\r\n<blockquote><pre>\r\nclass X { ... };\r\n\r\nclass Y : public X { ... };\r\n</pre></blockquote>\r\n\r\n<p>The <b>:</b> operator in this context can be read as <i>derives from</i> or <i>inherits from</i>.  The word <b>public</b> in this context means that the inheritance relationship is known throughout the program (i.e., code anywhere in the program can make use of this fact); while there are other ways to express inheritance relationships, ours will be public more often than not, so we'll reserve a conversation about other kinds until a later example.</p>\r\n\r\n<p>Conceptually, inheritance indicates what we often call an <i>is a</i> relationship (i.e., a Y object <i>is an</i> X).  This concept makes more sense given a specific example, like a Student class that inherits from Person; in that case, we would be saying logically that \"a Student is a Person,\" which makes good conceptual sense.  Almost everything that's true of a person is also true of a student, but students have additional qualities and are in certain ways different from other people.</p>\r\n\r\n<p>Once this relationship is introduced in C++, it has a few effects:</p>\r\n\r\n<ul>\r\n  <li>The class Y automatically has all of the members &mdash; e.g., member functions, member variables &mdash; declared in the class X, <i>except</i> for constructors and destructors.  This is where the \"inheritance\" comes in: Y is said to <i>inherit</i> these things from X, so that we don't have to rewrite them in Y.</li>\r\n  <li>You can introduce additional members into Y, different from the ones inherited from X, by simply declaring them within Y's class declaration (and separately defining them, if necessary).</li>\r\n  <li>You can replace existing member functions inherited from X with new implementations that are specific to Y, by re-declaring them in Y's class declaration with the same signature as those inherited from X, and then defining the new member function (i.e., giving it a body).  This is called <i>overriding</i> one of X's member functions.</li>\r\n</ul>\r\n\r\n<p>In short, the class Y can be written primarily in terms of what makes it different from X, rather than having to duplicate everything within X manually.  And, what's more, a change in the class X will have a corresponding, automatic effect on the class Y.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">An overview of polymorphism in C++</p>\r\n\r\n<p>Given the relationship between the classes X and Y above, certain things become legal and certain others become illegal.  In general, the fact that \"a Y is an X\" is respected by the compiler, and manifests itself in the ways you might expect, given that basic philosophy.</p>\r\n\r\n<p>First of all, we'll be able to declare and define objects of each of these classes, X and Y.</p>\r\n\r\n<blockquote><pre>\r\nX x;\r\nY y;\r\n</pre></blockquote>\r\n\r\n<p>These are both legal, since X and Y are both classes.  (We'll assume that these classes both have constructors that take no arguments, which would be required in order for those statements to be legal.)</p>\r\n\r\n<p>We'll also be able to dynamically allocate objects of both classes and point like-typed pointers to them, as you would with any other class.</p>\r\n\r\n<blockquote><pre>\r\nX* px = new X;\r\nY* py = new Y;\r\n</pre></blockquote>\r\n\r\n<p>And, similarly, we'll be able to use like-typed references to refer to these objects.  (I'm assuming all of the code in this section is part of the same function.)</p>\r\n\r\n<blockquote><pre>\r\nX& rx = x;\r\nY& ry = y;\r\n</pre></blockquote>\r\n\r\n<p>So far, there haven't been any surprises.  The more interesting effects come when we mix types, in cases like these:</p>\r\n\r\n<ul>\r\n  <li>Assigning objects of one type into variables of different, but related, types.</li>\r\n  <li>Using pointers or references of one type to point/refer to objects of different, but related, types.</li>\r\n  <li>Given a pointer or reference of one type, pointing/referring to an object of a different type, and calling one of its member functions.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Slice assignment</p>\r\n\r\n<p>Our first attempt at mixing types is to assign (or copy construct) a value of one type into a variable of a related type.  Consider these possibilities, again assuming that the code earlier in this section has already executed.</p>\r\n\r\n<blockquote><pre>\r\nY y2 = x;\r\nX x2 = y;\r\n</pre></blockquote>\r\n\r\n<p>Which of these do we expect will be legal?  Let's consider them in turn:</p>\r\n\r\n<ul>\r\n  <li>We should expect that assigning <b>x</b> into <b>y2</b> will fail, because an <b>X</b> object does not contain enough information to properly initialize a <b>Y</b> object.  Or, spoken more simply, <b>X</b>'s aren't necessarily kinds of <b>Y</b>'s.</li>\r\n  <li>On the other hand, we should expect that assigning <b>y</b> into <b>x2</b> could succeed.  Based on the notion of inheritance as an \"is a\" relationship, \"a Y is an X.\"  <b>Y</b> objects are kinds of <b>X</b>'s, so it makes at least some sense that it should be possible to assign a <b>Y</b> object into an <b>X</b> variable.\r\n    <ul>\r\n      <li>It does bring up an interesting question, though.  What happens?  An <b>X</b> object is only big enough to store all of the member variables declared in the <b>X</b> class.  A <b>Y</b> object is bigger, assuming that it contains additional member variables (in addition to the ones inherited from <b>X</b>).  The answer is what's called <i>slicing</i>.  The member variables that <b>Y</b> inherited from <b>X</b> would be copied into the variable <b>x2</b>, while the others would be \"sliced away\" (i.e., they would be lost).</li>\r\n      <li>Notably, when all is said and done in this case, <b>x2</b> contains an <b>X</b> object, not a <b>Y</b> object, albeit one that was \"sliced\" from a <b>Y</b> originally.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Using pointers and references to mix types</p>\r\n\r\n<p>Pointers and references make for some more interesting behavior.  Which of these do we expect will be legal?</p>\r\n\r\n<blockquote><pre>\r\nX xx;\r\nY yy;\r\nX& rxx = yy;\r\nY& ryy = xx;\r\nX* px = new X;\r\nY* py = new Y;\r\nX* px2 = py;\r\nY* py2 = px;\r\n</pre></blockquote>\r\n\r\n<p>The answer lies in the basic philosophical assumption that \"a Y is an X.\"  We expect, in general, that <b>X</b> pointers and <b>X</b> references can legally point to objects that are <b>X</b>'s.  But, because of the inheritance relationship between the two classes, <b>Y</b>'s are <b>X</b>'s.  So we can reasonably expect <b>X</b> pointers and <b>X</b> references to be able to point to <b>Y</b> objects.</p>\r\n\r\n<p>However, we don't expect the reverse to be true.  An <b>X</b> is not necessarily a <b>Y</b>, so we don't expect to be able to point <b>Y</b> pointers or <b>Y</b> references to <b>X</b> objects.</p>\r\n\r\n<p>If we have a pointer of one type pointing to an object of a different type, we have another interesting question to consider.  Suppose that the following member function is declared in both <b>X</b> and <b>Y</b> (i.e., <b>Y</b> has a version that overrides the version from <b>X</b>).</p>\r\n\r\n<blockquote><pre>\r\nclass X\r\n{\r\npublic:\r\n    void foo();\r\n};\r\n\r\nclass Y : public X\r\n{\r\npublic:\r\n    void foo();\r\n};\r\n</pre></blockquote>\r\n\r\n<p>Given the declarations above, what do we expect will happen in these cases?</p>\r\n\r\n<blockquote><pre>\r\nrxx.foo();\r\npx2-&gt;foo();\r\n</pre></blockquote>\r\n\r\n<p>There are two possibilities.</p>\r\n\r\n<ul>\r\n  <li><b>X</b>'s version of <b>foo()</b> will be called, because the pointer and reference have type <b>X</b>.</li>\r\n  <li><b>Y</b>'s version of <b>foo()</b> will be called, because the objects are actually <b>Y</b> objects.</li>\r\n</ul>\r\n\r\n<p>Which of these possibilities holds true depends on how the <b>foo()</b> function is declared.  The latter behavior &mdash; determining the version based on the type of the object &mdash; is an example of what's called <i>polymorphism</i>, where the same pointer might be used to call different versions of <b>foo()</b> at run time, depending on the kind of object the pointer points to.</p>\r\n\r\n<p>But polymorphism has a run-time cost (i.e., the cost of looking up the appropriate version of the function at run time, based on the type of the object), so this behavior is not the default in C++.  You have to opt in, on a member-function-by-member-function basis, by declaring particular member functions to be <i>virtual</i>.  We declare a member function to be virtual by putting the keyword <b>virtual</b> at the beginning of its signature in the class declaration.</p>\r\n\r\n<blockquote><pre>\r\nclass X\r\n{\r\npublic:\r\n    virtual void foo();\r\n};\r\n\r\nclass Y : public X\r\n{\r\npublic:\r\n    virtual void foo();\r\n};\r\n</pre></blockquote>\r\n\r\n<p>Note that declaring <b>foo()</b> to be a virtual function in the class <b>X</b> automatically makes it virtual in all of the classes derived from <b>X</b>, though it's still useful, from a code readability standpoint, to carry that declaration down into <b>Y</b>, as well.</p>\r\n\r\n<p>If <b>foo()</b> is virtual, then our calls to <b>foo()</b> using <b>rxx</b> and <b>px2</b> will both call <b>Y</b>'s version of <b>foo()</b>.  If <b>foo()</b> is not virtual, then they would call <b>X</b>'s version (i.e., the version corresponding to the pointer's or reference's type) instead.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>This code example demonstrates many of the principles behind inheritance and polymorphism using the Person and Student classes that we wrote in lecture.</p>\r\n\r\n<p>The official moniker for this code example is <b>InheritanceAndPolymorphism</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code InheritanceAndPolymorphism</b> to download the code example into your project directory's <b>src</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"InheritanceAndPolymorphism.tar.gz\">InheritanceAndPolymorphism.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 10026.0}