{"text": "View Javadoc 1 2 Created on Mar 5 2 5 3 4 5 package edu uci isr impromptu repository 6 7 import java io InputStream 8 import java io OutputStream 9 import java util Enumeration 1 import java util HashMap 11 import java util Map 12 13 import javax jmdns ServiceInfo 14 import javax servlet http HttpServletRequest 15 import javax servlet http HttpServletResponse 16 17 import org apache commons httpclient Header 18 import org apache commons httpclient HostConfiguration 19 import org apache commons httpclient HttpClient 2 import org apache commons httpclient HttpMethod 21 import org apache commons httpclient HttpMethodBase 22 import org apache commons httpclient HttpRecoverableException 23 import org apache commons httpclient UsernamePasswordCredentials 24 import org apache commons httpclient methods DeleteMethod 25 import org apache commons httpclient methods EntityEnclosingMethod 26 import org apache commons httpclient methods GetMethod 27 import org apache commons httpclient methods HeadMethod 28 import org apache commons httpclient methods OptionsMethod 29 import org apache commons httpclient methods PostMethod 3 import org apache commons httpclient methods PutMethod 31 import org apache commons httpclient methods TraceMethod 32 import org apache commons logging Log 33 import org apache commons logging LogFactory 34 import org apache slide webdav util AclConstants 35 import org apache slide webdav util BindConstants 36 import org apache slide webdav util DaslConstants 37 import org apache slide webdav util DeltavConstants 38 import org apache slide webdav util WebdavConstants 39 import org apache webdav lib methods AclMethod 4 import org apache webdav lib methods BindMethod 41 import org apache webdav lib methods CheckinMethod 42 import org apache webdav lib methods CheckoutMethod 43 import org apache webdav lib methods CopyMethod 44 import org apache webdav lib methods DepthSupport 45 import org apache webdav lib methods HttpRequestBodyMethodBase 46 import org apache webdav lib methods LabelMethod 47 import org apache webdav lib methods LockMethod 48 import org apache webdav lib methods MkWorkspaceMethod 49 import org apache webdav lib methods MkcolMethod 5 import org apache webdav lib methods MoveMethod 51 import org apache webdav lib methods PollMethod 52 import org apache webdav lib methods PropFindMethod 53 import org apache webdav lib methods PropPatchMethod 54 import org apache webdav lib methods RebindMethod 55 import org apache webdav lib methods ReportMethod 56 import org apache webdav lib methods SearchMethod 57 import org apache webdav lib methods SubscribeMethod 58 import org apache webdav lib methods UnbindMethod 59 import org apache webdav lib methods UncheckoutMethod 6 import org apache webdav lib methods UnlockMethod 61 import org apache webdav lib methods UnsubscribeMethod 62 import org apache webdav lib methods UpdateMethod 63 import org apache webdav lib methods VersionControlMethod 64 import org apache webdav lib methods XMLResponseMethodBase 65 import org mortbay http EOFException 66 import org mortbay http HttpFields 67 import org w3c dom Document 68 69 import edu uci isr impromptu common Peer 7 import edu uci isr impromptu common Utils 71 import edu uci isr impromptu security SecurityConstants 72 import edu uci isr impromptu security SlideUserRealm 73 74 75 RepositoryPeer represents each peer either the local one or a remote one 76 77 author Jie Ren 78 79 public class RepositoryPeer implements Peer 8 private static Log log LogFactory getLog RepositoryPeer class 81 82 83 Create an empty peer 84 85 86 public RepositoryPeer 87 if log null 88 89 9 91 the serviceInfo through which this peer is created 92 private ServiceInfo theServiceInfo 93 information collected from the service info 94 private String name 95 private String hostAddress localhost 96 private int port 97 private HttpClient client new HttpClient 98 private HostConfiguration target new HostConfiguration 99 1 files owned by this peer the key is the name the value is the sharing level 1 1 We now use a secure by default principle Any file probably created by 1 2 other apps including those temporary files are hidden This means others 1 3 cannot dir them and even we can dir them should we we will still not see them in the pie 1 4 Here we assume dir is a lower level see than the pie or actually a propatch 1 5 even just level is more visible than no properties at all 1 6 A file remains hidden until they are explictly shared by dragging in the pie 1 7 to either the private level or other higher levels Only these files are returned to others 1 8 private Map ownedFiles new HashMap 1 9 11 111 Create a peer based on service information received from JmDNS 112 param theServiceInfo the seviceInfo that describes the peer 113 param remoteUserName the user name to use for the remote peer 114 param password the password to use for the remote peer 115 116 public RepositoryPeer ServiceInfo theServiceInfo String remoteUserName String password 117 theServiceInfo theServiceInfo 118 name theServiceInfo getName 119 String host theServiceInfo getHostAddress 12 if host null host equals 121 when we first add ourselves directly the host address is not resolved yet 122 hostAddress host 123 port theServiceInfo getPort 124 target setHost hostAddress port 125 client setHostConfiguration target 126 TODO security protocol because of this secret maybe we can use mobile code 127 so downloaded entity controls a real secret that the host cannot steal 128 and make another research architectural story 129 TODO security architecture ownedFiles is maintained by events but 13 how does it bootstrap Here we do a pull of PROPFIND maybe we can use 131 some fancy mobile code to download the current state 132 client getState setCredentials SlideUserRealm REALM NAME hostAddress 133 new UsernamePasswordCredentials remoteUserName password 134 this remoteUserName remoteUserName 135 this password password 136 137 138 139 Get the service information received from JmDNS 14 return the service inforamtion 141 142 public ServiceInfo getServiceInfo 143 return theServiceInfo 144 145 146 147 Get the name of the peer for use in a more human readable manner 148 return the name of the peer 149 15 public String getName 151 return name 152 153 154 155 get the host address of the peer 156 return the host address of the peer 157 158 public String getHostAddress 159 return hostAddress 16 161 162 163 get the port of the peer 164 return the port 165 166 public int getPort 167 return port 168 169 17 private String password 171 private String remoteUserName 172 173 Get the remote user name 174 return the remote user name 175 176 public String getRemoteUserName 177 return remoteUserName 178 179 18 181 Get the password 182 return the password 183 184 public String getPassword 185 return password 186 187 188 189 The peer has added a file 19 191 param fileName the name of the newly added file 192 param radius the relative radius between and 1 of the newly added file 193 This might be null if another application creates the file 194 param angle the relative angle between and 1 of the newly added file 195 This might be null if another application creates the file 196 return true if there was not such a file false otherwise 197 198 public boolean fileAdded String fileName double radius double angle 199 if radius angle 2 return addFile fileName Utils getSharingLevelFromRelativeRadius radius 2 1 2 2 2 3 2 4 Add a file to the owned file list 2 5 2 6 param fileName the name of the newly added file 2 7 param sharingLevel the sharing level of this file 2 8 return true if there was not such a file false otherwise 2 9 21 public boolean addFile String fileName int sharingLevel 211 boolean result true 212 if ownedFiles containsKey fileName 213 ownedFiles put fileName new Integer sharingLevel 214 result false 215 216 return result 217 218 219 22 The peer has moved a file 221 222 param fileName the name of the newly moved file 223 param radius the new relative radius between and 1 of the newly added file 224 param angle the new relative angle between and 1 of the newly added file 225 return true if there was not such a file false otherwise 226 227 public boolean fileMoved String fileName double radius double angle 228 if radius angle 229 boolean result false 23 recalculate and update sharing level in ownedFiles map in case it has changed 231 if ownedFiles containsKey fileName 232 int sharingLevel Utils getSharingLevelFromRelativeRadius radius 233 ownedFiles put fileName new Integer sharingLevel 234 result true 235 236 return result 237 238 239 24 The peer has removed a file 241 242 param fileName the name of the newly removed file 243 return true if there was a file false otherwise 244 245 public boolean fileRemoved String fileName 246 boolean result ownedFiles containsKey fileName 247 if result 248 ownedFiles remove fileName 249 25 return result 251 252 253 254 Whether the peer owns a file 255 param fileName the name of the file 256 return true if the peer owns it and has not suspended the ownership of it 257 false if it does not own it or it has temporarily suspended the ownership 258 259 public boolean owns String fileName 26 return ownedFiles containsKey fileName isSuspended fileName 261 262 263 public Map getOwnedFiles 264 return ownedFiles 265 266 267 268 Files that are temporarily suspended 269 27 private Map suspendedFiles new HashMap 271 272 Suspend a file so this peer no longer claims ownership 273 param fileName the file name to suspend 274 param newOwner the new temporary owner of the file 275 276 public void suspendFile String fileName RepositoryPeer newOwner 277 suspendedFiles put fileName newOwner 278 newOwner grabFile fileName this 279 28 281 282 Is a file suspended 283 param fileName the name of the file 284 return true if the file is suspended 285 286 public boolean isSuspended String fileName 287 return suspendedFiles containsKey fileName 288 289 29 291 Resume the ownership of a file 292 param fileName the name of the file 293 294 public void resumeFile String fileName 295 suspendedFiles remove fileName 296 297 298 299 Files that are temporarily owned grabbed 3 3 1 private Map grabbedFiles new HashMap 3 2 3 3 Claim a file for temporary ownership 3 4 param fileName the file temporarily owned 3 5 param originalOwner the original owner 3 6 3 7 public void grabFile String fileName RepositoryPeer originalOwner 3 8 grabbedFiles put fileName originalOwner 3 9 31 311 312 Is a file grabbed 313 param fileName the name of the file 314 return the original owner if the file is grabbed null if the file is not grabbed 315 316 public RepositoryPeer isGrabbed String fileName 317 return RepositoryPeer grabbedFiles get fileName 318 319 32 321 Release the ownership of a file 322 param fileName the file name 323 return the original owner of this file 324 325 public RepositoryPeer releaseFile String fileName 326 return RepositoryPeer grabbedFiles remove fileName 327 328 329 33 Whether the local peer shares a file 331 param fileName the name of the file 332 return true if the local peer shares the file 333 false if the local peer does not share it 334 335 public boolean isShared String fileName 336 When a file is just stored in the local peer but should not be noticeable 337 to others this method returns false This is not a security problem 338 since this is just to make PROPFIND do what it is supposed to do Even 339 a malicious user gets the name he can not do anything than other security 34 constraints would allow him to do 341 342 boolean result false 343 Integer sharedDegree Integer ownedFiles get fileName 344 if sharedDegree null 345 if sharedDegree intValue SecurityConstants LEVEL PRIVATE 346 result true 347 348 349 return result 35 351 352 353 Whether the local peer imports the file into the private space 354 param fileName the name of the file 355 return true if the file is in the private space false otherwise 356 357 public boolean isPrivate String fileName 358 boolean result false 359 Integer sharedDegree Integer ownedFiles get fileName 36 if sharedDegree null 361 if sharedDegree intValue SecurityConstants LEVEL PRIVATE 362 result true 363 364 365 return result 366 367 368 369 Execute a request towards this remote peer It is invoked by the filter 37 to direct the request to an owner peer This method executes a HttpClient 371 call and forward the response back to the original client This extra 372 round trip affects performance 373 param request the original request 374 param response the original response 375 param forward if true then the response from the method will be 376 forwarded to the original response 377 param identifySelf whether the method should add a header to identify itself 378 return the response body of the execution can be either a string or a XML document 379 38 public Object service HttpServletRequest request HttpServletResponse response 381 boolean forward boolean identifySelf 382 clear credentials 383 client getState setCredentials SlideUserRealm REALM NAME hostAddress null 384 385 Object responseBody null 386 HttpMethodBase method null 387 388 try 389 When A is already up and B joins 1 A s repository needs to add B to its allowed 39 others and 2 B s pie needs to get the files from A 1 should happen 391 before 2 but if 2 happens before 1 maybe because of JmDNS resolution 392 then 2 will receive many 4 1 errors A retry should solve the problem 393 An unsuccessful mountDrive seems causing problematic delays here 394 A message ACTION ADD PEER is added to control the pie s fetching 395 whether to issue the message is an admission control policy Violtaing 396 the policy fetching without permission will not breach the security 397 boolean done false 398 int maxRetry 3 399 int retry 4 4 1 while done retry maxRetry 4 2 try 4 3 create a HttpClient method based on the request 4 4 HttpClient should have a factory method for this 4 5 TODO protocol long delay in LOCK after GET 4 6 method createMethod request 4 7 4 8 should identify self 4 9 if identifySelf 41 method addRequestHeader Configuration IMPROMPTU HEADER NAME 411 Configuration IMPROMPTU HEADER VALUE 412 413 414 Execute the method 415 client executeMethod method 416 done true 417 418 catch HttpRecoverableException hre 419 if hre getMessage indexOf Maximum redirects 1 42 try 421 Thread sleep 5 422 423 catch InterruptedException e 424 425 retry 426 427 else 428 throw hre 429 43 431 432 433 forward the response 434 if forward 435 forwardResponse method response 436 if method instanceof XMLResponseMethodBase 437 responseBody XMLResponseMethodBase method getResponseDocument 438 439 else 44 responseBody method getResponseBodyAsString 441 442 443 catch Exception e 444 Here rarely it comes with narrowly avoided infinite loop exception 445 It looks like the JmDNS resolves a peer to a wrong address to which 446 our correct password is just wrong After many 4 1 retrials the 447 method gives up Since this is a JmDNS infrastructure problem we will 448 not address it and use a restart as a workaround 449 The scenario is when A and B is up and C joins sometimes A s 45 JmDNS resolves C s name into B s address and result in an infinite 451 redirection This seems happening when C is a Windows 2 3 machine 452 or A is a Mac machine 453 Utils handleException e 454 455 finally 456 Release the connection 457 method releaseConnection 458 459 46 return responseBody 461 462 463 464 Create a method that can be executed later based on a servelet request 465 param request the servelet request 466 return a method that encapsulates information from this request 467 468 private HttpMethodBase createMethod HttpServletRequest request 469 HttpMethodBase method null 47 String methodName request getMethod toUpperCase 471 472 HTTP RFC 2616 473 if methodName equals WebdavConstants M OPTIONS 474 method new OptionsMethod 475 476 else if methodName equals WebdavConstants M GET 477 method new GetMethod 478 479 else if methodName equals WebdavConstants M HEAD 48 method new HeadMethod 481 482 else if methodName equals WebdavConstants M POST 483 method new PostMethod 484 485 else if methodName equals WebdavConstants M PUT 486 method new PutMethod 487 488 else if methodName equals WebdavConstants M DELETE 489 method new DeleteMethod 49 491 else if methodName equals WebdavConstants M TRACE 492 method new TraceMethod 493 494 else if methodName equals WebdavConstants M CONNECT 495 This constructor is not available in httpclient 2 496 method new ConnectMethod 497 498 499 WebDAV RFC 2518 5 else if methodName equals WebdavConstants M PROPFIND 5 1 method new PropFindMethod 5 2 5 3 else if methodName equals WebdavConstants M PROPPATCH 5 4 method new PropPatchMethod 5 5 5 6 else if methodName equals WebdavConstants M MKCOL 5 7 method new MkcolMethod 5 8 5 9 else if methodName equals WebdavConstants M COPY 51 method new CopyMethod 511 512 else if methodName equals WebdavConstants M MOVE 513 method new MoveMethod 514 515 else if methodName equals WebdavConstants M LOCK 516 method new LockMethod 517 518 else if methodName equals WebdavConstants M UNLOCK 519 method new UnlockMethod 52 521 WebDAV Redirect not on client side 522 else if methodName equals MKREDIRECTREF 523 method new MkredirectrefMethod 524 525 526 WebDAV ACL RFC 3744 527 else if methodName equals AclConstants M ACL 528 method new AclMethod 529 53 531 Methods below are not well tested in Impromptu 532 DeltaV RFC 3253 533 else if methodName equals DeltavConstants M REPORT 534 method new ReportMethod 535 536 else if methodName equals DeltavConstants M VERSION CONTROL 537 method new VersionControlMethod 538 539 else if methodName equals DeltavConstants M CHECKIN 54 method new CheckinMethod 541 542 else if methodName equals DeltavConstants M CHECKOUT 543 method new CheckoutMethod 544 545 else if methodName equals DeltavConstants M UNCHECKOUT 546 method new UncheckoutMethod 547 548 else if methodName equals DeltavConstants M MKWORKSPACE 549 method new MkWorkspaceMethod 55 551 else if methodName equals DeltavConstants M LABEL 552 method new LabelMethod 553 554 else if methodName equals DeltavConstants M UPDATE 555 method new UpdateMethod 556 557 558 DASL Search 559 else if methodName equals DaslConstants M SEARCH 56 method new SearchMethod 561 562 563 BIND 564 else if methodName equals BindConstants M BIND 565 method new BindMethod 566 567 else if methodName equals BindConstants M UNBIND 568 method new UnbindMethod 569 57 else if methodName equals BindConstants M REBIND 571 method new RebindMethod 572 573 574 Microsoft Exchange extensions 575 else if methodName equals SUBSCRIBE 576 method new SubscribeMethod 577 578 else if methodName equals UNSUBSCRIBE 579 method new UnsubscribeMethod 58 581 else if methodName equals POLL 582 method new PollMethod 583 584 else if methodName equals EVENT 585 method new EventMethod 586 587 588 unknown method 589 else 59 return null 591 592 try 593 method setPath request getRequestURI 594 595 Copy headers from the request 596 Enumeration headerNames request getHeaderNames 597 while headerNames hasMoreElements 598 String headerName String headerNames nextElement 599 boolean processed false whether the header has been processed 6 Slide Webdav Client s Lock method only catches Lock Token 6 1 through setRequestHeader It expects Lock Token has been set 6 2 during the following addRequestHeader 6 3 if headerName equalsIgnoreCase Lock Token 6 4 method setRequestHeader headerName 6 5 request getHeader headerName 6 6 processed true 6 7 6 8 Do not copy the auhtorization header which comes from a pie 6 9 Use our shared password with the remote peer 61 if headerName equalsIgnoreCase Authorization 611 TODO security delegate here we do a blind credentials 612 delegation We should check whether the credentials 613 provided meet what we have 614 processed true 615 616 if processed 617 Enumeration headers request getHeaders headerName 618 while headers hasMoreElements 619 String headerValue String headers nextElement 62 method addRequestHeader headerName headerValue 621 622 623 624 625 handle depth header specially 626 because webdav lib ignores our previous setting of Depth 627 if method instanceof DepthSupport 628 try 629 if request getIntHeader Depth 1 63 DepthSupport method setDepth request getIntHeader Depth 631 632 catch NumberFormatException nfe 633 634 635 636 handle the timeout header for lock specially 637 if method instanceof LockMethod 638 LockMethod lm LockMethod method 639 int myTimeout 18 64 if lm getTimeout LockMethod TIMEOUT INFINITY 641 http support microsoft com default aspx scid kb en us 832161 642 http mailman lyra org pipermail dav dev 2 2 October 4 98 html 643 http www greenbytes de tech webdav webfolder client list html issue lock timeout 644 Office XP 2 3 bypasses the redirector and does its own WebDAV Office 645 2K uses the redirector if one is available 646 Then Office XP 2 3 does not recognize infinite timeout response for LOCK 647 and thinks it can only open the file as read only 648 Slide LockMethod always issues a timeout header with LOCK and the 649 default value for it is infinite 65 Thus we must set a more normal time out value if it has not been set 651 lm setTimeout myTimeout 652 653 654 655 656 if method instanceof ExpectContinueMethod 657 security architecture security changes protocol address based basic 658 authentication are easy to proxy since they will not change and 659 can be sent primtively Digest authentication needs a 66 challenge response handshake and httpclient makes this somewhat 661 awarkward because the request body cannot be reread much like 662 the servlet request body cannot be reread 663 664 about when to use this header 665 http www mail archive com commons httpclient dev jakarta apache org msg 6723 html 666 about container quirks 667 http www mail archive com commons httpclient dev jakarta apache org msg 6743 html 668 about clone method 669 http www mail archive com commons httpclient dev jakarta apache org msg 12 6 html 67 ExpectContinueMethod method setUseExpectHeader true 671 672 673 674 copy body from the request 675 if method instanceof EntityEnclosingMethod 676 From HttpClient library 677 EntityEnclosingMethod bodyMethod EntityEnclosingMethod method 678 httpclient 3 679 InputStreamRequestEntity isre new InputStreamRequestEntity 68 request getInputStream request getContentLength 681 request getContentType 682 bodyMethod setRequestEntity isre 683 684 bodyMethod setRequestHeader Content Type request getContentType 685 bodyMethod setRequestContentLength request getContentLength 686 Had setUseExpectHeader worked with Jetty who automatically emits a continue 687 we would not need to use this to trigger buffering the content 688 bodyMethod setRequestContentLength EntityEnclosingMethod CONTENT LENGTH AUTO 689 bodyMethod setRequestBody request getInputStream 69 691 else if method instanceof HttpRequestBodyMethodBase 692 From Slide WebDAV client library 693 HttpRequestBodyMethodBase bodyMethod HttpRequestBodyMethodBase method 694 bodyMethod setRequestBody request getInputStream 695 696 697 catch Exception e 698 Utils handleException e 699 7 7 1 return method 7 2 7 3 7 4 7 5 Forward the response from the execution of a method to a servlet 7 6 param method the method that has been executed 7 7 param response the servlet response to which the execution should be reported 7 8 7 9 private void forwardResponse HttpMethod method HttpServletResponse response 71 clear the existing response stuff if it would work 711 response reset 712 713 Jetty makes us do this 714 response setHeader HttpFields CacheControl null 715 response setHeader HttpFields Connection null 716 response setHeader HttpFields Date null 717 response setHeader HttpFields Pragma null 718 response setHeader HttpFields ProxyConnection null 719 response setHeader HttpFields Trailer null 72 response setHeader HttpFields TransferEncoding null 721 response setHeader HttpFields Upgrade null 722 response setHeader HttpFields Via null 723 response setHeader HttpFields Warning null 724 response setHeader HttpFields Allow null 725 response setHeader HttpFields ContentEncoding null 726 response setHeader HttpFields ContentLanguage null 727 response setHeader HttpFields ContentLength null 728 response setHeader HttpFields ContentLocation null 729 response setHeader HttpFields ContentMD5 null 73 response setHeader HttpFields ContentRange null 731 response setHeader HttpFields ContentType null 732 response setHeader HttpFields Expires null 733 response setHeader HttpFields LastModified null 734 response setHeader HttpFields Accept null 735 response setHeader HttpFields AcceptCharset null 736 response setHeader HttpFields AcceptEncoding null 737 response setHeader HttpFields AcceptLanguage null 738 response setHeader HttpFields Authorization null 739 response setHeader HttpFields Expect null 74 response setHeader HttpFields Forwarded null 741 response setHeader HttpFields From null 742 response setHeader HttpFields Host null 743 response setHeader HttpFields IfMatch null 744 response setHeader HttpFields IfModifiedSince null 745 response setHeader HttpFields IfNoneMatch null 746 response setHeader HttpFields IfRange null 747 response setHeader HttpFields IfUnmodifiedSince null 748 response setHeader HttpFields KeepAlive null 749 response setHeader HttpFields MaxForwards null 75 response setHeader HttpFields ProxyAuthorization null 751 response setHeader HttpFields Range null 752 response setHeader HttpFields RequestRange null 753 response setHeader HttpFields Referer null 754 response setHeader HttpFields TE null 755 response setHeader HttpFields UserAgent null 756 response setHeader HttpFields XForwardedFor null 757 response setHeader HttpFields AcceptRanges null 758 response setHeader HttpFields Age null 759 response setHeader HttpFields ETag null 76 response setHeader HttpFields Location null 761 response setHeader HttpFields ProxyAuthenticate null 762 response setHeader HttpFields RetryAfter null 763 response setHeader HttpFields Server null 764 response setHeader HttpFields ServletEngine null 765 response setHeader HttpFields Vary null 766 response setHeader HttpFields WwwAuthenticate null 767 response setHeader HttpFields Cookie null 768 response setHeader HttpFields SetCookie null 769 response setHeader HttpFields SetCookie2 null 77 response setHeader HttpFields MimeVersion null 771 response setHeader HttpFields Identity null 772 response setHeader HttpFields SoapAction null 773 774 boolean buffered false 775 int bufferSize x1 776 if method instanceof GetMethod 777 System getProperty os name indexOf Mac 1 778 This gets the whole content and buffers it 779 byte body method getResponseBody 78 if body null 781 buffered true 782 bufferSize body length 783 784 785 response setBufferSize bufferSize 786 787 set status which is different than header 788 response setStatus method getStatusCode 789 79 copy headers 791 Header headers method getResponseHeaders 792 for int i i headers length i 793 794 response setHeader headers i getName headers i getValue 795 796 797 copy body 798 try 799 InputStream in method getResponseBodyAsStream 8 OutputStream out response getOutputStream 8 1 byte buffer new byte 2 48 8 2 int len 8 3 int written 8 4 if in null 8 5 while len in read buffer buffer length 1 8 6 try 8 7 out write buffer len 8 8 written len 8 9 81 catch Exception se 811 if se instanceof EOFException buffered 812 ignore this exception for GET method on Mac 813 The Mac DavFS client switches to another socket 814 Let Jetty handle it 815 816 else 817 Utils handleException se 818 819 82 821 in close 822 823 else if method instanceof XMLResponseMethodBase 824 Slide WebDAV lib methods do not fill ResponseBodyAsStream 825 Document d XMLResponseMethodBase method getResponseDocument 826 response might be empty even for a so called XMLResponseMethodBase 827 if d null 828 RepositoryUtils writeXMLResponse d out 829 83 out flush 831 out close 832 833 catch Exception e 834 Utils handleException e 835 836 837 This page was automatically generated by Maven", "_id": "http://drzaius.ics.uci.edu/~swirl/impromptu-0.30/xref/edu/uci/isr/impromptu/repository/RepositoryPeer.html", "title": "repositorypeer xref", "html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=ISO-8859-1\" /><title>RepositoryPeer xref</title>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"../../../../../stylesheet.css\" />\n</head>\n<body>\n<div id=\"overview\"><a href=\"../../../../../../apidocs/edu/uci/isr/impromptu/repository/RepositoryPeer.html\">View Javadoc</a></div><pre>\n\n<a name=\"1\" href=\"#1\">1</a>   <em class=\"comment\">/*</em>\n<a name=\"2\" href=\"#2\">2</a>   <em class=\"comment\"> * Created on Mar 5, 2005</em>\n<a name=\"3\" href=\"#3\">3</a>   <em class=\"comment\"> *</em>\n<a name=\"4\" href=\"#4\">4</a>   <em class=\"comment\"> */</em>\n<a name=\"5\" href=\"#5\">5</a>   <strong>package</strong> <a href=\"../../../../../edu/uci/isr/impromptu/repository/package-summary.html\">edu.uci.isr.impromptu.repository</a>;\n<a name=\"6\" href=\"#6\">6</a>   \n<a name=\"7\" href=\"#7\">7</a>   <strong>import</strong> java.io.InputStream;\n<a name=\"8\" href=\"#8\">8</a>   <strong>import</strong> java.io.OutputStream;\n<a name=\"9\" href=\"#9\">9</a>   <strong>import</strong> java.util.Enumeration;\n<a name=\"10\" href=\"#10\">10</a>  <strong>import</strong> java.util.HashMap;\n<a name=\"11\" href=\"#11\">11</a>  <strong>import</strong> java.util.Map;\n<a name=\"12\" href=\"#12\">12</a>  \n<a name=\"13\" href=\"#13\">13</a>  <strong>import</strong> javax.jmdns.ServiceInfo;\n<a name=\"14\" href=\"#14\">14</a>  <strong>import</strong> javax.servlet.http.HttpServletRequest;\n<a name=\"15\" href=\"#15\">15</a>  <strong>import</strong> javax.servlet.http.HttpServletResponse;\n<a name=\"16\" href=\"#16\">16</a>  \n<a name=\"17\" href=\"#17\">17</a>  <strong>import</strong> org.apache.commons.httpclient.Header;\n<a name=\"18\" href=\"#18\">18</a>  <strong>import</strong> org.apache.commons.httpclient.HostConfiguration;\n<a name=\"19\" href=\"#19\">19</a>  <strong>import</strong> org.apache.commons.httpclient.HttpClient;\n<a name=\"20\" href=\"#20\">20</a>  <strong>import</strong> org.apache.commons.httpclient.HttpMethod;\n<a name=\"21\" href=\"#21\">21</a>  <strong>import</strong> org.apache.commons.httpclient.HttpMethodBase;\n<a name=\"22\" href=\"#22\">22</a>  <strong>import</strong> org.apache.commons.httpclient.HttpRecoverableException;\n<a name=\"23\" href=\"#23\">23</a>  <strong>import</strong> org.apache.commons.httpclient.UsernamePasswordCredentials;\n<a name=\"24\" href=\"#24\">24</a>  <strong>import</strong> org.apache.commons.httpclient.methods.DeleteMethod;\n<a name=\"25\" href=\"#25\">25</a>  <strong>import</strong> org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n<a name=\"26\" href=\"#26\">26</a>  <strong>import</strong> org.apache.commons.httpclient.methods.GetMethod;\n<a name=\"27\" href=\"#27\">27</a>  <strong>import</strong> org.apache.commons.httpclient.methods.HeadMethod;\n<a name=\"28\" href=\"#28\">28</a>  <strong>import</strong> org.apache.commons.httpclient.methods.OptionsMethod;\n<a name=\"29\" href=\"#29\">29</a>  <strong>import</strong> org.apache.commons.httpclient.methods.PostMethod;\n<a name=\"30\" href=\"#30\">30</a>  <strong>import</strong> org.apache.commons.httpclient.methods.PutMethod;\n<a name=\"31\" href=\"#31\">31</a>  <strong>import</strong> org.apache.commons.httpclient.methods.TraceMethod;\n<a name=\"32\" href=\"#32\">32</a>  <strong>import</strong> org.apache.commons.logging.Log;\n<a name=\"33\" href=\"#33\">33</a>  <strong>import</strong> org.apache.commons.logging.LogFactory;\n<a name=\"34\" href=\"#34\">34</a>  <strong>import</strong> org.apache.slide.webdav.util.AclConstants;\n<a name=\"35\" href=\"#35\">35</a>  <strong>import</strong> org.apache.slide.webdav.util.BindConstants;\n<a name=\"36\" href=\"#36\">36</a>  <strong>import</strong> org.apache.slide.webdav.util.DaslConstants;\n<a name=\"37\" href=\"#37\">37</a>  <strong>import</strong> org.apache.slide.webdav.util.DeltavConstants;\n<a name=\"38\" href=\"#38\">38</a>  <strong>import</strong> org.apache.slide.webdav.util.WebdavConstants;\n<a name=\"39\" href=\"#39\">39</a>  <strong>import</strong> org.apache.webdav.lib.methods.AclMethod;\n<a name=\"40\" href=\"#40\">40</a>  <strong>import</strong> org.apache.webdav.lib.methods.BindMethod;\n<a name=\"41\" href=\"#41\">41</a>  <strong>import</strong> org.apache.webdav.lib.methods.CheckinMethod;\n<a name=\"42\" href=\"#42\">42</a>  <strong>import</strong> org.apache.webdav.lib.methods.CheckoutMethod;\n<a name=\"43\" href=\"#43\">43</a>  <strong>import</strong> org.apache.webdav.lib.methods.CopyMethod;\n<a name=\"44\" href=\"#44\">44</a>  <strong>import</strong> org.apache.webdav.lib.methods.DepthSupport;\n<a name=\"45\" href=\"#45\">45</a>  <strong>import</strong> org.apache.webdav.lib.methods.HttpRequestBodyMethodBase;\n<a name=\"46\" href=\"#46\">46</a>  <strong>import</strong> org.apache.webdav.lib.methods.LabelMethod;\n<a name=\"47\" href=\"#47\">47</a>  <strong>import</strong> org.apache.webdav.lib.methods.LockMethod;\n<a name=\"48\" href=\"#48\">48</a>  <strong>import</strong> org.apache.webdav.lib.methods.MkWorkspaceMethod;\n<a name=\"49\" href=\"#49\">49</a>  <strong>import</strong> org.apache.webdav.lib.methods.MkcolMethod;\n<a name=\"50\" href=\"#50\">50</a>  <strong>import</strong> org.apache.webdav.lib.methods.MoveMethod;\n<a name=\"51\" href=\"#51\">51</a>  <strong>import</strong> org.apache.webdav.lib.methods.PollMethod;\n<a name=\"52\" href=\"#52\">52</a>  <strong>import</strong> org.apache.webdav.lib.methods.PropFindMethod;\n<a name=\"53\" href=\"#53\">53</a>  <strong>import</strong> org.apache.webdav.lib.methods.PropPatchMethod;\n<a name=\"54\" href=\"#54\">54</a>  <strong>import</strong> org.apache.webdav.lib.methods.RebindMethod;\n<a name=\"55\" href=\"#55\">55</a>  <strong>import</strong> org.apache.webdav.lib.methods.ReportMethod;\n<a name=\"56\" href=\"#56\">56</a>  <strong>import</strong> org.apache.webdav.lib.methods.SearchMethod;\n<a name=\"57\" href=\"#57\">57</a>  <strong>import</strong> org.apache.webdav.lib.methods.SubscribeMethod;\n<a name=\"58\" href=\"#58\">58</a>  <strong>import</strong> org.apache.webdav.lib.methods.UnbindMethod;\n<a name=\"59\" href=\"#59\">59</a>  <strong>import</strong> org.apache.webdav.lib.methods.UncheckoutMethod;\n<a name=\"60\" href=\"#60\">60</a>  <strong>import</strong> org.apache.webdav.lib.methods.UnlockMethod;\n<a name=\"61\" href=\"#61\">61</a>  <strong>import</strong> org.apache.webdav.lib.methods.UnsubscribeMethod;\n<a name=\"62\" href=\"#62\">62</a>  <strong>import</strong> org.apache.webdav.lib.methods.UpdateMethod;\n<a name=\"63\" href=\"#63\">63</a>  <strong>import</strong> org.apache.webdav.lib.methods.VersionControlMethod;\n<a name=\"64\" href=\"#64\">64</a>  <strong>import</strong> org.apache.webdav.lib.methods.XMLResponseMethodBase;\n<a name=\"65\" href=\"#65\">65</a>  <strong>import</strong> org.mortbay.http.EOFException;\n<a name=\"66\" href=\"#66\">66</a>  <strong>import</strong> org.mortbay.http.HttpFields;\n<a name=\"67\" href=\"#67\">67</a>  <strong>import</strong> org.w3c.dom.Document;\n<a name=\"68\" href=\"#68\">68</a>  \n<a name=\"69\" href=\"#69\">69</a>  <strong>import</strong> edu.uci.isr.impromptu.common.Peer;\n<a name=\"70\" href=\"#70\">70</a>  <strong>import</strong> edu.uci.isr.impromptu.common.Utils;\n<a name=\"71\" href=\"#71\">71</a>  <strong>import</strong> edu.uci.isr.impromptu.security.SecurityConstants;\n<a name=\"72\" href=\"#72\">72</a>  <strong>import</strong> edu.uci.isr.impromptu.security.SlideUserRealm;\n<a name=\"73\" href=\"#73\">73</a>  \n<a name=\"74\" href=\"#74\">74</a>  <em>/**<em>*</em></em>\n<a name=\"75\" href=\"#75\">75</a>  <em> * RepositoryPeer represents each peer, either the local one or a remote one. </em>\n<a name=\"76\" href=\"#76\">76</a>  <em> * </em>\n<a name=\"77\" href=\"#77\">77</a>  <em> * @author Jie Ren</em>\n<a name=\"78\" href=\"#78\">78</a>  <em> */</em>\n<a name=\"79\" href=\"#79\">79</a>  <strong>public</strong> <strong>class</strong> <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a> implements <a href=\"../../../../../edu/uci/isr/impromptu/common/Peer.html\">Peer</a> {\n<a name=\"80\" href=\"#80\">80</a>      <strong>private</strong> <strong>static</strong> Log \t\tlog = LogFactory.getLog(RepositoryPeer.<strong>class</strong>);\n<a name=\"81\" href=\"#81\">81</a>  \n<a name=\"82\" href=\"#82\">82</a>      <em>/**<em>*</em></em>\n<a name=\"83\" href=\"#83\">83</a>  <em>     * Create an empty peer</em>\n<a name=\"84\" href=\"#84\">84</a>  <em>     *</em>\n<a name=\"85\" href=\"#85\">85</a>  <em>     */</em>\n<a name=\"86\" href=\"#86\">86</a>      <strong>public</strong> <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a>() {\n<a name=\"87\" href=\"#87\">87</a>          <strong>if</strong> (log != <strong>null</strong>) {\n<a name=\"88\" href=\"#88\">88</a>          }\n<a name=\"89\" href=\"#89\">89</a>      }\n<a name=\"90\" href=\"#90\">90</a>      \n<a name=\"91\" href=\"#91\">91</a>      <em class=\"comment\">// the serviceInfo through which this peer is created</em>\n<a name=\"92\" href=\"#92\">92</a>      <strong>private</strong>\t\tServiceInfo\t\ttheServiceInfo;\n<a name=\"93\" href=\"#93\">93</a>      <em class=\"comment\">// information collected from the service info</em>\n<a name=\"94\" href=\"#94\">94</a>      <strong>private</strong> \tString\t\tname;\n<a name=\"95\" href=\"#95\">95</a>      <strong>private</strong>\t\tString\t\thostAddress = <span class=\"string\">\"localhost\"</span>;\n<a name=\"96\" href=\"#96\">96</a>      <strong>private</strong> \t<strong>int</strong>\t\t\tport;\n<a name=\"97\" href=\"#97\">97</a>      <strong>private</strong> \tHttpClient \tclient = <strong>new</strong> HttpClient();\n<a name=\"98\" href=\"#98\">98</a>      <strong>private</strong>\t\tHostConfiguration target = <strong>new</strong> HostConfiguration();\n<a name=\"99\" href=\"#99\">99</a>  \n<a name=\"100\" href=\"#100\">100</a>     <em class=\"comment\">// files owned by this peer, the key is the name, the value is the sharing level</em>\n<a name=\"101\" href=\"#101\">101</a>     <em class=\"comment\">// We now use a \"secure by default\" principle. Any file, probably created by </em>\n<a name=\"102\" href=\"#102\">102</a>     <em class=\"comment\">// \tother apps, including those temporary files, are hidden. This means others</em>\n<a name=\"103\" href=\"#103\">103</a>     <em class=\"comment\">//  cannot dir them, and even we can dir them (should we?), we will still not see them in the pie.</em>\n<a name=\"104\" href=\"#104\">104</a>     <em class=\"comment\">//\tHere, we assume dir is a lower-level see than the pie, or actually a propatch, </em>\n<a name=\"105\" href=\"#105\">105</a>     <em class=\"comment\">//  even just level 0, is more visible than no properties at all. </em>\n<a name=\"106\" href=\"#106\">106</a>     <em class=\"comment\">// A file remains hidden until they are explictly shared by dragging in the pie, </em>\n<a name=\"107\" href=\"#107\">107</a>     <em class=\"comment\">//\tto either the private level or other higher levels. Only these files are returned to others. </em>\n<a name=\"108\" href=\"#108\">108</a>     <strong>private</strong>\t\tMap\t\t\townedFiles = <strong>new</strong> HashMap(); \n<a name=\"109\" href=\"#109\">109</a>     \n<a name=\"110\" href=\"#110\">110</a>     <em>/**<em>*</em></em>\n<a name=\"111\" href=\"#111\">111</a> <em>     * Create a peer based on service information received from JmDNS</em>\n<a name=\"112\" href=\"#112\">112</a> <em>     * @param _theServiceInfo the seviceInfo that describes the peer</em>\n<a name=\"113\" href=\"#113\">113</a> <em>     * @param remoteUserName\tthe user name to use for the remote peer</em>\n<a name=\"114\" href=\"#114\">114</a> <em>     * @param password\t\t\tthe password to use for the remote peer</em>\n<a name=\"115\" href=\"#115\">115</a> <em>     */</em>\n<a name=\"116\" href=\"#116\">116</a>     <strong>public</strong> <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a>(ServiceInfo _theServiceInfo, String remoteUserName, String password) {\n<a name=\"117\" href=\"#117\">117</a>         theServiceInfo = _theServiceInfo;\n<a name=\"118\" href=\"#118\">118</a>         name = theServiceInfo.getName();\n<a name=\"119\" href=\"#119\">119</a>         String\thost = theServiceInfo.getHostAddress(); \n<a name=\"120\" href=\"#120\">120</a>         <strong>if</strong> (host != <strong>null</strong> &amp;&amp; !host.equals(<span class=\"string\">\"\"</span>))\n<a name=\"121\" href=\"#121\">121</a>             <em class=\"comment\">// when we first add ourselves directly, the host address is not resolved yet</em>\n<a name=\"122\" href=\"#122\">122</a>             hostAddress = host;\n<a name=\"123\" href=\"#123\">123</a>         port = theServiceInfo.getPort();\n<a name=\"124\" href=\"#124\">124</a>         target.setHost(hostAddress, port);\n<a name=\"125\" href=\"#125\">125</a>         client.setHostConfiguration(target);\n<a name=\"126\" href=\"#126\">126</a>         <em class=\"comment\">// TODO: security: protocol: because of this secret, maybe we can use mobile code</em>\n<a name=\"127\" href=\"#127\">127</a>         <em class=\"comment\">//\tso downloaded entity controls a real secret that the host cannot steal,</em>\n<a name=\"128\" href=\"#128\">128</a>         <em class=\"comment\">//\tand make another research architectural story.</em>\n<a name=\"129\" href=\"#129\">129</a>         <em class=\"comment\">// TODO: security: architecture: ownedFiles is maintained by events, but </em>\n<a name=\"130\" href=\"#130\">130</a>         <em class=\"comment\">//\thow does it bootstrap? Here we do a pull of PROPFIND, maybe we can use </em>\n<a name=\"131\" href=\"#131\">131</a>         <em class=\"comment\">//  some fancy mobile code to download the current state. </em>\n<a name=\"132\" href=\"#132\">132</a>         client.getState().setCredentials(SlideUserRealm.REALM_NAME, hostAddress,\n<a name=\"133\" href=\"#133\">133</a>                 <strong>new</strong> UsernamePasswordCredentials(remoteUserName, password));\n<a name=\"134\" href=\"#134\">134</a>         <strong>this</strong>.remoteUserName = remoteUserName;\n<a name=\"135\" href=\"#135\">135</a>         <strong>this</strong>.password = password;\n<a name=\"136\" href=\"#136\">136</a>     }\n<a name=\"137\" href=\"#137\">137</a>     \n<a name=\"138\" href=\"#138\">138</a>     <em>/**<em>*</em></em>\n<a name=\"139\" href=\"#139\">139</a> <em>     * Get the service information received from JmDNS</em>\n<a name=\"140\" href=\"#140\">140</a> <em>     * @return the service inforamtion</em>\n<a name=\"141\" href=\"#141\">141</a> <em>     */</em>\n<a name=\"142\" href=\"#142\">142</a>     <strong>public</strong> ServiceInfo\tgetServiceInfo() {\n<a name=\"143\" href=\"#143\">143</a>         <strong>return</strong> theServiceInfo;\n<a name=\"144\" href=\"#144\">144</a>     }\n<a name=\"145\" href=\"#145\">145</a>     \n<a name=\"146\" href=\"#146\">146</a>     <em>/**<em>*</em></em>\n<a name=\"147\" href=\"#147\">147</a> <em>     * Get the name of the peer, for use in a more human readable manner </em>\n<a name=\"148\" href=\"#148\">148</a> <em>     * @return the name of the peer</em>\n<a name=\"149\" href=\"#149\">149</a> <em>     */</em>\n<a name=\"150\" href=\"#150\">150</a>     <strong>public</strong> String getName() {\n<a name=\"151\" href=\"#151\">151</a>         <strong>return</strong> name;\n<a name=\"152\" href=\"#152\">152</a>     }\n<a name=\"153\" href=\"#153\">153</a> \n<a name=\"154\" href=\"#154\">154</a>     <em>/**<em>*</em></em>\n<a name=\"155\" href=\"#155\">155</a> <em>     * get the host address of the peer</em>\n<a name=\"156\" href=\"#156\">156</a> <em>     * @return the host address of the peer</em>\n<a name=\"157\" href=\"#157\">157</a> <em>     */</em>\n<a name=\"158\" href=\"#158\">158</a>     <strong>public</strong> String getHostAddress() {\n<a name=\"159\" href=\"#159\">159</a>         <strong>return</strong> hostAddress;\n<a name=\"160\" href=\"#160\">160</a>     }\n<a name=\"161\" href=\"#161\">161</a>     \n<a name=\"162\" href=\"#162\">162</a>     <em>/**<em>*</em></em>\n<a name=\"163\" href=\"#163\">163</a> <em>     * get the port of the peer</em>\n<a name=\"164\" href=\"#164\">164</a> <em>     * @return the port</em>\n<a name=\"165\" href=\"#165\">165</a> <em>     */</em>\n<a name=\"166\" href=\"#166\">166</a>     <strong>public</strong> <strong>int</strong>  getPort() {\n<a name=\"167\" href=\"#167\">167</a>         <strong>return</strong> port;\n<a name=\"168\" href=\"#168\">168</a>     }\n<a name=\"169\" href=\"#169\">169</a> \n<a name=\"170\" href=\"#170\">170</a>     <strong>private</strong>\tString\tpassword = <span class=\"string\">\"\"</span>;\n<a name=\"171\" href=\"#171\">171</a>     <strong>private</strong> String  remoteUserName = <span class=\"string\">\"\"</span>;\n<a name=\"172\" href=\"#172\">172</a>     <em>/**<em>*</em></em>\n<a name=\"173\" href=\"#173\">173</a> <em>     * Get the remote user name </em>\n<a name=\"174\" href=\"#174\">174</a> <em>     * @return the remote user name</em>\n<a name=\"175\" href=\"#175\">175</a> <em>     */</em>\n<a name=\"176\" href=\"#176\">176</a>     <strong>public</strong> String getRemoteUserName() {\n<a name=\"177\" href=\"#177\">177</a>         <strong>return</strong> remoteUserName;\n<a name=\"178\" href=\"#178\">178</a>     }\n<a name=\"179\" href=\"#179\">179</a>     \n<a name=\"180\" href=\"#180\">180</a>     <em>/**<em>*</em></em>\n<a name=\"181\" href=\"#181\">181</a> <em>     * Get the password </em>\n<a name=\"182\" href=\"#182\">182</a> <em>     * @return the password</em>\n<a name=\"183\" href=\"#183\">183</a> <em>     */</em>\n<a name=\"184\" href=\"#184\">184</a>     <strong>public</strong> String\tgetPassword() {\n<a name=\"185\" href=\"#185\">185</a>         <strong>return</strong> password;\n<a name=\"186\" href=\"#186\">186</a>     }\n<a name=\"187\" href=\"#187\">187</a>     \n<a name=\"188\" href=\"#188\">188</a>     <em>/**<em>*</em></em>\n<a name=\"189\" href=\"#189\">189</a> <em>     * The peer has added a file</em>\n<a name=\"190\" href=\"#190\">190</a> <em>     * </em>\n<a name=\"191\" href=\"#191\">191</a> <em>     * @param fileName the name of the newly added file</em>\n<a name=\"192\" href=\"#192\">192</a> <em>     * @param radius the relative radius (between 0 and 1) of the newly added file. </em>\n<a name=\"193\" href=\"#193\">193</a> <em>     * \t\tThis might be null if another application creates the file</em>\n<a name=\"194\" href=\"#194\">194</a> <em>     * @param angle the relative angle (between 0 and 1) of the newly added file.</em>\n<a name=\"195\" href=\"#195\">195</a> <em>     * \t\tThis might be null if another application creates the file</em>\n<a name=\"196\" href=\"#196\">196</a> <em>     * @return true if there was not such a file, false otherwise</em>\n<a name=\"197\" href=\"#197\">197</a> <em>     */</em>\n<a name=\"198\" href=\"#198\">198</a>     <strong>public</strong> <strong>boolean</strong> fileAdded(String fileName, <strong>double</strong> radius, <strong>double</strong> angle) {\n<a name=\"199\" href=\"#199\">199</a>         <strong>if</strong>(radius!=angle);\n<a name=\"200\" href=\"#200\">200</a>         <strong>return</strong> addFile(fileName, Utils.getSharingLevelFromRelativeRadius(radius));\n<a name=\"201\" href=\"#201\">201</a>     }\n<a name=\"202\" href=\"#202\">202</a>     \n<a name=\"203\" href=\"#203\">203</a>     <em>/**<em>*</em></em>\n<a name=\"204\" href=\"#204\">204</a> <em>     * Add a file to the owned file list.</em>\n<a name=\"205\" href=\"#205\">205</a> <em>     * </em>\n<a name=\"206\" href=\"#206\">206</a> <em>     * @param fileName \t\tthe name of the newly added file</em>\n<a name=\"207\" href=\"#207\">207</a> <em>     * @param sharingLevel\tthe sharing level of this file</em>\n<a name=\"208\" href=\"#208\">208</a> <em>     * @return true if there was not such a file, false otherwise</em>\n<a name=\"209\" href=\"#209\">209</a> <em>     */</em>\n<a name=\"210\" href=\"#210\">210</a>     <strong>public</strong> <strong>boolean</strong> addFile(String fileName, <strong>int</strong> sharingLevel) {\n<a name=\"211\" href=\"#211\">211</a>         <strong>boolean</strong> result = <strong>true</strong>;\n<a name=\"212\" href=\"#212\">212</a>         <strong>if</strong> (!ownedFiles.containsKey(fileName)) {\n<a name=\"213\" href=\"#213\">213</a>             ownedFiles.put(fileName, <strong>new</strong> Integer(sharingLevel));\n<a name=\"214\" href=\"#214\">214</a>             result = false;\n<a name=\"215\" href=\"#215\">215</a>         }\n<a name=\"216\" href=\"#216\">216</a>         <strong>return</strong> result;\n<a name=\"217\" href=\"#217\">217</a>     }\n<a name=\"218\" href=\"#218\">218</a>     \n<a name=\"219\" href=\"#219\">219</a>     <em>/**<em>*</em></em>\n<a name=\"220\" href=\"#220\">220</a> <em>     * The peer has moved a file</em>\n<a name=\"221\" href=\"#221\">221</a> <em>     * </em>\n<a name=\"222\" href=\"#222\">222</a> <em>     * @param fileName the name of the newly moved file</em>\n<a name=\"223\" href=\"#223\">223</a> <em>     * @param radius the new relative radius (between 0 and 1) of the newly added file</em>\n<a name=\"224\" href=\"#224\">224</a> <em>     * @param angle the new relative angle (between 0 and 1) of the newly added file</em>\n<a name=\"225\" href=\"#225\">225</a> <em>     * @return true if there was not such a file, false otherwise</em>\n<a name=\"226\" href=\"#226\">226</a> <em>     */</em>\n<a name=\"227\" href=\"#227\">227</a>     <strong>public</strong> <strong>boolean</strong> fileMoved(String fileName, <strong>double</strong> radius, <strong>double</strong> angle) {\n<a name=\"228\" href=\"#228\">228</a>         <strong>if</strong>(radius!=angle);\n<a name=\"229\" href=\"#229\">229</a>         <strong>boolean</strong> result = false;\n<a name=\"230\" href=\"#230\">230</a>         <em class=\"comment\">// recalculate and update sharing level in ownedFiles map in case it has changed</em>\n<a name=\"231\" href=\"#231\">231</a>         <strong>if</strong> (ownedFiles.containsKey(fileName)) {\n<a name=\"232\" href=\"#232\">232</a>         \t<strong>int</strong> sharingLevel = Utils.getSharingLevelFromRelativeRadius(radius);\n<a name=\"233\" href=\"#233\">233</a>             ownedFiles.put(fileName, <strong>new</strong> Integer(sharingLevel));\n<a name=\"234\" href=\"#234\">234</a>             result = <strong>true</strong>;\n<a name=\"235\" href=\"#235\">235</a>         }\n<a name=\"236\" href=\"#236\">236</a>         <strong>return</strong> result;\n<a name=\"237\" href=\"#237\">237</a>     }\n<a name=\"238\" href=\"#238\">238</a>     \n<a name=\"239\" href=\"#239\">239</a>     <em>/**<em>*</em></em>\n<a name=\"240\" href=\"#240\">240</a> <em>     * The peer has removed a file</em>\n<a name=\"241\" href=\"#241\">241</a> <em>     * </em>\n<a name=\"242\" href=\"#242\">242</a> <em>     * @param fileName the name of the newly removed file</em>\n<a name=\"243\" href=\"#243\">243</a> <em>     * @return true if there was a file, false otherwise</em>\n<a name=\"244\" href=\"#244\">244</a> <em>     */</em>\n<a name=\"245\" href=\"#245\">245</a>     <strong>public</strong> <strong>boolean</strong> fileRemoved(String fileName) {\n<a name=\"246\" href=\"#246\">246</a>         <strong>boolean</strong>\tresult = ownedFiles.containsKey(fileName);\n<a name=\"247\" href=\"#247\">247</a>         <strong>if</strong> (result) {\n<a name=\"248\" href=\"#248\">248</a>             ownedFiles.remove(fileName);\n<a name=\"249\" href=\"#249\">249</a>         }\n<a name=\"250\" href=\"#250\">250</a>         <strong>return</strong> result;\n<a name=\"251\" href=\"#251\">251</a>     }\n<a name=\"252\" href=\"#252\">252</a>     \n<a name=\"253\" href=\"#253\">253</a>     <em>/**<em>*</em></em>\n<a name=\"254\" href=\"#254\">254</a> <em>     * Whether the peer owns a file</em>\n<a name=\"255\" href=\"#255\">255</a> <em>     * @param fileName the name of the file</em>\n<a name=\"256\" href=\"#256\">256</a> <em>     * @return true if the peer owns it and has not suspended the ownership of it,</em>\n<a name=\"257\" href=\"#257\">257</a> <em>     * false if it does not own it or it has temporarily suspended the ownership</em>\n<a name=\"258\" href=\"#258\">258</a> <em>     */</em>\n<a name=\"259\" href=\"#259\">259</a>     <strong>public</strong> <strong>boolean</strong> owns(String fileName) {\n<a name=\"260\" href=\"#260\">260</a>         <strong>return</strong>  ownedFiles.containsKey(fileName) &amp;&amp; !isSuspended(fileName);\n<a name=\"261\" href=\"#261\">261</a>     }\n<a name=\"262\" href=\"#262\">262</a> \n<a name=\"263\" href=\"#263\">263</a>     <strong>public</strong> Map getOwnedFiles() {\n<a name=\"264\" href=\"#264\">264</a>     \t<strong>return</strong> ownedFiles;\n<a name=\"265\" href=\"#265\">265</a>     }\n<a name=\"266\" href=\"#266\">266</a>     \n<a name=\"267\" href=\"#267\">267</a>     <em>/**<em>*</em></em>\n<a name=\"268\" href=\"#268\">268</a> <em>     * Files that are temporarily suspended</em>\n<a name=\"269\" href=\"#269\">269</a> <em>     */</em>\n<a name=\"270\" href=\"#270\">270</a>     <strong>private</strong>\tMap\tsuspendedFiles = <strong>new</strong> HashMap();\n<a name=\"271\" href=\"#271\">271</a>     <em>/**<em>*</em></em>\n<a name=\"272\" href=\"#272\">272</a> <em>     * Suspend a file so this peer no longer claims ownership</em>\n<a name=\"273\" href=\"#273\">273</a> <em>     * @param fileName\t\tthe file name to suspend</em>\n<a name=\"274\" href=\"#274\">274</a> <em>     * @param newOwner\t\tthe new temporary owner of the file</em>\n<a name=\"275\" href=\"#275\">275</a> <em>     */</em>\n<a name=\"276\" href=\"#276\">276</a>     <strong>public</strong> <strong>void</strong> suspendFile(String fileName, <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a> newOwner) {\n<a name=\"277\" href=\"#277\">277</a>         suspendedFiles.put(fileName, newOwner);\n<a name=\"278\" href=\"#278\">278</a>         newOwner.grabFile(fileName, <strong>this</strong>);\n<a name=\"279\" href=\"#279\">279</a>     }\n<a name=\"280\" href=\"#280\">280</a>     \n<a name=\"281\" href=\"#281\">281</a>     <em>/**<em>*</em></em>\n<a name=\"282\" href=\"#282\">282</a> <em>     * Is a file suspended?</em>\n<a name=\"283\" href=\"#283\">283</a> <em>     * @param fileName\tthe name of the file</em>\n<a name=\"284\" href=\"#284\">284</a> <em>     * @return true if the file is suspended</em>\n<a name=\"285\" href=\"#285\">285</a> <em>     */</em>\n<a name=\"286\" href=\"#286\">286</a>     <strong>public</strong> <strong>boolean</strong> isSuspended(String fileName) {\n<a name=\"287\" href=\"#287\">287</a>         <strong>return</strong> suspendedFiles.containsKey(fileName);\n<a name=\"288\" href=\"#288\">288</a>     }\n<a name=\"289\" href=\"#289\">289</a>     \n<a name=\"290\" href=\"#290\">290</a>     <em>/**<em>*</em></em>\n<a name=\"291\" href=\"#291\">291</a> <em>     * Resume the ownership of a file</em>\n<a name=\"292\" href=\"#292\">292</a> <em>     * @param fileName the name of the file</em>\n<a name=\"293\" href=\"#293\">293</a> <em>     */</em>\n<a name=\"294\" href=\"#294\">294</a>     <strong>public</strong> <strong>void</strong> resumeFile(String fileName) {\n<a name=\"295\" href=\"#295\">295</a>         suspendedFiles.remove(fileName);\n<a name=\"296\" href=\"#296\">296</a>     }\n<a name=\"297\" href=\"#297\">297</a>     \n<a name=\"298\" href=\"#298\">298</a>     <em>/**<em>*</em></em>\n<a name=\"299\" href=\"#299\">299</a> <em>     * Files that are temporarily owned (grabbed)</em>\n<a name=\"300\" href=\"#300\">300</a> <em>     */</em>\n<a name=\"301\" href=\"#301\">301</a>     <strong>private</strong> Map\tgrabbedFiles = <strong>new</strong> HashMap();\n<a name=\"302\" href=\"#302\">302</a>     <em>/**<em>*</em></em>\n<a name=\"303\" href=\"#303\">303</a> <em>     * Claim a file for temporary ownership</em>\n<a name=\"304\" href=\"#304\">304</a> <em>     * @param fileName\t\tthe file temporarily owned</em>\n<a name=\"305\" href=\"#305\">305</a> <em>     * @param originalOwner\tthe original owner</em>\n<a name=\"306\" href=\"#306\">306</a> <em>     */</em>\n<a name=\"307\" href=\"#307\">307</a>     <strong>public</strong> <strong>void</strong> grabFile(String fileName, <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a> originalOwner) {\n<a name=\"308\" href=\"#308\">308</a>         grabbedFiles.put(fileName, originalOwner);\n<a name=\"309\" href=\"#309\">309</a>     }\n<a name=\"310\" href=\"#310\">310</a>     \n<a name=\"311\" href=\"#311\">311</a>     <em>/**<em>*</em></em>\n<a name=\"312\" href=\"#312\">312</a> <em>     * Is a file grabbed?</em>\n<a name=\"313\" href=\"#313\">313</a> <em>     * @param fileName\tthe name of the file</em>\n<a name=\"314\" href=\"#314\">314</a> <em>     * @return the original owner if the file is grabbed, null if the file is not grabbed</em>\n<a name=\"315\" href=\"#315\">315</a> <em>     */</em>\n<a name=\"316\" href=\"#316\">316</a>     <strong>public</strong> <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a> isGrabbed(String fileName) {\n<a name=\"317\" href=\"#317\">317</a>         <strong>return</strong> (RepositoryPeer)grabbedFiles.get(fileName);\n<a name=\"318\" href=\"#318\">318</a>     }\n<a name=\"319\" href=\"#319\">319</a> \n<a name=\"320\" href=\"#320\">320</a>     <em>/**<em>*</em></em>\n<a name=\"321\" href=\"#321\">321</a> <em>     * Release the ownership of a file</em>\n<a name=\"322\" href=\"#322\">322</a> <em>     * @param fileName \t\tthe file name</em>\n<a name=\"323\" href=\"#323\">323</a> <em>     * @return\tthe original owner of this file</em>\n<a name=\"324\" href=\"#324\">324</a> <em>     */</em>\n<a name=\"325\" href=\"#325\">325</a>     <strong>public</strong> <a href=\"../../../../../edu/uci/isr/impromptu/repository/RepositoryPeer.html\">RepositoryPeer</a> releaseFile(String fileName) {\n<a name=\"326\" href=\"#326\">326</a>         <strong>return</strong> (RepositoryPeer)grabbedFiles.remove(fileName);\n<a name=\"327\" href=\"#327\">327</a>     }\n<a name=\"328\" href=\"#328\">328</a>     \n<a name=\"329\" href=\"#329\">329</a>     <em>/**<em>*</em></em>\n<a name=\"330\" href=\"#330\">330</a> <em>     * Whether the local peer shares a file</em>\n<a name=\"331\" href=\"#331\">331</a> <em>     * @param fileName the name of the file</em>\n<a name=\"332\" href=\"#332\">332</a> <em>     * @return true if the local peer shares the file, </em>\n<a name=\"333\" href=\"#333\">333</a> <em>     * false if the local peer does not share it.</em>\n<a name=\"334\" href=\"#334\">334</a> <em>     */</em>\n<a name=\"335\" href=\"#335\">335</a>     <strong>public</strong> <strong>boolean</strong> isShared(String fileName) {\n<a name=\"336\" href=\"#336\">336</a> \t    <em class=\"comment\">/*<em class=\"comment\"> When a file is just stored in the local peer but should not be noticeable</em></em>\n<a name=\"337\" href=\"#337\">337</a> <em class=\"comment\">\t     * to others, this method returns false. This is not a security problem, </em>\n<a name=\"338\" href=\"#338\">338</a> <em class=\"comment\">\t     * since this is just to make PROPFIND do what it is supposed to do. Even </em>\n<a name=\"339\" href=\"#339\">339</a> <em class=\"comment\">\t     * a malicious user gets the name, he can not do anything than other security</em>\n<a name=\"340\" href=\"#340\">340</a> <em class=\"comment\">\t     * constraints would allow him to do.</em>\n<a name=\"341\" href=\"#341\">341</a> <em class=\"comment\">\t     */</em>\n<a name=\"342\" href=\"#342\">342</a>         <strong>boolean</strong>\tresult = false;\n<a name=\"343\" href=\"#343\">343</a>         Integer\tsharedDegree = (Integer)ownedFiles.get(fileName);\n<a name=\"344\" href=\"#344\">344</a>         <strong>if</strong> (sharedDegree != <strong>null</strong>) {\n<a name=\"345\" href=\"#345\">345</a>             <strong>if</strong> (sharedDegree.intValue() > SecurityConstants.LEVEL_PRIVATE) {\n<a name=\"346\" href=\"#346\">346</a>                 result = <strong>true</strong>;\n<a name=\"347\" href=\"#347\">347</a>             }\n<a name=\"348\" href=\"#348\">348</a>         }\n<a name=\"349\" href=\"#349\">349</a>         <strong>return</strong> result;\n<a name=\"350\" href=\"#350\">350</a>     }\n<a name=\"351\" href=\"#351\">351</a>     \n<a name=\"352\" href=\"#352\">352</a>     <em>/**<em>*</em></em>\n<a name=\"353\" href=\"#353\">353</a> <em>     * Whether the local peer imports the file into the private space</em>\n<a name=\"354\" href=\"#354\">354</a> <em>     * @param fileName the name of the file</em>\n<a name=\"355\" href=\"#355\">355</a> <em>     * @return true if the file is in the private space, false otherwise.</em>\n<a name=\"356\" href=\"#356\">356</a> <em>     */</em>\n<a name=\"357\" href=\"#357\">357</a>     <strong>public</strong> <strong>boolean</strong> isPrivate(String fileName) {\n<a name=\"358\" href=\"#358\">358</a>         <strong>boolean</strong>\tresult = false;\n<a name=\"359\" href=\"#359\">359</a>         Integer\tsharedDegree = (Integer)ownedFiles.get(fileName);\n<a name=\"360\" href=\"#360\">360</a>         <strong>if</strong> (sharedDegree != <strong>null</strong>) {\n<a name=\"361\" href=\"#361\">361</a>             <strong>if</strong> (sharedDegree.intValue() == SecurityConstants.LEVEL_PRIVATE) {\n<a name=\"362\" href=\"#362\">362</a>                 result = <strong>true</strong>;\n<a name=\"363\" href=\"#363\">363</a>             }\n<a name=\"364\" href=\"#364\">364</a>         }\n<a name=\"365\" href=\"#365\">365</a>         <strong>return</strong> result;\n<a name=\"366\" href=\"#366\">366</a>     }\n<a name=\"367\" href=\"#367\">367</a>     \n<a name=\"368\" href=\"#368\">368</a>     <em>/**<em>*</em></em>\n<a name=\"369\" href=\"#369\">369</a> <em>     * Execute a request towards this (remote) peer. It is invoked by the filter</em>\n<a name=\"370\" href=\"#370\">370</a> <em>     * \t\tto direct the request to an owner peer. This method executes a HttpClient</em>\n<a name=\"371\" href=\"#371\">371</a> <em>     * \t\tcall and forward the response back to the original client. This extra </em>\n<a name=\"372\" href=\"#372\">372</a> <em>     * \t\tround trip affects performance.  </em>\n<a name=\"373\" href=\"#373\">373</a> <em>     * @param request\t\tthe original request</em>\n<a name=\"374\" href=\"#374\">374</a> <em>     * @param response\t\tthe original response</em>\n<a name=\"375\" href=\"#375\">375</a> <em>     * @param forward\t\tif true, then the response from the method will be </em>\n<a name=\"376\" href=\"#376\">376</a> <em>     * \t\t\t\t\t\tforwarded to the original response.</em>\n<a name=\"377\" href=\"#377\">377</a> <em>     * @param identifySelf  whether the method should add a header to identify itself</em>\n<a name=\"378\" href=\"#378\">378</a> <em>     * @return the response body of the execution, can be either a string or a XML document  </em>\n<a name=\"379\" href=\"#379\">379</a> <em>     */</em>\n<a name=\"380\" href=\"#380\">380</a>     <strong>public</strong> Object service(HttpServletRequest request, HttpServletResponse response, \n<a name=\"381\" href=\"#381\">381</a>             \t\t\t  <strong>boolean</strong> forward, <strong>boolean</strong> identifySelf) {\n<a name=\"382\" href=\"#382\">382</a>         <em class=\"comment\">// clear credentials</em>\n<a name=\"383\" href=\"#383\">383</a>         <em class=\"comment\">// client.getState().setCredentials(SlideUserRealm.REALM_NAME, hostAddress, null);</em>\n<a name=\"384\" href=\"#384\">384</a>         \n<a name=\"385\" href=\"#385\">385</a>         Object\t\t\tresponseBody = <strong>null</strong>;\n<a name=\"386\" href=\"#386\">386</a>         HttpMethodBase\tmethod = <strong>null</strong>;\n<a name=\"387\" href=\"#387\">387</a> \n<a name=\"388\" href=\"#388\">388</a>         <strong>try</strong> {\n<a name=\"389\" href=\"#389\">389</a>             <em class=\"comment\">// When A is already up, and B joins, 1)A's repository needs to add B to its allowed </em>\n<a name=\"390\" href=\"#390\">390</a>             <em class=\"comment\">// \"others\", and 2)B's pie needs to get the files from A. 1) should happen</em>\n<a name=\"391\" href=\"#391\">391</a>             <em class=\"comment\">// before 2), but if 2) happens before 1), maybe because of JmDNS resolution,</em>\n<a name=\"392\" href=\"#392\">392</a>             <em class=\"comment\">// then 2) will receive many 401 errors. A retry should solve the problem.</em>\n<a name=\"393\" href=\"#393\">393</a>             <em class=\"comment\">// An unsuccessful mountDrive seems causing problematic delays here</em>\n<a name=\"394\" href=\"#394\">394</a>             <em class=\"comment\">// A message, ACTION_ADD_PEER, is added to control the pie's fetching.</em>\n<a name=\"395\" href=\"#395\">395</a>             <em class=\"comment\">// whether to issue the message is an admission control policy. Violtaing</em>\n<a name=\"396\" href=\"#396\">396</a>             <em class=\"comment\">// the policy (fetching without permission) will not breach the security.</em>\n<a name=\"397\" href=\"#397\">397</a>             <strong>boolean</strong>\t\tdone = false;\n<a name=\"398\" href=\"#398\">398</a>             <strong>int</strong>\t\t\tmaxRetry = 3;\n<a name=\"399\" href=\"#399\">399</a>             <strong>int</strong>\t\t\tretry = 0;\n<a name=\"400\" href=\"#400\">400</a>             \n<a name=\"401\" href=\"#401\">401</a>             <strong>while</strong> (!done &amp;&amp; retry &lt;maxRetry) {\n<a name=\"402\" href=\"#402\">402</a>                 <strong>try</strong> {\n<a name=\"403\" href=\"#403\">403</a> \t\t            <em class=\"comment\">// create a HttpClient method based on the request</em>\n<a name=\"404\" href=\"#404\">404</a> \t\t            <em class=\"comment\">// HttpClient should have a factory method for this</em>\n<a name=\"405\" href=\"#405\">405</a> \t\t            <em class=\"comment\">// TODO: protocol: long delay in LOCK after GET</em>\n<a name=\"406\" href=\"#406\">406</a> \t\t            method = createMethod(request);\n<a name=\"407\" href=\"#407\">407</a> \t\t\n<a name=\"408\" href=\"#408\">408</a> \t\t            <em class=\"comment\">// should identify self? </em>\n<a name=\"409\" href=\"#409\">409</a> \t\t            <strong>if</strong> (ident<strong>if</strong>ySelf) {\n<a name=\"410\" href=\"#410\">410</a> \t\t                method.addRequestHeader(Configuration.IMPROMPTU_HEADER_NAME, \n<a name=\"411\" href=\"#411\">411</a> \t\t                        \t\t\t\tConfiguration.IMPROMPTU_HEADER_VALUE);\n<a name=\"412\" href=\"#412\">412</a> \t\t            }\n<a name=\"413\" href=\"#413\">413</a> \t\t            \n<a name=\"414\" href=\"#414\">414</a> \t\t            <em class=\"comment\">// Execute the method.</em>\n<a name=\"415\" href=\"#415\">415</a> \t\t            client.executeMethod(method);\n<a name=\"416\" href=\"#416\">416</a> \t\t            done = <strong>true</strong>;\n<a name=\"417\" href=\"#417\">417</a>                 }\n<a name=\"418\" href=\"#418\">418</a>                 <strong>catch</strong> (HttpRecoverableException hre) {\n<a name=\"419\" href=\"#419\">419</a>                     <strong>if</strong> (hre.getMessage().indexOf(<span class=\"string\">\"Maximum redirects\"</span>) != -1) {\n<a name=\"420\" href=\"#420\">420</a>                         <strong>try</strong> {\n<a name=\"421\" href=\"#421\">421</a>                             Thread.sleep(5000);\n<a name=\"422\" href=\"#422\">422</a>                         }\n<a name=\"423\" href=\"#423\">423</a>                         <strong>catch</strong> (InterruptedException e) {\n<a name=\"424\" href=\"#424\">424</a>                         }\n<a name=\"425\" href=\"#425\">425</a>                         retry++;\n<a name=\"426\" href=\"#426\">426</a>                     }\n<a name=\"427\" href=\"#427\">427</a>                     <strong>else</strong> {\n<a name=\"428\" href=\"#428\">428</a>                         <strong>throw</strong> hre;\n<a name=\"429\" href=\"#429\">429</a>                     }\n<a name=\"430\" href=\"#430\">430</a>                 }\n<a name=\"431\" href=\"#431\">431</a>             }\n<a name=\"432\" href=\"#432\">432</a> \n<a name=\"433\" href=\"#433\">433</a>             <em class=\"comment\">// forward the response</em>\n<a name=\"434\" href=\"#434\">434</a>             <strong>if</strong> (forward)\n<a name=\"435\" href=\"#435\">435</a>                 forwardResponse(method, response);\n<a name=\"436\" href=\"#436\">436</a>             <strong>if</strong> (method instanceof XMLResponseMethodBase) {\n<a name=\"437\" href=\"#437\">437</a>                 responseBody = ((XMLResponseMethodBase)method).getResponseDocument();\n<a name=\"438\" href=\"#438\">438</a>             }\n<a name=\"439\" href=\"#439\">439</a>             <strong>else</strong> {\n<a name=\"440\" href=\"#440\">440</a>                 responseBody = method.getResponseBodyAsString();\n<a name=\"441\" href=\"#441\">441</a>             }\n<a name=\"442\" href=\"#442\">442</a>         }\n<a name=\"443\" href=\"#443\">443</a>         <strong>catch</strong> (Exception e) {\n<a name=\"444\" href=\"#444\">444</a>             <em class=\"comment\">// Here, rarely it comes with \"narrowly avoided infinite loop\" exception.</em>\n<a name=\"445\" href=\"#445\">445</a>             <em class=\"comment\">// It looks like the JmDNS resolves a peer to a wrong address, to which </em>\n<a name=\"446\" href=\"#446\">446</a>             <em class=\"comment\">// our \"correct\" password is just wrong. After many 401 retrials the </em>\n<a name=\"447\" href=\"#447\">447</a>             <em class=\"comment\">// method gives up. Since this is a JmDNS infrastructure problem, we will </em>\n<a name=\"448\" href=\"#448\">448</a>             <em class=\"comment\">// not address it, and use a restart as a workaround.</em>\n<a name=\"449\" href=\"#449\">449</a>             <em class=\"comment\">// The scenario is: when A and B is up, and C joins, sometimes A's </em>\n<a name=\"450\" href=\"#450\">450</a>             <em class=\"comment\">// JmDNS resolves C's name into B's address, and result in an infinite </em>\n<a name=\"451\" href=\"#451\">451</a>             <em class=\"comment\">// \"redirection\". This seems happening when C is a Windows 2003 machine </em>\n<a name=\"452\" href=\"#452\">452</a>             <em class=\"comment\">// or A is a Mac machine. </em>\n<a name=\"453\" href=\"#453\">453</a>             Utils.handleException(e);\n<a name=\"454\" href=\"#454\">454</a>         } \n<a name=\"455\" href=\"#455\">455</a>         <strong>finally</strong> {\n<a name=\"456\" href=\"#456\">456</a>             <em class=\"comment\">// Release the connection.</em>\n<a name=\"457\" href=\"#457\">457</a>             method.releaseConnection();\n<a name=\"458\" href=\"#458\">458</a>         }  \n<a name=\"459\" href=\"#459\">459</a>         \n<a name=\"460\" href=\"#460\">460</a>         <strong>return</strong> responseBody;\n<a name=\"461\" href=\"#461\">461</a>     }\n<a name=\"462\" href=\"#462\">462</a>     \n<a name=\"463\" href=\"#463\">463</a>     <em>/**<em>*</em></em>\n<a name=\"464\" href=\"#464\">464</a> <em>     * Create a method that can be executed later, based on a servelet request</em>\n<a name=\"465\" href=\"#465\">465</a> <em>     * @param request the servelet request</em>\n<a name=\"466\" href=\"#466\">466</a> <em>     * @return a method that encapsulates information from this request</em>\n<a name=\"467\" href=\"#467\">467</a> <em>     */</em>\n<a name=\"468\" href=\"#468\">468</a>     <strong>private</strong> HttpMethodBase\tcreateMethod(HttpServletRequest request) {\n<a name=\"469\" href=\"#469\">469</a>         HttpMethodBase\tmethod = <strong>null</strong>;\n<a name=\"470\" href=\"#470\">470</a>         String\t\tmethodName = request.getMethod().toUpperCase();\n<a name=\"471\" href=\"#471\">471</a> \n<a name=\"472\" href=\"#472\">472</a>         <em class=\"comment\">// HTTP: RFC 2616</em>\n<a name=\"473\" href=\"#473\">473</a>         <strong>if</strong> (methodName.equals(WebdavConstants.M_OPTIONS)) {\n<a name=\"474\" href=\"#474\">474</a>             method = <strong>new</strong> OptionsMethod();\n<a name=\"475\" href=\"#475\">475</a>         } \n<a name=\"476\" href=\"#476\">476</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_GET)) {\n<a name=\"477\" href=\"#477\">477</a>             method = <strong>new</strong> GetMethod();\n<a name=\"478\" href=\"#478\">478</a>         } \n<a name=\"479\" href=\"#479\">479</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_HEAD)) {\n<a name=\"480\" href=\"#480\">480</a>             method = <strong>new</strong> HeadMethod();\n<a name=\"481\" href=\"#481\">481</a>         } \n<a name=\"482\" href=\"#482\">482</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_POST)) {\n<a name=\"483\" href=\"#483\">483</a>             method = <strong>new</strong> PostMethod();\n<a name=\"484\" href=\"#484\">484</a>         } \n<a name=\"485\" href=\"#485\">485</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_PUT)) {\n<a name=\"486\" href=\"#486\">486</a>             method = <strong>new</strong> PutMethod();\n<a name=\"487\" href=\"#487\">487</a>         } \n<a name=\"488\" href=\"#488\">488</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_DELETE)) {\n<a name=\"489\" href=\"#489\">489</a>             method = <strong>new</strong> DeleteMethod();\n<a name=\"490\" href=\"#490\">490</a>         } \n<a name=\"491\" href=\"#491\">491</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_TRACE)) {\n<a name=\"492\" href=\"#492\">492</a>             method = <strong>new</strong> TraceMethod(<span class=\"string\">\"\"</span>);\n<a name=\"493\" href=\"#493\">493</a>         } \n<a name=\"494\" href=\"#494\">494</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_CONNECT)) {\n<a name=\"495\" href=\"#495\">495</a>         \t<em class=\"comment\">// This constructor is not available in httpclient 2</em>\n<a name=\"496\" href=\"#496\">496</a>             <em class=\"comment\">// method = new ConnectMethod();</em>\n<a name=\"497\" href=\"#497\">497</a>         }\n<a name=\"498\" href=\"#498\">498</a>         \n<a name=\"499\" href=\"#499\">499</a>         <em class=\"comment\">// WebDAV: RFC 2518</em>\n<a name=\"500\" href=\"#500\">500</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_PROPFIND)) {\n<a name=\"501\" href=\"#501\">501</a>             method = <strong>new</strong> PropFindMethod();\n<a name=\"502\" href=\"#502\">502</a>         } \n<a name=\"503\" href=\"#503\">503</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_PROPPATCH)) {\n<a name=\"504\" href=\"#504\">504</a>             method = <strong>new</strong> PropPatchMethod();\n<a name=\"505\" href=\"#505\">505</a>         } \n<a name=\"506\" href=\"#506\">506</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_MKCOL)) {\n<a name=\"507\" href=\"#507\">507</a>             method = <strong>new</strong> MkcolMethod();\n<a name=\"508\" href=\"#508\">508</a>         } \n<a name=\"509\" href=\"#509\">509</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_COPY)) {\n<a name=\"510\" href=\"#510\">510</a>             method = <strong>new</strong> CopyMethod();\n<a name=\"511\" href=\"#511\">511</a>         } \n<a name=\"512\" href=\"#512\">512</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_MOVE)) {\n<a name=\"513\" href=\"#513\">513</a>             method = <strong>new</strong> MoveMethod();\n<a name=\"514\" href=\"#514\">514</a>         } \n<a name=\"515\" href=\"#515\">515</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_LOCK)) {\n<a name=\"516\" href=\"#516\">516</a>             method = <strong>new</strong> LockMethod();\n<a name=\"517\" href=\"#517\">517</a>         } \n<a name=\"518\" href=\"#518\">518</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(WebdavConstants.M_UNLOCK)) {\n<a name=\"519\" href=\"#519\">519</a>             method = <strong>new</strong> UnlockMethod();\n<a name=\"520\" href=\"#520\">520</a>         }\n<a name=\"521\" href=\"#521\">521</a>         <em class=\"comment\">// WebDAV Redirect: not on client side?</em>\n<a name=\"522\" href=\"#522\">522</a>         <em class=\"comment\">// else if (methodName.equals(\"MKREDIRECTREF\")) {</em>\n<a name=\"523\" href=\"#523\">523</a>         <em class=\"comment\">//    method = new MkredirectrefMethod();</em>\n<a name=\"524\" href=\"#524\">524</a>         <em class=\"comment\">// } </em>\n<a name=\"525\" href=\"#525\">525</a> \n<a name=\"526\" href=\"#526\">526</a>         <em class=\"comment\">// WebDAV ACL: RFC 3744</em>\n<a name=\"527\" href=\"#527\">527</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(AclConstants.M_ACL)) {\n<a name=\"528\" href=\"#528\">528</a>             method = <strong>new</strong> AclMethod();\n<a name=\"529\" href=\"#529\">529</a>         }\n<a name=\"530\" href=\"#530\">530</a> \n<a name=\"531\" href=\"#531\">531</a>         <em class=\"comment\">// Methods below are not well tested in Impromptu</em>\n<a name=\"532\" href=\"#532\">532</a>         <em class=\"comment\">// DeltaV: RFC 3253</em>\n<a name=\"533\" href=\"#533\">533</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_REPORT)) {\n<a name=\"534\" href=\"#534\">534</a>             method = <strong>new</strong> ReportMethod();\n<a name=\"535\" href=\"#535\">535</a>         } \n<a name=\"536\" href=\"#536\">536</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_VERSION_CONTROL)) {\n<a name=\"537\" href=\"#537\">537</a>             method = <strong>new</strong> VersionControlMethod();\n<a name=\"538\" href=\"#538\">538</a>         } \n<a name=\"539\" href=\"#539\">539</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_CHECKIN)) {\n<a name=\"540\" href=\"#540\">540</a>             method = <strong>new</strong> CheckinMethod();\n<a name=\"541\" href=\"#541\">541</a>         } \n<a name=\"542\" href=\"#542\">542</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_CHECKOUT)) {\n<a name=\"543\" href=\"#543\">543</a>             method = <strong>new</strong> CheckoutMethod();\n<a name=\"544\" href=\"#544\">544</a>         } \n<a name=\"545\" href=\"#545\">545</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_UNCHECKOUT)) {\n<a name=\"546\" href=\"#546\">546</a>             method = <strong>new</strong> UncheckoutMethod();\n<a name=\"547\" href=\"#547\">547</a>         } \n<a name=\"548\" href=\"#548\">548</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_MKWORKSPACE)) {\n<a name=\"549\" href=\"#549\">549</a>             method = <strong>new</strong> MkWorkspaceMethod();\n<a name=\"550\" href=\"#550\">550</a>         } \n<a name=\"551\" href=\"#551\">551</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_LABEL)) {\n<a name=\"552\" href=\"#552\">552</a>             method = <strong>new</strong> LabelMethod();\n<a name=\"553\" href=\"#553\">553</a>         } \n<a name=\"554\" href=\"#554\">554</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DeltavConstants.M_UPDATE)) {\n<a name=\"555\" href=\"#555\">555</a>             method = <strong>new</strong> UpdateMethod();\n<a name=\"556\" href=\"#556\">556</a>         }\n<a name=\"557\" href=\"#557\">557</a> \n<a name=\"558\" href=\"#558\">558</a>         <em class=\"comment\">// DASL Search: </em>\n<a name=\"559\" href=\"#559\">559</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(DaslConstants.M_SEARCH)) {\n<a name=\"560\" href=\"#560\">560</a>              method = <strong>new</strong> SearchMethod();\n<a name=\"561\" href=\"#561\">561</a>         }\n<a name=\"562\" href=\"#562\">562</a>         \n<a name=\"563\" href=\"#563\">563</a>         <em class=\"comment\">// BIND</em>\n<a name=\"564\" href=\"#564\">564</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(BindConstants.M_BIND)) {\n<a name=\"565\" href=\"#565\">565</a>             method = <strong>new</strong> BindMethod();\n<a name=\"566\" href=\"#566\">566</a>         } \n<a name=\"567\" href=\"#567\">567</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(BindConstants.M_UNBIND)) {\n<a name=\"568\" href=\"#568\">568</a>             method = <strong>new</strong> UnbindMethod();\n<a name=\"569\" href=\"#569\">569</a>         } \n<a name=\"570\" href=\"#570\">570</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(BindConstants.M_REBIND)) {\n<a name=\"571\" href=\"#571\">571</a>             method = <strong>new</strong> RebindMethod();\n<a name=\"572\" href=\"#572\">572</a>         }\n<a name=\"573\" href=\"#573\">573</a> \n<a name=\"574\" href=\"#574\">574</a>         <em class=\"comment\">// Microsoft Exchange extensions</em>\n<a name=\"575\" href=\"#575\">575</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(<span class=\"string\">\"SUBSCRIBE\"</span>)) {\n<a name=\"576\" href=\"#576\">576</a>             method = <strong>new</strong> SubscribeMethod();\n<a name=\"577\" href=\"#577\">577</a>         } \n<a name=\"578\" href=\"#578\">578</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(<span class=\"string\">\"UNSUBSCRIBE\"</span>)) {\n<a name=\"579\" href=\"#579\">579</a>             method = <strong>new</strong> UnsubscribeMethod();\n<a name=\"580\" href=\"#580\">580</a>         } \n<a name=\"581\" href=\"#581\">581</a>         <strong>else</strong> <strong>if</strong> (methodName.equals(<span class=\"string\">\"POLL\"</span>)) {\n<a name=\"582\" href=\"#582\">582</a>             method = <strong>new</strong> PollMethod();\n<a name=\"583\" href=\"#583\">583</a>         } \n<a name=\"584\" href=\"#584\">584</a>         <em class=\"comment\">//else if (methodName.equals(\"EVENT\")) {</em>\n<a name=\"585\" href=\"#585\">585</a>         <em class=\"comment\">//    method = new EventMethod();</em>\n<a name=\"586\" href=\"#586\">586</a>         <em class=\"comment\">//}</em>\n<a name=\"587\" href=\"#587\">587</a> \n<a name=\"588\" href=\"#588\">588</a>         <em class=\"comment\">// unknown method</em>\n<a name=\"589\" href=\"#589\">589</a>         <strong>else</strong> \n<a name=\"590\" href=\"#590\">590</a>             <strong>return</strong> <strong>null</strong>;\n<a name=\"591\" href=\"#591\">591</a> \n<a name=\"592\" href=\"#592\">592</a>         <strong>try</strong> {\n<a name=\"593\" href=\"#593\">593</a>             method.setPath(request.getRequestURI());\n<a name=\"594\" href=\"#594\">594</a>             \n<a name=\"595\" href=\"#595\">595</a>             <em class=\"comment\">// Copy headers from the request</em>\n<a name=\"596\" href=\"#596\">596</a>             Enumeration\t\theaderNames = request.getHeaderNames();\n<a name=\"597\" href=\"#597\">597</a>             <strong>while</strong>(headerNames.hasMoreElements()) {\n<a name=\"598\" href=\"#598\">598</a>                 String\t\theaderName = (String)headerNames.nextElement();\n<a name=\"599\" href=\"#599\">599</a>                 <strong>boolean</strong>\t\tprocessed = false;\t<em class=\"comment\">// whether the header has been processed</em>\n<a name=\"600\" href=\"#600\">600</a>                 <em class=\"comment\">// Slide Webdav Client's Lock method only catches Lock-Token </em>\n<a name=\"601\" href=\"#601\">601</a>                 <em class=\"comment\">//\tthrough setRequestHeader. It expects Lock-Token has been set</em>\n<a name=\"602\" href=\"#602\">602</a>                 <em class=\"comment\">//\tduring the following addRequestHeader.</em>\n<a name=\"603\" href=\"#603\">603</a>                 <strong>if</strong> (headerName.equalsIgnoreCase(<span class=\"string\">\"Lock-Token\"</span>)) {\n<a name=\"604\" href=\"#604\">604</a>                     method.setRequestHeader(headerName, \n<a name=\"605\" href=\"#605\">605</a>                             request.getHeader(headerName));\n<a name=\"606\" href=\"#606\">606</a>                     processed = <strong>true</strong>;\n<a name=\"607\" href=\"#607\">607</a>                 }\n<a name=\"608\" href=\"#608\">608</a>                 <em class=\"comment\">// Do not copy the auhtorization header, which comes from a pie. </em>\n<a name=\"609\" href=\"#609\">609</a>                 <em class=\"comment\">//\tUse our shared password with the remote peer</em>\n<a name=\"610\" href=\"#610\">610</a>                 <strong>if</strong> (headerName.equalsIgnoreCase(<span class=\"string\">\"Authorization\"</span>)) {\n<a name=\"611\" href=\"#611\">611</a>                     <em class=\"comment\">// TODO: security: delegate: here we do a blind credentials </em>\n<a name=\"612\" href=\"#612\">612</a>                     <em class=\"comment\">//\t\tdelegation. We should check whether the credentials</em>\n<a name=\"613\" href=\"#613\">613</a>                     <em class=\"comment\">//\t\tprovided meet what we have</em>\n<a name=\"614\" href=\"#614\">614</a>                     processed = <strong>true</strong>;\n<a name=\"615\" href=\"#615\">615</a>                 }\n<a name=\"616\" href=\"#616\">616</a>                 <strong>if</strong> (!processed){\n<a name=\"617\" href=\"#617\">617</a> \t                Enumeration\theaders = request.getHeaders(headerName);\n<a name=\"618\" href=\"#618\">618</a> \t                <strong>while</strong>(headers.hasMoreElements()) {\n<a name=\"619\" href=\"#619\">619</a> \t                    String\theaderValue = (String)headers.nextElement();\n<a name=\"620\" href=\"#620\">620</a> \t                    method.addRequestHeader(headerName, headerValue);\n<a name=\"621\" href=\"#621\">621</a> \t                }\n<a name=\"622\" href=\"#622\">622</a>                 }\n<a name=\"623\" href=\"#623\">623</a>             }\n<a name=\"624\" href=\"#624\">624</a> \n<a name=\"625\" href=\"#625\">625</a>             <em class=\"comment\">// handle depth header specially</em>\n<a name=\"626\" href=\"#626\">626</a>             <em class=\"comment\">// because webdav.lib ignores our previous setting of Depth</em>\n<a name=\"627\" href=\"#627\">627</a>             <strong>if</strong> (method instanceof DepthSupport) {\n<a name=\"628\" href=\"#628\">628</a> \t            <strong>try</strong> {\n<a name=\"629\" href=\"#629\">629</a> \t                <strong>if</strong> (request.getIntHeader(<span class=\"string\">\"Depth\"</span>) != -1)\n<a name=\"630\" href=\"#630\">630</a> \t    \t            ((DepthSupport)method).setDepth(request.getIntHeader(<span class=\"string\">\"Depth\"</span>));\n<a name=\"631\" href=\"#631\">631</a> \t            }\n<a name=\"632\" href=\"#632\">632</a> \t            <strong>catch</strong> (NumberFormatException nfe) {\n<a name=\"633\" href=\"#633\">633</a> \t            }\n<a name=\"634\" href=\"#634\">634</a>             }\n<a name=\"635\" href=\"#635\">635</a> \n<a name=\"636\" href=\"#636\">636</a>             <em class=\"comment\">// handle the timeout header for lock specially</em>\n<a name=\"637\" href=\"#637\">637</a>             <strong>if</strong> (method instanceof LockMethod) {\n<a name=\"638\" href=\"#638\">638</a>                 LockMethod\tlm = (LockMethod)method;\n<a name=\"639\" href=\"#639\">639</a>                 <strong>int</strong>\t\t\tmyTimeout = 180;\n<a name=\"640\" href=\"#640\">640</a>                 <strong>if</strong> (lm.getTimeout() == LockMethod.TIMEOUT_INFINITY) {\n<a name=\"641\" href=\"#641\">641</a>                     <em class=\"comment\">// http://support.microsoft.com/default.aspx?scid=kb;en-us;832161</em>\n<a name=\"642\" href=\"#642\">642</a>                     <em class=\"comment\">// http://mailman.lyra.org/pipermail/dav-dev/2002-October/004098.html</em>\n<a name=\"643\" href=\"#643\">643</a>                     <em class=\"comment\">// http://www.greenbytes.de/tech/webdav/webfolder-client-list.html#issue-lock-timeout</em>\n<a name=\"644\" href=\"#644\">644</a>                     <em class=\"comment\">// Office XP/2003 bypasses the redirector and does its own WebDAV. Office</em>\n<a name=\"645\" href=\"#645\">645</a>                     <em class=\"comment\">// 2K uses the redirector, if one is available.</em>\n<a name=\"646\" href=\"#646\">646</a>                     <em class=\"comment\">// Then, Office XP/2003 does not recognize infinite timeout response for LOCK,</em>\n<a name=\"647\" href=\"#647\">647</a>                     <em class=\"comment\">// and thinks it can only open the file as read-only. </em>\n<a name=\"648\" href=\"#648\">648</a>                     <em class=\"comment\">// Slide LockMethod always issues a timeout header with LOCK, and the</em>\n<a name=\"649\" href=\"#649\">649</a>                     <em class=\"comment\">// default value for it is infinite.</em>\n<a name=\"650\" href=\"#650\">650</a>                     <em class=\"comment\">// Thus we must set a more normal time out value if it has not been set</em>\n<a name=\"651\" href=\"#651\">651</a>                     lm.setTimeout(myTimeout);\n<a name=\"652\" href=\"#652\">652</a>                 }\n<a name=\"653\" href=\"#653\">653</a>             }\n<a name=\"654\" href=\"#654\">654</a> \n<a name=\"655\" href=\"#655\">655</a>             <em class=\"comment\">/*</em>\n<a name=\"656\" href=\"#656\">656</a> <em class=\"comment\">            if (method instanceof ExpectContinueMethod) {</em>\n<a name=\"657\" href=\"#657\">657</a> <em class=\"comment\">                // security: architecture: security changes protocol. address-based, basic</em>\n<a name=\"658\" href=\"#658\">658</a> <em class=\"comment\">                //  authentication are easy to proxy, since they will not change, and</em>\n<a name=\"659\" href=\"#659\">659</a> <em class=\"comment\">                //\tcan be sent primtively. Digest authentication needs a </em>\n<a name=\"660\" href=\"#660\">660</a> <em class=\"comment\">                //  challenge/response handshake, and httpclient makes this somewhat</em>\n<a name=\"661\" href=\"#661\">661</a> <em class=\"comment\">                //  awarkward, because the request body cannot be reread, much like</em>\n<a name=\"662\" href=\"#662\">662</a> <em class=\"comment\">                //\tthe servlet request body cannot be reread.</em>\n<a name=\"663\" href=\"#663\">663</a> <em class=\"comment\">                // </em>\n<a name=\"664\" href=\"#664\">664</a> <em class=\"comment\">                // about when to use this header</em>\n<a name=\"665\" href=\"#665\">665</a> <em class=\"comment\">                // <a href=\"http://www.mail-archive.com/commons-httpclient-dev@jakarta.apache.org/msg06723.html\" target=\"alexandria_uri\">http://www.mail-archive.com/commons-httpclient-dev@jakarta.apache.org/msg06723.html</a></em>\n<a name=\"666\" href=\"#666\">666</a> <em class=\"comment\">                // about container quirks</em>\n<a name=\"667\" href=\"#667\">667</a> <em class=\"comment\">                // <a href=\"http://www.mail-archive.com/commons-httpclient-dev@jakarta.apache.org/msg06743.html\" target=\"alexandria_uri\">http://www.mail-archive.com/commons-httpclient-dev@jakarta.apache.org/msg06743.html</a></em>\n<a name=\"668\" href=\"#668\">668</a> <em class=\"comment\">                // about clone method</em>\n<a name=\"669\" href=\"#669\">669</a> <em class=\"comment\">                // <a href=\"http://www.mail-archive.com/commons-httpclient-dev@jakarta.apache.org/msg01206.html\" target=\"alexandria_uri\">http://www.mail-archive.com/commons-httpclient-dev@jakarta.apache.org/msg01206.html</a></em>\n<a name=\"670\" href=\"#670\">670</a> <em class=\"comment\">                ((ExpectContinueMethod)method).setUseExpectHeader(true);</em>\n<a name=\"671\" href=\"#671\">671</a> <em class=\"comment\">            }</em>\n<a name=\"672\" href=\"#672\">672</a> <em class=\"comment\">            */</em>\n<a name=\"673\" href=\"#673\">673</a> \n<a name=\"674\" href=\"#674\">674</a>             <em class=\"comment\">// copy body from the request</em>\n<a name=\"675\" href=\"#675\">675</a>             <strong>if</strong> (method instanceof EntityEnclosingMethod) {\n<a name=\"676\" href=\"#676\">676</a>                 <em class=\"comment\">// From HttpClient library</em>\n<a name=\"677\" href=\"#677\">677</a>                 EntityEnclosingMethod\tbodyMethod = (EntityEnclosingMethod)method;\n<a name=\"678\" href=\"#678\">678</a>                 <em class=\"comment\">/*<em class=\"comment\"> httpclient 3.0</em></em>\n<a name=\"679\" href=\"#679\">679</a> <em class=\"comment\">                InputStreamRequestEntity isre = new InputStreamRequestEntity(</em>\n<a name=\"680\" href=\"#680\">680</a> <em class=\"comment\">                        request.getInputStream(), request.getContentLength(), </em>\n<a name=\"681\" href=\"#681\">681</a> <em class=\"comment\">                        request.getContentType());</em>\n<a name=\"682\" href=\"#682\">682</a> <em class=\"comment\">                bodyMethod.setRequestEntity(isre);</em>\n<a name=\"683\" href=\"#683\">683</a> <em class=\"comment\">                */</em>\n<a name=\"684\" href=\"#684\">684</a>                 bodyMethod.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, request.getContentType());\n<a name=\"685\" href=\"#685\">685</a>                 <em class=\"comment\">// bodyMethod.setRequestContentLength(request.getContentLength());</em>\n<a name=\"686\" href=\"#686\">686</a>                 <em class=\"comment\">// Had setUseExpectHeader worked with Jetty (who automatically emits a continue)</em>\n<a name=\"687\" href=\"#687\">687</a>                 <em class=\"comment\">// \twe would not need to use this to trigger buffering the content</em>\n<a name=\"688\" href=\"#688\">688</a>                 bodyMethod.setRequestContentLength(EntityEnclosingMethod.CONTENT_LENGTH_AUTO);\n<a name=\"689\" href=\"#689\">689</a>                 bodyMethod.setRequestBody(request.getInputStream());\n<a name=\"690\" href=\"#690\">690</a>             }\n<a name=\"691\" href=\"#691\">691</a>             <strong>else</strong> <strong>if</strong> (method instanceof HttpRequestBodyMethodBase) {\n<a name=\"692\" href=\"#692\">692</a>                 <em class=\"comment\">// From Slide WebDAV client library</em>\n<a name=\"693\" href=\"#693\">693</a>                 HttpRequestBodyMethodBase bodyMethod = (HttpRequestBodyMethodBase)method;\n<a name=\"694\" href=\"#694\">694</a>                 bodyMethod.setRequestBody(request.getInputStream());\n<a name=\"695\" href=\"#695\">695</a>             }\n<a name=\"696\" href=\"#696\">696</a>         }\n<a name=\"697\" href=\"#697\">697</a>         <strong>catch</strong> (Exception e) {\n<a name=\"698\" href=\"#698\">698</a>             Utils.handleException(e);\n<a name=\"699\" href=\"#699\">699</a>         }\n<a name=\"700\" href=\"#700\">700</a>         \n<a name=\"701\" href=\"#701\">701</a>         <strong>return</strong> method;\n<a name=\"702\" href=\"#702\">702</a>     }\n<a name=\"703\" href=\"#703\">703</a>     \n<a name=\"704\" href=\"#704\">704</a>     <em>/**<em>*</em></em>\n<a name=\"705\" href=\"#705\">705</a> <em>     * Forward the response from the execution of a method to a servlet</em>\n<a name=\"706\" href=\"#706\">706</a> <em>     * @param method the method that has been executed</em>\n<a name=\"707\" href=\"#707\">707</a> <em>     * @param response the servlet response to which the execution should be reported </em>\n<a name=\"708\" href=\"#708\">708</a> <em>     */</em>\n<a name=\"709\" href=\"#709\">709</a>     <strong>private</strong> <strong>void</strong> forwardResponse(HttpMethod method, HttpServletResponse response) {\n<a name=\"710\" href=\"#710\">710</a>         <em class=\"comment\">// clear the existing response stuff, if it would work</em>\n<a name=\"711\" href=\"#711\">711</a>         response.reset();\n<a name=\"712\" href=\"#712\">712</a> \n<a name=\"713\" href=\"#713\">713</a>         <em class=\"comment\">// Jetty makes us do this</em>\n<a name=\"714\" href=\"#714\">714</a>         response.setHeader(HttpFields.__CacheControl, <strong>null</strong>);\n<a name=\"715\" href=\"#715\">715</a>         response.setHeader(HttpFields.__Connection, <strong>null</strong>);\n<a name=\"716\" href=\"#716\">716</a>        \tresponse.setHeader(HttpFields.__Date, <strong>null</strong>);\n<a name=\"717\" href=\"#717\">717</a>         response.setHeader(HttpFields.__Pragma, <strong>null</strong>);\n<a name=\"718\" href=\"#718\">718</a>         response.setHeader(HttpFields.__ProxyConnection, <strong>null</strong>);\n<a name=\"719\" href=\"#719\">719</a>         response.setHeader(HttpFields.__Trailer, <strong>null</strong>);\n<a name=\"720\" href=\"#720\">720</a>         response.setHeader(HttpFields.__TransferEncoding, <strong>null</strong>);\n<a name=\"721\" href=\"#721\">721</a>         response.setHeader(HttpFields.__Upgrade, <strong>null</strong>);\n<a name=\"722\" href=\"#722\">722</a>         response.setHeader(HttpFields.__Via, <strong>null</strong>);\n<a name=\"723\" href=\"#723\">723</a>         response.setHeader(HttpFields.__Warning, <strong>null</strong>);\n<a name=\"724\" href=\"#724\">724</a>         response.setHeader(HttpFields.__Allow, <strong>null</strong>);\n<a name=\"725\" href=\"#725\">725</a>         response.setHeader(HttpFields.__ContentEncoding, <strong>null</strong>);\n<a name=\"726\" href=\"#726\">726</a>         response.setHeader(HttpFields.__ContentLanguage, <strong>null</strong>);\n<a name=\"727\" href=\"#727\">727</a>         response.setHeader(HttpFields.__ContentLength, <strong>null</strong>);\n<a name=\"728\" href=\"#728\">728</a>         response.setHeader(HttpFields.__ContentLocation, <strong>null</strong>);\n<a name=\"729\" href=\"#729\">729</a>         response.setHeader(HttpFields.__ContentMD5, <strong>null</strong>);\n<a name=\"730\" href=\"#730\">730</a>         response.setHeader(HttpFields.__ContentRange, <strong>null</strong>);\n<a name=\"731\" href=\"#731\">731</a>         response.setHeader(HttpFields.__ContentType, <strong>null</strong>);\n<a name=\"732\" href=\"#732\">732</a>         response.setHeader(HttpFields.__Expires, <strong>null</strong>);\n<a name=\"733\" href=\"#733\">733</a>         response.setHeader(HttpFields.__LastModified, <strong>null</strong>);\n<a name=\"734\" href=\"#734\">734</a>         response.setHeader(HttpFields.__Accept, <strong>null</strong>);\n<a name=\"735\" href=\"#735\">735</a>         response.setHeader(HttpFields.__AcceptCharset, <strong>null</strong>);\n<a name=\"736\" href=\"#736\">736</a>         response.setHeader(HttpFields.__AcceptEncoding, <strong>null</strong>);\n<a name=\"737\" href=\"#737\">737</a>         response.setHeader(HttpFields.__AcceptLanguage, <strong>null</strong>);\n<a name=\"738\" href=\"#738\">738</a>         response.setHeader(HttpFields.__Authorization, <strong>null</strong>);\n<a name=\"739\" href=\"#739\">739</a>         response.setHeader(HttpFields.__Expect, <strong>null</strong>);\n<a name=\"740\" href=\"#740\">740</a>         response.setHeader(HttpFields.__Forwarded, <strong>null</strong>);\n<a name=\"741\" href=\"#741\">741</a>         response.setHeader(HttpFields.__From, <strong>null</strong>);\n<a name=\"742\" href=\"#742\">742</a>         response.setHeader(HttpFields.__Host, <strong>null</strong>);\n<a name=\"743\" href=\"#743\">743</a>         response.setHeader(HttpFields.__IfMatch, <strong>null</strong>);\n<a name=\"744\" href=\"#744\">744</a>         response.setHeader(HttpFields.__IfModifiedSince, <strong>null</strong>);\n<a name=\"745\" href=\"#745\">745</a>         response.setHeader(HttpFields.__IfNoneMatch, <strong>null</strong>);\n<a name=\"746\" href=\"#746\">746</a>         response.setHeader(HttpFields.__IfRange, <strong>null</strong>);\n<a name=\"747\" href=\"#747\">747</a>         response.setHeader(HttpFields.__IfUnmodifiedSince, <strong>null</strong>);\n<a name=\"748\" href=\"#748\">748</a>         response.setHeader(HttpFields.__KeepAlive, <strong>null</strong>);\n<a name=\"749\" href=\"#749\">749</a>         response.setHeader(HttpFields.__MaxForwards, <strong>null</strong>);\n<a name=\"750\" href=\"#750\">750</a>         response.setHeader(HttpFields.__ProxyAuthorization, <strong>null</strong>);\n<a name=\"751\" href=\"#751\">751</a>         response.setHeader(HttpFields.__Range, <strong>null</strong>);\n<a name=\"752\" href=\"#752\">752</a>         response.setHeader(HttpFields.__RequestRange, <strong>null</strong>);\n<a name=\"753\" href=\"#753\">753</a>         response.setHeader(HttpFields.__Referer, <strong>null</strong>);\n<a name=\"754\" href=\"#754\">754</a>         response.setHeader(HttpFields.__TE, <strong>null</strong>);\n<a name=\"755\" href=\"#755\">755</a>         response.setHeader(HttpFields.__UserAgent, <strong>null</strong>);\n<a name=\"756\" href=\"#756\">756</a>         response.setHeader(HttpFields.__XForwardedFor, <strong>null</strong>);\n<a name=\"757\" href=\"#757\">757</a>         response.setHeader(HttpFields.__AcceptRanges, <strong>null</strong>);\n<a name=\"758\" href=\"#758\">758</a>         response.setHeader(HttpFields.__Age, <strong>null</strong>);\n<a name=\"759\" href=\"#759\">759</a>         response.setHeader(HttpFields.__ETag, <strong>null</strong>);\n<a name=\"760\" href=\"#760\">760</a>         response.setHeader(HttpFields.__Location, <strong>null</strong>);\n<a name=\"761\" href=\"#761\">761</a>         response.setHeader(HttpFields.__ProxyAuthenticate, <strong>null</strong>);\n<a name=\"762\" href=\"#762\">762</a>         response.setHeader(HttpFields.__RetryAfter, <strong>null</strong>);\n<a name=\"763\" href=\"#763\">763</a>         response.setHeader(HttpFields.__Server, <strong>null</strong>);\n<a name=\"764\" href=\"#764\">764</a>         response.setHeader(HttpFields.__ServletEngine, <strong>null</strong>);\n<a name=\"765\" href=\"#765\">765</a>         response.setHeader(HttpFields.__Vary, <strong>null</strong>);\n<a name=\"766\" href=\"#766\">766</a>         response.setHeader(HttpFields.__WwwAuthenticate, <strong>null</strong>);\n<a name=\"767\" href=\"#767\">767</a>         response.setHeader(HttpFields.__Cookie, <strong>null</strong>);\n<a name=\"768\" href=\"#768\">768</a>         response.setHeader(HttpFields.__SetCookie, <strong>null</strong>);\n<a name=\"769\" href=\"#769\">769</a>         response.setHeader(HttpFields.__SetCookie2, <strong>null</strong>);\n<a name=\"770\" href=\"#770\">770</a>         response.setHeader(HttpFields.__MimeVersion, <strong>null</strong>);\n<a name=\"771\" href=\"#771\">771</a>         response.setHeader(HttpFields.__Identity, <strong>null</strong>);\n<a name=\"772\" href=\"#772\">772</a>         response.setHeader(HttpFields.__SoapAction, <strong>null</strong>);\n<a name=\"773\" href=\"#773\">773</a> \n<a name=\"774\" href=\"#774\">774</a>         <strong>boolean</strong>\t\tbuffered = false;\n<a name=\"775\" href=\"#775\">775</a>         <strong>int</strong>\t\t\tbufferSize = 0x1000;\n<a name=\"776\" href=\"#776\">776</a>         <strong>if</strong> (method instanceof GetMethod &amp;&amp; \n<a name=\"777\" href=\"#777\">777</a>             System.getProperty(<span class=\"string\">\"os.name\"</span>).indexOf(<span class=\"string\">\"Mac\"</span>) != -1) {\n<a name=\"778\" href=\"#778\">778</a>             <em class=\"comment\">// This gets the whole content and buffers it</em>\n<a name=\"779\" href=\"#779\">779</a>             byte[]\tbody = method.getResponseBody();\n<a name=\"780\" href=\"#780\">780</a>             <strong>if</strong> (body != <strong>null</strong> ) {\n<a name=\"781\" href=\"#781\">781</a> \t            buffered = <strong>true</strong>;\n<a name=\"782\" href=\"#782\">782</a> \t            bufferSize = body.length;\n<a name=\"783\" href=\"#783\">783</a>             }\n<a name=\"784\" href=\"#784\">784</a>         }\n<a name=\"785\" href=\"#785\">785</a> \t    response.setBufferSize(bufferSize);\n<a name=\"786\" href=\"#786\">786</a> \n<a name=\"787\" href=\"#787\">787</a>         <em class=\"comment\">// set status, which is different than header</em>\n<a name=\"788\" href=\"#788\">788</a>         response.setStatus(method.getStatusCode());\n<a name=\"789\" href=\"#789\">789</a>         \n<a name=\"790\" href=\"#790\">790</a> \t    <em class=\"comment\">// copy headers</em>\n<a name=\"791\" href=\"#791\">791</a>         Header[] headers = method.getResponseHeaders();\n<a name=\"792\" href=\"#792\">792</a>         <strong>for</strong>(<strong>int</strong> i = 0; i &lt; headers.length; ++i)\n<a name=\"793\" href=\"#793\">793</a>         {\n<a name=\"794\" href=\"#794\">794</a>             response.setHeader(headers[i].getName(), headers[i].getValue());\n<a name=\"795\" href=\"#795\">795</a>         }\n<a name=\"796\" href=\"#796\">796</a> \n<a name=\"797\" href=\"#797\">797</a>         <em class=\"comment\">// copy body</em>\n<a name=\"798\" href=\"#798\">798</a>         <strong>try</strong> {\n<a name=\"799\" href=\"#799\">799</a> \t\t    InputStream \tin = method.getResponseBodyAsStream();\n<a name=\"800\" href=\"#800\">800</a> \t\t    OutputStream \tout = response.getOutputStream();\n<a name=\"801\" href=\"#801\">801</a> \t\t    byte[] \t\t\tbuffer = <strong>new</strong> byte[2048];\n<a name=\"802\" href=\"#802\">802</a> \t\t    <strong>int</strong> \t\t\tlen = 0;\n<a name=\"803\" href=\"#803\">803</a> \t\t    <strong>int</strong>\t\t\t\twritten = 0;\n<a name=\"804\" href=\"#804\">804</a> \t\t    <strong>if</strong>(in != <strong>null</strong>) {\n<a name=\"805\" href=\"#805\">805</a> \t\t        <strong>while</strong>((len = in.read(buffer, 0, buffer.length)) != -1) {\n<a name=\"806\" href=\"#806\">806</a> \t\t            <strong>try</strong> {\n<a name=\"807\" href=\"#807\">807</a> \t\t                out.write(buffer, 0, len);\n<a name=\"808\" href=\"#808\">808</a> \t\t                written += len;\n<a name=\"809\" href=\"#809\">809</a> \t\t            }\n<a name=\"810\" href=\"#810\">810</a> \t\t            <strong>catch</strong> (Exception se) {\n<a name=\"811\" href=\"#811\">811</a> \t\t                <strong>if</strong> (se instanceof EOFException &amp;&amp; buffered) {\n<a name=\"812\" href=\"#812\">812</a> \t\t                    <em class=\"comment\">// ignore this exception for GET method on Mac. </em>\n<a name=\"813\" href=\"#813\">813</a> \t\t                    <em class=\"comment\">// The Mac DavFS client switches to another socket.</em>\n<a name=\"814\" href=\"#814\">814</a> \t\t                    <em class=\"comment\">// Let Jetty handle it</em>\n<a name=\"815\" href=\"#815\">815</a> \t\t                }\n<a name=\"816\" href=\"#816\">816</a> \t\t                <strong>else</strong> {\n<a name=\"817\" href=\"#817\">817</a> \t\t                    Utils.handleException(se);\n<a name=\"818\" href=\"#818\">818</a> \t\t                }\n<a name=\"819\" href=\"#819\">819</a> \t\t            }\n<a name=\"820\" href=\"#820\">820</a> \t\t        }\n<a name=\"821\" href=\"#821\">821</a> \t\t        in.close();\n<a name=\"822\" href=\"#822\">822</a> \t\t    }\n<a name=\"823\" href=\"#823\">823</a> \t\t    <strong>else</strong> <strong>if</strong>(method instanceof XMLResponseMethodBase) {\n<a name=\"824\" href=\"#824\">824</a> \t\t        <em class=\"comment\">// Slide WebDAV lib methods do not fill ResponseBodyAsStream</em>\n<a name=\"825\" href=\"#825\">825</a> \t\t        Document d = ((XMLResponseMethodBase)method).getResponseDocument();\n<a name=\"826\" href=\"#826\">826</a> \t\t        <em class=\"comment\">// response might be empty, even for a so-called XMLResponseMethodBase </em>\n<a name=\"827\" href=\"#827\">827</a> \t\t        <strong>if</strong> (d != <strong>null</strong>)\n<a name=\"828\" href=\"#828\">828</a> \t\t            RepositoryUtils.writeXMLResponse(d, out);\n<a name=\"829\" href=\"#829\">829</a> \t\t    }\n<a name=\"830\" href=\"#830\">830</a> \t\t    out.flush();\n<a name=\"831\" href=\"#831\">831</a> \t\t    out.close();\n<a name=\"832\" href=\"#832\">832</a>         }\n<a name=\"833\" href=\"#833\">833</a>         <strong>catch</strong> (Exception e) {\n<a name=\"834\" href=\"#834\">834</a>             Utils.handleException(e);\n<a name=\"835\" href=\"#835\">835</a>         }\n<a name=\"836\" href=\"#836\">836</a> \t}\n<a name=\"837\" href=\"#837\">837</a> }\n</pre>\n<hr/><div id=\"footer\">This page was automatically generated by <a href=\"http://maven.apache.org/\">Maven</a></div></body>\n</html>\n\n", "id": 34325.0}