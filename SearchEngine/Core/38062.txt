{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 192D Planar Maps Ester Ezra Eyal Flato Efi Fogel Dan Halperin Iddo Hanniel Sariel Har Peled Shai Hirsch Oren Nechushtan and Ron Wein 19 1 Introduction Planar maps are embeddings of topological maps into the plane A planar map subdivides the plane into vertices edges and faces The vertices edges and faces of a subdivision are the embeddings of their topological map counterparts into the plane such that 1 each vertex is embedded as a planar point 2 each edge is embedded as a bounded x monotone curve and does not contain vertices in its interior and 3 each face is a maximal connected region of the plane that does not contain edges and vertices in its interior Figure A planar map induced by 14 circles of 53 faces one of which is unbounded 1 6 edges and 59 vertices The Planar map 2 Dcel Traits class is derived from the Topological map Dcel class While the Topological map Dcel base class provides the necessary combinatorial related capabilities the Planar map 2 Dcel Traits class provides all the geometric related capabilities required to maintain planar maps of interior disjoint x monotone curves and perform geometric queries such as point location In this chapter we review the data and functionality added to the Planar map 2 Dcel Traits class over that of the Topological map Dcel class The combinatorial capabilities of the base class are covered in chapter Topological Maps Figure A portion of the planar map depicted in Figure with some of the DCEL records that represent it ftilde is the unbounded face The half edge e and its twin e correspond to a circular arc that connects the vertices v1 and v2 and separates the face f1 from f2 The predecessors and successors of e and e are also shown note that e together with its predecessor and successor half edges form a closed chain representing the boundary of f1 lightly shaded Also note that the face f3 darkly shaded has a more complicated structure as it contains a hole in its interior 19 1 1 Terms and Definitions Before we expose a code fragment that manipulates a planar map let us define precisely some of the terms used here after Curve the image of a continuous 1 1 mapping into the plane of any one of the following the closed unit interval arc the open unit interval unbounded curve or the unit circle closed curve In all cases a curve is non self intersecting Segments lines rays conic sections1 are examples of curves X monotone curve a curve that intersects any vertical line in at most one point or a vertical segment Face a maximal connected region of the plane that does not contain any vertex or edge We consider a face to be open and its boundary is formed by vertices and halfedges of the subdivision The halfedges are oriented around a face so that the face they bound is to their left This means that halfedges on the outer boundary of a face are traversed in counterclockwise order and halfedges on the inner boundaries holes of a face are traversed in clockwise order Halfedges around a vertex are also traversed in clockwise order Point Location a query applied to a planar map Given a map and a query point p find the region of the map containing p 19 1 2 A simple Program The simple program listed below constructs a planar map of three segments include CGAL Cartesian h include CGAL MP Float h include CGAL Quotient h include CGAL Pm segment traits 2 h include CGAL Pm default dcel h include CGAL Planar map 2 h typedef CGAL Quotient CGAL MP Float Number type typedef CGAL Cartesian Number type Kernel typedef CGAL Pm segment traits 2 Kernel Traits typedef Traits Point 2 Point 2 typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Pm default dcel Traits Dcel typedef CGAL Planar map 2 Dcel Traits Planar map int main Planar map pm X monotone curve 2 cv 3 Point 2 a1 a2 4 a3 4 cv X monotone curve 2 a1 a2 cv 1 X monotone curve 2 a2 a3 cv 2 X monotone curve 2 a3 a1 pm insert cv cv 3 return The constructed planar map is instantiated with the Pm segment traits 2 traits class to handle segments only It consists of two faces a triangular face and the unbounded face This program is not very useful as it ends immediately after the planar map is constructed Let us add something useful such as querying whether a point is located in the interior of the single face of our planar map All we need to do is issue the following statements Point 2 p 1 1 typedef Planar map Locate type lt void pm locate p lt if lt Planar map FACE std cout Point location failed std endl else std cout Point location passed std endl The information returned from the locate function is not analyzed further as this program is presented to illustrates a simple usage only Let us make our simple example a bit more interesting and draw the planar map with Qt as exemplified in the code fragments below First we must add the following include directives include qapplication h include CGAL IO Qt widget h include CGAL IO Pm Window stream h Next we create a Qt widget QApplication app argc argv CGAL Qt widget widget app setMainWidget widget widget resize 4 4 widget set window 5 4 5 5 4 5 widget show Now we can send the planar map to a Qt widget after constructing one ws pm 19 2 Software Design The Planar map 2 Dcel Traits class is parameterized with two objects The Dcel object maintains a doubly connected edge list that represents the underlying topological data structure The Traits object provides the geometric functionality and is tailored to handle a specific family of curves It encapsulates the number type used and the coordinate representation This package contains traits classes that handle various types of curves e g segments polylines conics etc The combinatorial entities have a geometric mapping e g a vertex of a planar map has a Point data member and a halfedge has a X monotone curve 2 x monotone curve data member The Planar map 2 Dcel Traits class consists of a three other components 1 It includes a set of interface functions that allow you to construct modify query save and restore a planar map 2 It is parameterized with a traits concept class that defines the abstract interface between planar maps and the primitives they use and 3 some of its constructors allow you to choose between various point location strategies The point location strategy has a significant impact not only on the performance of point location queries but also on the performance of the operations that modify the planar map 19 2 1 Operations The set of operations you can apply to a planar map is divided into four subsets namely constructors modifiers queries and input output operations Construction A default constructor as well as a copy constructor are available However if you want to override the default point location strategy you must provide the strategy you choose as the single parameter to the constructor See section for further information Modification Once a planar map has been constructed you can insert an x monotone curve or a collection of x monotone curves into the map remove a curve already in the map split a curve already in the map into two curves and merge two curves already in the map given that the resulting curve can be handled by the traits class All these operations can be repeated and performed at any order Insertion of a collection of x monotone curves into a planar map that is not empty is not supported yet However the aggregate insertion of a collection of curves into an empty map is drastically more efficient than the incremental insertion of the curves one at a time as the aggregate insertion exploits a dedicated efficient sweep line algorithm Notice that the traits function curves compare y at x left is not required nor are the point reflect in x and y and curve reflect in x and y functions if aggregate insertion is the only modification performed and no queries are performed When additional information detailed below is available special insertion function can be used to expedite the insertion of a single curve This information may consists of one of the following 1 the face containing the curve to be inserted 2 the vertex containing a curve endpoint 3 the two vertices containing the two curve endpoints respectively or 4 the halfedges whose incident vertices contain the curve endpoints respectively The time complexity of the insertion operation reduces to O 1 when the incident halfedges are available and provided to the corresponding special insert function The code fragment listed below demonstrates the use of some of the special insertion functions Planar map pm Point 2 a a1 2 a2 1 2 X monotone curve 2 cv 3 cv X monotone curve 2 a a1 cv 1 X monotone curve 2 a1 a2 cv 2 X monotone curve 2 a2 a Planar map Halfedge handle e 3 e pm insert in face interior cv pm unbounded face e 1 pm insert from vertex cv 1 e e 2 pm insert at vertices cv 2 e 1 e twin Two halfedges are constructed as a result of inserting a single curve into a planar map One of the two new halfedges is returned from the applied function The insert and the insert in face interior insertion functions return the new halfedge directed in the same way as the input curve There are two flavors of insert from vertex and two falvours of insert at vertices functions One accepts vertices and the other accepts halfedges as additional information to expedite the insertion These functions return the new halfedge directed according to the additional information regardless of the input curve direction The insert from vertex functions return the new halfedge that has the given vertex as its source vertex when a vertex is provided When a halfedge is provided instead of a vertex the target vertex of the given halgedge is the source of the returned new halfedge The insert at vertices functions return the new halfedge that has the given vertices as its source and target vertices respectively when vertices are provided When halfedges are provided instead of vertices the target vertices of the given halgedges are the source and target of the returned new halfedge respectively The next example exploits the most efficient speacial insertion functions and provided to untangle their subtleties Figure contains the drawing of the planar map generated by the code fragment listed below Figure A planar map generated by special insertion functions Planar map pm X monotone curve 2 cv1 Point 2 1 Point 2 3 2 X monotone curve 2 cv2 Point 2 4 1 Point 2 3 2 X monotone curve 2 cv3 Point 2 4 1 Point 2 1 X monotone curve 2 cv4 Point 2 1 Point 2 4 1 X monotone curve 2 cv5 Point 2 3 2 Point 2 4 1 X monotone curve 2 cv6 Point 2 6 Point 2 4 1 X monotone curve 2 cv7 Point 2 4 1 Point 2 6 Halfedge handle h1 pm insert in face interior cv1 pm unbounded face Halfedge handle h2 pm insert in face interior cv2 pm unbounded face Halfedge handle h3 pm insert at vertices cv3 h2 twin h1 twin Halfedge handle h4 pm insert from vertex cv4 h1 twin Halfedge handle h5 pm insert at vertices cv5 h1 h4 Halfedge handle h6 pm insert from vertex cv6 h3 twin Halfedge handle h7 pm insert at vertices cv7 h5 h6 Queries In addition to the queries provided by the Topological map Dcel base class you can perform point location and vertical ray shoot queries and find out whether a given point is contained in a given face The point location and vertical ray shoot functions namely Halfedge handle locate const Point 2 p Locate type lt and Halfedge handle vertical ray shoot const Point 2 p Locate type lt bool up direction return the type of the feature that has been located through the Locate type reference parameter Figure contains the drawing of the planar map generated by example1 This example issues a vertical ray shoot query illustrated in the figure as well The code of this program is listed below Figure The map generated by example1 The constructed planar map is instantiated with the Pm segment traits 2 traits class to handle segments only The traits class is instanciated in turn with the CGAL Cartesian kernel The later is instanciated with the field of quotions of multi precision floating point as the number type The planar map consists of five segments that induce three faces After the construction of the map its validity is verified follwed by a vertical ray shoot file examples Planar map example1 C include short names h include CGAL Cartesian h include CGAL Quotient h include CGAL Pm segment traits 2 h include CGAL Pm default dcel h include CGAL Planar map 2 h include iostream include iterator include algorithm typedef CGAL Quotient long Number type typedef CGAL Cartesian Number type Kernel typedef CGAL Pm segment traits 2 Kernel Traits typedef Traits Point 2 Point 2 typedef Traits X monotone curve 2 X monotone curve 2 typedef CGAL Pm default dcel Traits Dcel typedef CGAL Planar map 2 Dcel Traits Planar map int main Create an instance of a Planar map Planar map pm X monotone curve 2 cv 5 Point 2 p 1 4 p1 5 7 p2 9 4 p3 5 1 Create the curves cv X monotone curve 2 p p1 cv 1 X monotone curve 2 p1 p2 cv 2 X monotone curve 2 p2 p3 cv 3 X monotone curve 2 p3 p cv 4 X monotone curve 2 p p2 std cout The curves of the map std endl std copy cv cv 5 std ostream iterator X monotone curve 2 std cout n std cout std endl Insert the curves into the Planar map std cout Inserting the curves to the map pm insert cv cv 5 std cout pm is valid map valid map invalid std endl std endl Shoot a vertical ray upward from p Point 2 p 4 3 Planar map Locate type lt std cout Upward vertical ray shooting from p std endl Planar map Halfedge handle e pm vertical ray shoot p lt true std cout returned the curve e curve oriented toward e target point std endl return The output of the program is the curves of the map 1 1 4 1 5 1 7 1 5 1 7 1 9 1 4 1 9 1 4 1 5 1 1 1 5 1 1 1 1 1 4 1 1 1 4 1 9 1 4 1 Inserting the curves to the map map valid Upward vertical ray shooting from 4 1 3 1 returned the curve 1 1 4 1 9 1 4 1 oriented toward 1 1 4 1 IO The Planar Map package supports saving restoring and drawing of planar maps Each traits class shipped with this package contains the necessary I O operators to save restore and draw the type of curves it handles and the type of the curve endpoint A simple textual format of a planar map representation can be written to the standard output with the Extractor operator defined for Planar map 2 The same format can be read from the standard input with the Inserter operator defined for Planar map 2 Add the include directive below to include these operator definitions include CGAL IO Pm iostream h Advanced formats such as XML based are currently considered but haven t been implemented yet nor has a binary format With the use of the Pm drawer class a planar map representation can be sent to a graphic stream such as CGAL Qt widget Postscript file or Geomview window Add the include directive below to include this class definition include CGAL IO Pm drawer h Drawing a planar map with Geomview or producing Postscript that represents a planar map can be done by applying the Inserter operator to the appropriate graphic stream and the planar map instance Add the corresponding include directive below to include any if these class definitions include CGAL IO Pm Postscript file stream h include CGAL IO Pm Geomview stream h If you intend to save restore or draw a planar map you must define I O operators for the point and curve types defined in your Traits classes in case these operations are not present The traits classes provided in the Planar Map packages e g Pm segment traits 2 and Pm conic traits 2 contain the appropriate definitions to save a textual representation of a planar map to the standard output restore it from the standard input and draw it to a CGAL window stream advanced 19 2 2 I O for User Defined Planar Maps and the I O Format If you wish to add your own attributes planar map components If those attributes are to be written as part of the planar map representation respectively are to be re read later a specialized reader scanner class writer class resp should be defined for the special planar map This is done preferably by making it a sub class of the class Pm file scanner Pm file writer resp and overriding all the relevant function for scanning writing resp the changed components After the definition of the inherited class you have to call the function read of Planar map resp the global function write pm with the inherited class as a parameter The same applies for extending the output graphic streams to include additional attributes only for this purpose a new drawer class has to be defined This is done preferably by making this class inherit the class Pm drawer In order to send the special planar map to the graphic stream one should call the global function draw pm with this class and their planar map as parameters Format The chosen format does not follow an existing standard format Generally the format contains lists of the components of a planar map followed by each other For each component we write its associative geometric information and some topological information in order to be able to update the Dcel efficiently The format is detailed below The data begins with a line of three integer values specifying the number of vertices halfedges and faces in the planar map The vertices list each component in the vertices list contains the point of its associative vertex The halfedges list each halfedge component is written by an index indicating the vertex origin of the halfedge and a curve specifying the halfedge curve The faces list each component in the faces list contains its outer boundary if the face is bounded and a list of its holes which can be empty in case the face has no holes The format of the outer boundary is the number of halfedges of its connected component followed by the indices indicating the halfedges of that component those indices have the same order of the halfedges on the connected component The format of the list of the holes is first the number of holes followed by the connected components per each hole the format of each connected components resembles the format of the outer boundary specified above Lines beginning with serve as comments and are ignored The format does not differentiate between spaces and new lines except new lines which belong to commented lines And hence writing the planar map in one single line having no comments is also considered legal If you would like to keep the commented lines they may write all the components between two consecutive commented lines in one single line The current format may not be comfortable for a user to read because of the extensive use of indices You can print a planar map in a verbose format shorthand for verbose mode format The skeleton of the verbose format is the same However in order for the output to be clearer for a human reader points and halfedges are explicitly written rather than being represented by indices Also the direction of the halfedges are printed in a more convenient way to read This verbose format cannot be scanned by the reading functions of Planar map 2 Example The example below presents a representation of a planar map containing one triangle with the coordinates 1 1 and 2 The Planar map 2 instance that was used to produce this example was templated with the Pm segment traits 2 class which in turn was templated with the representation class Cartesian leda rational The first line specifies that the planar map has three vertices six halfedges and 2 faces the triangle and the unbounded face The list of vertices each represented by its associated point follows as shown in the output example The next list is the one of halfedges each component is represented by its index 1 or 2 in the vertices list and its associated segment The faces list is presented next It starts with the unbounded face having one hole which is the triangle this connected component specifies that the hole has three halfedges with the indices 4 and 3 The next face presenting the triangle is written in the same manner Printing Planar map Printing number of vertices halfedges and faces in Planar map 3 6 2 3 vertices 1 1 1 1 1 1 2 1 1 6 halfedges 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 2 1 1 1 1 2 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 3 4 3 finish writing face writing face outer ccb number halfedges on outer boundary 3 5 2 1 number of holes finish writing face End of Planar map 19 2 3 Example of User Defined I O Functions The following program demonstrates the usage of I O functions while users have an additional attribute in their planar map The attribute chosen here is adding an associative color to each vertex First the program extends the Dcel to maintain this attribute Second the program extends the Pm file writer class to handle the newly defined vertex It simply overrides the functions for writing a vertex to print the color of the vertex as well Finally the main function defines an empty Planar map reads it from the standard input stream and then set all vertices colors It then defines an object of its extended writer class and parameterize the function write pm with that object file examples Planar map example1 C include CGAL Cartesian h include CGAL Quotient h include CGAL Pm default dcel h include CGAL Planar map 2 h include CGAL Pm segment traits 2 h include CGAL IO Pm iostream h include CGAL IO write pm h include iostream include string template class Pt class Pm my vertex public CGAL Pm vertex base Pt public Pm my vertex CGAL Pm vertex base Pt void set color const std string c color c std string get color const return color private std string color building new dcel with my vertex base template class Traits class Pm my dcel public CGAL Pm dcel Pm my vertex typename Traits Point 2 CGAL Pm halfedge base typename Traits X monotone curve 2 CGAL Pm face base public Creation Pm my dcel extend the drawer to print the color as well template class PM class Pm my file writer public CGAL Pm file writer PM public typedef typename PM Vertex handle Vertex handle typedef typename PM Vertex const handle Vertex const handle typedef typename PM Vertex iterator Vertex iterator typedef typename PM Vertex const iterator Vertex const iterator Pm my file writer std ostream o const PM pm bool verbose false CGAL Pm file writer PM o pm verbose void write vertex Vertex const handle v const this out v point this out v get color std endl typedef CGAL Quotient int NT typedef CGAL Cartesian NT Kernel typedef CGAL Pm segment traits 2 Kernel Traits typedef Pm my dcel Traits Dcel typedef CGAL Planar map 2 Dcel Traits Planar map typedef Planar map Vertex iterator Vertex iterator int main Planar map pm std cin pm std cout Demonstrating definition of user attributes for Planar map components std endl std endl std endl Update the colors for halfedge and vertex for Vertex iterator v iter pm vertices begin v iter pm vertices end v iter v iter set color BLUE Print the map to output stream with the user attributes std cout Printing the Planar map std endl std cout std endl Pm my file writer Planar map writer std cout pm CGAL write pm pm writer std cout return The input of the program is a text file presenting the Planar map Printing Planar map Printing number of vertices halfedges and faces in Planar map 3 6 2 3 vertices 1 1 1 1 1 1 2 1 1 6 halfedges 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 2 1 1 1 1 2 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 3 4 3 finish writing face writing face outer ccb number halfedges on outer boundary 3 5 2 1 number of holes finish writing face End of Planar map The output is the Planar map written in both formats non verbose and verbose In addition the two lists non verbose and verbose of halfedges are written Demonstrating definition of user attributes for Planar map components Printing the Planar map Begin Planar Map Number of vertices halfedges and faces in Planar map 3 6 2 3 vertices 1 1 1 1 BLUE 1 1 BLUE 2 1 1 BLUE 6 halfedges 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 2 1 1 1 1 2 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 3 4 3 finish writing face writing face outer ccb number halfedges on outer boundary 3 5 2 1 number of holes finish writing face End Planar Map More details are given in sections File header Pm file scanner Planar map Pm file writer Planar map and Pm drawer Planar map advanced 19 2 4 Traits Classes The planar map class is parameterized with the concept class PlanarMapTraits 2 that defines the abstract interface between planar maps and the primitives they use A model of this concept must define two types of objects namely X monotone curve 2 and Point 2 where the type of the endpoints of an X monotone curve 2 type curve is Point 2 In addition the traits class must contain the implementation of a set of operations on these two types We supply a default traits class for segments namely Pm segment traits 2 Kernel where Kernel is a kernel representation type e g Homogeneous or Cartesian This traits class handles finite line segments in the plane In this class the X monotone curve 2 and Point 2 types are defined as the CGAL kernel types Kernel Segment 2 and Kernel Point 2 respectively and the CGAL kernel operations on these types are exploited to implement the required functions The leda rat kernel traits class exploits LEDA s rational kernel and its efficient predicates As a model that conforms to the CGAL kernel concept it can be injected to the Pm segment traits 2 Kernel class leda rat kernel traits class is available as an external package Models of PlanarMapTraits 2 are meant to serve as arguments for the respective template parameter of CGAL Planar map 2 Dcel Traits However it should be noted that each model of PlanarMapTraits 2 defines a family of curves and primitive geometric operations thereof Sometimes the only implementation available for the manipulation of a certain family of curves is one of the supplied traits classes A scenario where one uses a traits class object to manipulate such curves without maintaining planar maps is certainly possible ArrangementTraits 2 concept is a refinements of the PlanarMapWithIntersectionsTraits 2 concept and the latter is a refinement of the PlanarMapTraits 2 concept Therefore all models of the formers are models of the latter There are several supplied traits classes for the Arrangement that you can use These classes are described at the end of Chapter 2D Arrangements 19 2 5 Point Location Strategies Some of the basic operations on planar maps are queries such as what is the location of a point in the map or which curve is vertically above the point The answer to these geometric queries can be obtained through the use of the Planar Map package along with several algorithms available for you to choose from The class has a point location function namely the locate function that determines which feature of the map contains a given query point which is also used internally in the insert function You can define which algorithm to use in the point location queries This is done with a point location class passed to the map in the constructor The class passed should be derived from the base class Pm point location base which is a pure virtual base class that defines the interface between the algorithm implemented by the users and the planar map This follows the known Strategy pattern GHJV95 The indirection overhead due to the virtual functions is negligible since the optimal point location algorithm e g the one implemented in our default strategy takes logn time We have derived three concrete classes for point location strategies the trapezoid randomized incremental construction strategy based on a trapezoidal decomposition of the map the naive strategy which goes over all the vertices and halfedges of the planar map and the walk along a line strategy which improves the naive one by walking only along the zone of the vertical ray emanating from the query point All three strategies are classes that inherit Pm point location base Planar map More details are give in sections Pm trapezoid ric point location Planar map Pm naive point location Planar map and Pm walk along a line point location Planar map Trade off Issues The main trade off among the three strategies implemented is between time and storage Using the naive or walk strategies takes more time but saves storage space Another trade off depends on the need for point location queries compared to the need for other functions If you do not need point location queries but do need other modifying functions e g remove edge split edge and merge edge then using the naive or walk strategies is preferable Note that using the insert function invokes the point location query therefore when using the naive or walk strategies it is recommended to use the specialized insertion functions insert in face interior insert from vertex and insert at vertices For example when using the planar map to represent polygons e g when computing boolean operations on polygons it might be preferable to use the walk strategy with the specialized insertion functions There are two modes of the default strategy which enables you to choose whether preprocessing should be performed or not read more in the section stated above There is a trade off between those two modes If preprocessing is not used the building of the structure is faster However for some input sequences the structure might be unbalanced and therefore queries and updates might take longer especially if many removal and split operation are performed 19 3 Implementation 19 3 1 Robustness The Planar map 2 Dcel Traits class can handle all inputs and requires no general position assumption Calculations are exact and leave no place for errors of any kind Nevertheless since the input curves are disjoint in their interiors no construction of intersection points are performed Therefore filtered kernel can definitely expedite the various operations 19 3 2 Programming Tips This section presents some tips on how to tune CGAL Planar map 2 Dcel Traits for best performance Before we list specific tips we remind you that compiling programs with debug flags turned off and with optimization flags turned on significantly reduces running time The default point location strategy i e using trapezoidal decomposition is the fastest one when queries are concerned However since it has to build a search structure it might slow down the incremental building process of the map If it is known in advance that there will not be many point location or vertical ray shoot queries use another point location strategy such as the walk or simple strategies which does not slow down the building process no search structure is being built Prior knowledge of the combinatorial structure of the map can be used to accelerate insertion time The specialized insertion functions i e insert in face interior insert from vertex or insert at vertices should be used according to this information The insert function performs point location queries and then calls one of the other update functions and therefore takes more time The function insert in face interior even takes constant time The other two are linear in the worst case but should be much faster most of the time Insertion of a polygon which is represented by a list of segments along its boundary into an empty planar map should be done in the following way First some segment should be inserted using insert in face interior with the unbounded face Then a segment with a common end point can be inserted using insert from vertex and so on with the rest of the segments but last The last segment can be inserted using insert at vertices since both it endpoints are represented as vertices of the map and are known in advanced If you have LEDA installed it is recommended to use the specialized traits classes Pm leda segment traits 2 or Arr leda polyline traits These traits classes are much faster since they are specialized for LEDA s rational geometric kernel Note that these traits classes are models of PlanarMapTraits 2 since they model its refinement the ArrangementTraits 2 concept 19 4 Example Programs 19 4 1 Example of IO functions The following program demonstrates the use of I O functions provided for planar maps First the program demonstrates a trivial use of the I O functions it defines an empty instance of Planar map 2 reads the planar map representation text from the standard input stream and then prints the resulting planar map to the standard output stream Second it presents the usage of the verbose format by defining Pm file writer with the verbose flag set to true and then calls the function write pm A usage of the interface of the class Pm file writer is also presented by calling its function write halfedges which prints all the halfedges of the map In addition the program presents the operators writing the resulting Planar map to a postscript file when LEDA is installed The demo for the planar map package makes use of the output operator of Planar map 2 Dcel Traits to a window stream see at CGAL ROOT demo Planar map demo C file examples Planar map example9 C include short names h include CGAL Cartesian h include CGAL Quotient h include CGAL Pm default dcel h include CGAL Planar map 2 h include CGAL Pm segment traits 2 h include CGAL IO write pm h include CGAL IO Pm iostream h include iostream define CGAL POSTSCRIPT if defined CGAL USE LEDA defined CGAL POSTSCRIPT include CGAL IO Pm Postscript file stream h endif typedef CGAL Quotient int NT typedef CGAL Cartesian NT Kernel typedef CGAL Pm segment traits 2 Kernel Traits typedef CGAL Pm default dcel Traits Dcel typedef CGAL Planar map 2 Dcel Traits Planar map typedef CGAL Pm file writer Planar map Pm writer int main Planar map pm Pm writer verbose writer std cout pm true Pm writer writer std cout pm std cout Demonstrating a trivial use of IO functions std endl std endl std cin pm std cout pm std cout std endl std cout Presenting the use of verbose format std endl std cout std endl CGAL write pm pm verbose writer std cout std cout std endl std cout Demonstrating the use of the writer class interface std endl std cout Printing all halfedges in non verbose format std endl std endl writer write halfedges pm halfedges begin pm halfedges end std cout std endl std cout Printing all halfedges in a verbose format std endl std endl verbose writer write halfedges pm halfedges begin pm halfedges end if defined CGAL USE LEDA defined CGAL POSTSCRIPT Print to Postscript file CGAL Postscript file stream LPF 5 5 pm ps LPF init 3 3 3 LPF set line width 1 LPF pm endif return The input of the program is a text file which holds the planar map representation in a special format which is presented in the reference pages of the the Planar Map package This representation appears as the first block in the output file The output is the Planar map includes both formats non verbose and verbose In addition the two lists non verbose and verbose of halfedges are written Demonstrating a trivial use of IO functions Begin Planar Map Number of vertices halfedges and faces in Planar map 3 6 2 3 vertices 1 1 1 1 1 1 2 1 1 6 halfedges 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 2 1 1 1 1 2 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 3 4 3 finish writing face writing face outer ccb number halfedges on outer boundary 3 5 2 1 number of holes finish writing face End Planar Map Presenting the use of verbose format Begin Planar Map Number of vertices halfedges and faces in Planar map 3 6 2 3 vertices 1 1 1 1 1 1 2 1 1 6 halfedges 1 1 1 1 1 1 towards 1 1 1 1 1 1 1 1 1 1 towards 1 1 1 1 1 1 2 1 1 towards 1 1 1 1 1 1 1 1 2 1 1 towards 2 1 1 2 1 1 1 1 towards 1 1 2 1 1 1 1 towards 2 1 1 2 faces writing face UNBOUNDED number halfedges on outer boundary number of holes 1 inner ccb number halfedges on inner boundary 3 2 1 1 1 1 towards 1 1 1 1 1 1 1 1 towards 1 1 1 1 1 1 1 1 2 1 1 towards 2 1 1 finish writing face writing face outer ccb number halfedges on outer boundary 3 2 1 1 1 1 towards 2 1 1 1 1 1 1 2 1 1 towards 1 1 1 1 1 1 1 1 1 1 towards 1 1 number of holes finish writing face End Planar Map Demonstrating the use of the writer class interface Printing all halfedges in non verbose format 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 2 1 1 1 1 Printing all halfedges in a verbose format 1 1 1 1 1 1 towards 1 1 1 1 1 1 1 1 1 1 towards 1 1 1 1 1 1 2 1 1 towards 1 1 1 1 1 1 1 1 2 1 1 towards 2 1 1 2 1 1 1 1 towards 1 1 2 1 1 1 1 towards 2 1 1 Footnotes 1 A conic section is the nondegenerate curve generated by the intersections of a plane with one or two nappes of a cone Next chapter 2D Planar Maps Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Planar_map/Chapter_main.html", "title": "2d planar maps", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Planar_map/main.tex' -->\n<html> <head>  \n<title>2D Planar Maps</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_19\"></a>\n  \n<h1>Chapter 19<BR>2D Planar Maps</h1>\n\n<A NAME=\"I1_ChapterPlanarMap\"></A>\n<EM>Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Sariel Har-Peled, Shai Hirsch, Oren Nechushtan, and Ron Wein</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>19.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n\n<A NAME=\"PM_sec:intro\"></A>\n<P>\n\n<I>Planar maps</I> are embeddings of <I>topological maps</I> into the\nplane. A planar map subdivides the plane into vertices, edges, and\nfaces. The vertices, edges, and faces of a subdivision are the\nembeddings of their <I>topological map</I> counterparts into the plane,\nsuch that (1) each vertex is embedded as a planar point, (2) each edge\nis embedded as a bounded <MATH><I>x</I></MATH>-monotone curve, and does not contain\nvertices in its interior, and (3) each face is a maximal connected\nregion of the plane that does not contain edges and vertices in its\ninterior.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A planar map induced by 14 circles of 53 faces\n  (one of which is unbounded), 106 edges, and 59 vertices.\n<A NAME=\"PM_sec:rose_14\"></A>\n<P>\n\n<center>\n  <img src=\"rose_14.gif\"  border=0 alt=\"rose shaped planar-map\">\n</center>\n<P>\n\nThe <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> class is derived from the\n<I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;</I> class. While the\n<I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;</I> base class provides the necessary\ncombinatorial-related capabilities, the\n<I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> class provides all the\ngeometric-related capabilities required to maintain <I>planar maps</I>\nof interior-disjoint <MATH><I>x</I></MATH>-monotone curves, and perform\ngeometric queries, such as point location.\n<P>\n\nIn this chapter we review the data and functionality added\nto the <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> class over that of the \n<I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;</I> class. The combinatorial capabilities of\nthe base class are covered in chapter &nbsp;<A HREF=\"../Topological_map/Chapter_main.html#I1_ChapterTopologicalMap\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>,\n<I>Topological Maps</I>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A portion of the planar map depicted in Figure&nbsp;<A HREF=\"Chapter_main.html#PM_sec:rose_14\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> with some of the D<SMALL>CEL</SMALL> records that represent it. <MATH><I>&ftilde;</I></MATH> is the unbounded face. The half-edge <MATH><I>e</I></MATH> (and its twin <MATH><I>e'</I></MATH>) correspond to a circular arc that connects the vertices <MATH><I>v<SUB>1</SUB></I></MATH> and <MATH><I>v<SUB>2</SUB></I></MATH> and separates the face <MATH><I>f<SUB>1</SUB></I></MATH> from <MATH><I>f<SUB>2</SUB></I></MATH>. The predecessors and successors of <MATH><I>e</I></MATH> and <MATH><I>e'</I></MATH> are also shown  -  note that <MATH><I>e</I></MATH>, together with its <A HREF=\"../STL_Extension_ref/Function_predecessor.html#Cross_link_anchor_1442\">predecessor</A> and <A HREF=\"../STL_Extension_ref/Function_successor.html#Cross_link_anchor_1444\">successor</A> half-edges form a closed chain representing the boundary of <MATH><I>f<SUB>1</SUB></I></MATH> (lightly shaded). Also note that the face <MATH><I>f<SUB>3</SUB></I></MATH> (darkly shaded) has a more complicated structure as it contains a hole in its interior.\n<A NAME=\"PM_sec:circ_dcel\"></A>\n<P>\n\n<center>\n  <img src=\"circ_dcel.gif\"  border=0 alt=\"rose shaped planar-map\">\n</center>\n<P>\n\n<h3>19.1.1&nbsp;&nbsp;&nbsp;Terms and Definitions</h3>\n\nBefore we expose a code fragment that manipulates a <I>planar\nmap</I>, let us define precisely some of the terms used here after.\n<P>\n\n<DL>\n<DT><B>Curve</B><DD> - the image of a continuous <MATH><I>1</I></MATH>-<MATH><I>1</I></MATH> mapping into the\nplane of any one of the following: the closed unit interval (arc), the\nopen unit interval (unbounded curve), or the unit circle (closed\ncurve). In all cases a curve is non self-intersecting. Segments,\nlines, rays, conic sections<A HREF=\"#Footnote_1\"><SUP>1</SUP></A> are examples of curves.\n<P>\n\n<DT><B><B><MATH><I>X</I></MATH></B>-monotone curve</B><DD> - a curve that intersects\nany vertical line in at most one point, or a vertical segment.\n<P>\n\n<DT><B>Face</B><DD> - a maximal connected region of the plane that does not\ncontain any vertex or edge. We consider a face to be open, and its\nboundary is formed by vertices and halfedges of the subdivision.\nThe halfedges are oriented around a face so that the face they bound \nis to their left. This means that halfedges on the outer boundary\nof a face are traversed in counterclockwise order, and halfedges on\nthe inner boundaries (holes) of a face are traversed in clockwise\norder. Halfedges around a vertex are also traversed in clockwise order.\n<P>\n\n<DT><B>Point Location</B><DD> - a query applied to a <I>planar map</I>. Given a\nmap and a query point <MATH><I>p</I></MATH>, find the region of the map containing <MATH><I>p</I></MATH>.\n</DL>\n<P>\n\n<h3>19.1.2&nbsp;&nbsp;&nbsp;A simple Program</h3>\n\nThe simple program listed below constructs a planar map of three segments\n<P>\n\n<PRE>\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/Pm_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;    Number_type;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;Number_type&gt;      <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_801\">CGAL::Pm_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Traits;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                   <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::X_monotone_curve_2        X_monotone_curve_2;\ntypedef CGAL::Pm_default_dcel&lt;Traits&gt;     Dcel;\ntypedef <A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_786\">CGAL::Planar_map_2</A>&lt;Dcel,Traits&gt;   Planar_map;\n\nint main()\n{\n  Planar_map pm;\n  X_monotone_curve_2 cv[3];\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> a1(0,0), a2(0,4), a3(4,0);\n \n  cv[0] = X_monotone_curve_2(a1,a2);\n  cv[1] = X_monotone_curve_2(a2,a3);\n  cv[2] = X_monotone_curve_2(a3,a1);\n  pm.insert(&amp;cv[0], &amp;cv[3]);\n\n  return 0;\n}\n</PRE>\n<P>\n\nThe constructed planar map is instantiated with the\n<I><A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A></I> traits class to handle segments only. It\nconsists of two faces, a triangular face and the unbounded face.\nThis program is not very useful, as it ends immediately after the\nplanar map is constructed. Let us add something useful, such as\nquerying whether a point is located in the interior of the single\nface of our planar map. All we need to do is issue the following\nstatements:\n<P>\n\n<PRE>\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(1,1);\n  typedef Planar_map::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> lt;\n  (void) pm.locate(p, lt);\n  if (lt != Planar_map::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">FACE</A>)\n    std::cout &lt;&lt; &quot;Point location failed!&quot; &lt;&lt; std::endl;\n  else\n    std::cout &lt;&lt; &quot;Point location passed!&quot; &lt;&lt; std::endl;\n</PRE>\n<P>\n\nThe information returned from the <I>locate()</I> function is\nnot analyzed further, as this program is presented to illustrates a\nsimple usage only.\n<P>\n\nLet us make our simple example a bit more interesting, and draw\nthe planar map with Qt, as exemplified in the code fragments below.\nFirst, we must add the following include directives:\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/qapplication.h\">qapplication.h</A>&gt;</I>\n<P>\n\n<BR>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Qt_widget.h\">CGAL/IO/Qt_widget.h</A>&gt;</I>\n<P>\n\n<BR>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Pm_Window_stream.h\">CGAL/IO/Pm_Window_stream.h</A>&gt;</I>\n<P>\n\nNext, we create a Qt widget:\n<P>\n\n<PRE>\n  QApplication app(argc, argv);\n  CGAL::Qt_widget widget;\n  app.setMainWidget(widget);\n  widget.resize(400,400);\n  widget.set_window(-0.5, 4.5, -0.5, 4.5);\n  widget.show();\n</PRE>\n<P>\n\nNow, we can send the planar map to a Qt widget after constructing\none::\n<P>\n\n<PRE>\n  ws &lt;&lt; pm;\n</PRE>\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>19.2&nbsp;&nbsp;&nbsp;Software Design</h2>\n\nThe <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> class is parameterized with two\nobjects. The <I>Dcel</I> object maintains a <I>doubly-connected edge list</I>\nthat represents the underlying topological data structure. The\n<I>Traits</I> object provides the geometric functionality, and is\ntailored to handle a specific family of curves. It encapsulates the\nnumber type used and the coordinate representation. This package\ncontains traits classes that handle various types of curves (e.g.,\nsegments, polylines, conics, etc.).\n<P>\n\nThe combinatorial entities have a geometric mapping, e.g.,\na vertex of a planar map has a <I>Point</I> data member and a halfedge\nhas a <I>X_monotone_curve_2</I> (x-monotone curve) data member.\n<P>\n\nThe <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> class consists of a three other\ncomponents. (1) It includes a set of interface functions that allow\nyou to construct, modify, query, save, and restore a planar map,\n(2) It is parameterized with a traits concept class that defines the\nabstract interface between planar maps and the primitives they use,\nand (3) some of its constructors allow you to choose between\nvarious point-location strategies. The point-location strategy has a\nsignificant impact not only on the performance of point-location\nqueries, but also on the performance of the operations that modify the\nplanar map.\n<P>\n\n<h3>19.2.1&nbsp;&nbsp;&nbsp;Operations</h3>\n\nThe set of operations you can apply to a planar map is divided into\nfour subsets, namely constructors, modifiers, queries, and\ninput/output operations.\n<P>\n\n<h4>Construction</h4>\n\nA default constructor as well as a copy constructor are\navailable. However, if you want to override the default point-location\nstrategy, you must provide the strategy you choose as the single\nparameter to the constructor. See section\n&nbsp;<A HREF=\"Chapter_main.html#PM_sec:point_location\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for further information.\n<P>\n\n<h4>Modification</h4>\n\nOnce a planar map has been constructed, you can insert an <MATH><I>x</I></MATH>-monotone\ncurve or a collection of <MATH><I>x</I></MATH>-monotone curves into the map, remove a\ncurve already in the map, split a curve already in the map into two\ncurves, and merge two curves already in the map, given that the\nresulting curve can be handled by the traits class. All these\noperations can be repeated and performed at any order.\n<P>\n\nInsertion of a collection of <MATH><I>x</I></MATH>-monotone curves into a planar map\nthat is not empty is not supported yet. However, the aggregate\ninsertion of a collection of curves into an empty map is drastically\nmore efficient than the incremental insertion of the curves one at a\ntime, as the aggregate insertion exploits a dedicated efficient sweep\nline algorithm. Notice, that the traits function\n<I>curves_compare_y_at_x_left()</I> is not required, nor are the\n<I>point_reflect_in_x_and_y()</I> and <I>curve_reflect_in_x_and_y()</I>\nfunctions, if aggregate insertion is the only modification performed\nand no queries are performed.\n<P>\n\nWhen additional information detailed below is available, special\ninsertion function can be used to expedite the insertion of a single\ncurve. This information may consists of one of the following: (1) the\nface containing the curve to be inserted, (2) the vertex containing a\ncurve endpoint, (3) the two vertices containing the two curve\nendpoints respectively, or (4) the halfedges whose incident vertices\ncontain the curve endpoints respectively. The time complexity of the\ninsertion operation reduces to <MATH><I>O(1)</I></MATH>, when the incident halfedges are\navailable and provided to the corresponding special insert function.\n<P>\n\nThe code fragment listed below demonstrates the use of some of the\nspecial insertion-functions.\n<P>\n\n<PRE>\n  Planar_map pm;\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> a0(0, 0), a1(2, 0), a2(1, 2);\n\n  X_monotone_curve_2 cv[3];\n  cv[0] = X_monotone_curve_2(a0, a1);\n  cv[1] = X_monotone_curve_2(a1, a2);\n  cv[2] = X_monotone_curve_2(a2, a0);\n\n  Planar_map::Halfedge_handle e[3];  \n  e[0] = pm.insert_in_face_interior(cv[0], pm.unbounded_face());\n  e[1] = pm.insert_from_vertex(cv[1], e[0]);\n  e[2] = pm.insert_at_vertices(cv[2], e[1], e[0]-&gt;twin());\n</PRE>\n<P>\n\nTwo halfedges are constructed as a result of inserting a single curve into a\nplanar map. One of the two new halfedges is returned from the applied function.\nThe <I>insert()</I> and the <I>insert_in_face_interior()</I> insertion functions\nreturn the new halfedge directed in the same way as the input curve. There are\ntwo flavors of <I>insert_from_vertex()</I> and two falvours of\n<I>insert_at_vertices()</I> functions. One accepts vertices and the other\naccepts halfedges as additional information to expedite the insertion. These\nfunctions return the new halfedge directed according to the additional\ninformation, regardless of the input-curve direction. The\n<I>insert_from_vertex()</I> functions return the new halfedge that has the given\nvertex as its source vertex, when a vertex is provided. When a halfedge is\nprovided instead of a vertex, the target vertex of the given halgedge is the\nsource of the returned new halfedge. The <I>insert_at_vertices()</I> functions\nreturn the new halfedge, that has the given vertices as its source and target\nvertices respectively, when vertices are provided. When halfedges are provided\ninstead of vertices, the target vertices of the given halgedges are the source\nand target of the returned new halfedge respectively.\n<P>\n\nThe next example exploits the most efficient speacial insertion-functions, and\nprovided to untangle their subtleties. Figure <A HREF=\"Chapter_main.html#PM_sec:insert_at\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> contains\nthe drawing of the planar map generated by the code fragment listed below.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>A planar map generated by special insertion functions\n<A NAME=\"PM_sec:insert_at\"></A>\n<P>\n\n<center>\n  <img src=\"insert_at.gif\"  border=0 alt=\"insert example output\">\n</center>\n<P>\n\n<PRE>\n  Planar_map pm;\n  X_monotone_curve_2 cv1(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1.0, 0.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(3.0, 2.0));\n  X_monotone_curve_2 cv2(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4.0, -1.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(3.0, -2.0));\n  X_monotone_curve_2 cv3(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4.0, -1.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1.0, 0.0));\n  X_monotone_curve_2 cv4(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1.0, 0.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4.0, 1.0));\n  X_monotone_curve_2 cv5(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(3.0, 2.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4.0, 1.0));\n  X_monotone_curve_2 cv6(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(6.0, 0.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4.0, -1.0));\n  X_monotone_curve_2 cv7(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4.0, 1.0), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(6.0, 0.0));\n\n  Halfedge_handle h1 = pm.insert_in_face_interior(cv1, pm.unbounded_face());\n  Halfedge_handle h2 = pm.insert_in_face_interior(cv2, pm.unbounded_face());\n  Halfedge_handle h3 = pm.insert_at_vertices(cv3, h2-&gt;twin(), h1-&gt;twin());\n  Halfedge_handle h4 = pm.insert_from_vertex(cv4, h1-&gt;twin());\n  Halfedge_handle h5 = pm.insert_at_vertices(cv5, h1, h4);\n  Halfedge_handle h6 = pm.insert_from_vertex(cv6, h3-&gt;twin());\n  Halfedge_handle h7 = pm.insert_at_vertices(cv7, h5, h6);\n</PRE>\n<P>\n\n<h4>Queries</h4>\n<P>\n\nIn addition to the queries provided by the <I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;</I>\nbase class, you can perform point location and vertical ray shoot\nqueries, and find out whether a given point is contained in a given\nface.\n<P>\n\nThe point location and vertical ray-shoot functions, namely\n<UL>\n<LI><I>Halfedge_handle locate(const <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> &amp; p , <A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> &amp; lt)</I>,\nand\n<LI><I> Halfedge_handle vertical_ray_shoot(const <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> &amp; p,                                           <A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> &amp; lt,                                          bool up_direction )</I>\n</UL>\nreturn the type of the feature that has been located through the\n<I><A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A></I> reference parameter.\n<P>\n\nFigure <A HREF=\"Chapter_main.html#PM_sec:shoot\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> contains\nthe drawing of the planar map generated by example1. This example issues \na vertical-ray shoot query illustrated in the figure as well. The code of this\nprogram is listed below.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The map generated by example1\n<A NAME=\"PM_sec:shoot\"></A>\n<P>\n\n<center>\n        <img src=\"pm_ray_shoot.gif\"  border=0 alt=\"Ray shoot example\">\n        <!--The map generated by the example program-->\n    </center>\n<P>\n\nThe constructed planar map is instantiated with the\n<I><A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A></I> traits class to handle segments only.\nThe traits class is instanciated in turn with the C<SMALL>GAL</SMALL> <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> kernel.\nThe later is instanciated with the field of quotions of multi-precision\nfloating-point as the number type. The planar map consists of five segments\nthat induce three faces. After the construction of the map, its validity\nis verified, follwed by a vertical-ray shoot.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Planar_map/example1.C\n\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/Pm_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>.h&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;long&gt;              Number_type;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;Number_type&gt;      <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_801\">CGAL::Pm_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Traits;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                   <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::X_monotone_curve_2        X_monotone_curve_2;\ntypedef CGAL::Pm_default_dcel&lt;Traits&gt;     Dcel;\ntypedef <A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_786\">CGAL::Planar_map_2</A>&lt;Dcel,Traits&gt;   Planar_map;\n\nint main()\n{\n  // Create an instance of a Planar_map:\n  Planar_map pm;\n  X_monotone_curve_2 cv[5];\n\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p0(1, 4), p1(5, 7), p2(9, 4), p3(5, 1);\n\n  // Create the curves:\n  cv[0] = X_monotone_curve_2(p0, p1);\n  cv[1] = X_monotone_curve_2(p1, p2);\n  cv[2] = X_monotone_curve_2(p2, p3);\n  cv[3] = X_monotone_curve_2(p3, p0);\n  cv[4] = X_monotone_curve_2(p0, p2);\n  \n  std::cout &lt;&lt; &quot;The curves of the map :&quot; &lt;&lt; std::endl;\n  std::copy(&amp;cv[0], &amp;cv[5],\n            std::ostream_iterator&lt;X_monotone_curve_2&gt;(std::cout, &quot;\\n&quot;));\n  std::cout &lt;&lt; std::endl;\n\n  // Insert the curves into the Planar_map:\n  std::cout &lt;&lt; &quot;Inserting the curves to the map ... &quot;;\n  pm.insert(&amp;cv[0], &amp;cv[5]);\n  std::cout &lt;&lt; ((pm.is_valid()) ? &quot;map valid!&quot; : &quot;map invalid!&quot;) &lt;&lt; std::endl\n            &lt;&lt; std::endl;\n  \n  // Shoot a vertical ray upward from p:\n  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(4, 3);\n  Planar_map::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> lt;\n\n  std::cout &lt;&lt; &quot;Upward vertical ray shooting from &quot; &lt;&lt; p &lt;&lt; std::endl; \n  Planar_map::Halfedge_handle e = pm.vertical_ray_shoot(p, lt, true);\n  std::cout &lt;&lt; &quot;returned the curve &quot; &lt;&lt; e-&gt;curve() &lt;&lt; &quot;, oriented toward &quot; \n  \t    &lt;&lt; e-&gt;target()-&gt;point() &lt;&lt; std::endl; \n  return 0;\n}\n\n</pre>\n<P>\n\nThe output of the program is:\n<P>\n\n<pre class=\"ExampleCode\">\nthe curves of the map :\n1/1 4/1 5/1 7/1\n5/1 7/1 9/1 4/1\n9/1 4/1 5/1 1/1\n5/1 1/1 1/1 4/1\n1/1 4/1 9/1 4/1\n\nInserting the curves to the map ... map valid!\n\nUpward vertical ray shooting from 4/1 3/1\nreturned the curve 1/1 4/1 9/1 4/1, oriented toward 1/1 4/1\n</pre>\n<P>\n\n<h4>IO</h4>\n\nThe <I>Planar Map</I> package supports saving, restoring, and drawing\nof planar maps. Each traits class shipped with this package contains\nthe necessary I/O operators to save, restore and draw the type of\ncurves it handles and the type of the curve endpoint.\n<P>\n\nA simple textual format of a <I>planar map</I> representation can be\nwritten to the standard output with the <I>Extractor</I> (<I> &gt;&gt; </I>)\noperator defined for <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A></I>. The same format can be read\nfrom the standard input with the <I>Inserter</I> (<I> &lt;&lt; </I>) operator\ndefined for <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A></I>. Add the include directive below to\ninclude these operator definitions,\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Pm_iostream.h\">CGAL/IO/Pm_iostream.h</A>&gt;</I>\n<P>\n\nAdvanced formats, such as XML-based, are currently considered, but\nhaven't been implemented yet, nor has a binary format.\n<P>\n\nWith the use of the <I><A HREF=\"../Planar_map_ref/Class_Pm_drawer.html#Cross_link_anchor_813\">Pm_drawer</A></I> class a <I>planar map</I>\nrepresentation can be sent to a graphic stream, such as\n<I>CGAL::Qt_widget</I>, Postscript file, or Geomview window.\nAdd the include directive below to include this class definition.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Pm_drawer.h\">CGAL/IO/Pm_drawer.h</A>&gt;</I>\n<P>\n\nDrawing a <I>planar map</I> with Geomview or producing Postscript that\nrepresents a planar map, can be done by applying the <I>Inserter</I>\noperator to the appropriate graphic stream and the planar map\ninstance. Add the corresponding include directive below, to include\nany if these class definitions.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Pm_Postscript_file_stream.h\">CGAL/IO/Pm_Postscript_file_stream.h</A>&gt;</I>\n<P>\n\n<BR>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Pm_Geomview_stream.h\">CGAL/IO/Pm_Geomview_stream.h</A>&gt;</I>\n<P>\n\nIf you intend to save, restore, or draw a planar map, you must\ndefine I/O operators for the point and curve types defined in your\n<I>Traits</I> classes, in case these operations are not present. The\ntraits classes provided in the <I>Planar Map</I> packages, e.g.,\n<I><A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A></I> and <I>Pm_conic_traits_2</I>,\ncontain the appropriate definitions to save a textual representation\nof a planar map to the standard output, restore it from the standard \ninput, and draw it to a C<SMALL>GAL</SMALL> window stream.\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n\n<h3>19.2.2&nbsp;&nbsp;&nbsp;I/O for User Defined Planar Maps and the I/O Format</h3>\n<P>\n\nIf you wish to add your own attributes planar map components. If\nthose attributes are to be written as part of the planar map\nrepresentation (respectively, are to be re-read later) a specialized\nreader (scanner) class (writer class, resp.) should be defined for the\nspecial planar map. This is done preferably by making it a sub class\nof the class <I><A HREF=\"../Planar_map_ref/Class_Pm_file_scanner.html#Cross_link_anchor_807\">Pm_file_scanner</A></I> (<I><A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_809\">Pm_file_writer</A></I>,\nresp.) and overriding all the relevant function for scanning (writing,\nresp.) the changed components.\n<P>\n\nAfter the definition of the inherited class, you have to call the\nfunction <I>read</I> of <I>Planar map</I> (resp., the global\nfunction <I><A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_811\">write_pm</A></I> ) with the inherited class as a\nparameter.\n<P>\n\nThe same applies for extending the output graphic streams to include\nadditional attributes only for this purpose a new <I>drawer</I> class\nhas to be defined.  This is done preferably by making this class\ninherit the class <I><A HREF=\"../Planar_map_ref/Class_Pm_drawer.html#Cross_link_anchor_813\">Pm_drawer</A></I>. In order to send the special\nplanar map to the graphic stream one should call the global function\n<I><A HREF=\"../Planar_map_ref/Function_draw_pm.html#Cross_link_anchor_815\">draw_pm</A></I> with this class and their planar map as parameters.\n<P>\n\n<b>Format</b>\n\n<A NAME=\"ccRef_Pm_IO_format\"></A>\nThe chosen format does not follow an existing standard format.\nGenerally, the format contains lists of the components of a planar map \nfollowed by each other. For each component we write its associative\ngeometric information and some topological information in order to be\nable to update the <I>Dcel</I> efficiently. The format is detailed\nbelow.\n<P>\n\n<OL>\n<P>\n\n<LI>The data begins with a line of three integer values specifying\nthe number of vertices, halfedges and faces in the planar map.\n<LI>The vertices list: each component in the vertices list contains\nthe point of its associative vertex. \n<LI>The halfedges list: each halfedge component is written by an\nindex indicating the vertex origin of the halfedge, and a curve\nspecifying the halfedge curve.\n<LI>The faces list: each component in the faces list contains its\nouter boundary, if the face is bounded, and a list of its holes which\ncan be empty in case the face has no holes. The format of the outer\nboundary is the number of halfedges of its connected component\nfollowed by the indices indicating the halfedges of that component,\nthose indices have the same order of the halfedges on the connected\ncomponent. The format of the list of the holes is first the number of\nholes followed by the connected components per each hole, the format\nof each connected components resembles the format of the outer\nboundary specified above.\n<LI>Lines beginning with '#' serve as comments and are ignored.\n<LI>The format does not differentiate between spaces and new lines, \nexcept new lines which belong to commented lines. \nAnd hence, writing the planar map in one single line having no comments is\nalso considered legal. If you would like to keep the commented\nlines, they may write all the components between two consecutive\ncommented lines in one single line.\n<P>\n\n</OL>\n<P>\n\nThe current format may not be comfortable for a user to read because\nof the extensive use of indices. You can print a planar map in a\nverbose format (shorthand for verbose mode format).  The skeleton of \nthe verbose format is the same. However, in order for the output to be\nclearer for a human reader points and halfedges are explicitly written\nrather than being represented by indices. Also the direction of the\nhalfedges are printed in a more convenient way to read. This verbose\nformat cannot be scanned by the reading functions of\n<I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A></I>.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe example below presents a representation of a planar map containing\none triangle with the coordinates <I>(0,0)</I>, <I>(1,1)</I> and <I>(2,0)</I>.  The <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A></I> instance that was used to produce this\nexample was templated with the <I><A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A></I>\nclass, which in turn was templated with the representation class\n<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_leda_rational.html#Cross_link_anchor_1389\">leda_rational</A>&gt;</I>.  The first line specifies that the\nplanar map has three vertices, six halfedges, and 2 faces (the\ntriangle and the unbounded face).  The list of vertices each\nrepresented by its associated point follows, as shown in the output\nexample.  The next list is the one of halfedges, each component is\nrepresented by its index (0,1 or 2) in the vertices list and its\nassociated segment.  The faces list is presented next. It starts with\nthe <I>unbounded face</I> having one hole which is the triangle,\nthis connected component specifies that the hole has three halfedges\nwith the indices 4, 0 and 3. The next face presenting the triangle is\nwritten in the same manner.\n<P>\n\n<pre class=\"ExampleCode\"># ------------------------------------- Printing Planar map\n# --------------------------------------------------------\n# Printing number of vertices halfedges and faces in Planar map\n3 6 2\n# 3 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n2/1 0/1\n# 6 halfedges\n# ------------------------------------------\n0 0/1 0/1 1/1 1/1\n1 0/1 0/1 1/1 1/1\n0 1/1 1/1 2/1 0/1\n2 1/1 1/1 2/1 0/1\n1 2/1 0/1 0/1 0/1\n2 2/1 0/1 0/1 0/1\n# 2 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n3\n4 0 3 \n# finish writing face\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# outer ccb\n# number halfedges on outer boundary\n3\n5 2 1 \n# number of holes\n0\n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End of Planar map\n# --------------------------------------------------------\n</pre>\n<P>\n\n<h3>19.2.3&nbsp;&nbsp;&nbsp;Example of User Defined I/O Functions</h3>\n\n<A NAME=\"PM_sec:example10\"></A>\n<P>\n\nThe following program demonstrates the usage of I/O functions while\nusers have an additional attribute in their planar map.\nThe attribute chosen here is adding an associative color to each\nvertex. First the program extends the <I>Dcel</I> to maintain this\nattribute. Second, the program extends the <I><A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_809\">Pm_file_writer</A></I> class\nto handle the newly defined vertex. \nIt simply overrides the functions for writing a vertex to print the\ncolor of the vertex as well. Finally, the main function defines an\nempty <I>Planar map</I>, reads it from the standard input stream, and\nthen set all vertices colors. It then defines an object of its\nextended writer class and parameterize the function <I><A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_811\">write_pm</A></I>\nwith that object.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Planar_map/example10.C\n\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Pm_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/IO/Pm_iostream.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_811\">write_pm</A>.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\ntemplate &lt;class Pt&gt;\nclass Pm_my_vertex : public CGAL::Pm_vertex_base&lt;Pt&gt;\n{\npublic:\n  Pm_my_vertex() : CGAL::Pm_vertex_base&lt;Pt&gt;() { }\n\n  void set_color(const std::string &amp; c) { color = c; }\n  std::string get_color() const { return color;}\n  \nprivate:\n  std::string color;\n};\n\n// building new dcel with my vertex base.\ntemplate &lt;class Traits&gt;\nclass Pm_my_dcel : \n  public <A HREF=\"../Planar_map_ref/Class_Pm_dcel.html#Cross_link_anchor_798\">CGAL::Pm_dcel</A>&lt;Pm_my_vertex&lt;typename Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&gt;,\n               CGAL::Pm_halfedge_base&lt;typename Traits::X_monotone_curve_2&gt;, \n                       CGAL::Pm_face_base&gt; \n{\npublic:  // Creation\n  Pm_my_dcel() { }\n};\n\n// extend the drawer to print the color as well. \ntemplate &lt;class PM&gt;\nclass Pm_my_file_writer : public <A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_808\">CGAL::Pm_file_writer</A>&lt;PM&gt;\n{\npublic:\n  typedef typename PM::Vertex_handle             Vertex_handle;\n  typedef typename PM::Vertex_const_handle       Vertex_const_handle;\n  typedef typename PM::Vertex_iterator           Vertex_iterator;\n  typedef typename PM::Vertex_const_iterator     Vertex_const_iterator;\n\n  Pm_my_file_writer(std::ostream &amp; o, const PM &amp; pm, bool verbose = false) : \n    <A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_808\">CGAL::Pm_file_writer</A>&lt;PM&gt;(o, pm, verbose) { }\n  \n  void write_vertex(Vertex_const_handle v) const\n  {\n    this-&gt;out() &lt;&lt; v-&gt;point() &lt;&lt;&quot;  &quot;;\n    this-&gt;out() &lt;&lt; v-&gt;get_color()&lt;&lt; std::endl;\n  }\n};\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;int&gt;               NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;               <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_801\">CGAL::Pm_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Traits;\ntypedef Pm_my_dcel&lt;Traits&gt;                Dcel;\ntypedef <A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_786\">CGAL::Planar_map_2</A>&lt;Dcel,Traits&gt;   Planar_map;\ntypedef Planar_map::Vertex_iterator       Vertex_iterator;\n\nint main()\n{\n  Planar_map pm;\n  std::cin &gt;&gt; pm;\n \n  std::cout &lt;&lt; &quot;* * * Demonstrating definition of user attributes for &quot;\n            &lt;&lt; &quot;Planar map components&quot; &lt;&lt; std::endl &lt;&lt; std::endl\n            &lt;&lt; std::endl;\n  \n  // Update the colors for halfedge and vertex:\n  for (Vertex_iterator v_iter = pm.vertices_begin(); \n       v_iter != pm.vertices_end(); \n       ++v_iter)\n    v_iter-&gt;set_color(&quot;BLUE&quot;);\n\n // Print the map to output stream with the user attributes:\n  std::cout &lt;&lt; &quot;* * * Printing the Planar map&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::endl;\n  \n  Pm_my_file_writer&lt;Planar_map&gt;  writer(std::cout, pm); \n  <A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_810\">CGAL::write_pm</A>(pm, writer, std::cout);\n\n  return 0;\n}\n</pre>\n<P>\n\nThe input of the program is a text file presenting the <I>Planar map</I>:\n<pre class=\"ExampleCode\"># ------------------------------------- Printing Planar map\n# --------------------------------------------------------\n# Printing number of vertices halfedges and faces in Planar map\n3 6 2\n# 3 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n2/1 0/1\n# 6 halfedges\n# ------------------------------------------\n0 0/1 0/1 1/1 1/1\n1 0/1 0/1 1/1 1/1\n0 1/1 1/1 2/1 0/1\n2 1/1 1/1 2/1 0/1\n1 2/1 0/1 0/1 0/1\n2 2/1 0/1 0/1 0/1\n# 2 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n3\n4 0 3 \n# finish writing face\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# outer ccb\n# number halfedges on outer boundary\n3\n5 2 1 \n# number of holes\n0\n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End of Planar map\n# --------------------------------------------------------\n</pre>\n<P>\n\nThe output is the <I>Planar map</I> written in both formats, non\nverbose and verbose. In addition the two lists (non verbose and\nverbose) of halfedges are written.\n<pre class=\"ExampleCode\">* * * Demonstrating definition of user attributes for Planar map components\n\n\n* * * Printing the Planar map\n\n# ------------------------------------- Begin Planar Map\n# --------------------------------------------------------\n# Number of vertices halfedges and faces in Planar map\n3 6 2\n# 3 vertices\n# ------------------------------------------\n1/1 1/1  BLUE\n0/1 0/1  BLUE\n2/1 0/1  BLUE\n# 6 halfedges\n# ------------------------------------------\n0 0/1 0/1 1/1 1/1\n1 0/1 0/1 1/1 1/1\n0 1/1 1/1 2/1 0/1\n2 1/1 1/1 2/1 0/1\n1 2/1 0/1 0/1 0/1\n2 2/1 0/1 0/1 0/1\n# 2 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n3\n4 0 3 \n# finish writing face\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# outer ccb\n# number halfedges on outer boundary\n3\n5 2 1 \n# number of holes\n0\n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End Planar Map\n# --------------------------------------------------------\n</pre>\n<P>\n\nMore details are given in sections\n<I><A HREF=\"../Planar_map_ref/Class_File_header.html#Cross_link_anchor_805\">File_header</A></I>,\n<I><A HREF=\"../Planar_map_ref/Class_Pm_file_scanner.html#Cross_link_anchor_807\">Pm_file_scanner</A>&lt;Planar_map&gt;</I>, \n<I><A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_809\">Pm_file_writer</A>&lt;Planar_map&gt;</I> and\n<I><A HREF=\"../Planar_map_ref/Class_Pm_drawer.html#Cross_link_anchor_813\">Pm_drawer</A>&lt;Planar_map&gt;</I>.\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<h3>19.2.4&nbsp;&nbsp;&nbsp;Traits Classes</h3>\n\nThe planar map class is parameterized with the concept class\n<I><A HREF=\"../Planar_map_ref/Concept_PlanarMapTraits_2.html#Cross_link_anchor_800\">PlanarMapTraits_2</A></I> that defines the abstract interface\nbetween planar maps and the primitives they use. A model of this\nconcept must define two types of objects,\nnamely <I>X_monotone_curve_2</I> and\n<I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>, where the type of the endpoints of an\n<I>X_monotone_curve_2</I>-type curve is <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>. In\naddition, the traits class must contain the implementation of a set of\noperations on these two types.\n<P>\n\nWe supply a default traits class for segments, namely\n<I><A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I>, where <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A></I> is a\nkernel representation type, e.g., <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A></I> or\n<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A></I>. This traits class handles finite line segments in\nthe plane. In this class the\n<I>X_monotone_curve_2</I> and <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I> types are\ndefined as the C<SMALL>GAL</SMALL> kernel types\n<I><A HREF=\"../Kernel_23_ref/Concept_Kernel--Segment_2.html#Cross_link_anchor_463\">Kernel::Segment_2</A></I> and <I><A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_2.html#Cross_link_anchor_459\">Kernel::Point_2</A></I>\nrespectively, and the C<SMALL>GAL</SMALL> kernel operations on these types are\nexploited to implement the required functions.\nThe <I>leda_rat_kernel_traits</I> class exploits L<SMALL>EDA</SMALL>'s rational\nkernel and its efficient predicates. As a model that conforms to the\nC<SMALL>GAL</SMALL> kernel concept, it can be injected to the\n<I><A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I> class.\n<I>leda_rat_kernel_traits</I> class is available as an external\npackage.\n<P>\n\nModels of <A HREF=\"../Planar_map_ref/Concept_PlanarMapTraits_2.html#Cross_link_anchor_800\">PlanarMapTraits_2</A> are meant to serve as arguments for the\nrespective template parameter of\n<I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_786\">CGAL::Planar_map_2</A>&lt;Dcel,Traits&gt;</I>. However, it should be noted\nthat each model of <A HREF=\"../Planar_map_ref/Concept_PlanarMapTraits_2.html#Cross_link_anchor_800\">PlanarMapTraits_2</A> defines a family of curves and\nprimitive geometric operations thereof. Sometimes, the only\nimplementation available for the manipulation of a certain family of\ncurves is one of the supplied traits classes. A scenario where one\nuses a traits class object to manipulate such curves without\nmaintaining planar maps is certainly possible.\n<P>\n\n<I><A HREF=\"../Arrangement_2_ref/Concept_ArrangementTraits_2.html#Cross_link_anchor_835\">ArrangementTraits_2</A></I> concept is a refinements of the\n<I><A HREF=\"../Pm_with_intersections_2_ref/Concept_PlanarMapWithIntersectionsTraits_2.html#Cross_link_anchor_818\">PlanarMapWithIntersectionsTraits_2</A></I> concept, and the latter is a\nrefinement of the <I><A HREF=\"../Planar_map_ref/Concept_PlanarMapTraits_2.html#Cross_link_anchor_800\">PlanarMapTraits_2</A></I> concept.\nTherefore, all models of the formers are models of the latter. \nThere are several supplied traits classes for the <I>Arrangement</I>\nthat you can use. These classes are described at the end of Chapter\n<A HREF=\"../Arrangement_2/Chapter_main.html#I1_ChapterArrangement_2\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> (<I>2D Arrangements</I>).\n<P>\n\n<h3>19.2.5&nbsp;&nbsp;&nbsp;Point Location Strategies</h3>\n\n<A NAME=\"PM_sec:point_location\"></A>\nSome of the basic operations on planar maps are queries such as ``what\nis the location of a point in the map?'', or ``which curve is\nvertically above the point?''. The answer to these geometric queries can\nbe obtained through the use of the Planar Map package, along with several\nalgorithms available for you to choose from.\n<P>\n\nThe  class has a point location function\n(namely, the <I>locate</I> function that determines which feature of the map \ncontains a given query point)\nwhich is also used internally in the <I>insert</I> function.\nYou can define which algorithm to use in the\npoint location queries. This is done with a <I>point location class</I>\npassed to the map in the constructor. The class passed should be derived\nfrom the base class <I>Pm_point_location_base</I> which is a\n(<I>pure virtual</I>) base class that defines the interface between the \nalgorithm implemented by the users and the planar map. This follows the \nknown <I>Strategy</I>\npattern &nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ghjv-dpero-95\">GHJV95</A>]. The indirection overhead due to the virtual\nfunctions is negligible since the optimal point location algorithm \n(e.g., the one implemented in our default strategy) takes <MATH><I><IMG BORDER=0 WIDTH=11 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Theta.gif\">(</I></MATH>log<MATH><I>n)</I></MATH> time.\nWe have derived three concrete classes for point location strategies,\nthe <I>trapezoid-randomized-incremental-construction</I> strategy, based on\na trapezoidal decomposition of the map, the <I>naive</I> strategy, which goes\nover all the vertices and halfedges of the planar map and the\n<I>walk-along-a-line</I> strategy, which improves\nthe <I>naive</I> one by ``walking'' only along the zone of the vertical ray\nemanating from the query point. All three strategies are classes\nthat inherit <I>Pm_point_location_base&lt;Planar_map&gt;</I>.\nMore details are give in sections \n  <I><A HREF=\"../Planar_map_ref/Class_Pm_trapezoid_ric_point_location.html#Cross_link_anchor_790\">Pm_trapezoid_ric_point_location</A>&lt;Planar_map&gt;</I>, \n  <I><A HREF=\"../Planar_map_ref/Class_Pm_naive_point_location.html#Cross_link_anchor_792\">Pm_naive_point_location</A>&lt;Planar_map&gt;</I> and\n  <I><A HREF=\"../Planar_map_ref/Class_Pm_walk_along_a_line_point_location.html#Cross_link_anchor_794\">Pm_walk_along_a_line_point_location</A>&lt;Planar_map&gt;</I>.\n<P>\n\n<b>Trade-off Issues</b>\n<P>\n\nThe main trade-off among the three strategies implemented, is between\ntime and storage. Using the naive or walk strategies takes more\ntime but saves storage space.\n<P>\n\nAnother trade-off depends on the need for point location queries compared\nto the need for other functions. If you do not need point location \nqueries, but do need other modifying functions (e.g., <I>remove_edge</I>, \n<I>split_edge</I> and <I>merge_edge</I>) then using the naive or walk strategies\nis preferable. Note that using the <I>insert</I> function invokes the\npoint location query, therefore when using the naive or walk strategies it\nis recommended to use the specialized insertion functions : \n<I>insert_in_face_interior</I>, <I>insert_from_vertex</I> and \n<I>insert_at_vertices</I>.\nFor example, when using the planar map to represent polygons (e.g., when\ncomputing boolean operations on polygons) it might be preferable to use\nthe walk strategy with the specialized insertion functions.\n<P>\n\nThere are two modes of the <I>default</I> strategy which enables\nyou to choose whether preprocessing should be performed or not (read\nmore in the section stated above).\nThere is a trade-off between those two modes. If\npreprocessing is not used, the building of the structure is faster. However,\nfor some input sequences the structure might be unbalanced and therefore \nqueries and updates might take longer, especially, if many removal and split \noperation are performed.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>19.3&nbsp;&nbsp;&nbsp;Implementation</h2>\n\n\n<h3>19.3.1&nbsp;&nbsp;&nbsp;Robustness</h3>\n\nThe <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> class can handle all inputs and\nrequires no general position assumption. Calculations are exact and\nleave no place for errors of any kind. Nevertheless, since the input\ncurves are disjoint in their interiors, no construction of\n<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> points are performed. Therefore, filtered kernel can\ndefinitely expedite the various operations.\n<P>\n\n<h3>19.3.2&nbsp;&nbsp;&nbsp;Programming Tips</h3>\n\nThis section presents some tips on how to tune\n<I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_786\">CGAL::Planar_map_2</A>&lt;Dcel,Traits&gt;</I> for best performance.\n<P>\n\nBefore we list specific tips, we remind you that compiling\nprograms with debug flags turned off, and with optimization flags\nturned on, significantly reduces running time.\n<P>\n\n<OL>\n   <LI>The default point location strategy (i.e. using\n   <I>trapezoidal decomposition</I>) is the fastest one when queries\n   are concerned. However, since it has to build a search structure it\n   might slow down the incremental building process of the map. If it\n   is known in advance that there will not be many point location or\n   vertical ray shoot queries use another point location strategy\n   (such as the <I>walk</I> or <I>simple</I> strategies) which does not\n   slow down the building process (no search structure is being\n   built).\n<P>\n\n<LI>Prior knowledge of the combinatorial structure of the map can\n   be used to accelerate insertion time. The specialized insertion\n   functions, i.e <I>insert_in_face_interior</I>,\n   <I>insert_from_vertex</I> or <I>insert_at_vertices</I> should be used\n   according to this information. The insert function performs point\n   location queries and then calls one of the other update functions\n   and therefore takes more time.  The function\n   <I>insert_in_face_interior</I> even takes constant time. The other\n   two are linear in the worst case, but should be much faster most of\n   the time.\n<P>\n\nInsertion of a polygon, which is represented by a list of segments\n   along its boundary, into an empty planar map should be done in the\n   following way. First, some segment should be inserted using\n   <I>insert_in_face_interior</I> with the unbounded face. Then a\n   segment with a common end point can be inserted using\n   <I>insert_from_vertex</I> and so on with the rest of the segments\n   but last. The last segment can be inserted using\n   <I>insert_at_vertices</I> since both it endpoints are represented as\n   vertices of the map and are known in advanced.\n<P>\n\n<LI>If you have L<SMALL>EDA</SMALL> installed it is recommended to use\n   the specialized traits classes <I>Pm_leda_segment_traits_2</I>\n   or <I>Arr_leda_polyline_traits</I>. These traits classes are much\n   faster since they are specialized for L<SMALL>EDA</SMALL>'s <I>rational    geometric kernel</I>. Note that these traits classes are models of\n   <I><A HREF=\"../Planar_map_ref/Concept_PlanarMapTraits_2.html#Cross_link_anchor_800\">PlanarMapTraits_2</A></I> since they model its refinement, the\n   <I><A HREF=\"../Arrangement_2_ref/Concept_ArrangementTraits_2.html#Cross_link_anchor_835\">ArrangementTraits_2</A></I> concept.\n<P>\n\n</OL>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>19.4&nbsp;&nbsp;&nbsp;Example Programs</h2>\n<P>\n\n<h3>19.4.1&nbsp;&nbsp;&nbsp;Example of IO functions</h3>\n\n<A NAME=\"PM_sec:example9\"></A>\n<P>\n\nThe following program demonstrates the use of I/O functions provided\nfor planar maps. \nFirst the program demonstrates a trivial use of the I/O functions: \nit defines an empty instance of <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A></I>, \nreads the planar map representation text from the standard input stream, \nand then prints the resulting planar map to the standard output stream.\n<P>\n\nSecond, it presents the usage of the verbose format, \nby defining <I><A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_809\">Pm_file_writer</A></I> with the verbose flag set to true, \nand then calls the function <I><A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_811\">write_pm</A></I>.\nA usage of the interface of the class <I><A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_809\">Pm_file_writer</A></I> is also\npresented, by calling its function <I>write_halfedges</I>, which\nprints all the halfedges of the map. In addition, the program presents\nthe operators writing the resulting  <I>Planar map</I> to a postscript\nfile when LEDA is installed. The demo for the planar map package makes\nuse of the output operator of <I><A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> to a\nwindow stream  (see at <I>&lt;CGAL_ROOT&gt;/demo/Planar_map/demo.C</I> ).\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Planar_map/example9.C\n\n#include &quot;short_names.h&quot;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#include &lt;CGAL/Pm_default_dcel.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_802\">Pm_segment_traits_2</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_811\">write_pm</A>.h&gt;\n#include &lt;CGAL/IO/Pm_iostream.h&gt;\n#include &lt;iostream&gt;\n\n// #define CGAL_POSTSCRIPT\n#if defined(CGAL_USE_LEDA) &amp;&amp; defined(CGAL_POSTSCRIPT)\n#include &lt;CGAL/IO/Pm_Postscript_file_stream.h&gt;\n#endif\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;int&gt;                     NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;                     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Planar_map_ref/Class_Pm_segment_traits_2.html#Cross_link_anchor_801\">CGAL::Pm_segment_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;       Traits;\ntypedef CGAL::Pm_default_dcel&lt;Traits&gt;           Dcel;\ntypedef <A HREF=\"../Planar_map_ref/Class_Planar_map_2.html#Cross_link_anchor_786\">CGAL::Planar_map_2</A>&lt;Dcel,Traits&gt;         Planar_map;\ntypedef <A HREF=\"../Planar_map_ref/Class_Pm_file_writer.html#Cross_link_anchor_808\">CGAL::Pm_file_writer</A>&lt;Planar_map&gt;        Pm_writer;\n\nint main()\n{ \n  Planar_map pm;\n  Pm_writer verbose_writer(std::cout, pm, true);\n  Pm_writer writer(std::cout, pm);\n\n  std::cout &lt;&lt; &quot;* * * Demonstrating a trivial use of IO functions&quot;\n            &lt;&lt; std::endl &lt;&lt; std::endl;\n  std::cin  &gt;&gt; pm;\n  std::cout &lt;&lt; pm;\n  \n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;* * * Presenting the use of verbose format&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::endl;\n  <A HREF=\"../Planar_map_ref/Function_write_pm.html#Cross_link_anchor_810\">CGAL::write_pm</A>(pm, verbose_writer, std::cout);\n  \n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;* * * Demonstrating the use of the writer class interface.&quot;\n            &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;* * * Printing all halfedges in non verbose format&quot;\n            &lt;&lt; std::endl &lt;&lt; std::endl;\n  writer.write_halfedges(pm.halfedges_begin(), pm.halfedges_end());\n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;* * * Printing all halfedges in a verbose format&quot; &lt;&lt; std::endl\n            &lt;&lt; std::endl;\n  verbose_writer.write_halfedges(pm.halfedges_begin(), pm.halfedges_end());\n   \n#if defined(CGAL_USE_LEDA) &amp;&amp; defined(CGAL_POSTSCRIPT)\n  // Print to Postscript file:\n  <A HREF=\"../Colors_and_windows_ref/Class_Postscript_file_stream.html#Cross_link_anchor_1755\">CGAL::Postscript_file_stream</A>  LPF(500, 500 ,&quot;pm.ps&quot;);\n  LPF.init(-3,3,-3);\n  LPF.set_line_width(1);\n  LPF &lt;&lt; pm;\n#endif\n\n  return 0;\n}\n</pre>\n<P>\n\nThe input of the program is a text file which holds the planar map\nrepresentation in a special format (which is presented in the\nreference pages of the the <I>Planar Map</I> package.\nThis representation appears as the first block in the output file.\n<P>\n\nThe output is the <I>Planar map</I> includes both formats, non-verbose\nand verbose. In addition the two lists (non-verbose and verbose) of\nhalfedges are written.\n<pre class=\"ExampleCode\">* * * Demonstrating a trivial use of IO functions\n\n# ------------------------------------- Begin Planar Map\n# --------------------------------------------------------\n# Number of vertices halfedges and faces in Planar map\n3 6 2\n# 3 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n2/1 0/1\n# 6 halfedges\n# ------------------------------------------\n0 0/1 0/1 1/1 1/1\n1 0/1 0/1 1/1 1/1\n0 1/1 1/1 2/1 0/1\n2 1/1 1/1 2/1 0/1\n1 2/1 0/1 0/1 0/1\n2 2/1 0/1 0/1 0/1\n# 2 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n3\n4 0 3 \n# finish writing face\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# outer ccb\n# number halfedges on outer boundary\n3\n5 2 1 \n# number of holes\n0\n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End Planar Map\n# --------------------------------------------------------\n\n* * * Presenting the use of verbose format\n\n# ------------------------------------- Begin Planar Map\n# --------------------------------------------------------\n# Number of vertices halfedges and faces in Planar map\n3 6 2\n# 3 vertices\n# ------------------------------------------\n1/1 1/1\n0/1 0/1\n2/1 0/1\n# 6 halfedges\n# ------------------------------------------\n0/1 0/1 1/1 1/1  towards  1/1 1/1\n0/1 0/1 1/1 1/1  towards  0/1 0/1\n1/1 1/1 2/1 0/1  towards  1/1 1/1\n1/1 1/1 2/1 0/1  towards  2/1 0/1\n2/1 0/1 0/1 0/1  towards  0/1 0/1\n2/1 0/1 0/1 0/1  towards  2/1 0/1\n# 2 faces\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# UNBOUNDED\n# number halfedges on outer boundary\n0\n# number of holes\n1\n# inner ccb\n# number halfedges on inner boundary\n3\n2/1 0/1 0/1 0/1  towards  0/1 0/1\n0/1 0/1 1/1 1/1  towards  1/1 1/1\n1/1 1/1 2/1 0/1  towards  2/1 0/1\n\n# finish writing face\n# ------------------------------------------\n# writing face\n# ------------------------------------------\n# outer ccb\n# number halfedges on outer boundary\n3\n2/1 0/1 0/1 0/1  towards  2/1 0/1\n1/1 1/1 2/1 0/1  towards  1/1 1/1\n0/1 0/1 1/1 1/1  towards  0/1 0/1\n\n# number of holes\n0\n# finish writing face\n# ------------------------------------------\n# ------------------------------------- End Planar Map\n# --------------------------------------------------------\n\n* * * Demonstrating the use of the writer class interface.\n* * * Printing all halfedges in non verbose format\n\n0 0/1 0/1 1/1 1/1\n1 0/1 0/1 1/1 1/1\n0 1/1 1/1 2/1 0/1\n2 1/1 1/1 2/1 0/1\n1 2/1 0/1 0/1 0/1\n2 2/1 0/1 0/1 0/1\n\n* * * Printing all halfedges in a verbose format\n\n0/1 0/1 1/1 1/1  towards  1/1 1/1\n0/1 0/1 1/1 1/1  towards  0/1 0/1\n1/1 1/1 2/1 0/1  towards  1/1 1/1\n1/1 1/1 2/1 0/1  towards  2/1 0/1\n2/1 0/1 0/1 0/1  towards  0/1 0/1\n2/1 0/1 0/1 0/1  towards  2/1 0/1\n</pre>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nA conic section is the\nnondegenerate curve generated by the intersections of a plane with\none or two nappes of a cone.\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Planar_map_ref/Chapter_intro.html\">2D Planar Maps</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_19!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38062.0}