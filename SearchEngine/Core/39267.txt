{"text": "Navigation Up Table of Contents Bibliography Index Title Page advanced CGAL Interval nt advanced Definition The advanced class allows you to make faster computations with interval arithmetic but you need to set the rounding mode of the FPU to round to infinity see below for how to do that before doing any computation with this number type and each function arithmetic operators and conversion functions leaves the rounding mode in this state if it needs to modify it internally Changing the rounding mode affects all floating point computations and might cause problems with parts of your code or external libraries even CGAL that expect the rounding mode to be the default round to the nearest include CGAL Interval arithmetic h Is Model for the ConceptFieldNumberType Operations Interval nt advanced convert to Interval nt advanced NT Several such functions provide a cast from the following numerical types to an Interval nt advanced containing the value The following types are supported leda real leda rational leda integer leda bigfloat Gmpz Fixed precision nt all built in types that fit exactly in a double which excludes long double and 64 bits integers which must be treated separately and all Quotient RT where RT is a type listed above The user can add such functions for his own number types see the files CGAL Interval arithmetic IA h for examples We provide the following interface to change the rounding mode typedef int FPU CW t The type used by the following functions to deal with rounding modes This is usually an int void FPU set cw FPU CW t R sets the rounding mode to R FPU CW t FPU get cw void returns the current rounding mode FPU CW t FPU get and set cw FPU CW t R sets the rounding mode to R and returns the old one The macros CGAL FE TONEAREST CGAL FE TOWARDZERO CGAL FE UPWARD and CGAL FE DOWNWARD are the values corresponding to the rounding modes Example The correct way to protect an area of code that uses operations on the class Interval nt advanced is the following FPU CW t backup FPU get and set cw CGAL FE UPWARD The code to be protected FPU set cw backup Implementation The basic idea is to use the directed rounding modes specified by the IEEE 754 standard which are implemented by almost all processors nowadays It states that you have the possibility concerning the basic floating point operations sqrt to specify the rounding mode of each operation instead of using the default which is set to round to the nearest This feature allows us to compute easily on intervals For example to add the two intervals a i a s and b i b s compute c i a i b i rounded towards minus infinity and c s a s b s rounded towards plus infinity and the result is the interval c i c s This method can be extended easily to the other operations The problem is that we have to change the rounding mode very often and the functions of the C library doing this operation are slow and not portable That s why assembly versions are used as often as possible Another trick is to store the opposite of the lower bound instead of the lower bound itself which allows us to never change the rounding mode inside simple operations Therefore all basic operations which are in the class Interval nt advanced assume that the rounding mode is set to round to infinity and everything works with this correctly set The class Interval nt takes care of this but is a bit slower So if the user needs the speed of Interval nt advanced he must take care of setting the rounding mode to round to infinity before each block of operations on this number type And if other operations might be affected by this he must take care to reset it to round to the nearest before they are executed Notes On Intel platforms with any operating system and compiler due to a misfeature of the floating point unit which does not handle exactly IEEE compliant operations on doubles we are forced to use a workaround which slows down the code but is only useful when the intervals can overflow or underflow If you know that the intervals will never overflow nor underflow for your code then you can disable this workaround with the flag CGAL IA NO X86 OVER UNDER FLOW PROTECT Other platforms are not affected by this flag When optimizing compilers usually propagate the value of variables when they know it s a constant This can break the interval routines because the compiler then does some floating point operations on these constants with the default rounding mode which is wrong This kind of problem is avoided by stopping constant propagation in the interval routines However this solution slows down the code and is rarely useful so you can disable it by setting the flag CGAL IA DONT STOP CONSTANT PROPAGATION advanced Next is negative Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/NumberTypeSupport_ref/Class_Interval_nt_advanced.html", "title": "interval_nt_advanced", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './NumberTypeSupport_ref/Interval.tex' -->\n<html> <head>  \n<title>Interval_nt_advanced</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1367\"></A>\n\n<A NAME=\"Cross_link_anchor_1368\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1387\"></A><BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Interval_nt_advanced\"></A>\n<h2><I>CGAL::Interval_nt_advanced</I></h2>\n\n\n<A NAME=\"interval-adv\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe advanced class allows you to make faster computations with interval \narithmetic, but you need to set\nthe rounding mode of the FPU to 'round to infinity' (see below for how to do\nthat) before doing any computation with this number type, and each function\n(arithmetic operators and conversion functions)\nleaves the rounding mode in this state if it needs to modify it internally.\n<P>\n\nChanging the rounding mode affects all floating point computations, and might\ncause problems with parts of your code, or external libraries (even C<SMALL>GAL</SMALL>),\nthat expect the rounding mode to be the default (round to the nearest).\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Interval_arithmetic.h\">CGAL/Interval_arithmetic.h</A>&gt;</I>\n<P>\n\n<H3>Is Model for the Concept</H3><A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>\n<P>\n\n<H3>Operations</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Interval_nt_advanced_convert_to6Interval_nt_advanced96NT9;\"></A>\n<A HREF=\"Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A> convert_to&lt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A>&gt; ( NT)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Several such functions provide a cast from the following numerical types\nto an <I><A HREF=\"Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A></I> containing the value.  The following types are\nsupported: <I><A HREF=\"Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>, <I><A HREF=\"Class_leda_rational.html#Cross_link_anchor_1389\">leda_rational</A></I>, <I><A HREF=\"Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A></I>,\n<I><A HREF=\"Class_leda_bigfloat.html#Cross_link_anchor_1387\">leda_bigfloat</A></I>, <I><A HREF=\"Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A></I>, <I><A HREF=\"Class_Fixed_precision_nt.html#Cross_link_anchor_1354\">Fixed_precision_nt</A></I>, all built-in\ntypes that fit exactly in a <I>double</I> (which excludes <I>long double</I>\nand 64 bits integers, which must be treated separately), and all\n<I><A HREF=\"Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;RT&gt;</I> where RT is a type listed above.\nThe user can add such functions for his own number types, see the files\n<I>CGAL/Interval_arithmetic/IA_*.h</I> for examples.\n        </TD></TR>\n        </TABLE>\n<P>\n\nWe provide the following interface to change the rounding mode:\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_FPU_CW_t\"></A>\n<A NAME=\"Typedef_FPU_CW_t\"></A>\ntypedef int\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    FPU_CW_t;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The type used by the following functions to deal with rounding modes.\n       This is usually an <I>int</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_FPU_set_cw_6FPU_CW_t_R9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    FPU_set_cw ( FPU_CW_t R)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets the rounding mode to <I>R</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_FPU_CW_t_FPU_get_cw_6void9;\"></A>\nFPU_CW_t\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    FPU_get_cw ( void)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the current rounding mode.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_FPU_CW_t_FPU_get_and_set_cw_6FPU_CW_t_R9;\"></A>\nFPU_CW_t\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    FPU_get_and_set_cw ( FPU_CW_t R)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets the rounding mode to <I>R</I> and returns the old one.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe macros <I>CGAL_FE_TONEAREST</I>, <I>CGAL_FE_TOWARDZERO</I>,\n<I>CGAL_FE_UPWARD</I> and <I>CGAL_FE_DOWNWARD</I> are the values corresponding\nto the rounding modes.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe correct way to protect an <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> of code that uses operations on the class\n<I><A HREF=\"Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A></I> is the following:\n<P>\n\n<pre class=\"Verbatim\">\n  FPU_CW_t backup = FPU_get_and_set_cw(CGAL_FE_UPWARD);\n  ... // The code to be protected.\n  FPU_set_cw(backup);\n</pre>\n<P>\n\n<H3>Implementation</H3>\n<P>\n\nThe basic idea is to use the directed rounding modes specified by the \n<I>IEEE 754</I> standard, which are implemented by almost all processors \nnowadays.\nIt states that you have the possibility, concerning the basic floating point\noperations (<MATH><I>+,-,*,/,<A HREF=\"Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>()</I></MATH>) to specify the rounding mode of each operation\ninstead of using the default, which is set to 'round to the nearest'.\nThis feature allows us to compute easily on intervals.  For example, to\nadd the two intervals [a.i;a.s] and [b.i;b.s], compute <MATH><I>c.i=a.i+b.i</I></MATH> rounded\ntowards minus infinity, and <MATH><I>c.s=a.s+b.s</I></MATH> rounded towards plus infinity, and\nthe result is the interval [c.i;c.s].  This method can be extended easily to\nthe other operations.\n<P>\n\nThe problem is that we have to change the rounding mode very often, and the\nfunctions of the C library doing this operation are slow and not portable.\nThat's why assembly versions are used as often as possible.\nAnother trick is to store the <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> of the lower bound, instead of the\nlower bound itself, which allows us to never change the rounding mode inside\nsimple operations.  Therefore, all basic operations, which are in the class \n<I><A HREF=\"Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A></I> assume that the rounding mode is set to \n'round to infinity', and everything works with this correctly set.  \nThe class <I><A HREF=\"Class_Interval_nt.html#Cross_link_anchor_1366\">Interval_nt</A></I> takes care of this, but is a bit slower.\n<P>\n\nSo, if the user needs the speed of <I><A HREF=\"Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A></I>, he must\ntake care of setting the rounding mode to 'round to infinity' before each\nblock of operations on this number type.  And if other operations might be\naffected by this, he must take care to reset it to 'round to the nearest'\nbefore they are executed.\n<P>\n\nNotes:<BR>\n\n<UL>\n<LI>On Intel platforms (with any operating system and compiler), due to a\n      misfeature of the floating point unit, which does not handle exactly\n      IEEE compliant operations on doubles, we are forced to use a workaround\n      which slows down the code, but is only useful when the intervals can\n      overflow or underflow.  If you know that the intervals will never\n      overflow nor underflow for your code, then you can disable this\n      workaround with the flag <I>CGAL_IA_NO_X86_OVER_UNDER_FLOW_PROTECT</I>.\n      Other platforms are not affected by this flag.\n<LI>When optimizing, compilers usually propagate the value of variables when\n      they know it's a constant.  This can break the interval routines because\n      the compiler then does some floating point operations on these constants\n      with the default rounding mode, which is wrong.  This kind of problem\n      is avoided by stopping constant propagation in the interval routines.\n      However, this solution slows down the code and is rarely useful, so you\n      can disable it by setting the flag\n      <I>CGAL_IA_DONT_STOP_CONSTANT_PROPAGATION</I>.\n</UL>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_is_negative.html\"><I>is_negative</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_2!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39267.0}