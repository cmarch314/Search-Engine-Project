{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 16Qt widget Laurent Rineau and Radu Ursu Qt is a GUI toolkit1 for cross platform application development 16 1 Introduction This chapter describes the Qt widget package which provides an interface between CGAL and the GUI toolkit Qt The Qt widget package allows to build Qt applications showing two dimensional CGAL objects and algorithms The atom of the Qt user interface is called a widget A widget receives mouse keyboard and other events from the window system and paints a representation of itself on the screen Widgets are rectangular and the different widgets of an application are sorted in a Z order Widgets can have a parent widget and children A widget is clipped by its parent and by the widgets in front of it The most important class in the package is the class Qt widget which implements a widget providing a drawing area and output stream operators for CGAL two dimensional objects Qt widget also provides zooming and panning functionalities The Qt widget allows to attach layers Layers usually draw on the drawing area of the widget Layers can be activated and deactivated and what you see in the drawing area is the overlay of all attached activated layers Layers can also be used for entering input and CGAL provides input layers for the two dimensional CGAL objects The package includes also the class Qt widget standard toolbar providing a standard toolbar for controlling the basic functionality of the Qt widget The following sections describe the main class as well as the helper classes in more detail and give examples that can be taken as starting points for new applications Remark The Qt widget is distributed under the QPL which is Trolltech s open source license For more details on the QPL see http www trolltech com developer licensing qpl html 16 2 Qt widget The class Qt widget is derived from the class QWidget which is the base class of all Qt user interface objects The Qt widget provides output operators for two dimensional CGAL objects There are operators defined for output of points segments lines rays circles triangles rectangles polygons conics and all type of triangulations Also some operators are defined to set Qt widget s properties like background and fill color as well as line width and point size As the following examples show simple applications can be written without the layers 16 2 1 Example Hello Segment The first example draws a red segment on an orange background demo Qt widget Examples hellosegment C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Cartesian h include CGAL IO Qt widget h include qapplication h typedef CGAL Cartesian int Rep typedef CGAL Point 2 Rep Point 2 typedef CGAL Segment 2 Rep Segment int main int argc char argv QApplication app argc argv CGAL Qt widget w new CGAL Qt widget app setMainWidget w w resize 6 6 w set window 6 6 w show w lock w CGAL BackgroundColor CGAL ORANGE CGAL RED w Segment Point 2 1 1 Point 2 4 4 w unlock return app exec endif We follow the Qt naming conventions for material properties for example the CGAL BackgroundColor above All the drawing code should be put between Qt Widget s lock and unlock functions See the manual reference pages of Qt widget Doing like this the window will be updated only once when Qt widget finds the last unlock This way you can avoid the window flickering This example has a severe drawback when you resize the window it is empty as nothing is redrawn This style of programs makes only sense if you quickly want to validate output of a geometric computation As in any event driven GUI application Qt provides a callback mecanism so that the window system can update the drawing whenever necessary This is the topic of the next example 16 2 2 Example Signals and Slots This example is slightly more involved and uses the signal slots mecanism of Qt The main widget shows a Delaunay triangulation Every time the mouse button is pressed over the widget a point is input and inserted in the Delaunay triangulation The result of this insertion appears immediately Furthermore the drawing is updated every time the window is resized demo Qt widget Examples tutorial2 C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Cartesian h include CGAL Delaunay triangulation 2 h include CGAL IO Qt widget Triangulation 2 h include CGAL IO Qt widget h include qapplication h include qmainwindow h typedef CGAL Cartesian double K typedef K Point 2 Point 2 typedef CGAL Delaunay triangulation 2 K Delaunay Delaunay dt class My window public QMainWindow Q OBJECT public My window int x int y widget new CGAL Qt widget this widget resize x y widget set window x y connect widget SIGNAL redraw on back this SLOT redraw win connect widget SIGNAL s mousePressEvent QMouseEvent this SLOT mousePressEvent QMouseEvent setCentralWidget widget private slots void redraw win widget dt void mousePressEvent QMouseEvent e dt insert Point 2 widget x real e x widget y real e y widget redraw private private data member CGAL Qt widget widget moc source file tutorial2 C include tutorial2 moc int main int argc char argv QApplication app argc argv My window w new My window 4 4 app setMainWidget w w show return app exec endif Qt applications are event driven and respond to user interaction For example when a user clicks on a menu item or on a toolbar button the application executes some codes The programmer of an application has to be able to relate events to the relevant code Qt provide for that the signals slots mecanism Signals Each Qt widget declares a set of signals which using the keyword emit can be emitted by member functions under some circumstances Signals are declared by using the keyword signals just like an access specifier in your class declaration Slots A slot is just a member function declared under a public or private slots section Connect Signals and slots can be connected together using the method connect This method needs to know four things the object that sends out the signal the signal the object to which belong the connected slot and the slot connected to the signal For instance the statement connect widget SIGNAL redraw on back this SLOT redraw win connects the signal redraw on back of the widget widget to the slot redraw win of the QMainWindow his Signals and slots can have any type of arguments but a signal and a slot connected together must have the same arguments types Every class that defines at least a signal or a slot must be derived from the class QObject and must use the macro Q OBJECT inside the private section of its declaration You also need to run moc the Meta Object Compiler supplied with Qt on the file that contains the class declaration moc is a pre compiler that produces the meta object code of each class that uses the macro Q OBJECT This meta object code is needed by the signal slot mecanism There are several methods to compile the outputs of moc In CGAL we have chosen to include the outputs of moc in a source files See the Qt documentation on moc for other possibilities The line moc source file tutorial2 C is for users that use makefiles This line tells to the CGAL makefile generator that tutorial2 C should be the file that moc should be run on Let us come back to the control flow in the above example The main widget of the application is the widget w of class My window The creator of My window triggers the creation of a Qt widget accessible through the pointer widget When the mouse button is pressed in its drawing area the Qt widget emits the signal s mousePressEvent QMouseEvent connected to the slot mousePressEvent QMouseEvent of My window This slot inserts the point in the Delaunay triangulation and calls the method redraw of Qt widget The redraw method of Qt widget emits the signal redraw on back This signal is connected to the slot redraw win of My window which actually draws the triangulation Note that the Qt widget emits the same signal redraw on back when the window is resized Thus the signals slots connection ensures that the triangulation is redrawn each time the redrawing is needed advanced There are several ways to draw something with Qt widget One way is to use the signals redraw on back redraw on front This way you can bring your drawings before all or after all the other drawings An other option is to use the QPainter instance of Qt widget that you can get calling get painter method The most recommended way is to use layers that are described in the next section advanced Note that in that example the My window constructor calls new to allocate a new Qt widget object but delete is never called to deallocate it This does not mean that there is a memory leak It is in Qt s responsability to free widgets that have a parent In that example the My window object is the parent of widget and will deallocate it automatically at its destruction 16 3 Layers 16 3 1 Using Layers to Draw In the examples from the previous section the code for drawing on the widget was in the redraw win function As soon as the applications are more involved it leads to a more modular design if one delegates the drawing task to layers For example if the application displays a Delaunay triangulation the corresponding Voronoi diagram and at the same time highlights the nearest vertex to the mouse coordinates it makes sense to have three independent layers Besides better code layers have the advantage that they can be activated and deactivated at runtime Finally more modularity means a higher potential for reuse A layer can be attached to a Qt widget The redraw member function of the Qt widget calls the method Qt widget layer draw of all attached layers in the order that they were attached It is a very simple rule the last layer attached will be drawn on top Also a layer can be activated and deactivated Only active layers are drawn and by default a layer is activated when it gets attached Note that deactivating and activating do not influence the order of layers You can change the order only by attaching and detaching it CGAL provides a base class so that users can write their own layers All the layers have to derive from this base class Qt widget layer to have the functionality described 16 3 2 Example Using a Layer to Draw Example include CGAL Cartesian h include CGAL Point 2 h include CGAL Delaunay triangulation 2 h include CGAL IO Qt widget Delaunay triangulation 2 h include CGAL IO Qt widget h include CGAL IO Qt widget layer h include qapplication h typedef CGAL Cartesian double Rep typedef CGAL Point 2 Rep Point typedef CGAL Delaunay triangulation 2 Rep Delaunay Delaunay dt class My layer public CGAL Qt widget layer void draw widget dt class My window public CGAL Qt widget public My window int x int y resize x y attach layer private this method is called when the user presses the mouse void mousePressEvent QMouseEvent e Qt widget mousePressEvent e dt insert Point x real e x y real e y redraw My layer layer int main int argc char argv QApplication app argc argv My window W new My window 4 4 app setMainWidget W W show W set window 4 4 return app exec This example defines a class derived from Qt widget layer In the member function draw is the code for drawing the triangulation In My Window class you need an instance of My Layer and you will have to attach it if you want to see what the layer draws on the screen As you see this example is very similar to the previous one but the code for drawing the triangulation is no longer in the redraw win function but in a layer 16 3 3 Using Layers to Build New Objects The main purpose of layers is to have more modular code for drawing on the widget Things are similar for handling input In the previous examples input went through the Qt widget mousePressedEvent callback which interpreted the input In applications where you have different kinds of input e g segments and polygons in an arrangement demo this quickly leads to unreadable difficult to maintain code especially as typically more than one event callback is involved The proper way of decomposition is delegation of the event handling to a layer A layer for Qt widget receives all the events from Qt widget if it is active and can provide some functionality like input objects for Qt widget Notice that the layers receive events in the order they have been attached Layers can have internal state because for entering complex objects it needs several events Therefore layers must have functions to initialize state when they are activated and to clean up when they are deactivated CGAL provides some predefined input layers You can have a lot of layers attached that could be active in the same time You have to take care how you manage the events if you do not want to have conflicts A conflict is when two attached layers that are active need both the same event and getting and using it might not have such a good effect in your application For example the predefined layers that builds a new line and a new circle produce bad visual effects when are both active You can resolve conflicts by using layers exclusive If you have several layers that can not be active at the same time without creating conflicts you can resolve that by letting the user not activate more than one of those at a time advanced In all the CGAL demos that are provided the layers are used with a toolbar and buttons To activate and deactivate a layer you have to click one of the toolbar buttons There are layers that need exclusive use This is accomplished by grouping the buttons in one group and making that group exclusive The group class is QButtonGroup that comes with Qt advanced We first show how to use layers and then how they work 16 3 4 Example How to Use a Layer In the previous section you could insert new points in the triangulation by clicking on the widget This example shows how the same can be achieved with the help of a layer We attach the predefined layer Qt widget get point to the widget and connect the signal emitted by the widget to the function that handles the input When the user clicks with the left mouse button the layer creates a point and passes it to the widget The widget then emits a signal that gets passed to the connected slot My Window get new object CGAL Object demo Qt widget Examples layer C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Cartesian h include CGAL Delaunay triangulation 2 h include CGAL IO Qt widget Delaunay triangulation 2 h include CGAL IO Qt widget h include CGAL IO Qt widget layer h include CGAL IO Qt widget get point h include qapplication h include qmainwindow h typedef CGAL Cartesian double Rep typedef CGAL Point 2 Rep Point 2 typedef CGAL Delaunay triangulation 2 Rep Delaunay Delaunay dt class My Layer public CGAL Qt widget layer void draw widget dt class My Window public QMainWindow Q OBJECT public My Window int x int y widget new CGAL Qt widget this CGAL Qt widget setCentralWidget widget resize x y widget attach get point widget attach v connect widget SIGNAL new cgal object CGAL Object this SLOT get new object CGAL Object widget set window 6 6 private members CGAL Qt widget get point Rep get point My Layer v CGAL Qt widget widget private slots void get new object CGAL Object obj Point 2 p if CGAL assign p obj dt insert p widget redraw endclass moc source file layer C include layer moc int main int argc char argv QApplication app argc argv My Window W new My Window 6 6 app setMainWidget W W show return app exec endif The Qt widget forwards all events that it receives to the attached and active layers If a layer is attached but not active it does not get the events It is put in a passive state Activating and deactivating the layer does not mean that the object is destructed 16 3 5 Example How Layers Work The following is an example of a layer that creates CGAL points when the user clicks the left mouse button over the widget include CGAL IO Qt widget h include CGAL IO Qt widget layer h include qcursor h ifndef CGAL QT WIDGET GET POINT BUTTON define CGAL QT WIDGET GET POINT BUTTON Qt LeftButton endif namespace CGAL template class R class Qt widget get point public Qt widget layer public typedef typename R Point 2 Point typedef typename R FT FT Qt widget get point const QCursor c QCursor Qt crossCursor QObject parent const char name Qt widget layer parent name cursor c private bool is pure Qt ButtonState s if s Qt ControlButton s Qt ShiftButton s Qt AltButton return else return 1 void mousePressEvent QMouseEvent e if e button CGAL QT WIDGET GET POINT BUTTON is pure e state FT x y widget x real e x x widget y real e y y widget new object make object Point x y void activating oldcursor widget cursor widget setCursor cursor void deactivating widget setCursor oldcursor QCursor cursor QCursor oldcursor namespace CGAL The Qt widget forwards mouse and keyboard events to the attached layer In the above example only the mousePressEvent member function is overloaded Tools that create new CGAL objects must call the member function Qt widget new object CGAL Object The Qt widget then emits the signal new cgal object CGAL Object This signal can be routed to any slot of other object accepting a CGAL Object with the following connect statement connect qt widget ptr SIGNAL new cgal object CGAL Object any other object ptr SLOT any other slot CGAL Object The first argument must be a pointer to an instance of Qt widget In the example we connect it to MyWindow get new object CGAL Object 16 4 The Standard Toolbar The Qt widget allows to zoom and pan This functionality is accessible through the class Qt widget standard toolbar The example further down shows how to use it in your application The functionality of the toolbar is as follows from the left to right History back Go back into the transformation history History forth Go forth into the transformation history Zoom In The scaling factor is multiplied by two keeping the same center Zoom Out The scaling factor is divided by two keeping the same center Point tool Deactivate the layers corresponding to the three following buttons which form an exclusive group Focus on Point Lets you choose the center of the region where you want to focus Focus on the Region The area in the rectangle that you selected will be magnified to best fit in the window Hand Tool Used for translate Click to select the first point of translation and drag to select the second point Mouse Coordinates Layer Mouse coordinates are displayed on the status bar of your window You can deactivate this layer if you click on it To activate it again just click one more time Example demo Qt widget Examples Standard toolbar C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Cartesian h include CGAL Delaunay triangulation 2 h include CGAL IO Qt widget Delaunay triangulation 2 h include qapplication h include qmainwindow h include CGAL IO Qt widget h include CGAL IO Qt widget standard toolbar h include CGAL point generators 2 h typedef CGAL Cartesian double Rep typedef CGAL Point 2 Rep Point 2 typedef CGAL Delaunay triangulation 2 Rep Delaunay Delaunay dt class My window public QMainWindow Q OBJECT public My window int x int y widget new CGAL Qt widget this setCentralWidget widget resize x y widget show widget set window x y CGAL Random points in disc 2 Point 2 g 5 for int count count 1 count dt insert g How to attach the standard toolbar std toolbar new CGAL Qt widget standard toolbar widget this Standard Toolbar connect widget SIGNAL redraw on back this SLOT redraw win private slots functions void redraw win widget dt private members CGAL Qt widget widget CGAL Qt widget standard toolbar std toolbar moc source file standard toolbar C include standard toolbar moc int main int argc char argv QApplication app argc argv My window W 6 6 app setMainWidget W W show W setCaption Using the Standard Toolbar return app exec endif This example generates 1 points and inserts them in a Delaunay triangulation Using the standard toolbar you can zoom in zoom out translate 16 5 The Help Window We provide a class in the Qt widget library that was taken from an example of Qt and adapted to our needs This class has the functionality of a rich text browser with hypertext navigation You can also PRINT GO BACK GO FORWARD or GO HOME This class is called Qt help window and you can use it to display hypertext support in your application It is used in a lot of demos provided in the distribution Example include CGAL IO Qt help window h QString home help index html Qt help window help new Qt help window home help viewer help resize 4 4 help setCaption Demo HowTo help show 16 6 Some Predefined Icons CGAL provides some icons defined in some header files The icons are pixmaps having the extension xpm Their location is include CGAL IO pixmaps To use a pixmap in your code you have to include the right file and to know the names of the pixmaps The names of the pixmaps are composed of two parts the name of the file and the tag xpm So for example the arrow pixmap has the name arrow xpm the line pixmap has the name line xpm and so on There are also pixmaps files that contain small icons The name of the smaller pixmaps contain a small at the middle of it like point small xpm In the tutorials and demos almost all the pixmaps are used for the toolbar buttons like this Example include CGAL IO pixmaps point xpm QIconSet set QPixmap const char point small xpm QPixmap const char point xpm QToolButton point button point button new QToolButton toolbar ptr POINT INPUT BUTTON point button setIconSet set point button setTextLabel POINT INPUT LAYER 16 7 What Shall I Use The previous sections presented different ways of writing Qt based applications We recommend to use layers for the drawing task and for input handling even if you write tiny applications because in general they grow over time Layers are a little bit more overhead but it pays off in the long run as you then do not have to completely reorganize your code to add layers Footnotes 1 http www trolltech com Next chapter Qt widget Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Qt_widget/Chapter_main.html", "title": "qt_widget", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Qt_widget/main.tex' -->\n<html> <head>  \n<title>Qt_widget</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_16\"></a>\n  \n<h1>Chapter 16<BR>Qt_widget</h1>\n\n<A NAME=\"chapterQtwidget\"></A>\n\n<EM>Laurent Rineau  and Radu Ursu</EM><BR>\n\n\n<P>\n\n<CENTER>\n<IMG BORDER=0 SRC=\"triangulation.gif\"  ALIGN=center  ALT=\"A Nice Screen Shoot\">\n</CENTER>\n<P>\n\n<I>Qt</I> is a G<SMALL>UI</SMALL> toolkit<A HREF=\"#Footnote_1\"><SUP>1</SUP></A> for\ncross-platform application development.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>16.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nThis chapter describes the <I>Qt_widget</I> package which provides\nan interface between C<SMALL>GAL</SMALL>  and the  G<SMALL>UI</SMALL> toolkit <I>Qt</I> .\nThe <I>Qt_widget</I> package allows to build <I>Qt</I> \napplications  showing two dimensional C<SMALL>GAL</SMALL> objects \nand algorithms.\n<P>\n\nThe atom of the <I>Qt</I> user interface is called a widget.\nA widget receives mouse, keyboard and other \nevents from the window system, and paints a representation of itself on the \nscreen. Widgets are rectangular, and the different widgets\nof an application  are sorted in a Z-order. Widgets\ncan have a parent widget and  children.\nA widget is clipped by its parent and by the widgets in front of it.\n<P>\n\nThe most important class in the package\nis the class <I>Qt_widget</I> which implements a widget\nproviding \na drawing <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> and output stream operators for C<SMALL>GAL</SMALL> \ntwo dimensional objects.  <I>Qt_widget</I> also provides\nzooming and panning functionalities.\n<P>\n\nThe <I>Qt_widget</I> allows to attach <I>layers</I>. Layers usually\ndraw on the drawing <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> of the widget. Layers can be activated and\ndeactivated, and what you see in the drawing <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> is the overlay of\nall attached activated layers. Layers can also be used for entering\ninput, and C<SMALL>GAL</SMALL> provides input <I>layers</I> for the two-dimensional\nC<SMALL>GAL</SMALL> objects.\n<P>\n\nThe package includes also the class <I><A HREF=\"../Qt_widget_ref/Class_Qt_widget_standard_toolbar.html#Cross_link_anchor_1782\">Qt_widget_standard_toolbar</A></I>\n providing a  standard toolbar for controlling the basic functionality\nof the <I>Qt_widget</I>.\n<P>\n\nThe following sections describe the main class as well as the helper classes\nin more detail and give examples that can be taken as starting points for\nnew applications.\n<P>\n\n<B>Remark:</B> The <I>Qt_widget</I> is distributed under\nthe Q<SMALL>PL</SMALL>, which is Trolltech's open source license. For more details\non the Q<SMALL>PL</SMALL> see http://www.trolltech.com/developer/licensing/qpl.html.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>16.2&nbsp;&nbsp;&nbsp;Qt_widget</h2>\n\n<A NAME=\"Qt_widget\"></A>\n<P>\n\nThe class <I>Qt_widget</I> is derived from the class \n<I>QWidget</I> \nwhich is the base class of all <I>Qt</I> user interface objects.\n<P>\n\nThe <I>Qt_widget</I> provides output operators for two dimensional C<SMALL>GAL</SMALL> objects. There are operators defined for output of: points, segments, \nlines, rays, circles, triangles, rectangles, polygons, conics,  and all type of\ntriangulations. Also some operators are defined to set\n<I>Qt_widget</I>'s properties, like background and fill color, as\nwell as line width and point size.\n<P>\n\nAs the following examples show, simple applications can be written\nwithout the layers.\n<P>\n\n<h3>16.2.1&nbsp;&nbsp;&nbsp;Example: Hello Segment</h3>\n\nThe first example draws a red segment on an orange background.\n<pre class=\"ExampleCode\">//demo/Qt_widget/Examples/hellosegment.C\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/IO/Qt_widget.h&gt;\n\n#include &lt;qapplication.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;int&gt; Rep;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;Rep&gt; <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_55\">CGAL::Segment_2</A>&lt;Rep&gt; Segment;\n\nint main( int argc, char **argv )\n{\n  QApplication app( argc, argv );\n  CGAL::Qt_widget *w = new CGAL::Qt_widget();\n  app.setMainWidget( w );\n  w-&gt;resize(600, 600);\n  w-&gt;set_window(0, 600, 0, 600);\n  w-&gt;show();\n  w-&gt;lock();\n  *w &lt;&lt; CGAL::BackgroundColor(CGAL::ORANGE) &lt;&lt; CGAL::RED;\n  *w &lt;&lt; Segment(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(100,100), <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(400,400));\n  w-&gt;unlock();\n  return app.exec();\n}\n#endif\n</pre>\n<P>\n\nWe follow the <I>Qt</I> naming conventions for material properties, for\nexample, the CGAL::BackgroundColor above.\n<P>\n\nAll the drawing code should be put between <I>Qt_Widget</I>'s lock() and\nunlock() functions. See the manual reference pages of\n<I>Qt_widget</I>. Doing like this, the window will be updated only\nonce, when <I>Qt_widget</I> finds the last unlock(). This way you\ncan avoid the window flickering.\n<P>\n\nThis example has a severe drawback: when you resize the window it is\nempty, as nothing is redrawn. This style of programs makes\nonly sense, if you quickly want to validate output of a geometric\ncomputation. As in any event driven G<SMALL>UI</SMALL> application,\n <I>Qt</I>  provides a callback mecanism so\nthat the window system can update the drawing\nwhenever necessary. This is the topic of the next example.\n<P>\n\n<h3>16.2.2&nbsp;&nbsp;&nbsp;Example: Signals and Slots</h3>\n<P>\n\nThis example is slightly more involved and uses  the\nsignal/slots mecanism of <I>Qt</I> .\n<P>\n\nThe main widget shows a\nDelaunay triangulation. Every time the mouse button is pressed over \nthe widget, a point is input  and inserted in the Delaunay\ntriangulation. The result of this insertion appears immediately.\nFurthermore, the drawing is  updated every time the window is resized.\n<P>\n\n<pre class=\"ExampleCode\">//demo/Qt_widget/Examples/tutorial2.C\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/IO/Qt_widget_Triangulation_2.h&gt;\n#include &lt;CGAL/IO/Qt_widget.h&gt;\n#include &lt;qapplication.h&gt;\n#include &lt;qmainwindow.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;             K;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                          <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;K&gt;   Delaunay;\n\nDelaunay dt;\n\nclass My_window : public QMainWindow {\n  Q_OBJECT\npublic:\n  My_window(int x, int y)\n  {\n    widget = new CGAL::Qt_widget(this);\n    widget-&gt;resize(x,y);\n    widget-&gt;set_window(0, x, 0, y);\n\n    connect(widget, SIGNAL(redraw_on_back()),\n\t   this, SLOT(redraw_win()));\n\n    connect(widget, SIGNAL(s_mousePressEvent(QMouseEvent*)),\n\t    this, SLOT(mousePressEvent(QMouseEvent*)));\n\n    setCentralWidget(widget);\n  };\nprivate slots:  \n  void redraw_win()\n  {\n    *widget &lt;&lt; dt;\n  }\n\n  void mousePressEvent(QMouseEvent *e)\n  {\n    dt.insert(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(widget-&gt;x_real(e-&gt;x()), widget-&gt;y_real(e-&gt;y())));\n    widget-&gt;redraw();\n  }\n\nprivate: // private data member\n  CGAL::Qt_widget* widget;\n};\n\n//moc_source_file : tutorial2.C\n#include &quot;tutorial2.moc&quot;\n\nint main( int argc, char **argv )\n{\n    QApplication app( argc, argv );\n    My_window *w = new My_window(400,400);\n    app.setMainWidget( w);\n    w-&gt;show();\n    return app.exec();\n}\n#endif\n</pre>\n<P>\n\n<I>Qt</I> applications are event driven and respond to user interaction.\nFor example, when a user clicks on a menu item or on a toolbar button,\nthe application executes some codes. The programmer of an\napplication has to be able to relate events to the relevant code.\n<I>Qt</I> provide for that the signals/slots mecanism:\n<DL>\n<LI><B>Signals.</B>\nEach <I>Qt</I> widget declares a set of signals which, using the\nkeyword <I>emit</I>  can be  emitted by member functions \nunder some circumstances. Signals are declared by using \nthe keyword <I>signals:</I> just like an\naccess specifier in your class declaration.\n<LI><B>Slots.</B>\nA slot is just a member function declared under a public (or private)\nslots section.\n<LI><B>Connect.</B>\nSignals and slots can be connected together using the method \n<I>connect</I>. This method needs to know four things: the object\nthat sends out the signal, the signal, \nthe object to which belong the connected slot\nand the slot connected to the signal.\nFor instance, the statement:\n<pre class=\"ExampleCode\">\nconnect(widget, SIGNAL(redraw_on_back()),\n        this, SLOT(redraw_win()));\n</pre>\n<P>\n\nconnects the signal <I>redraw_on_back()</I> of the widget <I>widget</I>\nto the slot <I>redraw_win()</I> of the <I>QMainWindow</I> <I>his</I>.\nSignals and slots can have any type of arguments, but a signal and a\nslot connected together must have the same arguments types.\n</DL>\n<P>\n\nEvery class that defines at least a signal or a slot must be derived\nfrom the class <I>QObject</I> and must use the macro Q_<SMALL>OBJECT</SMALL>\ninside the private section of its declaration. You also need to run\n<I>moc</I>, the <I>Meta <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> Compiler</I> supplied with <I>Qt</I> on the\nfile that contains the class declaration.\n<P>\n\n<I>moc</I> is a pre-compiler that produces the <I>meta object</I> code\nof each class that uses the macro Q_<SMALL>OBJECT</SMALL>. This <I>meta\n  object</I> code is needed by the signal/slot mecanism. There are\nseveral methods to compile the outputs of <I>moc</I>. In CGAL, we have\nchosen to include the outputs of <I>moc</I> in a source files. See the\n<I>Qt</I> documentation on <I>moc</I> for other possibilities.\n<P>\n\nThe line <I>//moc_source_file : tutorial2.C</I> is for users that use\nmakefiles. This line tells to the C<SMALL>GAL</SMALL> makefile generator that\n<I>tutorial2.C</I> should be the file that <I>moc</I> should be run on.\n<P>\n\nLet us come back to the control flow in the above example.\nThe main widget of the application is the widget <I>w</I>\nof  class <I>My_window</I>.  The creator  of \n<I>My_window</I> triggers the creation of a <I>Qt_widget</I>\naccessible through the pointer <I>widget</I>.\nWhen  the mouse button is pressed in its drawing <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A>,\nthe <I>Qt_widget</I> \nemits the signal  <I>s_mousePressEvent(QMouseEvent*)</I>\nconnected to the slot <I>mousePressEvent(QMouseEvent*)</I> of <I>My_window</I>.\nThis slot inserts the point in the Delaunay triangulation\nand calls the method <I>redraw()</I> of <I>Qt_widget</I>.\nThe  <I>redraw()</I> method of <I>Qt_widget</I>\nemits the signal <I>redraw_on_back()</I>. This signal is\nconnected to the slot <I>redraw_win()</I>\nof  <I>My_window</I> which actually draws the triangulation.\nNote that the  <I>Qt_widget</I>  emits the same signal\n<I>redraw_on_back()</I> when the window is resized. Thus,\nthe signals/slots connection  ensures that the\ntriangulation is redrawn  each time the redrawing is needed.\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\nThere are several ways to draw something with <I>Qt_widget</I>. One way\nis to use the signals <I>redraw_on_back()</I>, <I>redraw_on_front()</I>.\nThis way you can bring your drawings before all or after all the\nother drawings. An other option is to use the <I>QPainter</I> instance \nof <I>Qt_widget</I> that you can get calling <I>get_painter()</I>\nmethod. The most recommended way is to use layers, that are described\nin the next section.\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\nNote that in that example, the <I>My_window</I> constructor calls\n<I>new</I> to allocate a new <I>Qt_widget</I> object but <I>delete</I> is\nnever called to deallocate it. This does not mean that there is a\nmemory leak. It is in Qt's responsability to free widgets that have a\nparent. In that example the <I>My_window</I> object is the parent of\n<I>widget</I> and will deallocate it automatically at its destruction.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>16.3&nbsp;&nbsp;&nbsp;Layers</h2>\n\n<A NAME=\"Qt_widget_layers\"></A>\n\n<h3>16.3.1&nbsp;&nbsp;&nbsp;Using Layers to Draw</h3>\n<P>\n\nIn the examples from the previous section the code for drawing on the\nwidget was in the <I>redraw_win()</I> function. As soon as the\napplications are more involved it leads to a more modular design if\none delegates the drawing task to <I>layers</I>. For example, if the\napplication displays a Delaunay triangulation, the corresponding\nVoronoi diagram, and at the same time highlights the nearest vertex to\nthe mouse coordinates, it makes sense to have three independent\nlayers. Besides better code, layers have the advantage that they can\nbe activated and deactivated at runtime. Finally, more modularity\nmeans a higher potential for reuse.\n<P>\n\nA layer can be <I>attached</I> to a <I>Qt_widget</I>. The <I>redraw()</I>\nmember function of the <I>Qt_widget</I> calls\nthe method <I><A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A>::draw()</I> of all attached layers, in the\norder that they were attached. It is a very simple rule: the last layer\nattached will be drawn on top.\n<P>\n\nAlso a layer can be <I>activated</I> and <I>deactivated</I>. Only active\nlayers are drawn, and by default a layer is activated when it gets\nattached.  Note that deactivating and activating do not influence the\norder of layers. You can change the order only by attaching and\ndetaching it.\n<P>\n\nC<SMALL>GAL</SMALL> provides a base class so that users can write their own\nlayers. All the layers have to derive from this base class\n<I><A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A></I> to have the functionality described.\n<P>\n\n<h3>16.3.2&nbsp;&nbsp;&nbsp;Example: Using a Layer to Draw</h3>\n<P>\n\n<H3>Example</H3><pre class=\"ExampleCode\">\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/IO/Qt_widget_Delaunay_triangulation_2.h&gt;\n#include &lt;CGAL/IO/Qt_widget.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A>.h&gt;\n#include &lt;qapplication.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;             Rep;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;Rep&gt;                  Point;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;Rep&gt; Delaunay;\n\nDelaunay dt;\n\nclass My_layer : public <A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1761\">CGAL::Qt_widget_layer</A>{\n  void draw(){\n    *widget &lt;&lt; dt;\n  }\n};\n\nclass My_window : public CGAL::Qt_widget {\npublic:\n  My_window(int x, int y)\n  {\n    resize(x,y);\n    attach(&amp;layer);\n  };\nprivate:\n  //this method is called when the user presses the mouse\n  void mousePressEvent(QMouseEvent *e)\n  {\n    Qt_widget::mousePressEvent(e);\n    dt.insert(Point(x_real(e-&gt;x()), y_real(e-&gt;y())));\n    redraw();\n  }\n  My_layer layer;\n};\n\nint main( int argc, char **argv )\n{\n    QApplication app( argc, argv );\n    My_window *W = new My_window(400,400);\n    app.setMainWidget(W);\n    W-&gt;show();\n    W-&gt;set_window(0, 400, 0, 400);\n    return app.exec();\n}\n</pre>\n<P>\n\nThis example defines a class derived from\n<I><A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A></I>. In the member function <I>draw()</I>\nis the code for drawing the triangulation. In <I>My_Window</I>\nclass you need an instance of <I>My_Layer</I> and you will \nhave to attach it, if you want to see what the layer draws on the\nscreen.\n<P>\n\nAs you see, this example is very similar to the previous one, but\nthe code for drawing the triangulation is no longer in the\n<I>redraw_win()</I> function, but in a layer.\n<P>\n\n<h3>16.3.3&nbsp;&nbsp;&nbsp;Using Layers to Build New Objects</h3>\n\n<A NAME=\"Qt_widget_tools\"></A>\n<P>\n\nThe main purpose of layers is to have more modular code for drawing on\nthe widget. Things are similar for handling input. In the previous\nexamples, input went through the <I>Qt_widget::mousePressedEvent()</I>\ncallback, which interpreted the input. In applications where you have\ndifferent kinds of input, e.g., segments and polygons in an\narrangement demo, this quickly leads to unreadable, difficult to maintain\ncode,  especially as typically more than one event callback is\ninvolved. The proper way of decomposition, is delegation\nof the event handling to a <I>layer</I>.\n<P>\n\nA layer for <I>Qt_widget</I> receives all the events from\n<I>Qt_widget</I> if it is active and can provide some functionality\nlike input objects for <I>Qt_widget</I>. Notice that the layers\nreceive events in the order they have been attached. Layers can have\ninternal state, because for entering complex objects it needs several\nevents. Therefore layers must have functions to initialize state when\nthey are activated and to clean up when they are deactivated.\n<P>\n\nC<SMALL>GAL</SMALL> provides some predefined input layers. You can have a lot of\nlayers attached that could be active in the same time. You have to\ntake care how you manage the events if you do not want to have\nconflicts. A conflict is when two attached layers that are active need \nboth the same event and getting and using it might not have such a\ngood effect in your application. For example the predefined layers that \nbuilds a new line and a new circle produce bad visual effects when are \nboth active.\n<P>\n\nYou can resolve conflicts by using <I>layers</I> exclusive. If you have \nseveral layers that can not be active at the same time without creating\nconflicts, you can resolve that by letting the user not activate\nmore than one of those at a time.\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\nIn all the C<SMALL>GAL</SMALL> demos that are provided, the layers are used with a\ntoolbar and buttons. To activate and deactivate a layer you have to\nclick one of the toolbar buttons. There are layers that need exclusive \nuse. This is accomplished by grouping the buttons in one group, and\nmaking that group exclusive. The group class is <I>QButtonGroup</I> that\ncomes with <I>Qt</I> .\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\nWe first show how to use layers and then how they work.\n<P>\n\n<h3>16.3.4&nbsp;&nbsp;&nbsp;Example: How to Use a Layer</h3>\n<P>\n\nIn the previous section, you could insert new points in the\ntriangulation by clicking on the widget. This example shows how\nthe same can be achieved with the help of a layer.\n<P>\n\nWe attach the predefined layer <I><A HREF=\"../Qt_widget_ref/Class_Qt_widget_get_point.html#Cross_link_anchor_1764\">Qt_widget_get_point</A></I> to the widget,\nand connect the signal emitted by the widget to the function that\nhandles the input.  When the user clicks with the left mouse button,\nthe layer creates a point and passes it to the widget. The widget then\nemits a signal that gets passed to the connected slot\n<I>My_Window::get_new_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)</I>.\n<P>\n\n<pre class=\"ExampleCode\">//demo/Qt_widget/Examples/layer.C\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/IO/Qt_widget_Delaunay_triangulation_2.h&gt;\n#include &lt;CGAL/IO/Qt_widget.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Qt_widget_ref/Class_Qt_widget_get_point.html#Cross_link_anchor_1764\">Qt_widget_get_point</A>.h&gt;\n\n#include &lt;qapplication.h&gt;\n#include &lt;qmainwindow.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;             Rep;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;Rep&gt;                  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;Rep&gt; Delaunay;\n\nDelaunay dt;\n\nclass My_Layer : public <A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1761\">CGAL::Qt_widget_layer</A>{\n  void draw(){\n    *widget &lt;&lt; dt;\n  }\n};\n\nclass My_Window : public QMainWindow {\n  Q_OBJECT\npublic:\n  My_Window(int x, int y){\n    widget = new CGAL::Qt_widget(this, &quot;CGAL Qt_widget&quot;);\n    setCentralWidget(widget);\n    resize(x,y);\n    widget-&gt;attach(&amp;get_point);\n    widget-&gt;attach(&amp;v);\n    connect(widget, SIGNAL(new_cgal_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)), \n            this, SLOT(get_new_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)));\n    widget-&gt;set_window(0, 600, 0, 600);\n  };\nprivate:\t//members\n  <A HREF=\"../Qt_widget_ref/Class_Qt_widget_get_point.html#Cross_link_anchor_1763\">CGAL::Qt_widget_get_point</A>&lt;Rep&gt; get_point;\n  My_Layer v;\n  CGAL::Qt_widget *widget;\nprivate slots:\n  void get_new_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A> obj)\n  {\n    <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p;\n    if (<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(p, obj)) { \n      dt.insert(p);\n    }\n    widget-&gt;redraw();\n  }\n}; //endclass\n\n//  moc_source_file : layer.C\n#include &quot;layer.moc&quot;\n\nint main( int argc, char **argv )\n{\n    QApplication app( argc, argv );\n    My_Window *W = new My_Window(600,600);\n    app.setMainWidget( W );\n    W-&gt;show();\n    return app.exec();\n}\n#endif\n</pre>\n<P>\n\nThe <I>Qt_widget</I> forwards all events that it receives to the\nattached and active layers. If a layer is attached but not active, it\ndoes not get the events. It is put in a passive state. Activating and\ndeactivating the layer does not mean that the object is destructed.\n<P>\n\n<h3>16.3.5&nbsp;&nbsp;&nbsp;Example: How Layers Work</h3>\n<P>\n\nThe following is an example of a <I>layer</I> that creates C<SMALL>GAL</SMALL> points when\nthe user clicks the left mouse button over the widget.\n<P>\n\n<pre class=\"ExampleCode\">\n#include &lt;CGAL/IO/Qt_widget.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A>.h&gt;\n#include &lt;qcursor.h&gt;\n\n#ifndef CGAL_QT_WIDGET_GET_POINT_BUTTON\n#define CGAL_QT_WIDGET_GET_POINT_BUTTON Qt::LeftButton\n#endif\n\nnamespace CGAL {\ntemplate &lt;class R&gt;\nclass <A HREF=\"../Qt_widget_ref/Class_Qt_widget_get_point.html#Cross_link_anchor_1764\">Qt_widget_get_point</A> : public <A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A>\n{\npublic:\n  typedef typename R::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>   Point;\n  typedef typename R::FT        FT;\n  \n  <A HREF=\"../Qt_widget_ref/Class_Qt_widget_get_point.html#Cross_link_anchor_1764\">Qt_widget_get_point</A>(const QCursor c=QCursor(Qt::crossCursor),\n                      QObject* parent = 0, const char* name = 0) :\n    <A HREF=\"../Qt_widget_ref/Class_Qt_widget_layer.html#Cross_link_anchor_1762\">Qt_widget_layer</A>(parent, name), cursor(c) {};\n  \nprivate:\n  bool is_pure(Qt::ButtonState s){\n    if((s &amp; Qt::ControlButton) ||\n       (s &amp; Qt::ShiftButton) ||\n       (s &amp; Qt::AltButton))\n      return 0;\n    else\n      return 1;\n  }\n  void mousePressEvent(QMouseEvent *e)\n  {\n    if(e-&gt;button() == CGAL_QT_WIDGET_GET_POINT_BUTTON\n       &amp;&amp; is_pure(e-&gt;state()))\n    {\n      FT x, y;\n      widget-&gt;x_real(e-&gt;x(), x);\n      widget-&gt;y_real(e-&gt;y(), y);\n      widget-&gt;new_object(<A HREF=\"../Kernel_23_ref/Function_make_object.html#Cross_link_anchor_92\">make_object</A>(Point(x, y)));\n    }\n  };\n  void activating()\n  {\n    oldcursor = widget-&gt;cursor();\n    widget-&gt;setCursor(cursor);\n  };\n  \n  void deactivating()\n  {\n    widget-&gt;setCursor(oldcursor);\n  };\n\n  QCursor cursor;\n  QCursor oldcursor;\n};\n} // namespace CGAL\n</pre>\n<P>\n\nThe <I>Qt_widget</I> forwards mouse and keyboard events to the attached layer.\nIn the above example only the <I>mousePressEvent</I> member function is overloaded.\n<P>\n\nTools that create new C<SMALL>GAL</SMALL> objects, must call the member \nfunction <I>Qt_widget::new_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)</I>. The\n<I>Qt_widget</I> then emits the signal\n<I>new_cgal_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)</I>. This signal can be routed to\nany slot of other object accepting a <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A></I>, with the\nfollowing connect statement:\n<pre class=\"ExampleCode\">\nconnect(qt_widget_ptr, SIGNAL(new_cgal_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)), \n        any_other_object_ptr, SLOT(any_other_slot(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)));\n</pre>\n<P>\n\nThe first argument must be a pointer to an instance of <I>Qt_widget</I>.\nIn the example we connect it to <I>MyWindow::get_new_object(<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A>)</I>.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>16.4&nbsp;&nbsp;&nbsp;The Standard Toolbar</h2>\n\n<A NAME=\"Qt_widget_standard_toolbar\"></A>\n<P>\n\nThe <I>Qt_widget</I> allows to zoom and pan. This functionality is \naccessible through the class <I><A HREF=\"../Qt_widget_ref/Class_Qt_widget_standard_toolbar.html#Cross_link_anchor_1782\">Qt_widget_standard_toolbar</A></I>. The \nexample further down shows how to use it in your application.\n<P>\n\n<CENTER>\n<IMG BORDER=0 SRC=\"standard_toolbar.gif\"  ALIGN=center  ALT=\"The\nstandard toolbar\">\n</CENTER>\n<P>\n\nThe functionality of the toolbar is as follows from the left to right:\n<DL>\n<DT><B>History back:</B><DD> Go back into the transformation history\n        <DT><B>History forth:</B><DD> Go forth into the transformation history\n        <DT><B>Zoom In:</B><DD> The scaling factor is multiplied by two,\nkeeping the same center.\n        <DT><B>Zoom Out:</B><DD> The scaling factor is divided by two, keeping\nthe same center.\n       <DT><B>Point tool:</B><DD> Deactivate the layers corresponding to the\nthree following buttons which form an exclusive group\n        <DT><B>Focus on Point:</B><DD> Lets you choose the center of the\nregion where you want to focus.\n        <DT><B>Focus on the Region:</B><DD> The <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> in the rectangle that you selected will be magnified to best fit in the window.\n        <DT><B>Hand Tool:</B><DD> Used for translate. Click to select the\nfirst point of translation and drag to select the second point.\n        <DT><B>Mouse Coordinates Layer:</B><DD> Mouse coordinates are\ndisplayed on the status bar of your window.  You can deactivate this\nlayer if you click on it. To activate it again just click one more time.\n</DL>\n<P>\n\n<H3>Example</H3><pre class=\"ExampleCode\">//demo/Qt_widget/Examples/Standard_toolbar.C\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/IO/Qt_widget_Delaunay_triangulation_2.h&gt;\n\n#include &lt;qapplication.h&gt;\n#include &lt;qmainwindow.h&gt;\n\n#include &lt;CGAL/IO/Qt_widget.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Qt_widget_ref/Class_Qt_widget_standard_toolbar.html#Cross_link_anchor_1782\">Qt_widget_standard_toolbar</A>.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;             Rep;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;Rep&gt;                  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;Rep&gt; Delaunay;\n\nDelaunay dt;\n\nclass My_window : public QMainWindow{\n  Q_OBJECT\npublic:\n  My_window(int x, int y)\n  {\n    widget = new CGAL::Qt_widget(this);\n    setCentralWidget(widget);\n    resize(x,y);\n    widget-&gt;show();\n    widget-&gt;set_window(0, x, 0, y);\n\n    <A HREF=\"../Generator_ref/Class_Random_points_in_disc_2.html#Cross_link_anchor_1695\">CGAL::Random_points_in_disc_2</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&gt; g(500);\n    for(int count=0; count&lt;100; count++) {\n      dt.insert(*g++);\n    }\n    \n    //How to attach the standard toolbar\n    std_toolbar = new <A HREF=\"../Qt_widget_ref/Class_Qt_widget_standard_toolbar.html#Cross_link_anchor_1781\">CGAL::Qt_widget_standard_toolbar</A>(widget, this,\n\t\t\t\t\t\t       &quot;Standard Toolbar&quot;);\n\n    connect(widget, SIGNAL(redraw_on_back()),\n\t    this, SLOT(redraw_win()) );\n  }\n\nprivate slots:\t//functions\n  void redraw_win()\n  {\n    *widget &lt;&lt; dt;\n  }\n\nprivate:\t//members\n  CGAL::Qt_widget *widget;\n  <A HREF=\"../Qt_widget_ref/Class_Qt_widget_standard_toolbar.html#Cross_link_anchor_1781\">CGAL::Qt_widget_standard_toolbar</A> *std_toolbar;\n};\n\n// moc_source_file: standard_toolbar.C\n#include &quot;standard_toolbar.moc&quot;\n\nint main( int argc, char **argv )\n{\n    QApplication app( argc, argv );\n    My_window W(600,600);\n    app.setMainWidget( &amp;W );\n    W.show();\n    W.setCaption(&quot;Using the Standard Toolbar&quot;);\n    return app.exec();\n}\n#endif\n</pre>\n<P>\n\nThis example generates 100 points and inserts them in a Delaunay\ntriangulation. Using the standard toolbar you can zoom in, zoom out,\ntranslate.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>16.5&nbsp;&nbsp;&nbsp;The Help Window</h2>\n\n<A NAME=\"The Help Window\"></A>\n<P>\n\nWe provide a class in the <I>Qt_widget</I> library that was taken from\nan example of <I>Qt</I> and adapted to our needs. This class has the\nfunctionality of a rich text browser with hypertext navigation. You\ncan also PRINT, GO BACK, GO FORWARD or GO HOME. This class is called\n<I><A HREF=\"../Qt_widget_ref/Class_Qt_help_window.html#Cross_link_anchor_1786\">Qt_help_window</A></I> and you can use it to display hypertext support\nin your application. It is used in a lot of demos provided in the\ndistribution.\n<P>\n\n<H3>Example</H3><pre class=\"ExampleCode\">\n    #include &lt;CGAL/IO/<A HREF=\"../Qt_widget_ref/Class_Qt_help_window.html#Cross_link_anchor_1786\">Qt_help_window</A>.h&gt;\n        ....\n    QString home = &quot;help/index.html&quot;;\n    <A HREF=\"../Qt_widget_ref/Class_Qt_help_window.html#Cross_link_anchor_1786\">Qt_help_window</A> *help = new <A HREF=\"../Qt_widget_ref/Class_Qt_help_window.html#Cross_link_anchor_1786\">Qt_help_window</A>(home, &quot;.&quot;, 0, &quot;help viewer&quot;);\n    help-&gt;resize(400, 400);\n    help-&gt;setCaption(&quot;Demo HowTo&quot;);\n    help-&gt;show();\n</pre>\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>16.6&nbsp;&nbsp;&nbsp;Some Predefined Icons</h2>\n\n<A NAME=\"The predefined icons\"></A>\n<P>\n\nC<SMALL>GAL</SMALL> provides some icons defined in some header files. The icons are\npixmaps, having the extension <I>.xpm</I>. Their location is <I>/include/CGAL/IO/pixmaps</I>.\n<P>\n\nTo use a pixmap in your code you have to include the right file, and\nto know the names of the pixmaps. The names of the pixmaps are\ncomposed of two parts, the name of the file and the tag xpm. So for\nexample the arrow pixmap has the name <I>arrow_xpm</I>, the line\npixmap has the name <I>line_xpm</I>, and so on. There are also \npixmaps files that contain small icons. The name of the smaller \npixmaps contain a <I>small</I> at the middle of it like <I>point_small_xpm</I>.\nIn the tutorials and demos, almost all the pixmaps are used for the \ntoolbar buttons, like this:\n<P>\n\n<H3>Example</H3><pre class=\"ExampleCode\">\n    \n    #include &lt;CGAL/IO/pixmaps/point.xpm&gt;\n    \n    QIconSet set(QPixmap( (const char**)point_small_xpm ),\n                  QPixmap( (const char**)point_xpm ));\n\n    QToolButton *point_button;\n    point_button = new QToolButton(toolbar_ptr, &quot;POINT INPUT BUTTON&quot;);\n    point_button-&gt;setIconSet(set);\n    point_button-&gt;setTextLabel(&quot;POINT INPUT LAYER&quot;);\n\n</pre>\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>16.7&nbsp;&nbsp;&nbsp;What Shall I Use?</h2>\n<P>\n\nThe previous sections presented different ways of writing <I>Qt</I> based \napplications. We recommend to use layers for the drawing task and for\ninput handling, even if you write tiny applications, because in general\nthey grow over time. Layers are a little bit more overhead, but \nit pays off in the long run, as you then do not have to completely\nreorganize your code, to add layers.\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nhttp://www.trolltech.com\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Qt_widget_ref/Chapter_intro.html\">Qt_widget</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_16!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39436.0}