{"text": "ICS 33 Summer 2 13 News Course Reference Schedule Project Guide Code Examples About Alex ICS 33 Summer 2 13 Project 3 Careful With That Axe Eugene Due date and time Friday August 9 11 59pm Introduction In the United States and various parts of the world lotteries offer people the chance to make a very inexpensive purchase of a ticket in hopes of reaping a windfall if they win the jackpot which is quite often many millions of times the cost of the ticket The odds of winning are infinitesimal of course as a practical matter playing seems to make little sense but some players enjoy the brief dream of better days before discovering that yet again they haven t won And there s always that chance This project is centered around the concept of lotteries It continues our exploration into some of the deeper areas of Python that allow us to create abstractions that we can use cleanly and clearly in other parts of a program As we ve seen previously we should prefer to keep the little details of our program as localized as possible if we can solve a problem once and not have to think about it again that s a lot better than having to solve it over and over again Additionally any time we can eliminate redundant code from a program we re always better off The level of care required is more than you might be accustomed to but is one of the key skills you need to build if you want to successfully write programs tens or hundreds of times the size of the programs we ve been writing in ICS 31 32 and 33 In particular we ll cross a few bridges we ve not yet crossed Writing a potentially infinite set of similar classes without having to write them one by one Computers excel at boring repetitive work so we should write programs to do that kind of work writing many classes that are largely identical is one of the many examples of the kind of work you can automate easily in Python Making your classes more bullet proof by prohibiting misuse and failing fast when objects of your classes are used in ways that don t make sense Objects of built in types like lists and tuples fail immediately and tell you why when you try to use them in ways you shouldn t objects of your classes should do that too Expanding your ability to write unit tests including tests that expect exceptions to be raised which you may not have written previously Background on lotteries This project is centered around the concept of a lottery As is often the case when you dive into a new problem domain one of the first hurdles to clear is to understand the concepts and terminology relevant to the domain A lottery game involves the selling of tickets each of which contains a set of numbers selected by a person or sometimes selected randomly by a computer instead The numbers are generally integers chosen in a fairly small range Note the fact that a ticket is a set of numbers meaning that the order in which the numbers are selected is considered irrelevant At a prescribed time a drawing is held in which one more set of numbers is selected randomly A ticket is a winner if it contains the same set of numbers selected in the drawing Often there are lesser winners who receive a smaller prize for matching some but not all of the numbers While most lottery games are fairly similar they are differentiated by a few parameters A name such as Powerball or Mega Millions This is primarily a marketing concept but one that is nonetheless a well known differentiator A number count which specifies how many numbers a player must choose and how many will be chosen during the drawing A number range which specifies the range in which the chosen numbers must reside For example the lottery game BooLotto might have a number count of 6 and a number range of 1 45 meaning that players must select six numbers between 1 and 45 inclusive and that the drawing will be selected according to the same rules There are more complex rules in some lottery games involving additional numbers that follow special separate rules but we won t model those kinds of rules in this project A lottery game is won by anyone who selected the same numbers that were selected during the drawing This is generally pretty rare though the odds vary substantially from one game to another depending on its parameters A ticket sold for one lottery game is not good in another even if the numbers match the ones selected in another game s drawing and even if the other game has the same rules i e the same number count and the same number range The program One of the important skills we ve been developing this quarter and in ICS 32 is the ability to practice what software engineers call separation of concerns which is a fancy way of saying that we ought to think about smaller problems in isolation whenever possible and that we should write our solutions in a way that prevents us from having to think hard about the details of those problems again when we re solving bigger ones Writing large programs is all about taming complexity but it s difficult sometimes to catch on to this concept when you re working on large programs for the first time To give you experience with this concept more directly this project is focused on tool building rather than asking you to write a complete program You will write one module lotterysets which contains one of many tools you might use in writing a program having to do with lotteries Since you ll want to be sure that your lotterysets module is working correctly but since you have no larger scale program to provide the context to test it you ll also be doing what lots of real software developers do writing a complete set of unit tests using Python s built in unittest module to accompany it Lottery sets As we always should when we write Python programs we should be on the lookout for higher level concepts that we can turn into classes or functions Right away when thinking about lotteries the concept of a set of lottery numbers we ll call them lottery sets emerges Different lottery games have different rules in our program they each have a different name a different number count and a different number range But they all revolve around the same basic concept a collection of unique numbers in a particular range When we write programs one of our goals is to map a concept like this to an internal representation Python provides some built in choices We could represent them as lists of integers but the problem with lists is that they can be any size store any kind of element and the numbers would not be required to be unique Additionally lists can be modified after they re created meaning that a program bug could cause the set of numbers to be changed after a ticket was sold We could represent them as tuples of integers but we would have problems similar to those with lists except that tuples can t be modified once they re built We could represent them as sets of integers Using sets would eliminate the problem of potential duplication elements of a set must be unique but do nothing to require the correct size or that the numbers are in the appropriate range And sets like lists can be modified after they re created In the end nothing quite works That isn t to say that you couldn t make one of these choices and live with it but you would have to impose implicit restrictions throughout your program everywhere you created or used a lottery set to ensure that they followed the appropriate rules e g that they contained only the right number of unique integers in the appropriate range When restrictions like this are spread throughout a program the chances of making a mistake go up dramatically if you have to enforce the same rule in twenty places there s a pretty good chance you re going to forget a couple of them And even worse the penalty for forgetting in one place will often be bugs that manifest themselves in other places making debugging more difficult When the types built into Python don t solve our problems a better approach is to create our own types As we ve seen we can do this by writing classes in which we carefully implement all of the necessary behavior along with all of the rules and restrictions in one place Once we ve finished and tested our classes we end up with complete polished tools that feel more like the built in classes in Python but ones that are tailored to the problem that we re solving Implementing lottery set classes A better alternative would be to create new kinds of objects that represent lottery sets Since each game is different it has different rules that must be followed and since lottery sets for one game are incompatible with lottery sets for another we ll create a separate class for each game This may sound onerous but it s not as bad as it sounds Remember that classes are also objects in Python objects of the type class and that like other kinds of objects they can be created while a program runs Since our lottery set classes are largely the same we ll write a function that builds a new class and returns it to us Like any other class we can then use it as a constructor to build objects of our new class which will cause the init method of our new class to be called just like any other time we create an object From there we can use our new object just like any other we call access its attributes and call methods on it Your lotterysets module You are required to build a Python module called lotterysets in a file called lotterysets py which implements at least the things described below This module provides a set of tools that you can use in the rest of a program having to do with lotteries whenever you want to represent sets of lottery numbers the tools are polished and fail fast when they re used in ways that are against the rules of the game so that you could be confident in the rest of a larger program that these problems are solved once and for all Your lotterysets module is required to contain the following functions and classes along with any other utility functions or classes you find necessary in order to implement the functionality described below An exception class called LotterySetError LotterySetErrors will be raised whenever one of the functions or methods in your lotterysets module fails Objects of the LotterySetError should carry error messages with them so their backtraces if displayed will briefly explain what the problem is e g invalid index 7 or number out of allowable range 55 Remember that exceptions are a way that your code can communicate with other code about failure and also in the case of exceptions that aren t caught with the programmers who write that other code so they ll know as much as possible about the reason for it and what they might do to fix it Concise clear error messages are a big part of that A function make lottery set type whose job is to create a new class of lottery set The make lottery set type function takes three parameters in this order A string specifying the name of the lottery game for which a lottery set class should be built e g SuperLotto An integer specifying the number count for the lottery game The integer would need to be at least 1 but there is no upper limit on it A two element tuple of integers specifying the minimum maximum numbers allowed in the set The maximum would need to be at least as large as the minimum e g the tuple 5 4 would be illegal while the tuple 1 49 would be fine So for example if you called make lottery set type BooLotto 6 1 5 the result would be a class whose objects represent a lottery set specifically for the BooLotto game those lottery sets would require 6 numbers in the range 1 5 Once you had that class you could create objects from it like any other class BooLotto make lottery set type BooLotto 6 1 5 booset1 BooLotto 1 15 22 31 38 46 The class returned by make lottery set type must support all of the following functionality Three class variables A class variable set size that specifies how many numbers must be in a set of this type A class variable min set number that specifies the minimum number allowed in this set A class variable max set number that specifies the maximum number allowed in this set The ability to create an object of the lottery set class given a sequence of numbers as a parameter to its constructor Note that there are many kinds of sequences in Python e g lists tuples sets Any is fine here The sequence must Contain only integersBe the same length specified in set sizeContain integers that are all in the allowable range i e at least min set number at most max set number Contain unique integers i e the same number does not show up twice A method full match that takes another lottery set as a parameter and returns True if it is a full match meaning that it contains the same numbers and False otherwise If the other set is incompatible i e it is a set of numbers belonging to a different game this method should raise a LotterySetError A method match count that takes another lottery set as a parameter and returns an integer specifying how many numbers appear in both sets If the other set is incompatible i e it is a set of numbers belonging to a different game this method should raise a LotterySetError The ability to generate a canonical representation so that an object of your class can be viewed in the Python interpreter The canonical representation must be a string containing legal Python code to create an equivalent object The ability to ask for the set s length using the built in len function the length of a set is its size i e how many numbers are in it The ability to compare two sets to see if they re equal using the operator or not equal using the operator Two sets are equal if they are part of the same game have the same size the same minimum and maximum and the same set of numbers The ability to see if a particular number is in the set or not using the in and not in operators Objects of the class should be iterable and reverse iterable meaning among other things that it is possible to iterate through the numbers in the set using a for loop When iterating through the numbers they are always returned in ascending order i e smallest to largest when reverse iterating the numbers they are returned in descending order i e largest to smallest We ll be testing your submission by running a set of automated tests that verify the functionality described above Note that spelling capitalization and the use of underscores are all important here These may seem like insignificant details but it s vital to get them right when you want to write code that interoperates with code written by others In this case you want your lotterysets module to interoperate with our automated tests you ll need to follow the requirements in this section as carefully as you can so that our calls to your functions and methods will work as written Any function or method whose name you ve misspelled is one or more tests of ours that will fail due to the name not matching what we ve written in our tests A few examples of using your module in the Python interpreter So you can get a sense for some of the requirements above here is an example of how you might interact with your lotterysets module in the Python interpreter once you re finished This is not an exhaustive example so don t feel as though you re necessarily done when your output matches the example Note that parts of the tracebacks are elided e g no source code line numbers are shown since your line numbers and error messages may differ from mine from lotterysets import BooLotto make lottery set type BooLotto 6 1 3 b1 BooLotto 3 6 9 12 15 18 len b1 6 b2 BooLotto 3 6 9 12 Traceback most recent call last LotterySetError not enough numbers b2 BooLotto 4 6 8 1 12 14 b1 b2 False b1 BooLotto 15 9 18 3 6 12 True 15 in b1 True 17 in b2 False b1 make lottery set type BooLotto 6 1 3 3 6 9 12 15 18 b1 make lottery set type BooLotto 6 1 3 3 6 9 12 15 18 True b1 match count b2 2 b1 full match b2 False LesserLotto make lottery set type LesserLotto 6 1 25 x1 LesserLotto 3 6 9 12 15 18 b1 full match x1 Traceback most recent call last LotterySetError incompatible set types BooLotto and LesserLotto Unit testing As in the previous project you will be required to write unit tests using Python s built in unittest module This time you need only demonstrate that your lotterysets module works as specified in the requirements in the previous section Remember that unit testing is about isolating small individual features in separate test methods so for example you would need more than one test method to adequately test a method like full match In addition to correctness we ll be grading you on the quality and completeness of the tests you write so don t leave this task for the last minute you might well want to write the tests as you go or even use test driven development if you re so inclined Write your tests in a separate module called lotterysets tests in a file called lotterysets tests py It s generally wise to keep unit tests separate from the code under test because we don t generally include unit tests with the final product we might deliver to a customer Writing a unit test that asserts that an exception will be raised We ve seen previously that assertions are the mechanism we use to check our expections when writing unit tests using the built in unittest module For example if at some point in our test we expect two values to be equal we use assertEquals like this I should point out that there s no value in writing unit tests of functionality that s already built into Python this simply demonstrates the technique def test two strings are the same when they contain the same characters self self assertEquals Boo Boo But what if we want to assert that a block of code raises an exception One way to do it is manually use try except else and force the test to fail if no exception is raised def test accessing list elements out of bounds fails self x 1 2 3 4 5 try x 6 1 except IndexError pass else self fail IndexError not raised as it should have been In a unittest test method self fail causes the test to fail immediately and display the error message you pass to it So in this case we re saying If we end up in the else block it s because the exception we expected to be raised wasn t so the test has failed That s a lot of boilerplate to represent a pretty simple concept We expect the attempt to set the element at index 6 to raise an IndexError so it would be nice if we could say that more directly And indeed we can assertRaises provides just the right tool for the job def test accessing list elements out of bounds fails self x 1 2 3 4 5 with self assertRaises IndexError x 6 1 The parameter to assertRaises indicates what kind of exception we expect will be raised We place the call to assertRaises into a with statement as a way to surround the entire code block that we expect to raise an exception in general we re best off keeping that code block as short as possible so that we re asserting that the appropriate part of the code raises an exception to prevent false positives or false negatives from other unrelated code Notice in this case that I set up the list separately then asserted that the indexing operation would raise an exception The assertRaises method will be something you ll need when you test the variety of error cases in your lotterysets module Sanity checking your lotteryset module In order for us to test your lotterysets module it will be vital that you spell names the same way we expect the name of the module the name of your make lottery set type function the names of methods and class variables and so on are all important To ensure that your lotterysets module contains the right parts I ve put together a set of sanity check unit tests These tests don t check that your functionality is correct but they do verify that the right parts are present e g that you have functions and methods with the right names a LotterySetException class that can be created by passing an error message to its constructor and so on The sanity check tests are in the module linked below lotterysets sanitycheck tests py Do not include these sanity check tests in your own set of unit tests your unit tests should instead focus on whether the necessary functionality does what it should From a practical perspective if things like spelling errors seem inconsequential to you it s important to realize that the burden of detail you carry when you write a program is much different than the one you carry when you write prose to be read by another person People know that lotterysets lottery sets and my lottery sets all mean pretty much the same thing but Python sees them as completely distinct Programming demands a higher level of attention to those kinds of details though it s a kind of thinking that will become more familiar and automatic as you write more programs Limitations Third party libraries i e anything not included in a standard Python 3 3 2 installation are strictly off limits in this project Other than the standard Python library all of the code should be written solely by you Deliverables Put your name and student ID in a comment at the top of each of your py files then submit all of the files to Checkmate Take a moment to be sure you ve submitted all of your files and be sure you submit the right version we will only be able to accept the files you submit before the deadline so forgetting to submit one or submitting the wrong version can have a significant impact on the score you receive for this project Follow this link for a discussion of how to submit your project via Checkmate Can I submit after the deadline Yes it is possible subject to the late work policy for this course which is described in the section titled Late work at this link Originally written by Alex Thornton Summer 2 13", "_id": "http://www.ics.uci.edu/~thornton/ics33/ProjectGuide/Project3/", "title": "ics 33 summer 2013, project #3: careful with that axe, eugene", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\n\n<title>ICS 33 Summer 2013, Project #3: Careful With That Axe, Eugene</title>\n</head>\n\n<body>\n\n<div class=\"navbar\">\n\n<p>\nICS 33 Summer 2013 |\n<a href=\"../../index.html\">News</a> |\n<a href=\"../../CourseReference.html\">Course Reference</a> |\n<a href=\"../../Schedule.html\">Schedule</a> |\n<a href=\"../../ProjectGuide\">Project Guide</a> |\n<a href=\"../../CodeExamples\">Code Examples</a> |\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\n</p>\n\n<hr />\n\n</div>\n\n<div class=\"header\">\n\n<p>ICS 33 Summer 2013<br />\n   Project #3: <i>Careful With That Axe, Eugene</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, August 9, 11:59pm</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Introduction</p>\n\n<p>In the United States and various parts of the world, <i>lotteries</i> offer people the chance to make a very inexpensive purchase of a ticket in hopes of reaping a windfall if they win the jackpot, which is quite often many millions of times the cost of the ticket.  The odds of winning are infinitesimal, of course; as a practical matter, playing seems to make little sense, but some players enjoy the brief dream of better days before discovering that, yet again, they haven't won.  And there's always that chance...</p>\n\n<p>This project is centered around the concept of lotteries.  It continues our exploration into some of the deeper areas of Python that allow us to create abstractions that we can use cleanly and clearly in other parts of a program.  As we've seen previously, we should prefer to keep the little details of our program as localized as possible; if we can solve a problem once and not have to think about it again, that's a lot better than having to solve it over and over again.  Additionally, any time we can eliminate redundant code from a program, we're always better off.  The level of care required is more than you might be accustomed to, but is one of the key skills you need to build if you want to successfully write programs tens or hundreds of times the size of the programs we've been writing in ICS 31, 32, and 33.</p>\n\n<p>In particular, we'll cross a few bridges we've not yet crossed:</p>\n\n<ul>\n  <li>Writing a potentially infinite set of similar classes without having to write them one by one.  Computers excel at boring, repetitive work, so we should write programs to do that kind of work; writing many classes that are largely identical is one of the many examples of the kind of work you can automate easily in Python.</li>\n  <li>Making your classes more \"bullet-proof,\" by prohibiting misuse and \"failing fast\" when objects of your classes are used in ways that don't make sense.  Objects of built-in types like lists and tuples fail immediately (and tell you why) when you try to use them in ways you shouldn't; objects of your classes should do that, too.</li>\n  <li>Expanding your ability to write unit tests, including tests that expect exceptions to be raised, which you may not have written previously.</li>\n</ul>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Background on lotteries</p>\n\n<p>This project is centered around the concept of a <i>lottery</i>.  As is often the case when you dive into a new problem domain, one of the first hurdles to clear is to understand the concepts and terminology relevant to the domain.</p>\n\n<ul>\n  <li>A <i>lottery game</i> involves the selling of <i>tickets</i>, each of which contains a set of numbers selected by a person (or, sometimes, selected randomly by a computer instead).  The numbers are generally integers chosen in a fairly small range.\n    <ul>\n      <li>Note the fact that a ticket is a <i>set</i> of numbers, meaning that the order in which the numbers are selected is considered irrelevant.</li>\n    </ul>\n  </li>\n  <li>At a prescribed time, a <i>drawing</i> is held, in which one more set of numbers is selected randomly.  A ticket is a winner if it contains the same set of numbers selected in the drawing.  Often, there are lesser winners, who receive a smaller prize for matching some, but not all, of the numbers.</li>\n  <li>While most lottery games are fairly similar, they are differentiated by a few parameters:\n  \t<ul>\n  \t  <li>A <i>name</i>, such as <b>Powerball</b> or <b>Mega Millions</b>.  This is primarily a marketing concept, but one that is nonetheless a well-known differentiator.</li>\n  \t  <li>A <i>number count</i>, which specifies how many numbers a player must choose (and how many will be chosen during the drawing).</li>\n      <li>A <i>number range</i>, which specifies the range in which the chosen numbers must reside.</li>\n  \t</ul>\n  For example, the lottery game <b>BooLotto</b> might have a number count of 6 and a number range of 1..45, meaning that players must select six numbers between 1 and 45 (inclusive) and that the drawing will be selected according to the same rules.  (There are more complex rules in some lottery games involving additional numbers that follow special, separate rules, but we won't model those kinds of rules in this project.)</li>\n  </li>\n  <li>A lottery game is won by anyone who selected the same numbers that were selected during the drawing.  This is generally pretty rare, though the odds vary substantially from one game to another, depending on its parameters.</li>\n  <li>A ticket sold for one lottery game is not good in another, even if the numbers match the ones selected in another game's drawing, and even if the other game has the same rules (i.e., the same number count and the same number range).</li>\n</ul>\n\n</div>\n\n<div class=\"section\">\n\t\n<hr />\n\n<p class=\"title\">The program</p>\n\n<p>One of the important skills we've been developing this quarter (and in ICS 32) is the ability to practice what software engineers call <i>separation of concerns</i>, which is a fancy way of saying that we ought to think about smaller problems in isolation whenever possible, and that we should write our solutions in a way that prevents us from having to think hard about the details of those problems again when we're solving bigger ones.  Writing large programs is all about taming complexity, but it's difficult sometimes to catch on to this concept when you're working on large programs for the first time.</p>\n\n<p>To give you experience with this concept more directly, this project is focused on tool-building rather than asking you to write a complete program.  You will write one module, <b>lotterysets</b>, which contains one of many tools you might use in writing a program having to do with lotteries.  Since you'll want to be sure that your <b>lotterysets</b> module is working correctly, but since you have no larger-scale program to provide the context to test it, you'll also be doing what lots of real software developers do: writing a complete set of unit tests (using Python's built-in <b>unittest</b> module) to accompany it.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Lottery sets</p>\n\n<p>As we always should when we write Python programs, we should be on the lookout for higher-level concepts that we can turn into classes or functions.  Right away, when thinking about lotteries, the concept of a set of lottery numbers &mdash; we'll call them <i>lottery sets</i> &mdash; emerges.  Different lottery games have different rules; in our program, they each have a different name, a different number count, and a different number range.  But they all revolve around the same basic concept: a collection of unique numbers in a particular range.</p>\n\n<p>When we write programs, one of our goals is to map a concept like this to an internal representation.  Python provides some built-in choices:</p>\n\n<ul>\n  <li>We could represent them as lists of integers, but the problem with lists is that they can be any size, store any kind of element, and the numbers would not be required to be unique.  Additionally, lists can be modified after they're created, meaning that a program bug could cause the set of numbers to be changed after a ticket was sold.</li>\n  <li>We could represent them as tuples of integers, but we would have problems similar to those with lists, except that tuples can't be modified once they're built.</li>\n  <li>We could represent them as sets of integers.  Using sets would eliminate the problem of potential duplication &mdash; elements of a set must be unique &mdash; but do nothing to require the correct size or that the numbers are in the appropriate range.  And sets, like lists, can be modified after they're created.</li>\n</ul>\n\n<p>In the end, nothing quite works.  That isn't to say that you couldn't make one of these choices and live with it, but you would have to impose implicit restrictions &mdash; throughout your program, everywhere you created or used a lottery set &mdash; to ensure that they followed the appropriate rules (e.g., that they contained only the right number of unique integers in the appropriate range).  When restrictions like this are spread throughout a program, the chances of making a mistake go up dramatically; if you have to enforce the same rule in twenty places, there's a pretty good chance you're going to forget a couple of them.  And, even worse, the penalty for forgetting in one place will often be bugs that manifest themselves in other places, making debugging more difficult.</p>\n\n<p>When the types built into Python don't solve our problems, a better approach is to create our own types.  As we've seen, we can do this by writing <i>classes</i>, in which we carefully implement all of the necessary behavior, along with all of the rules and restrictions, in one place.  Once we've finished and tested our classes, we end up with complete, polished tools that feel more like the built-in classes in Python, but ones that are tailored to the problem that we're solving.</p>\n\n<p class=\"subtitle\">Implementing lottery set classes</p>\n\n<p>A better alternative would be to create new kinds of objects that represent lottery sets.  Since each game is different &mdash; it has different rules that must be followed &mdash; and since lottery sets for one game are incompatible with lottery sets for another, we'll create a <i>separate class</i> for each game.</p>\n\n<p>This may sound onerous, but it's not as bad as it sounds.  Remember that classes are also objects in Python &mdash; objects of the type <b>class</b> &mdash; and that, like other kinds of objects, they can be created while a program runs.  Since our lottery set classes are largely the same, we'll write a function that builds a new class and returns it to us.  Like any other class, we can then use it as a constructor to build objects of our new class, which will cause the <b>__init__</b> method of our new class to be called, just like any other time we create an object.  From there, we can use our new object just like any other; we call access its attributes and call methods on it.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Your 'lotterysets' module</p>\n\n<p>You are required to build a Python module called <b>lotterysets</b> (in a file called <b>lotterysets.py</b>), which implements (at least) the things described below.  This module provides a set of tools that you can use in the rest of a program having to do with lotteries, whenever you want to represent sets of lottery numbers; the tools are polished and \"fail fast\" when they're used in ways that are against the rules of the game, so that you could be confident, in the rest of a larger program, that these problems are solved once and for all.</p>\n\n<p>Your <b>lotterysets</b> module is required to contain the following functions and classes, along with any other utility functions or classes you find necessary in order to implement the functionality described below.</p>\n\n<ul>\n  <li>An exception class called <b>LotterySetError</b>.  LotterySetErrors will be raised whenever one of the functions or methods in your <b>lotterysets</b> module fails.  Objects of the LotterySetError should carry error messages with them, so their backtraces, if displayed, will briefly explain what the problem is (e.g., \"invalid index: 7\" or \"number out of allowable range: 55\").  (Remember that exceptions are a way that your code can communicate with other code about failure, and also, in the case of exceptions that aren't caught, with the programmers who write that other code, so they'll know as much as possible about the reason for it and what they might do to fix it.  Concise, clear error messages are a big part of that.)</li>\n  <li>A function <b>make_lottery_set_type</b>, whose job is to create a new <i>class</i> of lottery set.  The <b>make_lottery_set_type</b> function takes three parameters, in this order:\n    <ul>\n      <li>A string specifying the name of the lottery game for which a lottery set class should be built (e.g., <b>'SuperLotto'</b>).</li>\n      <li>An integer specifying the number count for the lottery game.  The integer would need to be at least 1, but there is no upper limit on it.</li>\n      <li>A two-element tuple of integers specifying the (<i>minimum</i>, <i>maximum</i>) numbers allowed in the set.  The maximum would need to be at least as large as the minimum (e.g., the tuple <b>(5, 4)</b> would be illegal, while the tuple <b>(1, 49)</b> would be fine).</li>\n    </ul>\n    So, for example, if you called <b>make_lottery_set_type('BooLotto', 6, (1, 50))</b>, the result would be a <i>class</i> whose objects represent a lottery set specifically for the BooLotto game; those lottery sets would require 6 numbers in the range 1..50.  Once you had that class, you could create objects from it like any other class:\n    <blockquote><pre>\n    BooLotto = make_lottery_set_type('BooLotto', 6, (1, 50))\n    booset1 = BooLotto([10, 15, 22, 31, 38, 46])</pre></blockquote>\n  </li>\n  <li>The class returned by <b>make_lottery_set_type</b> must support <i>all</i> of the following functionality:\n    <ul>\n      <li>Three class variables:\n        <ul>\n          <li>A class variable <b>set_size</b> that specifies how many numbers must be in a set of this type.</li>\n          <li>A class variable <b>min_set_number</b> that specifies the minimum number allowed in this set.</li>\n          <li>A class variable <b>max_set_number</b> that specifies the maximum number allowed in this set.</li>\n        </ul>\n      </li>\n      <li>The ability to create an object of the lottery set class given a <i>sequence</i> of numbers as a parameter to its constructor.  (Note that there are many kinds of <i>sequences</i> in Python, e.g., lists, tuples, sets.  Any is fine here.)  The sequence must:\n        <ul>\n          <li>Contain only integers</li>\n          <li>Be the same length specified in <b>set_size</b></li>\n          <li>Contain integers that are all in the allowable range (i.e., at least <b>min_set_number</b>, at most <b>max_set_number</b>)</li>\n          <li>Contain unique integers (i.e., the same number does not show up twice)</li>\n        </ul>\n      </li>\n      <li>A method <b>full_match</b> that takes another lottery set as a parameter and returns True if it is a <i>full match</i> (meaning that it contains the same numbers) and False otherwise.\n        <ul>\n          <li>If the other set is incompatible (i.e., it is a set of numbers belonging to a different game), this method should raise a LotterySetError.</li>\n        </ul>\n      </li>\n      <li>A method <b>match_count</b> that takes another lottery set as a parameter and returns an integer specifying how many numbers appear in both sets.\n        <ul>\n          <li>If the other set is incompatible (i.e., it is a set of numbers belonging to a different game), this method should raise a LotterySetError.</li>\n        </ul>\n      </li>\n      <li>The ability to generate a <i>canonical representation</i> so that an object of your class can be viewed in the Python interpreter.  The canonical representation <i>must</i> be a string containing legal Python code to create an equivalent object.</li>\n      <li>The ability to ask for the set's length using the built-in <b>len</b> function; the length of a set is its size (i.e., how many numbers are in it).</li>\n      <li>The ability to compare two sets to see if they're equal (using the == operator) or not equal (using the != operator).  Two sets are equal if they are part of the same game, have the same size, the same minimum and maximum, and the same set of numbers.</li>\n      <li>The ability to see if a particular number is in the set (or not) using the <b>in</b> and <b>not in</b> operators.</li>\n      <li>Objects of the class should be <i>iterable</i> and <i>reverse iterable</i>, meaning (among other things) that it is possible to iterate through the numbers in the set using a <b>for</b> loop.  When iterating through the numbers, they are always returned in ascending order (i.e., smallest to largest); when reverse-iterating the numbers, they are returned in descending order (i.e., largest to smallest).</li>\n    </ul>\n  </li>\n</ul>\n\n<p>We'll be testing your submission by running a set of automated tests that verify the functionality described above.  Note that spelling, capitalization, and the use of underscores are all important here.  These may seem like insignificant details, but it's vital to get them right when you want to write code that interoperates with code written by others.  In this case, you want your <b>lotterysets</b> module to interoperate with our automated tests; you'll need to follow the requirements in this section as carefully as you can, so that our calls to your functions and methods will work as written.  Any function or method whose name you've misspelled is one or more tests of ours that will fail due to the name not matching what we've written in our tests.</li>\n\n<p class=\"subtitle\">A few examples of using your module in the Python interpreter</p>\n\n<p>So you can get a sense for some of the requirements above, here is an example of how you might interact with your <b>lotterysets</b> module in the Python interpreter once you're finished.  This is not an exhaustive example, so don't feel as though you're necessarily done when your output matches the example.  Note that parts of the tracebacks are elided (e.g., no source code line numbers are shown), since your line numbers and error messages may differ from mine.</p>\n\n<blockquote><pre>\n&gt;&gt;&gt; <b>from</b> lotterysets <b>import</b> *\n&gt;&gt;&gt; BooLotto = make_lottery_set_type('BooLotto', 6, (1, 30))\n&gt;&gt;&gt; b1 = BooLotto([3, 6, 9, 12, 15, 18])\n&gt;&gt;&gt; <b>len</b>(b1)\n6\n&gt;&gt;&gt; b2 = BooLotto([3, 6, 9, 12])\n<i>Traceback (most recent call last):\n    ...\nLotterySetError: not enough numbers</i>\n&gt;&gt;&gt; b2 = BooLotto([4, 6, 8, 10, 12, 14])\n&gt;&gt;&gt; b1 == b2\n<b>False</b>\n&gt;&gt;&gt; b1 == BooLotto([15, 9, 18, 3, 6, 12])\n<b>True</b>\n&gt;&gt;&gt; 15 <b>in</b> b1\n<b>True</b>\n&gt;&gt;&gt; 17 <b>in</b> b2\n<b>False</b>\n&gt;&gt;&gt; b1\nmake_lottery_set_type('BooLotto', 6, (1, 30))([3, 6, 9, 12, 15, 18])\n&gt;&gt;&gt; b1 == make_lottery_set_type('BooLotto', 6, (1, 30))([3, 6, 9, 12, 15, 18])\n<b>True</b>\n&gt;&gt;&gt; b1.match_count(b2)\n2\n&gt;&gt;&gt; b1.full_match(b2)\n<b>False</b>\n&gt;&gt;&gt; LesserLotto = make_lottery_set_type('LesserLotto', 6, (1, 25))\n&gt;&gt;&gt; x1 = LesserLotto([3, 6, 9, 12, 15, 18])\n&gt;&gt;&gt; b1.full_match(x1)\n<i>Traceback (most recent call last):\n    ...\nLotterySetError: incompatible set types (BooLotto and LesserLotto)</i>\n</pre></blockquote>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Unit testing</p>\n\n<p>As in the previous project, you will be required to write unit tests using Python's built-in <b>unittest</b> module.  This time, you need only demonstrate that your <b>lotterysets</b> module works as specified in the requirements in the previous section.  Remember that unit testing is about isolating small, individual features in separate test methods, so, for example, you would need more than one test method to adequately test a method like <b>full_match</b>.  In addition to correctness, we'll be grading you on the quality and completeness of the tests you write, so don't leave this task for the last minute; you might well want to write the tests as you go (or even use test-driven development, if you're so inclined).</p>\n\n<p>Write your tests in a separate module called <b>lotterysets_tests</b> (in a file called <b>lotterysets_tests.py</b>).  It's generally wise to keep unit tests separate from the code under test, because we don't generally include unit tests with the final product we might deliver to a customer.</p>\n\t\n<p class=\"subtitle\">Writing a unit test that asserts that an exception will be raised</p>\n\n<p>We've seen previously that <i>assertions</i> are the mechanism we use to check our expections when writing unit tests using the built-in <b>unittest</b> module.  For example, if, at some point in our test, we expect two values to be equal, we use <b>assertEquals</b>, like this:</p>\n\n<blockquote><pre>\n<i># I should point out that there's no value in writing unit tests of\n# functionality that's already built into Python; this simply demonstrates\n# the technique</i>\n<b>def</b> test_two_strings_are_the_same_when_they_contain_the_same_characters(self):\n    self.assertEquals('Boo', 'Boo')\n</pre></blockquote>\n\n<p>But what if we want to assert that a block of code raises an exception?  One way to do it is manually: use <b>try</b>/<b>except</b>/<b>else</b> and force the test to fail if no exception is raised:</p>\n\n<blockquote><pre>\n<b>def</b> test_accessing_list_elements_out_of_bounds_fails(self):\n    x = [1, 2, 3, 4, 5]\n\n    <b>try</b>:\n        x[6] = 10\n    <b>except</b> IndexError:\n        <b>pass</b>\n    <b>else</b>:\n        self.fail('IndexError not raised as it should have been')\n</pre></blockquote>\n\n<p>In a <b>unittest</b> test method, <b>self.fail</b> causes the test to fail immediately and display the error message you pass to it.  So, in this case, we're saying \"If we end up in the <b>else</b> block, it's because the exception we expected to be raised wasn't, so the test has failed.\"</p>\n\n<p>That's a lot of boilerplate to represent a pretty simple concept.  We expect the attempt to set the element at index 6 to raise an IndexError, so it would be nice if we could say that more directly.  And, indeed, we can; <b>assertRaises</b> provides just the right tool for the job.</p>\n\n<blockquote><pre>\n<b>def</b> test_accessing_list_elements_out_of_bounds_fails(self):\n    x = [1, 2, 3, 4, 5]\n\n    <b>with</b> self.assertRaises(IndexError):\n        x[6] = 10\n</pre></blockquote>\n\n<p>The parameter to <b>assertRaises</b> indicates what kind of exception we expect will be raised.  We place the call to <b>assertRaises</b> into a <b>with</b> statement as a way to surround the entire code block that we expect to raise an exception; in general, we're best off keeping that code block as short as possible, so that we're asserting that the appropriate part of the code raises an exception (to prevent false positives or false negatives from other unrelated code).  Notice, in this case, that I set up the list separately, then asserted that the indexing operation would raise an exception.</p>\n\n<p>The <b>assertRaises</b> method will be something you'll need when you test the variety of error cases in your <b>lotterysets</b> module.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Sanity-checking your 'lotteryset' module</p>\n\n<p>In order for us to test your <b>lotterysets</b> module, it will be vital that you spell names the same way we expect &mdash; the name of the module, the name of your <b>make_lottery_set_type</b> function, the names of methods and class variables, and so on, are all important.  To ensure that your <b>lotterysets</b> module contains the right parts, I've put together a set of \"sanity-check\" unit tests.  These tests don't check that your functionality is correct, but they do verify that the right parts are present (e.g., that you have functions and methods with the right names, a LotterySetException class that can be created by passing an error message to its constructor, and so on).</p>\n\n<p>The sanity-check tests are in the module linked below.</p>\n\n<ul>\n  <li><a href=\"lotterysets_sanitycheck_tests.py\">lotterysets_sanitycheck_tests.py</a></li>\n</ul>\n\n<p><i>Do not</i> include these sanity-check tests in your own set of unit tests; your unit tests should instead focus on whether the necessary functionality does what it should.</p>\n\n<p>From a practical perspective, if things like spelling errors seem inconsequential to you, it's important to realize that the burden of detail you carry when you write a program is much different than the one you carry when you write prose to be read by another person.  People know that \"lotterysets\", \"lottery_sets\", and \"my_lottery_sets\" all mean pretty much the same thing, but Python sees them as completely distinct.  Programming demands a higher level of attention to those kinds of details, though it's a kind of thinking that will become more familiar and automatic as you write more programs.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Limitations</p>\n\n<p>Third-party libraries &mdash; i.e., anything not included in a standard Python 3.3.2 installation &mdash; are strictly off-limits in this project.  Other than the standard Python library, all of the code should be written solely by you.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Deliverables</p>\n\n<p>Put your name and student ID in a comment at the top of each of your <b>.py</b> files, then submit all of the files to Checkmate.  Take a moment to be sure you've submitted all of your files and be sure you submit the right version; we will only be able to accept the files you submit before the deadline, so forgetting to submit one (or submitting the wrong version) can have a significant impact on the score you receive for this project.</p>\n\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for a discussion of how to submit your project via Checkmate.</p>\n\n<p class=\"subtitle\">Can I submit after the deadline?</p>\n\n<p>Yes, it is possible, subject to the late work policy for this course, which is described in the section titled <i>Late work</i> at <a href=\"../index.html\">this link</a>.</p>\n\n</div>\n\n<div class=\"history\">\n\n<hr />\n\n<ul class=\"nomarker\">\n  <li>Originally written by Alex Thornton, Summer 2013</li>\n</ul>\n\n</div>\n\n</body>\n</html>\n", "id": 16780.0}