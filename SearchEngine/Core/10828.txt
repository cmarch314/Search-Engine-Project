{"text": "Program 3 Programs that Write Programs pnamedtuple ICS 33 Intermediate Programming Introduction This programming assignment is designed to show how Python functions can define other Python code in this case a class in an unexpected way the function can build a huge string that represents the definition of a Python class and then call exec on it which causes Python to define that class just as if it were written in a file and imported in which case Python reads the file as a big string and does the same thing Your code will heavily rely on string formatting operations I suggest using the str format method to do the replacements now is a good time to learn about this function if you don t know already know it but you are free to use whatever string processing tool s you want I suggest that you first read the description below and define test debug as much of the Point class as you can writing it directly in Eclipse especially the getitem eq and replace methods You might want to write a small batch file to help you test this class Once you have written debugged the code for the Point class define the general pnamedtuple function which when given the appropriate arguments for the Point class pnamedtuple Point x y constructs a huge string containing the same code as the Point class you wrote Much of the code from your Point class will be turned into strings and made generic generalized for calls to pnamedtuple with different arguments Use the format method to replace the generic parts with the actual strings needed for the class being defined Download the program3 project folder and use it to create an Eclipse project Read and run the miniexample py module which performs a similar but simpler task it illustrates how to write the keep function as a small string All the elements needed to write the pnamedtuple function appear in here in a simplfied form see especially the call to the join function Put your pnamedtuple in the pcollections py module which can be tested in the standard driver or by writing code in the script at the bottom of the pcollections py module It is recommend that you work on this assignment in pairs with someone in your lab section Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early Only one student should submit all parts of the the assignment but both students UICnetID and name should appear in a comment at the top of each submitted py file A special grading program reads this information The format is a comment starting with Submitter and Partner when working with a partner followed by a colon followed by the student s UCInetID in all lower case followed by the student s name in parentheses last name comma first name capitalized appropriately If you omit this information or do not follow this exact form it will require extra work for us to grade your program so we will deduct points Note if you are submitting by yourself and do NOT have a partner you should OMIT the partner line For example if Romeo Montague whose UCInetID is romeo1 submitted a program that he worked on with his partner Juliet Capulet whose UCInetID is jcapulet the comment at the top of each py file would appear as Submitter romeo1 Montague Romeo Partner jcapulet Capulet Juliet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can more accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files The code you write should be as compact and elegant as possible using appropriate Python idioms Problem 1 pnamedtuple Problem Summary Write a function named pnamedtuple that is passed information about a named tuple it returns a reference to a class object from which we can construct instances of the specified named tuple We might use this class as follows from pcollections import pnamedtuple Point pnamedtuple Point x y p Point perform operations on p using methods defined in the Point class Please note that although many of the examples in this description use the Point class your pnamedtuple function must work for all legal calls For example the batch self check file uses descriptions some legal some not of the Triple class I created six templates one big two medium three small which are each strings that have parts to fill in using the format method all but the small strings are triple quoted multi line strings that look like large chunks of Python code see miniexample py in the download to help understand this paragraph because it has similar templates Note calling the following format method on the string name from country tells you rest format name Rich country USA rest blah blah blah returns the string result Rich from USA tells you blah blah blah In many cases the arguments I passed to the format calls were computed by list comprehensions turned into strings by calling the join method the opposite of the split method See the miniexample for an example of everything working together to define a function by filling in a template with format Finally my solution is about 1 lines including blank lines and comments and a solution to the extra credit part and that is divided between Python code 7 of the lines and string templates that specify Python code 3 of the lines Details Define a function named pnamedtuple in a module named pcollections py that is the only name defined in the module but this function can define local functions I wrote three short ones Its header is def pnamedtuple type name field names mutable False an example call to this function is Point pnamedtuple Point x y mutable False which is equivalent to writing Point pnamedtuple Point x y or Point pnamedtuple Point x y Using Point we can then write code like origin Point A legal name for the type and fields must start with a letter which can be followed by or more letters digits or underscore characters hint I used a simple regular expression to verify legal names also it must not be a Python keyword Hint the name kwlist is importable from the keyword module it is bound to a list of all Python keywords The parameters must have the following structure type name must be a legal name see above field names must be a list of legal names see above or a string in which spaces separate legal names or commas and optional spaces separate legal names So we can specify field names like x y or x y or x y If a name is duplicated just ignore all but its first appearance hint I used the unique generator to filter out duplicates If any of the names are not legal raise a SyntaxError with an appropriate message The resulting class that is written should have the following functionality Note that the main job of pnamedtuple is to compute a large string that describes the class we could define the class by writing the string to a file and then importing the file instead the pnamedtuple function returns the class object Define the class name to be type name Define an init method that has all the field names as parameters in the order they appear in the second argument to pnamedtuple and initializes every instance name using these same names with the value bound to its parameter In addition define the instance names fields and mutable which are bound to a list of all the field names and the bool parameter respectively For Point described above the init method would be def init self x y self x x self y y self fields x y self mutable False The problem here and throughout the other parts of this is assignment is writing a functon like gen init such that gen init x y produces the a string representing the init function above including n at the end of each line Define the repr method that returns a string which when passed to eval returns a newly constructed object that has all the same instance names and values as the object repr was called on For Point if we defined origin Point then calling repr origin would return Point x y Here is one way to write repr for Point using the format method def repr self return Point x x y y format x self x y self y although there are other ways for it to produce the same resulting string Define simple accessor methods for each of the field names Each method name should start as get followed by the name of a field For Point there would be two accessor methods def get x self return self x def get y self return self y Note that with these methods if we had a list of Point named lp we could call lp sort key Point get x to sort the list by their x coordinates Python s builtin namedtuple does not have this ability but the code it produces for retrieving these values runs a bit faster Define the getitem method to overload the indexing operator for this class an index of returns the value of the first field name in the field names list an index of 1 returns the value of the second field name in the field names list etc Also the index can be a string with the named field So for p Point 1 2 writing p get x or p or p x returns a result of 1 Raise an IndexError with an appropriate message if the index is out of bounds int or a string that does not name a field Note that this method can be used by Python to iterate through any class produced by pnamedtuple one index after another It is also useful for writing the eq method see below Hint for an int index parameter combine the self fields instance name the get methods and the eval function to write a short solution to this problem in the case of origin Point calling origin 1 should construct the string self get y and return eval self get y Overload the operator so that it returns True when the two named tuples come from the same class and have all their name fields bound to equal values Hint use getitem for each name to check for equality Define a replace method which takes kargs as a parameter keyword args This allows the name kargs to be used in the method as a dict of parameter names and their matching argument values The semantics of the replace method depends on the value stored in the instance name self mutable If True the instance namess of the object it is called on are changed and the method returns None So if origin Point and we call origin replace y 5 then print origin would display as Point x y 5 because origin is mutated If False it returns a new object of the same class whose instance name s values are the same except for those specified in kargs So if origin Point and we call new origin origin replace y 5 then print origin new origin would display as Point x y Point x y 5 because origin is not mutated Define this method to look like def replace self kargs if self mutable else In both we iterate through kargs items or self fields and refer to self dict to retrieve the current values bound to the instance names this is a bit tricky Use our textbook or web resources to learn more about kargs feel free to post specific question on the forum not relating to their actual use in replace and also not Could someone please explain kargs to me The kargexample py module has a little kargs demo in it Extra credit Define the setattr method so after init finishes if the mutable parameter is False the named tuple will not allow any instance names to be changed it will raise an AttributeError with an appropriate message Of course our pnamedtuple function should work for Point as illustrated above but should also work for any other legal call The actual namedtuple class in Python is implemented differently but this programming assignment requires you to use the implemenation above Testing The pcollections py module includes a script that calls driver driver The project folder contains a bsc txt file examine it to use for batch self checking your function These are rigorous but not exhaustive tests Note that when exceptions are raised they are printed by the driver but the Command prompt sometimes appears misplaced You can write othercode at the bottom of your pcollections py module to test the pnamedtuple function or type code into the driver as illustrated below Notice the default for each command is the command previously entered Driver started Command from pcollections import pnamedtuple as pnt Command from pcollections import pnamedtuple as pnt Point pnt Point x y Command Point pnt Point x y origin Point Command origin Point p1 Point 5 2 Command p1 Point 5 2 print p1 Point x 5 y 2 Command print p1 print p1 get x 5 Command print p1 get x print p1 5 Command print p1 print p1 x 5 Command print p1 x print p1 z Traceback most recent call last File C Users Pattis workspace courselib driver py line 224 in driver exec old local globl File line 1 in File line 17 in getitem IndexError Point getitem index z is illegal Command print p1 z p2 p1 replace x 2 y 5 Command p2 p1 replace x 2 y 5 print p1 p2 Point x 5 y 2 Point x 2 y 5 Command print p1 p2 quit Driver stopped Files for batch test see bt txt for an example just contain commands that will be executed many are calls to the print function which show the result of the print Remember that your pnamedtuple function can print on the console for debugging purposes the string it is about to exec so you can look for errors there just eyeball whether the code correct The show listing function defined in the pnamedtuple function display a string on the console numbering its lines useful when exec finds an error it reports a line number that show listing shows Finalkly I have also included two programs that David Kay published in ICS 31 that use Python s namedtuple with those names changed to pnamedtuple ", "_id": "http://www.ics.uci.edu/~pattis/ICS-33/assignments/program3/program.html", "title": "program 3", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 3</title>\r\n</head>\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 3</h1>\r\n<h1>\r\nPrograms that Write Programs: pnamedtuple\r\n</h1>\r\n<p>\r\n<h2>ICS-33: Intermediate Programming<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to show how Python functions can define\r\n  other Python code (in this case, a class) in an unexpected way: the function\r\n  can build a huge string that represents the definition of a Python class and\r\n  then call <b>exec</b> on it, which causes Python to define that class just as\r\n  if it were written in a file and imported (in which case Python reads the\r\n  file as a big string and does the same thing).\r\nYour code will heavily rely on string formatting operations: I suggest using\r\n  the <b>str.format</b> method to do the replacements: now is a good time to\r\n  learn about this function if you don't know already know it; but you are free\r\n  to use whatever string processing tool(s) you want.\r\n\r\n<p>\r\nI suggest that you first read the description below and define/test/debug as\r\n  much of the <b>Point</b> class as you can, writing it directly in Eclipse\r\n (especially the<b>__getitem__</b>, <b>__eq__</b>, and <b>_replace__</b>\r\n  methods).\r\nYou might want to write a small batch file to help you test this class.\r\n<p>\r\nOnce you have written/debugged the code for the <b>Point</b> class, define the\r\n  general <b>pnamedtuple</b> function, which when given the appropriate\r\n  arguments (for the <b>Point</b> class: <b>pnamedtuple('Point', 'x y')</b>)\r\n  constructs a huge string containing the same code as the <b>Point</b> class\r\n  you wrote.\r\nMuch of the code from your <b>Point</b> class will be turned into strings and\r\n  made generic: generalized for calls to <b>pnamedtuple</b> with different\r\n  arguments.\r\nUse the <b>.format</b> method to replace the generic parts with the actual\r\n  strings needed for the class being defined.\r\n<p>\r\nDownload the <a href=\"program3.zip\">program3</a> project folder and use it to\r\n  create an Eclipse project.\r\nRead and run the <b>miniexample.py</b> module, which performs a similar but\r\n  simpler task: it illustrates how to write the <b>keep</b> function as a small\r\n  string.\r\nAll the elements needed to write the <b>pnamedtuple</b> function appear in here\r\n  in a simplfied form (see especially the call to the <b>join</b> function).\r\nPut your <b>pnamedtuple</b> in the <b>pcollections.py</b> module, which can be\r\n  tested in the standard driver or by writing code in the script at the bottom\r\n  of the <b>pcollections.py</b> module.\r\n<p>\r\nIt is recommend that you work on this assignment in pairs, with someone in your\r\n  lab section.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<!---\r\nIf you believe that it is impossible for you to work with someone, because of\r\n  some special reason(s), you should send me email stating them and asking for\r\n  special permission to work alone (which I do grant, but not frequently).\r\n--->\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  students' UICnetID and name should appear in a comment at the <b>top</b> of\r\n  <b>each submitted .py file</b>.\r\nA special grading program reads this information.\r\nThe format is a comment starting with <b>Submitter</b> and <b>Partner</b> (when\r\n  working with a partner), followed by a <b>colon</b>, followed by the student's\r\n  <b>UCInetID</b> (in all lower-case), followed by the student's <b>name in\r\n  parentheses</b> (last name, comma, first name -capitalized appropriately).\r\nIf you omit this information, or do not follow this exact form, it will require\r\n  extra work for us to grade your program, so we will deduct points.\r\nNote: if you are submitting by yourself, and do <b>NOT</b> have a partner, you\r\n  should <b>OMIT</b> the partner line.\r\n<p>\r\nFor example if Romeo Montague (whose UCInetID is romeo1) submitted a program\r\n  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)\r\n  the comment at the top of each .py file would appear as:\r\n<pre><b># Submitter: romeo1(Montague, Romeo)\r\n# Partner  : jcapulet(Capulet, Juliet)\r\n# We certify that we worked cooperatively on this programming\r\n#   assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  <b>before</b> starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can more\r\n  accurately assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nThe code you write should be as compact and elegant as possible, using \r\n  appropriate Python idioms.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: pnamedtuple</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite a function named <b>pnamedtuple</b> that is passed information about a\r\n  named tuple: it returns a reference to a class object from which we can\r\n  construct instances of the specified named tuple.\r\nWe might use this class as follows:\r\n<b><pre>from pcollections import pnamedtuple\r\nPoint = pnamedtuple('Point', 'x y')\r\np = Point(0,0)\r\n...perform operations on p using methods defined in the Point class</pre></b>\r\nPlease note that although many of the examples in this description use the\r\n  <b>Point</b> class, your <b>pnamedtuple</b> function must work for all legal\r\n  calls.\r\nFor example the batch-self-check file uses descriptions (some legal, some\r\n  not) of the <b>Triple</b> class.\r\n<p>\r\nI created six templates (one big, two medium, three small), which are each\r\n  strings that have parts to fill in using the <b>format</b> method; all but\r\n  the small strings are triple-quoted, multi-line strings, that look like large\r\n  chunks of Python code (see <b>miniexample.py</b> in the download to help\r\n  understand this paragraph, because it has similar templates).\r\n<p>\r\nNote calling the following <b>format</b> method on the string\r\n<b><pre>'{name} from {country} tells you {rest}'.format(name='Rich',country='USA',rest='blah..blah..blah')</pre></b>\r\nreturns the string result\r\n<b><pre>'Rich from USA tells you blah..blah..blah'</pre></b>\r\nIn many cases, the arguments I passed to the <b>format</b> calls were computed\r\n  by list comprehensions turned into strings by calling the <b>.join</b> method\r\n  (the opposite of the <b>.split</b> method).\r\nSee the <b>miniexample</b> for an example of everything working together to\r\n  define a function by filling in a template with <b>.format</b>.\r\nFinally, my solution is about 100 lines (including blank lines and comments,\r\n  and a solution to the extra credit part), and that is divided between Python\r\n  code (70% of the lines) and string templates that specify Python code (30% of\r\n  the lines).\r\n<h3>Details</h3>\r\n<ul>\r\n<li>Define a function named <b>pnamedtuple</b> in a module named\r\n    <b>pcollections.py</b> (that is the only name defined in the module, but\r\n       this function can define local functions: I wrote three short ones).\r\n    Its header is <b>def pnamedtuple(type_name, field_names, mutable=False):</b>\r\n      an example call to this function is\r\n       <b>Point = pnamedtuple('Point', ['x','y'], mutable=False)</b>, which\r\n       is equivalent to writing <b>Point = pnamedtuple('Point', 'x y')</b> or\r\n       <b>Point = pnamedtuple('Point', 'x,y')</b>.\r\n    Using <b>Point</b>, we can then write code like <b>origin = Point(0,0)</b>.\r\n    <p>\r\n    A <b>legal name</b> for  the type and fields must start with a letter which\r\n      can be followed by 0 or more letters, digits, or underscore characters\r\n     (hint: I used a simple regular expression to verify legal names); also it\r\n      must not be a Python keyword.\r\n    Hint: the name <b>kwlist</b> is importable from the <b>keyword</b> module:\r\n       it is bound to a list of all Python keywords.\r\n    <p>\r\n    The parameters must have the following structure.\r\n    <ul>\r\n       <li><b>type_name</b> must be a legal name (see above).\r\n       <p>\r\n       <li><b>field_names</b> must be a list of legal names (see above), or a\r\n               string in which spaces separate legal names (or commas and\r\n               optional spaces separate legal names).\r\n           So, we can specify <b>field_names</b> like <b>['x','y']</b> or\r\n\t      <b>'x y'</b>, or  <b>'x,  y'</b>.\r\n           If a name is duplicated, just ignore all but its first appearance\r\n             (hint: I used the <b>unique</b> generator to filter out\r\n             duplicates).\r\n    </ul>\r\n    <p>\r\n    If any of the names are not legal, raise a <b>SyntaxError</b> with\r\n      an appropriate message.\r\n</ul>\r\nThe resulting class that is written should have the following functionality.\r\nNote that the main job of <b>pnamedtuple</b> is to compute a large string\r\n  that describes the class; we could define the class by writing the string to\r\n  a file and then importing the file; instead, the <b>pnamedtuple</b> function\r\n  returns the class object.\r\n<ul>\r\n  <li>Define the class name to be <b>type_name</b>.\r\n<p>\r\n<li>Define an <b>__init__</b> method that has all the field names as parameters\r\n      (in the order they appear in the second argument to <b>pnamedtuple</b>)\r\n      and initializes every instance name (using these same names) with the\r\n      value bound to its parameter.\r\n    In addition, define the instance names <b>_fields</b> and <b>_mutable</b>,\r\n       which are bound to a <b>list</b> of all the field names and the\r\n       <b>bool</b> parameter respectively.\r\n    For <b>Point</b> described above, the <b>__init__</b> method would be\r\n<b><pre>    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n        self._fields = ['x','y']\r\n        self._mutable = False</pre></b>\r\n<p>\r\nThe problem here, and throughout the other parts of this is assignment is\r\n  writing a functon like <b>gen_init</b> such that <b>gen_init(['x','y'])</b>\r\n  produces the a string representing the <b>__init__</b> function above\r\n  (including <b>\\n</b> at the end of each line).\r\n<p>\r\n<li>Define the <b>__repr__</b> method that returns a string, which when passed\r\n       to <b>eval</b> returns a newly constructed object that has all the same\r\n       instance names and values(<b>==</b>) as the object <b>__repr__</b>\r\n        was called on.\r\n    For <b>Point</b>, if we defined <b>origin = Point(0,0)</b> then calling\r\n       <b>repr(origin)</b> would return  <b>'Point(x=0,y=0)'</b>.\r\n    Here is one way to write <b>__repr__</b> for <b>Point</b> using the\r\n       <b>format</b> method,\r\n<b><pre>    def __repr__(self):\r\n        return 'Point(x={x},y={y})'.format(x=self.x,y=self.y)</pre></b>\r\n       although there are other ways for it to produce the same resulting\r\n       string.\r\n<p>\r\n<li>Define simple accessor methods for each of the field names.\r\n    Each method name should start as <b>get_</b> followed by the name of\r\n       a field.\r\n    For <b>Point</b>, there would be two accessor methods.\r\n<b><pre>    def get_x(self):\r\n        return self.x\r\n  \r\n    def get_y(self):\r\n        return self.y</pre></b>\r\n    Note that with these methods, if we had a list of <b>Point</b> named\r\n      <b>lp</b>, we could call <b>lp.sort(key= Point.get_x)</b> to sort the\r\n      list by their <b>x</b> coordinates.\r\n    Python's builtin <b>namedtuple</b> does not have this ability but the code\r\n      it produces for retrieving these values runs a bit faster.\r\n<p>\r\n<li>Define the <b>__getitem__</b> method to overload the <b>[]</b> (indexing\r\n       operator) for this class: an index of <b>0</b> returns the value of the\r\n       first field name in the <b>field_names</b> list; an index of <b>1</b>\r\n       returns the value of the second field name in the <b>field_names</b>\r\n       list, etc.\r\n    Also, the index can be a string with the named field.\r\n    So, for <b>p = Point(1,2)</b> writing <b>p.get_x()</b>, or <b>p[0])</b>, \r\n      or <b>p['x']</b> returns a result of <b>1</b>.\r\n    Raise an <b>IndexError</b> with an appropriate message if the index is out\r\n       of bounds <b>int</b> or a string that does not name a field.\r\n    <p>\r\n    Note that this method can be used by Python to iterate through any class\r\n       produced by <b>pnamedtuple</b> one index after another.\r\n    It is also useful for writing the <b>__eq__</b> method: see below.\r\n    <p>\r\n    Hint: for an <b>int index</b> parameter, combine the <b>self._fields</b>,\r\n      instance name, the <b>get_</b> methods, and the <b>eval</b> function\r\n      to write a short solution to this problem; in the case of\r\n      <b>origin = Point(0,0)</b>, calling <b>origin[1]</b> should construct \r\n      the  string <b>'self.get_y()'</b> and return <b>eval('self.get_y()')</b>.\r\n<p>\r\n<li>Overload the <b>==</b> operator so that it returns <b>True</b> when the two\r\n      named tuples come from the same class and have all their name fields\r\n      bound to equal values.\r\n    Hint: use <b>__getitem__</b> for each name to check for equality.\r\n<p>\r\n<li>Define a <b>_replace</b> method, which takes <b>**kargs</b> as a parameter\r\n      (keyword args).\r\n    This allows the name <b>kargs</b> to be used in the method as a\r\n       <b>dict</b> of  parameter names and their matching argument values.\r\n    The semantics of the <b>_replace</b> method depends on the value stored in\r\n      the instance name <b>self._mutable</b>:\r\n    <ul>\r\n    <li>If <b>True</b>, the instance namess of the object it is called on\r\n           are changed and the method returns <b>None</b>.\r\n        So, if <b>origin = Point(0,0)</b> and we call\r\n        <b>origin._replace(y=5)</b>, then <b>print(origin)</b> would\r\n           display as <b>Point(x=0,y=5)</b> because <b>origin</b> is mutated.\r\n    <p>\r\n    <li>If <b>False</b>, it returns a new object of the same class, whose\r\n           instance name's values are the same, except for those specified\r\n           in <b>kargs</b>.\r\n        So, if <b>origin = Point(0,0)</b> and we call\r\n        <b>new_origin = origin._replace(y=5)</b>, then\r\n        <b>print(origin,new_origin)</b> would display as\r\n        <b>Point(x=0,y=0) Point(x=0,y=5)</b> because <b>origin</b> is not\r\n           mutated.\r\n    </ul>\r\n    <p>\r\n    Define this method to look like\r\n<b><pre>    def _replace(self,**kargs):\r\n        if self._mutable:\r\n            ...\r\n        else:\r\n            ...</pre></b>\r\n    In both <b>...</b> we iterate (through <b>kargs.items()</b> or\r\n      <b>self._fields</b>) and refer to <b>self.__dict__</b> to retrieve the\r\n      current values bound to the instance names: this is a bit tricky.\r\n\r\n    Use our textbook or web resources to learn more about <b>**kargs</b>; feel\r\n      free to post specific question on the forum not relating to their actual\r\n      use in <b>_replace</b> and also, not, \"Could someone please explain\r\n      **kargs to me\").\r\n    <p>\r\n   The <b>kargexample.py</b> module has a little <b>**kargs</b> demo in it.\r\n<p>\r\n<li><b>Extra credit</b>:\r\n    Define the <b>__setattr__</b> method so after <b>__init__</b> finishes, if\r\n          the <b>mutable</b> parameter is <b>False</b>, the named tuple will not\r\n          allow any instance names to be changed: it will raise an\r\n          <b>AttributeError</b> with an appropriate message.\r\n</ul>\r\n<p>\r\nOf course, our <b>pnamedtuple</b> function should work for <b>Point</b> as\r\n  illustrated above, but should also work for any other legal call.\r\nThe actual <b>namedtuple</b> class in Python is implemented differently, but \r\n  this programming assignment requires you to use the implemenation above.\r\n\r\n\r\n<h3>Testing</h3>\r\nThe <b>pcollections.py</b> module includes a script that calls\r\n  <b>driver.driver()</b>.\r\nThe project folder contains a <b>bsc.txt</b> file (examine it) to use for\r\n   batch-self-checking your function.\r\nThese are rigorous but not exhaustive tests.\r\n<p>\r\nNote that when exceptions are raised, they are printed by the driver but the \r\n  <b>Command:</b> prompt sometimes appears misplaced.\r\n<p>\r\nYou can write othercode at the bottom of your <b>pcollections.py</b> module to\r\n  test the <b>pnamedtuple</b> function, or type code into the driver as\r\n  illustrated below.\r\nNotice the default for each command is the command previously entered.\r\n<b><pre>  Driver started\r\n  Command[!]: from pcollections import pnamedtuple as pnt\r\n  Command[from pcollections import pnamedtuple as pnt]: Point = pnt('Point', 'x y')\r\n  Command[Point = pnt('Point', 'x y')]: origin = Point(0,0)\r\n  Command[origin = Point(0,0)]: p1 = Point(5,2)\r\n  Command[p1 = Point(5,2)]: print(p1)\r\n  Point(x=5,y=2)\r\n  Command[print(p1)]: print(p1.get_x())\r\n  5\r\n  Command[print(p1.get_x())]: print(p1[0])\r\n  5\r\n  Command[print(p1[0])]: print(p1['x'])\r\n  5\r\n  Command[print(p1['x'])]: print(p1['z'])\r\n  Traceback (most recent call last):\r\n    File \"C:\\Users\\Pattis\\workspace\\courselib\\driver.py\", line 224, in driver\r\n      exec(old,local,globl)\r\n    File \"<string>\", line 1, in <module>\r\n    File \"<string>\", line 17, in __getitem__\r\n  IndexError: Point.__getitem__: index(z) is illegal\r\n  Command[print(p1['z'])]: p2 = p1._replace(x=2,y=5)\r\n  Command[p2 = p1._replace(x=2,y=5)]: print(p1,p2)\r\n  Point(x=5,y=2) Point(x=2,y=5)\r\n  Command[print(p1,p2)]: quit\r\n  Driver stopped</pre></b>\r\n\r\n<p>\r\nFiles for <b>batch_test</b> (see <b>bt.txt</b> for an example) just contain\r\n  commands that will be executed; many are calls to the <b>print</b> function,\r\n  which show the result of the print.\r\n<p>\r\nRemember that your <b>pnamedtuple</b> function can print on the console, for\r\n  debugging purposes, the string it is about to <b>exec</b> so you can look for\r\n  errors there (just eyeball whether the code correct).\r\nThe <b>show_listing</b> function (defined in the <b>pnamedtuple</b> function)\r\n  display a string on the console, numbering its lines (useful when <b>exec</b> \r\n finds an error: it reports a line number that <b>show_listing</b> shows).\r\n<p>\r\nFinalkly, I have also included two programs that David Kay published in ICS-31\r\n  that use Python's <b>namedtuple</b> (with those names changed to\r\n  <b>pnamedtuple</b>).\r\n</tbody>\r\n</table>\r\n\r\n</html>\r\n", "id": 10828.0}