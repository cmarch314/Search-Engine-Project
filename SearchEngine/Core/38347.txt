{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 1Introduction This part of the reference manual covers the higher dimensional kernel The kernel contains objects of constant size such as point vector direction line ray segment circle With each type comes a set of functions which can be applied to an object of this type You will typically find access functions e g to the coordinates of a point tests of the position of a point relative to the object a function returning the bounding box the length or the area of an object and so on The CGAL kernel further contains basic operations such as affine transformations detection and computation of intersections and distance computations Note that this section partly recapitulates facts already mentioned for the lower dimensional kernel 1 1 Robustness The correctness proof of nearly all geometric algorithms presented in theory papers assumes exact computation with real numbers This leads to a fundamental problem with the implementation of geometric algorithms Naively often the exact real arithmetic is replaced by inexact floating point arithmetic in the implementation This often leads to acceptable results for many input data However even for the implementation of the simplest geometric algorithms this simplification occasionally does not work Rounding errors introduced by inaccurate arithmetic may lead to inconsistent decisions causing unexpected failures for some correct input data There are many approaches to this problem one of them is to compute exactly compute so accurate that all decisions made by the algorithm are exact which is possible in many cases but more expensive than standard floating point arithmetic C M Hoffmann Hof89a Hof89b illustrates some of the problems arising in the implementation of geometric algorithms and discusses some approaches to solve them A more recent overview is given in Sch The exact computation paradigm is discussed by Yap and Dub YD95 and Yap Yap97 In CGAL you can choose the underlying number types and arithmetic You can use different types of arithmetic simultaneously and the choice can be easily changed e g for testing So you can choose between implementations with fast but occasionally inexact arithmetic and implementations guaranteeing exact computation and exact results Of course you have to pay for the exactness in terms of execution time and storage space See the section on number types in the Support Library for more details on number types and their capabilities and performance 1 2 Genericity To increase generic usage of objects and predicates the higher dimensional kernel makes heavy use of iterator ranges as defined in the STL for modelling tuples Iterators conceptualize C pointers For an iterator range first last we define T tuple first last as the ordered tuple T T 1 T d 1 where S i i first the element obtained by i times forwarding the iterator by operator and then dereferencing it to get the value to which it points We write d size first last and S set first last to denote the unordered set of elements of the corresponding tuple This extends the syntax of random access iterators to input iterators If we index the tuple as above then we require that d 1 first last Next chapter Kernel Representations Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Kernel_d/Chapter_introduction_d.html", "title": "introduction", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Kernel_d/introduction_d.tex' -->\n<html> <head>  \n<title>Introduction</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_introduction_d.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_1\"></a>\n  \n<h1>Chapter 1<BR>Introduction</h1>\n<P>\n\nThis part of the reference manual covers the higher-dimensional\nkernel.  The kernel contains objects of constant size, such as point,\nvector, direction, line, ray, segment, circle.  With each type comes a\nset of functions which can be applied to an object of this type.  You\nwill typically find access functions (e.g. to the coordinates of a\npoint), tests of the position of a point relative to the object, a\nfunction returning the bounding box, the length, or the <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> of an\nobject, and so on.  The C<SMALL>GAL</SMALL> kernel further contains basic\noperations such as affine transformations, detection and computation\nof intersections, and distance computations. Note that this section\npartly recapitulates facts already mentioned for the lower-dimensional\nkernel.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>1.1&nbsp;&nbsp;&nbsp;Robustness</h2>\n<P>\n\nThe correctness proof of nearly all geometric algorithms presented in\ntheory papers assumes exact computation with real numbers.  This leads\nto a fundamental problem with the implementation of geometric\nalgorithms.  Naively, often the exact real arithmetic is replaced by\ninexact floating-point arithmetic in the implementation.  This often\nleads to acceptable results for many input data.  However, even for\nthe implementation of the simplest geometric algorithms this\nsimplification occasionally does not work.  Rounding errors introduced\nby inaccurate arithmetic may lead to inconsistent decisions, causing\nunexpected failures for some correct input data.  There are many\napproaches to this problem, one of them is to compute exactly (compute\nso accurate that all decisions made by the algorithm are exact) which\nis possible in many cases but more expensive than standard\nfloating-point arithmetic.  C.&nbsp;M.&nbsp;Hoffmann&nbsp;[<A HREF=\"../biblio.html#Biblio_h-gsm-89\">Hof89a</A>, <A HREF=\"../biblio.html#Biblio_h-pargc-89\">Hof89b</A>]\nillustrates some of the problems arising in the implementation of\ngeometric algorithms and discusses some approaches to solve them.  A\nmore recent overview is given in [<A HREF=\"../biblio.html#Biblio_s-rpigc-00\">Sch00</A>].  The exact\ncomputation paradigm is discussed by Yap and Dub&eacute; [<A HREF=\"../biblio.html#Biblio_yd-ecp-95\">YD95</A>]\nand Yap [<A HREF=\"../biblio.html#Biblio_y-tegc-97\">Yap97</A>].\n<P>\n\nIn C<SMALL>GAL</SMALL> you can choose the underlying number types and arithmetic.\nYou can use different types of arithmetic simultaneously and the\nchoice can be easily changed, e.g. for testing.  So you can choose\nbetween implementations with fast but occasionally inexact arithmetic\nand implementations guaranteeing exact computation and exact results.\nOf course you have to pay for the exactness in terms of execution time\nand storage space.  See the section on number types in the\n<A HREF=\"./support/contents.html\" TARGET=\"_top\">Support Library</A> for more details\non number types and their capabilities and performance.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>1.2&nbsp;&nbsp;&nbsp;Genericity</h2>\n<P>\n\nTo increase generic usage of objects and predicates the\nhigher-dimensional kernel makes heavy use of iterator ranges as\ndefined in the STL for modelling tuples. Iterators conceptualize C++\npointers.\n<P>\n\nFor an iterator range <I>[first,last)</I> we define <I>T = tuple   [first,last)</I> as the ordered tuple <MATH><I>(T[0],T[1], ...T[d-1])</I></MATH>\nwhere <MATH><I>S[i] = *++<SUP>(i)</SUP><I>first</I></I></MATH> (the element obtained by <MATH><I>i</I></MATH>\ntimes forwarding the iterator by operator <I>++</I> and then\ndereferencing it to get the value to which it points).  We write <I>d   = size [first,last)</I> and <I>S = set [first,last)</I> to denote the\nunordered set of elements of the corresponding tuple.\n<P>\n\nThis extends the syntax of random access iterators to input iterators.\nIf we index the tuple as above then we require that\n<MATH><I>++<SUP>(d+1)</SUP><I>first</I> = <I>last</I></I></MATH>.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"Chapter_kernel_representation_d.html\">Kernel Representations</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_1!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38347.0}