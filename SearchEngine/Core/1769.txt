{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Project 3 Maps and Legends Due date and time Wednesday November 26 11 59pm Introduction In the last couple of decades two forces have combined to fundamentally change how software is built The rise of an always on Internet local networks within organizations and a growing variety of Internet capable devices allows us to make assumptions about near ubiquitous connectivity The cost of acquiring and connecting many small servers has dropped precipitously Thanks especially to cloud providers it s no longer even necessary to purchase the servers it s now possible to dynamically and automatically rent servers by the hour in data centers around the world What were once single large scale software systems running on beefy individual servers are now collections of cooperating services communicating with one another over networks The paradigm of providing software as a service i e providing the ability to access software running on the provider s servers or even on servers rented by the provider from a third party rather than providing software to be installed on the user s infrastructure is becoming increasingly popular and profitable As a result it s become quite useful to break complex problems into collections of small services The small services can be recombined more easily to solve new problems and an organization may not even have to build all of the services it needs instead subscribing to services offered by others to provide some of the necessary functionality What appears outwardly to be a single web site might be composed underneath the covers of a variety of services provided by multiple distinct vendors In this project we ll consider one such small service an authentication service that manages usernames and passwords but does little else It will not be battle ready it ll store its information only in memory with no redundancy and will completely ignore security for example but it will serve as a vehicle for us to continue our recent exploration into writing well behaved C classes and begin to consider the design of somewhat larger C programs which will seed our work on future projects Well behaved classes We ve been discussing in lecture what I call well behaved C classes A well behaved C class is one whose objects can be used in ways that other types in the language can be used while exhibiting the same kinds of behavior with respect to things like memory usage parameter passing modes and so on Objects of well behaved C classes clean up after themselves when they die can be copied in a way that makes the copy entirely unique and separate from the original or disallow copying altogether when there is no reasonable way to provide that guarantee can be made constant while preserving the ability to perform whatever operations do not change the publicly observable state of the object and so on Every C class you write starting with this project will have to be a well behaved class What we ll discover as we go forward is that smart design choices and the use of additional C features as we learn them can make this goal simpler to achieve than you might think But first we need to understand where the issues and pitfalls lie and what tools C provides us to solve these problems so we ll focus our energies on some of the lowest level mechanisms first Getting started As with the previous project you ll need to complete a couple of chores before you can start working on this project Be sure you read these instructions and follow them completely before proceeding Refreshing your ICS 45C VM environment Even if you previously downloaded your ICS 45C VM you may need to refresh its environment before proceeding with this project so that you have a copy of the project3 project template that you ll need for this project Log into your VM and issue the command ics45c version to see what version of the ICS 45C environment you currently have stored on your VM Note in particular the timestamp if you see a version with a timestamp older than the one listed below you ll want to refresh your environment by running the command ics45c refresh to download the latest one before you proceed with this project 2 14 11 9 3 13 12 Project 3 template added Creating your project directory on your ICS 45C VM A project template has been created specifically for this project It includes a gather script for preparing your files for submission when you re finished scripts for running the program with and without the Memcheck tool scripts for running your unit tests with and without the Memcheck tool as well as a sample input for your program the same input that is specified in the project write up so you won t have to type it in repeatedly You will no doubt need additional test inputs besides the one we ve provided especially ones that contain fewer kinds of commands so you can use them earlier in your development process Decide on a name for your project directory then issue the command ics45c start project PROJECT NAME project3 to create your new project using the project3 template Do not use other project templates like basic or project2 for this project A brief tour of your project directory After creating your project directory using the project3 template change into your project directory and issue the command ls to list its contents Most of what you ll see is the same as in previous projects but you ll see a couple of things that you ll want to take note of The inputs directory contains the sample input contained in this project write up which you can use for testing purposes using the redirection trick shown in the previous project you can avoid re typing that input repeatedly The gtest directory in which you ll write your unit tests contains three files gtestmain cpp a file that provides a main function for your unit tests you will not need to modify this file HashMapTests cpp a file in which you ll write your unit tests HashMap SanityCheckTests cpp a file that contains a set of sanity checking unit tests that will check that your HashMap class is compatible i e it has the necessary member functions and you haven t introduced incompatible changes with the tests we ll be running against it More information about unit testing appears later in this write up The program You will be writing an authentication service whose role is to keep track of username password combinations verify that a particular username password combination is valid and be able to report on the number of unique username password combinations that are currently known As in the previous project it will read all of its input from the standard input std cin and will write all of its output to the standard output std cout though you could certainly imagine it doing its work across a network connection instead If text based communication like this seems primitive you might be surprised to find out that many well known Internet protocols actually send text based commands and responses that are not all that different from what we re doing here Input and output Your program should read one complete line of input at a time parse it and execute one command Any command that is unable to be parsed correctly because for example it has too few parameters or is a completely unrecognized command should be seen as invalid Valid commands on the other hand should be executed and will have some kind of observable effect either changing what data is stored by the service or reporting back on some aspect of it The program continues reading parsing and processing one command at a time until a special quit command appears on the input in which case the program ends More details about what the service does The program stores a collection of username password combinations in memory arranging them in a data structure called a hash table Initially there are no username password combinations stored there are commands to create and remove them as well as a command to verify that a particular username password combination is correct and a collection of debug commands that allow you to analyze the state of your hash table Clean memory usage As in the previous project before the program ends any objects it has allocated dynamically must be deallocated Furthermore any illegal memory accesses reads or writes to memory addresses that have not been allocated or have been deallocated already use of uninitialized values are prohibited even if the behavior of the program is otherwise correct The latter rule is motivated by the fact that these kinds of illegal memory accesses exhibit behavior that is actually undefined in the C standard that your program works correctly with illegal memory accesses when using one particular compiler on one particular operating system is no guarantee that it will work correctly on others or even that it will always work on your own As before Memcheck is a great tool for verifying these conditions If Memcheck reports no warnings as the program runs and it reports no leaks when the program ends you can rest assured that your program is using memory cleanly You can run your program with Memcheck by issuing the command run memcheck from within your project directory The commands There are two sets of commands that your service must provide One is a set of user facing commands that would presumably be used by subscribers to your authentication service access to these commands is what you would hypothetically be selling if your service was available via the Internet Separately you ll provide a set of debug commands which make visible certain aspects of the internals of your service e g specifics on the structure of your hash table these are commands you would not likely make available to a subscriber were this a real Internet based service but might be very handy for finding problems when they occur The user facing commands The following user facing commands must be supported Every command appears on a line by itself and the output of every command should appear on a line by itself Command FormatDescriptionCREATE username passwordCreate a new username password combination and stores it in the program s collection If successful the output is CREATED If the username is already stored in the collection no change is made and the output is EXISTS LOGIN username passwordChecks a username password combination to see if it is valid A username password combination is valid if it exists i e the username is in the collection and is associated with the password in which case the output is SUCCEEDED If the username password combination does not exist the output is FAILED REMOVE usernameRemoves the username password combination with the given username if it exists If so the output is REMOVED If no username password combination with the given username exists the output is NONEXISTENT CLEARRemoves all username password combinations from the service The output is CLEARED even if there were no username password combinations at the time QUITThe output of this command is GOODBYE Once this command has been processed the program should end The debug commands The following debug commands must be supported These are designed to provide you visibility into the internals of your service which will assist you in your testing They are also designed to provide us visibility when we grade your project Command FormatDescriptionDEBUG ONMakes the other debug commands available Before issuing this command all other debug commands should be considered invalid If debug commands were not already on the output is ON NOW if they were the output is ON ALREADY While in debug mode all of the user facing commands remain available DEBUG OFFMakes the other debug commands unavailable After issuing this command all debug commands should be considered invalid except for DEBUG ON If debug commands were already on the output is OFF NOW if they weren t already on the output is OFF ALREADY LOGIN COUNTThe output is the number of username password combinations currently being stored BUCKET COUNTThe output is the number of buckets in the hash table at present LOAD FACTORThe output is the load factor of the hash table at present There is no specific requirement here about the number of decimal places to include in the output whatever emerges by default if you write a double to std cout is fine MAX BUCKET SIZEThe output is the length of the largest bucket i e the one whose linked list contains the largest number of elements in the hash table You can absolutely feel free to add more debug commands if you d find them useful though no additional debug commands are required Debugging generally involves making things visible that are otherwise hidden if you find yourself confronted with a scenario that you can t understand think about what things you d like to know that you can t already see then add a debug command that makes it visible Examples might include being able to see which usernames are stored in which buckets or being able to see the hash value of a particular username Input and output requirements All commands require all of the parameters listed above The output for any invalid command one that is missing parameters has too many parameters or is simply unrecognized e g LISTEN to music should be INVALID Note that spelling is relevant here You ll need to expect commands in the input to be spelled correctly and you ll need to be sure that your output is spelled correctly i e exactly as specified in the project write up When we grade your program part of that work will be done using an automated test suite so the spelling issue becomes vitally important Minor but important details All input and output is case sensitive the word BOO would always be considered different from the word boo or the word Boo You ll find that this means you don t have to worry at all about this problem string comparisons in C by default behave this way It is safe to assume that usernames and passwords can contain any character other than whitespace but they can never have whitespace characters in them This simplifies the problem of parsing the commands A complete example of program execution The following is a complete example of program execution demonstrating how input and output are interleaved Input is shown in a regular font weight output is shown in bold CREATE thornton ics uci edu abcdefg CREATED CREATE boo thornton com sleeping CREATED CREATE boo thornton com playing EXISTS LOGIN thornton ics uci edu abcdefg SUCCEEDED LOGIN thornton ics uci edu defg FAILED LOGIN bill gates microsoft com windows FAILED LOGIN COUNT INVALID DEBUG ON ON NOW LOGIN COUNT 2 DEBUG ON ON ALREADY DEBUG OFF OFF NOW LOGIN COUNT INVALID REMOVE thornton ics uci edu REMOVED REMOVE thornton ics uci edu NONEXISTENT REMOVE edge u2 com NONEXISTENT LOGINS hello hello com hello INVALID LOGIN thornton ics uci edu INVALID LOGIN INVALID WTF INVALID INVALID QUIT GOODBYE Some background on our hash table implementation Hash tables are implemented in many slightly different ways but the central concept is always the same when storing a collection of search keys and possibly other information attached to each define a way to determine where each search key belongs then use that as a starting point for deciding where to store the key and where to find it later Deciding where a search key belongs is the role of a hash function whose job is to take a key and return a hash value The hash value is in turn used to choose a location to store find or remove the key Our hash table has the specific goal of acting as a map which is a collection of key value pairs dictionaries in Python and TreeMaps and HashMaps in Java are kinds of maps We ll implement our hash table in a class called HashMap It will be separately chained which is to say that it will be implemented as a dynamically allocated array of buckets where each bucket is a singly linked list or more specifically a dynamically allocated array of pointers to nodes with an empty list represented by nullptr Because keys and values are paired together each linked list node will store both a key and a value In a separately chained hash table like ours storing removing and looking up existing keys is a matter of hashing the key deciding which bucket it belongs in and then searching that bucket by traversing that bucket s linked list Hash functions Part of what makes a hash table work is the presence of a hash function A hash function s job ultimately is to decide which bucket a particular key belongs in Not surprisingly there are lots of different ways to write a hash function and a well implemented hash table is not necessarily tied to a particular one instead it s ideally possible to configure different hash tables with different hash functions In our HashMap class we ll solve this problem by writing two different constructors One of them will take no parameters A default hash function of your choosing will be used by any HashMap created using this constructor Another of them will a hash function as a parameter Whatever hash function is given will be used by any HashMap created using this constructor Being able to configure different HashMaps with different hash functions will give us the ability to more thoroughly test your HashMap implementation so that we can be sure we know how it will behave and might also prove useful for you in our own testing Hash functions have the type std function unsigned int const std string which means they are functions or anything else that can be treated as a function that take a const std string as a parameter and return an unsigned int Note that these hash functions will have no other contextual information available to them all they ll know is the string they re given when they re called In particular since they will be unaware of the number of buckets they can actually legally return any arbitrary unsigned int so it will be up to the HashMap class to take the values returned by the hash function and reduce them into the range of available bucket indices e g by using the operator Load factors and rehashing While linked lists can grow with relative impunity their size is ultimately limited only by the amount of available memory the performance of a separately chained hash table is a function of the lengths of its linked lists so we re strongly incentivized to keep those lists as short as possible Even with a wonderfully designed hash function a separately chained hash table can still be slow simply because it s become overly full with every list storing multiple keys We d like to avoid this problem This leads to a question How do we measure how full a hash table is We say that the load factor of a hash table is the number of keys it s storing divided by the number of buckets or stated differently the average length of its lists To avoid the performance hit of becoming overly full your HashMap class is required to allocate a larger number of buckets and rehash all of the keys into them whenever the load factor exceeds a threshold of 8 The reason that rehashing is necessary is that the number of buckets has an effect on which bucket a key will be stored in so changing the number of buckets requires rehashing the keys so they re each stored in their new home Design requirements for your HashMap class Your HashMap class must use the provided HashMap hpp header file which you ll find in your project directory after creating your project using the project3 project template as a starting point That header file declares a set of members that your class is required to implement as is though you re welcome to add anything you d like to it you won t be able to change or remove anything because we ll be running a set of unit tests against your HashMap class to verify its correctness separately from the rest of your program For example if you change the signatures of the member functions declared in HashMap hpp our unit tests won t compile One of the primary goals of this project is to explore the tools provided by C to allow you to write a well behaved class so your HashMap class is required to be well behaved Sanity checking your HashMap implementation To ensure that your HashMap is compatible with our unit tests a set of sanity checking unit tests are included in the gtest directory in your project directory in a file called HashMap SanityCheckTests cpp They make no attempt to validate any of the HashMap s functionality but they do at least ensure that your HashMap contains all of the necessary public member functions and that their parameter and return types are correct Initially the sanity checking unit tests will not link successfully this why they re they are all commented out but as you work you ll be able to gradually uncomment them and see the compile If you haven t successfully uncommented compiled linked and run all of the sanity checking unit tests your HashMap will not compile against our unit tests As you work you may discover that the sanity checking tests that once compiled and linked successfully suddenly don t anymore this is actually a clue that something important may have changed so you ll want to be cognizant of it Many of the errors you ll get from the sanity checking tests are actually linker errors which can be a bit difficult to unravel when you haven t had a lot of practice with them but if you compile relatively often there won t be many candidates whenever you have a problem focus on changes you made most recently and you ll find your likely culprit Some rules limitations and additional challenges Here are the rules and limitations governing your work on this project You are not permitted to use containers e g std vector or std list or generic algorithms e g std find from the C standard library We will be exploring the standard library in some depth in the relatively near future but the goal here is to implement your own data structure by hand to gain an understanding of how to build a well behaved class out of underlying features that are not themselves well behaved The public members of your HashMap class cannot be changed in any way from the way they ve been declared in the provided HashMap hpp header file including seemingly minor changes such as removing const from one of the member variable declarations This is necessary so that we can compile and run our unit tests against your class which will expect the public members to be identical to their current declarations If you introduce incompatible changes that cause our unit tests to fail this will have a potentially significant impact on the score you receive on this project Your best bet is to make sure that all of the sanity checking unit tests pass before you submit your work Now that we re embracing C s object oriented features you should write classes other than just HashMap in your implementation While there are no specific rules about precisely which classes you need consider how you might slice the program s functionality into pieces or layers representing each of those layers with a class Classes provide the ability to combine data with operations and that would certainly benefit parts of this project other than just the hash table All of your classes should be well behaved and no memory or resources should leak anywhere in your program Note however that classes whose member variables are all of well behaved types are generally well behaved without any extra work e g you won t find that you need the Big Three in those classes Don t write the Big Three unless you need them e g don t include empty destructors in classes that don t require them and don t write copy constructors or assignment operators if all they do is the same thing that the default generated ones do Every class must be declared in its own header file and implemented in its own source file with separation of interface and implementation as we ve seen in code examples thus far Additional challenges As you work on the project if you re interested in tackling additional challenges here are a few directions you can go In general you should always feel free to explore the use of language features we ve yet to cover though you should also be aware that you sometimes won t be able to submit your work if you choose features that explicitly violate one of the rules above such as using C standard library containers like std list that doesn t stop you from doing it as a learning experience One design challenge is to consider implementing your user interface using the Command pattern with inheritance and polymorphism used to differentiate the different commands that can be entered via the standard input Another design challenge is that the HashMap class is somewhat more limited than it could be because it requires its keys and values to be strings A more broadly useful HashMap would be implemented as a template class meaning that individual HashMap objects can have their key and value types configured e g HashMap int Student If you d like to go this route we can talk about ways to do it that won t break our unit tests you ll have to approach it carefully but it can be done Or you can work on that part separately and not submit it which is probably a lot safer A useful optimization is to implement the ability for your HashMaps to be moved You can accomplish this by adding a move constructor and a move assignment operator to your HashMap class which requires the use of a new C 11 feature called rvalue references We don t offer extra credit in this course so things like this are strictly voluntary but if you re looking for something interesting and additional to do these are some ideas you might like to pursue Testing Along with the program you ll be writing in this project you will also need to write some unit tests that focus their efforts on verifying that your HashMap class is behaving as you d expect I d actually suggest writing your HashMap class and its unit tests before writing any of the rest of the program because your program won t be possible to write without having a working HashMap implementation Of course we ll be offering substantial partial credit to anyone who submits a working HashMap but none of the rest of the program so there s additional incentive to work on the HashMap implementation first When we grade your submission we ll be running two kinds of tests Whole program tests where we will redirect test input files into the program s standard input and check the output against our expectationsUnit tests that focus only on your HashMap class including member functions and other functionality e g the Big Three that your program may not use Why should we test functionality that s not used by the program You should think of classes as reusable components To the extent that we can make their designs clear and their implementations bullet proof reuse will be enabled For example when you ve finished your HashMap class you should be able to write a second separate program that uses it in ways that your original program didn t and I d suggest doing this in the course of your testing yet still see ultimately that it works as it should if not you still have work to do How many tests do we have to write There is no explicit number of unit tests that we re requiring Your goal is to write isolated separate tests that together achieve coverage of all of the functionality in your HashMap class Note that this is going to take more than just a small handful of tests though each test is likely to be relatively short Writing your unit tests You ll be using a unit testing library called Google Test to write your unit tests We ll talk about Google Test in lecture and that talk will be accompanied by a code example but if you want to get a head start on reading about it a good place to start is the documentation page linked below Google Test Documentation Write your unit tests in a file called HashMapTests cpp which you ll find in a directory called gtest inside your project directory Note that your unit tests do not belong in the app directory because they are not part of your program they re separate I ve already created that file for you and I ve even given you one unit test already implemented though it s commented out initially since it depends on functionality you ve not yet written Once you get the necessary member functions in your HashMap class implemented you can feel free to use the test I provided as one of your unit tests Running your unit tests When you compile and link your code using the build script there are actually two separate executables being built one that is your program which starts executing in main cpp and another that is your unit tests To run your program you should use the run script as usual To run your unit tests instead you should use the command run gtest instead Note too that you can run your unit tests using Memcheck with the command run memcheck gtest too if you re so inclined You can try all of this out before you write any code Simply run the build script and then issue the command run gtest which will show you output that looks something like this Running tests from test cases tests from test cases ran 1 ms total PASSED tests Submitting your unit tests The gather script will gather files in both the app and gtest directories in your project directory so your unit tests will automatically be included in your submission Deliverables After using the gather script in your project directory to gather up your C source and header files including your unit tests into a single project3 tar gz file submit that file and only that file to Checkmate Follow this link for a discussion of how to submit your project via Checkmate Be aware that I ll be holding you to all of the rules specified in that document including the one that says that you re responsible for submitting the version of the project that you want graded We won t regrade a project simply because you submitted the wrong version accidentally It s not a bad idea to look at the contents of your tarball on your host operating system before submitting it Can I submit after the deadline Yes it is possible subject to the late work policy for this course which is described in the section titled Late work at this link Additional tweaks for new ICS 45C VM by Alex Thornton Fall 2 14 A unit testing requirement additional tweaks and new explanations added by Alex Thornton Winter 2 14 Parts rewritten and additional debugging commands and information added by Alex Thornton Fall 2 13 Originally written by Alex Thornton Fall 2 12 ", "_id": "http://www.ics.uci.edu/~thornton/ics45c/ProjectGuide/Project3/", "title": "ics 45c fall 2014, project #3: maps and legends", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Project #3: Maps and Legends</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Project #3: <i>Maps and Legends</i></p>\r\n   \r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Wednesday, November 26, 11:59pm</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>In the last couple of decades, two forces have combined to fundamentally change how software is built:</p>\r\n\r\n<ul>\r\n  <li>The rise of an \"always-on\" Internet, local networks within organizations, and a growing variety of Internet-capable devices allows us to make assumptions about near-ubiquitous connectivity.</li>\r\n  <li>The cost of acquiring and connecting many small servers has dropped precipitously.  Thanks especially to cloud providers, it's no longer even necessary to purchase the servers; it's now possible to dynamically (and automatically) rent servers by the hour in data centers around the world.</li>\r\n</ul>\r\n\r\n<p>What were once single, large-scale software systems running on beefy individual servers are now collections of cooperating services communicating with one another over networks.  The paradigm of providing <i>software as a service</i> (i.e., providing the ability to access software running on the provider's servers &mdash; or even on servers rented by the provider from a third party &mdash; rather than providing software to be installed on the user's infrastructure) is becoming increasingly popular and profitable.</p>\r\n\r\n<p>As a result, it's become quite useful to break complex problems into collections of small services.  The small services can be recombined more easily to solve new problems, and an organization may not even have to build all of the services it needs, instead subscribing to services offered by others to provide some of the necessary functionality.  What appears outwardly to be a single web site might be composed, underneath the covers, of a variety of services provided by multiple distinct vendors.</p>\r\n\r\n<p>In this project, we'll consider one such small service: an <i>authentication service</i> that manages usernames and passwords, but does little else.  It will not be battle-ready &mdash; it'll store its information only in memory with no redundancy and will completely ignore security, for example &mdash; but it will serve as a vehicle for us to continue our recent exploration into writing <i>well-behaved</i> C++ classes and begin to consider the design of somewhat larger C++ programs, which will seed our work on future projects.</p>\r\n\r\n<p class=\"subtitle\">Well-behaved classes</p>\r\n\r\n<p>We've been discussing in lecture what I call <i>well-behaved</i> C++ classes.  \r\nA well-behaved C++ class is one whose objects can be used in ways that other types in the language can be used, while exhibiting the same kinds of behavior with respect to things like memory usage, parameter passing modes, and so on.  Objects of well-behaved C++ classes clean up after themselves when they die, can be copied in a way that makes the copy entirely unique and separate from the original (or disallow copying altogether, when there is no reasonable way to provide that guarantee), can be made constant while preserving the ability to perform whatever operations do not change the publicly observable state of the object, and so on.</p>\r\n\r\n<p>Every C++ class you write, starting with this project, will have to be a well-behaved class.  What we'll discover as we go forward is that smart design choices &mdash; and the use of additional C++ features as we learn them &mdash; can make this goal simpler to achieve than you might think.  But first we need to understand where the issues and pitfalls lie, and what tools C++ provides us to solve these problems, so we'll focus our energies on some of the lowest-level mechanisms first.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Getting started</p>\r\n\r\n<p>As with the previous project, you'll need to complete a couple of chores before you can start working on this project.  <i>Be sure you read these instructions and follow them completely before proceeding.</i></p>\r\n\r\n<p class=\"subtitle\">Refreshing your ICS 45C VM environment</p>\r\n\r\n<p>Even if you previously downloaded your ICS 45C VM, you may need to refresh its environment before proceeding with this project, so that you have a copy of the <b>project3</b> project template that you'll need for this project.</p>\r\n\r\n<p>Log into your VM and issue the command <b>ics45c version</b> to see what version of the ICS 45C environment you currently have stored on your VM.  Note, in particular, the timestamp; if you see a version with a timestamp older than the one listed below, you'll want to refresh your environment by running the command <b>ics45c refresh</b> to download the latest one before you proceed with this project.</p>\r\n\r\n<blockquote><pre>\r\n2014-11-09 03:13:12\r\nProject #3 template added\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Creating your project directory on your ICS 45C VM</p>\r\n\r\n<P>A project template has been created specifically for this project.  It includes a <b>gather</b> script for preparing your files for submission when you're finished, scripts for running the program with and without the Memcheck tool, scripts for running your unit tests with and without the Memcheck tool, as well as a sample input for your program (the same input that is specified in the project write-up) so you won't have to type it in repeatedly.  (You will no doubt need additional test inputs besides the one we've provided, especially ones that contain fewer kinds of commands, so you can use them earlier in your development process.)</p>\r\n\r\n<p>Decide on a name for your project directory, then issue the command <b>ics45c start_project PROJECT_NAME project3</b> to create your new project using the <b>project3</b> template.</p>\r\n\r\n<p><i>Do not use other project templates, like <b>basic</b> or <b>project2</b>, for this project!</i></p>\r\n\r\n<p class=\"subtitle\">A brief tour of your project directory</p>\r\n\r\n<p>After creating your project directory using the <b>project3</b> template, change into your project directory and issue the command <b>ls</b> to list its contents.  Most of what you'll see is the same as in previous projects, but you'll see a couple of things that you'll want to take note of:</p>\r\n\r\n<ul>\r\n  <li>The <b>inputs/</b> directory contains the sample input contained in this project write-up, which you can use for testing purposes &mdash; using the redirection trick shown in the previous project, you can avoid re-typing that input repeatedly.</li>\r\n  <li>The <b>gtest/</b> directory, in which you'll write your unit tests, contains three files:\r\n    <ul>\r\n      <li><b>gtestmain.cpp</b>, a file that provides a <b>main()</b> function for your unit tests; you will not need to modify this file.</li>\r\n      <li><b>HashMapTests.cpp</b>, a file in which you'll write your unit tests.</li>\r\n      <li><b>HashMap_SanityCheckTests.cpp</b>, a file that contains a set of \"sanity checking\" unit tests that will check that your HashMap class is compatible (i.e., it has the necessary member functions and you haven't introduced incompatible changes) with the tests we'll be running against it.</li>\r\n      <li>(More information about unit testing appears later in this write-up.)</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The program</p>\r\n\r\n<p>You will be writing an <i>authentication service</i>, whose role is to keep track of username/password combinations, verify that a particular username/password combination is valid, and be able to report on the number of unique username/password combinations that are currently known.  As in the previous project, it will read all of its input from the standard input (<b>std::cin</b>) and will write all of its output to the standard output (<b>std::cout</b>), though you could certainly imagine it doing its work across a network connection instead.  (If text-based communication like this seems primitive, you might be surprised to find out that many well-known Internet protocols actually send text-based commands and responses that are not all that different from what we're doing here.)</p>\r\n\r\n<p class=\"subtitle\">Input and output</p>\r\n\r\n<p>Your program should read one complete line of input at a time, parse it, and execute one <i>command</i>.  Any command that is unable to be parsed correctly &mdash; because, for example, it has too few parameters or is a completely unrecognized command &mdash; should be seen as <i>invalid</i>.  Valid commands, on the other hand, should be executed and will have some kind of observable effect, either changing what data is stored by the service or reporting back on some aspect of it.</p>\r\n\r\n<p>The program continues reading, parsing, and processing one command at a time until a special \"quit\" command appears on the input, in which case the program ends.</p>\r\n\r\n<p class=\"subtitle\">More details about what the service does</p>\r\n\r\n<p>The program stores a collection of username/password combinations in memory, arranging them in a data structure called a <i>hash table</i>.  Initially, there are no username/password combinations stored; there are commands to create and remove them, as well as a command to verify that a particular username/password combination is correct, and a collection of <i>debug commands</i> that allow you to analyze the state of your hash table.</p>\r\n\r\n<p class=\"subtitle\">\"Clean\" memory usage</p>\r\n\r\n<p>As in the previous project, before the program ends, any objects it has allocated dynamically must be deallocated.  Furthermore, any illegal memory accesses &mdash; reads or writes to memory addresses that have not been allocated (or have been deallocated already), use of uninitialized values &mdash; are prohibited, even if the behavior of the program is otherwise correct.  (The latter rule is motivated by the fact that these kinds of illegal memory accesses exhibit behavior that is actually undefined in the C++ standard; that your program works correctly with illegal memory accesses when using one particular compiler on one particular operating system is no guarantee that it will work correctly on others, or even that it will always work on your own.)</p>\r\n\r\n<p>As before, Memcheck is a great tool for verifying these conditions.  If Memcheck reports no warnings as the program runs, and it reports no leaks when the program ends, you can rest assured that your program is using memory cleanly.  You can run your program with Memcheck by issuing the command <b>./run --memcheck</b> from within your project directory.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The commands</p>\r\n\r\n<p>There are two sets of commands that your service must provide.  One is a set of <i>user-facing commands</i> that would presumably be used by subscribers to your authentication service; access to these commands is what you would hypothetically be selling if your service was available via the Internet.  Separately, you'll provide a set of <i>debug commands</i>, which make visible certain aspects of the internals of your service (e.g., specifics on the structure of your hash table); these are commands you would not likely make available to a subscriber, were this a real Internet-based service, but might be very handy for finding problems when they occur.</p>\r\n\r\n<p class=\"subtitle\">The \"user-facing\" commands</p>\r\n\r\n<p>The following user-facing commands must be supported.  Every command appears on a line by itself, and the output of every command should appear on a line by itself.</p>\r\n\r\n<table class=\"normal\">\r\n  <tr class=\"top\">\r\n    <td>Command Format</td>\r\n    <td>Description</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>CREATE&nbsp;<i>username</i>&nbsp;<i>password</i></b></td>\r\n    <td>Create a new username/password combination and stores it in the program's collection.  If successful, the output is <b>CREATED</b>.  If the username is already stored in the collection, no change is made and the output is <b>EXISTS</b>.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>LOGIN&nbsp;<i>username</i>&nbsp;<i>password</i></b></td>\r\n    <td>Checks a username/password combination to see if it is valid.  A username/password combination is valid if it exists (i.e., the username is in the collection <i>and</i> is associated with the password), in which case the output is <b>SUCCEEDED</b>.  If the username/password combination does not exist, the output is <b>FAILED</b>.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>REMOVE&nbsp;<i>username</i></b></td>\r\n    <td>Removes the username/password combination with the given username, if it exists.  If so, the output is <b>REMOVED</b>.  If no username/password combination with the given username exists, the output is <b>NONEXISTENT</b>.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>CLEAR</b></td>\r\n    <td>Removes <i>all</i> username/password combinations from the service.  The output is <b>CLEARED</b> (even if there were no username/password combinations at the time).</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>QUIT</b></td>\r\n    <td>The output of this command is <b>GOODBYE</b>.  Once this command has been processed, the program should end.</td>\r\n  </tr>\r\n</table>\r\n\r\n<p class=\"subtitle\">The debug commands</p>\r\n\r\n<p>The following debug commands must be supported.  These are designed to provide you visibility into the internals of your service, which will assist you in your testing.  They are also designed to provide <i>us</i> visibility when we grade your project.</p>\r\n\r\n<table class=\"normal\">\r\n  <tr class=\"top\">\r\n    <td>Command Format</td>\r\n    <td>Description</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>DEBUG&nbsp;ON</b></td>\r\n    <td>Makes the other debug commands available.  Before issuing this command, all other debug commands should be considered invalid.  If debug commands were not already on, the output is <b>ON NOW</b>; if they were, the output is <b>ON ALREADY</b>.  While in debug mode, all of the user-facing commands remain available.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>DEBUG&nbsp;OFF</b></td>\r\n    <td>Makes the other debug commands unavailable.  After issuing this command, all debug commands should be considered invalid except for <b>DEBUG ON</b>.  If debug commands were already on, the output is <b>OFF NOW</b>; if they weren't already on, the output is <b>OFF ALREADY</b>.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>LOGIN&nbsp;COUNT</b></td>\r\n    <td>The output is the number of username/password combinations currently being stored.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>BUCKET&nbsp;COUNT</b></td>\r\n    <td>The output is the number of buckets in the hash table at present.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>LOAD&nbsp;FACTOR</b></td>\r\n    <td>The output is the load factor of the hash table at present.  There is no specific requirement here about the number of decimal places to include in the output; whatever emerges by default if you write a <b>double</b> to <b>std::cout</b> is fine.</td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>MAX&nbsp;BUCKET&nbsp;SIZE</b></td>\r\n    <td>The output is the length of the largest bucket (i.e., the one whose linked list contains the largest number of elements) in the hash table.</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>You can absolutely feel free to add more debug commands if you'd find them useful, though no additional debug commands are required.  Debugging generally involves making things visible that are otherwise hidden; if you find yourself confronted with a scenario that you can't understand, think about what things you'd like to know that you can't already see, then add a debug command that makes it visible.  (Examples might include being able to see which usernames are stored in which buckets, or being able to see the hash value of a particular username.)</p>\r\n\r\n<p class=\"subtitle\">Input and output requirements</p>\r\n\r\n<p>All commands require all of the parameters listed above.  The output for any invalid command &mdash; one that is missing parameters, has too many parameters, or is simply unrecognized (e.g., <b>LISTEN to music</b>) should be <b>INVALID</b>.</p>\r\n\r\n<p>Note that spelling is relevant here.  You'll need to expect commands in the input to be spelled correctly, <i>and</i> you'll need to be sure that your output is spelled correctly (i.e., exactly as specified in the project write-up).  When we grade your program, part of that work will be done using an automated test suite, so the spelling issue becomes vitally important.</p>\r\n\r\n<p class=\"subtitle\">Minor but important details</p>\r\n\r\n<p>All input and output is case-sensitive; the word <b>BOO</b> would always be considered different from the word <b>boo</b> or the word <b>Boo</b>.  (You'll find that this means you don't have to worry at all about this problem; string comparisons in C++, by default, behave this way.)</p>\r\n\r\n<p>It is safe to assume that usernames and passwords can contain any character <i>other than</i> whitespace, but they can never have whitespace characters in them.  (This simplifies the problem of parsing the commands.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">A complete example of program execution</p>\r\n\r\n<p>The following is a complete example of program execution, demonstrating how input and output are interleaved.  Input is shown in a regular font weight; output is shown in <b>bold</b>.</p>\r\n\r\n<blockquote><pre>\r\nCREATE thornton@ics.uci.edu abcdefg\r\n<b>CREATED</b>\r\nCREATE boo@thornton.com sleeping\r\n<b>CREATED</b>\r\nCREATE boo@thornton.com playing\r\n<b>EXISTS</b>\r\nLOGIN thornton@ics.uci.edu abcdefg\r\n<b>SUCCEEDED</b>\r\nLOGIN thornton@ics.uci.edu defg\r\n<b>FAILED</b>\r\nLOGIN bill.gates@microsoft.com windows\r\n<b>FAILED</b>\r\nLOGIN COUNT\r\n<b>INVALID</b>\r\nDEBUG ON\r\n<b>ON NOW</b>\r\nLOGIN COUNT\r\n<b>2</b>\r\nDEBUG ON\r\n<b>ON ALREADY</b>\r\nDEBUG OFF\r\n<b>OFF NOW</b>\r\nLOGIN COUNT\r\n<b>INVALID</b>\r\nREMOVE thornton@ics.uci.edu\r\n<b>REMOVED</b>\r\nREMOVE thornton@ics.uci.edu\r\n<b>NONEXISTENT</b>\r\nREMOVE edge@u2.com\r\n<b>NONEXISTENT</b>\r\nLOGINS hello@hello.com hello\r\n<b>INVALID</b>\r\nLOGIN thornton@ics.uci.edu\r\n<b>INVALID</b>\r\nLOGIN\r\n<b>INVALID</b>\r\nWTF\r\n<b>INVALID</b>\r\n\r\n<b>INVALID</b>\r\nQUIT\r\n<b>GOODBYE</b>\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Some background on our hash table implementation</p>\r\n\r\n<p>Hash tables are implemented in many slightly different ways, but the central concept is always the same: when storing a collection of <i>search keys</i> (and possibly other information attached to each), define a way to determine where each search key \"belongs,\" then use that as a starting point for deciding where to store the key and where to find it later.  Deciding where a search key belongs is the role of a <i>hash function</i>, whose job is to take a key and return a <i>hash value</i>.  The hash value is, in turn, used to choose a location to store, find, or remove the key.</p>\r\n\r\n<p>Our hash table has the specific goal of acting as a <i>map</i>, which is a collection of key/value pairs; dictionaries in Python and TreeMaps and HashMaps in Java are kinds of maps.  We'll implement our hash table in a class called HashMap.  It will be <i>separately chained</i>, which is to say that it will be implemented as a dynamically-allocated array of <i>buckets</i>, where each bucket is a singly-linked list (or, more specifically, a dynamically-allocated array of pointers to nodes, with an empty list represented by <b>nullptr</b>).  Because keys and values are paired together, each linked list node will store both a key and a value.</p>\r\n\r\n<p>In a separately-chained hash table like ours, storing, removing, and looking up existing keys is a matter of hashing the key, deciding which bucket it belongs in, and then searching that bucket by traversing that bucket's linked list.</p>\r\n\r\n<p class=\"subtitle\">Hash functions</p>\r\n\r\n<p>Part of what makes a hash table work is the presence of a hash function.  A hash function's job, ultimately, is to decide which bucket a particular key belongs in.  Not surprisingly, there are lots of different ways to write a hash function, and a well-implemented hash table is not necessarily tied to a particular one; instead, it's ideally possible to configure different hash tables with different hash functions.</p>\r\n\r\n<p>In our HashMap class, we'll solve this problem by writing two different constructors:</p>\r\n\r\n<ul>\r\n  <li>One of them will take no parameters.  A <i>default hash function</i> of your choosing will be used by any HashMap created using this constructor.</li>\r\n  <li>Another of them will a hash function as a parameter.  Whatever hash function is given will be used by any HashMap created using this constructor.</li>\r\n</ul>\r\n\r\n<p>Being able to configure different HashMaps with different hash functions will give us the ability to more thoroughly test your HashMap implementation (so that we can be sure we know how it will behave), and might also prove useful for you in our own testing.</p>\r\n\r\n<p>Hash functions have the type <b>std::function&lt;unsigned int(const std::string&)&gt;</b>, which means they are functions (or anything else that can be treated as a function) that take a <b>const std::string&</b> as a parameter and return an <b>unsigned int</b>.  Note that these hash functions will have no other contextual information available to them; all they'll know is the string they're given when they're called.  In particular, since they will be unaware of the number of buckets, they can actually legally return any arbitrary <b>unsigned int</b>, so it will be up to the HashMap class to take the values returned by the hash function and reduce them into the range of available bucket indices (e.g., by using the <b>%</b> operator).</p>\r\n\r\n<p class=\"subtitle\">Load factors and rehashing</p>\r\n\r\n<p>While linked lists can grow with relative impunity &mdash; their size is ultimately limited only by the amount of available memory &mdash; the performance of a separately-chained hash table is a function of the lengths of its linked lists, so we're strongly incentivized to keep those lists as short as possible.  Even with a wonderfully-designed hash function, a separately-chained hash table can still be slow simply because it's become overly full, with every list storing multiple keys.  We'd like to avoid this problem.</p>\r\n\r\n<p>This leads to a question: How do we measure how \"full\" a hash table is?  We say that the <i>load factor</i> of a hash table is the number of keys it's storing divided by the number of buckets (or, stated differently, the average length of its lists).  To avoid the performance hit of becoming overly full, your HashMap class is required to allocate a larger number of buckets and rehash all of the keys into them whenever the load factor exceeds a threshold of 0.8.  (The reason that rehashing is necessary is that the number of buckets has an effect on which bucket a key will be stored in, so changing the number of buckets requires rehashing the keys so they're each stored in their new \"home.\")</p>\r\n\r\n<p class=\"subtitle\">Design requirements for your HashMap class</p>\r\n\r\n<p>Your HashMap class <i>must</i> use the provided <b>HashMap.hpp</b> header file &mdash; which you'll find in your project directory after creating your project using the <b>project3</b> project template &mdash; as a starting point.  That header file declares a set of members that your class is required to implement as-is &mdash; though you're welcome to add anything you'd like to it, you won't be able to change or remove <i>anything</i> &mdash; because we'll be running a set of unit tests against your HashMap class to verify its correctness, separately from the rest of your program.  For example, if you change the signatures of the member functions declared in HashMap.hpp, our unit tests won't compile.</p>\r\n\r\n<p>One of the primary goals of this project is to explore the tools provided by C++ to allow you to write a <i>well-behaved</i> class, so your HashMap class is required to be well-behaved.</p>\r\n\r\n<p class=\"subtitle\">Sanity-checking your HashMap implementation</p>\r\n\r\n<p>To ensure that your HashMap is compatible with our unit tests, a set of \"sanity-checking\" unit tests are included in the <b>gtest</b> directory in your project directory, in a file called <b>HashMap_SanityCheckTests.cpp</b>.  They make no attempt to validate any of the HashMap's functionality, but they do at least ensure that your HashMap contains all of the necessary public member functions, and that their parameter and return types are correct.  Initially, the sanity-checking unit tests will not link successfully &mdash; this why they're they are all commented out &mdash; but as you work, you'll be able to gradually uncomment them and see the compile.  If you haven't successfully uncommented, compiled, linked, and run all of the sanity-checking unit tests, your HashMap will not compile against our unit tests.</p>\r\n\r\n<p>As you work, you may discover that the sanity-checking tests that once compiled and linked successfully suddenly don't anymore; this is actually a clue that something important may have changed, so you'll want to be cognizant of it.  Many of the errors you'll get from the sanity-checking tests are actually linker errors, which can be a bit difficult to unravel when you haven't had a lot of practice with them, but if you compile relatively often, there won't be many candidates whenever you have a problem; focus on changes you made most recently and you'll find your likely culprit.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Some rules, limitations, and additional challenges</p>\r\n\r\n<p>Here are the rules and limitations governing your work on this project.</p>\r\n\r\n<ul>\r\n  <li>You are not permitted to use containers (e.g., <b>std::vector</b> or <b>std::list</b>) or generic algorithms (e.g., <b>std::find</b>) from the C++ standard library.  We will be exploring the standard library in some depth in the relatively near future, but the goal here is to implement your own data structure by hand, to gain an understanding of how to build a well-behaved class out of underlying features that are not themselves well-behaved.</li>\r\n  <li>The public members of your HashMap class cannot be changed in any way from the way they've been declared in the provided <b>HashMap.hpp</b> header file &mdash; including seemingly minor changes, such as removing <b>const</b> from one of the member variable declarations.  This is necessary so that we can compile and run our unit tests against your class, which will expect the public members to be identical to their current declarations.  <i>If you introduce incompatible changes that cause our unit tests to fail, this will have a potentially significant impact on the score you receive on this project.</i>  Your best bet is to make sure that all of the \"sanity-checking\" unit tests pass before you submit your work.</li>\r\n  <li>Now that we're embracing C++'s object-oriented features, you should write classes other than just HashMap in your implementation.  While there are no specific rules about precisely which classes you need, consider how you might slice the program's functionality into pieces or layers, representing each of those layers with a class.  Classes provide the ability to combine data with operations, and that would certainly benefit parts of this project other than just the hash table.</li>\r\n  <li>All of your classes should be well-behaved and no memory or resources should leak anywhere in your program.  Note, however, that classes whose member variables are all of well-behaved types are generally well-behaved without any extra work (e.g., you won't find that you need the Big Three in those classes).  Don't write the Big Three unless you need them (e.g., don't include empty destructors in classes that don't require them, and don't write copy constructors or assignment operators if all they do is the same thing that the default-generated ones do).</li>\r\n  <li>Every class must be declared in its own header file and implemented in its own source file, with separation of interface and implementation as we've seen in <a href=\"../../CodeExamples\">code examples</a> thus far.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Additional challenges</p>\r\n\r\n<p>As you work on the project, if you're interested in tackling additional challenges, here are a few directions you can go.  In general, you should always feel free to explore the use of language features we've yet to cover, though you should also be aware that you sometimes won't be able to submit your work (if you choose features that explicitly violate one of the rules above, such as using C++ standard library containers like <b>std::list</b>); that doesn't stop you from doing it as a learning experience.</p>\r\n\r\n<ul>\r\n  <li>One design challenge is to consider implementing your user interface using the Command pattern, with inheritance and polymorphism used to differentiate the different commands that can be entered via the standard input.</li>\r\n  <li>Another design challenge is that the HashMap class is somewhat more limited than it could be, because it requires its keys and values to be strings.  A more broadly useful HashMap would be implemented as a <i>template class</i>, meaning that individual HashMap objects can have their key and value types configured (e.g., HashMap&lt;int, Student&gt;).  If you'd like to go this route, we can talk about ways to do it that won't break our unit tests; you'll have to approach it carefully, but it can be done.  (Or you can work on that part separately and not submit it, which is probably a lot safer!)</li>\r\n  <li>A useful optimization is to implement the ability for your HashMaps to be <i>moved</i>.  You can accomplish this by adding a <i>move constructor</i> and a <i>move assignment operator</i> to your HashMap class, which requires the use of a new C++11 feature called <i>rvalue references</i>.</li>\r\n</ul>\r\n\r\n<p>We don't offer extra credit in this course, so things like this are strictly voluntary, but if you're looking for something interesting and additional to do, these are some ideas you might like to pursue.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Testing</p>\r\n\r\n<p>Along with the program you'll be writing in this project, you will also need to write some <i>unit tests</i> that focus their efforts on verifying that your HashMap class is behaving as you'd expect.  I'd actually suggest writing your HashMap class <i>and</i> its unit tests <i>before</i> writing any of the rest of the program, because your program won't be possible to write without having a working HashMap implementation.  (Of course, we'll be offering substantial partial credit to anyone who submits a working HashMap but none of the rest of the program, so there's additional incentive to work on the HashMap implementation first.)</p>\r\n\r\n<p>When we grade your submission, we'll be running two kinds of tests:</p>\r\n\r\n<ul>\r\n  <li>Whole-program tests, where we will redirect test input files into the program's standard input and check the output against our expectations</li>\r\n  <li>Unit tests that focus only on your HashMap class, including member functions and other functionality (e.g., the Big Three) that your program may not use</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Why should we test functionality that's not used by the program?</p>\r\n\r\n<p>You should think of classes as reusable components.  To the extent that we can make their designs clear and their implementations bullet-proof, reuse will be enabled.  For example, when you've finished your HashMap class, you should be able to write a second, separate program that uses it in ways that your original program didn't &mdash; and I'd suggest doing this in the course of your testing &mdash; yet still see, ultimately, that it works as it should; if not, you still have work to do.</p>\r\n\r\n<p class=\"subtitle\">How many tests do we have to write?</p>\r\n\r\n<p>There is no explicit number of unit tests that we're requiring.  Your goal is to write isolated, separate tests that together achieve coverage of all of the functionality in your HashMap class.  Note that this is going to take more than just a small handful of tests, though each test is likely to be relatively short.</p>\r\n\r\n<p class=\"subtitle\">Writing your unit tests</p>\r\n\r\n<p>You'll be using a unit testing library called <b>Google Test</b> to write your unit tests.  We'll talk about Google Test in lecture, and that talk will be accompanied by a <a href=\"../../CodeExamples\">code example</a>, but if you want to get a head start on reading about it, a good place to start is the documentation page linked below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://code.google.com/p/googletest/wiki/Documentation\">Google Test Documentation</a></li>\r\n</ul>\r\n\r\n<p>Write your unit tests in a file called <b>HashMapTests.cpp</b>, which you'll find in a directory called <b>gtest</b> inside your project directory.  (Note that your unit tests do not belong in the <b>app</b> directory, because they are not part of your program; they're separate.)  I've already created that file for you, and I've even given you one unit test already implemented, though it's commented out initially, since it depends on functionality you've not yet written.  Once you get the necessary member functions in your HashMap class implemented, you can feel free to use the test I provided as one of your unit tests.</p>\r\n\r\n<p class=\"subtitle\">Running your unit tests</p>\r\n\r\n<p>When you compile and link your code using the <b>./build</b> script, there are actually two separate executables being built, one that is your program (which starts executing in <b>main.cpp</b>) and another that is your unit tests.  To run your program, you should use the <b>./run</b> script as usual.  To run your unit tests instead, you should use the command <b>./run gtest</b> instead.  Note, too, that you can run your unit tests using Memcheck with the command <b>./run --memcheck gtest</b>, too, if you're so inclined.</p>\r\n\r\n<p>You can try all of this out before you write any code.  Simply run the <b>./build</b> script and then issue the command <b>./run gtest</b>, which will show you output that looks something like this:</p>\r\n\r\n<blockquote><pre>\r\n[==========] Running 0 tests from 0 test cases.\r\n[==========] 0 tests from 0 test cases ran. (1 ms total)\r\n[  PASSED  ] 0 tests.\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Submitting your unit tests</p>\r\n\r\n<p>The <b>gather</b> script will gather files in both the <b>app</b> and <b>gtest</b> directories in your project directory, so your unit tests will automatically be included in your submission.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>After using the <b>gather</b> script in your project directory to gather up your C++ source and header files (including your unit tests) into a single <b>project3.tar.gz</b> file, submit that file (and only that file!) to Checkmate.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for a discussion of how to submit your project via Checkmate.  Be aware that I'll be holding you to all of the rules specified in that document, including the one that says that you're responsible for submitting the version of the project that you want graded.  We won't regrade a project simply because you submitted the wrong version accidentally.  (It's not a bad idea to look at the contents of your tarball on your host operating system before submitting it.)</p>\r\n\r\n<p class=\"subtitle\">Can I submit after the deadline?</p>\r\n\r\n<p>Yes, it is possible, subject to the late work policy for this course which is described in the section titled <i>Late work</i> at <a href=\"../index.html\">this link</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Additional tweaks for new ICS 45C VM by Alex Thornton, Fall 2014.</li>\r\n  <li>A unit testing requirement, additional tweaks, and new explanations added by Alex Thornton, Winter 2014.</li>\r\n  <li>Parts rewritten and additional debugging commands and information added by Alex Thornton, Fall 2013.</li>\r\n  <li>Originally written by Alex Thornton, Fall 2012.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 1769.0}