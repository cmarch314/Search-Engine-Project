{"text": "Program 2 Implementing Ordered Collections with Linked Lists and real iterators Fundamental Data Structures ICS 23 Introduction This programming assignment is designed to ensure that you know how to implement two ordered collection classes Queue and Priority Queue and one collection class Set with linked lists Your implementations will include fully functional iterators implementing the hasNext next and remove methods The first two of these collection classes share the same subinterface OrderedCollection the third uses the Collection subinterface Each has its own special sub subinterface Queue PriorityQueue and Set but only PriorityQueue includes any new methods Each implementation extends one abstract classes which itself extends AbstractOrderedCollection or AbstractCollection Primarily the implementation specifies an actual data structure linked list and the methods that implement the collection s operations methods that must appear in the concrete class or should appear there to improve the speed over some inherited methods Note that the Iterable interface which the OrderedCollection and Collection interfaces extend specifies just that a method named iterator is defined to return an Iterator IMPORTANT I have written implementations for these same collections using arrays although this assignment uses linked lists there are still many strong similarities in all these implementations So I encourage you to examine these implementations closely while you are writing your linked list implementations These array implementations are all included in the collections jar file that you build a path to in this assignment You must write all your implementations using linked lists a linear linked list for Queue a header linked list for PriorityQueue and a trailer linked list for Set The constuctors in the PriorityQueue class must be passed an object constructed from some class that implements the Comparator interface for specifying how to prioritize all the values added to it The toString method in each class should include the name of the class followed by in brackets the size and the order of values in the list For example if we add a then add b then add c into a queue its toString should show as LinkedQueue 3 a b c null In a header list we skip showing the value in the first header node as that node is not really in the collection represented by the list likewise in a trailer list we skip showing the value in the last trailer node for the same reason The toString method is not tested in the JUnit test but is useful for debugging when running the DriverForOrderedCollection After you have written your classes you will run each against my JUnit tests to verify a bit too strong of a word here that it is correct You will find it useful to begin testing your classes with the DriverForOrderedCollection or DriverForCollection which you can run from collection jar once you build a path to this library in the project With these drivers you can individually test any methods in your classes interactively and see their results returned values and state changes frequently using the toString menu item The following programming assignments this quarter will require you to perform a similar task implement some collection class via some advanced data structure that we have studied Most will have a JUnit test and a driver and speed test similar to this one so this assignment will also allow you to learn and get used to such a method of testing your classes Download and unzip the following Eclipse project Start and use it to start working on this program For each part of this assignmnment you will update and submit a single java file in the project see the Checkmate submission for this assignment for more details You should work on this assignment in pairs with someone in your lab section Try to find someone who lives near you with a similar work schedule e g talk about whether you like to work morning nights weekends Only one student should submit the assignment but both student s names should appear in the comments at the top of each submitted program Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review while you work on this assignment and before you turn in the files Queues Queues are implemented by simple FIFO data structures adhering to the Fast In First Out order property We can implement queues efficiently by using two instance variables which refer to a linked list whose first value is the node at the front of the queue and whose last value is the node at the rear of the queue Nodes are removed from the front and added to the rear so these are the two hot spots Although we can easily compute the number of values in linked list by traversing it instead we will declare and update an extra instance variable named objectCount to cache the size incrementing and decrementing it as values are successfully added removed from the queue so we don t have to traverse the list to compute this value The class LinkedQueue declares the required instance variables and declares stubs for all the needed methods just fill in these stubs note that this class compiles correctly but fails most JUnit tests because its method bodies are empty Finally fill in the complexity class information at the top of the class file as comments based on your implementation See the common sections below pertaining to iterators and testing Priority Queues Priority Queues can be implemented by a variety of data structures where the highest priority value is always removed first How does a specific priority queue determine which value has the highest priority When constructed we supply the priority queue with an object constructed from a class that implements the Comparator interface So we cannot ask What is the priority of a value But we can ask Which of two values has the higher priority using such a Comparator For example we cannot ask for the priority of a String value but we can ask which of two String values has the higher priority We can implement priority queues naively although not very efficiently with one instance variable which refers to a linked list whose first value is the highest priority value and whose remaining values occur in decreasing priority when adding a value to a priority queue we insert it at the right spot keeping the list ordered from highest to lowest priority when removing the highest priority value from a priority queue we remove it from the front Instead of a plain linked list you must implement the priority queue queue using a Header node first in the linked list Doing so should simplify writing the most complicated method adding a value to the priority queue write this method very simply Although we can easily compute the number of values in linked list by traversing it instead we will declare and update an extra instance variable named objectCount to cache the size incrementing and decrementing it as values are successfully added removed from the priority queue so we don t have to traverse the list to compute this value The class HeaderLinkedPriorityQueue declares the required instance variables declares stubs for all the needed methods just fill in these stubs note that this class compiles correctly but fails most JUnit tests because its method bodies are empty Finally fill in the complexity class information at the top of the class file as comments based on your implementation See the common sections below pertaining to iterators and testing Sets Sets can be implemented by a variety of data structures We can implement sets naively although not very efficiently with one instance variable which refers to a linked list of values in the set their order is not important Instead of a plain linked list you must implement the set using a Trailer node last in the linked list Doing so should simplify removing a value from the set both the class and iterator remove methods using the standard code covered in the the discussion of trailer lists Although we can easily compute the number of values in linked list by traversing it instead we will declare and update an extra instance variable named objectCount to cache the size incrementing and decrementing it as values are successfully added removed from the priority queue so we don t have to traverse the list to compute this value The class TrailerLinkedSet declares the required instance variables declares stubs for all the needed methods just fill in these stubs note that this class compiles correctly but fails most JUnit tests because its method bodies are empty Finally fill in the complexity class information at the top of the class file as comments based on your implementation See the common sections below pertaining to iterators and testing Iterators In each java file implementing a collection class in the start folder I have included enough of the iterator class so that its hasNext and next methods work correctly but only if remove which does not work correctly is never called So any methods that use iterators but do not call remove and are declared in some abstract class and not overridden in the concrete class will work correctly toArray is the most important of these methods because it is used extensively in the JUnit tests If your iterator fails to work in these simple cases almost every JUnit test will fail because the iterator does not work correctly So change the code in the next method carefully I would suggest that you leave this code alone until you have gotten all the other parts of each class working correctly Note that iterators for OrderedCollection classes return values in the order that they would be removed from the collection FIFO for queue and priority ordering for a priority queue for sets which aren t ordered iterators can return the set values in any order Given how these linked lists represent collections queue front to rear priority queue highest to lowest priority set any order the order of iterating through these collections is the same as the order of traversing their linked list implementation from beginning to end which makes the hasNext and next methods straightforward to implement To pass the special JUnit tests that focus on iterators you must write more code in the next and remove methods to complete them To this end I have supplied the declaration and intialization of a few extra instance variables but these variables are not all used in the code I supplied you have to write more code that uses them correctly You can observe how the expectedModCount and removedAlready instance variables are used in the array implementations of these classes they are used equivalently here You can use whatever other references I supply previous seen and next to remove values carefully from the list in the iterator Generally the instance variables if supplied should refer to the node whose value the next method will return next to the node whose value the next method just returned seen and to the node whose that come before the seen one in the linked list previous not needed in the TrailerLinkedSet because of its special removal property Generally after the next method is called these three values refer to consecutive values in the linked list being iterated over it should be the case that previous next seen and seen next next This relationship doesn t hold a when we just start iterating there has been no seen value and there is no value previous to seen and b after a call to remove which removes the seen value in this case previous next next if we did not just remove the first value in the linked list which is a special case Recall that in an iterator we remove the value that the next method most recently returned Thus remove throws an exception either if either a no value has ever been returned by next yet or if the most recent value returned by next has already been removed it cannot be removed twice Also next and remove must throw an exception if the collection has been modified via any command mutator methods since the iterator was constructed note it is OK for an iterator to mutate the data structure via remove and continue iterating on it although other iterators will fail So you should carefully manipulate the next seen and previous if present instance variables to meet all the requirements for the hasNext next and remove methods Note that you should hand simulate debug your code for the following cases some may require special code to recognize and process these cases removing values at the front of the list several times in a row calling next when the previously seen value was NOT removed calling next when the previously seen value was removed To remove the value already seen when it is appropriate to do so make the next link of the previous ListNode refer to the node the instance variable next refers to bypassing the node referred to by seen and update the required instance variables so that they will work correctly for future calls to these three iterator methods This is a delicate operation and there are subtltities beyond the brief description above Definitely draw pictures to help yourself understand the possible values for these three variables and how to update them Again you can see how these constraints are accomplished in the array implementations of these classes which are SIMPLER than how they are accomplished with linked lists because we can more easily access array indices like i 1 For linked list implementations implementing remove is a bit more complicated to implement but more EFFICIENT because values in arrays must be shifted causing the complexity class of remove to be O N in arrays Testing There are various ways to test each of the classes you are writing in this programming assignment The easiest way to start debugging is by using the DriverForOrderedCollection and DriverForCollection programs When each of these programs start it prompts you to enter the name of the collection class that you want to test debug if you set up the libraries correctly Then it allows you to perform any method call supported by the collection classes and check the results typically by calling the toString method to show the state of the collection class or view the debugger Of course you must get the toString method to work before calling it to debug other methods Although if you don t override the toString method in your implementation your class will inherit a simpler toString method from one of the abstract collections using an iterator only its hasNext and next methods to produce a String that includes all the values in the collection but in the wrong format After you debug your code with the driver try running the appropciate JUnit test Again this form of testing is useful only as you approach a finished solution We will use the JUnit test and visual inspection to grade this assignment Important Note You can put System out print statements in the JUnit code but don t accidentally remove any of the assertions otherwise you won t be fully checking your code the way we will while you are debugging your classes When you run the JUnit tests choose the default values for the first third and fourth questions for the second question enter the index of the collection class that you want to test Besides an indication of which tests pass and fail the console window will show a speed for the speed test which will vary depending on how fast a machine you run your code on don t worry about it You can also examine the execution of these classes by using the debugger and or by inserting System out print statements in your code or the JUnit test code ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/assignments/program2/program.html", "title": "program 2", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 2</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 2</h1>\r\n<h1>Implementing Ordered Collections<br>\r\n    with Linked Lists (and real iterators)\r\n</h1>\r\n<p>\r\n<h2>Fundamental Data Structures<br>\r\nICS-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to\r\n  implement two ordered collection classes (<b>Queue</b> and\r\n   <b>Priority Queue</b>) and one collection class (<b>Set</b>)\r\n  with linked lists.\r\nYour implementations will include fully-functional iterators (implementing\r\n  the <b>hasNext</b>, <b>next</b>, and <b>remove</b> methods).\r\n<p>\r\nThe first two of these collection classes share the same subinterface,\r\n  <b>OrderedCollection</b> the third uses the <b>Collection</b> subinterface.\r\nEach has its own special sub-subinterface, <b>Queue</b>, <b>PriorityQueue</b>,\r\n  and <b>Set</b>, but only <b>PriorityQueue</b> includes any new methods.\r\nEach implementation extends one abstract classes (which itself extends\r\n  <b>AbstractOrderedCollection</b> or <b>AbstractCollection</b>).\r\nPrimarily, the implementation specifies an actual data structure (linked list)\r\n  and the methods that implement the collection's operations (methods that must\r\n  appear in the concrete class or should appear there to improve the speed over\r\n  some inherited methods).\r\n<p>\r\nNote that the <b>Iterable</b> interface, which the <b>OrderedCollection</b>\r\n  and <b>Collection</b> interfaces extend, specifies just that a method named\r\n  <b>iterator</b> is defined: to return an <b>Iterator</b>.\r\n<p>\r\n<b>IMPORTANT: I have written implementations for these same collections\r\n  using arrays; although this assignment uses linked lists, there are still\r\n  <b>many strong similarities</b> in all these implementations.\r\nSo, I encourage you to examine these implementations closely while you are\r\n  writing your linked list implementations.\r\nThese array implementations are all included in the <b>collections.jar</b> file\r\n  that you build a path to in this assignment.</b>\r\n<p>\r\nYou must write all your implementations using linked lists: a linear-linked\r\n  list for <b>Queue</b>, a header linked list for <b>PriorityQueue</b>, and\r\n  a trailer linked list for <b>Set</b>.\r\nThe constuctors in the <b>PriorityQueue</b> class must be passed an object\r\n  constructed from some class that implements the <b>Comparator</b> interface,\r\n  for specifying how to prioritize all the values added to it.\r\n<p>\r\nThe <b>toString</b> method in each class should include the name of the class,\r\n  followed by, in brackets, the size and the order of values in the list.\r\nFor example, if we add <b>a</b>, then add <b>b</b>, then add <b>c</b> into a\r\n  queue, its <b>toString</b> should show as\r\n  <b>LinkedQueue[3:a->b->c->null]</b>.\r\nIn a header list, we skip showing the value in the first/header node, as that\r\n  node is not really <b>in</b> the collection represented by the list;\r\n  likewise, in a trailer list, we skip showing the value in the last/trailer\r\n  node, for the same reason.\r\nThe <b>toString</b> method is not tested in the JUnit test, but is useful for\r\n  debugging when running the <b>DriverForOrderedCollection</b>.\r\n<p>\r\nAfter you have written your classes, you will run each against my JUnit tests\r\n  to verify (a bit too strong of a word here) that it is correct.\r\nYou will find it useful to begin testing your classes with the\r\n  <b>DriverForOrderedCollection</b> or <b>DriverForCollection</b>, which you\r\n  can run from <b>collection.jar</b> once you build a path to this library in\r\n  the project.\r\nWith these drivers, you can individually test any methods in your classes\r\n  interactively, and see their results (returned values and state changes,\r\n  frequently using the <b>toString</b> menu item).\r\n<p>\r\n<!--- No speed tests\r\nThe JUnit test also includes a speed test (be careful: it makes little\r\n  sense to compare speed tests run on two different machines, as the machines\r\n  themselves might run at different speeds).\r\nNote that a class <b>must pass all its correctness tests</b> to get any credit\r\n  for speed.\r\n<p>\r\n--->\r\nThe following programming assignments this quarter will require you to perform\r\n  a similar task: implement some collection class via some advanced data \r\n structure that we have studied.\r\nMost will have a JUnit test (and a driver) and speed test similar to this one,\r\n  so this assignment will also allow you to learn and get used to such a\r\n  method of testing your classes.\r\n<p>\r\nDownload and unzip the following <a href=\"program2start.zip\">Eclipse project\r\n  Start</a> and use it to start working on this program.\r\nFor each part of this assignmnment you will update and submit a single\r\n  <b>.java</b> file in the project (see the <b>Checkmate</b> submission for\r\n  this assignment for more details).\r\n<p>\r\nYou should work on this assignment in pairs, with someone in your lab section.\r\nTry to find someone who lives near you, with a similar work schedule: e.g.,\r\n  talk about whether you like to work morning, nights, weekends.\r\n<p>\r\n<b>Only one student should submit the assignment</b>, but both student's names\r\nshould appear in the comments at the top of <b>each submitted program</b>.\r\nPlease turn in each program as you finish it, so that I can accurately assess\r\n  the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review while you work on\r\n  this assignment and before you turn in the files).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- queue -->\r\n\r\n<a name=\"queue\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Queues</b></td>\r\n<td width =\"80%\">\r\nQueues are implemented by simple FIFO data structures (adhering to the\r\n  Fast-In/First-Out order property).\r\nWe can implement queues efficiently by using two instance variables, which\r\n  refer to a linked list (whose first value is the node at the <b>front</b>\r\n  of the queue and whose last value is the node at the <b>rear</b> of the\r\n  queue).\r\nNodes are removed from the front and added to the rear, so these are the\r\n  two \"hot spots\".\r\n<p>\r\nAlthough we can easily compute the number of values in linked list by\r\n  traversing it, instead we will declare and update an extra instance variable \r\n  named <b>objectCount</b> to <b>cache</b> the size (incrementing and\r\n  decrementing it, as values are successfully added/removed from the queue) so\r\n  we don't have to traverse the list to compute this value.\r\n<p>\r\nThe class <b>LinkedQueue</b> declares the required instance variables and\r\n  declares stubs for all the needed methods: just fill in these stubs; note\r\n  that this class compiles correctly but fails most JUnit tests because its\r\n  method bodies are empty.\r\n<p>\r\nFinally, fill in the complexity class information at the top of the class file\r\n  as comments, based on your implementation.\r\nSee the common sections below pertaining to iterators and testing.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- priorityqueue -->\r\n\r\n<a name=\"priorityqueue\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Priority Queues</b></td>\r\n<td width =\"80%\">\r\nPriority Queues can be implemented by a variety of data structures (where the\r\n  highest priority value is always removed first).\r\nHow does a specific priority queue determine which value has the highest\r\n  priority?\r\nWhen constructed, we supply the priority queue with an object constructed from\r\n  a class that implements the <b>Comparator</b> interface.\r\n<p>\r\nSo, we cannot ask, \"What is the priority of a value.\" But, we can ask \"Which\r\n  of two values has the higher priority\", using such a <b>Comparator</b>.\r\nFor example, we cannot ask for the priority of a <b>String</b> value, but we\r\n  can ask which of two <b>String</b> values has the higher priority.\r\n<p>\r\nWe can implement priority queues naively (although not very efficiently) with\r\n  one instance variable, which refers to a linked list whose first value\r\n  is the highest priority value, and whose remaining values occur in decreasing\r\n  priority; when adding a value to a priority queue, we insert it at the right\r\n  spot, keeping the list ordered from highest to lowest priority; when removing\r\n  the highest priority value from a priority queue, we remove it from the\r\n  front.\r\nInstead of a plain linked-list, you must <b>implement the priority queue\r\n  queue using a \"Header node\" first in the linked list.</b>\r\nDoing so should simplify writing the most complicated method: adding a value\r\n  to the priority queue: write this method very simply.\r\n<p>\r\nAlthough we can easily compute the number of values in linked list by\r\n  traversing it, instead we will declare and update an extra instance variable \r\n  named <b>objectCount</b> to <b>cache</b> the size (incrementing and\r\n  decrementing it as values are successfully added/removed from the priority\r\n  queue) so we don't have to traverse the list to compute this value.\r\n<p>\r\nThe class <b>HeaderLinkedPriorityQueue</b> declares the required instance\r\n  variables declares stubs for all the needed methods: just fill in these\r\n  stubs; note that this class compiles correctly but fails most JUnit tests\r\n  because its method bodies are empty.\r\n<p>\r\nFinally, fill in the complexity class information at the top of the class file\r\n  as comments, based on your implementation.\r\nSee the common sections below pertaining to iterators and testing.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- set -->\r\n\r\n<a name=\"set\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Sets</b></td>\r\n<td width =\"80%\">\r\nSets can be implemented by a variety of data structures.\r\nWe can implement sets naively (although not very efficiently) with one instance\r\n  variable, which refers to a linked list of values in the set (their order\r\n  is not important).\r\nInstead of a plain linked-list, you must <b>implement the set using a \"Trailer\r\n  node\" last in the linked list.</b>\r\nDoing so should simplify removing a value from the set (both the class and\r\n  iterator <b>remove</b> methods), using the standard code covered in the the\r\n  discussion of trailer lists.\r\n<p>\r\nAlthough we can easily compute the number of values in linked list by\r\n  traversing it, instead we will declare and update an extra instance variable \r\n  named <b>objectCount</b> to <b>cache</b> the size (incrementing and\r\n  decrementing it as values are successfully added/removed from the priority\r\n  queue) so we don't have to traverse the list to compute this value.\r\n<p>\r\nThe class <b>TrailerLinkedSet</b> declares the required instance variables\r\n  declares stubs for all the needed methods: just fill in these stubs; note\r\n  that this class compiles correctly but fails most JUnit tests because its\r\n   method bodies are empty..\r\n<p>\r\nFinally, fill in the complexity class information at the top of the class file\r\n  as comments, based on your implementation.\r\nSee the common sections below pertaining to iterators and testing.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- iterators -->\r\n\r\n<a name=\"iterators\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Iterators</b></td>\r\n<td width =\"80%\">\r\nIn each <b>.java</b> file implementing a collection class in the start folder,\r\n  I have included enough of the iterator class so that its <b>hasNext</b> and\r\n  <b>next</b> methods work correctly, but only if <b>remove</b> (which does not\r\n  work correctly) is never called.\r\nSo, any methods that use iterators (but do not call <b>remove</b>) and are\r\n  declared in some abstract class and not overridden in the concrete class, \r\n  will work correctly: <b>toArray</b> is the most important of these methods,\r\n  because it is used extensively in the JUnit tests.\r\n<b>If your iterator fails to work in these simple cases, almost every JUnit\r\n  test will  fail because the iterator does not work correctly.</b>\r\nSo, change the code in the <b>next</b> method carefully!\r\nI would suggest that you leave this code alone, until you have gotten all\r\n  the other parts of each class working correctly.\r\n<p>\r\nNote that iterators for <b>OrderedCollection</b> classes return values in \r\n  the order that they would be removed from the collection: FIFO for queue and\r\n  priority ordering for a priority queue; for sets, which aren't ordered,\r\n  iterators can return the set values in any order.\r\nGiven how these linked lists represent collections\r\n  (queue: front to rear; priority queue: highest to lowest priority; set any\r\n  order), the order of iterating through these collections is the same as the\r\n  order of traversing their linked list implementation from beginning to end,\r\n  which makes the <b>hasNext</b> and <b>next</b> methods straightforward to\r\n  implement.\r\n<p>\r\nTo pass the special JUnit tests that focus on iterators, you must write more\r\n  code in the <b>next</b> and <b>remove</b> methods, to complete them.\r\nTo this end, I have supplied the declaration and intialization of a few extra\r\n  instance variables, but these variables are not all used in the code I\r\n  supplied: you have to write more code that uses them correctly.\r\n<ul>\r\n<li>You can observe how the <b>expectedModCount</b> and <b>removedAlready</b>\r\n  instance variables are used in the array implementations of these classes\r\n  (they are used equivalently here).\r\n<p>\r\n<li>You can use whatever other references I supply (<b>previous</b>,\r\n  <b>seen</b>, and <b>next</b>) to remove values carefully from the list in\r\n  the iterator.\r\nGenerally, the instance variables, if supplied, should refer to the node whose\r\n  value the <b>next</b> method will return (<b>next</b>), to the node whose\r\n  value the <b>next</b> method just returned (<b>seen</b>), and to the node\r\n  whose that come before the <b>seen</b> one in the linked list\r\n  (<b>previous</b>; not needed in the <b>TrailerLinkedSet</b>, because of its\r\n  special removal property).\r\n<p>\r\nGenerally after the <b>next</b> method is called, these three values refer to\r\n  consecutive values in the linked list being iterated over: it should be the\r\n  case that <b>previous.next == seen</b> and <b>seen.next == next</b>.\r\n<p>\r\nThis relationship doesn't hold (a) when we just start iterating (there has been\r\n  no seen value, and there is no value previous to seen) and (b) after a call\r\n  to <b>remove</b> which removes the seen value; in this case\r\n  <b>previous.next == next</b> if we did not just remove the first value in\r\n  the linked list (which is a special case).\r\n</ul>\r\nRecall that in an iterator,  we remove the value that the <b>next</b> method\r\n  most recently returned.\r\nThus, <b>remove</b> throws an exception either if either (a) no value has ever\r\n  been returned by <b>next</b> yet, or if the most recent value returned by\r\n  <b>next</b> has already been removed (it cannot be removed twice).\r\n<p>\r\nAlso, <b>next</b> and <b>remove</b> must throw an exception if the collection\r\n  has been modified (via any command / mutator methods) since the iterator was\r\n  constructed; note, it is OK for an iterator to mutate the data structure\r\n  via <b>remove</b> and continue iterating on it (although other iterators\r\n  will fail).\r\n<p>\r\nSo, you should carefully manipulate the <b>next</b>, <b>seen</b>, and\r\n  <b>previous</b> (if present) instance variables to meet all the requirements\r\n  for the <b>hasNext</b>, <b>next</b>, and <b>remove</b> methods.\r\nNote that you should hand-simulate/debug your code for the following cases;\r\n  some may require special code to recognize and process these cases.\r\n<ol>\r\n  <li> removing values at the front of the list several times in a row\r\n  <li> calling <b>next</b> when the previously seen value was NOT removed\r\n  <li> calling <b>next</b> when the previously seen value was removed,\r\n</ol>\r\nTo remove the value already seen (when it is appropriate to do so), make\r\n  the <b>next</b> link of the <b>previous ListNode</b> refer to the node the\r\n  instance variable <b>next</b> refers to (bypassing the node referred to by\r\n  <b>seen</b>) and update the required instance variables so that they will\r\n  work correctly for future calls to these three iterator methods.\r\nThis is a delicate operation, and there are subtltities beyond the brief\r\n  description above.\r\nDefinitely draw pictures to help yourself understand the possible values\r\n  for these three variables and how to update them.\r\n<p>\r\nAgain, you can see how these constraints are accomplished in the array\r\n  implementations of these classes, which are SIMPLER than how they are\r\n  accomplished with linked lists (because we can more easily access array\r\n  indices like <b>i-1</b>).\r\nFor linked list implementations, implementing <b>remove</b> is a bit more\r\n  complicated to implement, but more EFFICIENT, because values in arrays must\r\n  be shifted (causing the complexity class of <b>remove</b> to be O(N) in\r\n  arrays).\r\n<!--\r\n<p>\r\nThis part of the assignment is the hardest, and I'm not sure how many students\r\n  will completely and successfully implement <b>remove</b>.\r\nAll together, the <b>remove</b> methods in all three iterators are worth a\r\n  total of 5% of this assignment (4 of 80 points).\r\nSo, make an earnest attempt to solve this part of the programming assignment,\r\n  but if you cannot get it, you can still score 95% on the assignment.\r\n<p>\r\n-->\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- testing -->\r\n\r\n<a name=\"testing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Testing</b></td>\r\n<td width =\"80%\">\r\nThere are various ways to test each of the classes you are writing in this\r\n  programming assignment.\r\n<p>\r\nThe easiest way to start debugging is by using the\r\n  <b>DriverForOrderedCollection</b> and <b>DriverForCollection</b> programs.\r\nWhen each of these programs start, it prompts you to enter the name of the\r\n  collection class that you want to test/debug (if you set up the libraries\r\n  correctly).\r\nThen, it allows you to perform any method call supported by the collection\r\n  classes, and check the results, typically by calling the <b>toString</b>\r\n  method, to show the state of the collection class (or view the debugger).\r\nOf course, \r\n<b>you must get the <b>toString</b> method to work before calling it to debug\r\n  other methods.</b>\r\nAlthough, if you don't override the <b>toString</b> method in your\r\n  implementation, your class will inherit a simpler <b>toString</b> method \r\n  from one of the abstract collections, using an iterator (only its\r\n  <b>hasNext</b> and <b>next</b> methods) to produce a <b>String</b> that\r\n  includes all the values in the collection, but in the wrong format.\r\n<p>\r\nAfter you debug your code with the driver, try running the appropciate JUnit\r\n  test.\r\nAgain, this form of testing is useful only as you approach a finished solution.\r\nWe will use the JUnit test, and visual inspection, to grade this assignment.\r\n<b>Important Note</b>: You can put <b>System.out.print</b> statements in the\r\n  JUnit code (but don't accidentally remove any of the assertions, otherwise\r\n  you won't be fully checking your code the way we will) while you are\r\n  debugging your classes.\r\n<p>\r\nWhen you run the JUnit tests, choose the default values for the first, third, \r\n  and fourth questions; for the second question enter the index of the\r\n  collection class that you want to test.\r\nBesides an indication of which tests pass and fail, the console window\r\n  will show a speed for the speed test (which will vary depending on how\r\n  fast a machine you run your code on): don't worry about it.\r\n<p>\r\nYou can also examine the execution of these classes by using the debugger\r\n  and/or by inserting <b>System.out.print</b> statements in your code or\r\n  the JUnit test code.\r\n<!--\r\n<p>\r\nIf you want to run the program that computes the \"size\" of your code,\r\n  download and unzip the <a href=\"../../../common/zips/Lexer.zip\">Lexer</a>\r\n  file; then double click the <b>.bat</b> file in it on a PC; if you have\r\n  a Mac I'll show you how to run it during one of the Labs.\r\n--->\r\n<p>\r\n\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 33256.0}