{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 33D Convex Hulls Susan Hert and Stefan Schirra 3 1 Introduction A subset S 3 is convex if for any two points p and q in the set the line segment with endpoints p and q is contained in S The convex hull of a set S is the smallest convex set containing S The convex hull of a set of points P 3 is a convex polytope with vertices in P A point in P is an extreme point with respect to P if it is a vertex of the convex hull of P A set of points is said to be strongly convex if it consists of only extreme points This chapter describes the functions provided in CGAL for producing convex hulls in three dimensions as well as functions for checking if sets of points are strongly convex are not One can compute the convex hull of a set of points in three dimensions in one of three ways in CGAL using a static algorithm using an incremental construction algorithm or using a triangulation to get a fully dynamic computation 3 2 Static Convex Hull Construction The function convex hull 3 provides an implementation of the quickhull algorithm BDH96 for three dimensions There are two versions of this function available one that can be used when it is known that the output will be a polyhedron i e there are more than three points and they are not all collinear and one that handles all degenerate cases and returns a CGAL Object which may be a point a segment a triangle or a polyhedron Both versions accept a range of input iterators defining the set of points whose convex hull is to be computed and a traits class defining the geometric types and predicates used in computing the hull 3 2 1 Traits Class The function convex hull 3 is parameterized by a traits class which specifies the types and geometric primitives to be used in the computation The default for this traits class is Convex hull traits 3 3 2 2 Convexity Checking The function is strongly convex 3 implements the algorithm of Mehlhorn et al MNS 96 to determine if the vertices of a given polytope constitute a strongly convex point set or not This function is used in postcondition testing for convex hull 3 3 2 3 Example The following program computes the convex hull of a set of 25 random points chosen from a sphere of radius 1 It then determines if the resulting hull is a segment or a polyhedron file examples Convex hull 3 ch quickhull 3 ex C include CGAL Homogeneous h include CGAL point generators 3 h include CGAL copy n h include CGAL Convex hull traits 3 h include CGAL convex hull 3 h include vector ifdef CGAL USE GMP include CGAL Gmpz h typedef CGAL Gmpz RT else include CGAL MP Float h typedef CGAL MP Float RT endif typedef CGAL Homogeneous RT K typedef CGAL Convex hull traits 3 K Traits typedef Traits Polyhedron 3 Polyhedron 3 typedef K Segment 3 Segment 3 define point creator typedef K Point 3 Point 3 typedef CGAL Creator uniform 3 double Point 3 PointCreator int main CGAL Random points in sphere 3 Point 3 PointCreator gen 1 generate 25 points randomly on a sphere of radius 1 and copy them to a vector std vector Point 3 points CGAL copy n gen 25 std back inserter points define object to hold convex hull CGAL Object ch object compute convex hull CGAL convex hull 3 points begin points end ch object determine what kind of object it is Segment 3 segment Polyhedron 3 polyhedron if CGAL assign segment ch object std cout convex hull is a segment std endl else if CGAL assign polyhedron ch object std cout convex hull is a polyhedron std endl else std cout convex hull error std endl return 3 3 Incremental Convex Hull Construction The function convex hull incremental 3 provides an interface similar to convex hull 3 for the d dimensional incremental construction algorithm CMS93 implemented by the class CGAL Convex hull d R that is specialized to three dimensions This function accepts an iterator range over a set of input points and returns a polyhedron but it does not have a traits class in its interface It uses the kernel class Kernel used in the polyhedron type to define an instance of the adapter traits class CGAL Convex hull d traits 3 Kernel In most cases the function convex hull 3 will be faster than convex hull incremental 3 The latter is provided mainly for comparison purposes To use the full functionality available with the d dimensional class CGAL Convex hull d R in three dimensions e g the ability to insert new points and to query if a point lies in the convex hull or not you can instantiate the class CGAL Convex hull d K with the adapter traits class CGAL Convex hull d traits 3 K as shown in the following example 3 3 1 Example Copyright c 2 2 Max Planck Institut fuer Informatik Germany All rights reserved This file is part of CGAL www cgal org you may redistribute it under the terms of the Q Public License version 1 See the file LICENSE QPL distributed with CGAL Licensees holding a valid commercial license may use this file in accordance with the commercial license agreement provided with the software This file is provided AS IS with NO WARRANTY OF ANY KIND INCLUDING THE WARRANTY OF DESIGN MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE Source CVSROOT CGAL Packages Convex hull 3 demo Convex hull 3 incremental hull 3 demo C v Revision 1 9 4 1 Date 2 4 12 19 14 58 2 Name Author s Susan Hert include CGAL Homogeneous h include CGAL point generators 3 h include CGAL Convex hull d h include CGAL Convex hull d traits 3 h include CGAL Convex hull d to polyhedron 3 h include CGAL Polyhedron 3 h include CGAL copy n h include CGAL IO Geomview stream h include CGAL IO Polyhedron geomview ostream h include vector include cassert ifdef CGAL USE GEOMVIEW ifdef CGAL USE LEDA include CGAL leda integer h typedef leda integer RT else ifdef CGAL USE GMP include CGAL Gmpz h typedef CGAL Gmpz RT else NOTE the choice of double here for a number type may cause problems for degenerate point sets include CGAL double h typedef double RT endif endif typedef CGAL Homogeneous RT K typedef K Point 3 Point 3 typedef CGAL Polyhedron 3 K Polyhedron 3 typedef CGAL Convex hull d traits 3 K Hull traits 3 typedef CGAL Convex hull d Hull traits 3 Convex hull 3 typedef CGAL Creator uniform 3 double Point 3 Creator int main Convex hull 3 CH 3 create instance of the class with dimension 3 generate 25 points randomly on a sphere of radius 1 and insert them into the convex hull CGAL Random points in sphere 3 Point 3 Creator gen 1 for int i i 25 i gen CH insert gen assert CH is valid define polyhedron to hold convex hull and create it Polyhedron 3 P CGAL convex hull d to polyhedron 3 CH P display polyhedron in a geomview window CGAL Geomview stream geomview geomview CGAL RED geomview P std cout Press any key to end the program std cout flush char ch std cin get ch return else int main std cerr This demo requires geomview which is not present on this platform n return endif 3 4 Dynamic Convex Hull Construction Fully dynamic maintenance of a convex hull can be achieved by using the class CGAL Delaunay triangulation 3 This class supports insertion and removal of points i e vertices of the triangulation and the convex hull edges are simply the finite edges of infinite faces The following example illustrates the dynamic construction of a convex hull First random points from a sphere of a certain radius are generated and are inserted into a triangulation Then the number of points of the convex hull are obtained by counting the number of triangulation vertices incident to the infinite vertex Some of the points are removed and then the number of points remaining on the hull are determined Notice that the vertices incident to the infinite vertex of the triangulation are on the convex hull but it may be that not all of them are vertices of the hull 3 4 1 Example file examples Convex hull 3 dynamic hull 3 ex C include CGAL Simple cartesian h include CGAL Filtered kernel h include CGAL point generators 3 h include CGAL Delaunay triangulation 3 h include CGAL copy n h include list typedef CGAL Simple cartesian double SK typedef CGAL Filtered kernel SK FK struct K public FK typedef K Point 3 Point 3 typedef CGAL Delaunay triangulation 3 K Delaunay typedef Delaunay Vertex handle Vertex handle int main CGAL Random points in sphere 3 Point 3 gen 1 std list Point 3 points generate 25 points randomly on a sphere of radius 1 and insert them into the triangulation CGAL copy n gen 25 std back inserter points Delaunay T T insert points begin points end std list Vertex handle vertices T incident vertices T infinite vertex std back inserter vertices std cout This convex hull of the 25 points has vertices size points on it std endl remove 25 of the input points std list Vertex handle iterator v set it vertices begin for int i i 25 i T remove v set it v set it vertices clear T incident vertices T infinite vertex std back inserter vertices std cout After removal of 25 points there are vertices size points on the convex hull std endl return Next chapter 3D Convex Hulls Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Convex_hull_3/Chapter_main.html", "title": "3d convex hulls", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Convex_hull_3/main.tex' -->\n<html> <head>  \n<title>3D Convex Hulls</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_3\"></a>\n  \n<h1>Chapter 3<BR>3D Convex Hulls</h1>\n\n<A NAME=\"chap:convex_hull_3\"></A>\n\n<EM>Susan Hert  and Stefan Schirra</EM><BR>\n\n\n<P>\n\n<A NAME=\"Index_anchor_538\"></A> \n\n<a name=\"Section_1\"></a>\n        \n<h2>3.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nA subset <MATH><I>S  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_subseteq.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> is convex if for any two points <MATH><I>p</I></MATH> and <MATH><I>q</I></MATH>\nin the set the line segment with endpoints <MATH><I>p</I></MATH> and <MATH><I>q</I></MATH> is contained\nin <MATH><I>S</I></MATH>. The convex hull of a set <MATH><I>S</I></MATH> \nis the smallest convex set containing\n<MATH><I>S</I></MATH>. The convex hull of a set of points <MATH><I>P  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> is a convex \npolytope with vertices in <MATH><I>P</I></MATH>. A point in <MATH><I>P</I></MATH> is an extreme point \n(with respect to <MATH><I>P</I></MATH>) if it is a vertex of \nthe convex hull of <MATH><I>P</I></MATH>.  A set of points is said to be strongly convex  \n     \n<A NAME=\"Index_anchor_539\"></A> \n \n   \n if it consists of only extreme points.\n<P>\n\nThis chapter describes the functions provided in\nC<SMALL>GAL</SMALL> for producing convex hulls in three dimensions as well as\nfunctions for checking if sets of points are strongly convex are not.  \nOne can compute the convex hull of a set of points in three dimensions\nin one of three ways in C<SMALL>GAL</SMALL>: using a static algorithm,\nusing an incremental construction algorithm, or using a\ntriangulation to get a fully dynamic computation.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>3.2&nbsp;&nbsp;&nbsp;Static Convex Hull Construction</h2>\n\n<A NAME=\"sec:convex_hull_3\"></A>\n<P>\n\n<A NAME=\"Index_anchor_540\"></A> \n\n   \n\n   \n     \n     \n<A NAME=\"Index_anchor_541\"></A>\n<P>\n\nThe function \n<I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_630\">convex_hull_3</A></I>\n<A NAME=\"Index_anchor_542\"></A> \n provides an \nimplementation of the quickhull algorithm [<A HREF=\"../biblio.html#Biblio_bdh-qach-96\">BDH96</A>] for three \ndimensions \n     \n<A NAME=\"Index_anchor_543\"></A> \n \n   \n.  There are two versions of this\nfunction available, one that can be used when it is known that the output\nwill be a polyhedron (<I>i.e.</I>, there are more than three points and\nthey are not all <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A>) and one that handles all degenerate cases\nand returns a <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A></I>, which may be a point, a segment, a\ntriangle, or a polyhedron.  Both versions accept a range of input\niterators defining the set of points whose convex hull is to be computed\nand a traits class defining the geometric types and predicates used in\ncomputing the hull.\n<P>\n\n<h3>3.2.1&nbsp;&nbsp;&nbsp;Traits Class</h3>\n<P>\n\nThe function <I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_630\">convex_hull_3</A></I> is parameterized by a traits class,\nwhich specifies the types and geometric primitives to be used in the\ncomputation.  The default for this traits class is\n<I><A HREF=\"../Convex_hull_3_ref/Class_Convex_hull_traits_3.html#Cross_link_anchor_639\">Convex_hull_traits_3</A></I>\n<A NAME=\"Index_anchor_544\"></A> \n.\n<P>\n\n<h3>3.2.2&nbsp;&nbsp;&nbsp;Convexity Checking</h3>\n<P>\n\nThe function <I><A HREF=\"../Convex_hull_3_ref/Function_is_strongly_convex_3.html#Cross_link_anchor_641\">is_strongly_convex_3</A></I>\n<A NAME=\"Index_anchor_545\"></A> \n\nimplements the algorithm of Mehlhorn <I>et al.</I> [<A HREF=\"../biblio.html#Biblio_mnssssu-cgpvg-96\">MNS<MATH><I><SUP>+</SUP></I></MATH>96</A>] \nto determine if the vertices of a given polytope constitute a strongly convex \npoint set or not.  This function is used in postcondition testing for\n<I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_630\">convex_hull_3</A></I>\n   \n     \n     \n<A NAME=\"Index_anchor_546\"></A> \n\n   \n.\n<P>\n\n<h3>3.2.3&nbsp;&nbsp;&nbsp;Example</h3>\n\nThe following program computes the convex hull of a set of 250 random\npoints chosen from a sphere of radius 100.  It then determines if the \nresulting hull is a segment or a polyhedron.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Convex_hull_3/ch_quickhull_3_ex.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Convex_hull_3_ref/Class_Convex_hull_traits_3.html#Cross_link_anchor_639\">Convex_hull_traits_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_630\">convex_hull_3</A>.h&gt;\n#include &lt;vector&gt;\n\n#ifdef CGAL_USE_GMP\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\n#else\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A> RT;\n#endif\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt;                     K;\ntypedef <A HREF=\"../Convex_hull_3_ref/Class_Convex_hull_traits_3.html#Cross_link_anchor_638\">CGAL::Convex_hull_traits_3</A>&lt;K&gt;             Traits;\ntypedef Traits::<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>                      <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Segment_3.html#Cross_link_anchor_78\">Segment_3</A>                              <A HREF=\"../Kernel_23_ref/Class_Segment_3.html#Cross_link_anchor_78\">Segment_3</A>;\n\n// define point creator \ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>                                <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_3.html#Cross_link_anchor_1567\">CGAL::Creator_uniform_3</A>&lt;double, <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;  PointCreator;\n\n\nint main()\n{\n  <A HREF=\"../Generator_ref/Class_Random_points_in_sphere_3.html#Cross_link_anchor_1697\">CGAL::Random_points_in_sphere_3</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>, PointCreator&gt; gen(100.0);\n\n  // generate 250 points randomly on a sphere of radius 100.0 \n  // and copy them to a vector \n  std::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt; points;\n  <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( gen, 250, std::back_inserter(points) );\n  \n  // define object to hold convex hull \n  <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A> ch_object;\n\n  // compute convex hull \n  <A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_629\">CGAL::convex_hull_3</A>(points.begin(), points.end(), ch_object);\n\n  // determine what kind of object it is\n  <A HREF=\"../Kernel_23_ref/Class_Segment_3.html#Cross_link_anchor_78\">Segment_3</A> segment;\n  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A> polyhedron;\n  if ( <A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(segment, ch_object) )\n     std::cout &lt;&lt; &quot;convex hull is a segment &quot; &lt;&lt; std::endl;\n  else if ( <A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A> (polyhedron, ch_object) )\n     std::cout &lt;&lt; &quot;convex hull is a polyhedron &quot; &lt;&lt; std::endl;\n  else\n     std::cout &lt;&lt; &quot;convex hull error!&quot; &lt;&lt; std::endl;\n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>3.3&nbsp;&nbsp;&nbsp;Incremental  Convex Hull Construction</h2>\n\n   \n     \n     \n<A NAME=\"Index_anchor_547\"></A>\n<P>\n\nThe function <I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_incremental_3.html#Cross_link_anchor_632\">convex_hull_incremental_3</A></I> \n<A NAME=\"Index_anchor_548\"></A> \n provides an\ninterface similar to <I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_630\">convex_hull_3</A></I> for the <MATH><I>d</I></MATH>-dimensional \nincremental construction algorithm [<A HREF=\"../biblio.html#Biblio_cms-frric-93\">CMS93</A>].  \nimplemented by the class <I><A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d.html#Cross_link_anchor_644\">CGAL::Convex_hull_d</A>&lt;R&gt;</I> that is specialized \nto three dimensions. This function accepts an iterator range over a set of\ninput points and returns a polyhedron, but it does not have a traits class\nin its interface.  It uses the kernel\nclass <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A></I> used in the polyhedron type to define an instance of the \nadapter traits class <I><A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d_traits_3.html#Cross_link_anchor_646\">CGAL::Convex_hull_d_traits_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I>.\n<P>\n\nIn most cases, the function <I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_3.html#Cross_link_anchor_630\">convex_hull_3</A></I> will be faster than\n<I><A HREF=\"../Convex_hull_3_ref/Function_convex_hull_incremental_3.html#Cross_link_anchor_632\">convex_hull_incremental_3</A></I>.  The latter is provided mainly \nfor comparison purposes.\n<P>\n\nTo use the full functionality available with the <MATH><I>d</I></MATH>-dimensional class \n<I><A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d.html#Cross_link_anchor_644\">CGAL::Convex_hull_d</A>&lt;R&gt;</I> in three dimensions (<I>e.g.</I>, the ability\nto insert new points and to query if a point lies in the convex hull or not), \nyou can instantiate the class <I><A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d.html#Cross_link_anchor_644\">CGAL::Convex_hull_d</A>&lt;K&gt;</I> with the adapter\ntraits class <I><A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d_traits_3.html#Cross_link_anchor_646\">CGAL::Convex_hull_d_traits_3</A>&lt;K&gt;</I>, as shown in the following\nexample.\n<P>\n\n<h3>3.3.1&nbsp;&nbsp;&nbsp;Example</h3>\n<P>\n\n<pre class=\"ExampleCode\">// Copyright (c) 2002  <A HREF=\"../NumberTypeSupport_ref/FunctionObjectClass_Max.html#Cross_link_anchor_1396\">Max</A> Planck Institut fuer Informatik (Germany).\n// All rights reserved.\n//\n// This file is part of CGAL (www.cgal.org); you may redistribute it under\n// the terms of the Q Public License version 1.0.\n// See the file LICENSE.QPL distributed with CGAL.\n//\n// Licensees holding a valid commercial license may use this file in\n// accordance with the commercial license agreement provided with the software.\n//\n// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE\n// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n//\n// $Source: /CVSROOT/CGAL/Packages/Convex_hull_3/demo/Convex_hull_3/incremental_hull_3_demo.C,v $\n// $Revision: 1.9.4.1 $ $Date: 2004/12/19 14:58:02 $\n// $Name:  $\n//\n// Author(s)     : Susan Hert\n// \n\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d.html#Cross_link_anchor_645\">Convex_hull_d</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d_traits_3.html#Cross_link_anchor_647\">Convex_hull_d_traits_3</A>.h&gt;\n#include &lt;CGAL/Convex_hull_d_to_polyhedron_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Geomview_ref/Class_Geomview_stream.html#Cross_link_anchor_1760\">Geomview_stream</A>.h&gt;\n#include &lt;CGAL/IO/Polyhedron_geomview_ostream.h&gt;\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\n#ifdef CGAL_USE_GEOMVIEW\n\n#ifdef CGAL_USE_LEDA\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A>.h&gt;\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A> RT;\n#else\n#ifdef CGAL_USE_GMP\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A> RT;\n#else\n// NOTE: the choice of double here for a number type may cause problems\n//       for degenerate point sets\n#include &lt;CGAL/double.h&gt;\ntypedef double RT;\n#endif\n#endif\n\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt;                  K;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>                             <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt; K&gt;                 <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>;\n\ntypedef <A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d_traits_3.html#Cross_link_anchor_646\">CGAL::Convex_hull_d_traits_3</A>&lt;K&gt;        Hull_traits_3;\ntypedef <A HREF=\"../Convex_hull_d_ref/Class_Convex_hull_d.html#Cross_link_anchor_644\">CGAL::Convex_hull_d</A>&lt; Hull_traits_3 &gt;   Convex_hull_3;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_3.html#Cross_link_anchor_1567\">CGAL::Creator_uniform_3</A>&lt;double, <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;   Creator;\n\nint main ()\n{\n  Convex_hull_3 CH(3);  // create instance of the class with dimension == 3\n\n  // generate 250 points randomly on a sphere of radius 100 \n  // and insert them into the convex hull\n  <A HREF=\"../Generator_ref/Class_Random_points_in_sphere_3.html#Cross_link_anchor_1697\">CGAL::Random_points_in_sphere_3</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>, Creator&gt; gen(100);\n\n  for (int i = 0; i &lt; 250 ; i++, ++gen)\n     CH.insert(*gen);\n\n  assert(CH.is_valid());\n\n  // define polyhedron to hold convex hull and create it\n  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A> P; \n  CGAL::convex_hull_d_to_polyhedron_3(CH,P);\n\n  // display polyhedron in a geomview window\n  <A HREF=\"../Geomview_ref/Class_Geomview_stream.html#Cross_link_anchor_1759\">CGAL::Geomview_stream</A> geomview;\n  geomview &lt;&lt; CGAL::RED;\n  geomview &lt;&lt; P;\n\n  std::cout &lt;&lt; &quot;Press any key to end the program: &quot;;\n  std::cout.flush();\n  char ch;\n  std::cin.get(ch);\n\n  return 0;\n}\n\n#else\n\nint main() {\n  std::cerr &lt;&lt;\n  &quot;This demo requires geomview, which is not present on this platform\\n&quot;;\n  return 0;\n}\n\n#endif\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>3.4&nbsp;&nbsp;&nbsp;Dynamic  Convex Hull Construction</h2>\n\n   \n     \n     \n<A NAME=\"Index_anchor_549\"></A>\n<P>\n\nFully dynamic maintenance of a convex hull can be achieved by using the\nclass <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A></I>.  This class supports insertion\nand removal of points (<I>i.e.</I>, vertices of the triangulation) and the \nconvex hull edges are simply the finite edges of infinite faces.  \nThe following example illustrates the dynamic construction of a convex hull.\nFirst, random points from a sphere of a certain radius are generated and are\ninserted into a triangulation.  Then the number of points of the convex hull \nare obtained by counting the number of triangulation vertices incident to the \ninfinite vertex.  Some of the points are removed and then the number of points \nremaining on the hull are determined.  Notice that the vertices incident to the\ninfinite vertex of the triangulation are on the convex hull but it may be that\nnot all of them are vertices of the hull.\n<P>\n\n<h3>3.4.1&nbsp;&nbsp;&nbsp;Example</h3>\n\n<pre class=\"ExampleCode\">// file: examples/Convex_hull_3/dynamic_hull_3_ex.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_12\">Filtered_kernel</A>.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n\n#include &lt;list&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; SK;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_11\">CGAL::Filtered_kernel</A>&lt;SK&gt; FK;\nstruct K : public FK {};\n\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>                                  <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K&gt;           Delaunay;\ntypedef Delaunay::Vertex_handle                     Vertex_handle;\n\nint main()\n{\n  <A HREF=\"../Generator_ref/Class_Random_points_in_sphere_3.html#Cross_link_anchor_1697\">CGAL::Random_points_in_sphere_3</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt; gen(100.0);\n  std::list&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;   points;\n\n  // generate 250 points randomly on a sphere of radius 100.0 \n  // and insert them into the triangulation\n  <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>(gen, 250, std::back_inserter(points) );\n  Delaunay T;\n  T.insert(points.begin(), points.end());\n\n  std::list&lt;Vertex_handle&gt;  vertices;\n  T.incident_vertices(T.infinite_vertex(), std::back_inserter(vertices));\n  std::cout &lt;&lt; &quot;This convex hull of the 250 points has &quot; \n            &lt;&lt; vertices.size() &lt;&lt; &quot; points on it.&quot; &lt;&lt; std::endl;\n\n  // remove 25 of the input points \n  std::list&lt;Vertex_handle&gt;::iterator v_set_it = vertices.begin();\n  for (int i = 0; i &lt; 25; i++)\n  {\n     T.remove(*v_set_it);\n     v_set_it++;\n  }\n\n  vertices.clear();\n  T.incident_vertices(T.infinite_vertex(), std::back_inserter(vertices));\n  std::cout &lt;&lt; &quot;After removal of 25 points, there are &quot;\n            &lt;&lt; vertices.size() &lt;&lt; &quot; points on the convex hull.&quot; &lt;&lt; std::endl;\n  return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Convex_hull_3_ref/Chapter_intro.html\">3D Convex Hulls</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_3!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38371.0}