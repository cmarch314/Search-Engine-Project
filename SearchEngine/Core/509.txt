{"text": "HW1 Demosaicing Due Oct 9 in EEE DropBox at 11 59 pm In this assignment thouroughly prepared by David Martin you ll implement many of the processing steps that digital cameras perform to transform raw sensor measurements into nice looking images These steps are Demosaicing White Balancing Gamma Correction Histogram Clipping The following directory contains raw images from a Canon 2 D camera CR2 as well as corresponding JPEG images from the camera JPG The raw images CR2 have been converted to 16 bit PGM images pgm using a David Coffin s dcraw program freely available online PGM images can be read into matlab that you can easily load into matlab using imread a useful conversion utility is David Coggin s dcraw program downloads News The deadline is postponed until October 9 Additionally I put together a project template in the download section Unzipping it will produce a template directory containing skeleton matlab code a html writeup and the input images Run hw1 run m from Matlab to get started Programming 25 points Write the following 4 functions each in their own file with the following prototypes to perform each of the processing steps such that the following code should do something sensible I im2single imread IMG 13 8 pgm I demosaic I 1 pts wp getWhitePoint I Not graded I whiteBalance I wp 5 pts I clipHistogram I 5 pts I gammaCorrect I 5 pts figure 1 clf imshow I function J demosaic I demosaic demosaic a Bayer RG GB image to an RGB image I RG GB mosaic image J RGB image Bayer RGGB mosaic Source 1 points Demosaicing The raw image has just one value per pixel The sensor is covered with a filter array that modifies the sensitivity curve of each pixel There are three types of filters red green and blue arranged in the following pattern repeated from the top left corner R G G B Your job is to compute the missing color values at each pixel to produce a full RGB image 3 values per pixel For example for each green pixel you need to compute blue and red values Do this by interpolating values from adjacent pixels Try not to write any loops for this computation use the imfilter function instead function I whiteBalance I wp whiteBalance white balance an image I RGB image wp RGB white point vector 5 points White Balancing A pixel with all 3 RGB components equal has no color meaning it is white gray or black A white object in a raw image however will not have equal RGB values since the RGB sensors do not have equal sensitivities To white balance an image you need to find the measured RGB values of some white object in the image Consider using getpts to get the coordinates of a mouse click on a figure window These values give you the relative sensitivities of the RGB sensors dividing each channel by these values will normalize the channels so that they have equal perceptual units function I clipHistogram I fa fb clipHistogram clip image histogram I RGB image fa fb lower and upper clip fraction in 1 The image values are re normalized to span 1 For example I clipHistogram I 1 1 clips the bottom 1 and top 1 of the pixel values 5 points Histogram Clipping You ll notice that the image looks washed out This is because most of the pixel values fall well inside the allowed range of 1 The histogram of pixel values makes this clear x linspace 1 1 h hist I x figure plot x h title pixel value histogram xlabel pixel value ylabel pixel count The minimum and maximum display values are arbitrary We can move them to focus on the values that are present in the image Given a new range a b where a b 1 we can set all values a to a all values b to b and rescale the pixel values so they fill the range 1 We don t want to lose too much information however so for example we may set a and b to exclude only the top 1 of values each function I gammaCorrect I gamma gammaCorrect gamma correct the luminance of an RGB image I RGB image gamma exponent for gamma correction gamma 1 5 points Gamma Correction The camera sensor implements some mapping from pixel flux to pixel value For the raw images I m providing you this function happens to be linear This is convenient from an analysis point of view but computer displays are built assuming that the mapping from pixel value to brightness is nonlinear because our visual perception is senstive to brightness on a log scale rather than a linear scale To reproduce the image faithfully on a computer screen you need to apply gamma correction to the pixel brightness values The trick is to modify the brightness of the pixels without changing their perceived color Compute the brightness grayscale image using rgb2gray Compute the ratios of red green and blue to brightness We want to keep these ratios the same since that is what produces the perception of color These color ratios are called chromaticity Gamma correct the brightness image Reconstruct the RGB channels from the original ratios and the new brightness Matlab Tips Put each function in its own file using the same name for the file and the function Document the function with a 1 line summary and document each input and output argument Convert your images to floating point immediately after reading them from a file using im2single or im2double Use imshow to view a grayscale or RGB image If you are viewing data then always use imagesc When using imagesc always show the colorbar and use a sensible colormap You can change the colormap with the colormap command The gray jet and hsv colormaps are the most useful Use imwrite to write an image to a file If you want to create an image of a figure window either use a screen capture utility or use the print command Strings use single quotes Double quotes are not used in matlab Useful matlab functions for this assignment help I still need it after several years of using matlab figure clf close imread imwrite im2single im2double rgb2gray imshow imagesc colorbar colormap gray colormap jet imfilter imcrop getpts linspace hist cumsum isempty plot min max Writeup 15 points Use IMG 13 8 for the writeup you may use other images in addition for illustration Since the images are so large choose an interesting 5 x5 pixel sub block for illustrations Make sure your writeup includes links to full size images however Follow these guidelines for writeup submission 3 points Show the original raw image in grayscale in RGB before demosaicing and in RGB after demosaicing Without white balancing and the other things it won t look great but the colors should look ok 2 points Show the demosaiced RGB image with and without white balancing 2 points Show the image before and after histogram clipping 2 points Show the image before and after gamma correction 3 points Show your final result alongside the camera s JPEG output What differences remain 3 points Show details of the image where demosaicing has not worked well Why does it not work well in those places What kinds of image structures pose the biggest challenges for demosaicing Extra credit As detailed in the guidelines guidelines any project handed by 11 59 pm on the previous day Oct 8 will recieve 1 4 points extra credit ", "_id": "http://www.ics.uci.edu/~dramanan/teaching/cs116_fall08/hw/Project/Demosaic/", "title": "hw1: demosaicing", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n  <head>\n    <title>HW1: Demosaicing</title>\n  </head>\n\n  <body>\n    <h1>HW1: Demosaicing</h1>\n    <h3> Due Oct 9 in EEE DropBox at 11:59 pm </h3>\n    <hr>\n\n    In this assignment (thouroughly prepared by <a href=\"http://vision.bc.edu/~dmartin/\">David Martin</a>), you'll implement many of the processing\n    steps that digital cameras perform to transform raw sensor\n    measurements into nice looking images. These steps are:\n    \n    <ol>\n      <li> Demosaicing\n      <li> White Balancing\n      <li> Gamma Correction\n      <li> Histogram Clipping\t\n    </ol>\n\n    The following directory contains raw images from a Canon 20D camera\n    (<tt>*.CR2</tt>) as well as corresponding JPEG images from the camera\n    (<tt>*.JPG</tt>).  The raw images (<tt>*.CR2</tt>) have been converted to 16-bit PGM images (<tt>*.pgm</tt>) using a David Coffin's <tt> dcraw </tt> program (freely available online). PGM images can be read into matlab\n\n that you can easily load into matlab using <tt>imread</tt> (a useful conversion utility is David Coggin's <tt> dcraw </tt> program):\n\n    <ul>\n      <li><a href=\"downloads\">downloads</a>\n    </ul>\n \n <p>  <b> <span style='color:red;text-decoration:none;text-underline:none'>News:</span></b> The deadline is postponed until October 9. Additionally, I put together a project template in the download section. Unzipping it will produce a <tt>template</tt> directory containing skeleton matlab code, a html writeup, and the input images. Run <tt> hw1_run.m</tt> from Matlab to get started.\n </p>\n  \n    <h4>Programming [25 points]</h4>\n\n    Write the following 4 functions (each in their own file) \n    with the following prototypes to perform each of the\n    processing steps, such that the following code should do something\n    sensible:\n    \n    <blockquote><tt><pre>\nI = im2single(imread('IMG_1308.pgm'));\nI = demosaic(I);         % 10 pts\nwp = getWhitePoint(I);   % Not graded\nI = whiteBalance(I,wp);  % 5 pts\nI = clipHistogram(I);    % 5 pts\nI = gammaCorrect(I);     % 5 pts\nfigure(1); clf; imshow(I);\n      </pre></tt></blockquote>\n    <ol>\n      \n\t<hr>\n\t<blockquote><tt><pre>\nfunction [J] = demosaic(I)\n%demosaic - demosaic a Bayer RG/GB image to an RGB image\n%\n% I: RG/GB mosaic image\n% J: RGB image\n\t  </pre></tt></blockquote>\n\t\n\t<div style=\"float:right; padding:10px; text-align:right;\">\n\t  <img style=\"border:0px; padding:5px;\" src=\"3shotcm_figure1.jpg\"><br>\n\t  <font size=\"-1\">Bayer RGGB mosaic.</font>\n\t  <font size=\"-2\">[<a href=\"http://www.i-cubeinc.com/pdf/cameras/3shotcm.shtml\">Source</a>]</font>\n\t</div>\n\t<p><li><b>[10 points]</b> <i>Demosaicing:</i>  The raw image has\n\tjust one value per pixel.  The sensor is covered with a filter\n\tarray that modifies the sensitivity curve of each pixel.  There\n\tare three types of filters:  \"red\", \"green\", and \"blue\", arranged\n\tin the following pattern repeated from the top left corner:\n\t\n\t\n\t<blockquote><pre>\nR G . . .\nG B\n.\n.\n.\n\t  </pre></blockquote>\n\t\n\t<p>Your job is to compute the missing color values at each pixel\n\t  to produce a full RGB image (3 values per pixel).  For example,\n\t  for each \"green\" pixel, you need to compute \"blue\" and \"red\" values.\n\t  Do this by interpolating values from adjacent pixels.  Try not to\n\t  write any loops for this computation; use the <tt>imfilter</tt> \n\t  function instead.\n\n\t<hr>\n\t<blockquote><tt><pre>\nfunction [I] = whiteBalance(I,wp)\n%whiteBalance - white balance an image\n%\n%   I: RGB image\n%   wp: RGB white point vector\n</pre></tt></blockquote>\n\n\t<p><li><b>[5 points]</b> <i>White Balancing:</i>  A pixel with all 3\n\tRGB components equal has no \"color\", meaning it is white, gray,\n\tor black.  A white object in a raw image, however, will not\n\thave equal RGB values since the RGB sensors do not have\n\tequal sensitivities.  To white balance an image you need to\n\tfind the measured RGB values of some white object in the image.\n\t(Consider using <tt>getpts</tt> to get the coordinates of a mouse\n\tclick on a figure window.)\n\tThese values give you the relative sensitivities of the RGB \n\tsensors; dividing each channel by these values will normalize\n\tthe channels so that they have equal perceptual \"units\".\n\n\t<hr>\n\t<blockquote><tt><pre>\nfunction [I] = clipHistogram(I,fa,fb)\n%clipHistogram - clip image histogram\n%\n% I: RGB image\n% fa,fb: lower and upper clip fraction, in [0,1]\n%\n% The image values are re-normalized to span [0,1].\n%\n% For example, I = clipHistogram(I,0.001,0.01) clips the\n% bottom 0.1% and top 1% of the pixel values.\n\t  </pre></tt></blockquote>\n\t\n\t<p><li><b>[5 points]</b> <i>Histogram Clipping:</i>  You'll notice that\n\tthe image looks washed out.  This is because most of the pixel\n\tvalues fall well inside the allowed range of [0,1].  The histogram\n\tof pixel values makes this clear:\n\t\n\t\n\t<blockquote><tt><pre>\nx = linspace(0,1,100);\nh = hist(I(:),x); \nfigure; plot(x,h);\ntitle('pixel value histogram');\nxlabel('pixel value');\nylabel('pixel count');\n\t  </pre></tt></blockquote>\n\t\n\t<p>\n\t  The minimum and maximum display values are arbitrary: We can move them\n\t  to focus on the values that are present in the image.  Given a new\n\t  range [a,b] where 0 &lt; a &lt; b &lt; 1, we can set all values &lt; a\n\t  to a, all values &gt; b to b, and rescale the pixel values so they\n\t  fill the range [0,1].  We don't want to lose too much information,\n\t  however, so, for example, we may set a and b to exclude only the top\n\t  0.1% of values each.\n\t  \n\t<hr>\n\t\n\t<blockquote><tt><pre>\nfunction [I] = gammaCorrect(I,gamma)\n%gammaCorrect - gamma correct the luminance of an RGB image\n%\n% I: RGB image\n% gamma: exponent for gamma correction; 0 < gamma < 1\n\t  </pre></tt></blockquote>\n\t\n\t<p><li><b>[5 points]</b> <i>Gamma Correction:</i> The camera sensor implements\n\tsome mapping from pixel flux to pixel value.  For the raw images I'm\n\tproviding you, this function happens to be linear.  This is convenient\n\tfrom an analysis point of view, but computer displays are built assuming\n\tthat the mapping from pixel value to brightness is nonlinear because\n\tour visual perception is senstive to brightness on a log scale rather \n\tthan a linear scale.  To reproduce the image faithfully on a computer\n\tscreen, you need to apply <i>gamma correction</i> to the pixel\n\tbrightness values.  The trick is to modify the brightness of the\n\tpixels without changing their perceived color:\n\t\n\t<ol>\n\t    <p><li> Compute the brightness (grayscale) image using <tt>rgb2gray</tt>.\n\t    \n\t    <p><li> Compute the ratios of red, green, and blue to brightness.  We want\n\t    to keep these ratios the same, since that is what produces the perception\n\t    of color.  These color ratios are called <i>chromaticity</i>.\n\t    <p><li> Gamma correct the brightness image.\n\t    <p><li> Reconstruct the RGB channels from the original ratios and the new\n\t    brightness.\n\t</ol>\t\n    </ol>\n\n    <h4>Matlab Tips</h4>\n    \n    <ol>\n      \n\t<p><li> Put each function in its own file using the same name for the\n\tfile and the function.  Document the function with a 1-line summary,\n\tand document each input and output argument.\n\t\n\t<p><li> Convert your images to floating-point immediately after\n\treading them from a file using <tt>im2single</tt> or \n\t<tt>im2double</tt>.\n\t\n\t<p><li> Use <tt>imshow</tt> to view a grayscale or RGB <i>image</i>.  If\n\tyou are viewing <i>data</i>, then always use <tt>imagesc</tt>.  \n\t\n\t\n\t<p><li> When using <tt>imagesc</tt>, always show the colorbar\n\tand use a sensible colormap.  You can change\n\tthe colormap with the <tt>colormap</tt> command.  The <tt>gray</tt>, \n\t<tt>jet</tt>, and <tt>hsv</tt> colormaps are the most useful.\n\t\n\t<p><li> Use <tt>imwrite</tt> to write an image to a file.  If you want\n\tto create an image of a figure window, either use a screen capture\n\tutility or use the <tt>print</tt> command.\n\t\n\t\n\t<p><li> Strings use single quotes.  Double quotes are not used in matlab.\n\t\n\t<p><li> Useful matlab functions for this assignment:\n\n\t<tt>\n\t<ul>\n\t  <li> help (I still need it after several years of using matlab!)\n\t  <li> figure, clf, close\n\t  <li> imread, imwrite\n\t  <li> im2single, im2double, rgb2gray\n\t  <li> imshow, imagesc\n\t  <li> colorbar, colormap gray, colormap jet\n\t    \n\t  <li> imfilter\n\t  <li> imcrop\n\t  <li> getpts\n\t  <li> linspace, hist, cumsum, isempty\n\t  <li> plot\n\t  <li> min, max\n\t</ul>\n      </tt>\n\t\n    </ol>\n\n    <h4>Writeup [15 points]</h4>\n    \n    <p>\n      Use <tt>IMG_1308</tt> for the writeup; you may use other\n      images in addition for illustration.\n      Since the images are so large, choose an interesting\n      500x500 pixel sub-block for illustrations.  Make sure your\n      writeup includes links to full size images, however. Follow these <a href=\"../../hw_guide.html\"> guidelines</a> for writeup submission.\n      \n    <ol>\n      \n\t<p><li><b>[3 points]</b> Show the original raw image in grayscale, in\n\tRGB before demosaicing, and in RGB after demosaicing.  Without white\n\tbalancing and the other things, it won't look great but the colors\n\tshould look ok.  \n\t\n\t<p><li><b>[2 points]</b> Show the demosaiced RGB image with and \n\twithout white balancing. \n\n\t<p><li><b>[2 points]</b> Show the image before and after histogram\n\tclipping.\n\t\n\t\n\t<p><li><b>[2 points]</b> Show the image before and after gamma correction.\n\t\n\t<p><li><b>[3 points]</b> Show your final result alongside the camera's\n\tJPEG output.  What differences remain?\n\t\n\t<p><li><b>[3 points]</b> Show details of the image where demosaicing\n\thas not worked well.  Why does it not work well in those places?\n\tWhat kinds of image structures pose the biggest challenges for\n\tdemosaicing?\n\t\n    </ol>\n    <h4>Extra-credit</h4>\n    As detailed in the guidelines <a href=\"../../hw_guide.html\"> guidelines</a>, any project handed by 11:59 pm on the previous day (Oct 8), will recieve 10% (4 points) extra credit.\n  </body>\n</html>\n", "id": 509.0}