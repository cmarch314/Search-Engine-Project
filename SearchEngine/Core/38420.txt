{"text": "OEChem C Theory Manual Version 1 3 1 Previous 32 11 Parameter Aliases Shortcuts Up OEChem C Theory Next 33 1 Atoms Bond Conformers 33 Design Decisions This chapter builds upon important concepts introduced in the previous section entitled Getting Started with OEChem Molecule found in the introductory chapter as well as the chapters entitled OEMols and OEGraphMols and OEQMols and Queries in OEChem It may be beneficial to review those section before proceeding As you have seen throughout this manual the OEMol OEGraphMol and OEQMol are the concrete classes which handle most molecular function in OEChem The OEGraphMol s API is defined in the OEMolBase abstract base class the OEMol s API is defined by the OEMolBase and OEMCMolBaseT abstract base classes and the OEQMol s API is defined by the OEMolBase and OEQMolBase abstract base classes The OEMCMolBaseT class publicly inherits from the OEMolBase class which in turn inherits from the OEBase class Similarly the OEQMolBase class publicly inherits from the OEMolBase class which again inherits from the OEBase class An OEGraphMol can be passed to any function which takes an OEMolBase argument An OEMol can be passed to any function which takes an OEMCMolBaseT or OEMolBase argument and an OEQMol can be passed to any function which takes an OEQMolBase or OEMolBase argument Simplistic OEChem inheritance scheme OEBase OEMolBase OEGraphMol OEMCMolBaseT OEMol OEQMolBase OEQMol indicates inheritance indicates API correspondence without inheritance This paragraph requires some previous knowledge of the C factory and smart pointer idioms It is standard practice when working with abstract base classes such as OEMolBase or OEMCMolBaseT to define a function which returns a pointer one of these objects These functions called factories give library users access to concrete objects even when only the abstract base class is exposed in the public API The problem with factory functions is that they require the user to manage the object s memory When the factory function returns a pointer to an abstract base class it also passes ownership of the memory to the programmer To alleviate the problems associated with memory management introduced by factories the C smart pointer idiom is often used Simply put a smart pointer holds a real pointer to an object and deallocates the pointer s memory when the smart pointer goes out of scope e g in it s destructor In OEChem OEGraphMols and OEMols fulfill the function of both factories and smart pointers This gives the user access to multiple OEMolBase and OEMCMolBase implementations without the need of worrying about memory management The OEGraphMol and OEMol constructors allow the user to specify which OEMolBase or OEMCMolBaseT implementation they would like i e factory function and the OEGraphMol and OEMol objects themselves act as smart pointers cleaning up the implementation pointers when the molecules go out of scope The relationship between the OEQMolBase class and the OEQMol class is similar Subsections 33 1 Atoms Bond Conformers and Molecules 33 2 Objects and Free Functions 33 3 Programming Layers The Deep and Twisted Path OEChem C Theory Manual Version 1 3 1 Previous 32 11 Parameter Aliases Shortcuts Up OEChem C Theory Next 33 1 Atoms Bond Conformers Documentation released on July 3 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/oechem/cplusprog/node269.html", "title": "33. design decisions", "html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html>\n<head>\n<title>33. Design Decisions</title>\n<META NAME=\"description\" CONTENT=\"33. Design Decisions\">\n<META NAME=\"keywords\" CONTENT=\"cplusprog\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<link rel=\"STYLESHEET\" href=\"cplusprog.css\">\n<link rel=\"first\" href=\"cplusprog.html\">\n<link rel=\"contents\" href=\"contents.html\" title=\"Contents\">\n\n<LINK REL=\"next\" HREF=\"node273.html\">\n<LINK REL=\"previous\" HREF=\"node252.html\">\n<LINK REL=\"up\" HREF=\"cplusprog.html\">\n<LINK REL=\"next\" HREF=\"node270.html\">\n</head>\n<body>\n<DIV CLASS=\"navigation\">\n<table align=\"center\" border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n<tr>\n<td rowspan=2><A HREF=\"node268.html\"><img src=\"../icons/previous.gif\"\n  border=\"0\" alt=\"Previous Page\"></A></td>\n<td rowspan=2><A HREF=\"cplusprog.html\"><img src=\"../icons/up.gif\"\n  border=\"0\" alt=\"Up One Level\"></A></td>\n<td rowspan=2><A HREF=\"node270.html\"><img src=\"../icons/next.gif\"\n  border=\"0\" alt=\"Next Page\"></A></td><td width=\"100%\" rowspan=\"2\"> </td>\n<td valign=\"center\" align=\"right\" height=\"56\" background=\"../icons/title_bkgd.gif\" colspan=4 class=\"navigation\">OEChem - C++ Theory Manual\n<BR>\nVersion 1.3.1</td></tr>\n<tr><td><img src=\"../icons/spacer_1.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><A href=\"contents.html\"><img src=\"../icons/contents.gif\"\n  border=\"0\" alt=\"Contents\"></A></td>\n<td><img src=\"../icons/spacer_2.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><img src=\"../icons/blank_4.gif\"\n  border=\"0\" alt=\"\"></td>\n</tr></table>\n<b class=\"navlabel\">Previous:</b> <a class=\"sectref\" HREF=\"node268.html\">32.11 Parameter Aliases/Shortcuts</A>\n<b class=\"navlabel\">Up:</b> <a class=\"sectref\" HREF=\"cplusprog.html\">OEChem - C++ Theory</A>\n<b class=\"navlabel\">Next:</b> <a class=\"sectref\" HREF=\"node270.html\">33.1 Atoms, Bond, Conformers,</A>\n<br><hr>\n</DIV>\n<!--End of Navigation Panel-->\n\n<H1><A NAME=\"SECTION0036000000000000000000\">\n33. Design Decisions</A>\n</H1>\n\n<P>\nThis chapter builds upon important concepts introduced in the previous\nsection entitled <i>Getting Started with OEChem Molecule</i> found in the\nintroductory chapter as well as the chapters entitled <i>OEMols and\nOEGraphMols</i> and <i>OEQMols and Queries in OEChem</i>.  It may be beneficial to review those section before\nproceeding.\n\n<P>\nAs you have seen throughout this manual, the OEMol, OEGraphMol and OEQMol\nare the\nconcrete classes which handle most molecular function in OEChem.  The\nOEGraphMol's API is defined in the OEMolBase abstract base-class, the\nOEMol's API is defined by the OEMolBase and OEMCMolBaseT abstract base-classes,\nand the OEQMol's API is defined by the OEMolBase and OEQMolBase abstract base-\nclasses.  The\nOEMCMolBaseT class publicly inherits from the OEMolBase class, which in\nturn inherits from the OEBase class.  Similarly, the OEQMolBase class publicly\ninherits from the OEMolBase class, which again inherits from the OEBase class.\nAn OEGraphMol,  can be passed to any\nfunction which takes an OEMolBase argument.  An OEMol can be passed to any\nfunction which takes an OEMCMolBaseT or OEMolBase argument, and an OEQMol can\nbe passed to any function which takes an OEQMolBase or OEMolBase argument.\n\n<P>\n<dl><dd><pre class=\"verbatim\">Simplistic OEChem inheritance scheme:\n                OEBase\n                  |\n                  |\n             -- OEMolBase ---------------- OEGraphMol\n             |    |\n             |    |\n             |  OEMCMolBaseT ------------- OEMol\n          OEQMolBase --------------------- OEQMol\n&lt;- indicates inheritance\n-- indicates API correspondence without inheritance\n</pre></dl>\n\n<P>\nThis paragraph requires some previous knowledge of the C++ factory and\nsmart-pointer idioms.  It is standard practice when working with abstract\nbase-classes, such as OEMolBase or OEMCMolBaseT, to define a function which\nreturns a pointer one of these objects.  These functions, called factories,\ngive library users access to concrete objects even when only the abstract\nbase-class is exposed in the public API.  The problem with factory\nfunctions is that they require the user to manage the object's memory.\nWhen the factory function returns a pointer to an abstract base-class, it\nalso passes ownership of the memory to the programmer.  To alleviate the\nproblems associated with memory management introduced by factories, the C++\nsmart-pointer idiom is often used.  Simply put, a smart-pointer holds a\nreal pointer to an object, and deallocates the pointer's memory when the\nsmart-pointer goes out of scope (<I>e.g.</I> in it's destructor).  In OEChem,\nOEGraphMols and OEMols fulfill the function of both factories and\nsmart-pointers.  This gives the user access to multiple OEMolBase and\nOEMCMolBase implementations without the need of worrying about memory\nmanagement.  The OEGraphMol and OEMol constructors allow the user to specify\nwhich OEMolBase or OEMCMolBaseT implementation they would like (<I>i.e.</I> -\nfactory function), and the OEGraphMol and OEMol objects themselves act as\nsmart-pointers, cleaning up the implementation pointers when the molecules\ngo out of scope.  The relationship between the OEQMolBase class and the\nOEQMol class is similar.\n\n<P>\n\n<p><hr>\n<!--Table of Child-Links-->\n<A NAME=\"CHILD_LINKS\"><STRONG>Subsections</STRONG></a>\n\n<UL CLASS=\"ChildLinks\">\n<LI><A href=\"node270.html\">33.1 Atoms, Bond, Conformers, and Molecules</a>\n<LI><A href=\"node271.html\">33.2 Objects and Free-Functions</a>\n<LI><A href=\"node272.html\">33.3 Programming Layers:  The Deep and Twisted Path</a>\n</ul>\n<!--End of Table of Child-Links-->\n\n<DIV CLASS=\"navigation\">\n<p><hr>\n<table align=\"center\" border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n<tr>\n<td rowspan=2><A HREF=\"node268.html\"><img src=\"../icons/previous.gif\"\n  border=\"0\" alt=\"Previous Page\"></A></td>\n<td rowspan=2><A HREF=\"cplusprog.html\"><img src=\"../icons/up.gif\"\n  border=\"0\" alt=\"Up One Level\"></A></td>\n<td rowspan=2><A HREF=\"node270.html\"><img src=\"../icons/next.gif\"\n  border=\"0\" alt=\"Next Page\"></A></td><td width=\"100%\" rowspan=\"2\"> </td>\n<td valign=\"center\" align=\"right\" height=\"56\" background=\"../icons/title_bkgd.gif\" colspan=4 class=\"navigation\">OEChem - C++ Theory Manual\n<BR>\nVersion 1.3.1</td></tr>\n<tr><td><img src=\"../icons/spacer_1.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><A href=\"contents.html\"><img src=\"../icons/contents.gif\"\n  border=\"0\" alt=\"Contents\"></A></td>\n<td><img src=\"../icons/spacer_2.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><img src=\"../icons/blank_4.gif\"\n  border=\"0\" alt=\"\"></td>\n</tr></table>\n<b class=\"navlabel\">Previous:</b> <a class=\"sectref\" HREF=\"node268.html\">32.11 Parameter Aliases/Shortcuts</A>\n<b class=\"navlabel\">Up:</b> <a class=\"sectref\" HREF=\"cplusprog.html\">OEChem - C++ Theory</A>\n<b class=\"navlabel\">Next:</b> <a class=\"sectref\" HREF=\"node270.html\">33.1 Atoms, Bond, Conformers,</A>\n<hr>\n<span class=\"release-info\">Documentation released on July 30, 2004.</span>\n</DIV>\n<!--End of Navigation Panel-->\n\n</BODY>\n</HTML>\n", "id": 38420.0}