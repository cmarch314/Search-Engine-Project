{"text": "Simplification Introduction to Computer Science I III ICS 21 22 23 Introduction In this lecture we will discuss a variety of general issues in program simplification It introduces no new Java programming features but instead steps back to provide a perspective on one very important programming skill that all competent programmers must acquire Sometimes simplifying a program is the only way to comprehend it and hence debug it Finally this lecture shows that programs themselves can be studied and manipulated in a formal way just as expressions are manipulated in algebra Simplification We can use the laws of algebra to tell whether two forms are equivalent using either one produces the same result Thus equivalence is a mathematical topic But as programmers we must judge which form the simpler one to use in our programs The simplest program is the one that is easiest to read debug and maintain Thus simplicity is a psychological topic As a rule of thumb smaller forms are often easier to understand although sometimes a bit of redundancy makes forms easier to understand smtms lss s nt mr In this section we will examine three kinds of algebras for proving equivalences Boolean Algebra Relational Algebra Control Structure Algebra We will learn how to prove equivalences in each algebra and discuss how to gauge simplicity as well as show lots of examples of simplifictions Boolean Algebra Boolean Algebra concerns equivalences involving the boolean type and the logical operators The following is a list of useful laws theorems if you will of Boolean Algebra The most practical law is DeMorgan s law one form explains how to simplify the negation of a conjunction and the other form explains how to simplify the negaion of a disjunction We can easily prove laws in Boolean Algebra by trying every combination of the true and false values for each of the variables For example to prove the conjunctive version of DeMorgan s law we can start with the following table of values called a truth table Here we list all the variables in the leftmost columns and the two expressions which we hope to prove equivalent in the rightmost columns AB A B A Btruetrue truefalse falsetrue falsefalse We then fill in each column by just computing the values of the expressions using the semantics of the operators and our knowledge of evaluating expressions e g operator precedence and associativity AB A B A Btruetruefalsefalsetruefalsetruetruefalsetruetruetruefalsefalsetruetrue The law is proved if the columns under the two expressions always contain the same pair of values on each line This means that for every pair of values the expressions compute the same result so the expression are equivalent and thus interchangable in our code This approach also illustrates a divide and conquer strategy to proofs we divide the complicated proof into four different parts each a line in the truth table each line is easy to verify by pure calculation once we verify all of the lines we have verified the entire proof Relational Algebra Relational Algebra concerns equivalances mostly involving the int and double types and the numeric and relational operators It is based on the law of trichotomy The law of trichotomy Given two values the first is either less than equal to or greater than the second One and exactly one of these relationships must always hold We can use the law of trichotomy as a divide and conquer method to break one hard proof into many simpler ones Unlike using boolean values there are billions of different int values and an infinite number of integer value in the mathematics sense As a first example we will prove that Math max x y 1 is equivalent to Math max x 1 y 1 So we can factor additive constants out of calls to Math max x yMath max x y 1Math max x 1 y 1 x yy 1y 1x yx 1 or y 1x 1 or y 1x yx 1x 1 Here knowing the relationship between x and y allows us to compute the answer for each expression For example if we know that x lty we know Math max x y evaluates to y so Math max x y 1 evaluates to y 1 likewise if we know that x lty we know that x 1 lty 1 so Math max x 1 y 1 evaluates to y 1 The other two cases can be simplified similarly Again the law is proved if the columns under the two expressions always have the same pair of values on each line This means that for every pair of values the expressions compute the same result so the expressions are interchangable As another example we can prove that the expression x is equivalent to x y which is true when x and y have the same sign assuming the sign of is considered positive Here we need to list all possibilities of how x and y compare to x y x x y xytruetruexy falsefalsexy falsefalsex yfalsefalsex y truetruex y truetruex yfalsefalsex y truetruex y truetrue So again the equivalence it proven Here is an interesting case where the smaller simpler more efficient code is not necessarily easier to understand Most students believe the larger expression is easier to understand until they intensely study the meaning of when applied to boolean values generated by relational operators In actual code I would suggest using the simpler form and then include the larger easier to understand form in a comment we could even include the above proof as part of the comment Finally we can use the law of trichotomy to prove that we simplify the negation of relational operators Be careful when you do so and recall the law of trichotomy If it is not true that x is less than y then there are two possiblities left x is equal to y or x is greater than y Beginning programmers make the mistake of negating x y as x y but the correct equivalent expression is x y x y x y x yx yfalsefalsex ytruetruex ytruetrue In fact we can use the same kinds of proofs to show how to simplify the negation of every relational operator Negated FormSimplified Form only Form x y x y x y x x yy x x y x yx y y x x y x y x y y x x y x yx y x y x y x Also notice that each of the relational operators is equivalent to an expression that includes only the relational operator along with sone logical operators Although we don t need the five other relational operators to write Java programs in a mathematical sense they are provided because most programmers are aware of them and can use them to write simpler programs in a psychological sense Thus the Java language is made larger more operators to make it easier for human minds to use Such value judgements which is better a smaller language or a language easier for humans to use are required by programming language designers Finally we can often simplify negatate relational operators in DeMorgan s Laws simplifications For example we can simplify x x 1 to x x 1 which is actually a bit larger but can be further simplified to x x which is truly simpler Control Structure Algebra Now we will explore the richest algebra the algebra of control structures First we will examine when changing the order in a sequence of statements doesn t change the results of executing the sequence Second we will discuss transformations to if statements Finally we will discuss transformations to for loops containing break statements Sequence equivalences We start by examining the orderings of statements and defining two important terms A statement stores into a variable if the state of the variable can be changed by executing the statement So x y stores into x but not y A statement examines a variable if the statements needs to retrieve the value stored in that variable So x y examines y but not x Interestingly enough the expression statement x both stores into and examines x it first examines the value stored in x then computes a value one higher then stores that value back into x the equivalent expression statement x x 1 illustrates this assertion more clearly In the entire if statement if x y Examines x and y z x Stores into z examines x else y Stores into and examines y we say that it stores into z and y it examines x and y Note that we will also say System out println stores into the console because this method causes new information to appear inside the console window changing its state Armed with this terminology we can define indepdendent statements in a sequence Two statements are independent if we can exchange their order and they still always compute equivalent results Two statements S1 and S2 are independent if S1 stores into and examines no variables that S2 stores into and S2 stores into and examines no variables that S1 stores into For example we can exchange the order of x 1 System out println y because they satisfy the property above also just think about whether either statement affects the other they don t We cannot exchange the order of x 1 System out println x because the second statement examines x which the first statement stores into the value printed depends on whether x is assigned the value 1 before or after the print statement Likewise we can exchange the order of x 1 y because they satisfy the property above We cannot exchange the order of x 1 x because the second statement stores into x which the first statement also stores into Obviously changing the order of two statements doesn t simplify anything but we will learn that such exchanges can sometimes enable further real simplifications if equivalences Now onto if statements We can use a modified truth table to prove the equivalence of two if statements For the if statement below if test statement1 else statement2 we have the following modified truth table Note that although test can be an arbitrarily complicated expression ultimately its value is either true or false testCode Executedtruestatement1falsestatement2 Boolean Assignment Let s examine various pairs of statements that we can prove equivalent by using these modified truth tables The first involves storing a value into a boolean variable Assume that we have declared boolean b For the two statements if test b test b true else b false we have the following modified truth table testLeft Code ExecutedRight Code Executedtrueb true b true becaue test is true falseb false b false becaue test is false Again because both columns show the same statements executed regardless of the value of test the if else statement on the left and expression statement on the right are equivalent Test Reversal This equivalence shows that we can reverse the test AND the order of the two statements inside the if else and the resulting if statement is equivalent to the first if test if test statement1 statement2 else else statement2 statement1 we have the following modified truth table testLeft Code ExecutedRight Code Executedtruestatement1statement1 falsestatement2 statement2 Which means that the following two if else statements are equivalent I d argue that the one on the right is simpler and easier to understand because it is easier to see that it is an if else statement our eyes can see that loking just at the top three lines In the version on the left the small else clause is almost hidden at the bottom if test if test statementT1 statementF statementT2 else statementT1 statementTn statementT2 else statementF statementTn Of course we might be able to use DeMorgan s law to further simplify test too Bottom Factoring This equivalence shows that we can always remove factor a common statement out from the bottom of an if else statement It is similar to algebraically factoring AX BX into A B X if test if test statement1 statement1 statementc else else statement2 statement2 statementc statementc To prove this equivalence we use the following modified truth table testLeft Code ExecutedRight Code Executedtruestatement1 statementc statement1 statementcfalsestatement2 statementc statement2 statementc For example the code on the top is equivalent to the code on the bottom if zcc System out println zcc zcc 1 else System out println zcc zcc 1 if zcc System out println zcc else System out println zcc zcc 1 Note that there is one extra constraint on this simplification the statement factored out of a block cannot use any variables declared in that block because those variables are not in the new scope of the statement which has been moved outside of either block This constraint is typically not a problem because few local variables are declared in blocks following if and else Top Factoring This equivalence is shows that we can often remove a common statement out from the front of an if else statement It is similar to algebraically factoring XA XB into X A B if test statementc statementc if test statement1 statement1 else else statementc statement2 statement2 To prove this equivalence we use the following modified truth table testLeft Code ExecutedRight Code Executedtruestatementc statement1 statementc statement1falsestatementc statement2 statementc statement2 But there is one more detail to take care of Now we are executing statementc before the if else which means it is executed before the test expression is evaluated This is guaranteed to work only if the statement and test are independent as defined early In the example below the code on the top is NOT equivalent to the code on the bottom if zcc zcc 1 System out println zcc else zcc 1 System out println zcc zcc 1 if zcc System out println zcc else System out println zcc because the code on the bottom can never have the test zcc succeed This is because the test zcc is not independent of the statements zcc 1 it examines accesses a variable stored into by this statement On the other hand sometimes even if the expression and statement are not independent we can modify the test to account for the statement always executing before the if else statement The code on the top here is equivalent to the code on the bottom we can prove it using the law of trichotomy zcc if zcc zcc System out println zcc was else zcc System out println zcc was not zcc if zcc 1 System out println zcc was else System out println zcc was not In fact another way to simplify this code is to exchange the two statements in each block they are independent and then just bottom factor zcc yielding if zcc System out println zcc was else System out println zcc was not zcc As with bottom factoring the statement factored out of a block cannot contain any variables declared in that block if such is the case often the declaration can be top factored out of the block too for equivalences Finally let s look at three for loop equivalences else Removal This equivalence involves the removal of an unnecessary else in an if controlling a break for for statements1 statements1 if test if test break break else statements2 statements2 In both loops if test is true Java executes the break if test is false each loop executes statements2 next and then re executes the loop on the left because statements2 is in the else and on the right because the if finishes and Java executes the next statement in the loop s body After executing statements2 the bodies of both loops are finished executing so the for loop causes Java to execute them again Typically code is simpler if it isn t nested deeply Loop Factoring The second loop equivalence again involves factoring statements for for statements1 statements1 if test if test statementsa break break statements2 statements2 statementsa In both loops if test is false each executes statements2 and the bodies of both loops are executed again In the left loop if test is true it executes statementsa and then terminates the loop on the right it terminates the loop and afterward executes statementsa The order of these operations makes no difference except that any variables declared inside the block that is the block that is the body of the for statement cannot be stored in or examined outside of that block after the loop terminates Typically loop statements are the most complex to understand in terms of what they do so by removing statementsa from the body of the loop we simplify it Loop Rerolling The third loop equivalence involves moving statements repeated before and at the bottom of a loop completely inside the loop statements1 for for statements1 if test if test break break statements2 statements2 statements1 Each code fragment first executes statements1 on the left before the loop on the right as the first statement in the loop s body Then each tests for termination if the test is not true each executes statements2 followed by statements1 on the left at the bottom of the loop on the right at the top of th loop followed by testing for termination again Typically we want to avoid duplicating statements inside and outside of loops By using for if break which allows a termination test in the middle of a loop we can remove this redundancy Pragmatics The formal techniques presented and illustrated above allow us to prove that two programming forms are equivalent It is then up to us to determine which form is simpler and use it in our programs As a rule of thumb the smaller the code the simpler it is Also code with fewer nested statements is generally simpler More generally we should try to distribute complexity So when decidiing between two equivalences choose the one whose most complicated statement is simplest If you ever find yourself duplicating code there is an excellent chance that some simplification will remove this redundancy Beginners are especially prone to duplicating large chunks of code missing the important simplification We should aggressively simplify our code while we are programming We will be amply rewarded because it is easier to add more code completing the phases of the enhancements to an already simplified program If we wait until the program is finished before simplifying well we many never finish the program because it has become too complex if we do finish the context in which to perform each simplification will be much bigger and more complex making it harder to simplify Excessive complexity is one of the biggest problems that a software engineer faces Generally I try not to get distracted when I am writing code but one of the few times that I will stop writing code is when I see a simplification I know that in the long run taking time to do a simplification immediately will likely allow me to finish the program faster Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a CA or any other student Prove that the expressions x 1 and x 1 true are equivalent Prove that the expressions x 1 and x 1 false are equivalent In each case which would you judge the simpler expression Use the law of trichotomy to prove that x y Math abs x y 2 and Math min x y compute the same value In the following statements identify which variabes are stored into and which variables are examined x y x x 1 System out println x if x x if x break x y z Prove that the following two statements are equivalent Assume that we declared boolean b if test b test b false else b true The code on the left is not equivalent to the code on the right which has been top factored They are not equivalent because the if s test and the statements x are not independent Rewrite the if s test in the code on the right so that left and right are equivalent if x 1 x x if x 1 System out println x System out println x else else x y x y x Suppose we are comparing aspirin A1 A2 A3 and A4 for efficacy Suppose that the company making A1 goes on TV with the advertisement No aspirin is better than A1 Could the other companies also run ads saying the exact same thing about their products How does this question relate to the material in this lecture How does it relate to mathematical vs perceptual psychological truths in advertising As a programmer whose code is read by other people as well as the Java compiler what implications does this have for the audience for which we are writing code ", "_id": "http://www.ics.uci.edu/~pattis/ICS-21/lectures/simplification/lecture.html", "title": "simplification", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Simplification</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Simplification</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture, we will discuss a variety of general issues in program simplification.\r\n  It introduces no new Java programming features, but instead steps back to provide a perspective\r\n    on one very important programming skill that all competent programmers must acquire.\r\n  Sometimes simplifying a program is the only way to comprehend it, and hence debug it.\r\n  Finally, this lecture shows that programs themselves can be studied and manipulated in a\r\n    formal way (just as expressions are manipulated in algebra).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Simplification -->\r\n\r\n<a name=\"Simplification\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Simplification</b></td>\r\n<td width =\"80%\">\r\n  We can use the laws of algebra to tell whether two forms are equivalent: using either\r\n    one produces the same result.\r\n  Thus, equivalence is a mathematical topic.\r\n  But as programmers, we must judge which form (the simpler one) to use in our programs.\r\n  <p>\r\n  The simplest program is the one that is easiest to read, debug, and maintain.\r\n  Thus, simplicity is a psychological topic.\r\n  As a rule of thumb, smaller forms are often easier to understand (although sometimes a bit of\r\n    redundancy makes forms easier to understand: smtms lss s nt mr).\r\n  <p>\r\n  In this section we will examine three kinds of algebras for proving equivalences\r\n  <ul>\r\n    <li>Boolean Algebra\r\n    <li>Relational Algebra\r\n    <li>Control Structure Algebra\r\n  </ul>\r\n  We will learn how to prove equivalences in each algebra and discuss how to gauge simplicity, as\r\n    well as show lots of examples of simplifictions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Boolean Algebra -->\r\n\r\n<a name=\"BooleanAlgebra\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Boolean Algebra</b></td>\r\n<td width =\"80%\">\r\n  Boolean Algebra concerns equivalences involving the <b>boolean</b> type and the logical operators.\r\n  The following is a list of useful laws (theorems, if you will) of Boolean Algebra.\r\n  The most practical law is DeMorgan's law: one form explains how to simplify the negation of\r\n    a conjunction (<b>&&</b>) and the other form explains how to simplify the negaion of a\r\n    disjunction (<b>||</b>).\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/boolean.gif\"></mage>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  We can easily prove laws in Boolean Algebra by trying every combination of\r\n    the <b>true</b> and <b>false</b> values for each of the variables.\r\n  For example, to prove the conjunctive version of DeMorgan's law, we can start with the\r\n    following table of values, called a <i>truth table</i>.\r\n  Here we list all the variables in the leftmost columns, and the two\r\n    expressions -which we hope to prove equivalent- in the rightmost columns.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">A</th><th>B</th><th>!(A&&B)</th><th>!A||!B</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>true</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>true</td><td>false</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>false</td><td>true</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>false</td><td>false</td><td>&nbsp</td><td>&nbsp</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  We then fill in each column by just computing the values of the expressions\r\n    (using the semantics of the operators and our knowledge of evaluating\r\n     expressions: e.g., operator precedence and associativity).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">A</th><th>B</th><th>!(A&&B)</th><th>!A||!B</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>true</td><td>false</td><td>false</td>\r\n  <tr valign=\"top\"><td>true</td><td>false</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>false</td><td>true</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>false</td><td>false</td><td>true</td><td>true</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  The law is proved if the columns under the two expressions always contain the same pair of\r\n    values on each line.\r\n  This means that for every pair of values, the expressions compute the same result, so the\r\n    expression are equivalent and thus interchangable in our code.\r\n  <p>\r\n  This approach also illustrates a divide and conquer strategy to proofs: we divide the complicated \r\n    proof into four different parts (each a line in the truth table); each line is easy to verify by\r\n    pure calculation; once we verify all of the lines, we have verified the entire proof.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Relational Algebra -->\r\n\r\n<a name=\"RelationalAlgebra\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Relational Algebra</b></td>\r\n<td width =\"80%\">\r\n  Relational Algebra concerns equivalances mostly involving the <b>int</b> and <b>double</b> types\r\n    and the numeric and relational operators.\r\n  It is based on the law of trichotomy. \r\n    <ul>\r\n      <li><b>The law of trichotomy</b>: Given two values, the first is either less than, equal to,\r\n            or greater than the second.\r\n          One (and exactly one) of these relationships must always hold.\r\n    </ul>\r\n  We can use the law of trichotomy as a divide and conquer method to break one\r\n    hard proof into many simpler ones.\r\n  Unlike using boolean values, there are billions of different <b>int</b>\r\n   values (and an infinite number of integer value -in the mathematics sense).\r\n  <p>\r\n  As a first example, we will prove that <b>Math.max(x,y)+1</b> is equivalent to <b>Math.max(x+1,y+1)</b>.\r\n  So, we can factor additive constants out of calls to <b>Math.max</b>.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">x?y</th><th>Math.max(x,y)+1</th><th>Math.max(x+1,y+1)</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>x < y</td><td>y+1</td><td>y+1</td>\r\n  <tr valign=\"top\"><td>x = y</td><td>x+1 or y+1</td><td>x+1 or y+1</td>\r\n  <tr valign=\"top\"><td>x > y</td><td>x+1</td><td>x+1</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here, knowing the relationship between <b>x</b> and <b>y</b> allows us to compute the answer\r\n    for each expression.\r\n  For example, if we know that <b>x&lty</b>, we know <b>Math.max(x,y)</b> evaluates to <b>y</b>,\r\n    so <b>Math.max(x,y)+1</b> evaluates to <b>y+1</b>; likewise, if we know that <b>x&lty</b>, we\r\n    know that <b>x+1&lty+1</b>, so <b>Math.max(x+1,y+1)</b> evaluates to <b>y+1</b>.\r\n  The other two cases can be simplified similarly. \r\n  <p>\r\n  Again, the law is proved if the columns under the two expressions always have\r\n    the same pair of values on each line.\r\n  This means that for every pair of values, the expressions compute the same\r\n    result, so the expressions are interchangable.\r\n  <p>\r\n  As another example, we can prove that the expression <b>x<0 == y<0</b> is\r\n    equivalent to  <b>(x<0 && y<0) || (x>=0 && y>=0)</b>, which is true when\r\n    <b>x</b> and <b>y</b> have the same sign (assuming the sign of 0 is\r\n    considered positive).\r\n  Here we need to list all possibilities of how <b>x</b> and <b>y</b>\r\n    compare to <b>0</b>.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">x?0</th><th>y?0</th><th>x<0 == y<0</th><th>(x<0 && y<0) ||\r\n    (x>=0 && y>=0)</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>x<0</td><td>y<0</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>x<0</td><td>y=0</td><td>false</td><td>false</td>\r\n  <tr valign=\"top\"><td>x<0</td><td>y>0</td><td>false</td><td>false</td>\r\n  <tr valign=\"top\"><td>x=0</td><td>y<0</td><td>false</td><td>false</td>\r\n  <tr valign=\"top\"><td>x=0</td><td>y=0</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>x=0</td><td>y>0</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>x>0</td><td>y<0</td><td>false</td><td>false</td>\r\n  <tr valign=\"top\"><td>x>0</td><td>y=0</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>x>0</td><td>y>0</td><td>true</td><td>true</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  So again, the equivalence it proven.\r\n  Here is an interesting case where the smaller/simpler/more efficient code is\r\n    not necessarily easier to understand.\r\n  Most students believe the larger expression is easier to understand, until\r\n    they intensely study the meaning of <b>==</b> when applied to\r\n    <b>boolean</b> values generated by relational  operators.\r\n  <p>\r\n  In actual code, I would suggest using the simpler form, and then include\r\n    the larger -easier to understand- form in a comment; we could even include\r\n    the above proof as part of the comment.\r\n  <p>\r\n  Finally we can use the law of trichotomy to prove that we simplify the \r\n    negation of relational operators.\r\n  Be careful when you do so, and recall the law of trichotomy.\r\n  If it is not true that x is less than y, then there are two possiblities\r\n    left: x is equal to y or x is greater than y.\r\n  Beginning programmers make the mistake of negating <b>x&lt;y</b> as\r\n    <b>x&gt;y</b>, but the correct equivalent expression is <b>x&gt;=y</b>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">x?y</th><th>!(x < y)</th><th>x >= y</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>x < y</td><td>false</td><td>false</td>\r\n  <tr valign=\"top\"><td>x = y</td><td>true</td><td>true</td>\r\n  <tr valign=\"top\"><td>x > y</td><td>true</td><td>true</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  In fact, we can use the same kinds of proofs to show how to simplify the\r\n    negation of every relational operator.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Negated Form</th><th>Simplified Form</th><th> < only Form</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>!(x < y)</td><td>x >= y</td><td>!(x < y)</td>\r\n  <tr valign=\"top\"><td>!(x <= y)</td><td>x > y</td><td>y < x</td>\r\n  <tr valign=\"top\"><td>!(x == y)</td><td>x != y</td><td>x < y || y < x</td>\r\n  <tr valign=\"top\"><td>!(x != y)</td><td>x == y</td><td>!(x < y || y < x)</td>\r\n  <tr valign=\"top\"><td>!(x >= y)</td><td>x < y</td><td>x < y</td>\r\n  <tr valign=\"top\"><td>!(x > y)</td><td>x <= y</td><td>!(y < x)</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Also notice that each of the relational operators is equivalent to an\r\n    expression that includes only the <b>&lt</b> relational operator (along\r\n    with sone logical operators).\r\n  Although we don't need the five other relational operators to write Java\r\n     programs (in a mathematical sense), they are provided because most\r\n     programmers are aware of them and can use them to write simpler programs\r\n     (in a psychological sense).\r\n  Thus the Java language is made larger (more operators) to make it easier for\r\n    human minds to use.\r\n  Such value judgements (which is better, a smaller language or a language\r\n    easier for humans to use) are required by programming language designers.\r\n  <p>\r\n  Finally, we can often simplify negatate relational operators in DeMorgan's Laws simplifications.\r\n  For example, we can \"simplify\" <b>!(x < 0 || x > 10)</b> to\r\n     <b>!(x < 0) && !(x > 10)</b> which is actually a bit larger, but can be further simplified to\r\n     <b>x >= 0 && x <= 10</b> which is truly simpler.  \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Control Structure Algebra -->\r\n\r\n<a name=\"ControlStructureAlgebra\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Control Structure Algebra</b></td>\r\n<td width =\"80%\">\r\n  Now we will explore the richest algebra: the algebra of control structures.\r\n  First we will examine when changing the order in a sequence of statements\r\n    doesn't change the results of executing the sequence.\r\n  Second we will discuss transformations to <b>if</b> statements.\r\n  Finally, we will discuss transformations to <b>for</b> loops containing <b>break</b>\r\n    statements.\r\n\r\n  <a name=\"sequence\">\r\n  <h3>Sequence equivalences</h3>\r\n  We start by examining the orderings of statements and defining two important terms.\r\n  <ul>\r\n    <li>A statement <i>stores into</i> a variable if the state of the variable can be changed\r\n          by executing the statement.\r\n        So, <b>x = y;</b> stores into <b>x</b> (but not <b>y</b>).\r\n    <li>A statement <i>examines</i> a variable if the statements needs to retrieve the value\r\n          stored in that variable.\r\n        So, <b>x = y;</b> examines <b>y</b> (but not <b>x</b>).\r\n  </ul>\r\n  Interestingly enough, the expression statement <b>x++;</b> both stores into and examines <b>x</b>:\r\n    it first examines the value stored in <b>x</b>, then computes a value one higher, then stores\r\n    that value back into <b>x</b> (the equivalent expression statement <b>x = x+1;</b> illustrates\r\n    this assertion more clearly).\r\n  In the entire <b>if</b> statement <b><pre>\r\n  if (x > y)            //Examines x and y\r\n    z = x;              //Stores into z; examines x\r\n  else\r\n    y++;                //Stores into and examines y</pre></b>\r\n  we say that it stores into <b>z</b> and <b>y</b>; it examines <b>x</b> and <b>y</b>.\r\n  Note that we will also say <b>System.out.println(\"...\");</b> stores into the console because this\r\n    method causes new information to appear inside the console window (changing its state).\r\n  <p>\r\n  Armed with this terminology, we can define <i>indepdendent</i> statements in a sequence.\r\n  Two statements are independent if we can exchange their order and they still always compute \r\n    equivalent results.\r\n  Two statements <b>S<sub>1</sub></b> and <b>S<sub>2</sub></b> are independent if\r\n    <b>S<sub>1</sub></b> stores into and examines no variables that <b>S<sub>2</sub></b> stores into, and\r\n    <b>S<sub>2</sub></b> stores into and examines no variables that <b>S<sub>1</sub></b> stores into.\r\n  <p>\r\n  For example, we can exchange the order of <b> x = 1; System.out.println(y);</b> because they\r\n    satisfy the property above (also, just think about whether either statement affects the other:\r\n    they don't).\r\n  We cannot exchange the order of <b> x = 1; System.out.println(x);</b> because the second statement examines\r\n    <b>x</b>, which the first statement stores into (the value printed depends on whether <b>x</b> is\r\n    assigned the value 1 before or after the print statement).\r\n  Likewise, we can exchange the order of <b> x = 1; y = 0;</b> because they satisfy the\r\n    property above.\r\n  We cannot exchange the order of <b> x = 1; x++;</b> because the second statement stores into\r\n    <b>x</b>, which the first statement also stores into.\r\n  <p>\r\n  Obviously, changing the order of two statements doesn't simplify anything; but we will learn that\r\n    such exchanges can sometimes enable further \"real\" simplifications.\r\n  <p>\r\n\r\n\r\n  <a name=\"if\">\r\n  <h3>if equivalences</h3>\r\n  Now, onto <b>if</b> statements.\r\n  We can use a modified truth table to prove the equivalence of two <b>if</b> statements.\r\n  For the <b>if</b> statement below\r\n  <b><pre>  if (test)\r\n    statement<sub>1</sub>\r\n  else\r\n    statement<sub>2</sub>  </pre></b>\r\n  we have the following modified truth table. \r\n  Note that although <b>test</b> can be an arbitrarily complicated expression, ultimately its\r\n    value is either <b>true</b> or <b>false</b>.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">test</th><th>Code Executed</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>statement<sub>1</sub></td>\r\n  <tr valign=\"top\"><td>false</td><td>statement<sub>2</sub></td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  <b>Boolean Assignment</b>:\r\n  Let's examine various pairs of statements that we can prove equivalent by using these\r\n    modified truth tables.\r\n  The first involves storing a value into a <b>boolean</b> variable.\r\n  Assume that we have declared <b>boolean b;</b>\r\n  For the two statements <b><pre>  if (test)                  b = test;\r\n    b = true;\r\n  else\r\n    b = false;</pre></b>\r\n  we have the following modified truth table. \r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>b = true;</td><td>b = true; (becaue <b>test</b> is <b>true</b>)</td>\r\n  <tr valign=\"top\"><td>false</td><td>b = false;</td><td>b = false; (becaue <b>test</b> is <b>false</b>)</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Again, because both columns show the same statements executed, regardless of\r\n    the value of <b>test</b>, the <b>if/else</b> statement on the left and\r\n    expression statement on the right are equivalent.\r\n  <p>\r\n  <b>Test Reversal</b>:\r\n  This equivalence shows that we can reverse the <b>test</b> AND the order of the two\r\n    statements inside the <b>if/else</b> and the resulting <b>if</b> statement is equivalent to the first.\r\n  <b><pre>  if (test)          if (!test)\r\n    statement<sub>1</sub>         statement<sub>2</sub>\r\n  else               else\r\n    statement<sub>2</sub>         statement<sub>1</sub></pre></b>\r\n  we have the following modified truth table. \r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>statement<sub>1</sub></td><td>statement<sub>1</sub> </td>\r\n  <tr valign=\"top\"><td>false</td><td>statement<sub>2</sub> </td><td>statement<sub>2</sub> </td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Which means that the following two <b>if/else</b> statements are equivalent.\r\n  I'd argue that the one on the right is simpler and easier to understand,\r\n    because it is easier to see that it is an <b>if/else</b> statement: our\r\n    eyes can see that loking just at the top three lines.\r\n  In the version on the left, the small <b>else</b> clause is almost hidden\r\n    at the bottom.\r\n  <b><pre>\r\n  if (test) {          if (!test)\r\n    statement<sub>T1</sub>          statement<sub>F</sub>\r\n    statement<sub>T2</sub>        else {\r\n    ...<sub>&nbsp</sub>                 statement<sub>T1</sub>\r\n    statement<sub>Tn</sub>          statement<sub>T2</sub>\r\n  } else                 ...\r\n    statement<sub>F</sub>           statement<sub>Tn</sub>\r\n                       }</pre></b>\r\n  Of course, we might be able to use DeMorgan's law to further simplify <b>!test</b> too.\r\n  <p>\r\n  <b>Bottom Factoring</b>:\r\n  This equivalence shows that we can <i>always</i> remove (factor) a common statement out from the bottom \r\n    of an <b>if/else</b> statement.\r\n  It is similar to algebraically factoring <b>AX+BX</b> into <b>(A+B)X</b>.\r\n  <b><pre>\r\n  if (test) {          if (test)\r\n    statement<sub>1</sub>          statement<sub>1</sub>\r\n    statement<sub>c</sub>        else\r\n  }else{                statement<sub>2</sub>\r\n    statement<sub>2</sub>        statement<sub>c</sub>\r\n    statement<sub>c</sub>\r\n  }</pre></b>\r\n  To prove this equivalence we use the following modified truth table. \r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>statement<sub>1</sub>; statement<sub>c</sub>\r\n                   </td><td>statement<sub>1</sub>; statement<sub>c</sub></td>\r\n  <tr valign=\"top\"><td>false</td><td>statement<sub>2</sub>; statement<sub>c</sub>\r\n                   </td><td>statement<sub>2</sub>; statement<sub>c</sub></td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  For example, the code on the top is equivalent to the code on the bottom.\r\n  <b><pre>  if (zcc == 0) {\r\n    System.out.println(\"zcc = 0\");\r\n    zcc = 1;\r\n  }else{\r\n    System.out.println(\"zcc != 0\");\r\n    zcc = 1;\r\n  }\r\n\r\n  if (zcc == 0)\r\n    System.out.println(\"zcc = 0\");\r\n  else\r\n    System.out.println(\"zcc != 0\");\r\n  zcc = 1;</pre></b>\r\n  Note that there is one extra constraint on this simplification: the\r\n    statement factored out of a block cannot use any variables declared in \r\n    that block, because those variables are not in the new scope of the\r\n    statement, which has been moved outside of either block.\r\n  This constraint is typically not a problem, because few local variables are\r\n    declared in blocks following <b>if</b> and <b>else</b>.\r\n  <p>\r\n\r\n  <b>Top Factoring</b>:\r\n  This equivalence is shows that we can <i>often</i> remove a common statement \r\n    out from the front of an <b>if/else</b> statement.\r\n  It is similar to algebraically factoring <b>XA+XB</b> into <b>X(A+B)</b>.\r\n  <b><pre>\r\n  if (test) {          statement<sub>c</sub>\r\n    statement<sub>c</sub>         if (test)\r\n    statement<sub>1</sub>           statement<sub>1</sub>\r\n  }else{               else\r\n    statement<sub>c</sub>          statement<sub>2</sub>\r\n    statement<sub>2</sub>\r\n  }</pre></b>\r\n  To prove this equivalence we use the following modified truth table. \r\n   <p>\r\n <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>true</td><td>statement<sub>c</sub>; statement<sub>1</sub>\r\n                   </td><td>statement<sub>c</sub>; statement<sub>1</sub></td>\r\n  <tr valign=\"top\"><td>false</td><td>statement<sub>c</sub>; statement<sub>2</sub>\r\n                   </td><td>statement<sub>c</sub>; statement<sub>2</sub></td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  But there is one more detail to take care of.\r\n  Now we are executing <b>statement<sub>c</sub></b> before the <b>if/else</b>, which means\r\n    it is executed before the <b>test</b> expression is evaluated. \r\n  This is guaranteed to work only if the statement and test are independent (as defined early).\r\n  In the example below, the code on the top is NOT equivalent to the code on the bottom.\r\n  <b><pre>  if (zcc == 0) {\r\n    zcc = 1;\r\n    System.out.println(\"zcc = 0\");\r\n  }else{\r\n    zcc = 1;\r\n    System.out.println(\"zcc != 0\");\r\n  }\r\n\r\n\r\n  zcc = 1;\r\n  if (zcc == 0)\r\n    System.out.println(\"zcc = 0\");\r\n  else\r\n    System.out.println(\"zcc != 0\");</pre></b>\r\n  because the code on the bottom can never have the test <b>zcc == 0</b> succeed.\r\n  This is because the <b>test</b> (<b>zcc == 0</b>) is not independent of the statements\r\n     <b>zcc = 1;</b>: it examines (accesses) a variable stored into by this statement.\r\n  <p>\r\n  On the other hand, sometimes even if the expression and statement are not independent, we can \r\n    modify the test to account for the statement always executing before the <b>if/else</b> statement.\r\n  The code on the top here is equivalent to the code on the bottom (we can prove it using the\r\n    law of trichotomy: <b>zcc ? 0</b>).\r\n  <b><pre>  if (zcc == 0) {\r\n    zcc++;\r\n    System.out.println(\"zcc was == 0\");\r\n  }else{\r\n    zcc++;\r\n    System.out.println(\"zcc was not == 0\");\r\n  }\r\n\r\n\r\n  zcc++;\r\n  if (zcc == 1)\r\n    System.out.println(\"zcc was == 0\");\r\n  else\r\n    System.out.println(\"zcc was not == 0\");</pre></b>\r\n  In fact, another way to simplify this code is to exchange the two statements in each\r\n    block (they are independent) and then just bottom-factor <b>zcc++</b>,\r\n    yielding\r\n  <b><pre>  if (zcc == 0)\r\n    System.out.println(\"zcc was == 0\");\r\n  else\r\n    System.out.println(\"zcc was not == 0\");\r\n  zcc++;</pre></b>\r\n\r\n  <p>\r\n  As with bottom factoring, the statement factored out of a block cannot contain any variables \r\n    declared in that block (if such is the case, often the declaration can be top factored out\r\n    of the block too).\r\n  \r\n \r\n\r\n  <a name=\"for\">\r\n  <h3>for equivalences</h3>\r\n  Finally, let's look at three <b>for</b> loop equivalences.\r\n  <p>\r\n  <b>else Removal</b>:\r\n  This equivalence involves the removal of an unnecessary <b>else</b> in an\r\n    <b>if</b> controlling a <b>break</b>.\r\n  <b><pre>  for (;;) {              for (;;) {\r\n    statements<sub>1</sub>             statements<sub>1</sub>\r\n    if (test)               if (test)\r\n      break;                   break;\r\n    else {                  statements<sub>2</sub>\r\n      statements<sub>2</sub>          }\r\n    }\r\n  }</pre></b>\r\n  In both loops, if <b>test</b> is <b>true</b> Java executes the <b>break</b>;\r\n  if <b>test</b> is <b>false</b> each loop executes <b>statements<sub>2</sub></b> next and\r\n    then re-executes the loop:\r\n    on the left because <b>statements<sub>2</sub></b> is in the <b>else</b>, and on the right \r\n    because the <b>if</b> finishes and Java executes the next statement in the loop's body.\r\n  After executing <b>statements<sub>2</sub></b>, the bodies of both loops are finished executing,\r\n    so the <b>for</b> loop causes Java to execute them again.\r\n  <p>\r\n  Typically code is simpler if it isn't nested deeply.\r\n  <p>\r\n  <b>Loop Factoring</b>:\r\n  The second loop equivalence again involves factoring statements.\r\n  <b><pre>\r\n  for (;;) {              for (;;) {\r\n    statements<sub>1</sub>             statements<sub>1</sub>\r\n    if (test) {             if (test)\r\n      statements<sub>a</sub>              break;\r\n      break;                statements<sub>2</sub>\r\n    }                     }\r\n    statements<sub>2</sub>           statements<sub>a</sub>\r\n  }</pre></b>\r\n  In both loops, if <b>test</b> is <b>false</b> each executes <b>statements<sub>2</sub></b>,\r\n    and the bodies of both loops are executed again.\r\n  In the left loop, if <b>test</b> is <b>true</b> it executes <b>statements<sub>a</sub></b>\r\n     and then terminates the loop; on the right it terminates the loop and afterward executes\r\n     <b>statements<sub>a</sub></b>.\r\n  The order of these operations makes no difference, except that any variables declared inside\r\n    the block that is the block that is the body of the <b>for</b> statement cannot be stored\r\n    in or examined outside of that block (after the loop terminates).\r\n  <p>\r\n  Typically, loop statements are the most complex to understand, in terms of\r\n    what they do; so by removing <b>statements<sub>a</sub></b> from the body\r\n    of the loop, we simplify it.\r\n  <p>\r\n  <b>Loop Rerolling</b>:  <sub></sub>\r\n  The third loop equivalence involves moving statements repeated before and at the bottom of\r\n    a loop completely inside the loop.\r\n  <b><pre>\r\n  statements<sub>1</sub>             for (;;) {\r\n  for (;;) {                statements<sub>1</sub>\r\n    if (test)               if (test)\r\n      break;                  break;\r\n    statements<sub>2</sub>             statements<sub>2</sub>\r\n    statements<sub>1</sub>           }\r\n  }</pre></b>\r\n  Each code fragment first executes <b>statements<sub>1</sub></b> (on the left before the loop; on\r\n    the right as the first statement in the loop's body).\r\n  Then, each tests for termination; if the <b>test</b> is not true, each executes\r\n   <b>statements<sub>2</sub></b>, followed by <b>statements<sub>1</sub></b> (on the left at the\r\n   bottom of the loop; on the right at the top of th loop), followed by testing for termination again.\r\n  <p>\r\n  Typically, we want to avoid duplicating statements inside and outside of\r\n    loops.\r\n  By using <b>for</b>/<b>if</b>/<b>break</b>, which allows a termination test\r\n    in the middle of a loop, we can remove this redundancy.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Pragmatics -->\r\n\r\n<a name=\"Pragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Pragmatics</b></td>\r\n<td width =\"80%\">\r\n  The formal techniques presented and illustrated above allow us to prove that two programming\r\n    forms are equivalent.\r\n  It is then up to us to determine which form is simpler, and use it in our programs.\r\n  As a rule of thumb, the smaller the code the simpler it is.\r\n  Also, code with fewer nested statements is generally simpler.\r\n  <p>\r\n  More generally, we should try to distribute complexity.\r\n  So, when decidiing between two equivalences, choose the one whose most\r\n    complicated statement is simplest.\r\n  <p>\r\n  If you ever find yourself duplicating code, there is an excellent chance that\r\n    some simplification will remove this redundancy.\r\n  Beginners are especially prone to duplicating large chunks of code, missing the\r\n    important simplification.\r\n  <p>\r\n  We should aggressively simplify our code while we are programming.\r\n  We will be amply rewarded, because it is easier to add more code (completing\r\n    the phases of the enhancements) to an already simplified program.\r\n  If we wait until the program is finished before simplifying...well, we many\r\n    never finish the program because it has become too complex; if we do\r\n    finish, the  context in which to perform each simplification will be much\r\n    bigger and more complex, making it harder to simplify.\r\n  Excessive complexity is one of the biggest problems that a software engineer\r\n    faces.\r\n  <p>\r\n  Generally, I try not to get distracted when I am writing code; but one of \r\n    the few times that I will stop writing code is when I see a simplification.\r\n  I know that in the long run, taking time to do a simplification immediately\r\n    will likely allow me to finish the  program faster.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, or any other student.\r\n\r\n  <ol> \r\n     <li>Prove that the expressions <b>x < 10</b> and <b>(x < 10) == true</b> are equivalent.\r\n         Prove that the expressions <b>x < 10</b> and <b>(x >= 10) == false</b> are equivalent.\r\n         In each case, which would you judge the simpler expression?\r\n     <p>\r\n     \r\n\r\n     <li>Use the law of trichotomy to prove that <b>(x+y-Math.abs(x-y))/2.</b> and\r\n           <b>Math.min(x,y)</b> compute the same value.\r\n     <p>\r\n     \r\n     <li>In the following statements, identify which variabes are stored into and which variables\r\n           are examined.\r\n         <ul>\r\n           <li><b>x += y;</b>\r\n           <li><b>x = x + 1;</b>\r\n           <li><b>System.out.println(x);</b>\r\n           <li><b>if (x > 0) x = 0;</b>\r\n           <li><b>if (x == 0) break</b>\r\n           <li><b>x += y += z;</b>\r\n         </ul>\r\n     <p>\r\n\r\n  <li>Prove that the following two statements are equivalent. Assume that we declared <b>boolean b;</b>\r\n      <b><pre>  if (test)          b = !test;\r\n    b = false;\r\n  else\r\n    b = true;</pre></b>\r\n  <p>\r\n\r\n  <li>The code on the left is not equivalent to the code on the right (which has been top factored).\r\n      They are not equivalent because the <b>if</b>'s test and the statements <b>x++</b> are not\r\n        independent.\r\n      Rewrite the <b>if</b>'s test in the code on the right so that left and right are equivalent.\r\n     <b><pre>  if (x < 10) {               x++;\r\n    x++;                      if (x < 10)\r\n    System.out.println(x);      System.out.println(x);\r\n  }else{                      else\r\n    x++;                        y = x;\r\n    y = x;\r\n  }</pre></b>\r\n\r\n  <p>\r\n  <li>Suppose we are comparing aspirin A1, A2, A3, and A4 for efficacy.\r\n      Suppose that the company making A1 goes on TV with the advertisement:\r\n      \ufffdNo aspirin is better than A1\ufffd.\r\n      Could the other companies also run ads saying the exact same thing about their products?\r\n      <p>\r\n      How does this question relate to the material in this lecture?\r\n      How does it relate to mathematical vs. perceptual/psychological truths in advertising?\r\n      As a programmer whose code is read by other people (as well as the Java compiler), what\r\n        implications does this have for the audience for which we are writing code?\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 30713.0}