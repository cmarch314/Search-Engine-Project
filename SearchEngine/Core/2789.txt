{"text": "HW3 Alignment Due date see schedule Part 1 Mosaics Mosaic of 4 images aligned with homographies or perspective transformations In this assignment you will extend the field of view of a camera by forming a mosaic from multiple photographs When images are taken with same optical center they can be aligned with a homography transformation To estimate the homography you ll need 4 pairs of corresponding points in the overlap region You ll mark these points manually We discussed in class some methods for finding them automatically The following directory contains the source images for alignment along with skeleton code Downloads Programming 9 points The first image in each example provided is the central image It s simplest to construct a mosaic from a central image and a set of peripheral images since we then need to find just one homography perspective transformation for each peripheral image Use the cpselect and cpcorr functions to manually select and refine at least 4 pairs of corresponding points in each overlap region between the central and peripheral images These points should be located on high contrast corners Next compute the homography that maps corresponding points from the central base image to the peripheral images We showed in class that one can use the SVD to do this You will need to write two functions function H computeHomography x1 y1 x2 y2 3 points function x2 y2 applyHomography H x1 y1 3 points Note that the inverse mapping is given simply by inv H I highly recommend debugging computeHomography m by applying the homography transformation on points from x1 y1 and verifying that they produce x2 y2 Write a script mosaic m 3 points that loads in multiple images allows a user to click on corresponding points and constructs a mosaic I have included skeleton code in the download directoty Treat one image as the base Its coordinate system will be used for the final mosaic The script will need to figure out the min and max pixel coordinates when the peripheral images are mapped into the base image s coordinate system Simply apply your homographies to the peripheral images corner points to find the extent of the final mosaic Now generate a meshgrid of points to cover the mosaic send these points through each homography in turn and use interp2 to extract pixel values from the source images For each input image this produces an image the size of the final mosaic pixels that are outside the source image are set to NaN Finally assemble the mosaic from the remapped source images Use isnan m to get a mask for each one that tells you which pixels are valid and which are invalid For Part I you may simply take a pixel from any valid image Part 2 Morphing In this assignment you will produce a morph animation of your face into someone else s face A morph is a simultaneous geometric warping of the image shape and a cross dissolve weighted averaging of the image colors The cross dissolve is the easy part controlling and doing the warp is the hard part The warp is controlled by defining a correspondence between the two pictures The correspondence should map eyes to eyes mouth to mouth chin to chin ears to ears etc to get the smoothest transformations possible To start with you should take a picture of yourself on a uniform background for instance white Your image should be the same size and aspect ratio as your target face Your target face may be someone from class or a picture you find online Treat your target face as a passport photo template your face in the picture should be about where their face is This will make your morphing result more pleasing to the eye Use your photo as Picture A and your target person s photo as Picture B You ll morph still picture A into still picture B and produce 46 frames of animation numbered 45 where frame must be identical to picture A and frame 45 must be identical to picture B Downloads contains some skeleton code for you to start with Programming 6 points Write the following 3 functions each in their own file with the following prototypes to perform the morph REMINDER you need to comment your code if you want the grader to be able to understand it and give you full credit 15 points This function computes the affine transformation which maps points from tri1 to tri2 You will use this to map pixels inside each triangle of your mesh NOTE do not use maketform or other MATLAB functions just basic math operations You are allowed to use inv m which computes the inverse of a matrix function T tform tri1 tri2 compute the transformation T which maps points of triangle1 to triangle2 tri1 2x3 matrix containing coordinates of triangle 1 tri2 2x3 matrix containing coordinates of triangle 2 T the resulting transformation should be a 3x3 matrix which operates on points described in homogeneous coordinates 3 points This function computes a warped image starting from a source image and a set of triangulated keypoints You will want to use MATLAB s built in function for interpolation interp2 and the provided function mytsearch for finding which triangle each point lies in function I target warp I source pts source pts target tri I source color source image HxWx3 pts source coordinates of keypoints in the source image 2xN pts target coordinates of where the keypoints end up after the warp 2xN tri list of triangles triples of indices into pts source Kx3 for example the coordinates of the Tth triangle should be given by the expression pts source tri T I target resulting warped image same size as source image HxWx3 15 points Write a script morph m that loads in the source and target image and produces a morph between them I ve included skeleton code for such a script The script should let the user click on keypoints in each image to indicate correspondences It should then triangulate the set of points using delaunay m and then produce a morph sequence by repeatedly warping the source and target images to an intermediate image and blending them NOTE you may want to save user clicks out to a file and just load them in so that you don t have to keep recreating them while testing your other code morphing script load in two images get user clicks on keypoints generate triangulation tri now produce the frames of the morph sequenceA for fnum 45 t fnum 45 pts target 1 t pts img1 t pts img2 intermediate key point locations I1 warp warp I1 pts img1 pts target tri warp image 1 I2 warp warp image 2 Iresult 1 t I1 warp t I2 warp blend the two warped images imwrite Iresult sprintf frame 2 2d jpg fnum jpg end You will need to define pairs of corresponding points on the two images by hand the more points the better the morph generally The simplest way is probably to use the cpselect tool or write your own tool using ginput and plot commands with hold on and hold off Now you need to provide a triangulation of these points that will be used for morphing You can compute a triangulation any way you like or even define it by hand A Delaunay triangulation see delaunay m and related functions is a good choice since it does not produce overly skinny triangles You can compute the Delaunay triangulation on either of the point sets but not both the triangulation has to be the same throughout the morph But the best approach would probably be to compute the triangulation at midway shape i e mean of the two point sets to lessen the potential triangle deformations In order to get nice looking results you will probably want to click on lots of corresponding points 2 You should also add the 4 corners of the image to your list of source and target points so that the background gets mapped appropriately MATLAB has a function tsearch which takes a set of points and a set of triangles and returns a vector indicating which triangle each point lies in type help tsearch The only problem is that it requires the triangulation to be Delaunay and it may be the case that our triangulation is no longer Delaunay at some point during the morphing For this reason I would suggest you use the mytsearch function included in the downloads directory written by David Margin There is also a version written in C which you can compile by typing mex mytsearch cc at the MATLAB prompt The compiled version should run faster Code Points specified above Make sure to turn in two separate scripts mosaic m and morph m that produce a mosaic and morph when run You should include your source images in your code archive so that your code can run Do not include the output mosaic or 46 morph frames in your archive Writeup 25 points Show the resulting mosaic for one of the provided examples 1 pt Show one mosaic of your own creation each with at least 3 source images Show the original images and the final mosaic 1 pt Show every 9th frame of your morph frames 9 18 27 36 45 5 pt Matlab Tips Don t forget the hold on command if you want to plot one thing on top of another Running cpselect is a pain Don t do it more than once for any pair of images You can use the save and load functions to save and restore variables from your matlab workspace Do no use the full size images Resize them down so that your debugging goes fast For your final results 25 size is sufficient You can treat the central image as just another source image by using eye 3 as its homography Use linear interpolation with interp2 it s fast and looks good Just make sure you don t use nearest neighbor interpolation which looks terrible and may be the default Extra credit As detailed in the guidelines any project handed by 11 59 pm on the previous day will recieve 1 extra credit ", "_id": "http://www.ics.uci.edu/~dramanan/teaching/cs116_winter15/hw/hw3.html", "title": "hw3", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n  <head>\n    <title>HW3</title>\n  </head>\n  <body>\n    <h1>HW3: Alignment </h1>\n    <h2> Due date (see <a href=\"../lec.html\">schedule</a>)</h1>\n    <hr>\n\n<h2>Part 1: Mosaics </h2>\n\n\n<a href=\"window.png\"> <img width=500 src=\"window.png\"> </a>\n<font size=\"-1\"><br>\nMosaic of 4 images aligned with homographies, or perspective transformations.\n</font>\n<br>\n\n<p>\nIn this assignment, you will extend the field of view of a camera by forming a mosaic from multiple photographs. \n\nWhen images are taken with same optical center, they can be aligned with a homography transformation. To estimate the homography, you'll need 4 pairs of corresponding points in the overlap region. You'll mark these points manually. We discussed in class some methods for finding them automatically.\n\nThe following directory contains the source images for alignment, along with skeleton code:\n\n<ul>\n<li><a href=\"hw3_part1\">Downloads</a>\n</ul>\n\n<h4>Programming: [90 points]</h4>\n\n<p>\nThe first image in each example provided is the central image.  It's\nsimplest to construct a mosaic from a central image and a set of\nperipheral images, since we then need to find just one homography (perspective transformation) for each peripheral image.  Use the <tt>cpselect</tt> and <tt>cpcorr</tt>\n\nfunctions to manually select and refine at least 4 pairs of\ncorresponding points in each overlap region between the central and\nperipheral images.  These points should be located on high contrast\ncorners.\n\n<p>\nNext, compute the homography that maps corresponding points from the central base image to the peripheral images. We showed in class that one can use the SVD to do this. You will need to write two functions:\n\n<blockquote><tt><pre>\nfunction [H] = computeHomography(x1,y1,x2,y2) <b>[30 points]</b>\nfunction [x2,y2] = applyHomography(H,x1,y1) <b>[30 points]</b>\n</pre></tt></blockquote>\n\n<p>\nNote that the inverse mapping is given simply by <tt>inv(H)</tt>.\nI highly recommend debugging <tt>computeHomography.m</tt> by applying the homography transformation on points from (x1,y1) and verifying that they produce (x2,y2).\n\n<p>\nWrite a script <tt>mosaic.m</tt> <b>[30 points]</b> that loads in multiple images, allows a user to click on corresponding points, and constructs a mosaic. I have included skeleton code in the download directoty. Treat one image as the 'base'. Its' coordinate system will be used for the final mosaic.  The script will need to figure out the min and max pixel coordinates when the peripheral\nimages are mapped into the base image's coordinate system.  Simply apply your homographies to the peripheral images' corner points to find\nthe extent of the final mosaic.\n\n<p>\nNow generate a <tt>meshgrid</tt> of points to cover the mosaic, send\nthese points through each homography in turn, and use <tt>interp2</tt> to extract pixel values from the source images.  For each input image, this produces an image the size of the final mosaic; pixels that are outside the source image are set to <tt>NaN</tt>.\n\n<p>\nFinally, assemble the mosaic from the remapped source images.  Use\n<tt>isnan.m</tt> to get a mask for each one that tells you which pixels\nare valid and which are invalid.  For Part I, you may simply take a\npixel from any valid image.\n\n<h2> Part 2: Morphing </h2>\n\n<img width=500 src=\"morph.gif\"> </a>\n<br>\n\n<p>In this assignment you will produce a \"morph\" animation of your face into someone else's face. A morph is a simultaneous geometric warping of the image shape and a cross-dissolve (weighted averaging) of the image colors. The cross-dissolve is the easy part; controlling and doing the warp is the hard part. The warp is controlled by defining a correspondence between the two pictures. The correspondence should map eyes to eyes, mouth to mouth, chin to chin, ears to ears, etc., to get the smoothest transformations possible.\n\nTo start with, you should take a picture of yourself on a uniform background (for instance, white). Your image should be the same size and aspect ratio as your target face. Your target face may be someone from class, or a picture you find online. Treat your target face as a passport photo template -- your face in the picture should be about where their face is. This will make your morphing result more pleasing to the eye.\n\nUse your photo as Picture A and your target person's photo as Picture B. You'll morph still picture A into still picture B and produce 46 frames of animation numbered 0-45, where frame 0 must be identical to picture A and frame 45 must be identical to picture B. \n\n    <ul>\n      <li><a href=\"hw3_part2\">Downloads</a> contains some skeleton code for you to start with\n    </ul>\n \n    <h4>Programming [60 points]</h4>\n\n    Write the following 3 functions (each in their own file) with the following\n    prototypes to perform the morph.  <b>REMINDER: you need to comment your code \n    if you want the grader to be able to understand it and give you full credit</b>\n    \n    <blockquote><tt><pre>\n      </pre></tt></blockquote>\n    <ol>\n      \n\t<hr>\n\t<p><li><b>[15 points]</b> \n  This function computes the affine transformation which maps points from tri1\n  to tri2.  You will use this to map pixels inside each triangle of your mesh.\n\n  NOTE: do not use maketform or other MATLAB functions, just basic math operations. You are allowed to use <tt>inv.m</tt>, which computes the inverse of a matrix.\n\n\t<blockquote><tt><pre>\n  function T = tform(tri1,tri2)\n  %\n  % compute the transformation T which maps points\n  % of triangle1 to triangle2 \n  %\n  %  tri1 : 2x3 matrix containing coordinates of triangle 1\n  %  tri2 : 2x3 matrix containing coordinates of triangle 2\n  %\n  %  T : the resulting transformation, should be a 3x3\n  %      matrix which operates on points described in \n  %      homogeneous coordinates \n  %\n\t</pre></tt></blockquote>\n\t<hr>\n\n\t<p><li><b>[30 points]</b> \n  This function computes a warped image starting from a source image and a\n  set of triangulated keypoints.  You will want to use MATLAB's built in\n  function for interpolation <b>interp2</b> and the provided function\n  <b>mytsearch</b> for finding which triangle each point lies in.\n\t<blockquote><tt><pre>\n  function I_target = warp(I_source,pts_source,pts_target,tri)\n  %\n  % I_source : color source image  (HxWx3)\n  % pts_source : coordinates of keypoints in the source image  (2xN)\n  % pts_target : coordinates of where the keypoints end up after the warp (2xN)\n  % tri : list of triangles (triples of indices into pts_source)  (Kx3)\n  %       for example, the coordinates of the Tth triangle should be \n  %       given by the expression:\n  %\n  %           pts_source(:,tri(T,:))\n  % \n  %\n  % I_target : resulting warped image, same size as source image (HxWx3)\n  %\n</pre></tt></blockquote>\n  <hr>\n\n\t<p><li><b>[15 points]</b> \n  Write a script <b>morph.m</b> that loads in the source and target image\n  and produces a morph between them. I've included skeleton code for such a script. The script should let the user click on \n  keypoints in each image to indicate correspondences.  It should then triangulate\n  the set of points (using <b>delaunay.m</b>) and then produce a morph \n  sequence by repeatedly warping the source and target images to an intermediate\n  image and blending them.\n\n  NOTE: you may want to save user clicks out to a file and just load them\n  in so that you don't have to keep recreating them while testing your other \n  code.\n\n\t<blockquote><tt><pre>\n  %\n  % morphing script\n  %\n\n  % load in two images...\n\n  % get user clicks on keypoints\n\n  % generate triangulation \n  tri = ...\n\n  % now produce the frames of the morph sequenceA\n  for fnum = 0:45\n    t = fnum/45;\n    pts_target = (1-t)*pts_img1 + t*pts_img2;                % intermediate key-point locations\n    I1_warp = warp(I1,pts_img1,pts_target,tri);              % warp image 1\n    I2_warp = ...                                            % warp image 2\n    Iresult = (1-t)*I1_warp + t*I2_warp;                     % blend the two warped images\n    imwrite(Iresult,sprintf('frame_%2.2d.jpg',fnum),'jpg')\n  end\n  </pre></tt></blockquote>\n\t<hr>\n\n    </ol>\n\n    <p> You will need to define pairs of corresponding points on the two\n    images by hand (the more points, the better the morph, generally). The\n    simplest way is probably to use the <tt>cpselect</tt> tool or write your own \n    tool using ginput and plot commands (with hold on and hold off ). Now, you\n    need to provide a triangulation of these points that will be used for\n    morphing. You can compute a triangulation any way you like, or even define\n    it by hand. A Delaunay triangulation (see delaunay.m and related functions)\n    is a good choice since it does not produce overly skinny triangles. You can\n    compute the Delaunay triangulation on either of the point sets (but not\n    both -- the triangulation has to be the same throughout the morph!). But\n    the best approach would probably be to compute the triangulation at midway\n    shape (i.e. mean of the two point sets) to lessen the potential triangle\n    deformations. \n\n    <p> In order to get nice looking results you will probably want to click on\n    lots of corresponding points (~20).  You should also add the 4 corners\n    of the image to your list of source and target points so that the background\n    gets mapped appropriately.\n\n    <p> MATLAB has a function <b>tsearch</b> which takes a set of points and a set\n    of triangles and returns a vector indicating which triangle each point lies\n    in (type <b>help tsearch</b>).  The only problem is that it requires the \n    triangulation to be Delaunay and it may be the case that our triangulation\n    is no longer Delaunay at some point during the morphing.  For this reason\n    I would suggest you use the <b>mytsearch</b> function included in the \n    downloads directory, written by David Margin. There is also a version written in C++ which you can \n    compile by typing <b>>>mex mytsearch.cc</b> at the MATLAB prompt.  The \n    compiled version should run faster.<p>\n\n<h4>Code: [Points specified above]</h4>\nMake sure to turn in two separate scripts, <tt>mosaic.m</tt>, and <tt>morph.m</tt> that produce a mosaic and morph when run. You should include your source images in your code archive, so that your code can run. Do not include the output mosaic or 46 morph frames in your archive.\n\n<h4>Writeup: [25 points]</h4>\n\n<ol>\n\n<p><li> Show the resulting mosaic for one of the provided examples. [10 pt]\n\n\n<p><li> Show one mosaic of your own creation, each with at least 3 source images.  Show the original images and the final mosaic. [10pt]\n\n<p><li> Show every 9th frame of your morph (frames 0,9,18,27,36,45). [5 pt]\n\n</ol>\n\n<h4>Matlab Tips</h4>\n\n<ol>\n\n<p><li> Don't forget the <tt>hold on</tt> command if you want to \nplot one thing on top of another.\n\n<p><li> Running <tt>cpselect</tt> is a pain.  Don't do it more than\nonce for any pair of images!  You can use the <tt>save</tt> and\n\n<tt>load</tt> functions to save and restore variables from your\nmatlab workspace.\n\n<p><li> Do no use the full size images.  Resize them down so that your\ndebugging goes fast.  For your final results, 25% size is sufficient.\n\n<p><li> You can treat the central image as just another source image\nby using <tt>eye(3)</tt> as its homography.\n\n<p><li> Use <tt>'linear'</tt> interpolation with <tt>interp2</tt>; \nit's fast and looks good.  Just make sure you don't use nearest neighbor\ninterpolation, which looks terrible and may be the default.\n\n\n</ol>\n\n<h4>Extra-credit</h4>\n    As detailed in the <a href=\"../../hw_guide.html\"> guidelines</a>, any project handed by 11:59 pm on the previous day, will recieve 10% extra credit.\n\n\n</p></div></center>\n</body></html>\n", "id": 2789.0}