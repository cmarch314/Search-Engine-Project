{"text": "Search LoginPreferencesHelp GuideAbout Trac WikiTimelineRoadmapBrowse SourceView TicketsSearch Context Navigation BlameRevision Log source nomatic tags NomaticIM 5 buddy bots src zope interface README txt View diff against View revision Visit trunk Last change on this file was 712 checked in by cbaker 7 years ago First draft of nomatic buddy bots oscar bot is functional if you give it good authentication credentials jabber bot is just an example from the web File size 22 5 KB Line 1 2Interfaces3 45Interfaces are objects that specify document the external behavior6of objects that provide them An interface specifies behavior7through 89 Informal documentation in a doc string1 11 Attribute definitions1213 Invariants which are conditions that must hold for objects that14 provide the interface1516Attribute definitions specify specific attributes They define the17attribute name and provide documentation and constraints of attribute18values Attribute definitions can take a number of forms as we ll19see below 2 21Defining interfaces22 2324Interfaces are defined using Python class statements 2526 import zope interface27 class IFoo zope interface Interface 28 Foo blah blah 29 3 x zope interface Attribute X blah blah 31 32 def bar q r None 33 bar blah blah 3435In the example above we ve created an interface IFoo We36subclassed zope interface Interface which is an ancestor interface for37all interfaces much as object is an ancestor of all new style38classes create The interface is not a class it s an Interface 39an instance of InterfaceClass 4 41 type IFoo 42 class zope interface interface InterfaceClass 4344We can ask for the interface s documentation 4546 IFoo doc 47 Foo blah blah 4849and its name 5 51 IFoo name 52 IFoo 5354and even its module 5556 IFoo module 57 main 5859The interface defined two attributes 6 61 x 62 This is the simplest form of attribute definition It has a name63 and a doc string It doesn t formally specify anything else 6465 bar 66 This is a method A method is defined via a function definition A67 method is simply an attribute constrained to be a callable with a68 particular signature as provided by the function definition 697 Note that bar doesn t take a self argument Interfaces document71 how an object is used When calling instance methods you don t72 pass a self argument so a self argument isn t included in the73 interface signature The self argument in instance methods is74 really an implementation detail of Python instances Other objects 75 besides instances can provide interfaces and their methods might not76 be instance methods For example modules can provide interfaces and77 their methods are usually just functions Even instances can have78 methods that are not instance methods 798 You can access the attributes defined by an interface using mapping81syntax 8283 x IFoo x 84 type x 85 class zope interface interface Attribute 86 x name 87 x 88 x doc 89 X blah blah 9 91 IFoo get x name 92 x 9394 IFoo get y 9596You can use in to determine if an interface defines a name 9798 x in IFoo99 True1 1 1You can iterate over interfaces to get the names they define 1 21 3 names list IFoo 1 4 names sort 1 5 names1 6 bar x 1 71 8Remember that interfaces aren t classes You can t access attribute1 9definitions as attributes of interfaces 11 111 IFoo x112 Traceback most recent call last 113 File stdin line 1 in 114 AttributeError InterfaceClass object has no attribute x 115116Methods provide access to the method signature 117118 bar IFoo bar 119 bar getSignatureString 12 q r None 121122TODO123 Methods really should have a better API This is something that124 needs to be improved 125126Declaring interfaces127 128129Having defined interfaces we can declare that objects provide13 them Before we describe the details lets define some terms 131132 provide 133 We say that objects provide interfaces If an object provides an134 interface then the interface specifies the behavior of the135 object In other words interfaces specify the behavior of the136 objects that provide them 137138 implement 139 We normally say that classes implement interfaces If a class14 implements an interface then the instances of the class provide141 the interface Objects provide interfaces that their classes142 implement factory Objects can provide interfaces directly 143 in addition to what their classes implement 144145 It is important to note that classes don t usually provide the146 interfaces that they implement 147148 We can generalize this to factories For any callable object we149 can declare that it produces objects that provide some interfaces15 by saying that the factory implements the interfaces 151152Now that we ve defined these terms we can talk about the API for153declaring interfaces 154155Declaring implemented interfaces156 157158The most common way to declare interfaces is using the implements159function in a class statement 16 161 class Foo 162 zope interface implements IFoo 163 164 def init self x None 165 self x x166 167 def bar self q r None 168 return q r self x169 17 def repr self 171 return Foo s self x172173174In this example we declared that Foo implements IFoo This means175that instances of Foo provide IFoo Having made this declaration 176there are several ways we can introspect the declarations First we177can ask an interface whether it is implemented by a class 178179 IFoo implementedBy Foo 18 True181182And we can ask whether an interface is provided by an object 183184 foo Foo 185 IFoo providedBy foo 186 True187188Of course Foo doesn t provide IFoo it implements it 18919 IFoo providedBy Foo 191 False192193We can also ask what interfaces are implemented by an object 194195 list zope interface implementedBy Foo 196 InterfaceClass main IFoo 197198It s an error to ask for interfaces implemented by a non callable199object 2 2 1 IFoo implementedBy foo 2 2 Traceback most recent call last 2 3 2 4 TypeError ImplementedBy called for non factory Foo None 2 52 6 list zope interface implementedBy foo 2 7 Traceback most recent call last 2 8 2 9 TypeError ImplementedBy called for non factory Foo None 21 211Similarly we can ask what interfaces are provided by an object 212213 list zope interface providedBy foo 214 InterfaceClass main IFoo 215 list zope interface providedBy Foo 216 217218We can declare interfaces implemented by other factories besides219classes We do this using a Python 2 4 style decorator named22 implementer In versions of Python before 2 4 this looks like 221222223 def yfoo y 224 foo Foo 225 foo y y226 return foo227 yfoo zope interface implementer IFoo yfoo 228229 list zope interface implementedBy yfoo 23 InterfaceClass main IFoo 231232Note that the implementer decorator may modify it s argument Callers233should not assume that a new object is created 234235Also note that at least for now implementer can t be used with236classes 237238 zope interface implementer IFoo Foo 239 doctest NORMALIZE WHITESPACE24 Traceback most recent call last 241 242 TypeError Can t use implementer with classes 243 Use one of the class declaration functions instead 244245Declaring provided interfaces246 247248We can declare interfaces directly provided by objects Suppose that249we want to document what the init method of the Foo class25 does It s not really part of IFoo You wouldn t normally call251the init method on Foo instances Rather the init method252is part of the Foo s call method 253254 class IFooFactory zope interface Interface 255 Create foos 256 257 def call x None 258 Create a foo259 26 The argument provides the initial value for x 261 262263It s the class that provides this interface so we declare the264interface on the class 265266 zope interface directlyProvides Foo IFooFactory 267268And then we ll see that Foo provides some interfaces 26927 list zope interface providedBy Foo 271 InterfaceClass main IFooFactory 272 IFooFactory providedBy Foo 273 True274275Declaring class interfaces is common enough that there s a special276declaration function for it classProvides that allows the277declaration from within a class statement 278279 class Foo2 28 zope interface implements IFoo 281 zope interface classProvides IFooFactory 282 283 def init self x None 284 self x x285 286 def bar self q r None 287 return q r self x288 289 def repr self 29 return Foo s self x291292 list zope interface providedBy Foo2 293 InterfaceClass main IFooFactory 294 IFooFactory providedBy Foo2 295 True296297There s a similar function moduleProvides that supports interface298declarations from within module definitions For example see the use299of moduleProvides call in zope interface init which declares that3 the package zope interface provides IInterfaceDeclaration 3 13 2Sometimes we want to declare interfaces on instances even though3 3those instances get interfaces from their classes Suppose we create3 4a new interface ISpecial 3 53 6 class ISpecial zope interface Interface 3 7 reason zope interface Attribute Reason why we re special 3 8 def brag 3 9 Brag about being special 31 311We can make an existing foo instance special by providing reason 312and brag attributes 313314 foo reason I just am 315 def brag 316 return I m special 317 foo brag brag318 foo reason319 I just am 32 foo brag 321 I m special 322323and by declaring the interface 324325 zope interface directlyProvides foo ISpecial 326327then the new interface is included in the provided interfaces 328329 ISpecial providedBy foo 33 True331 list zope interface providedBy foo 332 InterfaceClass main ISpecial InterfaceClass main IFoo 333334We can find out what interfaces are directly provided by an object 335336 list zope interface directlyProvidedBy foo 337 InterfaceClass main ISpecial 338339 newfoo Foo 34 list zope interface directlyProvidedBy newfoo 341 342343Inherited declarations344 345346Normally declarations are inherited 347348 class SpecialFoo Foo 349 zope interface implements ISpecial 35 reason I just am 351 def brag self 352 return I m special because s self reason353354 list zope interface implementedBy SpecialFoo 355 InterfaceClass main ISpecial InterfaceClass main IFoo 356357 list zope interface providedBy SpecialFoo 358 InterfaceClass main ISpecial InterfaceClass main IFoo 35936 Sometimes you don t want to inherit declarations In that case you361can use implementsOnly instead of implements 362363 class Special Foo 364 zope interface implementsOnly ISpecial 365 reason I just am 366 def brag self 367 return I m special because s self reason368369 list zope interface implementedBy Special 37 InterfaceClass main ISpecial 371372 list zope interface providedBy Special 373 InterfaceClass main ISpecial 374375External declarations376 377378Normally we make implementation declarations as part of a class379definition Sometimes we may want to make declarations from outside38 the class definition For example we might want to declare interfaces381for classes that we didn t write The function classImplements can382be used for this purpose 383384 class C 385 pass386387 zope interface classImplements C IFoo 388 list zope interface implementedBy C 389 InterfaceClass main IFoo 39 391We can use classImplementsOnly to exclude inherited interfaces 392393 class C Foo 394 pass395396 zope interface classImplementsOnly C ISpecial 397 list zope interface implementedBy C 398 InterfaceClass main ISpecial 3994 4 14 2Declaration Objects4 3 4 44 5When we declare interfaces we create declaration objects When we4 6query declarations declaration objects are returned 4 74 8 type zope interface implementedBy Special 4 9 class zope interface declarations Implements 41 411Declaration objects and interface objects are similar in many ways In412fact they share a common base class The important thing to realize413about them is that they can be used where interfaces are expected in414declarations Here s a silly example 415416 class Special2 Foo 417 zope interface implementsOnly 418 zope interface implementedBy Foo 419 ISpecial 42 421 reason I just am 422 def brag self 423 return I m special because s self reason424425The declaration here is almost the same as426 zope interface implements ISpecial except that the order of427interfaces in the resulting declaration is different 428429 list zope interface implementedBy Special2 43 InterfaceClass main IFoo InterfaceClass main ISpecial 431432433Interface Inheritance434 435436Interfaces can extend other interfaces They do this simply by listing437the other interfaces as base interfaces 438439 class IBlat zope interface Interface 44 Blat blah blah 441 442 y zope interface Attribute y blah blah 443 def eek 444 eek blah blah 445446 IBlat bases 447 InterfaceClass zope interface Interface 448449 class IBaz IFoo IBlat 45 Baz blah 451 def eek a 1 452 eek in baz blah 453 454455 IBaz bases 456 InterfaceClass main IFoo InterfaceClass main IBlat 457458 names list IBaz 459 names sort 46 names461 bar eek x y 462463Note that IBaz overrides eek 464465 IBlat eek doc 466 eek blah blah 467 IBaz eek doc 468 eek in baz blah 46947 We were careful to override eek in a compatible way When extending471an interface the extending interface should be compatible compat 472with the extended interfaces 473474We can ask whether one interface extends another 475476 IBaz extends IFoo 477 True478 IBlat extends IFoo 479 False48 481Note that interfaces don t extend themselves 482483 IBaz extends IBaz 484 False485486Sometimes we wish they did but we can instead use isOrExtends 487488 IBaz isOrExtends IBaz 489 True49 IBaz isOrExtends IFoo 491 True492 IFoo isOrExtends IBaz 493 False494495When we iterate over an interface we get all of the names it defines 496including names defined by base interfaces Sometimes we want just 497the names defined by the interface directly We bane use the names 498method for that 4995 list IBaz names 5 1 eek 5 25 3Inheritance of attribute specifications5 4 5 55 6An interface may override attribute definitions from base interfaces 5 7If two base interfaces define the same attribute the attribute is5 8inherited from the most specific interface For example with 5 951 class IBase zope interface Interface 511 512 def foo 513 base foo doc 514515 class IBase1 IBase 516 pass517518 class IBase2 IBase 519 52 def foo 521 base2 foo doc 522523 class ISub IBase1 IBase2 524 pass525526ISub s definition of foo is the one from IBase2 since IBase2 is more527specific that IBase 528529 ISub foo doc 53 base2 foo doc 531532Note that this differs from a depth first search 533534Sometimes it s useful to ask whether an interface defines an535attribute directly You can use the direct method to get a directly536defined definitions 537538 IBase direct foo doc 539 base foo doc 54 541 ISub direct foo 542543Specifications544 545546Interfaces and declarations are both special cases of specifications 547What we described above for interface inheritance applies to both548declarations and specifications Declarations actually extend the549interfaces that they declare 55 551 class Baz 552 zope interface implements IBaz 553554 baz implements zope interface implementedBy Baz 555 baz implements bases 556 InterfaceClass main IBaz 557558 baz implements extends IFoo 559 True56 561 baz implements isOrExtends IFoo 562 True563 baz implements isOrExtends baz implements 564 True565566Specifications interfaces and declarations provide an sro 567that lists the specification and all of it s ancestors 568569 baz implements sro 57 implementedBy main Baz 571 InterfaceClass main IBaz 572 InterfaceClass main IFoo 573 InterfaceClass main IBlat 574 InterfaceClass zope interface Interface 575576577Tagged Values578 57958 Interfaces and attribute descriptions support an extension mechanism 581borrowed from UML called tagged values that lets us store extra582data 583584 IFoo setTaggedValue date modified 2 4 4 1 585 IFoo setTaggedValue author Jim Fulton 586 IFoo getTaggedValue date modified 587 2 4 4 1 588 IFoo queryTaggedValue date modified 589 2 4 4 1 59 IFoo queryTaggedValue datemodified 591 tags list IFoo getTaggedValueTags 592 tags sort 593 tags594 author date modified 595596Function attributes are converted to tagged values when method597attribute definitions are created 598599 class IBazFactory zope interface Interface 6 def call 6 1 create one 6 2 call return type IBaz6 36 4 IBazFactory call getTaggedValue return type 6 5 InterfaceClass main IBaz 6 66 76 8Invariants6 9 61 611Interfaces can express conditions that must hold for objects that612provide them These conditions are expressed using one or more613invariants Invariants are callable objects that will be called with614an object that provides an interface An invariant raises an Invalid 615exception if the condition doesn t hold Here s an example 616617 class RangeError zope interface Invalid 618 A range has invalid limits 619 def repr self 62 return RangeError r self args621622 def range invariant ob 623 if ob max ob min 624 raise RangeError ob 625626Given this invariant we can use it in an interface definition 627628 class IRange zope interface Interface 629 min zope interface Attribute Lower bound 63 max zope interface Attribute Upper bound 631 632 zope interface invariant range invariant 633634Interfaces have a method for checking their invariants 635636 class Range object 637 zope interface implements IRange 638 639 def init self min max 64 self min self max min max641 642 def repr self 643 return Range s s self min self max 644645 IRange validateInvariants Range 1 2 646 IRange validateInvariants Range 1 1 647 IRange validateInvariants Range 2 1 648 Traceback most recent call last 649 65 RangeError Range 2 1 651652If you have multiple invariants you may not want to stop checking653after the first error If you pass a list to validateInvariants 654then a single Invalid exception will be raised with the list of655exceptions as it s argument 656657 errors 658 IRange validateInvariants Range 2 1 errors 659 Traceback most recent call last 66 661 Invalid RangeError Range 2 1 662663And the list will be filled with the individual exceptions 664665 errors666 RangeError Range 2 1 667668669 del errors 67 671 672Adaptation673 674675Interfaces can be called to perform adaptation 676677The sematics based on those of the PEP 246 adapt function 678679If an object cannot be adapted then a TypeError is raised 68 681 class I zope interface Interface 682 pass683684 I 685 Traceback most recent call last 686 687 TypeError Could not adapt InterfaceClass main I 68868969 691unless an alternate value is provided as a second positional argument 692693 I bob 694 bob 695696If an object already implements the interface then it will be returned 697698 class C object 699 zope interface implements I 7 7 1 obj C 7 2 I obj is obj7 3 True7 47 5If an object implements conform then it will be used 7 67 7 class C object 7 8 zope interface implements I 7 9 def conform self proto 71 return 711712 I C 713 714715Adapter hooks see adapt will also be used if present 716717 from zope interface interface import adapter hooks718 def adapt to 42 iface obj 719 if obj 72 return 42721722 adapter hooks append adapt to 42 723 I 724 42725726 adapter hooks remove adapt to 42 727 I 728 Traceback most recent call last 729 73 TypeError Could not adapt InterfaceClass main I 731732 adapt 733 734735 class I zope interface Interface 736 pass737738Interfaces implement the PEP 246 adapt method 73974 This method is normally not called directly It is called by the PEP741246 adapt framework and by the interface call operator 742743The adapt method is responsible for adapting an object to the744reciever 745746The default version returns None 747748 I adapt 74975 unless the object given provides the interface 751752 class C object 753 zope interface implements I 754755 obj C 756 I adapt obj is obj757 True758759Adapter hooks can be provided or removed to provide custom76 adaptation We ll install a silly hook that adapts to 42 761We install a hook by simply adding it to the adapter hooks762list 763764 from zope interface interface import adapter hooks765 def adapt to 42 iface obj 766 if obj 767 return 42768769 adapter hooks append adapt to 42 77 I adapt 771 42772773Hooks must either return an adapter or None if no adapter can774be found 775776Hooks can be uninstalled by removing them from the list 777778 adapter hooks remove adapt to 42 779 I adapt 78 781782 create The main reason we subclass Interface is to cause the783 Python class statement to create an interface rather784 than a class 785786 It s possible to create interfaces by calling a special787 interface class directly Doing this it s possible788 and on rare occasions useful to create interfaces789 that don t descend from Interface Using this79 technique is beyond the scope of this document 791792 factory Classes are factories They can be called to create793 their instances We expect that we will eventually794 extend the concept of implementation to other kinds of795 factories so that we can declare the interfaces796 provided by the objects created 797798 compat The goal is substitutability An object that provides an799 extending interface should be substitutable for an object8 that provides the extended interface In our example an8 1 object that provides IBaz should be usable whereever an8 2 object that provides IBlat is expected 8 38 4 The interface implementation doesn t enforce this 8 5 but maybe it should do some checks Note See TracBrowser for help on using the repository browser Download in other formats Plain Text Original Format Powered by Trac 1 1 By Edgewall Software All content copyright 2 7 2 8 by LUCI http luci ics uci edu ", "_id": "http://djp3-pc2.ics.uci.edu/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt", "title": "\n      readme.txt in nomatic/tags/nomaticim-0.0.5/buddy_bots/src/zope/interface\n     \u2013 nomatic*im\n    ", "html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n  \n  \n\n  \n\n\n  <head>\n\t\t<title>\n      README.txt in nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface\n     \u2013 Nomatic*IM\n    </title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /><link rel=\"search\" href=\"/LUCICodeRepository/nomaticIM/search\" /><link rel=\"help\" href=\"/LUCICodeRepository/nomaticIM/wiki/TracGuide\" /><link rel=\"alternate\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt?format=txt\" type=\"text/plain\" title=\"Plain Text\" /><link rel=\"alternate\" href=\"/LUCICodeRepository/nomaticIM/export/1312/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\" type=\"text/plain; charset=iso-8859-15\" title=\"Original Format\" /><link rel=\"start\" href=\"/LUCICodeRepository/nomaticIM/wiki\" /><link rel=\"stylesheet\" href=\"/LUCICodeRepository/nomaticIM/chrome/common/css/trac.css\" type=\"text/css\" /><link rel=\"stylesheet\" href=\"/LUCICodeRepository/nomaticIM/chrome/common/css/code.css\" type=\"text/css\" /><link rel=\"stylesheet\" href=\"/LUCICodeRepository/nomaticIM/pygments/trac.css\" type=\"text/css\" /><link rel=\"stylesheet\" href=\"/LUCICodeRepository/nomaticIM/chrome/common/css/browser.css\" type=\"text/css\" /><link rel=\"shortcut icon\" href=\"http://luci.ics.uci.edu/logo32by32.gif\" type=\"image/gif\" /><link rel=\"icon\" href=\"http://luci.ics.uci.edu/logo32by32.gif\" type=\"image/gif\" /><link type=\"application/opensearchdescription+xml\" rel=\"search\" href=\"/LUCICodeRepository/nomaticIM/search/opensearch\" title=\"Search Nomatic*IM\" /><script type=\"text/javascript\" charset=\"utf-8\" src=\"/LUCICodeRepository/nomaticIM/chrome/common/js/jquery.js\"></script><script type=\"text/javascript\" charset=\"utf-8\" src=\"/LUCICodeRepository/nomaticIM/chrome/common/js/babel.js\"></script><script type=\"text/javascript\" charset=\"utf-8\" src=\"/LUCICodeRepository/nomaticIM/chrome/common/js/messages/en_US.js\"></script><script type=\"text/javascript\" charset=\"utf-8\" src=\"/LUCICodeRepository/nomaticIM/chrome/common/js/trac.js\"></script><script type=\"text/javascript\" charset=\"utf-8\" src=\"/LUCICodeRepository/nomaticIM/chrome/common/js/search.js\"></script><script type=\"text/javascript\" src=\"/LUCICodeRepository/nomaticIM/chrome/common/js/folding.js\"></script><script type=\"text/javascript\">\n      jQuery(document).ready(function($) {\n        $(\".trac-toggledeleted\").show().click(function() {\n                  $(this).siblings().find(\".trac-deleted\").toggle();\n                  return false;\n        }).click();\n        $(\"#jumploc input\").hide();\n        $(\"#jumploc select\").change(function () {\n          this.parentNode.parentNode.submit();\n        });\n          $('#preview table.code').enableCollapsibleColumns($('#preview table.code thead th.content'));\n      });\n    </script>\n\t</head>\n  <body>\n    <div id=\"banner\">\n      <div id=\"header\">\n        <a id=\"logo\" href=\"http://luci.ics.uci.edu/#code\"><img src=\"http://luci.ics.uci.edu/blog/archives/LUCIhorzTight.jpg\" alt=\"LUCI Code Repository\" /></a>\n      </div>\n      <form id=\"search\" action=\"/LUCICodeRepository/nomaticIM/search\" method=\"get\">\n        <div>\n          <label for=\"proj-search\">Search:</label>\n          <input type=\"text\" id=\"proj-search\" name=\"q\" size=\"18\" value=\"\" />\n          <input type=\"submit\" value=\"Search\" />\n        </div>\n      </form>\n      <div id=\"metanav\" class=\"nav\">\n    <ul>\n      <li class=\"first\"><a href=\"/LUCICodeRepository/nomaticIM/login\">Login</a></li><li><a href=\"/LUCICodeRepository/nomaticIM/prefs\">Preferences</a></li><li><a href=\"/LUCICodeRepository/nomaticIM/wiki/TracGuide\">Help/Guide</a></li><li class=\"last\"><a href=\"/LUCICodeRepository/nomaticIM/about\">About Trac</a></li>\n    </ul>\n  </div>\n    </div>\n    <div id=\"mainnav\" class=\"nav\">\n    <ul>\n      <li class=\"first\"><a href=\"/LUCICodeRepository/nomaticIM/wiki\">Wiki</a></li><li><a href=\"/LUCICodeRepository/nomaticIM/timeline\">Timeline</a></li><li><a href=\"/LUCICodeRepository/nomaticIM/roadmap\">Roadmap</a></li><li class=\"active\"><a href=\"/LUCICodeRepository/nomaticIM/browser\">Browse Source</a></li><li><a href=\"/LUCICodeRepository/nomaticIM/report\">View Tickets</a></li><li class=\"last\"><a href=\"/LUCICodeRepository/nomaticIM/search\">Search</a></li>\n    </ul>\n  </div>\n    <div id=\"main\">\n      <div id=\"ctxtnav\" class=\"nav\">\n        <h2>Context Navigation</h2>\n        <ul>\n          <li class=\"first\"><a href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/trunk/buddy_bots/zope/interface/README.txt?annotate=blame\" title=\"Annotate each line with the last changed revision (this can be time consuming...)\">Blame</a></li><li class=\"last\"><a href=\"/LUCICodeRepository/nomaticIM/log/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\">Revision Log</a></li>\n        </ul>\n        <hr />\n      </div>\n    <div id=\"content\" class=\"browser\">\n        <h1>\n          \n<a class=\"pathentry first\" href=\"/LUCICodeRepository/nomaticIM/browser?order=name\" title=\"Go to repository root\">source:</a>\n<a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic?order=name\" title=\"View nomatic\">nomatic</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags?order=name\" title=\"View tags\">tags</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5?order=name\" title=\"View NomaticIM-0.0.5\">NomaticIM-0.0.5</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots?order=name\" title=\"View buddy_bots\">buddy_bots</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src?order=name\" title=\"View src\">src</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope?order=name\" title=\"View zope\">zope</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface?order=name\" title=\"View interface\">interface</a><span class=\"pathentry sep\">/</span><a class=\"pathentry\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt?order=name\" title=\"View README.txt\">README.txt</a>\n<br style=\"clear: both\" />\n\n        </h1>\n        <div id=\"diffrev\">\n          <form action=\"/LUCICodeRepository/nomaticIM/changeset\" method=\"get\">\n            <div>\n              <label title=\"Show the diff against a specific revision\">\n                View diff against: <input type=\"text\" name=\"old\" size=\"6\" />\n                <input type=\"hidden\" name=\"old_path\" value=\"nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\" />\n                <input type=\"hidden\" name=\"new\" />\n                <input type=\"hidden\" name=\"new_path\" value=\"nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\" />\n              </label>\n            </div>\n          </form>\n        </div>\n        <div id=\"jumprev\">\n          <form action=\"\" method=\"get\">\n            <div>\n              <label for=\"rev\">\n                View revision:</label>\n              <input type=\"text\" id=\"rev\" name=\"rev\" size=\"6\" />\n            </div>\n          </form>\n        </div>\n        <div id=\"jumploc\">\n          <form action=\"\" method=\"get\">\n            <div class=\"buttons\">\n              <label for=\"preselected\">Visit:</label>\n              <select id=\"preselected\" name=\"preselected\">\n                <option selected=\"selected\"></option>\n                <optgroup label=\"branches\">\n                  <option value=\"/LUCICodeRepository/nomaticIM/browser/trunk\">trunk</option>\n                </optgroup>\n              </select>\n              <input type=\"submit\" value=\"Go!\" title=\"Jump to the chosen preselected path\" />\n            </div>\n          </form>\n        </div>\n        <div class=\"trac-tags\">\n        </div>\n      <table id=\"info\" summary=\"Revision info\">\n        <tr>\n          <th>\n                <a href=\"/LUCICodeRepository/nomaticIM/changeset/712/nomatic/trunk/buddy_bots/zope/interface/README.txt\" title=\"View differences\">Last change</a>\n                  on this file was\n                  <a href=\"/LUCICodeRepository/nomaticIM/changeset/712/\" title=\"View changeset 712\">712</a>,\n                  checked in by cbaker, <a class=\"timeline\" href=\"/LUCICodeRepository/nomaticIM/timeline?from=2008-02-16T08%3A16%3A53-08%3A00&amp;precision=second\" title=\"See timeline at Feb 16, 2008, 8:16:53 AM\">7 years ago</a>\n          </th>\n        </tr>\n        <tr>\n          <td class=\"message searchable\">\n              <p>\nFirst draft of nomatic buddy bots. oscar_bot is functional if you give it good authentication credentials, jabber_bot is just an example from the web <br />\n</p>\n          </td>\n        </tr>\n        <tr><td colspan=\"2\">\n            <strong>File size:</strong>\n            <span title=\"23052 bytes\">22.5 KB</span>\n          </td></tr>\n      </table>\n      <div id=\"preview\" class=\"searchable\">\n        \n  <table class=\"code\"><thead><tr><th class=\"lineno\" title=\"Line numbers\">Line</th><th class=\"content\">\u00a0</th></tr></thead><tbody><tr><th id=\"L1\"><a href=\"#L1\">1</a></th><td>==========</td></tr><tr><th id=\"L2\"><a href=\"#L2\">2</a></th><td>Interfaces</td></tr><tr><th id=\"L3\"><a href=\"#L3\">3</a></th><td>==========</td></tr><tr><th id=\"L4\"><a href=\"#L4\">4</a></th><td></td></tr><tr><th id=\"L5\"><a href=\"#L5\">5</a></th><td>Interfaces are objects that specify (document) the external behavior</td></tr><tr><th id=\"L6\"><a href=\"#L6\">6</a></th><td>of objects that \"provide\" them.\u00a0 An interface specifies behavior</td></tr><tr><th id=\"L7\"><a href=\"#L7\">7</a></th><td>through:</td></tr><tr><th id=\"L8\"><a href=\"#L8\">8</a></th><td></td></tr><tr><th id=\"L9\"><a href=\"#L9\">9</a></th><td>- Informal documentation in a doc string</td></tr><tr><th id=\"L10\"><a href=\"#L10\">10</a></th><td></td></tr><tr><th id=\"L11\"><a href=\"#L11\">11</a></th><td>- Attribute definitions</td></tr><tr><th id=\"L12\"><a href=\"#L12\">12</a></th><td></td></tr><tr><th id=\"L13\"><a href=\"#L13\">13</a></th><td>- Invariants, which are conditions that must hold for objects that</td></tr><tr><th id=\"L14\"><a href=\"#L14\">14</a></th><td>\u00a0 provide the interface</td></tr><tr><th id=\"L15\"><a href=\"#L15\">15</a></th><td></td></tr><tr><th id=\"L16\"><a href=\"#L16\">16</a></th><td>Attribute definitions specify specific attributes. They define the</td></tr><tr><th id=\"L17\"><a href=\"#L17\">17</a></th><td>attribute name and provide documentation and constraints of attribute</td></tr><tr><th id=\"L18\"><a href=\"#L18\">18</a></th><td>values.\u00a0 Attribute definitions can take a number of forms, as we'll</td></tr><tr><th id=\"L19\"><a href=\"#L19\">19</a></th><td>see below.</td></tr><tr><th id=\"L20\"><a href=\"#L20\">20</a></th><td></td></tr><tr><th id=\"L21\"><a href=\"#L21\">21</a></th><td>Defining interfaces</td></tr><tr><th id=\"L22\"><a href=\"#L22\">22</a></th><td>===================</td></tr><tr><th id=\"L23\"><a href=\"#L23\">23</a></th><td></td></tr><tr><th id=\"L24\"><a href=\"#L24\">24</a></th><td>Interfaces are defined using Python class statements:</td></tr><tr><th id=\"L25\"><a href=\"#L25\">25</a></th><td></td></tr><tr><th id=\"L26\"><a href=\"#L26\">26</a></th><td>\u00a0 &gt;&gt;&gt; import zope.interface</td></tr><tr><th id=\"L27\"><a href=\"#L27\">27</a></th><td>\u00a0 &gt;&gt;&gt; class IFoo(zope.interface.Interface):</td></tr><tr><th id=\"L28\"><a href=\"#L28\">28</a></th><td>\u00a0 ...\u00a0 \u00a0 \"\"\"Foo blah blah\"\"\"</td></tr><tr><th id=\"L29\"><a href=\"#L29\">29</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L30\"><a href=\"#L30\">30</a></th><td>\u00a0 ...\u00a0 \u00a0 x = zope.interface.Attribute(\"\"\"X blah blah\"\"\")</td></tr><tr><th id=\"L31\"><a href=\"#L31\">31</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L32\"><a href=\"#L32\">32</a></th><td>\u00a0 ...\u00a0 \u00a0 def bar(q, r=None):</td></tr><tr><th id=\"L33\"><a href=\"#L33\">33</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \"\"\"bar blah blah\"\"\"</td></tr><tr><th id=\"L34\"><a href=\"#L34\">34</a></th><td></td></tr><tr><th id=\"L35\"><a href=\"#L35\">35</a></th><td>In the example above, we've created an interface, `IFoo`.\u00a0 We</td></tr><tr><th id=\"L36\"><a href=\"#L36\">36</a></th><td>subclassed `zope.interface.Interface`, which is an ancestor interface for</td></tr><tr><th id=\"L37\"><a href=\"#L37\">37</a></th><td>all interfaces, much as `object` is an ancestor of all new-style</td></tr><tr><th id=\"L38\"><a href=\"#L38\">38</a></th><td>classes [#create]_.\u00a0 \u00a0The interface is not a class, it's an Interface,</td></tr><tr><th id=\"L39\"><a href=\"#L39\">39</a></th><td>an instance of `InterfaceClass`::</td></tr><tr><th id=\"L40\"><a href=\"#L40\">40</a></th><td></td></tr><tr><th id=\"L41\"><a href=\"#L41\">41</a></th><td>\u00a0 &gt;&gt;&gt; type(IFoo)</td></tr><tr><th id=\"L42\"><a href=\"#L42\">42</a></th><td>\u00a0 &lt;class 'zope.interface.interface.InterfaceClass'&gt;</td></tr><tr><th id=\"L43\"><a href=\"#L43\">43</a></th><td></td></tr><tr><th id=\"L44\"><a href=\"#L44\">44</a></th><td>We can ask for the interface's documentation::</td></tr><tr><th id=\"L45\"><a href=\"#L45\">45</a></th><td></td></tr><tr><th id=\"L46\"><a href=\"#L46\">46</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.__doc__</td></tr><tr><th id=\"L47\"><a href=\"#L47\">47</a></th><td>\u00a0 'Foo blah blah'</td></tr><tr><th id=\"L48\"><a href=\"#L48\">48</a></th><td></td></tr><tr><th id=\"L49\"><a href=\"#L49\">49</a></th><td>and its name::</td></tr><tr><th id=\"L50\"><a href=\"#L50\">50</a></th><td></td></tr><tr><th id=\"L51\"><a href=\"#L51\">51</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.__name__</td></tr><tr><th id=\"L52\"><a href=\"#L52\">52</a></th><td>\u00a0 'IFoo'</td></tr><tr><th id=\"L53\"><a href=\"#L53\">53</a></th><td></td></tr><tr><th id=\"L54\"><a href=\"#L54\">54</a></th><td>and even its module::</td></tr><tr><th id=\"L55\"><a href=\"#L55\">55</a></th><td></td></tr><tr><th id=\"L56\"><a href=\"#L56\">56</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.__module__</td></tr><tr><th id=\"L57\"><a href=\"#L57\">57</a></th><td>\u00a0 '__main__'</td></tr><tr><th id=\"L58\"><a href=\"#L58\">58</a></th><td></td></tr><tr><th id=\"L59\"><a href=\"#L59\">59</a></th><td>The interface defined two attributes:</td></tr><tr><th id=\"L60\"><a href=\"#L60\">60</a></th><td></td></tr><tr><th id=\"L61\"><a href=\"#L61\">61</a></th><td>`x`</td></tr><tr><th id=\"L62\"><a href=\"#L62\">62</a></th><td>\u00a0 This is the simplest form of attribute definition.\u00a0 It has a name</td></tr><tr><th id=\"L63\"><a href=\"#L63\">63</a></th><td>\u00a0 and a doc string.\u00a0 It doesn't formally specify anything else.</td></tr><tr><th id=\"L64\"><a href=\"#L64\">64</a></th><td></td></tr><tr><th id=\"L65\"><a href=\"#L65\">65</a></th><td>`bar`</td></tr><tr><th id=\"L66\"><a href=\"#L66\">66</a></th><td>\u00a0 This is a method.\u00a0 A method is defined via a function definition.\u00a0 A</td></tr><tr><th id=\"L67\"><a href=\"#L67\">67</a></th><td>\u00a0 method is simply an attribute constrained to be a callable with a</td></tr><tr><th id=\"L68\"><a href=\"#L68\">68</a></th><td>\u00a0 particular signature, as provided by the function definition.</td></tr><tr><th id=\"L69\"><a href=\"#L69\">69</a></th><td></td></tr><tr><th id=\"L70\"><a href=\"#L70\">70</a></th><td>\u00a0 Note that `bar` doesn't take a `self` argument.\u00a0 Interfaces document</td></tr><tr><th id=\"L71\"><a href=\"#L71\">71</a></th><td>\u00a0 how an object is *used*.\u00a0 When calling instance methods, you don't</td></tr><tr><th id=\"L72\"><a href=\"#L72\">72</a></th><td>\u00a0 pass a `self` argument, so a `self` argument isn't included in the</td></tr><tr><th id=\"L73\"><a href=\"#L73\">73</a></th><td>\u00a0 interface signature.\u00a0 The `self` argument in instance methods is</td></tr><tr><th id=\"L74\"><a href=\"#L74\">74</a></th><td>\u00a0 really an implementation detail of Python instances. Other objects,</td></tr><tr><th id=\"L75\"><a href=\"#L75\">75</a></th><td>\u00a0 besides instances can provide interfaces and their methods might not</td></tr><tr><th id=\"L76\"><a href=\"#L76\">76</a></th><td>\u00a0 be instance methods. For example, modules can provide interfaces and</td></tr><tr><th id=\"L77\"><a href=\"#L77\">77</a></th><td>\u00a0 their methods are usually just functions.\u00a0 Even instances can have</td></tr><tr><th id=\"L78\"><a href=\"#L78\">78</a></th><td>\u00a0 methods that are not instance methods.</td></tr><tr><th id=\"L79\"><a href=\"#L79\">79</a></th><td></td></tr><tr><th id=\"L80\"><a href=\"#L80\">80</a></th><td>You can access the attributes defined by an interface using mapping</td></tr><tr><th id=\"L81\"><a href=\"#L81\">81</a></th><td>syntax::</td></tr><tr><th id=\"L82\"><a href=\"#L82\">82</a></th><td></td></tr><tr><th id=\"L83\"><a href=\"#L83\">83</a></th><td>\u00a0 &gt;&gt;&gt; x = IFoo['x']</td></tr><tr><th id=\"L84\"><a href=\"#L84\">84</a></th><td>\u00a0 &gt;&gt;&gt; type(x)</td></tr><tr><th id=\"L85\"><a href=\"#L85\">85</a></th><td>\u00a0 &lt;class 'zope.interface.interface.Attribute'&gt;</td></tr><tr><th id=\"L86\"><a href=\"#L86\">86</a></th><td>\u00a0 &gt;&gt;&gt; x.__name__</td></tr><tr><th id=\"L87\"><a href=\"#L87\">87</a></th><td>\u00a0 'x'</td></tr><tr><th id=\"L88\"><a href=\"#L88\">88</a></th><td>\u00a0 &gt;&gt;&gt; x.__doc__</td></tr><tr><th id=\"L89\"><a href=\"#L89\">89</a></th><td>\u00a0 'X blah blah'</td></tr><tr><th id=\"L90\"><a href=\"#L90\">90</a></th><td></td></tr><tr><th id=\"L91\"><a href=\"#L91\">91</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.get('x').__name__</td></tr><tr><th id=\"L92\"><a href=\"#L92\">92</a></th><td>\u00a0 'x'</td></tr><tr><th id=\"L93\"><a href=\"#L93\">93</a></th><td></td></tr><tr><th id=\"L94\"><a href=\"#L94\">94</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.get('y')</td></tr><tr><th id=\"L95\"><a href=\"#L95\">95</a></th><td></td></tr><tr><th id=\"L96\"><a href=\"#L96\">96</a></th><td>You can use `in` to determine if an interface defines a name::</td></tr><tr><th id=\"L97\"><a href=\"#L97\">97</a></th><td></td></tr><tr><th id=\"L98\"><a href=\"#L98\">98</a></th><td>\u00a0 &gt;&gt;&gt; 'x' in IFoo</td></tr><tr><th id=\"L99\"><a href=\"#L99\">99</a></th><td>\u00a0 True</td></tr><tr><th id=\"L100\"><a href=\"#L100\">100</a></th><td></td></tr><tr><th id=\"L101\"><a href=\"#L101\">101</a></th><td>You can iterate over interfaces to get the names they define::</td></tr><tr><th id=\"L102\"><a href=\"#L102\">102</a></th><td></td></tr><tr><th id=\"L103\"><a href=\"#L103\">103</a></th><td>\u00a0 &gt;&gt;&gt; names = list(IFoo)</td></tr><tr><th id=\"L104\"><a href=\"#L104\">104</a></th><td>\u00a0 &gt;&gt;&gt; names.sort()</td></tr><tr><th id=\"L105\"><a href=\"#L105\">105</a></th><td>\u00a0 &gt;&gt;&gt; names</td></tr><tr><th id=\"L106\"><a href=\"#L106\">106</a></th><td>\u00a0 ['bar', 'x']</td></tr><tr><th id=\"L107\"><a href=\"#L107\">107</a></th><td></td></tr><tr><th id=\"L108\"><a href=\"#L108\">108</a></th><td>Remember that interfaces aren't classes. You can't access attribute</td></tr><tr><th id=\"L109\"><a href=\"#L109\">109</a></th><td>definitions as attributes of interfaces::</td></tr><tr><th id=\"L110\"><a href=\"#L110\">110</a></th><td></td></tr><tr><th id=\"L111\"><a href=\"#L111\">111</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.x</td></tr><tr><th id=\"L112\"><a href=\"#L112\">112</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L113\"><a href=\"#L113\">113</a></th><td>\u00a0 \u00a0 File \"&lt;stdin&gt;\", line 1, in ?</td></tr><tr><th id=\"L114\"><a href=\"#L114\">114</a></th><td>\u00a0 AttributeError: 'InterfaceClass' object has no attribute 'x'</td></tr><tr><th id=\"L115\"><a href=\"#L115\">115</a></th><td></td></tr><tr><th id=\"L116\"><a href=\"#L116\">116</a></th><td>Methods provide access to the method signature::</td></tr><tr><th id=\"L117\"><a href=\"#L117\">117</a></th><td></td></tr><tr><th id=\"L118\"><a href=\"#L118\">118</a></th><td>\u00a0 &gt;&gt;&gt; bar = IFoo['bar']</td></tr><tr><th id=\"L119\"><a href=\"#L119\">119</a></th><td>\u00a0 &gt;&gt;&gt; bar.getSignatureString()</td></tr><tr><th id=\"L120\"><a href=\"#L120\">120</a></th><td>\u00a0 '(q, r=None)'</td></tr><tr><th id=\"L121\"><a href=\"#L121\">121</a></th><td></td></tr><tr><th id=\"L122\"><a href=\"#L122\">122</a></th><td>TODO</td></tr><tr><th id=\"L123\"><a href=\"#L123\">123</a></th><td>\u00a0 Methods really should have a better API.\u00a0 This is something that</td></tr><tr><th id=\"L124\"><a href=\"#L124\">124</a></th><td>\u00a0 needs to be improved.</td></tr><tr><th id=\"L125\"><a href=\"#L125\">125</a></th><td></td></tr><tr><th id=\"L126\"><a href=\"#L126\">126</a></th><td>Declaring interfaces</td></tr><tr><th id=\"L127\"><a href=\"#L127\">127</a></th><td>====================</td></tr><tr><th id=\"L128\"><a href=\"#L128\">128</a></th><td></td></tr><tr><th id=\"L129\"><a href=\"#L129\">129</a></th><td>Having defined interfaces, we can *declare* that objects provide</td></tr><tr><th id=\"L130\"><a href=\"#L130\">130</a></th><td>them.\u00a0 Before we describe the details, lets define some terms:</td></tr><tr><th id=\"L131\"><a href=\"#L131\">131</a></th><td></td></tr><tr><th id=\"L132\"><a href=\"#L132\">132</a></th><td>*provide*</td></tr><tr><th id=\"L133\"><a href=\"#L133\">133</a></th><td>\u00a0 \u00a0We say that objects *provide* interfaces.\u00a0 If an object provides an</td></tr><tr><th id=\"L134\"><a href=\"#L134\">134</a></th><td>\u00a0 \u00a0interface, then the interface specifies the behavior of the</td></tr><tr><th id=\"L135\"><a href=\"#L135\">135</a></th><td>\u00a0 \u00a0object. In other words, interfaces specify the behavior of the</td></tr><tr><th id=\"L136\"><a href=\"#L136\">136</a></th><td>\u00a0 \u00a0objects that provide them.</td></tr><tr><th id=\"L137\"><a href=\"#L137\">137</a></th><td></td></tr><tr><th id=\"L138\"><a href=\"#L138\">138</a></th><td>*implement*</td></tr><tr><th id=\"L139\"><a href=\"#L139\">139</a></th><td>\u00a0 \u00a0We normally say that classes *implement* interfaces.\u00a0 If a class</td></tr><tr><th id=\"L140\"><a href=\"#L140\">140</a></th><td>\u00a0 \u00a0implements an interface, then the instances of the class provide</td></tr><tr><th id=\"L141\"><a href=\"#L141\">141</a></th><td>\u00a0 \u00a0the interface.\u00a0 Objects provide interfaces that their classes</td></tr><tr><th id=\"L142\"><a href=\"#L142\">142</a></th><td>\u00a0 \u00a0implement [#factory]_.\u00a0 (Objects can provide interfaces directly,</td></tr><tr><th id=\"L143\"><a href=\"#L143\">143</a></th><td>\u00a0 \u00a0in addition to what their classes implement.)</td></tr><tr><th id=\"L144\"><a href=\"#L144\">144</a></th><td></td></tr><tr><th id=\"L145\"><a href=\"#L145\">145</a></th><td>\u00a0 \u00a0It is important to note that classes don't usually provide the</td></tr><tr><th id=\"L146\"><a href=\"#L146\">146</a></th><td>\u00a0 \u00a0interfaces that they implement.</td></tr><tr><th id=\"L147\"><a href=\"#L147\">147</a></th><td></td></tr><tr><th id=\"L148\"><a href=\"#L148\">148</a></th><td>\u00a0 \u00a0We can generalize this to factories.\u00a0 For any callable object we</td></tr><tr><th id=\"L149\"><a href=\"#L149\">149</a></th><td>\u00a0 \u00a0can declare that it produces objects that provide some interfaces</td></tr><tr><th id=\"L150\"><a href=\"#L150\">150</a></th><td>\u00a0 \u00a0by saying that the factory implements the interfaces.</td></tr><tr><th id=\"L151\"><a href=\"#L151\">151</a></th><td></td></tr><tr><th id=\"L152\"><a href=\"#L152\">152</a></th><td>Now that we've defined these terms, we can talk about the API for</td></tr><tr><th id=\"L153\"><a href=\"#L153\">153</a></th><td>declaring interfaces.</td></tr><tr><th id=\"L154\"><a href=\"#L154\">154</a></th><td></td></tr><tr><th id=\"L155\"><a href=\"#L155\">155</a></th><td>Declaring implemented interfaces</td></tr><tr><th id=\"L156\"><a href=\"#L156\">156</a></th><td>--------------------------------</td></tr><tr><th id=\"L157\"><a href=\"#L157\">157</a></th><td></td></tr><tr><th id=\"L158\"><a href=\"#L158\">158</a></th><td>The most common way to declare interfaces is using the implements</td></tr><tr><th id=\"L159\"><a href=\"#L159\">159</a></th><td>function in a class statement::</td></tr><tr><th id=\"L160\"><a href=\"#L160\">160</a></th><td></td></tr><tr><th id=\"L161\"><a href=\"#L161\">161</a></th><td>\u00a0 &gt;&gt;&gt; class Foo:</td></tr><tr><th id=\"L162\"><a href=\"#L162\">162</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(IFoo)</td></tr><tr><th id=\"L163\"><a href=\"#L163\">163</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L164\"><a href=\"#L164\">164</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __init__(self, x=None):</td></tr><tr><th id=\"L165\"><a href=\"#L165\">165</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0self.x = x</td></tr><tr><th id=\"L166\"><a href=\"#L166\">166</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L167\"><a href=\"#L167\">167</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def bar(self, q, r=None):</td></tr><tr><th id=\"L168\"><a href=\"#L168\">168</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return q, r, self.x</td></tr><tr><th id=\"L169\"><a href=\"#L169\">169</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L170\"><a href=\"#L170\">170</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __repr__(self):</td></tr><tr><th id=\"L171\"><a href=\"#L171\">171</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"Foo(%s)\" % self.x</td></tr><tr><th id=\"L172\"><a href=\"#L172\">172</a></th><td></td></tr><tr><th id=\"L173\"><a href=\"#L173\">173</a></th><td></td></tr><tr><th id=\"L174\"><a href=\"#L174\">174</a></th><td>In this example, we declared that `Foo` implements `IFoo`. This means</td></tr><tr><th id=\"L175\"><a href=\"#L175\">175</a></th><td>that instances of `Foo` provide `IFoo`.\u00a0 Having made this declaration,</td></tr><tr><th id=\"L176\"><a href=\"#L176\">176</a></th><td>there are several ways we can introspect the declarations.\u00a0 First, we</td></tr><tr><th id=\"L177\"><a href=\"#L177\">177</a></th><td>can ask an interface whether it is implemented by a class::</td></tr><tr><th id=\"L178\"><a href=\"#L178\">178</a></th><td></td></tr><tr><th id=\"L179\"><a href=\"#L179\">179</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.implementedBy(Foo)</td></tr><tr><th id=\"L180\"><a href=\"#L180\">180</a></th><td>\u00a0 True</td></tr><tr><th id=\"L181\"><a href=\"#L181\">181</a></th><td></td></tr><tr><th id=\"L182\"><a href=\"#L182\">182</a></th><td>And we can ask whether an interface is provided by an object::</td></tr><tr><th id=\"L183\"><a href=\"#L183\">183</a></th><td></td></tr><tr><th id=\"L184\"><a href=\"#L184\">184</a></th><td>\u00a0 &gt;&gt;&gt; foo = Foo()</td></tr><tr><th id=\"L185\"><a href=\"#L185\">185</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.providedBy(foo)</td></tr><tr><th id=\"L186\"><a href=\"#L186\">186</a></th><td>\u00a0 True</td></tr><tr><th id=\"L187\"><a href=\"#L187\">187</a></th><td></td></tr><tr><th id=\"L188\"><a href=\"#L188\">188</a></th><td>Of course, `Foo` doesn't provide `IFoo`, it implements it::</td></tr><tr><th id=\"L189\"><a href=\"#L189\">189</a></th><td></td></tr><tr><th id=\"L190\"><a href=\"#L190\">190</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.providedBy(Foo)</td></tr><tr><th id=\"L191\"><a href=\"#L191\">191</a></th><td>\u00a0 False</td></tr><tr><th id=\"L192\"><a href=\"#L192\">192</a></th><td></td></tr><tr><th id=\"L193\"><a href=\"#L193\">193</a></th><td>We can also ask what interfaces are implemented by an object::</td></tr><tr><th id=\"L194\"><a href=\"#L194\">194</a></th><td></td></tr><tr><th id=\"L195\"><a href=\"#L195\">195</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(Foo))</td></tr><tr><th id=\"L196\"><a href=\"#L196\">196</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L197\"><a href=\"#L197\">197</a></th><td></td></tr><tr><th id=\"L198\"><a href=\"#L198\">198</a></th><td>It's an error to ask for interfaces implemented by a non-callable</td></tr><tr><th id=\"L199\"><a href=\"#L199\">199</a></th><td>object::</td></tr><tr><th id=\"L200\"><a href=\"#L200\">200</a></th><td></td></tr><tr><th id=\"L201\"><a href=\"#L201\">201</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.implementedBy(foo)</td></tr><tr><th id=\"L202\"><a href=\"#L202\">202</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L203\"><a href=\"#L203\">203</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L204\"><a href=\"#L204\">204</a></th><td>\u00a0 TypeError: ('ImplementedBy called for non-factory', Foo(None))</td></tr><tr><th id=\"L205\"><a href=\"#L205\">205</a></th><td></td></tr><tr><th id=\"L206\"><a href=\"#L206\">206</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(foo))</td></tr><tr><th id=\"L207\"><a href=\"#L207\">207</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L208\"><a href=\"#L208\">208</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L209\"><a href=\"#L209\">209</a></th><td>\u00a0 TypeError: ('ImplementedBy called for non-factory', Foo(None))</td></tr><tr><th id=\"L210\"><a href=\"#L210\">210</a></th><td></td></tr><tr><th id=\"L211\"><a href=\"#L211\">211</a></th><td>Similarly, we can ask what interfaces are provided by an object::</td></tr><tr><th id=\"L212\"><a href=\"#L212\">212</a></th><td></td></tr><tr><th id=\"L213\"><a href=\"#L213\">213</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(foo))</td></tr><tr><th id=\"L214\"><a href=\"#L214\">214</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L215\"><a href=\"#L215\">215</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(Foo))</td></tr><tr><th id=\"L216\"><a href=\"#L216\">216</a></th><td>\u00a0 []</td></tr><tr><th id=\"L217\"><a href=\"#L217\">217</a></th><td></td></tr><tr><th id=\"L218\"><a href=\"#L218\">218</a></th><td>We can declare interfaces implemented by other factories (besides</td></tr><tr><th id=\"L219\"><a href=\"#L219\">219</a></th><td>classes).\u00a0 We do this using a Python-2.4-style decorator named</td></tr><tr><th id=\"L220\"><a href=\"#L220\">220</a></th><td>`implementer`.\u00a0 In versions of Python before 2.4, this looks like:</td></tr><tr><th id=\"L221\"><a href=\"#L221\">221</a></th><td></td></tr><tr><th id=\"L222\"><a href=\"#L222\">222</a></th><td></td></tr><tr><th id=\"L223\"><a href=\"#L223\">223</a></th><td>\u00a0 &gt;&gt;&gt; def yfoo(y):</td></tr><tr><th id=\"L224\"><a href=\"#L224\">224</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0foo = Foo()</td></tr><tr><th id=\"L225\"><a href=\"#L225\">225</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0foo.y = y</td></tr><tr><th id=\"L226\"><a href=\"#L226\">226</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0return foo</td></tr><tr><th id=\"L227\"><a href=\"#L227\">227</a></th><td>\u00a0 &gt;&gt;&gt; yfoo = zope.interface.implementer(IFoo)(yfoo)</td></tr><tr><th id=\"L228\"><a href=\"#L228\">228</a></th><td></td></tr><tr><th id=\"L229\"><a href=\"#L229\">229</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(yfoo))</td></tr><tr><th id=\"L230\"><a href=\"#L230\">230</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L231\"><a href=\"#L231\">231</a></th><td></td></tr><tr><th id=\"L232\"><a href=\"#L232\">232</a></th><td>Note that the implementer decorator may modify it's argument. Callers</td></tr><tr><th id=\"L233\"><a href=\"#L233\">233</a></th><td>should not assume that a new object is created.</td></tr><tr><th id=\"L234\"><a href=\"#L234\">234</a></th><td></td></tr><tr><th id=\"L235\"><a href=\"#L235\">235</a></th><td>Also note that, at least for now, implementer can't be used with</td></tr><tr><th id=\"L236\"><a href=\"#L236\">236</a></th><td>classes:</td></tr><tr><th id=\"L237\"><a href=\"#L237\">237</a></th><td></td></tr><tr><th id=\"L238\"><a href=\"#L238\">238</a></th><td>\u00a0 &gt;&gt;&gt; zope.interface.implementer(IFoo)(Foo)</td></tr><tr><th id=\"L239\"><a href=\"#L239\">239</a></th><td>\u00a0 ... # doctest: +NORMALIZE_WHITESPACE</td></tr><tr><th id=\"L240\"><a href=\"#L240\">240</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L241\"><a href=\"#L241\">241</a></th><td>\u00a0 \u00a0 ...</td></tr><tr><th id=\"L242\"><a href=\"#L242\">242</a></th><td>\u00a0 TypeError: Can't use implementer with classes.</td></tr><tr><th id=\"L243\"><a href=\"#L243\">243</a></th><td>\u00a0 Use one of the class-declaration functions instead.</td></tr><tr><th id=\"L244\"><a href=\"#L244\">244</a></th><td></td></tr><tr><th id=\"L245\"><a href=\"#L245\">245</a></th><td>Declaring provided interfaces</td></tr><tr><th id=\"L246\"><a href=\"#L246\">246</a></th><td>-----------------------------</td></tr><tr><th id=\"L247\"><a href=\"#L247\">247</a></th><td></td></tr><tr><th id=\"L248\"><a href=\"#L248\">248</a></th><td>We can declare interfaces directly provided by objects.\u00a0 Suppose that</td></tr><tr><th id=\"L249\"><a href=\"#L249\">249</a></th><td>we want to document what the `__init__` method of the `Foo` class</td></tr><tr><th id=\"L250\"><a href=\"#L250\">250</a></th><td>does.\u00a0 It's not *really* part of `IFoo`.\u00a0 You wouldn't normally call</td></tr><tr><th id=\"L251\"><a href=\"#L251\">251</a></th><td>the `__init__` method on Foo instances.\u00a0 Rather, the `__init__` method</td></tr><tr><th id=\"L252\"><a href=\"#L252\">252</a></th><td>is part of the `Foo`'s `__call__` method::</td></tr><tr><th id=\"L253\"><a href=\"#L253\">253</a></th><td></td></tr><tr><th id=\"L254\"><a href=\"#L254\">254</a></th><td>\u00a0 &gt;&gt;&gt; class IFooFactory(zope.interface.Interface):</td></tr><tr><th id=\"L255\"><a href=\"#L255\">255</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0\"\"\"Create foos\"\"\"</td></tr><tr><th id=\"L256\"><a href=\"#L256\">256</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L257\"><a href=\"#L257\">257</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __call__(x=None):</td></tr><tr><th id=\"L258\"><a href=\"#L258\">258</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\"\"Create a foo</td></tr><tr><th id=\"L259\"><a href=\"#L259\">259</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L260\"><a href=\"#L260\">260</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0The argument provides the initial value for x ...</td></tr><tr><th id=\"L261\"><a href=\"#L261\">261</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\"\"</td></tr><tr><th id=\"L262\"><a href=\"#L262\">262</a></th><td></td></tr><tr><th id=\"L263\"><a href=\"#L263\">263</a></th><td>It's the class that provides this interface, so we declare the</td></tr><tr><th id=\"L264\"><a href=\"#L264\">264</a></th><td>interface on the class::</td></tr><tr><th id=\"L265\"><a href=\"#L265\">265</a></th><td></td></tr><tr><th id=\"L266\"><a href=\"#L266\">266</a></th><td>\u00a0 &gt;&gt;&gt; zope.interface.directlyProvides(Foo, IFooFactory)</td></tr><tr><th id=\"L267\"><a href=\"#L267\">267</a></th><td></td></tr><tr><th id=\"L268\"><a href=\"#L268\">268</a></th><td>And then, we'll see that Foo provides some interfaces::</td></tr><tr><th id=\"L269\"><a href=\"#L269\">269</a></th><td></td></tr><tr><th id=\"L270\"><a href=\"#L270\">270</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(Foo))</td></tr><tr><th id=\"L271\"><a href=\"#L271\">271</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFooFactory&gt;]</td></tr><tr><th id=\"L272\"><a href=\"#L272\">272</a></th><td>\u00a0 &gt;&gt;&gt; IFooFactory.providedBy(Foo)</td></tr><tr><th id=\"L273\"><a href=\"#L273\">273</a></th><td>\u00a0 True</td></tr><tr><th id=\"L274\"><a href=\"#L274\">274</a></th><td></td></tr><tr><th id=\"L275\"><a href=\"#L275\">275</a></th><td>Declaring class interfaces is common enough that there's a special</td></tr><tr><th id=\"L276\"><a href=\"#L276\">276</a></th><td>declaration function for it, `classProvides`, that allows the</td></tr><tr><th id=\"L277\"><a href=\"#L277\">277</a></th><td>declaration from within a class statement::</td></tr><tr><th id=\"L278\"><a href=\"#L278\">278</a></th><td></td></tr><tr><th id=\"L279\"><a href=\"#L279\">279</a></th><td>\u00a0 &gt;&gt;&gt; class Foo2:</td></tr><tr><th id=\"L280\"><a href=\"#L280\">280</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(IFoo)</td></tr><tr><th id=\"L281\"><a href=\"#L281\">281</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.classProvides(IFooFactory)</td></tr><tr><th id=\"L282\"><a href=\"#L282\">282</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L283\"><a href=\"#L283\">283</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __init__(self, x=None):</td></tr><tr><th id=\"L284\"><a href=\"#L284\">284</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0self.x = x</td></tr><tr><th id=\"L285\"><a href=\"#L285\">285</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L286\"><a href=\"#L286\">286</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def bar(self, q, r=None):</td></tr><tr><th id=\"L287\"><a href=\"#L287\">287</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return q, r, self.x</td></tr><tr><th id=\"L288\"><a href=\"#L288\">288</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L289\"><a href=\"#L289\">289</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __repr__(self):</td></tr><tr><th id=\"L290\"><a href=\"#L290\">290</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"Foo(%s)\" % self.x</td></tr><tr><th id=\"L291\"><a href=\"#L291\">291</a></th><td></td></tr><tr><th id=\"L292\"><a href=\"#L292\">292</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(Foo2))</td></tr><tr><th id=\"L293\"><a href=\"#L293\">293</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFooFactory&gt;]</td></tr><tr><th id=\"L294\"><a href=\"#L294\">294</a></th><td>\u00a0 &gt;&gt;&gt; IFooFactory.providedBy(Foo2)</td></tr><tr><th id=\"L295\"><a href=\"#L295\">295</a></th><td>\u00a0 True</td></tr><tr><th id=\"L296\"><a href=\"#L296\">296</a></th><td></td></tr><tr><th id=\"L297\"><a href=\"#L297\">297</a></th><td>There's a similar function, `moduleProvides`, that supports interface</td></tr><tr><th id=\"L298\"><a href=\"#L298\">298</a></th><td>declarations from within module definitions.\u00a0 For example, see the use</td></tr><tr><th id=\"L299\"><a href=\"#L299\">299</a></th><td>of `moduleProvides` call in `zope.interface.__init__`, which declares that</td></tr><tr><th id=\"L300\"><a href=\"#L300\">300</a></th><td>the package `zope.interface` provides `IInterfaceDeclaration`.</td></tr><tr><th id=\"L301\"><a href=\"#L301\">301</a></th><td></td></tr><tr><th id=\"L302\"><a href=\"#L302\">302</a></th><td>Sometimes, we want to declare interfaces on instances, even though</td></tr><tr><th id=\"L303\"><a href=\"#L303\">303</a></th><td>those instances get interfaces from their classes.\u00a0 Suppose we create</td></tr><tr><th id=\"L304\"><a href=\"#L304\">304</a></th><td>a new interface, `ISpecial`::</td></tr><tr><th id=\"L305\"><a href=\"#L305\">305</a></th><td></td></tr><tr><th id=\"L306\"><a href=\"#L306\">306</a></th><td>\u00a0 &gt;&gt;&gt; class ISpecial(zope.interface.Interface):</td></tr><tr><th id=\"L307\"><a href=\"#L307\">307</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0reason = zope.interface.Attribute(\"Reason why we're special\")</td></tr><tr><th id=\"L308\"><a href=\"#L308\">308</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def brag():</td></tr><tr><th id=\"L309\"><a href=\"#L309\">309</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"Brag about being special\"</td></tr><tr><th id=\"L310\"><a href=\"#L310\">310</a></th><td></td></tr><tr><th id=\"L311\"><a href=\"#L311\">311</a></th><td>We can make an existing foo instance special by providing `reason`</td></tr><tr><th id=\"L312\"><a href=\"#L312\">312</a></th><td>and `brag` attributes::</td></tr><tr><th id=\"L313\"><a href=\"#L313\">313</a></th><td></td></tr><tr><th id=\"L314\"><a href=\"#L314\">314</a></th><td>\u00a0 &gt;&gt;&gt; foo.reason = 'I just am'</td></tr><tr><th id=\"L315\"><a href=\"#L315\">315</a></th><td>\u00a0 &gt;&gt;&gt; def brag():</td></tr><tr><th id=\"L316\"><a href=\"#L316\">316</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 return \"I'm special!\"</td></tr><tr><th id=\"L317\"><a href=\"#L317\">317</a></th><td>\u00a0 &gt;&gt;&gt; foo.brag = brag</td></tr><tr><th id=\"L318\"><a href=\"#L318\">318</a></th><td>\u00a0 &gt;&gt;&gt; foo.reason</td></tr><tr><th id=\"L319\"><a href=\"#L319\">319</a></th><td>\u00a0 'I just am'</td></tr><tr><th id=\"L320\"><a href=\"#L320\">320</a></th><td>\u00a0 &gt;&gt;&gt; foo.brag()</td></tr><tr><th id=\"L321\"><a href=\"#L321\">321</a></th><td>\u00a0 \"I'm special!\"</td></tr><tr><th id=\"L322\"><a href=\"#L322\">322</a></th><td></td></tr><tr><th id=\"L323\"><a href=\"#L323\">323</a></th><td>and by declaring the interface::</td></tr><tr><th id=\"L324\"><a href=\"#L324\">324</a></th><td></td></tr><tr><th id=\"L325\"><a href=\"#L325\">325</a></th><td>\u00a0 &gt;&gt;&gt; zope.interface.directlyProvides(foo, ISpecial)</td></tr><tr><th id=\"L326\"><a href=\"#L326\">326</a></th><td></td></tr><tr><th id=\"L327\"><a href=\"#L327\">327</a></th><td>then the new interface is included in the provided interfaces::</td></tr><tr><th id=\"L328\"><a href=\"#L328\">328</a></th><td></td></tr><tr><th id=\"L329\"><a href=\"#L329\">329</a></th><td>\u00a0 &gt;&gt;&gt; ISpecial.providedBy(foo)</td></tr><tr><th id=\"L330\"><a href=\"#L330\">330</a></th><td>\u00a0 True</td></tr><tr><th id=\"L331\"><a href=\"#L331\">331</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(foo))</td></tr><tr><th id=\"L332\"><a href=\"#L332\">332</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;, &lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L333\"><a href=\"#L333\">333</a></th><td></td></tr><tr><th id=\"L334\"><a href=\"#L334\">334</a></th><td>We can find out what interfaces are directly provided by an object::</td></tr><tr><th id=\"L335\"><a href=\"#L335\">335</a></th><td></td></tr><tr><th id=\"L336\"><a href=\"#L336\">336</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.directlyProvidedBy(foo))</td></tr><tr><th id=\"L337\"><a href=\"#L337\">337</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;]</td></tr><tr><th id=\"L338\"><a href=\"#L338\">338</a></th><td></td></tr><tr><th id=\"L339\"><a href=\"#L339\">339</a></th><td>\u00a0 &gt;&gt;&gt; newfoo = Foo()</td></tr><tr><th id=\"L340\"><a href=\"#L340\">340</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.directlyProvidedBy(newfoo))</td></tr><tr><th id=\"L341\"><a href=\"#L341\">341</a></th><td>\u00a0 []</td></tr><tr><th id=\"L342\"><a href=\"#L342\">342</a></th><td></td></tr><tr><th id=\"L343\"><a href=\"#L343\">343</a></th><td>Inherited declarations</td></tr><tr><th id=\"L344\"><a href=\"#L344\">344</a></th><td>----------------------</td></tr><tr><th id=\"L345\"><a href=\"#L345\">345</a></th><td></td></tr><tr><th id=\"L346\"><a href=\"#L346\">346</a></th><td>Normally, declarations are inherited::</td></tr><tr><th id=\"L347\"><a href=\"#L347\">347</a></th><td></td></tr><tr><th id=\"L348\"><a href=\"#L348\">348</a></th><td>\u00a0 &gt;&gt;&gt; class SpecialFoo(Foo):</td></tr><tr><th id=\"L349\"><a href=\"#L349\">349</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(ISpecial)</td></tr><tr><th id=\"L350\"><a href=\"#L350\">350</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0reason = 'I just am'</td></tr><tr><th id=\"L351\"><a href=\"#L351\">351</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def brag(self):</td></tr><tr><th id=\"L352\"><a href=\"#L352\">352</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"I'm special because %s\" % self.reason</td></tr><tr><th id=\"L353\"><a href=\"#L353\">353</a></th><td></td></tr><tr><th id=\"L354\"><a href=\"#L354\">354</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(SpecialFoo))</td></tr><tr><th id=\"L355\"><a href=\"#L355\">355</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;, &lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L356\"><a href=\"#L356\">356</a></th><td></td></tr><tr><th id=\"L357\"><a href=\"#L357\">357</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(SpecialFoo()))</td></tr><tr><th id=\"L358\"><a href=\"#L358\">358</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;, &lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L359\"><a href=\"#L359\">359</a></th><td></td></tr><tr><th id=\"L360\"><a href=\"#L360\">360</a></th><td>Sometimes, you don't want to inherit declarations.\u00a0 In that case, you</td></tr><tr><th id=\"L361\"><a href=\"#L361\">361</a></th><td>can use `implementsOnly`, instead of `implements`::</td></tr><tr><th id=\"L362\"><a href=\"#L362\">362</a></th><td></td></tr><tr><th id=\"L363\"><a href=\"#L363\">363</a></th><td>\u00a0 &gt;&gt;&gt; class Special(Foo):</td></tr><tr><th id=\"L364\"><a href=\"#L364\">364</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implementsOnly(ISpecial)</td></tr><tr><th id=\"L365\"><a href=\"#L365\">365</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0reason = 'I just am'</td></tr><tr><th id=\"L366\"><a href=\"#L366\">366</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def brag(self):</td></tr><tr><th id=\"L367\"><a href=\"#L367\">367</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"I'm special because %s\" % self.reason</td></tr><tr><th id=\"L368\"><a href=\"#L368\">368</a></th><td></td></tr><tr><th id=\"L369\"><a href=\"#L369\">369</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(Special))</td></tr><tr><th id=\"L370\"><a href=\"#L370\">370</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;]</td></tr><tr><th id=\"L371\"><a href=\"#L371\">371</a></th><td></td></tr><tr><th id=\"L372\"><a href=\"#L372\">372</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.providedBy(Special()))</td></tr><tr><th id=\"L373\"><a href=\"#L373\">373</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;]</td></tr><tr><th id=\"L374\"><a href=\"#L374\">374</a></th><td></td></tr><tr><th id=\"L375\"><a href=\"#L375\">375</a></th><td>External declarations</td></tr><tr><th id=\"L376\"><a href=\"#L376\">376</a></th><td>---------------------</td></tr><tr><th id=\"L377\"><a href=\"#L377\">377</a></th><td></td></tr><tr><th id=\"L378\"><a href=\"#L378\">378</a></th><td>Normally, we make implementation declarations as part of a class</td></tr><tr><th id=\"L379\"><a href=\"#L379\">379</a></th><td>definition. Sometimes, we may want to make declarations from outside</td></tr><tr><th id=\"L380\"><a href=\"#L380\">380</a></th><td>the class definition. For example, we might want to declare interfaces</td></tr><tr><th id=\"L381\"><a href=\"#L381\">381</a></th><td>for classes that we didn't write.\u00a0 The function `classImplements` can</td></tr><tr><th id=\"L382\"><a href=\"#L382\">382</a></th><td>be used for this purpose::</td></tr><tr><th id=\"L383\"><a href=\"#L383\">383</a></th><td></td></tr><tr><th id=\"L384\"><a href=\"#L384\">384</a></th><td>\u00a0 &gt;&gt;&gt; class C:</td></tr><tr><th id=\"L385\"><a href=\"#L385\">385</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0pass</td></tr><tr><th id=\"L386\"><a href=\"#L386\">386</a></th><td></td></tr><tr><th id=\"L387\"><a href=\"#L387\">387</a></th><td>\u00a0 &gt;&gt;&gt; zope.interface.classImplements(C, IFoo)</td></tr><tr><th id=\"L388\"><a href=\"#L388\">388</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(C))</td></tr><tr><th id=\"L389\"><a href=\"#L389\">389</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFoo&gt;]</td></tr><tr><th id=\"L390\"><a href=\"#L390\">390</a></th><td></td></tr><tr><th id=\"L391\"><a href=\"#L391\">391</a></th><td>We can use `classImplementsOnly` to exclude inherited interfaces::</td></tr><tr><th id=\"L392\"><a href=\"#L392\">392</a></th><td></td></tr><tr><th id=\"L393\"><a href=\"#L393\">393</a></th><td>\u00a0 &gt;&gt;&gt; class C(Foo):</td></tr><tr><th id=\"L394\"><a href=\"#L394\">394</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0pass</td></tr><tr><th id=\"L395\"><a href=\"#L395\">395</a></th><td></td></tr><tr><th id=\"L396\"><a href=\"#L396\">396</a></th><td>\u00a0 &gt;&gt;&gt; zope.interface.classImplementsOnly(C, ISpecial)</td></tr><tr><th id=\"L397\"><a href=\"#L397\">397</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(C))</td></tr><tr><th id=\"L398\"><a href=\"#L398\">398</a></th><td>\u00a0 [&lt;InterfaceClass __main__.ISpecial&gt;]</td></tr><tr><th id=\"L399\"><a href=\"#L399\">399</a></th><td></td></tr><tr><th id=\"L400\"><a href=\"#L400\">400</a></th><td></td></tr><tr><th id=\"L401\"><a href=\"#L401\">401</a></th><td></td></tr><tr><th id=\"L402\"><a href=\"#L402\">402</a></th><td>Declaration Objects</td></tr><tr><th id=\"L403\"><a href=\"#L403\">403</a></th><td>-------------------</td></tr><tr><th id=\"L404\"><a href=\"#L404\">404</a></th><td></td></tr><tr><th id=\"L405\"><a href=\"#L405\">405</a></th><td>When we declare interfaces, we create *declaration* objects.\u00a0 When we</td></tr><tr><th id=\"L406\"><a href=\"#L406\">406</a></th><td>query declarations, declaration objects are returned::</td></tr><tr><th id=\"L407\"><a href=\"#L407\">407</a></th><td></td></tr><tr><th id=\"L408\"><a href=\"#L408\">408</a></th><td>\u00a0 &gt;&gt;&gt; type(zope.interface.implementedBy(Special))</td></tr><tr><th id=\"L409\"><a href=\"#L409\">409</a></th><td>\u00a0 &lt;class 'zope.interface.declarations.Implements'&gt;</td></tr><tr><th id=\"L410\"><a href=\"#L410\">410</a></th><td></td></tr><tr><th id=\"L411\"><a href=\"#L411\">411</a></th><td>Declaration objects and interface objects are similar in many ways. In</td></tr><tr><th id=\"L412\"><a href=\"#L412\">412</a></th><td>fact, they share a common base class.\u00a0 The important thing to realize</td></tr><tr><th id=\"L413\"><a href=\"#L413\">413</a></th><td>about them is that they can be used where interfaces are expected in</td></tr><tr><th id=\"L414\"><a href=\"#L414\">414</a></th><td>declarations. Here's a silly example::</td></tr><tr><th id=\"L415\"><a href=\"#L415\">415</a></th><td></td></tr><tr><th id=\"L416\"><a href=\"#L416\">416</a></th><td>\u00a0 &gt;&gt;&gt; class Special2(Foo):</td></tr><tr><th id=\"L417\"><a href=\"#L417\">417</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implementsOnly(</td></tr><tr><th id=\"L418\"><a href=\"#L418\">418</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 zope.interface.implementedBy(Foo),</td></tr><tr><th id=\"L419\"><a href=\"#L419\">419</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ISpecial,</td></tr><tr><th id=\"L420\"><a href=\"#L420\">420</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 )</td></tr><tr><th id=\"L421\"><a href=\"#L421\">421</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0reason = 'I just am'</td></tr><tr><th id=\"L422\"><a href=\"#L422\">422</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def brag(self):</td></tr><tr><th id=\"L423\"><a href=\"#L423\">423</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"I'm special because %s\" % self.reason</td></tr><tr><th id=\"L424\"><a href=\"#L424\">424</a></th><td></td></tr><tr><th id=\"L425\"><a href=\"#L425\">425</a></th><td>The declaration here is almost the same as</td></tr><tr><th id=\"L426\"><a href=\"#L426\">426</a></th><td>``zope.interface.implements(ISpecial)``, except that the order of</td></tr><tr><th id=\"L427\"><a href=\"#L427\">427</a></th><td>interfaces in the resulting declaration is different::</td></tr><tr><th id=\"L428\"><a href=\"#L428\">428</a></th><td></td></tr><tr><th id=\"L429\"><a href=\"#L429\">429</a></th><td>\u00a0 &gt;&gt;&gt; list(zope.interface.implementedBy(Special2))</td></tr><tr><th id=\"L430\"><a href=\"#L430\">430</a></th><td>\u00a0 [&lt;InterfaceClass __main__.IFoo&gt;, &lt;InterfaceClass __main__.ISpecial&gt;]</td></tr><tr><th id=\"L431\"><a href=\"#L431\">431</a></th><td></td></tr><tr><th id=\"L432\"><a href=\"#L432\">432</a></th><td></td></tr><tr><th id=\"L433\"><a href=\"#L433\">433</a></th><td>Interface Inheritance</td></tr><tr><th id=\"L434\"><a href=\"#L434\">434</a></th><td>=====================</td></tr><tr><th id=\"L435\"><a href=\"#L435\">435</a></th><td></td></tr><tr><th id=\"L436\"><a href=\"#L436\">436</a></th><td>Interfaces can extend other interfaces. They do this simply by listing</td></tr><tr><th id=\"L437\"><a href=\"#L437\">437</a></th><td>the other interfaces as base interfaces::</td></tr><tr><th id=\"L438\"><a href=\"#L438\">438</a></th><td></td></tr><tr><th id=\"L439\"><a href=\"#L439\">439</a></th><td>\u00a0 &gt;&gt;&gt; class IBlat(zope.interface.Interface):</td></tr><tr><th id=\"L440\"><a href=\"#L440\">440</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0\"\"\"Blat blah blah\"\"\"</td></tr><tr><th id=\"L441\"><a href=\"#L441\">441</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L442\"><a href=\"#L442\">442</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0y = zope.interface.Attribute(\"y blah blah\")</td></tr><tr><th id=\"L443\"><a href=\"#L443\">443</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def eek():</td></tr><tr><th id=\"L444\"><a href=\"#L444\">444</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\"\"eek blah blah\"\"\"</td></tr><tr><th id=\"L445\"><a href=\"#L445\">445</a></th><td></td></tr><tr><th id=\"L446\"><a href=\"#L446\">446</a></th><td>\u00a0 &gt;&gt;&gt; IBlat.__bases__</td></tr><tr><th id=\"L447\"><a href=\"#L447\">447</a></th><td>\u00a0 (&lt;InterfaceClass zope.interface.Interface&gt;,)</td></tr><tr><th id=\"L448\"><a href=\"#L448\">448</a></th><td></td></tr><tr><th id=\"L449\"><a href=\"#L449\">449</a></th><td>\u00a0 &gt;&gt;&gt; class IBaz(IFoo, IBlat):</td></tr><tr><th id=\"L450\"><a href=\"#L450\">450</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0\"\"\"Baz blah\"\"\"</td></tr><tr><th id=\"L451\"><a href=\"#L451\">451</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def eek(a=1):</td></tr><tr><th id=\"L452\"><a href=\"#L452\">452</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\"\"eek in baz blah\"\"\"</td></tr><tr><th id=\"L453\"><a href=\"#L453\">453</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L454\"><a href=\"#L454\">454</a></th><td></td></tr><tr><th id=\"L455\"><a href=\"#L455\">455</a></th><td>\u00a0 &gt;&gt;&gt; IBaz.__bases__</td></tr><tr><th id=\"L456\"><a href=\"#L456\">456</a></th><td>\u00a0 (&lt;InterfaceClass __main__.IFoo&gt;, &lt;InterfaceClass __main__.IBlat&gt;)</td></tr><tr><th id=\"L457\"><a href=\"#L457\">457</a></th><td></td></tr><tr><th id=\"L458\"><a href=\"#L458\">458</a></th><td>\u00a0 &gt;&gt;&gt; names = list(IBaz)</td></tr><tr><th id=\"L459\"><a href=\"#L459\">459</a></th><td>\u00a0 &gt;&gt;&gt; names.sort()</td></tr><tr><th id=\"L460\"><a href=\"#L460\">460</a></th><td>\u00a0 &gt;&gt;&gt; names</td></tr><tr><th id=\"L461\"><a href=\"#L461\">461</a></th><td>\u00a0 ['bar', 'eek', 'x', 'y']</td></tr><tr><th id=\"L462\"><a href=\"#L462\">462</a></th><td></td></tr><tr><th id=\"L463\"><a href=\"#L463\">463</a></th><td>Note that `IBaz` overrides eek::</td></tr><tr><th id=\"L464\"><a href=\"#L464\">464</a></th><td></td></tr><tr><th id=\"L465\"><a href=\"#L465\">465</a></th><td>\u00a0 &gt;&gt;&gt; IBlat['eek'].__doc__</td></tr><tr><th id=\"L466\"><a href=\"#L466\">466</a></th><td>\u00a0 'eek blah blah'</td></tr><tr><th id=\"L467\"><a href=\"#L467\">467</a></th><td>\u00a0 &gt;&gt;&gt; IBaz['eek'].__doc__</td></tr><tr><th id=\"L468\"><a href=\"#L468\">468</a></th><td>\u00a0 'eek in baz blah'</td></tr><tr><th id=\"L469\"><a href=\"#L469\">469</a></th><td></td></tr><tr><th id=\"L470\"><a href=\"#L470\">470</a></th><td>We were careful to override eek in a compatible way.\u00a0 When extending</td></tr><tr><th id=\"L471\"><a href=\"#L471\">471</a></th><td>an interface, the extending interface should be compatible [#compat]_</td></tr><tr><th id=\"L472\"><a href=\"#L472\">472</a></th><td>with the extended interfaces.</td></tr><tr><th id=\"L473\"><a href=\"#L473\">473</a></th><td></td></tr><tr><th id=\"L474\"><a href=\"#L474\">474</a></th><td>We can ask whether one interface extends another::</td></tr><tr><th id=\"L475\"><a href=\"#L475\">475</a></th><td></td></tr><tr><th id=\"L476\"><a href=\"#L476\">476</a></th><td>\u00a0 &gt;&gt;&gt; IBaz.extends(IFoo)</td></tr><tr><th id=\"L477\"><a href=\"#L477\">477</a></th><td>\u00a0 True</td></tr><tr><th id=\"L478\"><a href=\"#L478\">478</a></th><td>\u00a0 &gt;&gt;&gt; IBlat.extends(IFoo)</td></tr><tr><th id=\"L479\"><a href=\"#L479\">479</a></th><td>\u00a0 False</td></tr><tr><th id=\"L480\"><a href=\"#L480\">480</a></th><td></td></tr><tr><th id=\"L481\"><a href=\"#L481\">481</a></th><td>Note that interfaces don't extend themselves::</td></tr><tr><th id=\"L482\"><a href=\"#L482\">482</a></th><td></td></tr><tr><th id=\"L483\"><a href=\"#L483\">483</a></th><td>\u00a0 &gt;&gt;&gt; IBaz.extends(IBaz)</td></tr><tr><th id=\"L484\"><a href=\"#L484\">484</a></th><td>\u00a0 False</td></tr><tr><th id=\"L485\"><a href=\"#L485\">485</a></th><td></td></tr><tr><th id=\"L486\"><a href=\"#L486\">486</a></th><td>Sometimes we wish they did, but we can, instead use `isOrExtends`::</td></tr><tr><th id=\"L487\"><a href=\"#L487\">487</a></th><td></td></tr><tr><th id=\"L488\"><a href=\"#L488\">488</a></th><td>\u00a0 &gt;&gt;&gt; IBaz.isOrExtends(IBaz)</td></tr><tr><th id=\"L489\"><a href=\"#L489\">489</a></th><td>\u00a0 True</td></tr><tr><th id=\"L490\"><a href=\"#L490\">490</a></th><td>\u00a0 &gt;&gt;&gt; IBaz.isOrExtends(IFoo)</td></tr><tr><th id=\"L491\"><a href=\"#L491\">491</a></th><td>\u00a0 True</td></tr><tr><th id=\"L492\"><a href=\"#L492\">492</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.isOrExtends(IBaz)</td></tr><tr><th id=\"L493\"><a href=\"#L493\">493</a></th><td>\u00a0 False</td></tr><tr><th id=\"L494\"><a href=\"#L494\">494</a></th><td></td></tr><tr><th id=\"L495\"><a href=\"#L495\">495</a></th><td>When we iterate over an interface, we get all of the names it defines,</td></tr><tr><th id=\"L496\"><a href=\"#L496\">496</a></th><td>including names defined by base interfaces. Sometimes, we want *just*</td></tr><tr><th id=\"L497\"><a href=\"#L497\">497</a></th><td>the names defined by the interface directly. We bane use the `names`</td></tr><tr><th id=\"L498\"><a href=\"#L498\">498</a></th><td>method for that::</td></tr><tr><th id=\"L499\"><a href=\"#L499\">499</a></th><td></td></tr><tr><th id=\"L500\"><a href=\"#L500\">500</a></th><td>\u00a0 &gt;&gt;&gt; list(IBaz.names())</td></tr><tr><th id=\"L501\"><a href=\"#L501\">501</a></th><td>\u00a0 ['eek']</td></tr><tr><th id=\"L502\"><a href=\"#L502\">502</a></th><td></td></tr><tr><th id=\"L503\"><a href=\"#L503\">503</a></th><td>Inheritance of attribute specifications</td></tr><tr><th id=\"L504\"><a href=\"#L504\">504</a></th><td>---------------------------------------</td></tr><tr><th id=\"L505\"><a href=\"#L505\">505</a></th><td></td></tr><tr><th id=\"L506\"><a href=\"#L506\">506</a></th><td>An interface may override attribute definitions from base interfaces.</td></tr><tr><th id=\"L507\"><a href=\"#L507\">507</a></th><td>If two base interfaces define the same attribute, the attribute is</td></tr><tr><th id=\"L508\"><a href=\"#L508\">508</a></th><td>inherited from the most specific interface. For example, with:</td></tr><tr><th id=\"L509\"><a href=\"#L509\">509</a></th><td></td></tr><tr><th id=\"L510\"><a href=\"#L510\">510</a></th><td>\u00a0 &gt;&gt;&gt; class IBase(zope.interface.Interface):</td></tr><tr><th id=\"L511\"><a href=\"#L511\">511</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L512\"><a href=\"#L512\">512</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def foo():</td></tr><tr><th id=\"L513\"><a href=\"#L513\">513</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"base foo doc\"</td></tr><tr><th id=\"L514\"><a href=\"#L514\">514</a></th><td></td></tr><tr><th id=\"L515\"><a href=\"#L515\">515</a></th><td>\u00a0 &gt;&gt;&gt; class IBase1(IBase):</td></tr><tr><th id=\"L516\"><a href=\"#L516\">516</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0pass</td></tr><tr><th id=\"L517\"><a href=\"#L517\">517</a></th><td></td></tr><tr><th id=\"L518\"><a href=\"#L518\">518</a></th><td>\u00a0 &gt;&gt;&gt; class IBase2(IBase):</td></tr><tr><th id=\"L519\"><a href=\"#L519\">519</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L520\"><a href=\"#L520\">520</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def foo():</td></tr><tr><th id=\"L521\"><a href=\"#L521\">521</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"base2 foo doc\"</td></tr><tr><th id=\"L522\"><a href=\"#L522\">522</a></th><td></td></tr><tr><th id=\"L523\"><a href=\"#L523\">523</a></th><td>\u00a0 &gt;&gt;&gt; class ISub(IBase1, IBase2):</td></tr><tr><th id=\"L524\"><a href=\"#L524\">524</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0pass</td></tr><tr><th id=\"L525\"><a href=\"#L525\">525</a></th><td></td></tr><tr><th id=\"L526\"><a href=\"#L526\">526</a></th><td>ISub's definition of foo is the one from IBase2, since IBase2 is more</td></tr><tr><th id=\"L527\"><a href=\"#L527\">527</a></th><td>specific that IBase:</td></tr><tr><th id=\"L528\"><a href=\"#L528\">528</a></th><td></td></tr><tr><th id=\"L529\"><a href=\"#L529\">529</a></th><td>\u00a0 &gt;&gt;&gt; ISub['foo'].__doc__</td></tr><tr><th id=\"L530\"><a href=\"#L530\">530</a></th><td>\u00a0 'base2 foo doc'</td></tr><tr><th id=\"L531\"><a href=\"#L531\">531</a></th><td></td></tr><tr><th id=\"L532\"><a href=\"#L532\">532</a></th><td>Note that this differs from a depth-first search.</td></tr><tr><th id=\"L533\"><a href=\"#L533\">533</a></th><td></td></tr><tr><th id=\"L534\"><a href=\"#L534\">534</a></th><td>Sometimes, it's useful to ask whether an interface defines an</td></tr><tr><th id=\"L535\"><a href=\"#L535\">535</a></th><td>attribute directly.\u00a0 You can use the direct method to get a directly</td></tr><tr><th id=\"L536\"><a href=\"#L536\">536</a></th><td>defined definitions:</td></tr><tr><th id=\"L537\"><a href=\"#L537\">537</a></th><td></td></tr><tr><th id=\"L538\"><a href=\"#L538\">538</a></th><td>\u00a0 &gt;&gt;&gt; IBase.direct('foo').__doc__</td></tr><tr><th id=\"L539\"><a href=\"#L539\">539</a></th><td>\u00a0 'base foo doc'</td></tr><tr><th id=\"L540\"><a href=\"#L540\">540</a></th><td></td></tr><tr><th id=\"L541\"><a href=\"#L541\">541</a></th><td>\u00a0 &gt;&gt;&gt; ISub.direct('foo')</td></tr><tr><th id=\"L542\"><a href=\"#L542\">542</a></th><td></td></tr><tr><th id=\"L543\"><a href=\"#L543\">543</a></th><td>Specifications</td></tr><tr><th id=\"L544\"><a href=\"#L544\">544</a></th><td>--------------</td></tr><tr><th id=\"L545\"><a href=\"#L545\">545</a></th><td></td></tr><tr><th id=\"L546\"><a href=\"#L546\">546</a></th><td>Interfaces and declarations are both special cases of specifications.</td></tr><tr><th id=\"L547\"><a href=\"#L547\">547</a></th><td>What we described above for interface inheritance applies to both</td></tr><tr><th id=\"L548\"><a href=\"#L548\">548</a></th><td>declarations and specifications.\u00a0 Declarations actually extend the</td></tr><tr><th id=\"L549\"><a href=\"#L549\">549</a></th><td>interfaces that they declare:</td></tr><tr><th id=\"L550\"><a href=\"#L550\">550</a></th><td></td></tr><tr><th id=\"L551\"><a href=\"#L551\">551</a></th><td>\u00a0 &gt;&gt;&gt; class Baz:</td></tr><tr><th id=\"L552\"><a href=\"#L552\">552</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(IBaz)</td></tr><tr><th id=\"L553\"><a href=\"#L553\">553</a></th><td></td></tr><tr><th id=\"L554\"><a href=\"#L554\">554</a></th><td>\u00a0 &gt;&gt;&gt; baz_implements = zope.interface.implementedBy(Baz)</td></tr><tr><th id=\"L555\"><a href=\"#L555\">555</a></th><td>\u00a0 &gt;&gt;&gt; baz_implements.__bases__</td></tr><tr><th id=\"L556\"><a href=\"#L556\">556</a></th><td>\u00a0 (&lt;InterfaceClass __main__.IBaz&gt;,)</td></tr><tr><th id=\"L557\"><a href=\"#L557\">557</a></th><td></td></tr><tr><th id=\"L558\"><a href=\"#L558\">558</a></th><td>\u00a0 &gt;&gt;&gt; baz_implements.extends(IFoo)</td></tr><tr><th id=\"L559\"><a href=\"#L559\">559</a></th><td>\u00a0 True</td></tr><tr><th id=\"L560\"><a href=\"#L560\">560</a></th><td></td></tr><tr><th id=\"L561\"><a href=\"#L561\">561</a></th><td>\u00a0 &gt;&gt;&gt; baz_implements.isOrExtends(IFoo)</td></tr><tr><th id=\"L562\"><a href=\"#L562\">562</a></th><td>\u00a0 True</td></tr><tr><th id=\"L563\"><a href=\"#L563\">563</a></th><td>\u00a0 &gt;&gt;&gt; baz_implements.isOrExtends(baz_implements)</td></tr><tr><th id=\"L564\"><a href=\"#L564\">564</a></th><td>\u00a0 True</td></tr><tr><th id=\"L565\"><a href=\"#L565\">565</a></th><td></td></tr><tr><th id=\"L566\"><a href=\"#L566\">566</a></th><td>Specifications (interfaces and declarations) provide an `__sro__`</td></tr><tr><th id=\"L567\"><a href=\"#L567\">567</a></th><td>that lists the specification and all of it's ancestors:</td></tr><tr><th id=\"L568\"><a href=\"#L568\">568</a></th><td></td></tr><tr><th id=\"L569\"><a href=\"#L569\">569</a></th><td>\u00a0 &gt;&gt;&gt; baz_implements.__sro__</td></tr><tr><th id=\"L570\"><a href=\"#L570\">570</a></th><td>\u00a0 (&lt;implementedBy __main__.Baz&gt;,</td></tr><tr><th id=\"L571\"><a href=\"#L571\">571</a></th><td>\u00a0 \u00a0&lt;InterfaceClass __main__.IBaz&gt;,</td></tr><tr><th id=\"L572\"><a href=\"#L572\">572</a></th><td>\u00a0 \u00a0&lt;InterfaceClass __main__.IFoo&gt;,</td></tr><tr><th id=\"L573\"><a href=\"#L573\">573</a></th><td>\u00a0 \u00a0&lt;InterfaceClass __main__.IBlat&gt;,</td></tr><tr><th id=\"L574\"><a href=\"#L574\">574</a></th><td>\u00a0 \u00a0&lt;InterfaceClass zope.interface.Interface&gt;)</td></tr><tr><th id=\"L575\"><a href=\"#L575\">575</a></th><td></td></tr><tr><th id=\"L576\"><a href=\"#L576\">576</a></th><td></td></tr><tr><th id=\"L577\"><a href=\"#L577\">577</a></th><td>Tagged Values</td></tr><tr><th id=\"L578\"><a href=\"#L578\">578</a></th><td>=============</td></tr><tr><th id=\"L579\"><a href=\"#L579\">579</a></th><td></td></tr><tr><th id=\"L580\"><a href=\"#L580\">580</a></th><td>Interfaces and attribute descriptions support an extension mechanism,</td></tr><tr><th id=\"L581\"><a href=\"#L581\">581</a></th><td>borrowed from UML, called \"tagged values\" that lets us store extra</td></tr><tr><th id=\"L582\"><a href=\"#L582\">582</a></th><td>data::</td></tr><tr><th id=\"L583\"><a href=\"#L583\">583</a></th><td></td></tr><tr><th id=\"L584\"><a href=\"#L584\">584</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.setTaggedValue('date-modified', '2004-04-01')</td></tr><tr><th id=\"L585\"><a href=\"#L585\">585</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.setTaggedValue('author', 'Jim Fulton')</td></tr><tr><th id=\"L586\"><a href=\"#L586\">586</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.getTaggedValue('date-modified')</td></tr><tr><th id=\"L587\"><a href=\"#L587\">587</a></th><td>\u00a0 '2004-04-01'</td></tr><tr><th id=\"L588\"><a href=\"#L588\">588</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.queryTaggedValue('date-modified')</td></tr><tr><th id=\"L589\"><a href=\"#L589\">589</a></th><td>\u00a0 '2004-04-01'</td></tr><tr><th id=\"L590\"><a href=\"#L590\">590</a></th><td>\u00a0 &gt;&gt;&gt; IFoo.queryTaggedValue('datemodified')</td></tr><tr><th id=\"L591\"><a href=\"#L591\">591</a></th><td>\u00a0 &gt;&gt;&gt; tags = list(IFoo.getTaggedValueTags())</td></tr><tr><th id=\"L592\"><a href=\"#L592\">592</a></th><td>\u00a0 &gt;&gt;&gt; tags.sort()</td></tr><tr><th id=\"L593\"><a href=\"#L593\">593</a></th><td>\u00a0 &gt;&gt;&gt; tags</td></tr><tr><th id=\"L594\"><a href=\"#L594\">594</a></th><td>\u00a0 ['author', 'date-modified']</td></tr><tr><th id=\"L595\"><a href=\"#L595\">595</a></th><td></td></tr><tr><th id=\"L596\"><a href=\"#L596\">596</a></th><td>Function attributes are converted to tagged values when method</td></tr><tr><th id=\"L597\"><a href=\"#L597\">597</a></th><td>attribute definitions are created::</td></tr><tr><th id=\"L598\"><a href=\"#L598\">598</a></th><td></td></tr><tr><th id=\"L599\"><a href=\"#L599\">599</a></th><td>\u00a0 &gt;&gt;&gt; class IBazFactory(zope.interface.Interface):</td></tr><tr><th id=\"L600\"><a href=\"#L600\">600</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __call__():</td></tr><tr><th id=\"L601\"><a href=\"#L601\">601</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"create one\"</td></tr><tr><th id=\"L602\"><a href=\"#L602\">602</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0__call__.return_type = IBaz</td></tr><tr><th id=\"L603\"><a href=\"#L603\">603</a></th><td></td></tr><tr><th id=\"L604\"><a href=\"#L604\">604</a></th><td>\u00a0 &gt;&gt;&gt; IBazFactory['__call__'].getTaggedValue('return_type')</td></tr><tr><th id=\"L605\"><a href=\"#L605\">605</a></th><td>\u00a0 &lt;InterfaceClass __main__.IBaz&gt;</td></tr><tr><th id=\"L606\"><a href=\"#L606\">606</a></th><td></td></tr><tr><th id=\"L607\"><a href=\"#L607\">607</a></th><td></td></tr><tr><th id=\"L608\"><a href=\"#L608\">608</a></th><td>Invariants</td></tr><tr><th id=\"L609\"><a href=\"#L609\">609</a></th><td>==========</td></tr><tr><th id=\"L610\"><a href=\"#L610\">610</a></th><td></td></tr><tr><th id=\"L611\"><a href=\"#L611\">611</a></th><td>Interfaces can express conditions that must hold for objects that</td></tr><tr><th id=\"L612\"><a href=\"#L612\">612</a></th><td>provide them. These conditions are expressed using one or more</td></tr><tr><th id=\"L613\"><a href=\"#L613\">613</a></th><td>invariants.\u00a0 Invariants are callable objects that will be called with</td></tr><tr><th id=\"L614\"><a href=\"#L614\">614</a></th><td>an object that provides an interface. An invariant raises an `Invalid`</td></tr><tr><th id=\"L615\"><a href=\"#L615\">615</a></th><td>exception if the condition doesn't hold.\u00a0 Here's an example::</td></tr><tr><th id=\"L616\"><a href=\"#L616\">616</a></th><td></td></tr><tr><th id=\"L617\"><a href=\"#L617\">617</a></th><td>\u00a0 &gt;&gt;&gt; class RangeError(zope.interface.Invalid):</td></tr><tr><th id=\"L618\"><a href=\"#L618\">618</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0\"\"\"A range has invalid limits\"\"\"</td></tr><tr><th id=\"L619\"><a href=\"#L619\">619</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __repr__(self):</td></tr><tr><th id=\"L620\"><a href=\"#L620\">620</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"RangeError(%r)\" % self.args</td></tr><tr><th id=\"L621\"><a href=\"#L621\">621</a></th><td></td></tr><tr><th id=\"L622\"><a href=\"#L622\">622</a></th><td>\u00a0 &gt;&gt;&gt; def range_invariant(ob):</td></tr><tr><th id=\"L623\"><a href=\"#L623\">623</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0if ob.max &lt; ob.min:</td></tr><tr><th id=\"L624\"><a href=\"#L624\">624</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0raise RangeError(ob)</td></tr><tr><th id=\"L625\"><a href=\"#L625\">625</a></th><td></td></tr><tr><th id=\"L626\"><a href=\"#L626\">626</a></th><td>Given this invariant, we can use it in an interface definition::</td></tr><tr><th id=\"L627\"><a href=\"#L627\">627</a></th><td></td></tr><tr><th id=\"L628\"><a href=\"#L628\">628</a></th><td>\u00a0 &gt;&gt;&gt; class IRange(zope.interface.Interface):</td></tr><tr><th id=\"L629\"><a href=\"#L629\">629</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0min = zope.interface.Attribute(\"Lower bound\")</td></tr><tr><th id=\"L630\"><a href=\"#L630\">630</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0max = zope.interface.Attribute(\"Upper bound\")</td></tr><tr><th id=\"L631\"><a href=\"#L631\">631</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L632\"><a href=\"#L632\">632</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.invariant(range_invariant)</td></tr><tr><th id=\"L633\"><a href=\"#L633\">633</a></th><td></td></tr><tr><th id=\"L634\"><a href=\"#L634\">634</a></th><td>Interfaces have a method for checking their invariants::</td></tr><tr><th id=\"L635\"><a href=\"#L635\">635</a></th><td></td></tr><tr><th id=\"L636\"><a href=\"#L636\">636</a></th><td>\u00a0 &gt;&gt;&gt; class Range(object):</td></tr><tr><th id=\"L637\"><a href=\"#L637\">637</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(IRange)</td></tr><tr><th id=\"L638\"><a href=\"#L638\">638</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L639\"><a href=\"#L639\">639</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __init__(self, min, max):</td></tr><tr><th id=\"L640\"><a href=\"#L640\">640</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0self.min, self.max = min, max</td></tr><tr><th id=\"L641\"><a href=\"#L641\">641</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L642\"><a href=\"#L642\">642</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __repr__(self):</td></tr><tr><th id=\"L643\"><a href=\"#L643\">643</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return \"Range(%s, %s)\" % (self.min, self.max)</td></tr><tr><th id=\"L644\"><a href=\"#L644\">644</a></th><td></td></tr><tr><th id=\"L645\"><a href=\"#L645\">645</a></th><td>\u00a0 &gt;&gt;&gt; IRange.validateInvariants(Range(1,2))</td></tr><tr><th id=\"L646\"><a href=\"#L646\">646</a></th><td>\u00a0 &gt;&gt;&gt; IRange.validateInvariants(Range(1,1))</td></tr><tr><th id=\"L647\"><a href=\"#L647\">647</a></th><td>\u00a0 &gt;&gt;&gt; IRange.validateInvariants(Range(2,1))</td></tr><tr><th id=\"L648\"><a href=\"#L648\">648</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L649\"><a href=\"#L649\">649</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L650\"><a href=\"#L650\">650</a></th><td>\u00a0 RangeError: Range(2, 1)</td></tr><tr><th id=\"L651\"><a href=\"#L651\">651</a></th><td></td></tr><tr><th id=\"L652\"><a href=\"#L652\">652</a></th><td>If you have multiple invariants, you may not want to stop checking</td></tr><tr><th id=\"L653\"><a href=\"#L653\">653</a></th><td>after the first error.\u00a0 If you pass a list to `validateInvariants`,</td></tr><tr><th id=\"L654\"><a href=\"#L654\">654</a></th><td>then a single `Invalid` exception will be raised with the list of</td></tr><tr><th id=\"L655\"><a href=\"#L655\">655</a></th><td>exceptions as it's argument::</td></tr><tr><th id=\"L656\"><a href=\"#L656\">656</a></th><td></td></tr><tr><th id=\"L657\"><a href=\"#L657\">657</a></th><td>\u00a0 &gt;&gt;&gt; errors = []</td></tr><tr><th id=\"L658\"><a href=\"#L658\">658</a></th><td>\u00a0 &gt;&gt;&gt; IRange.validateInvariants(Range(2,1), errors)</td></tr><tr><th id=\"L659\"><a href=\"#L659\">659</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L660\"><a href=\"#L660\">660</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L661\"><a href=\"#L661\">661</a></th><td>\u00a0 Invalid: [RangeError(Range(2, 1))]</td></tr><tr><th id=\"L662\"><a href=\"#L662\">662</a></th><td></td></tr><tr><th id=\"L663\"><a href=\"#L663\">663</a></th><td>And the list will be filled with the individual exceptions::</td></tr><tr><th id=\"L664\"><a href=\"#L664\">664</a></th><td></td></tr><tr><th id=\"L665\"><a href=\"#L665\">665</a></th><td>\u00a0 &gt;&gt;&gt; errors</td></tr><tr><th id=\"L666\"><a href=\"#L666\">666</a></th><td>\u00a0 [RangeError(Range(2, 1))]</td></tr><tr><th id=\"L667\"><a href=\"#L667\">667</a></th><td></td></tr><tr><th id=\"L668\"><a href=\"#L668\">668</a></th><td></td></tr><tr><th id=\"L669\"><a href=\"#L669\">669</a></th><td>\u00a0 &gt;&gt;&gt; del errors[:]</td></tr><tr><th id=\"L670\"><a href=\"#L670\">670</a></th><td></td></tr><tr><th id=\"L671\"><a href=\"#L671\">671</a></th><td>==========</td></tr><tr><th id=\"L672\"><a href=\"#L672\">672</a></th><td>Adaptation</td></tr><tr><th id=\"L673\"><a href=\"#L673\">673</a></th><td>==========</td></tr><tr><th id=\"L674\"><a href=\"#L674\">674</a></th><td></td></tr><tr><th id=\"L675\"><a href=\"#L675\">675</a></th><td>Interfaces can be called to perform adaptation.</td></tr><tr><th id=\"L676\"><a href=\"#L676\">676</a></th><td></td></tr><tr><th id=\"L677\"><a href=\"#L677\">677</a></th><td>The sematics based on those of the PEP 246 adapt function.</td></tr><tr><th id=\"L678\"><a href=\"#L678\">678</a></th><td></td></tr><tr><th id=\"L679\"><a href=\"#L679\">679</a></th><td>If an object cannot be adapted, then a TypeError is raised::</td></tr><tr><th id=\"L680\"><a href=\"#L680\">680</a></th><td></td></tr><tr><th id=\"L681\"><a href=\"#L681\">681</a></th><td>\u00a0 &gt;&gt;&gt; class I(zope.interface.Interface):</td></tr><tr><th id=\"L682\"><a href=\"#L682\">682</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0pass</td></tr><tr><th id=\"L683\"><a href=\"#L683\">683</a></th><td></td></tr><tr><th id=\"L684\"><a href=\"#L684\">684</a></th><td>\u00a0 &gt;&gt;&gt; I(0)</td></tr><tr><th id=\"L685\"><a href=\"#L685\">685</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L686\"><a href=\"#L686\">686</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L687\"><a href=\"#L687\">687</a></th><td>\u00a0 TypeError: ('Could not adapt', 0, &lt;InterfaceClass __main__.I&gt;)</td></tr><tr><th id=\"L688\"><a href=\"#L688\">688</a></th><td></td></tr><tr><th id=\"L689\"><a href=\"#L689\">689</a></th><td></td></tr><tr><th id=\"L690\"><a href=\"#L690\">690</a></th><td></td></tr><tr><th id=\"L691\"><a href=\"#L691\">691</a></th><td>unless an alternate value is provided as a second positional argument::</td></tr><tr><th id=\"L692\"><a href=\"#L692\">692</a></th><td></td></tr><tr><th id=\"L693\"><a href=\"#L693\">693</a></th><td>\u00a0 &gt;&gt;&gt; I(0, 'bob')</td></tr><tr><th id=\"L694\"><a href=\"#L694\">694</a></th><td>\u00a0 'bob'</td></tr><tr><th id=\"L695\"><a href=\"#L695\">695</a></th><td></td></tr><tr><th id=\"L696\"><a href=\"#L696\">696</a></th><td>If an object already implements the interface, then it will be returned::</td></tr><tr><th id=\"L697\"><a href=\"#L697\">697</a></th><td></td></tr><tr><th id=\"L698\"><a href=\"#L698\">698</a></th><td>\u00a0 &gt;&gt;&gt; class C(object):</td></tr><tr><th id=\"L699\"><a href=\"#L699\">699</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(I)</td></tr><tr><th id=\"L700\"><a href=\"#L700\">700</a></th><td></td></tr><tr><th id=\"L701\"><a href=\"#L701\">701</a></th><td>\u00a0 &gt;&gt;&gt; obj = C()</td></tr><tr><th id=\"L702\"><a href=\"#L702\">702</a></th><td>\u00a0 &gt;&gt;&gt; I(obj) is obj</td></tr><tr><th id=\"L703\"><a href=\"#L703\">703</a></th><td>\u00a0 True</td></tr><tr><th id=\"L704\"><a href=\"#L704\">704</a></th><td></td></tr><tr><th id=\"L705\"><a href=\"#L705\">705</a></th><td>If an object implements __conform__, then it will be used::</td></tr><tr><th id=\"L706\"><a href=\"#L706\">706</a></th><td></td></tr><tr><th id=\"L707\"><a href=\"#L707\">707</a></th><td>\u00a0 &gt;&gt;&gt; class C(object):</td></tr><tr><th id=\"L708\"><a href=\"#L708\">708</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(I)</td></tr><tr><th id=\"L709\"><a href=\"#L709\">709</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0def __conform__(self, proto):</td></tr><tr><th id=\"L710\"><a href=\"#L710\">710</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0</td></tr><tr><th id=\"L711\"><a href=\"#L711\">711</a></th><td></td></tr><tr><th id=\"L712\"><a href=\"#L712\">712</a></th><td>\u00a0 &gt;&gt;&gt; I(C())</td></tr><tr><th id=\"L713\"><a href=\"#L713\">713</a></th><td>\u00a0 0</td></tr><tr><th id=\"L714\"><a href=\"#L714\">714</a></th><td></td></tr><tr><th id=\"L715\"><a href=\"#L715\">715</a></th><td>Adapter hooks (see __adapt__) will also be used, if present:</td></tr><tr><th id=\"L716\"><a href=\"#L716\">716</a></th><td></td></tr><tr><th id=\"L717\"><a href=\"#L717\">717</a></th><td>\u00a0 &gt;&gt;&gt; from zope.interface.interface import adapter_hooks</td></tr><tr><th id=\"L718\"><a href=\"#L718\">718</a></th><td>\u00a0 &gt;&gt;&gt; def adapt_0_to_42(iface, obj):</td></tr><tr><th id=\"L719\"><a href=\"#L719\">719</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0if obj == 0:</td></tr><tr><th id=\"L720\"><a href=\"#L720\">720</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return 42</td></tr><tr><th id=\"L721\"><a href=\"#L721\">721</a></th><td></td></tr><tr><th id=\"L722\"><a href=\"#L722\">722</a></th><td>\u00a0 &gt;&gt;&gt; adapter_hooks.append(adapt_0_to_42)</td></tr><tr><th id=\"L723\"><a href=\"#L723\">723</a></th><td>\u00a0 &gt;&gt;&gt; I(0)</td></tr><tr><th id=\"L724\"><a href=\"#L724\">724</a></th><td>\u00a0 42</td></tr><tr><th id=\"L725\"><a href=\"#L725\">725</a></th><td></td></tr><tr><th id=\"L726\"><a href=\"#L726\">726</a></th><td>\u00a0 &gt;&gt;&gt; adapter_hooks.remove(adapt_0_to_42)</td></tr><tr><th id=\"L727\"><a href=\"#L727\">727</a></th><td>\u00a0 &gt;&gt;&gt; I(0)</td></tr><tr><th id=\"L728\"><a href=\"#L728\">728</a></th><td>\u00a0 Traceback (most recent call last):</td></tr><tr><th id=\"L729\"><a href=\"#L729\">729</a></th><td>\u00a0 ...</td></tr><tr><th id=\"L730\"><a href=\"#L730\">730</a></th><td>\u00a0 TypeError: ('Could not adapt', 0, &lt;InterfaceClass __main__.I&gt;)</td></tr><tr><th id=\"L731\"><a href=\"#L731\">731</a></th><td></td></tr><tr><th id=\"L732\"><a href=\"#L732\">732</a></th><td>__adapt__</td></tr><tr><th id=\"L733\"><a href=\"#L733\">733</a></th><td>=========</td></tr><tr><th id=\"L734\"><a href=\"#L734\">734</a></th><td></td></tr><tr><th id=\"L735\"><a href=\"#L735\">735</a></th><td>\u00a0 &gt;&gt;&gt; class I(zope.interface.Interface):</td></tr><tr><th id=\"L736\"><a href=\"#L736\">736</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0pass</td></tr><tr><th id=\"L737\"><a href=\"#L737\">737</a></th><td></td></tr><tr><th id=\"L738\"><a href=\"#L738\">738</a></th><td>Interfaces implement the PEP 246 __adapt__ method.</td></tr><tr><th id=\"L739\"><a href=\"#L739\">739</a></th><td></td></tr><tr><th id=\"L740\"><a href=\"#L740\">740</a></th><td>This method is normally not called directly. It is called by the PEP</td></tr><tr><th id=\"L741\"><a href=\"#L741\">741</a></th><td>246 adapt framework and by the interface __call__ operator.</td></tr><tr><th id=\"L742\"><a href=\"#L742\">742</a></th><td></td></tr><tr><th id=\"L743\"><a href=\"#L743\">743</a></th><td>The adapt method is responsible for adapting an object to the</td></tr><tr><th id=\"L744\"><a href=\"#L744\">744</a></th><td>reciever.</td></tr><tr><th id=\"L745\"><a href=\"#L745\">745</a></th><td></td></tr><tr><th id=\"L746\"><a href=\"#L746\">746</a></th><td>The default version returns None::</td></tr><tr><th id=\"L747\"><a href=\"#L747\">747</a></th><td></td></tr><tr><th id=\"L748\"><a href=\"#L748\">748</a></th><td>\u00a0 &gt;&gt;&gt; I.__adapt__(0)</td></tr><tr><th id=\"L749\"><a href=\"#L749\">749</a></th><td></td></tr><tr><th id=\"L750\"><a href=\"#L750\">750</a></th><td>unless the object given provides the interface::</td></tr><tr><th id=\"L751\"><a href=\"#L751\">751</a></th><td></td></tr><tr><th id=\"L752\"><a href=\"#L752\">752</a></th><td>\u00a0 &gt;&gt;&gt; class C(object):</td></tr><tr><th id=\"L753\"><a href=\"#L753\">753</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0zope.interface.implements(I)</td></tr><tr><th id=\"L754\"><a href=\"#L754\">754</a></th><td></td></tr><tr><th id=\"L755\"><a href=\"#L755\">755</a></th><td>\u00a0 &gt;&gt;&gt; obj = C()</td></tr><tr><th id=\"L756\"><a href=\"#L756\">756</a></th><td>\u00a0 &gt;&gt;&gt; I.__adapt__(obj) is obj</td></tr><tr><th id=\"L757\"><a href=\"#L757\">757</a></th><td>\u00a0 True</td></tr><tr><th id=\"L758\"><a href=\"#L758\">758</a></th><td></td></tr><tr><th id=\"L759\"><a href=\"#L759\">759</a></th><td>Adapter hooks can be provided (or removed) to provide custom</td></tr><tr><th id=\"L760\"><a href=\"#L760\">760</a></th><td>adaptation. We'll install a silly hook that adapts 0 to 42.</td></tr><tr><th id=\"L761\"><a href=\"#L761\">761</a></th><td>We install a hook by simply adding it to the adapter_hooks</td></tr><tr><th id=\"L762\"><a href=\"#L762\">762</a></th><td>list::</td></tr><tr><th id=\"L763\"><a href=\"#L763\">763</a></th><td></td></tr><tr><th id=\"L764\"><a href=\"#L764\">764</a></th><td>\u00a0 &gt;&gt;&gt; from zope.interface.interface import adapter_hooks</td></tr><tr><th id=\"L765\"><a href=\"#L765\">765</a></th><td>\u00a0 &gt;&gt;&gt; def adapt_0_to_42(iface, obj):</td></tr><tr><th id=\"L766\"><a href=\"#L766\">766</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0if obj == 0:</td></tr><tr><th id=\"L767\"><a href=\"#L767\">767</a></th><td>\u00a0 ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0return 42</td></tr><tr><th id=\"L768\"><a href=\"#L768\">768</a></th><td></td></tr><tr><th id=\"L769\"><a href=\"#L769\">769</a></th><td>\u00a0 &gt;&gt;&gt; adapter_hooks.append(adapt_0_to_42)</td></tr><tr><th id=\"L770\"><a href=\"#L770\">770</a></th><td>\u00a0 &gt;&gt;&gt; I.__adapt__(0)</td></tr><tr><th id=\"L771\"><a href=\"#L771\">771</a></th><td>\u00a0 42</td></tr><tr><th id=\"L772\"><a href=\"#L772\">772</a></th><td></td></tr><tr><th id=\"L773\"><a href=\"#L773\">773</a></th><td>Hooks must either return an adapter, or None if no adapter can</td></tr><tr><th id=\"L774\"><a href=\"#L774\">774</a></th><td>be found.</td></tr><tr><th id=\"L775\"><a href=\"#L775\">775</a></th><td></td></tr><tr><th id=\"L776\"><a href=\"#L776\">776</a></th><td>Hooks can be uninstalled by removing them from the list::</td></tr><tr><th id=\"L777\"><a href=\"#L777\">777</a></th><td></td></tr><tr><th id=\"L778\"><a href=\"#L778\">778</a></th><td>\u00a0 &gt;&gt;&gt; adapter_hooks.remove(adapt_0_to_42)</td></tr><tr><th id=\"L779\"><a href=\"#L779\">779</a></th><td>\u00a0 &gt;&gt;&gt; I.__adapt__(0)</td></tr><tr><th id=\"L780\"><a href=\"#L780\">780</a></th><td></td></tr><tr><th id=\"L781\"><a href=\"#L781\">781</a></th><td></td></tr><tr><th id=\"L782\"><a href=\"#L782\">782</a></th><td>.. [#create] The main reason we subclass `Interface` is to cause the</td></tr><tr><th id=\"L783\"><a href=\"#L783\">783</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Python class statement to create an interface, rather</td></tr><tr><th id=\"L784\"><a href=\"#L784\">784</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0than a class.</td></tr><tr><th id=\"L785\"><a href=\"#L785\">785</a></th><td></td></tr><tr><th id=\"L786\"><a href=\"#L786\">786</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0It's possible to create interfaces by calling a special</td></tr><tr><th id=\"L787\"><a href=\"#L787\">787</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0interface class directly.\u00a0 Doing this, it's possible</td></tr><tr><th id=\"L788\"><a href=\"#L788\">788</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(and, on rare occasions, useful) to create interfaces</td></tr><tr><th id=\"L789\"><a href=\"#L789\">789</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0that don't descend from `Interface`.\u00a0 Using this</td></tr><tr><th id=\"L790\"><a href=\"#L790\">790</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0technique is beyond the scope of this document.</td></tr><tr><th id=\"L791\"><a href=\"#L791\">791</a></th><td></td></tr><tr><th id=\"L792\"><a href=\"#L792\">792</a></th><td>.. [#factory] Classes are factories.\u00a0 They can be called to create</td></tr><tr><th id=\"L793\"><a href=\"#L793\">793</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 their instances.\u00a0 We expect that we will eventually</td></tr><tr><th id=\"L794\"><a href=\"#L794\">794</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 extend the concept of implementation to other kinds of</td></tr><tr><th id=\"L795\"><a href=\"#L795\">795</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 factories, so that we can declare the interfaces</td></tr><tr><th id=\"L796\"><a href=\"#L796\">796</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 provided by the objects created.</td></tr><tr><th id=\"L797\"><a href=\"#L797\">797</a></th><td></td></tr><tr><th id=\"L798\"><a href=\"#L798\">798</a></th><td>.. [#compat] The goal is substitutability.\u00a0 An object that provides an</td></tr><tr><th id=\"L799\"><a href=\"#L799\">799</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0extending interface should be substitutable for an object</td></tr><tr><th id=\"L800\"><a href=\"#L800\">800</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0that provides the extended interface.\u00a0 In our example, an</td></tr><tr><th id=\"L801\"><a href=\"#L801\">801</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0object that provides IBaz should be usable whereever an</td></tr><tr><th id=\"L802\"><a href=\"#L802\">802</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0object that provides IBlat is expected.</td></tr><tr><th id=\"L803\"><a href=\"#L803\">803</a></th><td></td></tr><tr><th id=\"L804\"><a href=\"#L804\">804</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0The interface implementation doesn't enforce this.</td></tr><tr><th id=\"L805\"><a href=\"#L805\">805</a></th><td>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0but maybe it should do some checks.</td></tr></tbody></table>\n\n      </div>\n      <div id=\"anydiff\">\n        <form action=\"/LUCICodeRepository/nomaticIM/diff\" method=\"get\">\n          <div class=\"buttons\">\n            <input type=\"hidden\" name=\"new_path\" value=\"/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\" />\n            <input type=\"hidden\" name=\"old_path\" value=\"/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\" />\n            <input type=\"hidden\" name=\"new_rev\" />\n            <input type=\"hidden\" name=\"old_rev\" />\n            <input type=\"submit\" value=\"View changes...\" title=\"Select paths and revs for Diff\" />\n          </div>\n        </form>\n      </div>\n      <div id=\"help\"><strong>Note:</strong> See <a href=\"/LUCICodeRepository/nomaticIM/wiki/TracBrowser\">TracBrowser</a>\n        for help on using the repository browser.</div>\n    </div>\n    <div id=\"altlinks\">\n      <h3>Download in other formats:</h3>\n      <ul>\n        <li class=\"first\">\n          <a rel=\"nofollow\" href=\"/LUCICodeRepository/nomaticIM/browser/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt?format=txt\">Plain Text</a>\n        </li><li class=\"last\">\n          <a rel=\"nofollow\" href=\"/LUCICodeRepository/nomaticIM/export/1312/nomatic/tags/NomaticIM-0.0.5/buddy_bots/src/zope/interface/README.txt\">Original Format</a>\n        </li>\n      </ul>\n    </div>\n    </div>\n    <div id=\"footer\" lang=\"en\" xml:lang=\"en\"><hr />\n      <a id=\"tracpowered\" href=\"http://trac.edgewall.org/\"><img src=\"/LUCICodeRepository/nomaticIM/chrome/common/trac_logo_mini.png\" height=\"30\" width=\"107\" alt=\"Trac Powered\" /></a>\n      <p class=\"left\">Powered by <a href=\"/LUCICodeRepository/nomaticIM/about\"><strong>Trac 1.0.1</strong></a><br />\n        By <a href=\"http://www.edgewall.org/\">Edgewall Software</a>.</p>\n      <p class=\"right\">All content copyright 2007-2008 by LUCI <br /><a href=\"http://luci.ics.uci.edu/\">http://luci.ics.uci.edu/</a></p>\n    </div>\n\t\t<div id=\"sitefooter\">\n\t\t\t<script src=\"http://www.google-analytics.com/urchin.js\" type=\"text/javascript\">\n\t\t\t</script>\n\t\t\t<script type=\"text/javascript\">\n\t\t\t\t_uacct = \"UA-338915-2\";\n\t\t\t\turchinTracker();\n\t\t\t</script>\n\t\t</div>\n\t</body>\n</html>", "id": 44128.0}