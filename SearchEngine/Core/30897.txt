{"text": "Abstract Classes Introduction to Computer Science I III ICS 21 22 23 Introduction In this lecture we will continue our discussion of inheritance features by examing abstract classes Once again in many ways abstract classes are a simple concept involving only one new keyword that can be used in two places that has deep ramifications when designing complex class hierarchies We will discuss this Java language feature in the context of the Positional Shape Inheritance Demo which you should download run and examine In this lecture we will compare abstract classes to interfaces which seem closely related for example we can extend interfaces via inheritance too and see multiple ways to accomplish approximate the same result and compare them Finally we will examine some general principles for designing classes in inheritance hierarchies Defining Abstract Methods and Classes Sometimes a class should define a method that logically belongs in the class but that class cannot specify how to implement the method For example the Shape class is used as a superclass for 2 dimensional shapes like circles rectangles etc Logically every shape should have a getArea method because every shape has an area But every shape would compute its area using a different formula and there is no way to specify one getArea method in the Shape class that is correct for all its possible subclasses In an application we might want to declare a Shape array fill it with references to objects constructed from actual shapes subclasses of Shape and then ask each shape to return its area We would like Java to call the correct getShape method for each object to compute the result correctly again this illustrate how Java implements polymorphism to solve such a problem We accomplish this in Java by defining the getArea method in the Shape class but by specfying the abstract keyword in its list of access modifiers as a syntax constraint this keyword can be used when defining only classes and methods and then specifying no implementation no method body just like in an interface We would specify it in the Shape class as follows public abstract double getArea By defining this method we are telling the Java compiler that it should allows us to call the getArea method using any variable declared with the type Shape or declared with any class that is a subclass of Shape where the definition of getArea will really appear For example we can define the toString method in the Shape class as public String toString return Shape id id area getArea This method calls getArea and returns as a String the area of the shape Our first big rule about using abstract concerns where abstract methods can be called Any method in a class can be declared abstract Such a method has no body is replaced by just as in interfaces and can be called in other methods defined in that class or be called in methods defined in any of its subclasses or be called using any variables whose type is this class or any of its subclasses Our second big rule about using abstract concerns the relationship between abstract method and the classes in which the are defined If a class defines any abstract methods or as we will see inherits any abstract methods and doesn t override them that class must be defined using the abstract keyword in its access modifiers If this second rule is violated the Java compiler will detect and report an error so if we forget to make a class abstract Java will just remind us with no harm caused In fact we will define the Shape class using an id instance variable and constructor throughout the examples in this lecture as public abstract class Shape public Shape String id this id id This abstract method must be defined in a concrete subclass Note that it is called in this class in the toString method public abstract double getArea public String getId return id public String toString return Shape id id area getArea private String id Generally abstract classes can specify all the standard class components constructors methods and instance variables Again a class must be defined with the keyword abstract as is the case above if any of its methods is defined with the keyword abstract as is the case above Note that we can call the abstract method in other methods defined in the class even if its body isn t defined yet Again logically this method belongs in the class even if it cannot be written there because Shape is too high in the hierarchy Using Abstract Classes as Superclasses Now it should be obvious that it would make no sense to write Shape s new Shape s1 System out println s because although we are allowed to call the getArea method Java knows the prototype of this method its implementation HAS NOT BEEN SPECIFIED Java would have no idea what code to execute to compute getArea inside toString But the problem is not in the method call it is in the construction This issue brings us to our third big rule about using abstract for classes concerning the restriction on calling constructors ONLY IN SUBCLASSES If a class is defined with the keyword abstract we may call its constructor only via super in a class that extends it not via the new operator That is we cannot explicitly construct an object using an abstract class but we can use it to help construct an object from a subclass Thus the Java compiler would detect and report an error in the statement Shape s new Shape s1 and never even get to compiling the call to the getArea method If we cannot construct an object with an abstract class what can we do with one We can definine a subclass that extends it If the subclass overrides every abstract method that it inherits then that subclass is not abstract But if it inherits any abstract methods and doesn t override them then the subclass also has abstract methods and must itself also be defined abstract We call a non abstract class concrete although there is no keyword with this name For example we can define a concrete Circle subclass by extending Shape as follows public class Circle extends Shape public Circle String name double r super name radius r Overide the abstract method declared in shape public double getArea return Math PI radius radius public double getRadius return radius public void setRadius double newRadius radius newRadius public String toString return Circle radius radius super toString private double radius Here the Circle subclass does override the one abstract method that it inherits from Shape it defines a few new methods but none of them is abstract so it is a concrete class and therefore not defined with the abstract keyword Also notice that its constructor must be supplied a radius that is stored in an instance variable in this class and is used to compute the area As we described above although we cannot constuct a new object from the class Shape we can call the constructor for this class inside the constructor for a subclass as the Circle class does with its call of super name in its constructor Because the Circle class is concrete we can construct new objects from this class So we can write Circle c new Circle c1 1 System out println c toString or just c Which will print Circle radius 1 Shape id c1 area 3 141592653589793 In fact we can even write Shape s new Circle c1 1 Note the type System out println s toString or just s which prints exactly the same thing Here is the reasoning Both Shape and Circle define toString methods Java allows us to call toString on such variables In both cases the object to which c s refer is constructed from the Circle class so it is the method DEFINED IN THIS CLASS that is called Stop and think hard Many students reason that since s is DEFINED to be of type Shape then calling s toString calls the toString method defined in the Shape class THIS IS INCORRECT THINKING Recall that Java s rule say that the TYPE determines WHAT methods can be called but the CLASS OF THE OBJECT determines WHICH method is called This is polymorphism in action Of course if we wrote Shape s new Circle c1 1 then we COULD NOT call s setRadius 2 because the type Shape defines no setRadius method But if we wrote Circle c new Circle c1 1 then we COULD call c setRadius 2 because the type Circle does define this method Finally we learn our fourth and last big rule about using abstract We can treat an abstract class as a superclass and extend it its subclasses can override some or all of its inherited abstract methods If through this overriding a subclass contains no more abstract methods that class is concrete and we can construct objects directly from it If it still abstract it too can be used as a superclass until eventually a subclass of a subclass is concrete We can also easily define a simlar subclass for rectangles public class Rectangle extends Shape public Rectangle String name double w double h super name width w height h Overide the abstract method declared in Shape public double getArea return width height public double getWidth return width public double getHeight return height public void setWidthHeight double newWidth double newHeight width newWidth height newHeight public String toString return Rectangle width width height height super toString private double width height Because the Rectangle class is also concrete we can construct new objects from this class too We can write for example Shape s new Rectangle r1 2 3 Note the type System out println s Which will print Rectangle width 2 height 3 Shape id r1 area 6 We can picture such an object using our standard notation Of course it is very simple to add more shapes square triangle etc to this hierarchy by extending the Shape class Neither the Shape class nor Circle and Rectangle need to know any information about such newly added shapes Now lets look at a more complicated example writing parts of a model class that uses arrays abstract classes interfaces Suppose that we wanted to store an array of ten object that were each constructed from subclasses of Shape We could declare Shape allShapes new Shape 1 and then initialize this array Some member migh index circles and some rectangles Now assume that we want to find the two shapes that have the most similar area We can do this by first sorting the shapes in this array by their areas smallest to biggest We can call Arrays sort using the allShapes array and the following anonymous class that implements the correct Comparator Arrays sort allShapes new Comparator public int compare Object o1 Object o2 double areaDiff Shape o1 getArea Shape o2 getArea if areaDiff return 1 else if areaDiff return 1 else return Now we can scan the array to find the adjacent shapes that have the most similar areas int bestIndex 1 double minDist Double MAX VALUE for int i i allShapes length 1 i double newDist allShapes i 1 getArea allShapes i getArea if newDist minDist bestIndex i minDist newDist Now the minimum distance is between bestIndex and bestIndex 1 Doing Without Abstract Methods Classes We can get close to the effect of declaring abstract methods and classes by doing the following Remove the word abstract from each method and class Implement each formerly abstract method by a stub If the method is void its body should be just if its method returns some primitive value return or or or false and if its method returns some reference to an object return null Or just have each method throw UnsupportedOperationException in either case the method does nothing useful Leave unchanged any methods in a subclass that overrides a formerly abstract method Any compiling working classes will still compile work after these changes They will execute identically But other not so good things can also happen We can construct objects from the formerly abstract class when calling their stub methods bad results are returned We can extend the formerly abstract class and forget to override its stub methods when calling these methods the usefuless results are also returned In the latter case which is an easy mistake of omission or even one of misspelling if we used abstract methods the Java compiler would detect and inform us that the subclass must be defined to be abstract because an abstract method was not overridden typically this message doesn t really what it says normally we fix the problem not by defining the class to be abstract but by adding fixing the appropriate method s The designers of Java felt that the possiblity of messing up in this way was too big and introduced the keyword abstract into the language for the purposes explained above Its purpose is much like final for variables we can provide the compiler with extra information about our intent if we do something inconsistant with this intent we receive an error message from the Java compiler The Positional Shape Hierarchy Let s now deal with a more complicated example of a positional shape inheritance hierarchy It is illustrated below graphically the superscript A is used to denote classes that are abstract Here the root of the inheritance hierarchy is shown as the concrete Object class The Shape subclass defined exactly as shown above extends this concrete superclass and introduces an abstract method getArea so it becomes abstract The PositionalShape subclass extends the abstract Shape superclass It defines a constructor that initializes one new instance variable a Point read its Javadoc in the standard Java library that specifies the position of the center of the shape an x y coordinate on a 2 dimensional plane This class adds a few new methods that manipulate the position and adds one additional abstract method that returns the bounding box of the shape the smallest Rectangle in which the shape can be enclosed note this class has the full name java awt Rectange and IS NOT the Rectangle class that we will define read its Javadoc in the standard Java library Finally it adds one additional method that detects whether two shapes may overlap by checking for intersection in their bounding boxes if the bounding boxes don t intersect there is no possibility of an overlap So this class must be abstract because it contains two abstract methods it specifies getBoundingBox and also inherits and doesn t override getArea Here is a complete the class public abstract class PositionalShape extends Shape public PositionalShape String id int centerX int centerY super id center new Point centerX centerY These abstract methods must be defined in a concrete subclass public abstract Rectangle getBoundingBox public Point getCenter return center public double distanceTo PositionalShape other return center distance other center public void moveCenterTo Point newCenter center x newCenter x center y newCenter y public void moveCenterBy int dx int dy center x dx center y dy public boolean mayOverlap PositionalShape other return getBoundingBox intersects other getBoundingBox public String toString return PositionalShape center center super toString Fields private Point center Notice that although this class does not know how bounding boxes are constructed from PositionalShape objects that method is abstract it defines a concrete mayOverlap method because it knows that the getBoundingBox method in any concrete subclass of PositionalShape is defined concretely Thus just as the concrete toString method in the Shape class called the abstract method getArea the concrete mayOverlap method in the PositionalShape class calls the abstract method getBoundingBox Finally we can define the Circle subclass as follows Note that it is concrete it extends the abstract PositionalShape class and overrides both the getArea and getBoundingBox methods public class Circle extends PositionalShape public Circle String name int centerX int centerY double r super name centerX centerY radius r Overide the abstract method declared in Shape public double getArea return Math PI radius radius Overide the abstract method declared in PositionalShapee public Rectangle getBoundingBox return new Rectangle int getCenter x radius int getCenter y radius int 2 radius int 2 radius public double getRadius return radius public void setRadius double newRadius radius newRadius public String toString return Circle radius radius super toString Fields private double radius The bounding boxes are specified by the coordinate of the shapes upper left corner and its width and height For a circel here is a picture of its bounding box Again bounding boxes can detect whether two shapes may overlap by checking for an intersection if the bounding boxes don t intersect there is no possibility of an overlap if they do intersect the shapes must be examined more closely This property is illustrated below Given all this intheritance we can picture the result of calling new Circle c1 1 15 1 by the following picture If you have not already done so download Positional Shape Inheritance Demonstration and run this driver program It contains all the code above as well as the defintion of the Rectangle class Notice in the Rectangle class how we differentiate between the Rectangle class we are defining and the java awt Rectangle class that we are using to help define it no import full class name prefixed by its package name Finally notice that the Shape class defines a concrete PromptForInformation method which is overridden and called via super in the PositionalShape class which is again overridden and called via super in the Circle and Rectangle class a lot like how toString is overridden called in these same classes The result is that there is no checking instanceof or casting in the application This absence is always desired It ensures that if we add other subclasses of PositionalShape they will all work with this application we must change only get in the application to allow it to return other subclasses If you are writing instanceof you are probably not defining your classes correctly making appropriate use of polymorphism For example if you need to know whether a an object is drawn with only straight lines a square rectangle polygon not a circle or elipse don t use instanceof to pick out the right classes Instead define public abstract boolean drawnWithLines inside the Shape class and then override this method in each subclass Inheritance and Interfaces There is another interesting way to design the Circle and Rectangle classes through the use of inheritance of interfaces combined with inheritance of classes abstract classes To do so we must first learn that we can use the keyword extends to specify that one interface extends another In fact UNLIKE CLASSES an interface can extend multiple interfaces much like the way that a class can implement multiple interfaces recall that a class can extend only one other class The use of subinterfaces and superinterfaces will appear immediately below including the specification of a subinterface that extend multiple superinterfaces We will start by specifying two interfaces separately Shape and Position and then one interface that has the properties of both PositionShape Notice that these interfaces include all the abstract and concrete methods defined in the Shape and PositionalShape CLASSES above except toString which is not needed because every class whether or not it implements these interfaces inherits a toString method that it can override public interface Shape public double getArea public String getId public interface Position public Point getCenter public double distanceTo Position other public void moveCenterTo Point newCenter public void moveCenterBy int dx int dy public interface PositionalShape extends Position Shape public Rectangle getBoundingBox public boolean mayOverlap PositionalShape other Here the PositionalShape sub interface inherits all the methods specified in the Position and Shape super interfaces and specifies two new methods Why are these methods new here and not inherited from other interfaces It WOULD NOT make sense to specify getBoundingBox or mayOverlap in either individual interface because the concepts of bounding boxes and overlaping shapes don t make sense when applied to just shapes without positions or just positions without shapes It makes sense to specify these methods only within interfaces combining both shape and position properities If we declare a variable using the PositionalShape interface Java allows us to use such a variable to call methods from the Shape Position and PositionalShape interfaces I guess that we could also call this interfaces ShapelyPosition and this begins to get at the point There is no obvious reason to have Shape as the superclass and then extend it to PositionalShape we could have Position as the superclass and then extend it to ShapelyPositional In the original design we needed to make an arbitrary choice which is the subclass and which is the superclass in this design we avoid making such a choice developing each part on its own can combining them on equal terms Once we define these interfaces we can define three simple classes that implement them the last of these classes it implemented using the first two and will be extended when defining the Circle and Rectangle classes First we define a class that implements the basic part of the Shape interface all but the abstract method It cannot say that it implements Shape because it defines no getArea method public class ShapeBasics public ShapeBasics String id this id id public String getId return id public String toString return ShapeBasics id id private String id Next we similarly define the PositionBasics class It CAN say that it implements Position because it defines all the specified methods the formerly abstract getBoundingBox method is not specified in the Position interface but in PositionalShape Because we can we do specify implements Position public class PositionBasics implements Position public PositionBasics int centerX int centerY center new Point centerX centerY public Point getCenter return center public double distanceTo Position other return center distance other getCenter public void moveCenterTo Point newCenter center x newCenter x center y newCenter y public void moveCenterBy int dx int dy center x dx center y dy public String toString return PositionBasic center center Fields private Point center Note one small change in the distanceTo method It now is implemented via return center distance other getCenter instead of return center distance other center because the Position parameter is an interface and stores no instance variables for this method to access Finally we define an abstract class that implements the basic part of the PositionalShape interface It is this abstract class that our concrete Circle and Rectangle classes will extend The PositionShapeBasics class constructs objects from the ShapeBasics and PositionBasics classes and uses these objects whenever one of their methods is needed This is called delegation one object uses another to implement a method Thus this class defines many methods all those in the Shape Position and PositionalShape interfaces with most being concrete It also has the the same two from the first design abstract methods getArea and getBoundingBox All the concrete methods are implemented by delegation with one line bodies that delegate the call to the right object Note that mayOverap can be defined concretely here knowing that the getBoundingBox method will eventually be defined in a concrete subclass public abstract class PositionalShapeBasics implements PositionalShape public PositionalShapeBasics String name int centerX int centerY s new ShapeBasics name p new PositionBasics centerX centerY These abstracts method must be defined in a concrete subclass public abstract double getArea public abstract Rectangle getBoundingBox public String getId return s getId public double distanceTo Position other return p distanceTo other public Point getCenter return p getCenter public void moveCenterTo Point newCenter p moveCenterTo newCenter public void moveCenterBy int dx int dy p moveCenterBy dx dy public boolean mayOverlap PositionalShape other return getBoundingBox intersects other getBoundingBox public String toString return PositionalShapeBasics s s p p Fields private ShapeBasics s private PositionBasics p Any class extending the PositionalShapeBasics class in this design can do all the jobs of a class subclassing the PositionalShape class in the previous design A class like Circle is defined almostly identically the only difference is on the name of the class it extends and my comments in the class Recall that by knowing Circle extends PositionalShapeBasics and PositionalShapeBasics implements PositionalShape Java deduces and we don t have to write that Circle implements PositionalShape public class Circle extends PositionalShapeBasics public Circle String name int centerX int centerY double r super name centerX centerY radius r Implement the getArea method specified in the Shape interface public double getArea return Math PI radius radius Implement the getBoundingBox method specified inthe PositionalShape interface public Rectangle getBoundingBox return new Rectangle int getCenter x radius int getCenter y radius int 2 radius int 2 radius public double getRadius return radius public void setRadius double newRadius radius newRadius public String toString return Circle radius radius super toString Fields private double radius With this hierarchy we would picture a Circle object as follows Recall that the PositionalShapeBasics abstract class delegates all its methods to the objects referred to by either of its its instance variables So what are the advantage to each design given that by the time we construct Circle and Rectangle subclasses and other similar ones we do so identically As stated above the second design is a bit more symmetrical But the first design is certainly easier to understand 2 abstract classes 2 concrete ones vs 3 interfaces 4 concrete classes and 1 abstract one There is a general design rule that says to prefer delegation to inheritance because you can delegate using many classes but directly inherit from only one Other interfaces classes can more easily be constructed to use properties of these interfaces classes and others like them In fact the pattern used in the second solution although more complicated can be used more often to solve other similar and not so similar problems I think the bottom line is GOOD DESIGN IS A HARD I DO NOT have a goal for this class that you can design elegant inheritance hierarchies I DO have a goal that given an inheritance hierarchy you can quickly read understand and use it extend classes it contains You can download this alternative code in Positional Shape Inheritance Demonstration 2 and run its driver which is identical to the first one It contains all the code above as well as the Rectangle class General Comments on Inheritance In the next lecture we will apply inheritance to acheive a more perfect understanding of exceptions It will introduce no new material In this section I d like to make just a few observations about classes GOOD DESIGN IS A HARD Reread the last part of the previous section Don t try to fix a poor design by hacking it implementation fix the design There are two important relationships between classes we must be be able to recognize and understand and differentiate them The extends mechanism is also know as the IS A mechanism It is appropriate to use when the subclass IS A slightly different extended class than its superclass The delegation mechanism is known as the HAS A mechanism It is appropriate to use when an object from one class HAS A object from another class to help it do its work remember state implement behavior this second object is stored as an instance variable in the first The Liskov subsitution rule If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T Paraphrased If S it is a subclass of T then everything you can do to an object from class T should also make sense and have the same effect for an object from class S An example that is often dragged out is circles and elipses Mathematicians want to say a circle is just a special kind of elipse but the setAxes double x double y method on elipses makes no sense to apply to a circle since it has one radius not a major minor axis Likewise an elipse is not just a special kind of circle the relationship between the radius of a circle and its area makes no sense when speaking about an elipses This at a fundamental level as appealing as it may be a circle and an elipses are not IS A related One could for example define the Circle and Elipses classes separately and then implement the Circle class by delegating its behavior to an Elipse stored as an instance variable ensuring that the major and minor axes are always the same This implementation technique delegation is common It has been asserted that most inheritance problems boil down to a variant of the circle elipses scenario if you are smart enough to spot it If you truly understand this reasoning you will be able to apply it everywhere For example should SortedList extend List no because we can perform many operations on a List that make no sense for a SortedList we can call insertFront and insertRear on a List and the inserted value becomes the first last value respectively in the List but in a SortedList we cannot put values in these places when can put values in but they move to their naturally sorted place But one could for example specify the List and SortedList class separately and then implement the SortedList by delegating its behavior to a List So again we see delegation HAS A relationships are more common than inheritance IS A relationships between classes Generally Classes should be closed for modification but open for extension This means that once the specification and implementation of a class stabilizes we should never change it instead we can extend it with subclasses that behave similarly but not identically if we need different state and behavior Again relationships among classes in a large system is a quite advanced topic We need lots of experience reading classes noticing their designs and learning how to use them effectively before we can start creating complicated designs Finally final as an access modifier for class and methods in classes If a method in a class is prefaced by the final access modifier it means that it cannot be overridden Likewise if a class is prefaced by the the final access modifier it means that it cannot be extended thus none of its methods can be overridden The String class is defined to be final Abstract Rules Review To review here are the four rules for using the abstract keyword collected in one place Any method in a class can be declared abstract Such a method has no body is replaced by just as in interfaces and can be called in other methods defined in that class or be called in methods defined in any of its subclasses or be called using any variables whose type is this class or any of its subclasses If a class defines any abstract methods or as we will see inherits any abstract methods and doesn t override them that class must be defined using the abstract keyword in its access modifiers If a class is defined with the keyword abstract we may call its constructor only via super in a class that extends it not via the new operator That is we cannot explicitly construct an object using an abstract class but we can use it to help construct an object from a subclass We can treat an abstract class as a superclass and extend it its subclasses can override some or all of its inherited abstract methods If through this overriding a subclass contains no more abstract methods that class is concrete and we can construct objects directly from it If it still abstract it too can be used as a superclass until eventually a subclass of a subclass is concrete Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a TA or any other student Does Java allow us to declare a class abstract even if it define and inherits no abstract methods If so what do you expect the properties of the class to be Does it make sense to define a final abstract method use these two access modifiers together Write the ModularCounter class from the previous lecture to implement Counter but not by subclassing IntCounter instead store an IntCounter and delegate all the methods to operate on it Explain how a subclass can overload an inherited method not override it Do you think that an abstract class can say that it implements an interface even if one of the methods in the interface is declared to be abstract in the class Explain why your answer is reasonable ", "_id": "http://www.ics.uci.edu/~pattis/ICS-21/lectures/abstractclasses/lecture.html", "title": "abstract classes", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Abstract Classes</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Abstract Classes</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will continue our discussion of inheritance features by \r\n    examing <b>abstract</b> classes.\r\n  Once again, in many ways abstract classes are a simple concept (involving\r\n    only one new keyword that can be used in two places) that has deep\r\n    ramifications when designing complex class hierarchies.\r\n  We will discuss this Java language feature in the context of the\r\n    <a href=\"../../programs/positionalshapedemo.zip\">\r\n      Positional Shape Inheritance Demo</a>, which you should\r\n      download, run, and examine.\r\n  In this lecture we will compare abstract classes to interfaces (which seem\r\n    closely related: for example we can extend interfaces via inheritance too)\r\n    and see multiple ways to accomplish approximate the same result -and \r\n    compare them.\r\n  Finally, we will examine some general principles for designing classes in\r\n    inheritance hierarchies..\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Definition -->\r\n\r\n<a name=\"Definition\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Defining Abstract Methods and Classes</b></td>\r\n<td width =\"80%\">\r\n  Sometimes a class should define a method that logically belongs in the class,\r\n    but that class cannot specify how to implement the method.\r\n  For example, the <b>Shape</b> class is used as a superclass for 2-dimensional\r\n    shapes (like circles, rectangles, etc).\r\n  Logically, every shape should have a <b>getArea</b> method, because every\r\n    shape has an area.\r\n  But, every shape would compute its area using a different formula, and there\r\n    is no way to specify one <b>getArea</b> method in the <b>Shape</b> class\r\n    that is correct for all its possible subclasses.\r\n  <p>\r\n  In an application, we might want to declare a <b>Shape</b> array, fill it\r\n    with references to objects constructed from actual shapes (subclasses of\r\n    <b>Shape</b>), and then ask each shape to return its area.\r\n  We would like Java to call the correct <b>getShape</b> method for each object\r\n    to compute the result correctly; again, this illustrate how Java implements\r\n    polymorphism to solve such a problem.\r\n  <p>\r\n  We accomplish this in Java by defining the <b>getArea</b> method in the\r\n    <b>Shape</b> class, but by specfying the <b>abstract</b> keyword in its \r\n    list of access modifiers (as a syntax constraint this keyword can be used\r\n    when defining only classes and methods) and then specifying no\r\n    implementation (no method body, just like in an interface).\r\n  We would specify it in the <b>Shape</b> class as follows\r\n  <pre><b>  public abstract double getArea();</b></pre>\r\n  By defining this method, we are telling the Java  compiler that it should\r\n    allows us to call the <b>getArea</b> method using any variable declared\r\n    with the type <b>Shape</b>, or declared with any class that is a subclass\r\n    of <b>Shape</b> (where the definition of <b>getArea</b> will really\r\n    appear).\r\n  For example, we can define the <b>toString</b> method in the <b>Shape</b>\r\n    class as\r\n\r\n  <pre><b>  public String toString( )\r\n  {return \"Shape[id=\"+id+\",area=\"+getArea()+\"]\";}</b></pre>\r\n\r\n  This method calls <b>getArea</b> and returns (as a <b>String</b>) the area of\r\n    the shape.\r\n  Our first big rule about using <b>abstract</b> concerns where abstract\r\n    methods can be called.\r\n  <ol>\r\n    <li>Any method in a class can be declared <b>abstract</b>.\r\n        Such a method has no body (<b>{...}</b> is replaced by just <b>;</b>,\r\n          as in interfaces) and can be called in other methods defined in that\r\n          class, or be called in methods defined in any of its subclasses, or\r\n          be called using any variables whose type is this class or any of its\r\n          subclasses.  \r\n  </ol>\r\n  <p>\r\n  Our second big rule about using <b>abstract</b> concerns the relationship\r\n    between abstract method and the classes in which the are defined.\r\n  <ol start=\"2\">\r\n    <li>\r\n      If a class defines any abstract methods (or, as we will see, inherits\r\n        any abstract methods and doesn't override them), that class must be\r\n        defined using the <b>abstract</b> keyword in its access modifiers.\r\n  </ol>\r\n  If this second rule is violated, the Java compiler will detect and report an\r\n    error, so if we forget to make a class abstract, Java will just remind us\r\n    with no harm caused..\r\n  <p>\r\n  In fact, we will define the <b>Shape</b> class (using an <b>id</b> instance\r\n    variable and constructor) throughout the examples in this lecture as\r\n  <pre><b>  public abstract class Shape {\r\n\r\n    public Shape (String id)\r\n    {this.id = id;}\r\n\r\n    //This abstract method must be defined in a concrete subclass.\r\n    //Note that it is called in this class in the toString method.\r\n    public abstract double getArea();\r\n\r\n    public String getId()\r\n    {return id;}\r\n    \r\n    public String toString( )\r\n    {return \"Shape[id=\"+id+\",area=\"+getArea()+\"]\";}\r\n\r\n    private String id;\r\n  }</b></pre>\r\n  Generally, abstract classes can specify all the standard class components:\r\n    constructors, methods, and instance variables.\r\n  Again, a class must be defined with the keyword <b>abstract</b> (as is the\r\n    case above) if any of its methods is defined with the keyword\r\n    <b>abstract</b> (as is the case above).\r\n  Note that we can call the <b>abstract</b> method in other methods defined in\r\n    the class, even if its body isn't defined yet.\r\n  <p>\r\n  Again, logically this method belongs in the class, even if it cannot\r\n    be written there (because <b>Shape</b> is too high in the hierarchy).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Use -->\r\n\r\n<a name=\"Use\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Using Abstract Classes (as Superclasses)</b></td>\r\n<td width =\"80%\">\r\n  Now, it should be  obvious that it would make no sense to write\r\n  <pre><b>  Shape s = new Shape(\"s1\");\r\n  System.out.println(s);</pre></b>\r\n  because although we are allowed to call the <b>getArea</b> method (Java\r\n    knows the prototype of this method), its implementation\r\n    HAS NOT BEEN SPECIFIED.\r\n  Java would have no idea what code to execute to compute <b>getArea</b>\r\n    inside <b>toString</b>.\r\n  <p>\r\n  But the problem is not in the method call, it is in the construction.\r\n  This issue brings us to our third big rule about using <b>abstract</b> for\r\n    classes, concerning the restriction on calling constructors ONLY IN\r\n    SUBCLASSES.\r\n  <ol start =\"3\">\r\n    <li>\r\n    If a class is defined with the keyword <b>abstract</b>, we may call its\r\n      constructor only via <b>super</b> in a class that extends it, not\r\n      via the <b>new</b> operator.\r\n    That is, we cannot explicitly construct an object using an <b>abstract</b>\r\n      class, but we can use it to help construct an object from a subclass.\r\n  </ol>\r\n  Thus the Java compiler would detect and report an error in the statement\r\n    <b>Shape s = new Shape(\"s1\");</b> and never even get to compiling the\r\n    call to the <b>getArea</b> method.\r\n  <p>\r\n  If we cannot construct an object with an abstract class, what can we do with\r\n    one?\r\n  We can definine a subclass that extends it.\r\n  If the subclass overrides every abstract method that it inherits, then that\r\n    subclass is not abstract.\r\n  But, if it inherits any abstract methods and doesn't override them, then the \r\n    subclass also has abstract methods and must itself also be defined\r\n    abstract.\r\n  We call a \"non-abstract\" class concrete, although there is no keyword with\r\n    this name.\r\n  <p>\r\n  For example, we can define a concrete <b>Circle</b> subclass by extending\r\n    <b>Shape</b> as follows\r\n  <pre><b>  public class Circle extends Shape {\r\n\r\n    public Circle (String name, double r)\r\n    { \r\n      super(name);\r\n      radius = r;\r\n    }\r\n    \r\n    //Overide the abstract method declared in shape\r\n    public double getArea()\r\n    {return Math.PI * radius * radius;}\r\n    \r\n    public double getRadius()\r\n    {return radius;}\r\n    \r\n    public void setRadius(double newRadius)\r\n    {radius = newRadius;}\r\n    \r\n    public String toString( )\r\n    {return \"Circle[\"radius=\"+radius+\",\"+super.toString()+\"];}\r\n\r\n    private double radius;\r\n  }</b></pre>\r\n  Here the <b>Circle</b> subclass does override the one abstract method\r\n    that it inherits from <b>Shape</b>; it defines a few new methods, but none\r\n    of them is abstract; so, it is a concrete class -and therefore not defined\r\n    with the <b>abstract</b> keyword.\r\n  Also notice that its constructor must be supplied a radius that is stored in\r\n     an instance variable in this class, and is used to compute the area.\r\n  As we described above, although we cannot constuct a new object from the\r\n    class <b>Shape</b>, we can call the constructor for this class\r\n    <b>inside</b> the constructor for a subclass (as the <b>Circle</b> class\r\n    does with its call of <b>super(name);</b> in its constructor).\r\n  <p>\r\n  Because the <b>Circle</b> class is concrete, we can construct new objects\r\n    from this class.\r\n  So, we can write\r\n\r\n  <pre><b>  Circle c = new Circle(\"c1\",1.0);\r\n  System.out.println(c.toString());  //or just ...(c);</pre></b>\r\n\r\n  Which will print\r\n    <b>Circle[radius=1.0,Shape[id=c1,,area=3.141592653589793]]</b>\r\n  <p>\r\n  In fact, we can even write\r\n  <pre><b>  Shape s = new Circle(\"c1\",1.0);    //Note the type\r\n  System.out.println(s.toString());  //or just ...(s);</pre></b>\r\n  <p>\r\n  which prints exactly the same thing!\r\n  Here is the reasoning.\r\n  Both <b>Shape</b> and <b>Circle</b> define <b>toString</b> methods, Java\r\n    allows us to call <b>toString</b> on such variables.\r\n  In both cases the object to which <b>c</b>/<b>s</b> refer is constructed\r\n    from the <b>Circle</b> class, so it is the method DEFINED IN THIS CLASS\r\n    that is called.\r\n  <p>\r\n  Stop and think hard!\r\n  Many students reason that since <b>s</b> is DEFINED to be of type\r\n    <b>Shape</b> then calling <b>s.toString</b> calls the <b>toString</b>\r\n    method defined in the <b>Shape</b> class.\r\n  THIS IS INCORRECT THINKING!\r\n  Recall that Java's rule say that the TYPE determines WHAT methods can be\r\n    called, but the CLASS OF THE OBJECT determines WHICH method is called!\r\n  This is polymorphism in action.\r\n  <p>\r\n  Of course, if we wrote <b>Shape s = new Circle(\"c1\",1.0);</b> then we\r\n    COULD NOT call <b>s.setRadius(2.0);</b> because the type <b>Shape</b>\r\n    defines no <b>setRadius</b> method.\r\n  But if we wrote <b>Circle c = new Circle(\"c1\",1.0);</b> then we\r\n    COULD call <b>c.setRadius(2.0);</b> because the type <b>Circle</b>\r\n    does define this method.\r\n  <p>\r\n  Finally we learn our fourth, and last, big rule about using <b>abstract</b>.\r\n  <ol start=\"4\">\r\n    <li>\r\n     We can treat an abstract class as a superclass and extend it; its\r\n       subclasses can override some or all of its inherited abstract methods.\r\n     If through this overriding a subclass contains no more abstract methods,\r\n       that class is concrete (and we can construct objects directly from it).\r\n     If it still abstract, it too can be used as a superclass ... (until\r\n       eventually a subclass of a subclass ... is concrete).\r\n  </ol>\r\n  <p>\r\n  We can also easily define a simlar subclass for rectangles.\r\n  <pre><b>  public class Rectangle extends Shape {\r\n    public Rectangle (String name, double w, double h)\r\n    { \r\n      super(name);\r\n      width  = w;\r\n      height = h;\r\n    }\r\n    \r\n    //Overide the abstract method declared in Shape\r\n    public double getArea()\r\n    {return width*height;}\r\n    \r\n    public double getWidth()\r\n    {return width;}\r\n    \r\n    public double getHeight()\r\n    {return height;}\r\n    \r\n    public void setWidthHeight(double newWidth, double newHeight)\r\n    {\r\n      width  = newWidth;\r\n      height = newHeight;\r\n    }\r\n    \r\n    public String toString( )\r\n    {return \"Rectangle[\"width=\"+width+\",height=\"+height+\",+super.toString()+\"];}\r\n\r\n    private double width, height;\r\n  }</b></pre>\r\n  Because the <b>Rectangle</b> class is also concrete, we can construct new\r\n    objects from this class too.\r\n  We can write, for example\r\n  <pre><b>  Shape s = new Rectangle(\"r1\",2.0,3.0); //Note the type\r\n  System.out.println(s);</pre></b>\r\n  Which will print\r\n    <b>Rectangle[width=2.0,height=3.0,Shape[id=r1,area=6.0]]</b>\r\n  <p>\r\n  We can picture such an object using our standard notation.\r\n</table>\r\n   <img src=\"images/rectangle.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  <p>\r\n  Of course, it is very simple to add more shapes (square, triangle, etc.)\r\n    to this hierarchy by extending the <b>Shape</b> class.\r\n  Neither the <b>Shape</b> class, nor <b>Circle</b> and <b>Rectangle</b>\r\n    need to know any information about such newly added shapes.\r\n  <p>\r\n  Now, lets look at a more complicated example: writing parts of a model\r\n    class that uses arrays, abstract classes interfaces.\r\n  Suppose that we wanted to store an array of ten object that were each\r\n    constructed from subclasses of <b>Shape</b>.\r\n  We could declare <b>Shape[] allShapes = new Shape[10];</b> and then\r\n    initialize this array.\r\n  Some member migh index circles and some rectangles.\r\n  <p>\r\n  Now assume that we want to find the two shapes that have the most similar\r\n    area.\r\n  We can do this by first sorting the shapes in this array by their areas\r\n    (smallest to biggest).\r\n  We can call <b>Arrays.sort</b> using the <b>allShapes</b> array and the\r\n     following anonymous class (that implements the correct <b>Comparator</b>).\r\n<b><pre>  Arrays.sort(allShapes,\r\n    new Comparator () {\r\n      public int compare(Object o1, Object o2)\r\n      {\r\n        double areaDiff = ((Shape)o1).getArea() - ((Shape)o2).getArea();\r\n        if (areaDiff < 0)\r\n          return -1;\r\n        else if (areaDiff > 0)\r\n          return +1;\r\n        else return 0;\r\n      }\r\n    });</pre></b>\r\n  Now we can scan the array to find the adjacent shapes that have the most\r\n    similar areas.<br>\r\n<b><pre>  int bestIndex  = -1;\r\n  double minDist = Double.MAX_VALUE;\r\n  for (int i=0; i&lt;allShapes.length-1; i++) {\r\n    double newDist = allShapes[i+1].getArea()-allShapes[i].getArea();\r\n    if (newDist < minDist) {\r\n      bestIndex = i;\r\n      minDist   = newDist;\r\n    }</pre></b>\r\n  Now, the minimum distance is between <b>bestIndex</b> and <b>bestIndex</b>+1.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Faking It -->\r\n\r\n<a name=\"Fakingit\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Doing Without Abstract Methods/Classes</b></td>\r\n<td width =\"80%\">\r\n  We can get close to the effect of declaring <b>abstract</b> methods and\r\n    classes by doing the following.\r\n  <ul>\r\n    <li>Remove the word <b>abstract</b> from each method and class.\r\n    <li>Implement each formerly <b>abstract</b> method by a stub.\r\n         <ul>\r\n           <li> If the method\r\n          is <b>void</b> its body should be just <b>{}</b>; if its method\r\n          returns some primitive value, return <b>0</b>, or <b>0.0</b>, or\r\n          <b>'?'</b>, or <b>false</b>; and if its method returns some\r\n          reference to an object, return <b>null</b>.\r\n           <li> Or, just have each method throw\r\n          <b>UnsupportedOperationException</b>; in either case the method\r\n            does nothing useful.\r\n         </ul>\r\n    <li>Leave unchanged any methods in a subclass that overrides a formerly\r\n          <b>abstract</b> method.\r\n  </ul>\r\n  Any compiling/working classes will still compile/work after these changes.\r\n  They will execute identically.\r\n  But other -not so good- things can also happen.\r\n  <ul>\r\n    <li>We can construct objects from the formerly <b>abstract</b> class; when\r\n          calling their stub methods, bad results are returned.\r\n    <li>We can extend the formerly <b>abstract</b> class, and forget to\r\n          override its stub methods; when calling these methods, the usefuless\r\n          results are also returned.\r\n  </ul>\r\n  In the latter case, which is an easy mistake of omission (or even one of\r\n    misspelling), if we used <b>abstract</b> methods the Java compiler would\r\n    detect and inform us that the subclass must be defined to be abstract\r\n    because an abstract method was not overridden: typically this message\r\n    doesn't really what it says; normally we fix the problem not by defining\r\n    the class to be <b>abstract</b> but by adding/fixing the appropriate\r\n    method(s).\r\n  <p>\r\n  The designers of Java felt that the possiblity of \"messing up\" in this way\r\n    was too big, and introduced the keyword <b>abstract</b> into the language\r\n    for the purposes explained above.\r\n  Its purpose is much like <b>final</b> for variables: we can provide the\r\n    compiler with extra information about our intent; if we do something\r\n    inconsistant with this intent, we receive an error message from the Java\r\n    compiler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- PositionalShape -->\r\n\r\n<a name=\"Positionalshape\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Positional Shape Hierarchy</b></td>\r\n<td width =\"80%\">\r\n  Let's now deal with a more complicated example of a positional shape\r\n    inheritance hierarchy.\r\n  It is illustrated below graphically; the superscript <b>A</b> is used to\r\n    denote classes that are abstract.\r\n  <p>\r\n   <img src=\"images/positionalshape.gif\"></image>\r\n  <p>\r\n  Here the root of the inheritance hierarchy is shown as the concrete\r\n    <b>Object</b> class.\r\n  The <b>Shape</b> subclass, defined exactly as shown above, extends this\r\n    concrete superclass and introduces an abstract method (<b>getArea</b>),\r\n    so it becomes abstract.\r\n  The <b>PositionalShape</b> subclass, extends the abstract <b>Shape</b>\r\n    superclass.\r\n  <p>\r\n  It defines a constructor that initializes one new instance variable, a\r\n    <b>Point</b> (read its Javadoc in the standard Java library) that\r\n    specifies the position of the center of the shape (an x,y coordinate)\r\n    on a 2-dimensional plane.\r\n  This class adds a few new methods that manipulate the position, and adds one\r\n    additional abstract method that returns the <b>bounding box</b> of the\r\n     shape\r\n    (the smallest <b>Rectangle</b> in which the shape can be enclosed; \r\n    note, this class has the full name <b>java.awt.Rectange</b> and IS NOT\r\n    the <b>Rectangle</b> class that we will define; read its Javadoc in the\r\n    standard Java library).\r\n  Finally, it adds one additional method that detects whether two shapes\r\n    \"may overlap\" by checking for intersection in their bounding boxes: if\r\n    the bounding boxes don't intersect, there is no possibility of an overlap.\r\n  <p>\r\n  So, this class must be abstract because it contains two abstract methods:\r\n    it specifies <b>getBoundingBox</b> and also inherits (and doesn't override)\r\n    <b>getArea</b>.\r\n  Here is a complete the class.\r\n<b><pre>  public abstract class PositionalShape extends Shape {\r\n\r\n    public PositionalShape (String id, int centerX, int centerY)\r\n    { \r\n      super(id);\r\n      center = new Point(centerX,centerY);\r\n    }\r\n    \r\n    //These abstract methods must be defined in a concrete subclass.\r\n    public abstract Rectangle getBoundingBox();\r\n\r\n    public Point getCenter ()\r\n    {return center;}\r\n\r\n    public double distanceTo (PositionalShape other)\r\n    {return center.distance(other.center);}\r\n\r\n    public void moveCenterTo (Point newCenter)\r\n    {\r\n      center.x = newCenter.x;\r\n      center.y = newCenter.y;\r\n    }\r\n\r\n    public void moveCenterBy (int dx, int dy)\r\n    {\r\n      center.x += dx;\r\n      center.y += dy;\r\n    }\r\n\r\n    public boolean mayOverlap (PositionalShape other)\r\n    {return getBoundingBox().intersects(other.getBoundingBox());}\r\n    \r\n    public String toString ()\r\n    {return \"PositionalShape[center=\"+center+\",\"+super.toString()+\"]\";}\r\n\r\n    //Fields\r\n    private Point center;\r\n  }</pre></b>\r\n<p>\r\nNotice that although this class does not know how bounding boxes are\r\n  constructed from <b>PositionalShape</b>  objects (that method is abstract),\r\n  it defines a concrete <b>mayOverlap</b> method because it knows that the\r\n  <b>getBoundingBox</b> method in any concrete subclass of\r\n  <b>PositionalShape</b> is defined concretely.\r\nThus, just as the concrete <b>toString</b> method in the <b>Shape</b> class\r\n  called the abstract method <b>getArea</b>, the concrete <b>mayOverlap</b>\r\n  method in the <b>PositionalShape</b> class calls the abstract method\r\n  <b>getBoundingBox</b>.\r\n<p>\r\nFinally, we can define the <b>Circle</b> subclass as follows.\r\nNote that it is concrete: it extends the abstract <b>PositionalShape</b>\r\n  class, and overrides both the <b>getArea</b> and <b>getBoundingBox</b>\r\n  methods.\r\n<b><pre>  public class Circle extends PositionalShape {\r\n\r\n    public Circle (String name, int centerX, int centerY, double r)\r\n    { \r\n      super(name,centerX,centerY);\r\n      radius = r;\r\n    }\r\n    \r\n    //Overide the abstract method declared in Shape\r\n    public double getArea()\r\n    {return Math.PI * radius * radius;}\r\n\r\n    //Overide the abstract method declared in PositionalShapee\r\n    public Rectangle getBoundingBox()\r\n    {\r\n      return new Rectangle( (int)(getCenter().x-radius),\r\n                            (int)(getCenter().y-radius),\r\n                            (int)(2*radius),\r\n                            (int)(2*radius) );\r\n    }\r\n    \r\n    public double getRadius()\r\n    {return radius;}\r\n  \r\n    public void setRadius(double newRadius)\r\n    {radius = newRadius;}\r\n\r\n    public String toString( )\r\n    {return \"Circle[radius=\"+radius+\",\"+super.toString()+\"]\";}\r\n\r\n    //Fields\r\n    private double radius;\r\n  }</pre></b>\r\n  The bounding boxes are specified by the coordinate of the shapes upper-left\r\n   corner and its width and height.\r\n  For a circel, here is a picture of its bounding box.\r\n  <p>\r\n</table>\r\n   <img src=\"images/boundingbox.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\n  Again, bounding boxes can detect whether two shapes \"may overlap\" by\r\n    checking for an intersection: if the bounding boxes don't intersect,\r\n    there is no possibility of an overlap; if they do intersect, the shapes\r\n    must be examined more closely.\r\n  This property is illustrated below.\r\n<p>\r\n</table>\r\n   <img src=\"images/overlap.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nGiven all this intheritance, we can picture the result of calling\r\n  <b>new Circle(\"c1\", 100, 150, 1.0);</b>\r\n  by the following picture.\r\n<p>\r\n</table>\r\n   <img src=\"images/circleobject.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nIf you have not already done so, download\r\n  <a href=\"../../programs/positionalshapedemo.zip\">\r\n  Positional Shape Inheritance Demonstration</a> and run this driver\r\n  program.\r\nIt contains all the code above, as well as the defintion of the\r\n  <b>Rectangle</b> class.\r\nNotice in the <b>Rectangle</b> class how we differentiate between the\r\n  <b>Rectangle</b> class we are defining and the <b>java.awt.Rectangle</b>\r\n  class that we are using to help define it: no import, full class name\r\n  (prefixed by its package name).\r\n<p>\r\nFinally, notice that the <b>Shape</b> class defines a concrete\r\n  <b>PromptForInformation</b> method, which is overridden (and called via\r\n  <b>super</b>) in the <b>PositionalShape</b> class, which is again overridden\r\n  (and called via <b>super</b>) in the <b>Circle</b> and <b>Rectangle</b>\r\n  class (a lot like how <b>toString</b> is overridden/called in these same\r\n  classes).\r\nThe result is that there is no checking <b>instanceof</b> or casting in the\r\n  application.\r\nThis absence is always desired.\r\nIt ensures that if we add other subclasses of <b>PositionalShape</b> they\r\n  will all work with this application; we must change only <b>get</b> in\r\n  the application to allow it to return other subclasses.\r\n<p>\r\nIf you are writing <b>instanceof</b>, you are probably not defining your\r\n  classes correctly, making appropriate use of polymorphism.\r\nFor example, if you need to know whether a an object is drawn with only\r\n  straight lines (a square, rectangle, polygon; not a circle or elipse),\r\n  don't use <b>instanceof</b> to pick out the right classes.\r\nInstead define <b>public abstract boolean drawnWithLines()</b> inside the\r\n  <b>Shape</b> class and then override this method in each subclass.\r\n<p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Inheritance and Interfaces -->\r\n\r\n<a name=\"Interfaces\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Inheritance and Interfaces</b></td>\r\n<td width =\"80%\">\r\nThere is another interesting way to design the <b>Circle</b> and\r\n  <b>Rectangle</b> classes through the use of inheritance of interfaces,\r\n  combined with inheritance of classes/abstract classes.\r\nTo do so, we must first learn that we can use the keyword <b>extends</b> to\r\n  specify that one interface extends another.\r\nIn fact, UNLIKE CLASSES, an interface can extend multiple interfaces\r\n  (much like the way that a class can implement multiple interfaces; recall\r\n  that a class can extend only one other class).\r\nThe use of subinterfaces and superinterfaces will appear immediately below,\r\n  including the specification of a subinterface that extend multiple\r\n  superinterfaces.\r\n<p>\r\nWe will start by specifying two interfaces separately, <b>Shape</b> and\r\n  <b>Position</b>, and then one interface that has the properties of\r\n  both: <b>PositionShape</b>.\r\nNotice that these interfaces include all the abstract and concrete\r\n  methods defined in the <b>Shape</b> and <b>PositionalShape</b> CLASSES\r\n  above (except <b>toString</b>, which is not needed, because every\r\n  class -whether or not it implements these interfaces- inherits a\r\n  <b>toString</b> method that it can override).\r\n  <pre><b>  public interface Shape {\r\n    public double getArea();\r\n    public String getId();\r\n  }\r\n\r\n  public interface Position {\r\n    public Point     getCenter    ();\r\n    public double    distanceTo   (Position other);\r\n    public void      moveCenterTo (Point newCenter);\r\n    public void      moveCenterBy (int dx, int dy);\r\n  }\r\n\r\n  public interface PositionalShape extends Position,Shape {\r\n    public Rectangle getBoundingBox();\r\n    public boolean   mayOverlap    (PositionalShape other);\r\n  }</pre></b>\r\nHere, the <b>PositionalShape</b> (sub)interface inherits all the methods\r\n  specified in the <b>Position</b> and <b>Shape</b> (super)interfaces,\r\n  and specifies two new methods.\r\nWhy are these methods new here and not inherited from other interfaces?\r\nIt WOULD NOT make sense to specify <b>getBoundingBox</b> or <b>mayOverlap</b>\r\n  in either individual interface, because the concepts of bounding boxes\r\n  and overlaping shapes don't make sense when applied to just shapes without\r\n  positions or just positions without shapes.\r\nIt makes sense to specify these methods only within interfaces combining\r\n   both shape and position properities.\r\n<p>\r\nIf we declare a variable using the <b>PositionalShape</b> interface,\r\n  Java allows us to use such a variable to call methods from the <b>Shape</b>,\r\n  <b>Position</b> and <b>PositionalShape</b> interfaces.\r\nI guess that we could also call this interfaces <b>ShapelyPosition</b>,\r\n  and this begins to get at the point.\r\nThere is no obvious reason to have <b>Shape</b> as the superclass and then\r\n  extend it to <b>PositionalShape</b>; we could have <b>Position</b> as the\r\n  superclass and then extend it to <b>ShapelyPositional</b>.\r\nIn the original design we needed to make an arbitrary choice: which is the\r\n  subclass and which is the superclass; in this design we avoid making such\r\n  a choice, developing each part on its own can combining them on equal terms.\r\n<p>\r\nOnce we define these interfaces, we can define three \"simple\" classes\r\n  that implement them; the last of these classes it implemented using the\r\n  first two, and will be extended when defining the <b>Circle</b> and\r\n  <b>Rectangle</b> classes.\r\nFirst we define a class that implements the basic part of the\r\n   <b>Shape</b> interface (all but the abstract method).\r\nIt cannot say that it <b>implements Shape</b> because it defines no\r\n  <b>getArea</b> method.\r\n<pre><b>  public class ShapeBasics {\r\n\r\n    public ShapeBasics (String id)\r\n    {this.id = id;}\r\n\r\n    public String getId()\r\n    {return id;}\r\n  \r\n    public String toString( )\r\n    {return \"ShapeBasics[id=\"+id+\"]\";}\r\n\r\n    private String id;\r\n  }</b></pre>\r\nNext we similarly define the <b>PositionBasics</b> class.\r\nIt CAN say that it <b>implements Position</b> because it defines all\r\n  the specified methods (the formerly abstract <b>getBoundingBox</b> method\r\n  is not specified in the <b>Position</b> interface, but in\r\n  <b>PositionalShape</b>).\r\nBecause we can, we do specify <b>implements Position</b>.\r\n  <b><pre>  public class PositionBasics implements Position {\r\n\r\n    public PositionBasics (int centerX, int centerY)\r\n    {center = new Point(centerX,centerY);}\r\n    \r\n    public Point getCenter ()\r\n    {return center;}\r\n\r\n    public double distanceTo (Position other)\r\n    {return center.distance(other.getCenter());}\r\n\r\n    public void moveCenterTo (Point newCenter)\r\n    {\r\n      center.x = newCenter.x;\r\n      center.y = newCenter.y;\r\n    }\r\n\r\n    public void moveCenterBy (int dx, int dy)\r\n    {\r\n      center.x += dx;\r\n      center.y += dy;\r\n    }\r\n\r\n    public String toString ()\r\n    {return \"PositionBasic[center=\"+center+\"]\";}\r\n\r\n    //Fields\r\n    private Point center;\r\n  }</pre></b>\r\nNote one small change in the <b>distanceTo</b> method.\r\nIt now is implemented via\r\n  <b>{return center.distance(other.getCenter());}</b> instead of\r\n  <b>{return center.distance(other.center);}</b> because the <b>Position</b>\r\n  parameter is an interface, and stores no instance variables for this method\r\n  to access.\r\n<p>\r\nFinally, we define an abstract class that implements the basic part of the\r\n   <b>PositionalShape</b> interface.\r\nIt is this abstract class that our concrete <b>Circle</b> and </b>Rectangle</b>\r\n  classes will extend.\r\nThe <b>PositionShapeBasics</b> class constructs objects from the\r\n  <b>ShapeBasics</b> and <b>PositionBasics</b> classes, and uses these\r\n  objects whenever one of their methods is needed.\r\nThis is called <b>delegation</b>: one object uses another to implement a\r\n  method.\r\n<p>\r\nThus, this class defines many methods (all those in the <b>Shape</b>,\r\n  <b>Position</b>, and <b>PositionalShape</b> interfaces), with most being\r\n  concrete.\r\nIt also has the the same two (from the first design) abstract methods:\r\n  <b>getArea</b> and <b>getBoundingBox</b>.\r\nAll the concrete methods are implemented by delegation, with one-line bodies\r\n that delegate the call to the right object.\r\nNote that <b>mayOverap</b> can be defined concretely here, knowing that\r\n  the <b>getBoundingBox</b> method will eventually be defined in a concrete\r\n  subclass.\r\n<b><pre>  public abstract class PositionalShapeBasics implements PositionalShape {\r\n\r\n    public PositionalShapeBasics (String name, int centerX, int centerY)\r\n    { \r\n      s  = new ShapeBasics(name);\r\n      p  = new PositionBasics(centerX,centerY);\r\n    }\r\n  \r\n    //These abstracts method must be defined in a concrete subclass.\r\n    public abstract double    getArea();\r\n    public abstract Rectangle getBoundingBox();\r\n    \r\n    public String getId()\r\n    {return s.getId();}\r\n    \r\n    public double distanceTo(Position other)\r\n    {return p.distanceTo(other);}\r\n    \r\n    public Point getCenter()\r\n    {return p.getCenter();}\r\n    \r\n    public void moveCenterTo(Point newCenter)\r\n    {p.moveCenterTo(newCenter);}\r\n    \r\n    public void moveCenterBy(int dx, int dy)\r\n    {p.moveCenterBy(dx,dy);}\r\n    \r\n    public boolean mayOverlap(PositionalShape other)\r\n    {return getBoundingBox().intersects(other.getBoundingBox());}\r\n    \r\n    public String toString( )\r\n    {return \"PositionalShapeBasics[s=\"+s+\",p=\"+p+\"]\";}\r\n\r\n    //Fields\r\n    private ShapeBasics    s;\r\n    private PositionBasics p;\r\n  }</pre></b>\r\nAny class extending the <b>PositionalShapeBasics</b> class in this design\r\n  can do all the jobs of a class subclassing the <b>PositionalShape</b> class\r\n  in the previous design.\r\nA class like <b>Circle</b> is defined almostly identically: the only \r\n  difference is on the name of the class it extends (and my comments in\r\n  the class).\r\nRecall that by knowing <b>Circle extends PositionalShapeBasics</b> and\r\n  <b>PositionalShapeBasics implements PositionalShape</b> Java deduces\r\n  (and we don't have to write) that <b>Circle implements PositionalShape</b>.\r\n<b><pre>  public class Circle extends PositionalShapeBasics {\r\n\r\n    public Circle (String name, int centerX, int centerY, double r)\r\n    { \r\n      super(name,centerX,centerY);\r\n      radius = r;\r\n    }\r\n    \r\n    //Implement the getArea method,\r\n    //  specified in the Shape interface\r\n    public double getArea()\r\n    {return Math.PI * radius * radius;}\r\n\r\n    //Implement the getBoundingBox method,\r\n    //  specified inthe PositionalShape interface\r\n    public Rectangle getBoundingBox()\r\n    {\r\n      return new Rectangle( (int)(getCenter().x-radius),\r\n                            (int)(getCenter().y-radius),\r\n                            (int)(2*radius),\r\n                            (int)(2*radius) );\r\n    }\r\n    \r\n    public double getRadius()\r\n    {return radius;}\r\n    \r\n    public void setRadius(double newRadius)\r\n    {radius = newRadius;}\r\n\r\n    public String toString( )\r\n    {return \"Circle[radius=\"+radius+\",\"+super.toString()+\"]\";}\r\n\r\n    //Fields\r\n    private double radius;\r\n  }</b></pre>\r\nWith this hierarchy, we would picture a <b>Circle</b> object as follows.\r\nRecall that the <b>PositionalShapeBasics</b> abstract class delegates\r\n  all its methods to the objects referred to by either of its its instance\r\n  variables.\r\n<p>\r\n</table>\r\n   <img src=\"images/circle2object.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nSo, what are the advantage to each design, given that by the time we\r\n  construct <b>Circle</b> and <b>Rectangle</b> subclasses (and other similar\r\n  ones) we do so identically.\r\nAs stated above, the second design is a bit more symmetrical.\r\nBut the first design is certainly easier to understand (2 abstract classes,\r\n  2 concrete ones; vs. 3 interfaces, 4 concrete classes, and 1 abstract one).\r\nThere is a general design rule that says to prefer delegation to inheritance,\r\n  because you can delegate using many classes but directly inherit from only\r\n  one.\r\nOther interfaces/classes can more easily be constructed to use properties\r\n  of these interfaces/classes, and others like them.\r\nIn fact, the pattern used in the second solution, although more complicated,\r\n  can be used more often to solve other similar (and not so similar) problems.\r\n<p>\r\nI think the bottom line is: GOOD DESIGN IS A HARD.\r\nI DO NOT have a goal for this class that you can design elegant\r\n  inheritance hierarchies.\r\nI DO have a goal that given an inheritance hierarchy, you can quickly read,\r\n  understand, and use it (extend classes it contains).\r\n<p>\r\nYou can download this alternative code in\r\n  <a href=\"../../programs/positionalshapedemo2.zip\">\r\n  Positional Shape Inheritance Demonstration #2</a> and run its driver,\r\n  which is identical to the first one.\r\nIt contains all the code above, as well as the <b>Rectangle</b> class.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- General -->\r\n\r\n<a name=\"General\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>General Comments on Inheritance</b></td>\r\n<td width =\"80%\">\r\nIn the next lecture we will apply inheritance to acheive a more perfect\r\n  understanding of exceptions.\r\nIt will introduce no new material.\r\n<p>\r\nIn this section I'd like to make just a few observations about classes.\r\n<ul>\r\n<li>GOOD DESIGN IS A HARD.\r\nReread the last part of the previous section.\r\nDon't try to fix a poor design by hacking it implementation; fix the design.\r\n<p>\r\n<li>There are two important relationships between classes: we must be\r\n  be able to recognize and understand (and differentiate) them.\r\nThe <b>extends</b> mechanism is also know as the IS-A mechanism.\r\nIt is appropriate to use when the subclass IS-A slightly different (extended)\r\n  class than its superclass.\r\nThe delegation mechanism is known as the HAS-A mechanism.\r\nIt is appropriate to use when an object from one class HAS-A object from \r\n  another class to help it do its work (remember state; implement behavior);\r\n  this second object is stored as an instance variable in the first.\r\n<p>\r\n<li>The Liskov subsitution rule:\r\n<blockquote><i>\r\nIf for each object o1 of type S there is an object o2 of type T such that for\r\n   all programs P defined in terms of T, the behavior of P is unchanged when\r\n   o1 is substituted for o2 then S is a subtype of T.\r\n</i></blockquote>\r\nParaphrased: If S it is a subclass of T, then everything you can do to an\r\n  object from class T should also make sense (and have the same effect)\r\n  for an object from class S.\r\n<p>\r\nAn example that is often dragged out is circles and elipses.\r\nMathematicians want to say a circle is just a special kind of elipse,\r\n  but the <b>setAxes(double x, double y)</b> method on elipses makes no\r\n  sense to apply to a circle (since it has one radius, not a major/minor\r\n  axis).\r\nLikewise an elipse is not just a special kind of circle: the relationship\r\n  between the radius of a circle and its area makes no sense when speaking\r\n  about an elipses.\r\nThis, at a fundamental level, as appealing as it may be, a circle and an\r\n  elipses are not IS-A related.\r\n<p>\r\nOne could, for example, define the <b>Circle</b> and <b>Elipses</b> classes\r\n  separately, and then implement the <b>Circle</b> class by delegating its\r\n  behavior to an <b>Elipse</b> stored as an instance variable, ensuring that\r\n  the major and minor axes are always the same.\r\nThis implementation technique, delegation, is common.\r\n<p>\r\nIt has been asserted that most inheritance problems boil down to a\r\n  variant of the circle/elipses scenario, if you are smart enough to\r\n  spot it.\r\nIf you truly understand this reasoning, you will be able to apply it\r\n  everywhere.\r\nFor example, should <b>SortedList</b> extend <b>List</b>: no, because\r\n  we can perform many operations on a <b>List</b> that make no sense\r\n  for a <b>SortedList</b>: we can call <b>insertFront</b> and <b>insertRear</b>\r\n  on a <b>List</b> and the inserted value becomes the first/last value\r\n  respectively in the <b>List</b>;  but, in a <b>SortedList</b>, we cannot put\r\n  values in these places (when can put values in, but they move to their\r\n  \"naturally sorted\" place).\r\nBut one could, for example, specify the <b>List</b> and <b>SortedList</b> class\r\n  separately, and then implement the <b>SortedList</b> by delegating its\r\n  behavior to a <b>List</b stored as an instance variable, ensuring that\r\n  values are always stored in appropriate indexes.\r\n<p>\r\nSo again, we see delegation (HAS-A relationships) are more common than\r\n  inheritance (IS-A relationships) between classes.\r\n<p>\r\n<li>Generally, \"Classes should be closed for modification but open for\r\n      extension.\"\r\nThis means that once the specification and implementation of a class\r\n  stabilizes, we should never change it; instead we can extend it with\r\n  subclasses that behave similarly but not identically, if we need different\r\n  state and behavior.\r\n</ul>\r\nAgain, relationships among classes in a large system is a quite advanced\r\n  topic.\r\nWe need lots of experience reading classes -noticing their designs and\r\n  learning how to use them effectively- before we can start creating\r\n  complicated designs.\r\n<p>\r\nFinally, <b>final</b> as an access modifier for class and methods in classes.\r\nIf a method in a class is prefaced by the <b>final</b> access modifier, it\r\n   means that it cannot be overridden.\r\nLikewise, if a class is prefaced by the the <b>final</b> access modifier, it\r\n  means that it cannot be extended (thus, none of its methods can be\r\n  overridden).\r\nThe <b>String</b> class is defined to be <b>final</b>.\r\n</ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Abstract Rules Restated -->\r\n\r\n<a name=\"Abstractrules\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Abstract Rules Review</b></td>\r\n<td width =\"80%\">\r\n  To review, here are the four rules for using the <b>abstract</b> keyword,\r\n    collected in one place.\r\n  <ol>\r\n    <li>Any method in a class can be declared <b>abstract</b>.\r\n        Such a method has no body (<b>{...}</b> is replaced by just <b>;</b>,\r\n          as in interfaces) and can be called in other methods defined in that\r\n          class, or be called in methods defined in any of its subclasses, or\r\n          be called using any variables whose type is this class or any of its\r\n          subclasses.  \r\n      <p>\r\n \r\n    <li>\r\n      If a class defines any abstract methods (or, as we will see, inherits\r\n        any abstract methods and doesn't override them), that class must be\r\n        defined using the <b>abstract</b> keyword in its access modifiers.\r\n      <p>\r\n \r\n    <li>\r\n    If a class is defined with the keyword <b>abstract</b>, we may call its\r\n      constructor only via <b>super</b> in a class that extends it, not\r\n      via the <b>new</b> operator.\r\n    That is, we cannot explicitly construct an object using an <b>abstract</b>\r\n      class, but we can use it to help construct an object from a subclass.\r\n    <p> \r\n\r\n    <li>\r\n     We can treat an abstract class as a superclass and extend it; its\r\n       subclasses can override some or all of its inherited abstract methods.\r\n     If through this overriding a subclass contains no more abstract methods,\r\n       that class is concrete (and we can construct objects directly from it).\r\n     If it still abstract, it too can be used as a superclass ... (until\r\n       eventually a subclass of a subclass ... is concrete).\r\n   </ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Does Java allow us to declare a class <b>abstract</b> even if it define and\r\n      inherits no <b>abstract</b> methods?\r\n    If so, what do you expect the properties of the class to be?\r\n<p>\r\n<li>Does it make sense to define a <b>final abstract</b> method (use these\r\n      two access modifiers together)?\r\n<p>\r\n<li>Write the <b>ModularCounter</b> class from the previous lecture to\r\n      implement <b>Counter</b> but not by subclassing <b>IntCounter</b>;\r\n      instead, store an <b>IntCounter</b> and delegate all the methods to \r\n      operate on it.\r\n<p>\r\n<li>Explain how a subclass can overload an inherited method (not override it).\r\n<p>\r\n<li>Do you think that an abstract class can say that it implements an\r\n      interface, even if one of the methods in the interface is declared to\r\n      be abstract in the class?\r\n    Explain why your answer is reasonable.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 30897.0}