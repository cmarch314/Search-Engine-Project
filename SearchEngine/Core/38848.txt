{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 59dD Range and Segment Tree Gabriele Neyer 59 1 Introduction This chapter presents the CGAL range tree and segment tree data structures 59 2 Definitions This section presents d dimensional range and segment trees A one dimensional range tree is a binary search tree on one dimensional point data Here we call all one dimensional data types having a strict ordering like integer and double point data d dimensional point data are d tuples of one dimensional point data A one dimensional segment tree is a binary search tree as well but with one dimensional interval data as input data One dimensional interval data is a pair i e 2 tuple a b where a and b are one dimensional point data of the same type and a b The pair a b represents a half open interval a b Analogously a d dimensional interval is represented by a d tuple of one dimensional intervals The input data type for a d dimensional tree is a container class consisting of a d dimensional point data type interval data type or a mixture of both and optionally a value type which can be used to store arbitrary data E g the d dimensional bounding box of a d dimensional polygon may define the interval data of a d dimensional segment tree and the polygon itself can be stored as its value An input data item is an instance of an input data type The range and segment tree classes are fully generic in the sense that they can be used to define multilayer trees A multilayer tree of dimension number of layers d is a simple tree in the d th layer whereas the k th layer 1 k d 1 of the tree defines a tree where each inner vertex contains a multilayer tree of dimension d k 1 The k 1 dimensional tree which is nested in the k dimensional tree T is called the sublayer tree of T For example a d dim tree can be a range tree on the first layer constructed with respect to the first dimension of d dimensional data items On all the data items in each subtree a d 1 dimensional tree is built either a range or a segment tree with respect to the second dimension of the data items And so on The figures in Sections and illustrate the means of a sublayer tree graphically After creation of the tree further insertions or deletions of data items are disallowed The tree class does neither depend on the type of data nor on the concrete physical representation of the data items E g let a multilayer tree be a segment tree for which each vertex defines a range tree We can choose the data items to consist of intervals of type double and the point data of type integer As value type we can choose string For this generality we have to define what the tree of each dimension looks like and how the input data is organized For dimension k 1 k 4 CGAL provides ready to use range and segment trees that can store k dimensional keys intervals resp Examples illustrating the use of these classes are given in Sections and The description of the functionality of these classes as well as the definition of higher dimensional trees and mixed multilayer trees is given in the reference manual In the following two sections we give short definitions of the version of the range tree and segment tree implemented here together with some examples The presentation closely follows dBvKOS97 59 3 Software Design In order to be able to define a multilayer tree we first designed the range and segment tree to have a template argument defining the type of the sublayer tree With this sublayer tree type information the sublayers could be created This approach lead to nested template arguments since the sublayer tree can again have a template argument defining the sublayer Therefore the internal class and function identifiers got longer than a compiler dependent limit This happend already for d 2 Therefore we chose another object oriented design We defined a pure virtual base class called Tree base from which we derived the classes Range tree d and Segment tree d The constructor of these classes expects an argument called sublayer prototype of type Tree base Since class Range tree d and class Segment tree d are derived from class Tree base one can use an instantiation of class Range tree d or class Segment tree d as constructor argument This argument defines the sublayer tree of the tree E g you can construct a Range tree d with an instantiation of class Segment tree d as constructor argument You then have defined a range tree with a segment tree as sublayer tree Since both classes Range tree d and Segment tree d expect a sublayer tree in their constructor we had to derive a third class called Tree anchor from class Tree base which does not expect a constructor argument An instantiation of this class is used as constructor argument of class Range tree d or Segment tree d in order to stop the recursion All classes provide a clone function which returns an instance a copy of the same tree type The clone function of the sublayer prototype is called in the construction of the tree In case that the sublayer tree again has a sublayer it also has a sublayer prototype which is also cloned and so on Thus a call to the clone function generates a sublayer tree which has the complete knowledge about its sublayer tree The trees allow to perform window queries enclosing queries and inverse range queries on the keys Clearly an inverse range query makes only sense in the segment tree In order to perform an inverse range query a range query of width has to be performed We prefered not to offer an extra function for this sort of query since the inverse range query is a special case of the range query Furthermore offering an inverse range query in the segment tree class implies offering this function also in the range tree class and having an extra item in the traits class that accesses the inverse range query point The trees are templatized with three arguments Data Window and Traits Type Data defines the input data type and type Window defines the query window type The tree uses a well defined set of functions in order to access data These functions have to be provided by class Traits The design partly follows the prototype design pattern in GHJV95 In comparison to our first approach using templates we want to note the following In this approach the sublayer type is defined in use of object oriented programming at run time while in the approach using templates the sublayer type is defined at compile time The runtime overhead caused in use of virtual member functions in this object oriented design is negligible since all virtual functions are non trivial The design concept is illustrated in the figure below E g in order to define a two dimensional multilayer tree which consists of a range tree in the first dimension and a segment tree in the second dimension we proceed as follows We construct an object of type Tree anchor which stops the recursion Then we construct an object of type Segment tree d which gets as prototype argument our object of type Tree anchor After that we define an object of type Range tree d which is constructed with the object of type Segment tree d as prototype argument The following piece of code illustrates the construction of the two dimensional multilayer tree int main Tree Anchor anchor new Tree Anchor Segment Tree d segment tree new Segment Tree d anchor Range Tree d range segment tree new Range Tree d segment tree let data items be a list of Data items range segment tree make tree data items begin data items end Here class Tree Anchor Segment Tree d and Range Tree d are defined by typedefs typedef Tree anchor Data Window Tree Anchor typedef Segment tree d Data Window Interval traits Segment Tree d typedef Range tree d Data Window Point traits Range Tree d Class Tree base and class Tree anchor get two template arguments a class Data which defines the type of data that is stored in the tree and a class Window which defines the type of a query range The derived classes Range tree d and Segment tree d additionally get an argument called Tree traits which defines the interface between the Data and the tree Let the Data type be a d dimensional tuple which is either a point data or an interval data in each dimension Then the class Tree traits provides accessors to the point resp interval data of that tree layer and a compare function Remind our example of the two dimensional tree which is a range tree in the first dimension and a segment tree in the second dimension Then the Tree traits class template argument of class Segment tree d defines an accessor to the interval data of the Data and the Tree traits class template argument of class Range tree d defines an accessor to the point data of Data An example implementation for these classes is listed below struct Data int min max interval data double point point data struct Window int min max double min point max point class Point traits public typedef double Key Key get key Data d return d point key accessor Key get left Window w return w min point Key get right Window w return w max point bool comp Key key1 Key key2 return key1 key2 class Interval traits public typedef int Key Key get left Data d return d min Key get right Data d return d max Key get left win Window w return w min Key get right win Window w return w max bool comp Key key1 Key key2 return key1 key2 59 4 Creating an Arbitrary Multilayer Tree Now let us have a closer look on how a multilayer tree is built In case of creating a d dimensional tree we handle a sequence of arbitrary data items where each item defines a d dimensional interval point or other object The tree is constructed with an iterator over this structure In the i th layer the tree is built with respect to the data slot that defines the i th dimension Therefore we need to define which data slot corresponds to which dimension In addition we want our tree to work with arbitrary data items This requires an adaptor between the algorithm and the data item This is resolved by the use of traits classes implemented in form of a traits class using function objects These classes provide access functions to a specified data slot of a data item A d dimensional tree is then defined separately for each layer by defining a traits class for each layer 59 5 Range Trees A one dimensional range tree is a binary search tree on one dimensional point data The point data of the tree is stored in the leaves Each inner vertex stores the highest entry of its left subtree The version of a range tree implemented here is static which means that after construction of the tree no elements be inserted or deleted A d dimensional range tree is a binary leaf search tree according to the first dimension of the d dimensional point data where each vertex contains a d 1 dimensional search tree of the points in the subtree sublayer tree with respect to the second dimension See dBvKOS97 and Sam9 for more detailed information A d dimensional range tree can be used to determine all d dimensional points that lie inside a given d dimensional interval window query The pictures below show a two dimensional and a d dimensional range tree A two dimensional range tree The tree is a binary search tree on the first dimension Each sublayer tree of a vertex v is a binary search tree on the second dimension The data items in a sublayer tree of v are all data items of the subtree of v A d dimensional range tree For each layer of the tree one sublayer tree is illustrated The tree can be built in O nlogd 1 n time and needs O nlogd 1 n space The d dimensional points that lie in the d dimensional query interval can be reported in O logdn k time where n is the total number of points and k is the number of reported points 59 5 1 Example ofRange Tree on Map like Data The following example program uses the predefined Range tree 2 data structure together with the predefined traits class Range tree map traits 2 which has two template arguments specifying the type of the point data in each dimension CGAL Cartesian double and the value type of the 2 dimensional point data char Therefore the Range tree 2 is defined on 2 dimensional point data each of which is associated with a character Then a few data items are created and put into a list After that the tree is constructed according to that list a window query is performed and the query elements are given out include CGAL Cartesian h include CGAL Range segment tree traits h include CGAL Range tree k h typedef CGAL Cartesian double K typedef CGAL Range tree map traits 2 K char Traits typedef CGAL Range tree 2 Traits Range tree 2 type int main typedef Traits Key Key typedef Traits Interval Interval std vector Key InputList OutputList InputList push back Key K Point 2 8 5 1 a InputList push back Key K Point 2 1 1 1 b InputList push back Key K Point 2 3 2 1 c Range tree 2 type Range tree 2 InputList begin InputList end Interval win Interval K Point 2 4 8 1 K Point 2 5 8 2 std cout n Window Query n Range tree 2 window query win std back inserter OutputList std vector Key iterator current OutputList begin while current OutputList end std cout current first x current first y current second std endl 59 5 2 Example of Range Tree on Set like Data This example illustrates the use of the range tree on 2 dimensional point data no value is associated to a data item After the definition of the tree some input data items are created and the tree is constructed according to the input data items After that a window query is performed and the query elements are given to standard out include CGAL Cartesian h include CGAL Range segment tree traits h include CGAL Range tree k h typedef CGAL Cartesian double K typedef CGAL Range segment tree set traits 2 K Traits typedef CGAL Range tree 2 Traits Range tree 2 type int main typedef Traits Key Key typedef Traits Interval Interval std vector Key InputList OutputList std vector Key iterator first last current InputList push back Key 8 5 1 InputList push back Key 1 1 1 InputList push back Key 3 2 1 Range tree 2 type Range tree 2 InputList begin InputList end Interval win Interval Key 4 8 1 Key 5 8 2 std cout std endl Window Query lower left point 4 5 std cout upper right point 8 1 8 2 std endl Range tree 2 window query win std back inserter OutputList current OutputList begin while current OutputList end std cout current x current y std endl current 59 6 Segment Trees A segment tree is a static binary search tree for a given set of coordinates The set of coordinates is defined by the endpoints of the input data intervals Any two adjacent coordinates build an elementary interval Every leaf corresponds to an elementary interval Inner vertices correspond to the union of the subtree intervals of the vertex Each vertex or leaf v contains a sublayer type or a list if it is one dimensional that will contain all intervals I such that I contains the interval of vertex v but not the interval of the parent vertex of v A d dimensional segment tree can be used to solve the following problems Determine all d dimensional intervals that contain a d dimensional point This query type is called inverse range query Determine all d dimensional intervals that enclose a given d dimensional interval enclosing query Determine all d dimensional intervals that partially overlap or are contained in a given d dimensional interval window query An example of a one dimensional segment tree and an example of a two dimensional segment tree are shown below A one dimensional segment tree The segments and the corresponding elementary intervals are shown below the tree The arcs from the nodes point to their subsets A two dimensional segment tree The first layer of the tree is built according to the elementary intervals of the first dimension Each sublayer tree of a vertex v is a segment tree according to the second dimension of all data items of v The tree can be built in O nlogd n time and needs O nlogd n space The processing time for inverse range queries in an d dimensional segment tree is O logd n k time where n is the total number of intervals and k is the number of reported intervals One possible application of a two dimensional segment tree is the following Given a set of convex polygons in two dimensional space CGAL Polygon 2 we want to determine all polygons that intersect a given rectangular query window Therefore we define a two dimensional segment tree where the two dimensional interval of a data item corresponds to the bounding box of a polygon and the value type corresponds to the polygon itself The segment tree is created with a sequence of all data items and a window query is performed The polygons of the resulting data items are finally tested independently for intersections 59 6 1 Example of Segment Tree on Map like Data The following example program uses the predefined Segment tree 2 data structure together with the predefined traits class Segment tree map traits 2 which has two template arguments specifying the type of the point data in each dimension CGAL Cartesian double and the value type of the 2 dimensional point data char Therefore the Segment tree 2 is defined on 2 dimensional point data CGAL Point 2 Cartesian double each of which is associated with a character Then a few data items are created and put into a list After that the tree is constructed according to that list a window query is performed and the query elements are given out include CGAL Cartesian h include CGAL Segment tree k h include CGAL Range segment tree traits h typedef CGAL Cartesian double K typedef CGAL Segment tree map traits 2 K char Traits typedef CGAL Segment tree 2 Traits Segment tree 2 type int main typedef Traits Interval Interval typedef Traits Pure interval Pure interval typedef Traits Key Key std list Interval InputList OutputList1 OutputList2 InputList push back Interval Pure interval Key 1 5 Key 2 7 a InputList push back Interval Pure interval Key 2 7 Key 3 8 b InputList push back Interval Pure interval Key 6 9 Key 9 13 c InputList push back Interval Pure interval Key 1 3 Key 3 9 d Segment tree 2 type Segment tree 2 InputList begin InputList end Interval a Interval Pure interval Key 3 6 Key 7 12 e Segment tree 2 window query a std back inserter OutputList1 std list Interval iterator j OutputList1 begin std cout n window query 3 6 7 12 n while j OutputList1 end std cout j first first x j first second x j first first y j first second y std endl j Interval b Interval Pure interval Key 6 1 Key 7 11 f Segment tree 2 enclosing query b std back inserter OutputList2 j OutputList2 begin std cout n enclosing query 6 1 7 11 n while j OutputList2 end std cout j first first x j first second x j first first y j first second y std endl j return 59 6 2 Example of Segment Tree on Set like Data This example illustrates the use of the predefined segment tree on 3 dimensional interval data with no value associated After the definition of the traits type and tree type some intervals are constructed and the tree is build according to the intervals Then a window query is performed and the query elements are given out include CGAL Cartesian h include CGAL Segment tree k h include CGAL Range segment tree traits h typedef CGAL Cartesian int K typedef CGAL Range segment tree set traits 3 K Traits typedef CGAL Segment tree 3 Traits Segment tree 3 type int main typedef Traits Interval Interval typedef Traits Key Key std list Interval InputList OutputList InputList push back Interval Key 1 5 7 Key 2 7 9 InputList push back Interval Key 2 7 6 Key 3 8 9 InputList push back Interval Key 6 9 5 Key 9 13 8 InputList push back Interval Key 1 3 4 Key 3 9 8 Segment tree 3 type Segment tree 3 InputList begin InputList end Interval a Key 3 6 5 Key 7 12 8 Segment tree 3 window query a std back inserter OutputList std list Interval iterator j OutputList1 begin std cout n window query 3 6 5 7 12 8 n while j OutputList end std cout j first x j first y std cout j first z j second x std cout j second y j second z std endl j Next chapter dD Range and Segment Tree Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/SearchStructures/Chapter_main.html", "title": "dd range and segment tree", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './SearchStructures/main.tex' -->\n<html> <head>  \n<title>dD Range and Segment Tree</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_59\"></a>\n  \n<h1>Chapter 59<BR>dD Range and Segment Tree</h1>\n \n<A NAME=\"Trees\"></A>\n<EM>Gabriele Neyer</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>59.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nThis chapter presents the C<SMALL>GAL</SMALL> range tree and segment tree\ndata structures.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>59.2&nbsp;&nbsp;&nbsp;Definitions</h2>\n\nThis section presents <MATH><I>d</I></MATH>-dimensional range and segment trees.\nA one-dimensional range tree is a binary search tree on \n<B>one-dimensional point data</B>. \nHere we call all one-dimensional data types having a strict ordering\n(like integer and double) <I>point data</I>. \n<B><MATH><I>d</I></MATH>-dimensional point data</B> are <MATH><I>d</I></MATH>-tuples of one-dimensional \npoint data.\n<P>\n\nA one-dimensional segment tree is a binary search tree as well, but with\n<B>one-dimensional interval data</B> as input data.\nOne-dimensional interval data is a pair (i.e., 2-tuple) <MATH><I>(a,b)</I></MATH>, where <MATH><I>a</I></MATH> \nand <MATH><I>b</I></MATH> are one-dimensional point data of the same type and <MATH><I>a&lt; b</I></MATH>. \nThe pair <MATH><I>(a,b)</I></MATH> represents a half open interval <MATH><I>[a,b)</I></MATH>.\nAnalogously, a <MATH><I>d</I></MATH>-dimensional interval  is represented by a <MATH><I>d</I></MATH>-tuple of\none-dimensional intervals.\n<P>\n\nThe <B>input data type</B> for a <MATH><I>d</I></MATH>-dimensional tree is a container \nclass consisting of a <MATH><I>d</I></MATH>-dimensional point data type, interval data type \nor a mixture of both, and optionally a <B>value type</B>, which \ncan be used to store arbitrary data. \nE.g., the <MATH><I>d</I></MATH>-dimensional bounding box of a <MATH><I>d</I></MATH>-dimensional polygon \nmay define the interval data of a <MATH><I>d</I></MATH>-dimensional segment tree and\nthe polygon itself can be stored as its value.   \nAn <B>input data item</B> is an instance of an input data type.\n<P>\n\nThe range and segment tree classes are fully generic in the sense that they \ncan be used to define <B>multilayer trees</B>. \nA multilayer tree of dimension (number of layers) <MATH><I>d</I></MATH> is a simple tree in \nthe <MATH><I>d</I></MATH>-th layer, whereas the <MATH><I>k</I></MATH>-th layer, <MATH><I>1 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> k <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> d-1</I></MATH>, of the tree \ndefines a tree where each (inner) vertex contains a multilayer tree of \ndimension <MATH><I>d-k+1</I></MATH>.\nThe <MATH><I>k-1</I></MATH>-dimensional tree which is nested in the <MATH><I>k</I></MATH>-dimensional tree \n(<MATH><I>T</I></MATH>) is called the <I>sublayer tree</I> (of <MATH><I>T</I></MATH>).\nFor example, a <MATH><I>d</I></MATH>-dim tree can be a range tree on the first layer, \nconstructed with respect to the first dimension of <MATH><I>d</I></MATH>-dimensional data \nitems.\nOn all the data items in each subtree, a <MATH><I>(d-1)</I></MATH>-dimensional tree is built,\neither a range or a segment tree, with respect to the second dimension of \nthe data items.\nAnd so on.\n\n\nThe figures in Sections&nbsp;<A HREF=\"Chapter_main.html#sec:range_trees\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and&nbsp;<A HREF=\"Chapter_main.html#sec:segment_trees\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\nillustrate the means of a sublayer tree graphically.\n<P>\n\nAfter creation of the tree, further insertions or deletions of data items \nare disallowed.  \nThe tree class does neither depend on the type of data nor on the concrete\nphysical representation of the data items.\nE.g., let a multilayer tree be a segment tree for which each vertex\ndefines a range tree. \nWe can choose the data items to consist of intervals of type <I>double</I> \nand the point data of type <I>integer</I>. \nAs value type we can choose  <I>string</I>.\n<P>\n\nFor this generality we have to\ndefine what the tree of each dimension looks like and how the\ninput data is organized.\nFor dimension <MATH><I>k</I></MATH>, <MATH><I>1 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> k <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 4</I></MATH>, C<SMALL>GAL</SMALL> provides ready-to-use\nrange and segment trees that can store k-dimensional keys\n(intervals resp.). \nExamples illustrating the use of these classes are given in\nSections&nbsp;<A HREF=\"Chapter_main.html#sec:range_tree_ex\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\nand&nbsp;<A HREF=\"Chapter_main.html#sec:segment_tree_ex\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nThe description of the functionality of these classes as well as\nthe definition of higher dimensional trees and mixed multilayer\ntrees is given in the reference manual.\n<P>\n\nIn the following two sections we give short definitions of the version of\nthe range tree and segment tree implemented here together with some\nexamples. The presentation closely follows&nbsp;[<A HREF=\"../biblio.html#Biblio_bkos-cgaa-97\">dBvKOS97</A>].\n\n<a name=\"Section_3\"></a>\n        \n<h2>59.3&nbsp;&nbsp;&nbsp;Software Design</h2>\n<P>\n\nIn order to be able to define a multilayer tree we first\ndesigned the range and segment tree to have a template argument\ndefining the type of the sublayer tree. With this sublayer tree\ntype information the sublayers could be created. This approach lead to nested\ntemplate arguments, since the sublayer tree can again have a template\nargument defining the sublayer. Therefore, the internal class and function\nidentifiers got longer than a compiler-dependent limit.\nThis happend already for <MATH><I>d=2</I></MATH>.\n<P>\n\nTherefore, we chose another, object oriented,\ndesign. We defined  a pure\nvirtual base class called <I>Tree_base</I> from which we derived\nthe classes <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> and  <I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I>.\nThe constructor of these classes expects an argument called\n<I>sublayer_prototype</I> of type <I>Tree_base</I>. \nSince class <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> and class\n<I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> are derived from class <I>Tree_base</I>, one can\nuse an instantiation of class <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> or class\n<I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> as constructor argument.\nThis argument defines the sublayer tree of the tree. E.g., you\ncan construct a <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> with an\ninstantiation of class <I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> as constructor\nargument. You then have defined a range tree with a segment tree\nas sublayer tree. Since both classes <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> and \n<I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> expect a sublayer tree in their constructor\nwe had to derive a third class called <I><A HREF=\"../SearchStructures_ref/Class_Tree_anchor.html#Cross_link_anchor_1276\">Tree_anchor</A></I> from\nclass  <I>Tree_base</I> which\ndoes not expect a constructor argument. An instantiation of this\nclass is used as constructor argument of class <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> or\n<I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> in order to stop the recursion.\n<P>\n\nAll classes provide a <I>clone()</I> function which returns an\ninstance (a copy) of the same tree type. The  <I>clone()</I>\nfunction of the <I>sublayer_prototype</I> is called  in the\nconstruction of the tree. In case that the sublayer tree again\nhas a sublayer, it also has a  <I>sublayer_prototype</I> which is\nalso cloned and so on. Thus, a call to the <I>clone()</I> function\ngenerates a sublayer tree which has the complete knowledge about\nits sublayer tree.\n<P>\n\nThe trees allow to perform\nwindow queries, enclosing queries, and inverse range queries on\nthe keys. Clearly, an inverse range query makes only sense in the\nsegment tree.\nIn order to perform an inverse range query, a range query of\n<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH> width has to be performed. We prefered not to offer an\nextra function for this sort of query, since the inverse range\nquery is a special case of the range query. Furthermore, offering\nan inverse range query in the segment tree class implies offering this\nfunction also in the range tree class and having an extra item in\nthe traits class that accesses the inverse range query point.\n<P>\n\nThe trees are templatized with three arguments: <I>Data, Window</I> \nand <I>Traits</I>. Type <I>Data</I> defines\nthe input data type and type <I>Window</I> defines the query\nwindow type.  The tree uses a well defined set of functions in\norder to access data. These functions have to be provided by\nclass <I>Traits</I>.\n<P>\n\nThe design partly follows  the <I>prototype design pattern</I>\nin&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ghjv-dpero-95\">GHJV95</A>]. In comparison to our first approach\nusing templates we want to note the following: In this approach\nthe sublayer type is defined in\nuse of object oriented programming at run time, while in the\napproach using templates, the sublayer type is defined at compile\ntime.\n<P>\n\nThe runtime overhead caused in use of virtual member\nfunctions in this object oriented design is negligible since all virtual\nfunctions are non trivial.\n\n\nThe design concept is illustrated in the figure below.\n<P>\n\n<img border=0 width=400 height=200 src=\"./rsd.gif\" alt=\"Design of the range and\n  segment tree data structure. The symbol triangle means\nthat the lower class is derived from the upper class.\">\n<P>\n\nE.g. in order to define a two dimensional multilayer tree, which\nconsists of a range tree  in the first dimension and a segment\ntree in the second dimension we proceed as follows: We construct\nan object of type <I><A HREF=\"../SearchStructures_ref/Class_Tree_anchor.html#Cross_link_anchor_1276\">Tree_anchor</A></I> which stops the\nrecursion. Then we construct an object of type <I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I>,\nwhich gets as prototype argument our object of type\n<I><A HREF=\"../SearchStructures_ref/Class_Tree_anchor.html#Cross_link_anchor_1276\">Tree_anchor</A></I>. After that, we define an object of type\n<I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> which is constructed with the object of type\n<I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> as prototype argument.\nThe following piece of code illustrates\nthe construction of the two-dimensional multilayer tree.\n<P>\n\n<pre class=\"Verbatim\">\nint main(){\n  Tree_Anchor *anchor=new Tree_Anchor;\n  Segment_Tree_d *segment_tree = new Segment_Tree_d(*anchor);\n  Range_Tree_d *range_segment_tree = new Range_Tree_d(*segment_tree);\n  /* let data_items be a list of Data items */\n  range_segment_tree-&gt;make_tree(data_items.begin(),data_items.end());\n}\n</pre>\n<P>\n\nHere, class <I>Tree_Anchor, Segment_Tree_d</I>, and\n<I>Range_Tree_d</I> are defined by <I>typedef</I>s:\n<P>\n\n<pre class=\"Verbatim\">\ntypedef <A HREF=\"../SearchStructures_ref/Class_Tree_anchor.html#Cross_link_anchor_1276\">Tree_anchor</A>&lt;Data,Window&gt; Tree_Anchor;\ntypedef <A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A>&lt;Data,Window,Interval_traits&gt; Segment_Tree_d;\ntypedef <A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A>&lt;Data,Window,Point_traits&gt; Range_Tree_d;\n</pre>\n<P>\n\nClass <I>Tree_base</I> and class\n<I><A HREF=\"../SearchStructures_ref/Class_Tree_anchor.html#Cross_link_anchor_1276\">Tree_anchor</A></I> get  two template arguments: a class\n<I>Data</I> which defines the type of data that is stored in\nthe tree, and a class <I>Window</I> which defines the type of a query\nrange.\nThe derived classes <I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> and <I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I>\nadditionally get an argument called\n<I>Tree_traits</I> which defines the interface between the\n<I>Data</I> and the tree. Let the <I>Data</I> type be a <MATH><I>d</I></MATH>-dimensional\ntuple, which is either a point data or an interval data in each\ndimension. Then, the class <I>Tree_traits</I> provides accessors to\nthe point (resp. interval) data of that tree layer and a <A HREF=\"../NumberTypeSupport_ref/Function_compare.html#Cross_link_anchor_1339\">compare</A>\nfunction. Remind our example of the two-dimensional tree which\nis a range tree in  the first dimension and\na segment tree  in the second dimension. Then, the\n<I>Tree_traits</I> class template argument of class\n<I><A HREF=\"../SearchStructures_ref/Class_Segment_tree_d.html#Cross_link_anchor_1263\">Segment_tree_d</A></I> defines an accessor to the interval data of\nthe <I>Data</I>, and the\n<I>Tree_traits</I> class template argument of class\n<I><A HREF=\"../SearchStructures_ref/Class_Range_tree_d.html#Cross_link_anchor_1255\">Range_tree_d</A></I> defines an accessor to the point data of\n<I>Data</I>.\nAn example implementation for these classes is listed below.\n<P>\n\n<pre class=\"Verbatim\">\nstruct Data{\n  int <A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A>,<A HREF=\"../NumberTypeSupport_ref/Function_max.html#Cross_link_anchor_1392\">max</A>;  /* interval data */\n  double point; /* point data    */\n};\n \nstruct Window{\n  int <A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A>,<A HREF=\"../NumberTypeSupport_ref/Function_max.html#Cross_link_anchor_1392\">max</A>;\n  double min_point, max_point;\n};\n\nclass Point_traits{\n public:\n  typedef double Key;\n  Key get_key(Data&amp;  d){return d.point;} /*key accessor */\n  Key get_left(Window&amp; w){return w.min_point;}\n  Key get_right(Window&amp; w){return w.max_point;}\n  bool comp(Key&amp; key1, Key&amp; key2){return (key1 &lt; key2);} \n}\n\nclass Interval_traits{\n public:\n  typedef int Key;\n  Key get_left(Data&amp;  d){return d.<A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A>;}\n  Key get_right(Data&amp;  d){return d.<A HREF=\"../NumberTypeSupport_ref/Function_max.html#Cross_link_anchor_1392\">max</A>;}\n  Key get_left_win(Window&amp; w){return w.<A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A>;}\n  Key get_right_win(Window&amp; w){return w.<A HREF=\"../NumberTypeSupport_ref/Function_max.html#Cross_link_anchor_1392\">max</A>;}\n  bool comp(Key&amp; key1, Key&amp; key2){return (key1 &lt; key2);} \n}\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>59.4&nbsp;&nbsp;&nbsp;Creating an Arbitrary Multilayer Tree</h2>\n\n<A NAME=\"general\"></A>\n<P>\n\nNow let us have a closer look on how a multilayer tree is built.\nIn case of creating a <MATH><I>d</I></MATH>-dimensional tree,  we handle a\nsequence of arbitrary data\nitems, where each item  defines a <MATH><I>d</I></MATH>-dimensional interval, point\nor other object. The tree is constructed with an iterator over\nthis structure. In the <MATH><I>i</I></MATH>-th layer, the tree is\nbuilt with respect to the data slot that defines the <MATH><I>i</I></MATH>-th\ndimension. Therefore, we need to define which data slot\ncorresponds to which dimension.\nIn addition we want our tree to work with arbitrary data items.\nThis requires an\nadaptor between the algorithm and the data item. This is resolved\nby the use of traits classes, implemented in\nform of a traits class using\nfunction objects.\nThese classes provide\naccess functions to a specified data slot of a data item.\nA <MATH><I>d</I></MATH>-dimensional tree is then defined separately for each layer by\ndefining a traits class for each layer.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>59.5&nbsp;&nbsp;&nbsp;Range Trees</h2>\n\n<A NAME=\"sec:range_trees\"></A>\n<P>\n\nA one-dimensional range tree is a binary search tree on one-dimensional \npoint data. \nThe point data of the tree is stored in the leaves. \nEach inner vertex stores the highest entry of its left subtree.\nThe version of a range tree implemented here is static, which means that \nafter construction of the tree, no elements be inserted or deleted.\nA <MATH><I>d</I></MATH>-dimensional range tree is a binary leaf search tree according to the \nfirst dimension of the <MATH><I>d</I></MATH>-dimensional point data, where each vertex contains \na <MATH><I>(d-1)</I></MATH>-dimensional search tree of the points in the subtree (sublayer tree)\nwith respect to the second dimension.\nSee&nbsp;[<A HREF=\"../biblio.html#Biblio_bkos-cgaa-97\">dBvKOS97</A>] and&nbsp;[<A HREF=\"../biblio.html#Biblio_s-dasds-90\">Sam90</A>] for more detailed information.\n<P>\n\nA <MATH><I>d</I></MATH>-dimensional range tree can be used to determine all\n<MATH><I>d</I></MATH>-dimensional points that lie inside  a given <MATH><I>d</I></MATH>-dimensional\ninterval (<I>window_query</I>).\n\n\nThe pictures below show a two-dimensional and a <MATH>d</MATH>-dimensional\nrange tree.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=50% NOWRAP COLSPAN=2>\n    <A NAME=\"User:fig:range.eps\"><img border=0 src=\"./range2.gif\" alt=\"A two-dimensional range tree\"></A>\n    </TD>\n    <A NAME=\"User:fig:d-range.eps\"><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%><img border=0 src=\"./d-range.gif\" alt=\"A d-dimensional range tree\"></A>\n      </TD></TR></TABLE>\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=45%  COLSPAN=2>\n    A two-dimensional range tree. The\n      tree is a binary search tree on the first dimension. Each\n      sublayer tree of a vertex <MATH>v</MATH> is a binary search tree on the\nsecond\n      dimension. The data items in a sublayer tree of <MATH>v</MATH> are\n      all data items of the subtree of <MATH>v</MATH>\n </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\nA d-dimensional range tree. For\n      each layer of the tree, one\n      sublayer tree is illustrated.\n </TD></TR>\n        </TABLE>\n<P>\n\nThe tree can be built in  <MATH><I>O(n</I></MATH>log<MATH><I><SUP>d-1</SUP> n)</I></MATH> time and\nneeds  <MATH><I>O(n</I></MATH>log<MATH><I><SUP>d-1</SUP> n)</I></MATH> space. The <MATH><I>d</I></MATH>-dimensional points that lie in the\n<MATH><I>d</I></MATH>-dimensional query interval can be reported in <MATH><I>O(</I></MATH>log<MATH><I><SUP>d</SUP>n+k)</I></MATH> time,\nwhere <MATH><I>n</I></MATH> is the total number of points and <MATH><I>k</I></MATH> is the number of\nreported points. \n\n\n<h3>59.5.1&nbsp;&nbsp;&nbsp;Example ofRange Tree on Map-like Data</h3>\n\n<A NAME=\"sec:range_tree_ex\"></A>\n<P>\n\nThe following example program uses the predefined <I>   Range_tree_2</I> data structure together with the predefined traits\n  class <I>Range_tree_map_traits_2</I> which has two template\n  arguments specifying the\n  type of the point data in each dimension\n  (<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;</I>) and the value type of the\n  2-dimensional point data (<I>char</I>). Therefore the <I>   Range_tree_2</I> is defined on 2-dimensional point data each of which is\n  associated with a character.\nThen, a few data items are created and put into a list. After\n  that the tree is constructed according to that list, a window\n  query is performed, and the query elements are given out.\n<P>\n\n<pre class=\"Verbatim\">\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/Range_segment_tree_traits.h&gt;\n#include &lt;CGAL/<A HREF=\"../SearchStructures_ref/Class_Range_tree_k.html#Cross_link_anchor_1257\">Range_tree_k</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt; K;\ntypedef CGAL::Range_tree_map_traits_2&lt;K, char&gt; Traits;\ntypedef CGAL::Range_tree_2&lt;Traits&gt; Range_tree_2_type;\n\nint main()\n{\n  typedef Traits::Key Key;                \n  typedef Traits::<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>;    \n\n  std::vector&lt;Key&gt; InputList, OutputList;\n  InputList.push_back(Key(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(8,5.1), 'a'));\n  InputList.push_back(Key(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1,1.1), 'b'));\n  InputList.push_back(Key(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(3,2.1), 'c'));\n\n  Range_tree_2_type Range_tree_2(InputList.begin(),InputList.end());\n  <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> win(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(4,8.1),K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(5,8.2)));\n  std::cout &lt;&lt; &quot;\\n Window Query:\\n &quot;;\n  Range_tree_2.window_query(win, std::back_inserter(OutputList));\n  std::vector&lt;Key&gt;::iterator current=OutputList.begin();\n  while(current!=OutputList.end()){\n    std::cout &lt;&lt; (*current).first.x() &lt;&lt; &quot;,&quot; &lt;&lt; (*current).first.y()\n         &lt;&lt; &quot;:&quot; &lt;&lt; (*current++).second &lt;&lt; std::endl;\n  }\n}\n</pre>\n<P>\n\n<h3>59.5.2&nbsp;&nbsp;&nbsp;Example of Range Tree on Set-like Data</h3>\n<P>\n\nThis example illustrates the use of the range tree on\n2-dimensional point data (no value is associated to a data item).\nAfter the definition of the tree, some input data items are\ncreated and the tree is constructed according to the input data\nitems.\nAfter that, a window query is performed and the query elements\nare given to standard out.\n<P>\n\n<pre class=\"Verbatim\">\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/Range_segment_tree_traits.h&gt;\n#include &lt;CGAL/<A HREF=\"../SearchStructures_ref/Class_Range_tree_k.html#Cross_link_anchor_1257\">Range_tree_k</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt; K;\ntypedef CGAL::Range_segment_tree_set_traits_2&lt;K&gt; Traits;\ntypedef CGAL::Range_tree_2&lt;Traits&gt; Range_tree_2_type;\n\nint main()\n{\n  typedef Traits::Key Key;\n  typedef Traits::<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>;\n  std::vector&lt;Key&gt; InputList, OutputList;\n  std::vector&lt;Key&gt;::iterator first, last, current;\n\n  InputList.push_back(Key(8,5.1));\n  InputList.push_back(Key(1,1.1));\n  InputList.push_back(Key(3,2.1));\n\n  Range_tree_2_type Range_tree_2(InputList.begin(),InputList.end());\n\n  <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> win=<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Key(4,8.1),Key(5,8.2));\n  std::cout &lt;&lt; std::endl &lt;&lt; &quot;Window Query: lower left point: (4.0,5.0),&quot;;\n  std::cout &lt;&lt; &quot;upper right point: (8.1,8.2)&quot; &lt;&lt; std::endl;\n  Range_tree_2.window_query(win, std::back_inserter(OutputList));\n  current=OutputList.begin();\n  while(current!=OutputList.end()){\n    std::cout &lt;&lt; (*current).x()&lt;&lt; &quot;-&quot; &lt;&lt; (*current).y() &lt;&lt; std::endl;\n    current++;\n  }\n}\n</pre>\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>59.6&nbsp;&nbsp;&nbsp;Segment Trees</h2>\n\n<A NAME=\"sec:segment_trees\"></A>\n<P>\n\nA segment tree is a static binary search tree for a given set of\ncoordinates. The set of coordinates is defined by the endpoints\nof the input data intervals. Any two adjacent coordinates\nbuild an elementary interval. Every leaf corresponds to an\nelementary interval.\nInner vertices\ncorrespond to the union of the subtree intervals of the vertex.\nEach vertex or leaf <MATH><I>v</I></MATH> contains a sublayer type (or a\nlist, if it is one-dimensional) that will contain all intervals <MATH><I>I</I></MATH>, such that\n<MATH><I>I</I></MATH>  contains the interval of vertex <MATH><I>v</I></MATH> but not the interval\nof the parent vertex of <MATH><I>v</I></MATH>.\n<P>\n\nA <MATH><I>d</I></MATH>-dimensional segment tree can be used to solve the following problems:\n<UL>\n<LI>Determine all <MATH><I>d</I></MATH>-dimensional intervals that contain a\n  <MATH><I>d</I></MATH>-dimensional point. This query type is called ``inverse\n  range query''.\n  <LI>Determine all <MATH><I>d</I></MATH>-dimensional intervals that enclose a\n    given <MATH><I>d</I></MATH>-dimensional interval\n    (<I>enclosing_query</I>).\n  <LI>Determine all <MATH><I>d</I></MATH>-dimensional intervals that partially overlap or are\n    contained in a given <MATH><I>d</I></MATH>-dimensional interval (<I>window_query</I>).\n</UL>\n<P>\n\nAn example of a one-dimensional segment tree and an example\nof a two-dimensional segment tree are shown below.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR>\n    <A NAME=\"User:fig:segment2.eps\"></A>\n    <TD ALIGN=LEFT VALIGN=TOP WIDTH=50% NOWRAP COLSPAN=2>\n    <img border=0 src=\"./segment2.gif\" alt=\"A one-dimensional segment\ntree\">\n    </TD>\n    <A NAME=\"User:fig:d-segment.eps\"></A>\n    <TD ALIGN=LEFT VALIGN=TOP WIDTH=50%><img border=0\nsrc=\"./d-segment.gif\" alt=\"A d-dimensional segment tree\">\n      </TD></TR></TABLE>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%  COLSPAN=2>\nA one-dimensional segment\n  tree. The segments and the corresponding elementary intervals\n  are shown below the tree. The arcs from the nodes point to\n  their subsets.\n </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=45%>\nA two-dimensional segment\n  tree. The first layer of the tree is built according to the\n  elementary intervals of the first dimension. Each\n  sublayer tree of a vertex  <MATH>v</MATH> is a segment tree according to\n  the  second dimension of all data items of  <MATH>v</MATH>.\n </TD></TR>\n        </TABLE>\n<P>\n\nThe tree can be built in  <MATH><I>O(n</I></MATH>log<MATH><I><SUP>d</SUP> n)</I></MATH> time and\nneeds  <MATH><I>O(n</I></MATH>log<MATH><I><SUP>d</SUP> n)</I></MATH> space.\nThe  processing time for inverse range\nqueries in an <MATH><I>d</I></MATH>-dimensional segment tree is <MATH><I>O(</I></MATH>log<MATH><I><SUP>d</SUP> n\n+k)</I></MATH> time, where <MATH><I>n</I></MATH> is the total number of intervals and <MATH><I>k</I></MATH> is\nthe number of reported intervals.\n<P>\n\nOne possible application of a two-dimensional segment tree is the\nfollowing. Given a set of convex polygons in two-dimensional\nspace (<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_671\">CGAL::Polygon_2</A>), we want to determine all polygons\nthat intersect a given rectangular query window. Therefore, we define a\ntwo-dimensional segment tree, where the two-dimensional interval of\na data item corresponds to the  bounding box of a polygon and the\nvalue type corresponds to the polygon itself. The segment tree is created\nwith a sequence of all data items, and a window query is\nperformed. The polygons of the resulting data items are finally\ntested independently for intersections.\n<P>\n\n<h3>59.6.1&nbsp;&nbsp;&nbsp;Example of Segment Tree on Map-like Data</h3>\n\n<A NAME=\"sec:segment_tree_ex\"></A>\n<P>\n\nThe following example program uses the predefined <I>   Segment_tree_2</I> data structure together with the predefined traits\n  class <I>Segment_tree_map_traits_2</I> which has two template arguments\n  specifying the\n  type of the point data in each dimension\n  (<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;</I>) and the value type of the\n  2-dimensional point data (<I>char</I>). Therefore the <I>   Segment_tree_2</I> is defined on 2-dimensional point data\n  (<I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;double&gt; &gt;</I>) each of which is\n  associated with a character.\nThen, a few data items are created and put into a list. After\n  that the tree is constructed according to that list, a window\n  query is performed, and the query elements are given out.\n<P>\n\n<pre class=\"Verbatim\">\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../SearchStructures_ref/Class_Segment_tree_k.html#Cross_link_anchor_1265\">Segment_tree_k</A>.h&gt;\n#include &lt;CGAL/Range_segment_tree_traits.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt; K;\ntypedef CGAL::Segment_tree_map_traits_2&lt;K, char&gt; Traits;\ntypedef CGAL::Segment_tree_2&lt;Traits &gt; Segment_tree_2_type;\n\nint main()\n{\n  typedef Traits::<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>;\n  typedef Traits::Pure_interval Pure_interval;\n  typedef Traits::Key Key;\n  std::list&lt;<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>&gt; InputList, OutputList1, OutputList2;\n\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Pure_interval(Key(1,5), Key(2,7)),'a'));\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Pure_interval(Key(2,7), Key(3,8)),'b'));\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Pure_interval(Key(6,9), Key(9,13)),'c'));\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Pure_interval(Key(1,3), Key(3,9)),'d'));\n \n  Segment_tree_2_type Segment_tree_2(InputList.begin(),InputList.end());\n\n  <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> a=<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Pure_interval(Key(3,6), Key(7,12)),'e');\n  Segment_tree_2.window_query(a,std::back_inserter(OutputList1));\n\n  std::list&lt;<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>&gt;::iterator j = OutputList1.begin();\n  std::cout &lt;&lt; &quot;\\n window_query (3,6),(7,12)\\n&quot;;\n  while(j!=OutputList1.end()){\n    std::cout &lt;&lt; (*j).first.first.x() &lt;&lt; &quot;-&quot; &lt;&lt; (*j).first.second.x() &lt;&lt; &quot; &quot; \n         &lt;&lt; (*j).first.first.y() &lt;&lt; &quot;-&quot; &lt;&lt; (*j).first.second.y() &lt;&lt; std::endl; \n    j++;\n  }\n  \n  <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> b=<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Pure_interval(Key(6,10),Key(7,11)), 'f');\n  Segment_tree_2.enclosing_query(b,std::back_inserter(OutputList2));\n  j = OutputList2.begin();\n  std::cout &lt;&lt; &quot;\\n enclosing_query (6,10),(7,11)\\n&quot;;\n  while(j!=OutputList2.end()){\n    std::cout &lt;&lt; (*j).first.first.x() &lt;&lt; &quot;-&quot; &lt;&lt; (*j).first.second.x() &lt;&lt; &quot; &quot; \n         &lt;&lt; (*j).first.first.y() &lt;&lt; &quot;-&quot; &lt;&lt; (*j).first.second.y() &lt;&lt; std::endl; \n    j++;\n  }\n  return 0; \n}\n\n</pre>\n<P>\n\n<h3>59.6.2&nbsp;&nbsp;&nbsp;Example of Segment Tree on Set-like Data</h3>\n<P>\n\nThis example illustrates the use of the predefined segment tree\non 3-dimensional interval data (with no value associated). After\nthe definition of the traits type and tree type, some intervals\nare constructed and the tree is build according to the\nintervals. Then, a window query is performed and the query\nelements are given out.\n<P>\n\n<pre class=\"Verbatim\">\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../SearchStructures_ref/Class_Segment_tree_k.html#Cross_link_anchor_1265\">Segment_tree_k</A>.h&gt;\n#include &lt;CGAL/Range_segment_tree_traits.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;int&gt; K;\ntypedef CGAL::Range_segment_tree_set_traits_3&lt;K&gt; Traits;\ntypedef CGAL::Segment_tree_3&lt;Traits &gt; Segment_tree_3_type;\n\nint main()\n{\n  typedef Traits::<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>;\n  typedef Traits::Key Key;\n  std::list&lt;<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>&gt; InputList, OutputList;\n\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Key(1,5,7), Key(2,7,9)));\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Key(2,7,6), Key(3,8,9)));\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Key(6,9,5), Key(9,13,8)));\n  InputList.push_back(<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>(Key(1,3,4), Key(3,9,8)));\n \n  Segment_tree_3_type Segment_tree_3(InputList.begin(),InputList.end());\n\n  <A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A> a(Key(3,6,5), Key(7,12,8));\n  Segment_tree_3.window_query(a,std::back_inserter(OutputList));\n  std::list&lt;<A HREF=\"../Interval_skip_list_ref/Concept_Interval.html#Cross_link_anchor_1228\">Interval</A>&gt;::iterator j = OutputList1.begin();\n  std::cout &lt;&lt; &quot;\\n window_query (3,6,5),(7,12,8) \\n&quot;;\n  while(j!=OutputList.end()){\n    std::cout &lt;&lt; (*j).first.x() &lt;&lt; &quot;,&quot; &lt;&lt; (*j).first.y() &lt;&lt; &quot;,&quot;;\n    std::cout &lt;&lt; (*j).first.z() &lt;&lt;&quot;, &quot; &lt;&lt; (*j).second.x() &lt;&lt; &quot;,&quot;;\n    std::cout &lt;&lt; (*j).second.y() &lt;&lt; &quot;,&quot; &lt;&lt; (*j).second.z() &lt;&lt; std::endl; \n    j++;\n  }\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../SearchStructures_ref/Chapter_intro.html\">dD Range and Segment Tree</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_59!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38848.0}