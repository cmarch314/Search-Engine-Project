{"text": "Algorithms for Egyptian Fractions Brute Force Methods The Generalized Remainder Method This is closely related to the binary remainder method and to similar methods cited in the discussion there We find a number p with many divisors compute xp qy r represent q and r as sums of divisors of p and use these representations to expand x y q p r yp Here we assume a value p given by the user and use a close to brute force dynamic programming technique to represent numbers as sums of divisors of p We then use EgyptPairList because our technique does not necessarily avoid duplicate fractions and because the chief goal here is to minimize the number of terms in the expansion SumDivisors n p DivisorSums n p Table If p Mod i i i n DivisorSums n p t If t n t n DivisorSums n p ExtendDivTable t p n ExtendTableEntry e d Append d Select e Last d ExtendDivTable t p n Table If t i t i Join ExtendTableEntry t i Select Divisors p i i n EgyptRemainder Rational x y p Module r s q Quotient x p y r Mod x p y EgyptPairList OuterJoin SumDivisors q p p SumDivisors r p p y In general the behavior of this algorithm depends on the number p which should be chosen to have many divisors factorials are reasonable choices and to make q and r both small With a good choice this seems to be capable of generating very short representations with reasonably small denominators EgyptRemainder 31 311 252 1 1 1 1 1 1 1 1 14 36 2799 87 8 14 36 2177 78372 1 1 1 1 1 1 1 1 12 63 2799 87 8 12 63 2177 78372 The Small Multiple Method If y is prime then any representation of x y must have some terms 1 ky In particular the sum of these terms must be a by where xb a is divisible by y From this we can quickly see that for some x the denominators in any representation must be Omega y log y each such combination a b works for only one x so we need at least y different combinations to be available The idea behind the following method is simply to try all small combinations of terms until finding one cancelling the factor of y The result is a fraction which may well end up with a higher denominator than y but likely has more divisors If y is not prime we first start by greedily removing fractions d y where d is a divisor of y the hope is that this step makes x sufficiently small that a smaller combination a b will work Once we have found a combination that works we are likely to have a denominator with many more divisors so we apply some other method better suited to that case here the small denominator reverse greedy method rather than continuing recursively Subsets s Flatten Distribute s List List ESMGoodFrac Rational a b x y x b a Mod y ESMSubset x y i Select Subsets Table 1 j j i ESMGoodFrac Plus x y ESMFind x y i If ESMFind x y i 1 ESMSubset x y i ESMFrac x y Join EgyptSmallDen x y Plus ESMFind x y 1 y EgyptSmallMult Rational x y Reverse Sort ESMFrac x y It is not clear whether all terms in the representation produced by this method are distinct However it seems to produce good results in practice for moderate inputs If y is prime and this method produces a correct representation in which the largest denominator is divisible by y it will be the representation with the minimum possible denominator EgyptSmallMult 31 311 1 1 1 1 1 1 1 1 28 3 36 933 1555 2177 2799 311 1 1 1 1 1 1 1 15 36 311 1244 1866 2799 311 The Short Sequence Method This method proposed by Stewart Ste92 is based on the following idea If we are looking for any Egyptian fraction representation for q 1 u 1 v then each term must of course be no larger than q itself so u 1 q However if the terms are in sorted order u v and there are a total of k terms then the largest term 1 u must be at least q k So this gives upper and lower bounds for u we simply try all possibilities and continue recursively In the recursive call we have a further bound on the fractions from the assumption that they are generated in sorted order Incidentally since we have a k level recursion and each call generates a finite number of recursive calls the whole call tree must be finite and there are only finitely many k term representations of q To make this method less slow and perhaps even more important to make it use less memory we speed up the case for k 2 We wish to solve the equation x y 1 a 1 b this can be rewritten ax y bx y y 2 and letting the two factors of y 2 be r and s we can solve a r y x b s y x We try all factors r of y 2 for which r y and collect the ones that make a b integers Note that if a is an integer b must also be an integer so we only need one test EgyptTwoTerm Rational x y minden preplist Join preplist x x y y Select y Take Quotient Length 2 Divisors y 2 Mod x minden x EgyptShort q k EShortRecur q k 1 EShortRecur q k b a If q a If k 2 EgyptTwoTerm q b a Join Table EShortRecur q 1 i k 1 i 1 Append a 1 i i Max b Ceiling 1 q Floor k q This method is quite slow taking four minutes on my Powerbook 54 c to solve the following example A C version that I also coded up performs much more quickly solving the same problem in less than a minute but because it is less careful than Mathematica about arithmetic overflow it gets the wrong answers EgyptShort 31 311 4 1 1 1 1 1 1 1 1 11 115 1357 4642297 11 115 13662 193131 1 1 1 1 1 1 1 1 11 115 13684 157366 11 116 6728 23 16488 1 1 1 1 1 1 1 1 11 116 6842 396836 11 118 3421 4 3678 1 1 1 1 1 1 1 1 11 119 2772 19 332 12 62 4628 66927822 1 1 1 1 1 1 1 1 12 62 465 9641 12 62 4665 57846 1 1 1 1 1 1 1 1 12 62 4743 19 332 12 63 2124 77 658 1 1 1 1 1 1 1 1 12 63 2142 19 332 12 63 2177 78372 1 1 1 1 1 1 1 1 12 63 2799 87 8 12 64 1392 577216 1 1 1 1 1 1 1 1 12 68 612 19 332 12 68 622 31722 1 1 1 1 1 1 1 1 12 69 54 193131 12 72 4 8 19 332 1 1 1 1 1 1 1 1 12 78 284 287 53 12 86 212 4252614 1 1 1 1 1 1 1 1 12 1 2 153 19 332 12 119 126 19 332 1 1 1 1 1 1 1 1 13 44 3558 79117467 13 44 35581 48689 4 4 1 1 1 1 1 1 1 1 13 44 35596 71957314 13 44 356 7 442951 8 1 1 1 1 1 1 1 1 13 44 3562 3 464 5 13 44 35646 1876 764 1 1 1 1 1 1 1 1 13 44 35772 6573918 13 44 35893 4 59172 1 1 1 1 1 1 1 1 13 44 36 36 28 1799 13 44 36 76 2579434 1 1 1 1 1 1 1 1 13 44 36322 1737868 13 44 36387 16 1 28 1 1 1 1 1 1 1 1 13 44 4 612 287 53 13 44 41 52 266838 1 1 1 1 1 1 1 1 13 44 43758 19 332 13 44 44473 177892 1 1 1 1 1 1 1 1 13 44 48516 133419 13 44 566 2 95788 1 1 1 1 1 1 1 1 13 52 284 287 53 14 36 2124 77 658 1 1 1 1 1 1 1 1 14 36 2142 19 332 14 36 2177 78372 1 1 1 1 1 1 1 1 14 36 2799 87 8 15 54 69 193131 1 1 1 1 1 1 1 1 16 27 7 72 59383584 16 27 7 74 176 112 1 1 1 1 1 1 1 1 16 27 7344 19 332 16 27 7464 134352 1 1 1 1 1 1 1 1 16 27 8397 44784 16 28 683 2379 256 1 1 1 1 1 1 1 1 16 28 688 93611 18 23 1555 64377 1 1 1 1 1 1 1 1 18 23 1564 19 332 18 24 4 8 19 332 1 1 1 1 1 1 1 1 18 28 119 19 332 18 34 68 19 332 Many of these expansions could have also been obtained by EgyptRemainder using the following numbers as bases Union LCM Denominator 311 2 4 252 432 572 612 1224 1276 1298 1716 186 2 7 3692 4 4 4284 4816 5 6 5148 5568 621 7344 93 11 76 1242 14 76 14868 16588 18972 27348 36 36 4 612 47124 56592 6831 72644 74 8 76496 87516 142428 143572 14927 19 944 39182 43 4 4 462748 465 36 784212 1565564 5 8794 However some for instance 2 7 do not work Egyptian Fractions Number Theory David Eppstein ICS UC Irvine Formatted by nb2html and filter Last update ", "_id": "http://www.ics.uci.edu/~eppstein/numth/egypt/force.html", "title": "", "html": "<!-- This document automatically created using nb2html -->\n<!--         nb2html is Copyright T.D.Robb 1994        -->\n<H1><CENTER>\nAlgorithms for Egyptian Fractions\n</CENTER></H1>\n<P>\n<HR><H2><IMG SRC=\"mmaSection.gif\" ALT=\"o\">\nBrute Force Methods\n</H2>\n<P>\n<A NAME=\"genrem\"><H3><IMG SRC=\"mmaSubSection.gif\" ALT=\"+\">\nThe Generalized Remainder Method\n</H3>\n<P>\n</A>This is closely related to the\n<A HREF=\"binary.html#binrem\">binary remainder method</A>, and to similar methods cited in the discussion there.  We find a number p with many divisors, compute xp=qy+r, represent q and r as sums of divisors of p, and use these representations to expand x/y=q/p + r/yp.\n<P>\nHere we assume a value p given by the user, and use a close-to-brute-force dynamic programming technique to represent numbers as sums of divisors of p.  We then use\n<A HREF=\"conflict.html#pair\">EgyptPairList</A> because our technique does not necessarily avoid duplicate fractions (and because the chief goal here is to minimize the number of terms in the expansion).\n<BLOCKQUOTE><PRE><B>\nSumDivisors[n_,p_] :=\n\tDivisorSums[n,p,\n\t\t\t\tTable[If[p ~Mod~ i == 0, {{i}}, {}],{i,n}]];\n\nDivisorSums[n_,p_,t_] :=\n\tIf [t[[n]] != {}, t[[n]],\n\t\tDivisorSums[n,p,ExtendDivTable[t,p,n]]];\n\nExtendTableEntry[e_,d_] :=\n\tAppend[#,d]&amp; /@\n\tSelect[e,Last[#] &lt;= d&amp;];\n\t\nExtendDivTable[t_,p_,n_] :=\n\tTable[If[t[[i]] != {}, t[[i]],\n\t\t  \t Join @@\n\t\t  \t ( ExtendTableEntry[t[[i-#]],#]&amp; /@\n\t\t  \t Select[Divisors[p], #&lt;i&amp;] ) ],\n\t\t  {i,n}]\n\t\t  \nEgyptRemainder[Rational[x_,y_],p_] :=\n   Module[{r, s},\n           q = Quotient[x p, y];\n   \t\t   r = Mod[x p, y];\n           EgyptPairList /@\n           OuterJoin[SumDivisors[q,p]/p,\n           \t\t\t SumDivisors[r,p]/(p*y)]];\n</B></PRE></BLOCKQUOTE>\n<P>\nIn general, the behavior of this algorithm depends on the number p, which should be chosen to have many divisors (factorials are reasonable choices), and to make q and r both small.  With a good choice this seems to be capable of generating very short representations, with reasonably small denominators.\n<BLOCKQUOTE><PRE><B>\nEgyptRemainder[31/311,252]\n</B></PRE></BLOCKQUOTE>\n<BLOCKQUOTE><PRE>\n  1   1    1     1      1   1    1      1\n{{--, --, ----, ----}, {--, --, ----, -----}, \n  14  36  2799  8708    14  36  2177  78372\n \n   1   1    1     1      1   1    1      1\n  {--, --, ----, ----}, {--, --, ----, -----}}\n   12  63  2799  8708    12  63  2177  78372\n</PRE></BLOCKQUOTE>\n<H3><IMG SRC=\"mmaSubSection.gif\" ALT=\"+\">\nThe Small Multiple Method\n</H3>\n<P>\nIf y is prime, then any representation of x/y must have some terms 1/ky.  In particular, the sum of these terms must be a/by where xb-a is divisible by y.  (From this we can quickly see that for some x, the denominators in any representation must be Omega[y log[y]]: each such combination a/b works for only one x so we need at least y different combinations to be available.)\n<P>\nThe idea behind the following method is simply to try all small combinations of terms until finding one cancelling the factor of y.  The result is a fraction which may well end up with a higher denominator than y, but likely has more divisors.\n<P>\nIf y is not prime, we first start by greedily removing fractions d/y where d is a divisor of y;\nthe hope is that this step makes x sufficiently small that a smaller combination a/b will work.\n<P>\nOnce we have found a combination that works, we are likely to have a denominator with many more divisors, so we apply some other method better suited to that case (here, the\n<A HREF=\"greed.html#smallden\">small-denominator reverse greedy method</A>) rather than continuing recursively.\n<BLOCKQUOTE><PRE><B>\nSubsets[s_] :=\n\tFlatten /@ Distribute[{{},{#}}&amp; /@ s, List,List];\n\nESMGoodFrac[Rational[a_,b_],x_,y_] :=\n\t(x*b - a) ~Mod~ y == 0;\n\t\nESMSubset[x_,y_,i_] :=\n\tSelect[Subsets[Table[1/j,{j,i}]],\n\t\t   ESMGoodFrac[Plus@@#,x,y]&amp;];\n\t\t   \nESMFind[x_,y_,i_] :=\n\tIf[# == {}, ESMFind[x,y,i+1], #]&amp; @\n\tESMSubset[x,y,i];\n\nESMFrac[x_,y_] :=\n\t Join[EgyptSmallDen[x/y - Plus@@#], #]&amp; /@\n\t (ESMFind[x,y,1] / y);\n\nEgyptSmallMult[Rational[x_,y_]] :=\n\tReverse[Sort[#]]&amp; /@ ESMFrac[x,y];\n</B></PRE></BLOCKQUOTE>\n<P>\nIt is not clear whether all terms in the representation produced by this method are distinct. However it seems to produce good results in practice for moderate inputs.  If y is prime, and this method produces a correct representation in which the largest denominator is divisible by y, it will be the representation with the minimum possible denominator.\n<BLOCKQUOTE><PRE><B>\nEgyptSmallMult[31/311]\n</B></PRE></BLOCKQUOTE>\n<BLOCKQUOTE><PRE>\n  1   1   1    1    1     1     1     1\n{{--, --, --, ---, ----, ----, ----, ----}, \n  28  30  36  933  1555  2177  2799  3110\n \n   1   1    1    1     1     1     1\n  {--, --, ---, ----, ----, ----, ----}}\n   15  36  311  1244  1866  2799  3110\n</PRE></BLOCKQUOTE>\n<P>\n<A NAME=\"short\"><H3><IMG SRC=\"mmaSubSection.gif\" ALT=\"+\">\nThe Short Sequence Method\n</H3>\n<P>\n</A>This method, proposed by Stewart\n<A HREF=\"refs.html#Ste92\">[Ste92]</A>, is based on the following idea.  If we are looking for any Egyptian fraction representation for q,\n1/u + 1/v + ..., then each term must of course be no larger than q itself; so u &gt;= 1/q.  However if the terms are in sorted order u &gt; v &gt; ..., and there are a total of k terms, then the largest term 1/u must be at least q/k.  So this gives upper and lower bounds for u; we simply try all possibilities and continue recursively.  (In the recursive call we have a further bound on the fractions from the assumption that they are generated in sorted order.)  Incidentally, since we have a k-level recursion, and each call generates a finite number of recursive calls, the whole call tree must be finite and there are only finitely many k-term representations of q.\n<P>\nTo make this method less slow (and perhaps even more important, to make it use less memory), we speed up the case for k=2.  We wish to solve the equation x/y=1/a + 1/b; this can be rewritten (ax-y)(bx-y)=y^2, and letting the two factors of y^2 be r and s we can solve a=(r+y)/x, b=(s+y)/x.  We try all factors r of y^2 for which r&lt;y and collect the ones that make a,b integers.\n(Note that if a is an integer, b must also be an integer, so we only need one test.)\n<BLOCKQUOTE><PRE><B>\nEgyptTwoTerm[Rational[x_,y_],minden_,preplist_] :=\n\tJoin[preplist,{x/#,x(#-y)/(y #)}]&amp; /@\n\tSelect[ y + Take[#,Quotient[Length[#],2]]&amp; @ Divisors[y^2],\n\t\t\tMod[#,x]==0 &amp;&amp; # &gt;= minden*x &amp; ]\n</B></PRE></BLOCKQUOTE>\n<BLOCKQUOTE><PRE><B>\nEgyptShort[q_,k_] := EShortRecur[q,k,1,{}];\nEShortRecur[q_,k_,b_,a_] :=\n\tIf [q == 0, {a},\n\tIf [k &lt;= 2, EgyptTwoTerm[q, b, a],\n\t\tJoin @@\n\t\tTable[EShortRecur[q-1/i,k-1,i+1,Append[a,1/i]],\n\t\t\t  {i,Max[b,Ceiling[1/q]],Floor[k/q]}]]];\n</B></PRE></BLOCKQUOTE>\n<P>\nThis method is quite slow, taking four minutes on my Powerbook 540c to solve the following example.\n<A HREF=\"efrac.c\">A C++ version</A> that I also coded up performs much more quickly (\"solving\" the same problem in less than a minute) but because it is less careful than Mathematica about arithmetic overflow it gets the wrong answers.\n<BLOCKQUOTE><PRE><B>\nEgyptShort[31/311,4]\n</B></PRE></BLOCKQUOTE>\n<BLOCKQUOTE><PRE>\n  1    1     1       1        1    1     1       1\n{{--, ---, -----, --------}, {--, ---, -----, -------}, \n  11  115  13570  46422970    11  115  13662  1931310\n \n   1    1     1       1       1    1    1       1\n  {--, ---, -----, -------}, {--, ---, ----, --------}, \n   11  115  13684  1573660    11  116  6728  23016488\n \n   1    1    1      1       1    1    1      1\n  {--, ---, ----, ------}, {--, ---, ----, ------}, \n   11  116  6842  396836    11  118  3421  403678\n \n   1    1    1      1       1   1    1       1\n  {--, ---, ----, ------}, {--, --, ----, --------}, \n   11  119  2772  190332    12  62  4628  66927822\n \n   1   1    1      1       1   1    1      1\n  {--, --, ----, ------}, {--, --, ----, ------}, \n   12  62  4650  964100    12  62  4665  578460\n \n   1   1    1      1       1   1    1      1\n  {--, --, ----, ------}, {--, --, ----, ------}, \n   12  62  4743  190332    12  63  2124  770658\n \n   1   1    1      1       1   1    1      1\n  {--, --, ----, ------}, {--, --, ----, -----}, \n   12  63  2142  190332    12  63  2177  78372\n \n   1   1    1     1      1   1    1      1\n  {--, --, ----, ----}, {--, --, ----, ------}, \n   12  63  2799  8708    12  64  1392  577216\n \n   1   1    1     1       1   1    1     1\n  {--, --, ---, ------}, {--, --, ---, -----}, \n   12  68  612  190332    12  68  622  31722\n \n   1   1    1      1       1   1    1     1\n  {--, --, ---, -------}, {--, --, ---, ------}, \n   12  69  540  1931310    12  72  408  190332\n \n   1   1    1     1       1   1    1      1\n  {--, --, ---, ------}, {--, --, ---, -------}, \n   12  78  284  287053    12  86  212  4252614\n \n   1    1    1     1       1    1    1     1\n  {--, ---, ---, ------}, {--, ---, ---, ------}, \n   12  102  153  190332    12  119  126  190332\n \n   1   1     1        1        1   1     1        1\n  {--, --, -----, ---------}, {--, --, -----, ---------}, \n   13  44  35580  791174670    13  44  35581  486890404\n \n   1   1     1       1        1   1     1       1\n  {--, --, -----, --------}, {--, --, -----, --------}, \n   13  44  35596  71957314    13  44  35607  44295108\n \n   1   1     1       1        1   1     1       1\n  {--, --, -----, --------}, {--, --, -----, --------}, \n   13  44  35620  30464005    13  44  35646  18760764\n \n   1   1     1       1       1   1     1       1\n  {--, --, -----, -------}, {--, --, -----, -------}, \n   13  44  35772  6573918    13  44  35893  4059172\n \n   1   1     1       1       1   1     1       1\n  {--, --, -----, -------}, {--, --, -----, -------}, \n   13  44  36036  2801799    13  44  36076  2579434\n \n   1   1     1       1       1   1     1       1\n  {--, --, -----, -------}, {--, --, -----, -------}, \n   13  44  36322  1737868    13  44  36387  1601028\n \n   1   1     1      1       1   1     1      1\n  {--, --, -----, ------}, {--, --, -----, ------}, \n   13  44  40612  287053    13  44  41052  266838\n \n   1   1     1      1       1   1     1      1\n  {--, --, -----, ------}, {--, --, -----, ------}, \n   13  44  43758  190332    13  44  44473  177892\n \n   1   1     1      1       1   1     1      1\n  {--, --, -----, ------}, {--, --, -----, -----}, \n   13  44  48516  133419    13  44  56602  95788\n \n   1   1    1     1       1   1    1      1\n  {--, --, ---, ------}, {--, --, ----, ------}, \n   13  52  284  287053    14  36  2124  770658\n \n   1   1    1      1       1   1    1      1\n  {--, --, ----, ------}, {--, --, ----, -----}, \n   14  36  2142  190332    14  36  2177  78372\n \n   1   1    1     1      1   1   1      1\n  {--, --, ----, ----}, {--, --, --, -------}, \n   14  36  2799  8708    15  54  69  1931310\n \n   1   1    1       1        1   1    1       1\n  {--, --, ----, --------}, {--, --, ----, --------}, \n   16  27  7072  59383584    16  27  7074  17600112\n \n   1   1    1      1       1   1    1      1\n  {--, --, ----, ------}, {--, --, ----, ------}, \n   16  27  7344  190332    16  27  7464  134352\n \n   1   1    1      1      1   1    1      1\n  {--, --, ----, -----}, {--, --, ---, --------}, \n   16  27  8397  44784    16  28  683  23790256\n \n   1   1    1     1      1   1    1      1\n  {--, --, ---, -----}, {--, --, ----, ------}, \n   16  28  688  93611    18  23  1555  643770\n \n   1   1    1      1       1   1    1     1\n  {--, --, ----, ------}, {--, --, ---, ------}, \n   18  23  1564  190332    18  24  408  190332\n \n   1   1    1     1       1   1   1     1\n  {--, --, ---, ------}, {--, --, --, ------}}\n   18  28  119  190332    18  34  68  190332\n</PRE></BLOCKQUOTE>\n<P>\nMany of these expansions could have also been obtained by EgyptRemainder, using the following numbers as bases:\n<BLOCKQUOTE><PRE><B>\nUnion[((LCM@@ Denominator/@ #) / 311)&amp; /@ %]\n</B></PRE></BLOCKQUOTE>\n<BLOCKQUOTE><PRE>\n{204, 252, 432, 572, 612, 1224, 1276, 1298, 1716, 1860, \n \n  2070, 3692, 4004, 4284, 4816, 5060, 5148, 5568, 6210, \n \n  7344, 9300, 11076, 12420, 14076, 14868, 16588, 18972, \n \n  27348, 36036, 40612, 47124, 56592, 68310, 72644, 74008, \n \n  76496, 87516, 142428, 143572, 149270, 190944, 391820, \n \n  430404, 462748, 465036, 784212, 1565564, 5087940}\n</PRE></BLOCKQUOTE>\n<P>\nHowever some (for instance 2070) do not work.\n<P><HR><P><A HREF=\"http://www.ics.uci.edu/~eppstein/numth/egypt/\">Egyptian Fractions,\n</A><A HREF=\"http://www.ics.uci.edu/~eppstein/numth/\">Number Theory,\n</A><A HREF=\"http://www.ics.uci.edu/~eppstein/\">David Eppstein,\n</A><A HREF=\"http://www.ics.uci.edu/\">ICS,\n</A><A HREF=\"http://www.uci.edu/\">UC Irvine\n</A><P><SMALL>Formatted by\n<A HREF=\"http://www.hallym.ac.kr/~physics/education/Math/tdr/nbks/sourceCode.html\">nb2html</A> and\n<A HREF=\"http://www.ics.uci.edu/~eppstein/pubs/filter.html\">filter</A>.\n<!--#config timefmt=\"%d %h %Y, %T %Z\" -->Last update:\n<!--#flastmod file=\"egypt.ma\" -->.\n</SMALL>", "id": 22732.0}