{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL y monotone partition 2 Definition Function that produces a set of y monotone polygons that represent a partitioning of a polygon defined on a sequence of points include CGAL partition 2 h template class InputIterator class OutputIterator class Traits OutputIterator y monotone partition 2 InputIterator first InputIterator beyond OutputIterator result Traits traits Default traits computes a partition of the polygon defined by the points in the range first beyond into y monotone polygons The counterclockwise oriented partition polygons are written to the sequence starting at position result The past the end iterator for the resulting sequence of polygons is returned Precondition The points in the range first beyond define a simple counterclockwise oriented polygon Requirements Traits is a model of the concept YMonotonePartitionTraits 2 and for the purposes of checking the postcondition that the partition is valid it should also be a model of YMonotonePartitionIsValidTraits 2 OutputIterator value type should be Traits Polygon 2 InputIterator value type should be Traits Point 2 which should also be the type of the points stored in an object of type Traits Polygon 2 The default traits class Default traits is Partition traits 2 with the representation type determined by InputIterator value type See AlsoCGAL approx convex partition 2 CGAL greene approx convex partition 2 CGAL optimal convex partition 2 CGAL partition is valid 2 CGAL y monotone partition is valid 2 Implementation This function implements the algorithm presented by de Berg et al dBvKOS97 which requires O n logn time and O n space for a polygon with n vertices Example The following program computes a y monotone partitioning of a polygon using the default traits class and stores the partition polygons in the list partition polys It then asserts that each partition polygon produced is in fact y monotone and that the partition is valid Note that these assertions are superfluous unless the postcondition checking for y monotone partition 2 has been turned off file examples Partition 2 y monotone ex C include CGAL basic h include CGAL Exact predicates inexact constructions kernel h include CGAL Partition traits 2 h include CGAL partition 2 h include CGAL point generators 2 h include CGAL random polygon 2 h include cassert include list typedef CGAL Exact predicates inexact constructions kernel K typedef CGAL Partition traits 2 K Traits typedef Traits Point 2 Point 2 typedef Traits Polygon 2 Polygon 2 typedef std list Polygon 2 Polygon list typedef CGAL Creator uniform 2 int Point 2 Creator typedef CGAL Random points in square 2 Point 2 Creator Point generator void make polygon Polygon 2 polygon polygon push back Point 2 391 374 polygon push back Point 2 24 431 polygon push back Point 2 252 34 polygon push back Point 2 374 32 polygon push back Point 2 289 214 polygon push back Point 2 134 39 polygon push back Point 2 68 186 polygon push back Point 2 154 259 polygon push back Point 2 161 1 7 polygon push back Point 2 435 1 8 polygon push back Point 2 2 8 148 polygon push back Point 2 295 16 polygon push back Point 2 421 212 polygon push back Point 2 441 3 3 int main Polygon 2 polygon Polygon list partition polys CGAL random polygon 2 5 std back inserter polygon Point generator 1 make polygon polygon CGAL y monotone partition 2 polygon vertices begin polygon vertices end std back inserter partition polys std list Polygon 2 const iterator poly it for poly it partition polys begin poly it partition polys end poly it assert CGAL is y monotone 2 poly it vertices begin poly it vertices end assert CGAL partition is valid 2 polygon vertices begin polygon vertices end partition polys begin partition polys end return Next y monotone partition is valid 2 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Partition_2_ref/Function_y_monotone_partition_2.html", "title": "y_monotone_partition_2", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Partition_2_ref/y_monotone_partition_2.tex' -->\n<html> <head>  \n<title>y_monotone_partition_2</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_709\"></A>\n\n<A NAME=\"Cross_link_anchor_710\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_735\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Function.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::y_monotone_partition_2\"></A>\n<h2><I>CGAL::y_monotone_partition_2</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nFunction that produces a set of <MATH><I>y</I></MATH>-monotone polygons that \nrepresent a partitioning of a polygon defined on a sequence of points.\n   \n     \n     \n<A NAME=\"Index_anchor_736\"></A>\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/partition_2.h\">CGAL/partition_2.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator, class OutputIterator, class Traits&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_y_monotone_partition_26InputIterator_first+_InputIterator_beyond+_OutputIterator_result+_const_Traits__traits_=_Default_traits9;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Function_y_monotone_partition_2.html#Cross_link_anchor_710\">y_monotone_partition_2</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator beyond,<BR>\n\nOutputIterator result,<BR>\n\nTraits traits = Default_traits)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    computes a partition of the polygon defined \nby the points in the range [<I>first</I>, <I>beyond</I>) into <MATH><I>y</I></MATH>-monotone \npolygons. The counterclockwise-oriented partition polygons are written to\nthe sequence starting at position <I>result</I>.  The past-the-end iterator for \nthe resulting sequence of polygons is returned.<BR>\n\n<EM>Precondition: </EM>The points in the range [<I>first</I>, <I>beyond</I>) define a\nsimple, counterclockwise-oriented polygon.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Requirements</H3>\n<OL>\n    <LI><I>Traits</I> is a model of the concept\n          <I><A HREF=\"Concept_YMonotonePartitionTraits_2.html#Cross_link_anchor_685\">YMonotonePartitionTraits_2</A></I>\n          and, for the purposes\n          of checking the postcondition that the partition is valid, it should \n          also be a model of <I><A HREF=\"Concept_YMonotonePartitionIsValidTraits_2.html#Cross_link_anchor_684\">YMonotonePartitionIsValidTraits_2</A></I>.\n          <LI><I>OutputIterator::value_type</I> should be \n          <I>Traits::<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A></I>.\n    <LI><I>InputIterator::value_type</I> should be <I>Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I>,\n          which should also be the type of the points stored in an object\n          of type <I>Traits::<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A></I>.\n</OL>\n<P>\n\nThe default traits class <I>Default_traits</I> is <I><A HREF=\"Class_Partition_traits_2.html#Cross_link_anchor_690\">Partition_traits_2</A></I>,\nwith the representation type determined by <I>InputIterator::value_type</I>.\n<P>\n\n<H3>See Also</H3><I><A HREF=\"Function_approx_convex_partition_2.html#Cross_link_anchor_697\">CGAL::approx_convex_partition_2</A></I><BR>\n\n<I><A HREF=\"Function_greene_approx_convex_partition_2.html#Cross_link_anchor_701\">CGAL::greene_approx_convex_partition_2</A></I><BR>\n\n<I><A HREF=\"Function_optimal_convex_partition_2.html#Cross_link_anchor_705\">CGAL::optimal_convex_partition_2</A></I><BR>\n\n<I><A HREF=\"Function_partition_is_valid_2.html#Cross_link_anchor_707\">CGAL::partition_is_valid_2</A></I><BR>\n\n<I><A HREF=\"Function_y_monotone_partition_is_valid_2.html#Cross_link_anchor_711\">CGAL::y_monotone_partition_is_valid_2</A></I>\n<P>\n\n<H3>Implementation</H3>\n<P>\n\nThis function implements the algorithm presented by de Berg <I>et al.</I>\n[<A HREF=\"../biblio.html#Biblio_bkos-cgaa-97\">dBvKOS97</A>] which requires <MATH><I>O(n </I></MATH>log<MATH><I>n)</I></MATH> time\nand <MATH><I>O(n)</I></MATH> space for a polygon with <MATH><I>n</I></MATH> vertices.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe following program computes a <MATH><I>y</I></MATH>-monotone partitioning\nof a polygon using the default\ntraits class and stores the partition polygons in the list \n<I>partition_polys</I>.  It then asserts that each partition polygon\nproduced is, in fact, <MATH><I>y</I></MATH>-monotone and that the partition is valid.\n(Note that these assertions are superfluous unless the postcondition\nchecking for <I><A HREF=\"Function_y_monotone_partition_2.html#Cross_link_anchor_710\">y_monotone_partition_2</A></I> has been turned off.)\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Partition_2/y_monotone_ex.C\n\n#include &lt;CGAL/basic.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Partition_traits_2.html#Cross_link_anchor_690\">Partition_traits_2</A>.h&gt;\n#include &lt;CGAL/partition_2.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../Generator_ref/Function_random_polygon_2.html#Cross_link_anchor_1686\">random_polygon_2</A>.h&gt;\n#include &lt;cassert&gt;\n#include &lt;list&gt;\n\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> K;\ntypedef <A HREF=\"Class_Partition_traits_2.html#Cross_link_anchor_689\">CGAL::Partition_traits_2</A>&lt;K&gt;                         Traits;\ntypedef Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                     <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\ntypedef Traits::<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>                                   <A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>;\ntypedef std::list&lt;<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&gt;                                Polygon_list;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1565\">CGAL::Creator_uniform_2</A>&lt;int, <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&gt;               Creator;\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_in_square_2.html#Cross_link_anchor_1699\">CGAL::Random_points_in_square_2</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>, Creator&gt;   Point_generator;\n\nvoid make_polygon(<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&amp; polygon)\n{\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(391, 374));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(240, 431));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(252, 340));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(374, 320));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(289, 214));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(134, 390));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>( 68, 186));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(154, 259));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(161, 107));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(435, 108));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(208, 148));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(295, 160));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(421, 212));\n   polygon.push_back(<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(441, 303));\n}\n\n\nint main( )\n{\n   <A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>    polygon;\n   Polygon_list partition_polys;\n\n/*\n   <A HREF=\"../Generator_ref/Function_random_polygon_2.html#Cross_link_anchor_1685\">CGAL::random_polygon_2</A>(50, std::back_inserter(polygon), \n                          Point_generator(100));\n*/\n   make_polygon(polygon);\n   <A HREF=\"Function_y_monotone_partition_2.html#Cross_link_anchor_709\">CGAL::y_monotone_partition_2</A>(polygon.vertices_begin(), \n                                polygon.vertices_end(),\n                                std::back_inserter(partition_polys));\n\n   std::list&lt;<A HREF=\"../Polygon_ref/Class_Polygon_2.html#Cross_link_anchor_672\">Polygon_2</A>&gt;::const_iterator   poly_it;\n   for (poly_it = partition_polys.begin(); poly_it != partition_polys.end();\n        poly_it++)\n   {\n      assert(<A HREF=\"Function_is_y_monotone_2.html#Cross_link_anchor_703\">CGAL::is_y_monotone_2</A>((*poly_it).vertices_begin(),\n                                   (*poly_it).vertices_end()));\n   }\n\n   assert(<A HREF=\"Function_partition_is_valid_2.html#Cross_link_anchor_707\">CGAL::partition_is_valid_2</A>(polygon.vertices_begin(),\n                                     polygon.vertices_end(),\n                                     partition_polys.begin(),\n                                     partition_polys.end()));\n   return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_y_monotone_partition_is_valid_2.html\"><I>y_monotone_partition_is_valid_2</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_10!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39525.0}