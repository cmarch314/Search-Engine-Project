{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Classes The moniker for this code example is Classes Background In C a class is a blueprint for a new type of object When we write a class we specify everything needed so that our new type of object is able to do everything it needs to do When we re done we ll have a full fledged data type every bit as capable as built in types like int or types in the C Standard library like std string First of all it s important to recognize that C is not unique in offering a feature like this There are a number of programming languages that allow you to define classes and while they all have similarities C offers a decidedly more flexible set of features for defining its classes The more complex feature set offers the upside of finer grained control over both the memory and time efficiency of the objects of your classes as well as being able to design your classes so that they can be used as expressively as the types built into the language The cost of that flexibility as is often the case in C is a dramatic increase in the level of complexity There s simply more to know if you want to write classes well in C This code example begins our exploration of how to design and write classes in C but there is plenty more ground to be covered if we want to gain a full understanding we ll see more details in later code examples Data types in C Some programming languages draw a distinction between the data types built into the language and those you create A notable example is Java which divides all of its types into two categories primitive types and class types with all primitive values being statically allocated and passed by value and all objects the instances of class types being dynamically allocated and passed effectively by reference C does not draw this distinction The built in types like int and the user defined types like those you create by writing classes are on an equal footing Any value of any type is considered to be an object whether the value is an instance of a class or not The objectives rights and responsibilities are all the same for all types A type exhibits at least the following characteristics A type specifies a certain amount of memory that is required for its objects On the ICS 45C VM for example an int object is four bytes We ve seen previously that structs have a size that is at least the sum of the sizes of its members A type specifies a layout for that memory what parts of its objects will be stored where in that memory An int is simple generally a two s complement bitwise representation of an integer Structs lay out their members in the order they listed in the struct s declaration possibly with padding in between them to make data accesses faster Some types support operators that allow us to manipulate their objects though not all operators are supported by all types For example numeric types support arithemtic operators I O streams like std cin and std cout support and respectively arrays pointers and std strings support the indexing operator for indexing and so on Some types support member functions or methods that can be called on objects of those types For example given a std string variable called s we can say s length to get the string s length i e the number of characters it stores Member functions in general are a way to ask an object to do a job for us A type specifies any initialization that will occur at the time its objects are constructed Some types do no initialization e g ints have no default value but others do e g std strings are initialized to be empty unless you explicitly ask to initialize them to something else A type specifies how resources it holds memory open files open connections over a network etc are released upon the death of its objects For example we ve seen that a std string holds among other things a pointer to a dynamically allocated array of chars When the std string dies it needs to be sure that it deallocates that array of chars or the array will have leaked A type specifies how its objects can be copied or moved such as in an assignment operator or passing an object as a parameter to a function For example when a std string is passed to a function by value it s necessary for it to make a copy of its dynamically allocated array of characters so that changes to the formal parameter affect only the copied array not the original A type also specifies whether its objects can be copied or moved Some types such as input streams like std cin are not copyable at all e g you can t pass them to a function by value assign them into another variable of the same type etc Of all of the things you can do with objects of a type a type specifies which can legally be done on const objects of that type and which cannot We ve seen already that const ints can be accessed but not assigned objects of more complex types draw the same distinction between operations that are legal on constant objects and operations that aren t When we write a class we re defining a new data type so these are the various knobs we can in our design Gradually we ll learn how to turn all of these knobs but this example begins by introducing only some of them Here we will explore the implementation and use of a class called Song which defines a new kind of object that might represent a song in a media player application For simplicity we ll say that a song has two properties that are both strings an artist and a title Within that simple framework though lie a number of interesting problems we ll attempt to make the best decisions we can about both design and performance Writing a class in C Interface vs implementation When we write classes in C there are two things we re interested in specifying An interface which specifies what information is stored by objects of a type and what those objects are able to do An implementation which specifies precisely what happens when you objects are asked to do things Members A class interface consists broadly of a set of members There are two kinds of members we ll use for now though I should point out that there are others that we ll see later Member variables which specify data that are stored by objects of the class These parallel the members that we saw in structs previously Member functions also sometimes called methods which specify operations that can be performed by objects of the class Like regular functions member functions specify a sequence of parameters and a return type unlike regular functions though they re called on a particular object i e when we call them we re asking some particular object to do a job for us Public vs private Some members are declared public which means they are intended to be used by code outside of the class they re declared in Others will be declared private meaning that they are only accessible to code within the class e g private member variables in a class can only by accessed by the member functions in that class Note that the distinction between public and private members is a compile time one the compiler will disallow a program from compiling successfully and report an error if code outside of a class attempts to access one of that class private members In general you should tend to want to make details of a class implementation private whenever possible or leave them out of the interface altogether using local variables or other constructs we ve yet to see such as the unnamed namespace instead The fewer details you reveal to other parts of a program the more of those details you can change without breaking the other parts this is the essence of how you write very large programs Class declarations A class declaration is how we specify the existence of a class A class declaration is used to specify how objects of a class are used and has two audiences A human reader who will use the class declaration in order to understand how to write code that makes use of the class A compiler which will use the class declaration in order to know how much memory to allocate to objects of the class how its member variables are laid out and what member functions can legally be called on objects of the class So in a class declaration we specify all of the class members its member variables and member functions both public and private The declaration of a member function is like the function declarations we ve seen before it specifies the existence of the member function without giving it a body Using header and source files As with the declarations of structs we write the declarations of classes in header files whenever we intend those classes to be used in many source files However as with the definitions of functions we ll write definitions of member functions in a single source file Later we ll see that this distinction is more relaxed when writing classes than it is when you write functions motivated largely by efficiency and optimization concerns but we ll start by holding firm to that distinction Quite often we ll arrange things so that every class is a matched pair of files a header file specifying the class declaration and a source file specifying the definitions of its member functions We ll use that arrangement in this example The code The official moniker for this code example is Classes so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code Classes to download the code example into your project directory s app directory Alternatively you can click the link to the tarball below Classes tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/Classes/", "title": "ics 45c fall 2014, code example: classes", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Classes</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Classes</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>Classes</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>In C++, a <i>class</i> is a blueprint for a new type of object.  When we write a class, we specify everything needed so that our new type of object is able to do everything it needs to do.  When we're done, we'll have a full-fledged data type, every bit as capable as built-in types like <b>int</b> or types in the C++ Standard library like <b>std::string</b>.</p>\r\n\r\n<p>First of all, it's important to recognize that C++ is not unique in offering a feature like this.  There are a number of programming languages that allow you to define classes, and while they all have similarities, C++ offers a decidedly more flexible set of features for defining its classes.  The more complex feature set offers the upside of finer-grained control over both the memory and time efficiency of the objects of your classes, as well as being able to design your classes so that they can be used as expressively as the types built into the language.  The cost of that flexibility, as is often the case in C++, is a dramatic increase in the level of complexity.  There's simply more to know if you want to write classes well in C++.</p>\r\n\r\n<p>This code example begins our exploration of how to design and write classes in C++, but there is plenty more ground to be covered if we want to gain a full understanding; we'll see more details in later code examples.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Data types in C++</p>\r\n\r\n<p>Some programming languages draw a distinction between the data types built into the language and those you create.  A notable example is Java, which divides all of its types into two categories: <i>primitive types</i> and <i>class types</i>, with all primitive values being statically-allocated (and passed by value) and all <i>objects</i> (the instances of class types) being dynamically-allocated (and passed, effectively, by reference).</p>\r\n\r\n<p>C++ does not draw this distinction.  The built-in types like <b>int</b> and the user-defined types, like those you create by writing classes, are on an equal footing.  Any value of any type is considered to be an <i>object</i>, whether the value is an instance of a class or not.  The objectives, rights, and responsibilities are all the same for all types.  A type exhibits (at least) the following characteristics:</p>\r\n\r\n<ul>\r\n  <li>A type specifies a certain amount of memory that is required for its objects.  On the ICS 45C VM, for example, an <b>int</b> object is four bytes.  We've seen previously that structs have a size that is (at least) the sum of the sizes of its members.</li>\r\n  <li>A type specifies a layout for that memory &mdash; what parts of its objects will be stored where in that memory?  An <b>int</b> is simple, generally a \"two's complement\" bitwise representation of an integer.  Structs lay out their members in the order they listed in the struct's declaration, possibly with \"padding\" in between them to make data accesses faster.</li>\r\n  <li>Some types support <i>operators</i> that allow us to manipulate their objects, though not all operators are supported by all types.  For example, numeric types support arithemtic operators; I/O streams like <b>std::cin</b> and <b>std::cout</b> support &gt;&gt; and &lt;&lt;, respectively; arrays, pointers, and <b>std::string</b>s support the indexing operator [] for indexing; and so on.</li>\r\n  <li>Some types support <i>member functions</i> (or <i>methods</i>) that can be called on objects of those types.  For example, given a <b>std::string</b> variable called <b>s</b>, we can say <b>s.length()</b> to get the string's length (i.e., the number of characters it stores).  Member functions, in general, are a way to ask an object to do a job for us.</li>\r\n  <li>A type specifies any initialization that will occur at the time its objects are constructed.  Some types do no initialization (e.g., <b>int</b>s have no default value), but others do (e.g., <b>std::string</b>s are initialized to be empty, unless you explicitly ask to initialize them to something else).</li>\r\n  <li>A type specifies how resources it holds &mdash; memory, open files, open connections over a network, etc. &mdash; are released upon the death of its objects.  For example, we've seen that a <b>std::string</b> holds, among other things, a pointer to a dynamically-allocated array of <b>char</b>s.  When the <b>std::string</b> dies, it needs to be sure that it deallocates that array of <b>char</b>s, or the array will have \"leaked.\"</li>\r\n  <li>A type specifies how its objects can be copied or moved, such as in an assignment operator or passing an object as a parameter to a function.  For example, when a <b>std::string</b> is passed to a function by value, it's necessary for it to make a copy of its dynamically-allocated array of characters, so that changes to the formal parameter affect only the copied array, not the original.</li>\r\n  <li>A type also specifies <i>whether</i> its objects can be copied or moved.  Some types, such as input streams like <b>std::cin</b>, are not copyable at all (e.g., you can't pass them to a function by value, assign them into another variable of the same type, etc.).</li>\r\n  <li>Of all of the things you can do with objects of a type, a type specifies which can legally be done on <b>const</b> objects of that type and which cannot.  We've seen already that <b>const int</b>s can be accessed but not assigned; objects of more complex types draw the same distinction between operations that are legal on constant objects and operations that aren't.</li>\r\n</ul>\r\n\r\n<p>When we write a class, we're defining a new data type, so these are the various knobs we can in our design.  Gradually, we'll learn how to turn all of these knobs, but this example begins by introducing only some of them.  Here, we will explore the implementation and use of a class called <b>Song</b>, which defines a new kind of object that might represent a song in a media player application.  For simplicity, we'll say that a song has two properties that are both strings: an artist and a title.  Within that simple framework, though, lie a number of interesting problems; we'll attempt to make the best decisions we can about both design and performance.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Writing a class in C++</p>\r\n\r\n<p class=\"subtitle\">Interface vs. implementation</p>\r\n\r\n<p>When we write classes in C++, there are two things we're interested in specifying:</p>\r\n\r\n<ul>\r\n  <li>An <i>interface</i>, which specifies what information is stored by objects of a type and what those objects are able to do.</li>\r\n  <li>An <i>implementation</i>, which specifies precisely what happens when you objects are asked to do things.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Members</p>\r\n\r\n<p>A class' interface consists, broadly, of a set of <i>members</i>.  There are two kinds of members we'll use for now &mdash; though I should point out that there are others that we'll see later.</p>\r\n\r\n<ul>\r\n  <li><i>Member variables</i>, which specify data that are stored by objects of the class.  These parallel the <i>members</i> that we saw in structs previously.</li>\r\n  <li><i>Member functions</i> (also sometimes called <i>methods</i>), which specify operations that can be performed by objects of the class.  Like regular functions, member functions specify a sequence of parameters and a return type; unlike regular functions, though, they're called <i>on</i> a particular object (i.e., when we call them, we're asking some particular object to do a job for us).</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Public vs. private</p>\r\n\r\n<p>Some members are declared <i>public</i>, which means they are intended to be used by code outside of the class they're declared in.  Others will be declared <i>private</i>, meaning that they are only accessible to code within the class (e.g., private member variables in a class can only by accessed by the member functions in that class).  Note that the distinction between public and private members is a compile-time one; the compiler will disallow a program from compiling successfully and report an error if code outside of a class attempts to access one of that class' private members.</p>\r\n\r\n<p>In general, you should tend to want to make details of a class' implementation private whenever possible &mdash; or leave them out of the interface altogether, using local variables (or other constructs we've yet to see, such as the <i>unnamed namespace</i>) instead.  The fewer details you reveal to other parts of a program, the more of those details you can change without breaking the other parts; this is the essence of how you write very large programs.</p>\r\n\r\n<p class=\"subtitle\">Class declarations</p>\r\n\r\n<p>A <i>class declaration</i> is how we specify the existence of a class.  A class declaration is used to specify how objects of a class are used, and has two audiences:</p>\r\n\r\n<ul>\r\n  <li>A human reader, who will use the class declaration in order to understand how to write code that makes use of the class.</li>\r\n  <li>A compiler, which will use the class declaration in order to know how much memory to allocate to objects of the class, how its member variables are laid out, and what member functions can legally be called on objects of the class.</li>\r\n</ul>\r\n\r\n<p>So, in a class declaration, we specify all of the class' members: its member variables and member functions, both public and private.  The declaration of a member function is like the function declarations we've seen before; it specifies the existence of the member function without giving it a body.</p>\r\n\r\n<p class=\"subtitle\">Using header and source files</p>\r\n\r\n<p>As with the declarations of structs, we write the declarations of classes in header files whenever we intend those classes to be used in many source files.  However, as with the definitions of functions, we'll write definitions of member functions in a single source file.  (Later, we'll see that this distinction is more relaxed when writing classes than it is when you write functions &mdash; motivated largely by efficiency and optimization concerns &mdash; but we'll start by holding firm to that distinction.)</p>\r\n\r\n<p>Quite often, we'll arrange things so that every class is a matched pair of files: a header file specifying the class' declaration and a source file specifying the definitions of its member functions.  We'll use that arrangement in this example.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>Classes</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code Classes</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"Classes.tar.gz\">Classes.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 37.0}