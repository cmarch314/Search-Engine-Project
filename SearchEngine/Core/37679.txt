{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 1Number Type Support Olivier Devillers Susan Hert Lutz Kettner Sylvain Pion and Stefan Schirra CGAL kernel classes are parameterized by number types Depending on the problem and the input data that have to be handled one has to make a trade off between efficiency and accuracy in order to select an appropriate number type and kernel class In homogeneous representation two number types are involved although only one of them appears as a template parameter in the homogeneous kernel classes This type for the sake of simplicity and readability called ring type is used for the representation of homogeneous coordinates and all internal computations If it is assured that the second operand divides the first one these internal computations are basically division free The ring type is a placeholder for an integer type or an integral domain type rather than for elements of arbitrary rings The name should remind you that the division operation is not needed for this number type Of course also more general number types can be used as a ring type in a homogeneous kernel class In some computations e g accessing Cartesian coordinates divisions cannot be avoided In these computations a second number type the field type is used CGAL automatically generates this number type as a Quotient For the Cartesian kernels there is only one number type that is used for all calculations The kernel classes provide access to the number types involved in the representation although it is not expected that such access is needed at this level since low level geometric operations are wrapped in geometric primitives provided by CGAL This access can be useful if appropriate primitives are missing In a homogeneous kernel class K ring type and field type can be accessed as K RT and K FT respectively The number type used in Cartesian kernels is considered as ring type or as field type depending on the context If can be accessed as K RT and K FT according to the use of number types used in the homogeneous counterpart 1 1 Required Functionality of Number Types Number types must fulfill certain requirements such that they can be successfully used in CGAL code The syntacitical requirements of number types are described in the concepts RingNumberType and FieldNumberType included in the kernel reference manual Of course number types also have evident semantic constraints They should be meaningful in the sense that they approximate the integers or the rationals or some other subfield of the real numbers 1 2 Utility Routines The number type concepts mentioned in the previous section list all the required functionality For the user of a number type it is handy to have a larger set of operations available CGAL defines a number of such operations to compute for example the minimum or maximum of two numbers and the absolute value square sign or square root of a number These are available both as global functions and as functors See the reference manual for more details Those routines are implemented using the required operations from the number type concepts They are defined by means of templates so you do not have to supply all those operations when you write a new number type But if you have a better implementation for any of them you can provide a corresponding overloading function with the same name for your number types which will get preference over the template functions listed above For the number types int and double there is also a random numbers generator CGAL Random 1 3 Built in Number Types The built in number types float and double have the required arithmetic and comparison operators They lack some required routines though which are automatically included by CGAL All built in number types of C can represent a discrete bounded subset of the rational numbers only We assume that the floating point arithmetic of your machine follows IEEE floating point standard Since the floating point culture has much more infrastructural support hardware language definition and compiler than exact computation it is very efficient Like with all number types with finite precision representation which are used as approximations to the infinite ranges of integers or real numbers the built in number types are inherently potentially inexact Be aware of this if you decide to use the efficient built in number types you have to cope with numerical problems For example you can compute the intersection point of two lines and then check whether this point lies on the two lines With floating point arithmetic roundoff errors may cause the answer of the check to be false With the built in integer types overflow might occur 1 4 Number Types Provided by CGAL CGAL provides several number types that are that can be used for exact computation These include the Quotient class that can be used to create for example a number type that behaves like a rational number When used in conjunction with the number type MP Float that is able to represent multi precision floating point values you achieve an exact rational number representation The templated number type Lazy exact nt NT is able to represent any number that NT is able to represent but because it first tries to use an approximate value to perform computations it can be faster than the provided number type NT CGAL also provides a fixed precision number type Fixed precision nt that provides 24 bit numbers in fixed point representation This number type provides some specialized predicates that are exact and efficient for numbers known to be representable using 24 bits Two number types for doing interval arithmetic Interval nt and Interval nt advanced are also provided These number types help in doing filtering of predicates 1 5 Number Type Provided by CORE CGAL defines the functions needed to use the number type CORE Expr provided by CORE KLPY99 To use CORE with CGAL just install CGAL with CORE support and include the file CGAL CORE Expr h CORE version 1 5 or later is required CORE Exprs are a subset of real algebraic numbers Any integer is a CORE Expr and CORE Exprs are closed under the operations and sqrt CORE Exprs guarantee that all comparisons between expressions involving CORE Exprs produce the exact result This number type provides an equivalent functionality to leda real 1 6 Number Types Provided by GMP CGAL provides wrapper classes for number types defined in the GNU Multiple Precision arithmetic library Gra The file CGAL Gmpz h provides the class Gmpz a wrapper class for the integer type mpz t that is compliant with the CGAL number type requirements The file CGAL Gmpq h provides the class Gmpq a wrapper class for the rational type mpq t that is compliant with the CGAL number type requirements In addition it is possible to directly use the C number types provided by GMP mpz class mpq class note that support for mpf class is incomplete The file CGAL gmpxx h provides the necessary functions to make these classes compliant to the CGAL number type requirements To use this GMP must be installed 1 7 Number Types Provided by LEDA LEDA provides number types that can be used for exact computation with both Cartesian and homogeneous representations If you are using homogeneous representation with the built in integer types short int and long as ring type exactness of computations can be guaranteed only if your input data come from a sufficiently small integral range and the depth of the computations is sufficiently small LEDA provides the number type leda integer for integers of arbitrary length Of course the length is somehow bounded by the resources of your computer It can be used as ring type in homogeneous kernels and leads to exact computation as long as all intermediate results are rational For the same kind of problems Cartesian representation with number type leda rational leads to exact computation as well The number type leda bigfloat in LEDA is a variable precision floating point type Rounding mode and precision i e mantissa length of leda bigfloat can be set The most sophisticated number type in LEDA is the number type called leda real Like in Pascal where the name real is used for floating point numbers the name leda real does not describe the number type precisely but intentionally leda reals are a subset of real algebraic numbers Any integer is leda real and leda reals are closed under the operations and k th root computation leda reals guarantee that all comparisons between expressions involving leda reals produce the exact result 1 8 User supplied Number Types You can also use your own number type with the CGAL kernel classes e g the BIGNUM package SVH89 Depending on the arithmetic operations carried out by the algorithms that you are going to use the number types must fulfill the corresponding requirements from Section Next chapter Number Type Support Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/NumberTypeSupport/Chapter_main.html", "title": "number type support", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './NumberTypeSupport/main.tex' -->\n<html> <head>  \n<title>Number Type Support</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_1\"></a>\n  \n<h1>Chapter 1<BR>Number Type Support</h1>\n\n<A NAME=\"Numbertype\"></A>\n<EM>Olivier Devillers, Susan Hert, Lutz Kettner, Sylvain Pion, and Stefan Schirra</EM><BR>\n\n\n<P>\n\nC<SMALL>GAL</SMALL> kernel classes are parameterized by number types.  \nDepending on the problem and the input data that have to be handled,\none has to make a trade-off between efficiency and accuracy in \norder to select an appropriate number type and kernel class.\n<P>\n\nIn homogeneous representation, two number types are involved,\nalthough only one of them appears as a template parameter in\nthe homogeneous kernel classes.\nThis type, for the sake of simplicity and readability called ring type, is\nused for the representation of homogeneous coordinates and all \ninternal computations. \nIf it is assured that the second operand divides the first one, these \ninternal computations are basically division-free.\nThe ring type is a placeholder for an integer type (or an integral \ndomain type) rather than for elements of arbitrary rings. \nThe name should remind you that the division operation is not\nneeded for this number type.\nOf course, also more general number types can be used as a ring type \nin a homogeneous kernel class. In some computations, e.g. accessing \n<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> coordinates, divisions cannot be avoided. In these computations a \nsecond number type, the field type, is used. C<SMALL>GAL</SMALL> automatically generates \nthis number type as a <I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A></I>. For the <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> kernels \nthere is only one number type that is used for all calculations.\n<P>\n\nThe kernel classes provide access to the number types \ninvolved in the representation, although it is not expected that\nsuch access is needed at this level, since low-level geometric \noperations are wrapped in geometric primitives provided by C<SMALL>GAL</SMALL>.\nThis access can be useful if appropriate primitives are missing.\nIn a homogeneous kernel class <I>K</I>, ring type and field\ntype can be accessed as <I>K::RT</I> and <I>K::FT</I>, respectively.\nThe number type used in <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> kernels is considered as \nring type or as field type depending on the context.\nIf can be accessed as <I>K::RT</I> and <I>K::FT</I>, according\nto the use of number types used in the homogeneous counterpart.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>1.1&nbsp;&nbsp;&nbsp;Required Functionality of Number Types<A NAME=\"nt-requirements\"></A></h2>\n<P>\n\nNumber types must fulfill certain requirements, such that they can\nbe successfully used in C<SMALL>GAL</SMALL> code.  The syntacitical requirements of\nnumber types are described in\nthe concepts <A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A> and <A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A> included in the \nkernel reference manual.\nOf course, number types also\nhave evident semantic constraints. They should be meaningful in the\nsense that they approximate the integers or the rationals \nor some other subfield of the real numbers.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>1.2&nbsp;&nbsp;&nbsp;Utility Routines</h2>\n<P>\n\nThe number type concepts mentioned in the previous section list all \nthe required functionality.\nFor the user of a number type it is handy to have a larger set of\noperations available. C<SMALL>GAL</SMALL> defines a number of such operations,\nto compute, for example, the minimum or maximum of two numbers, and the\nabsolute value, <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A>, <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> or <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> root of a number.  These are\navailable both as global functions and as functors.  See the reference\nmanual for more details.\n<P>\n\nThose routines are implemented using the required operations from the\nnumber type concepts. They are defined by means of templates, so you do not\nhave to supply all those operations when you write  a new number type.\nBut if you have a better implementation for any of them, you can provide a \ncorresponding overloading function with the same name for your number types,\nwhich will get preference over the template functions listed above.\n<P>\n\nFor the number types <I>int</I>, and <I>double</I> there is\nalso a random numbers generator <I>CGAL::Random</I>.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>1.3&nbsp;&nbsp;&nbsp;Built-in Number Types</h2>\n<P>\n\nThe built-in number types <I>float</I> and <I>double</I> have the\nrequired arithmetic and comparison operators. They lack some required\nroutines though which are automatically included by C<SMALL>GAL</SMALL>.\n<P>\n\nAll built-in number types of C++ can represent a discrete (bounded)\nsubset of the rational numbers only.  We assume that the\nfloating-point arithmetic of your machine follows I<SMALL>EEE</SMALL>\nfloating-point standard.  Since the floating-point culture has much\nmore infrastructural support (hardware, language definition and\ncompiler) than exact computation, it is very efficient.\nLike with all number types with finite precision representation\nwhich are used as approximations to the infinite ranges of \nintegers or real numbers, the built-in number types are inherently\npotentially inexact.\nBe aware of this if you decide to use the efficient built-in \nnumber types: you have to cope with numerical problems.  \nFor example, you can compute the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> point of two lines and \nthen check whether this point lies on the two lines. \nWith floating point arithmetic,\nroundoff errors may cause the answer of the check to be <I>false</I>. \nWith the built-in integer types overflow might occur.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>1.4&nbsp;&nbsp;&nbsp;Number Types Provided by C<SMALL>GAL</SMALL></h2>\n<P>\n\nC<SMALL>GAL</SMALL> provides several number types that are that can be used for \nexact computation.  These include the <I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A></I> class that can\nbe used to create, for example, a number type that behaves like a rational\nnumber.  When used in conjunction with the number type <I><A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A></I> that\nis able to represent multi-precision floating point values, you achieve\nan exact rational number representation.  The templated number type\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Lazy_exact_nt.html#Cross_link_anchor_1386\">Lazy_exact_nt</A>&lt;NT&gt;</I> is able to represent any number that <I>NT</I> is able\nto represent, but because it first tries to use an approximate value to\nperform computations it can be faster than the provided number type <I>NT</I>.\nC<SMALL>GAL</SMALL> also provides a fixed-precision number type,\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Fixed_precision_nt.html#Cross_link_anchor_1354\">Fixed_precision_nt</A></I> that provides 24-bit numbers in fixed point\nrepresentation.  This number type provides some specialized predicates\nthat are exact and efficient for numbers known to be representable using\n24 bits.\nTwo number types for doing interval arithmetic, <I><A HREF=\"../NumberTypeSupport_ref/Class_Interval_nt.html#Cross_link_anchor_1366\">Interval_nt</A></I> and\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Interval_nt_advanced.html#Cross_link_anchor_1368\">Interval_nt_advanced</A></I>, are also provided.  These number types\nhelp in doing filtering of predicates.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>1.5&nbsp;&nbsp;&nbsp;Number Type Provided by C<SMALL>ORE</SMALL></h2>\n\n<A NAME=\"CORE\"></A>\n<P>\n\nC<SMALL>GAL</SMALL> defines the functions needed to use the number type <I><A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A></I>\nprovided by C<SMALL>ORE</SMALL>&nbsp;[<A HREF=\"../biblio.html#Biblio_klpy-clp-99\">KLPY99</A>].  To use C<SMALL>ORE</SMALL> with C<SMALL>GAL</SMALL>, just\ninstall C<SMALL>GAL</SMALL> with C<SMALL>ORE</SMALL> support, and include the file\n<I>CGAL/CORE_Expr.h</I>.  C<SMALL>ORE</SMALL> version 1.5 or later is required.\n<P>\n\n<I><A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A></I>s are a subset of real algebraic numbers.  Any integer is a\n<I><A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A></I> and <I><A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A></I>s are closed under the operations\n<MATH><I>+,-, &times; ,/</I></MATH> and <MATH><I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>()</I></MATH>.  <I><A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A></I>s guarantee that all\ncomparisons between expressions involving <I><A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A></I>s produce the exact\nresult.\n<P>\n\nThis number type provides an equivalent functionality to <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>.\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>1.6&nbsp;&nbsp;&nbsp;Number Types Provided by G<SMALL>MP</SMALL></h2>\n<P>\n\nC<SMALL>GAL</SMALL> provides wrapper classes for number types defined in the\nG<SMALL>NU</SMALL> Multiple Precision arithmetic library&nbsp;[<A HREF=\"../biblio.html#Biblio_g-ggmpa-\">Gra</A>].\nThe file <TT>CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h</TT> provides the class <I><A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A></I>,\na wrapper class for the integer type <I>mpz_t</I>, that is compliant with the\nC<SMALL>GAL</SMALL> number type requirements. The file <TT>CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1362\">Gmpq</A>.h</TT> provides the class <I><A HREF=\"../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1362\">Gmpq</A></I>,\na wrapper class for the rational type <I>mpq_t</I>, that is compliant\nwith the\nC<SMALL>GAL</SMALL> number type requirements.\n<P>\n\nIn addition, it is possible to directly use the C++ number types provided by\nG<SMALL>MP</SMALL>&nbsp;: <I><A HREF=\"../NumberTypeSupport_ref/Class_mpz_class.html#Cross_link_anchor_1360\">mpz_class</A></I>, <I><A HREF=\"../NumberTypeSupport_ref/Class_mpq_class.html#Cross_link_anchor_1359\">mpq_class</A></I> (note that support for\n<I>mpf_class</I> is incomplete).  The file <TT>CGAL/gmpxx.h</TT> provides the\nnecessary functions to make these classes compliant to the C<SMALL>GAL</SMALL> number type\nrequirements.\n<P>\n\nTo use this, G<SMALL>MP</SMALL> must be installed.\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>1.7&nbsp;&nbsp;&nbsp;Number Types Provided by L<SMALL>EDA</SMALL></h2>\n\n<A NAME=\"leda-nt\"></A>\n<P>\n\nL<SMALL>EDA</SMALL> provides number types that can be used for exact computation \nwith both <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> and homogeneous representations.  If you are using\nhomogeneous representation with the built-in integer types\n<I>short</I>, <I>int</I>, and <I>long</I> as ring type, exactness of\ncomputations can be guaranteed only if your input data come from a\nsufficiently small integral range and the depth of the computations is\nsufficiently small.  L<SMALL>EDA</SMALL> provides the number type <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A></I> for\nintegers of arbitrary length. (Of course the length is\nsomehow bounded by the resources of your computer.)  It can be used as\nring type in homogeneous kernels and leads to exact\ncomputation as long as all intermediate results are rational.  For the\nsame kind of problems, <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> representation with number type\n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_rational.html#Cross_link_anchor_1389\">leda_rational</A></I> leads to exact computation as well.\nThe number type <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_bigfloat.html#Cross_link_anchor_1387\">leda_bigfloat</A></I> in L<SMALL>EDA</SMALL> is a variable precision\nfloating-point type. Rounding mode and precision (i.e. mantissa length) of\n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_bigfloat.html#Cross_link_anchor_1387\">leda_bigfloat</A></I> can be set.\n<P>\n\nThe most sophisticated number type in L<SMALL>EDA</SMALL> is the number type called\n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>. Like in Pascal, where the name <I>real</I> is used for\nfloating-point numbers, the name <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I> does not describe the\nnumber type precisely, but intentionally.  \n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>s are a subset of real algebraic\nnumbers.  Any integer is <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I> and <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>s are closed under\nthe operations <MATH><I>+,-,*,/</I></MATH> and <MATH><I>k</I></MATH>-th root computation. \n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>s guarantee that\nall comparisons between expressions involving <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>s produce the\nexact result.\n<P>\n\n<a name=\"Section_8\"></a>\n        \n<h2>1.8&nbsp;&nbsp;&nbsp;User-supplied Number Types</h2>\n<P>\n\nYou can also use your own number type with the C<SMALL>GAL</SMALL> kernel\nclasses, e.g.  the B<SMALL>IG</SMALL>N<SMALL>UM</SMALL> package [<A HREF=\"../biblio.html#Biblio_svh-bpepa-89\">SVH89</A>].\nDepending on the arithmetic operations carried out by the algorithms\nthat you are going to use, the number types must fulfill the\ncorresponding requirements from Section <A HREF=\"Chapter_main.html#nt-requirements\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../NumberTypeSupport_ref/Chapter_intro.html\">Number Type Support</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_1!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 37679.0}