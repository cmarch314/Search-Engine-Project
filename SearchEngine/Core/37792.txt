{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 153D Nef Polyhedron Peter Hachenberger and Lutz Kettner 15 1 Introduction In solid modeling two major representation schemes are used constructive solid geometry CSG and boundary representations B rep Both have inherent strengths and weaknesses see Hof89c for a discussion In CSG a solid is represented as a set theoretic boolean combination of primitive solid objects such as blocks prisms cylinders or toruses The boolean operations are not evaluated instead objects are represented implicitly with a tree structure leaves represent primitive objects and interior nodes represent boolean operations or rigid motions e g translation and rotation Algorithms on such a CSG tree first evaluate properties on the primitive objects and propagate the results using the tree structure A B rep describes the incidence structure and the geometric properties of all lower dimensional features of the boundary of a solid Surfaces are oriented to decide between the interior and exterior of a solid The class of representable objects in a CSG is usually limited by the choice of the primitive solids A B rep is usually limited by the choice for the geometry of the supporting curves for edges and the supporting surfaces for surface patches and in addition the connectivity structure that is allowed In particular a B rep is not always closed under boolean set operations As an example the class of orientable 2 manifold objects is a popular and well understood class of surfaces commonly used for B reps They can be represented and manipulated efficiently the data structures are compact in storage size and many algorithms are simple On the other side this object class is not closed under boolean set operations as many examples can illustrate such as the Figure shown above that can be generated using boolean set operations on cubes The vertices bounding the tunnel or the edge connecting the roof with the cube are non manifold situations In our implementation of Nef polyhedra in 3D we offer a B rep data structure that is closed under boolean operations and with all their generality Starting from halfspaces and also directly from oriented 2 manifolds we can work with set union set intersection set difference set complement interior exterior boundary closure and regularization operations see Section for an explaination of regularized set operations In essence we can evaluate a CSG tree with halfspaces as primitives and convert it into a B rep representation In fact we work with two data structures one that represents the local neighborhoods of vertices which is in itself already a complete description and a data structure that connects these neighborhoods up to a global data structure with edges facets and volumes We offer a rich interface to investigate these data structures their different elements and their connectivity We provide affine rigid transformations and a point location query operation We have a custom file format for storing and reading Nef polyhedra from files We offer a simple OpenGL based visualizer for debugging and illustrations 15 2 Definition The theory of Nef polyhedra has been developed for arbitrary dimensions The class CGAL Nef polyhedron 3 implements a boundary representation for the 3 dimensional case Definition A Nef polyhedron in dimension d is a point set P d generated from a finite number of open halfspaces by set complement and set intersection operations Set union difference and symmetric difference can be reduced to intersection and complement Set complement changes between open and closed halfspaces thus the topological operations boundary interior exterior closure and regularization are also in the modeling space of Nef polyhedra A face of a Nef polyhedron is defined as an equivalence class of local pyramids that are a characterization of the local space around a point Definition A point set K d is called a cone with apex if K K i e p K p K and it is called a cone with apex x x d if K x K x A cone K is called a pyramid if K is a polyhedron Now let P d be a polyhedron and x d There is a neighborhood U x of x such that the pyramid Q x P U x x is the same for all neighborhoods U x U x Q is called the local pyramid of P in x and denoted PyrP x Definition Let P d be a polyhedron and x y d be two points We define an equivalence relation x y iff PyrP x PyrP y The equivalence classes of are the faces of P The dimension of a face s is the dimension of its affine hull dims dimaffs In other words a face s of P is a maximal non empty subset of d such that all of its points have the same local pyramid Q denoted PyrP s This definition of a face partitions d into faces of different dimension A face s is either a subset of P or disjoint from P We use this later in our data structure and store a selection mark in each face indicating its set membership Faces do not have to be connected There are only two full dimensional faces possible one whose local pyramid is the space d itself and the other with the empty set as a local pyramid All lower dimensional faces form the boundary of the polyhedron As usual we call zero dimensional faces vertices and one dimensional faces edges In the case of polyhedra in space we call two dimensional faces facets and the full dimensional faces volumes Faces are relative open sets e g an edge does not contain its end vertices We illustrate the definitions with an example in the plane Given the closed halfspaces h1 y h2 x y h3 x y 3 h4 x y 1 h5 x y 2 we define our polyhedron P h1 h2 h3 h4 h5 The left figure illustrates the polyhedron with its partially closed and partially open boundary i e vertex v4 v5 v6 and edges e4 and e5 are not part of P The local pyramids for the faces are PyrP f1 and PyrP f2 2 Examples for the local pyramids of edges are the closed halfspace h2 for the edge e1 PyrP e1 h2 and the open halfspace that is the complement of h4 for the edge e5 PyrP e5 x y x y 1 The edge e3 consists actually of two disconnected parts both with the same local pyramid PyrP e3 h1 In our data structure we will represent the two connected components of the edge e3 separately The figure on the right lists all local pyramids for this example The local pyramids of each vertex are represented by conceptually intersecting the local neighborhood with a small sphere This intersection forms a planar map on the sphere see next two figures which together with the set selection mark for each item i e vertices edges loops and faces forms a two dimensional Nef polyhedron embedded in the sphere We add the set selection mark for the vertex and call the resulting structure the sphere map of the vertex We use the prefix s to distinguish the elements of the sphere map from the three dimensional elements See Chapter for further details Having sphere maps for all vertices of our polyhedron is a sufficient but not easily accessible representation of the polyhedron We enrich the data structure with more explicit representations of all the faces and incidences between them We depart slightly from the definition of faces in a Nef polyhedron we represent the connected components of a face individually and do not implement additional bookkeeping to recover the original faces e g all edges on a common supporting line with the same local pyramid as this is not needed in our algorithms We discuss features in the increasing order of dimension edges We store two oppositely oriented edges for each edge and have a pointer from one oriented edge to its opposite edge Such an oriented edge can be identified with an svertex in a sphere map it remains to link one svertex with the corresponding opposite svertex in the other sphere map edge uses An edge can have many incident facets non manifold situation We introduce two oppositely oriented edge uses for each incident facet one for each orientation of the facet An edge use points to its corresponding oriented edge and to its oriented facet We can identify an edge use with an oriented sedge in the sphere map or in the special case also with an sloop Without mentioning it explicitly in the remainder all references to sedge can also refer to sloop facets We store oriented facets as boundary cycles of oriented edge uses We have a distinguished outer boundary cycle and several or maybe none inner boundary cycles representing holes in the facet Boundary cycles are linked in one direction We can access the other traversal direction when we switch to the oppositely oriented facet i e by using the opposite edge use shells The volume boundary decomposes into different connected components the shells A shell consists of a connected set of facets edges and vertices incident to this volume Facets around an edge form a radial order that is captured in the radial order of sedges around an svertex in the sphere map Using this information we can trace a shell from one entry element with a graph search We offer this graph traversal to the user in a visitor design pattern volumes A volume is defined by a set of shells one outer shell containing the volume and several or maybe none inner shells separating voids which are excluded from the volume For each face we store a label e g a set selection mark which indicates whether the face is part of the solid or if it is excluded We call the resulting data structure Selective Nef Complex SNC for short GHH 3 However in CGAL we identify the names and call the SNC data structure CGAL Nef polyhedron 3 15 3 Infimaximal Box We call a Nef polyhedron bounded if its boundary is bounded i e finite and unbounded otherwise Note that unbounded point sets can have a bounded boundary for example the complement of a cube has an unbounded outer volume but its boundary remains bounded Using a boundary representation it is convenient conceptually and in our implementation to consider bounded Nef polyhedra only Bounded Nef polyhedra are also closed under boolean set operations However one needs to start with bounded primitives the conceptually nice halfspaces cannot be used Instead we offer a construction from oriented 2 manifolds represented in a CGAL Polyhedron see Section below In order to handle unbounded Nef polyhedra conceptually in the same way as we handle bounded Nef polyhedra we intersect them with a bounding cubical volume of size R R 3 where R is a symbolical unspecified value which is finite but larger than all coordinate values that may occur in the bounded part of the polyhedron As a result each Nef polyhedron becomes bounded We call the boundary of the bounding volume the infimaximal box SM We clip lines and rays at the infimaximal box The intersection points with the infimaximal box are called non standard points which are points whose coordinates are R or R in at least one dimension and linear functions f R for the other dimensions Such extended points and developed from there also extended segments etc are provided in CGAL with extended kernels CGAL Extended cartesian and CGAL Extended homogeneous They are regular CGAL kernels with a polynomial type as coordinate number type As long as an extended kernel is used the full functionality provided by the CGAL Nef polyhedron 3 class is available If a kernel that does not use polynomials to represent coordinates is used it is not possible to create or load unbounded Nef polyhedra but all other operations work as expected We provided both possibilities since the restriction to bounded Nef polyhedra improves considerably space requirements plain number type instead of polynomial and runtime performance 15 4 Regularized Set Operations Since manifolds are not closed under boolean operations Requicha proposes to use regularized set operations KM76 Req8 A set is regular if it equals the closure of its interior A regularized set operation is defined as the standard set operation followed by a regularization of the result Regularized sets are closed under regularized set operations Regularized set operations are important since they simplify the class of solids to exclude lower dimensional features and the boundary belongs to the point set These properties are considered to reflect the nature of physical solids more closely Regularized polyhedral sets are a subclass of Nef polyhedra We provide the regularization operation as a shortcut for the consecutive execution of the interior and the closure operations 15 5 Example Programs The following example gives a first impression of how to instantiate and use Nef polyhedron 3 We use the CGAL Cartesian kernel All Cartesian and homogeneous kernels of CGAL are suitable if the number type parameter follows the usual requirements of being a model of the CGAL FieldNumberType concept for the Cartesian kernels or the CGAL RingNumberType concept for the homogeneous kernels respectively Note however that in the current state the Nef polyhedron works only with CGAL kernels The implementation makes use of CGAL specific functions in kernel objects and does not yet offer a designed interface to a clean kernel concept that could be offered by an external kernel as well The example creates two Nef polyhedra N is the empty set while N1 represents the full space i e the set of all points in the 3 dimensional space The assertion assures that the empty set is the complement of the full space file examples Nef 3 simple C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron 3 h typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron int main Nef polyhedron N Nef polyhedron EMPTY Nef polyhedron N1 Nef polyhedron COMPLETE CGAL assertion N N1 complement return 15 5 1 Construction and Comparison This example shows the various constructors We can create the empty set which is also the default constructor and the full space i e all points of 3 belong to the polyhedron We can create a halfspace defined by a plane bounding it It is only available if an extended kernel is used The halfspace constructor has a second parameter that specifies whether the defining plane belongs to the point set Nef polyhedron INCLUDED or not Nef polyhedron EXCLUDED The default value is Nef polyhedron INCLUDED Additionally we can create a Nef polyhedron 3 from a Polyhedron 3 see the Section below We can compute the point sets of two Nef polyhedra for equality and proper subset relationships We offer the usual comparison operators and Nef polyhedra have the important feature that a representation that is called the reduced W rzburg structure is unique i e two point sets of Nef polyhedra are equal if and only if the representations are equal The proof for the reduced W rzburg structure carries over to our representation and the comparison operators are therefore trivial to implement file examples Nef 3 construction C include CGAL Gmpz h include CGAL Extended homogeneous h include CGAL Nef polyhedron 3 h typedef CGAL Extended homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron typedef Nef polyhedron Plane 3 Plane 3 int main Nef polyhedron N Nef polyhedron N1 Nef polyhedron EMPTY Nef polyhedron N2 Nef polyhedron COMPLETE Nef polyhedron N3 Plane 3 1 2 5 1 Nef polyhedron N4 Plane 3 1 2 5 1 Nef polyhedron INCLUDED Nef polyhedron N5 Plane 3 1 2 5 1 Nef polyhedron EXCLUDED CGAL assertion N N1 CGAL assertion N3 N4 CGAL assertion N N2 CGAL assertion N3 N5 CGAL assertion N4 N5 CGAL assertion N5 N4 CGAL assertion N4 N5 CGAL assertion N5 N4 N5 N5 closure CGAL assertion N4 N5 CGAL assertion N4 N5 return 15 5 2 Point Set Operations As explained in the introduction Nef polyhedra are closed under all boolean set operations The class Nef polyhedron 3 provides functions and operators for the most common ones complement operator union operator difference operator intersection operator and symmetric difference operator Additionally the operators and are defined Nef polyhedron 3 also provides the topological operations interior closure and boundary With interior one deselects all boundary items with boundary one deselects all volumes and with closure one selects all boundary items file examples Nef 3 point set operations C include CGAL Gmpz h include CGAL Extended homogeneous h include CGAL Nef polyhedron 3 h typedef CGAL Extended homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron typedef Nef polyhedron Plane 3 Plane 3 int main Nef polyhedron N1 Plane 3 1 1 Nef polyhedron N2 Plane 3 1 1 Nef polyhedron N3 Plane 3 1 1 Nef polyhedron N4 Plane 3 1 1 Nef polyhedron N5 Plane 3 1 1 Nef polyhedron N6 Plane 3 1 1 Nef polyhedron I1 N1 N2 open slice in yz plane Nef polyhedron I2 N3 N4 closed slice in xz plane Nef polyhedron I3 N5 N6 open slice in yz plane Nef polyhedron Cube1 I2 I1 Cube1 I3 Nef polyhedron Cube2 N1 N2 N3 N4 N5 N6 CGAL assertion Cube1 Cube2 both are closed cube CGAL assertion Cube1 Cube1 closure CGAL assertion Cube1 Cube1 regularization CGAL assertion N1 N1 boundary N1 interior CGAL assertion I1 closure I1 complement interior complement CGAL assertion I1 regularization I1 interior closure return 15 5 3 Transformation Using the std transform function a Nef polyhedron can be translated rotated and scaled The usage is shown in the following example examples Nef 3 transformation C include CGAL Gmpz h include CGAL Extended homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h typedef CGAL Extended homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron typedef Nef polyhedron Plane 3 Plane 3 typedef Nef polyhedron Vector 3 Vector 3 typedef Nef polyhedron Aff transformation 3 Aff transformation 3 int main Nef polyhedron N Plane 3 1 Aff transformation 3 transl CGAL TRANSLATION Vector 3 5 7 9 Aff transformation 3 rotx9 1 1 1 1 Aff transformation 3 scale 3 3 3 2 N transform transl CGAL assertion N Nef polyhedron Plane 3 1 7 N transform rotx9 CGAL assertion N Nef polyhedron Plane 3 1 7 N transform scale CGAL assertion N Nef polyhedron Plane 3 2 21 return 15 5 4 The Interface between Polyhedron 3 and Nef polyhedron 3 Nef polyhedron 3 provides an interface for the conversion between polyhedral surfaces represented with the CGAL Polyhedron 3 class and Nef polyhedron 3 Polyhedron 3 represents orientable 2 manifold objects with boundaries However we exclude surfaces with boundaries from the conversion to Nef polyhedron 3 since they have no properly defined volume Both conversion directions can only be performed if the boundary of the point set is an oriented closed 2 manifold Nef polyhedron 3 provides the function is simple and Polyhedron 3 provides the function is closed to test for this property The usage is illustrated by the example program below The conversion gives us the possibility to use several file formats Polyhedron 3 can read the off file format and can write the off OpenInventor iv VRML 1 and 2 wrl and Wavefront Advanced Visualizer object format obj see Section file examples Nef 3 interface polyhedron C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Polyhedron 3 h include CGAL IO Polyhedron iostream h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h include iostream typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron typedef Nef polyhedron Vector 3 Vector 3 typedef Nef polyhedron Aff transformation 3 Aff transformation 3 int main Polyhedron P std cin P if P is closed Nef polyhedron N1 P Nef polyhedron N2 N1 Aff transformation 3 aff CGAL TRANSLATION Vector 3 2 2 1 N2 transform aff N1 N2 if N1 is simple N1 convert to Polyhedron P std cout P else std cerr N1 is not a 2 manifold std endl 15 5 5 Using an Extended Kernel The provided extended kernels are used the same way as any other CGAL kernel The essential difference is that coordinates are not represented by the number type that was used to parameterize the kernel type but by a Nef polynomial parametrized by that number type The example iterates all vertices of a given Nef polyhedron and decides whether it is an standard vertex or a vertex on the infimaximal box Furthermore it tests whether any of the vertices is at R R R Recall that R was the symbolical value large but finite for the size of the infimaximal box file examples Nef 3 extended kernel C include CGAL Gmpz h include CGAL Extended homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h typedef CGAL Gmpz NT typedef CGAL Extended homogeneous NT Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron typedef Nef polyhedron RT RT typedef Nef polyhedron Point 3 Point 3 typedef Nef polyhedron Plane 3 Plane 3 typedef Nef polyhedron Vertex const iterator Vertex const iterator int main Nef polyhedron N std cin N Vertex const iterator v for v N vertices begin v N vertices end v Point 3 p v point if p hx degree p hy degree p hz degree std cout extended vertex at p std endl else std cout standard vertex at p std endl if p Point 3 RT 1 RT 1 RT 1 std cout found vertex right back top of the infimaximal box std endl return 15 6 File I O Nef polyhedron 3 provides an input and an output operator for a proprietary file format It includes the complete incidence structure the geometric data and the marks of each item The output depends on the output operators of the geometric primitives provided by the traits class and on the output operators of the used number type Therefore it is necessary to use the same kernel and the same number type for input and output operations We recommend to use the CGAL kernels Homogeneous Simple homogeneous or Extended homogeneous We provide compatibility between the input and output of these kernels Especially it is possible to write a bounded Nef polyhedron using the Extended homogeneous kernel and to read it afterwards using one of the two others Using CGAL stream modifiers the following output formats can be chosen ASCII set ascii mode binary set binary mode or pretty set pretty mode The mandatory format is the ASCII format file examples Nef 3 nefIO C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Extended homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h include fstream typedef CGAL Gmpz NT typedef CGAL Homogeneous NT SK typedef CGAL Extended homogeneous NT EK typedef CGAL Nef polyhedron 3 SK Nef polyhedron S typedef CGAL Nef polyhedron 3 EK Nef polyhedron E int main Nef polyhedron E E Nef polyhedron S S std cin E if E is bounded std ofstream out temp nef3 out E std ifstream in temp nef3 in S 15 7 Further Example Programs 15 7 1 Exploring a Sphere Map A sphere map is explored by using the function get sphere map which returns the sphere map of the specified vertex as a Nef polyhedron S2 Nef polyhedron S2 provides the functionality necessary for the exploration Note that one has to use the type Nef polyhedron S2 as specified in Nef polyhedron 3 as is shown in the following example file examples Nef 3 exploration SM C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron 3 typedef Nef polyhedron 3 Vertex const iterator Vertex const iterator typedef Nef polyhedron 3 Nef polyhedron S2 Nef polyhedron S2 typedef Nef polyhedron S2 SVertex const handle SVertex const handle typedef Nef polyhedron S2 SHalfedge const handle SHalfedge const handle typedef Nef polyhedron S2 SHalfloop const handle SHalfloop const handle typedef Nef polyhedron S2 SFace const iterator SFace const iterator typedef Nef polyhedron S2 SFace cycle const iterator SFace cycle const iterator int main Nef polyhedron 3 N std cin N Vertex const iterator v N vertices begin Nef polyhedron S2 S N get sphere map v int i SFace const iterator sf for sf S sfaces begin sf S sfaces end sf SFace cycle const iterator it std cout the sface cycles of sface i start with an n for it sf sface cycles begin it sf sface cycles end it if it is svertex std cout svertex at position SVertex const handle it point std endl else if it is shalfedge std cout shalfedge from SHalfedge const handle it source point to SHalfedge const handle it target point std endl else if it is shalfloop std cout shalfloop lying in the plane SHalfloop const handle it circle std endl other cases can not occur return 15 7 2 Exploring Shells A shell of a Nef polyhedron is the connected part of the surface incident to a certain volume Each halffacet sface and shalfedge belongs to a single shell The figure below illustrates the notion of a shell It shows a Nef polyhedron with two volumes and three shells The first volume is the outer volume and the second volume is the interior of the cube The first shell is the whole surface of the left object The second shell is the outer surface of the right object and the third shell is the inner surface of the right object In detail the first shell consists of two halffacets eight halfedges and four vertices The second shell consists of the eight vertices of the cube plus the two endpoints of the antenna all halffacets oriented outwards and all halfedges The third shell consists of the same eight vertices of the cube plus the endpoint of the antenna that is in contact with the cube all halffacets oriented inwards and all halfedges the same as for the second shell We discuss how sfaces shalfedges and sloops belong to the shells with a closeup view of the situation at the antenna foot As you can see there are three items on the sphere map a shalfloop for each halffacet which intersects the sphere and an svertex where the antenna intersects the sphere The upper shalfloop lies on the halffacet which is oriented outwards and is therefore also oriented outwards This shalfloop and the svertex belong to the second shell The other shalfloop lies on the inwards oriented halffacet and is oriented inwards too This shalfloop belongs to the third shell Nef polyhedron 3 offers a visitor interface to explore a shell following the well known visitor pattern GHJV95 The interface is illustrated by the following example file examples Nef 3 shell exploration C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron typedef Nef polyhedron Vertex const handle Vertex const handle typedef Nef polyhedron Halfedge const handle Halfedge const handle typedef Nef polyhedron Halffacet const handle Halffacet const handle typedef Nef polyhedron SHalfedge const handle SHalfedge const handle typedef Nef polyhedron SHalfloop const handle SHalfloop const handle typedef Nef polyhedron SFace const handle SFace const handle typedef Nef polyhedron Volume const iterator Volume const iterator typedef Nef polyhedron Shell entry const iterator Shell entry const iterator typedef Kernel Point 3 Point 3 class Shell explorer bool first const Nef polyhedron N Vertex const handle v min public Shell explorer const Nef polyhedron N first true N N void visit Vertex const handle v if first CGAL lexicographically xyz smaller v point v min point v min v first false void visit Halfedge const handle e void visit Halffacet const handle f void visit SHalfedge const handle se void visit SHalfloop const handle sl void visit SFace const handle sf Vertex const handle minimal vertex return v min void reset minimal vertex first true int main Nef polyhedron N std cin N int ic Volume const iterator c Shell explorer SE N CGAL forall volumes c N std cout Volume ic std endl int is Shell entry const iterator it CGAL forall shells of it c SE reset minimal vertex N visit shell objects SFace const handle it SE Point 3 p SE minimal vertex point std cout minimal vertex of shell is is at p std endl The function visit shell objects SFace const handle sf Visitor V explores a shell starting at the sf The second argument expects any class providing the possibly empty functions visit Vertex const handle visit Halfedge const handle remember that Halfedge is the same type as SVertex visit Halffacet const handle visit SHalfedge const handle visit SHalfloop const handle and visit SFace const handle The visit shell objects function will call visit for each item belonging to the shell once There are no further requirements on that class In the example the class Shell explorer is passed as second argument to visit shell objects Its task is to find the lexicographically smallest vertex of a shell Its internal state consists of three variables The first one is a reference to the explored Nef polyhedron This reference is often necessary to retrieve information from the Nef polyhedron The second variable v min stores the smallest vertex found so far and the third variable first is initialized to false to signal that no vertex has been visited so far After the first vertex has been visited first is changed to true Shell explorer provides further member functions After the exploration of a shell the minimal vertex function retrieves the smallest vertex The reset minimal vertex function allows one to use the same instance of Shell explorer on multiple shells In this case the reset minimal vertex function has to be called between the exploration of two shells The example program uses the Shell explorer for each shell of the given Nef polyhedron once and reports the smallest vertex of each shell to the standard output 15 7 3 Point Location The locate Point 3 p function locates the point p in the Nef polyhedron and returns the item the point belongs to The locate function returns an instance of Object handle which is a polymorphic handle type representing any handle type no matter if it is mutable or const For further usage of the result the Object handle has to be casted to the concrete handle type The CGAL assign function performs such a cast It returns a boolean that reports the success or the failure of of the cast Looking at the possible return values of the locate function the Object handle can represent a Vertex const handle a Halfedge const handle a Halffacet handle or a Volume const handle One of the four casts will succeed file examples Nef 3 point location C include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron 3 typedef Nef polyhedron 3 Vertex const handle Vertex const handle typedef Nef polyhedron 3 Halfedge const handle Halfedge const handle typedef Nef polyhedron 3 Halffacet const handle Halffacet const handle typedef Nef polyhedron 3 Volume const handle Volume const handle typedef Nef polyhedron 3 Object handle Object handle typedef Kernel Point 3 Point 3 int main Nef polyhedron 3 N std cin N Vertex const handle v Halfedge const handle e Halffacet const handle f Volume const handle c Object handle o N locate Point 3 if CGAL assign v o std cout Locating vertex std endl else if CGAL assign e o std cout Locating edge std endl else if CGAL assign f o std cout Locating facet std endl else if CGAL assign c o std cout Locating volume std endl other cases can not occur return 15 8 Visualiation With the Qt widget OpenGL class an interface to OpenGL visualization via Qt is offered The class knows how to handle mouse movements and clicks and how to move and scale the 3D object displayed in the widget Qt widget OpenGL is a basis for writing Qt widgets displaying 3D objects A user can derive a new class from Qt widget OpenGL which implements the drawing method and configures the context menus 15 8 1 Visualizing a 3D Nef polyhedron Qt widget Nef 3 implements the drawing methods for displaying instances of Nef polyhedron 3 The following example shows how to set up an QApplication with a main widget of type Qt widget Nef 3 and how to start the viewer file examples Nef 3 visualization SNC C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h include CGAL IO Qt widget Nef 3 h include qapplication h typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron 3 int main int argc char argv Nef polyhedron 3 N std cin N QApplication a argc argv CGAL Qt widget Nef 3 Nef polyhedron 3 w new CGAL Qt widget Nef 3 Nef polyhedron 3 N a setMainWidget w w show return a exec endif 15 8 2 Visualizing a Sphere Map Qt widget Nef S2 is a widget implemented on the basis of Qt widget OpenGL It can be used to visualize the sphere map of a vertex in a Nef polyhedron 3 using the interface between Nef polyhedron S2 and Nef polyhedron 3 file examples Nef 3 visualization SM C ifndef CGAL USE QT include iostream int main int char std cout Sorry this demo needs QT std endl return else include CGAL Gmpz h include CGAL Homogeneous h include CGAL Nef polyhedron 3 h include CGAL IO Nef polyhedron iostream 3 h include CGAL IO Qt widget Nef S2 h include qapplication h typedef CGAL Homogeneous CGAL Gmpz Kernel typedef CGAL Nef polyhedron 3 Kernel Nef polyhedron 3 typedef Nef polyhedron 3 Vertex const iterator Vertex const iterator typedef Nef polyhedron 3 Nef polyhedron S2 Nef polyhedron S2 int main int argc char argv Nef polyhedron 3 N std cin N Vertex const iterator v N vertices begin Nef polyhedron S2 S N get sphere map v QApplication a argc argv CGAL Qt widget Nef S2 Nef polyhedron S2 w new CGAL Qt widget Nef S2 Nef polyhedron S2 S a setMainWidget w w show return a exec endif Next chapter 3D Nef Polyhedron Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Nef_3/Chapter_main.html", "title": "3d nef polyhedron", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Nef_3/main.tex' -->\n<html> <head>  \n<title>3D Nef Polyhedron</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_15\"></a>\n  \n<h1>Chapter 15<BR>3D Nef Polyhedron</h1>\n\n<A NAME=\"chapterNef_3\"></A>\n\n<EM>Peter Hachenberger  and Lutz Kettner</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>15.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\n<CENTER>\n        <img src=\"fig/nef_non_manifold3a.gif\">\n    </CENTER>\n<P>\n\nIn solid modeling, two major representation schemes are used:\n<I>constructive solid geometry</I> (CSG) and <I>boundary\n  representations</I> (B-rep). Both have inherent strengths and\nweaknesses, see [<A HREF=\"../biblio.html#Biblio_cgal:h-gsmi-89\">Hof89c</A>] for a discussion.\n<P>\n\nIn CSG a solid is represented as a set-theoretic boolean combination\nof primitive solid objects, such as blocks, prisms, cylinders, or\ntoruses.  The boolean operations are not evaluated, instead, objects\nare represented implicitly with a tree structure; leaves represent\nprimitive objects and interior nodes represent boolean operations or\nrigid motions, e.g., translation and rotation. Algorithms on such a\nCSG-tree first evaluate properties on the primitive objects and\npropagate the results using the tree structure.\n<P>\n\nA B-rep describes the incidence structure and the geometric properties\nof all lower-dimensional features of the boundary of a solid. Surfaces\nare oriented to decide between the interior and exterior of a solid.\n<P>\n\nThe class of representable objects in a CSG is usually limited by the\nchoice of the primitive solids. A B-rep is usually limited by the\nchoice for the geometry of the supporting curves for edges and the\nsupporting surfaces for surface patches, and, in addition, the\nconnectivity structure that is allowed. In particular, a B-rep is not\nalways closed under boolean set operations.  As an example, the class\nof orientable 2-manifold objects is a popular and well understood\nclass of surfaces commonly used for B-reps. They can be represented\nand manipulated efficiently, the data structures are compact in\nstorage size, and many algorithms are simple. On the other side, this\nobject class is not closed under boolean set operations, as many\nexamples can illustrate, such as the Figure shown above that can be\ngenerated using boolean set operations on cubes. The vertices bounding\nthe tunnel, or the edge connecting the ``roof'' with the cube are\nnon-manifold situations.\n<P>\n\nIn our implementation of Nef polyhedra in 3D, we offer a B-rep data\nstructure that is closed under boolean operations and with all their\ngenerality. Starting from halfspaces (and also directly from oriented\n2-manifolds), we can work with set union, set <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>, set\ndifference, set complement, interior, exterior, boundary, closure, and\nregularization operations (see Section&nbsp;<A HREF=\"Chapter_main.html#sectoinRegularized\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> \nfor an explaination of regularized\nset operations). In essence, we can evaluate a CSG-tree with\nhalfspaces as primitives and convert it into a B-rep representation.\n<P>\n\nIn fact, we work with two data structures; one that represents the\nlocal neighborhoods of vertices, which is in itself already a complete\ndescription, and a data structure that connects these neighborhoods up\nto a global data structure with edges, facets, and volumes. We offer a\nrich interface to investigate these data structures, their different\nelements and their connectivity. We provide affine (rigid)\ntransformations and a point location query operation. We have a custom\nfile format for storing and reading Nef polyhedra from files. We offer\na simple OpenGL-based visualizer for debugging and illustrations.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>15.2&nbsp;&nbsp;&nbsp;Definition</h2>\n<P>\n\nThe theory of Nef polyhedra has been developed for arbitrary\ndimensions. The class <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A></I> implements a\nboundary representation for the 3-dimensional case.\n<P>\n\n<B>Definition:</B>&nbsp;&nbsp;A <I>Nef-polyhedron</I> in dimension <MATH><I>d</I></MATH> is a point set <MATH><I>P  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_subseteq.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> generated from a finite number of open halfspaces by set\n    complement and set <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> operations.\n<P>\n\nSet union, difference and symmetric difference can be reduced to\n<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> and complement. Set complement changes between open\nand closed halfspaces, thus the topological operations <I>boundary</I>,\n<I>interior</I>, <I>exterior</I>, <I>closure</I> and <I>regularization</I> are also in the modeling space of Nef polyhedra.\n<P>\n\nA face of a Nef polyhedron is defined as an equivalence class of\n<I>local pyramids</I> that are a characterization of the local space\naround a point.\n<P>\n\n<B>Definition:</B>&nbsp;&nbsp;A point set <MATH><I>K  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_subseteq.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> is called a <I>cone with apex <MATH><I>0</I></MATH></I>,\n    if <MATH><I>K =  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>+</SUP> K</I></MATH> (i.e., <MATH><I> <IMG BORDER=0 WIDTH=9 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_forall.gif\"> p  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> K,  <IMG BORDER=0 WIDTH=9 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_forall.gif\"> <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\">&gt; 0: <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\">p\n     <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> K</I></MATH>) and it is called a <I>cone with apex <MATH><I>x</I></MATH></I>, <MATH><I>x  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH>,\n    if <MATH><I>K = x +  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>+</SUP> (K - x)</I></MATH>. A cone <MATH><I>K</I></MATH> is called a <I>pyramid</I>\n    if <MATH><I>K</I></MATH> is a polyhedron.\n<P>\n\nNow let <MATH><I>P  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> be a polyhedron and <MATH><I>x  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH>. There is a \n    neighborhood <MATH><I>U<SUB>0</SUB>(x)</I></MATH> of <MATH><I>x</I></MATH> such that the pyramid <MATH><I>Q := x +  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>+</SUP> \n    ((P  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cap.gif\"> U(x)) - x)</I></MATH> is the same for all neighborhoods <MATH><I>U(x)  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_subseteq.gif\"> U<SUB>0</SUB>(x)</I></MATH>. <MATH><I>Q</I></MATH> is called the <I>local pyramid</I> of <MATH><I>P</I></MATH> in <MATH><I>x</I></MATH> and\n    denoted <MATH><I>Pyr<SUB>P</SUB>(x)</I></MATH>.\n<P>\n\n<B>Definition:</B>&nbsp;&nbsp;Let <MATH><I>P  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> be a polyhedron and <MATH><I>x, y  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> be two points.\n    We define an equivalence relation <MATH><I>x  <IMG BORDER=0 WIDTH=11 HEIGHT=5 ALIGN=BOTTOM SRC=\"cc_sim.gif\"> y</I></MATH> iff\n    <MATH><I>Pyr<SUB>P</SUB>(x) = Pyr<SUB>P</SUB>(y)</I></MATH>. The equivalence classes of <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=5 ALIGN=BOTTOM SRC=\"cc_sim.gif\"> </I></MATH> \n    are the <I>faces</I> of <MATH><I>P</I></MATH>. The dimension of a face <MATH><I>s</I></MATH> is the  \n    dimension of its affine hull, <MATH><I></I></MATH>dim<MATH><I>s := </I></MATH>dim<MATH><I>affs</I></MATH>.\n<P>\n\nIn other words, a <I>face</I> <MATH><I>s</I></MATH> of <MATH><I>P</I></MATH> is a maximal non-empty subset\nof <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> such that all of its points have the same local pyramid <MATH><I>Q</I></MATH>\ndenoted <MATH><I>Pyr<SUB>P</SUB>(s)</I></MATH>.  This definition of a face partitions <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> into\nfaces of different dimension. A face <MATH><I>s</I></MATH> is either a subset of <MATH><I>P</I></MATH>, or\ndisjoint from <MATH><I>P</I></MATH>.  We use this later in our data structure and store\na selection mark in each face indicating its set membership.\n<P>\n\nFaces do not have to be connected. There are only two full-dimensional\nfaces possible, one whose local pyramid is the space <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> itself and\nthe other with the empty set as a local pyramid.\nAll lower-dimensional faces form the <I>boundary</I> of\nthe polyhedron. As usual, we call zero-dimensional faces <I>vertices</I> and one-dimensional faces <I>edges</I>. In the case of\npolyhedra in space we call two-dimensional faces <I>facets</I> and\nthe full-dimensional faces <I>volumes</I>. Faces are <I>relative\nopen</I> sets, e.g., an edge does not contain its end-vertices.\n<P>\n\nWe illustrate the definitions with an example in the plane.\n    Given the closed halfspaces\n    <P ALIGN=CENTER>\n<MATH><I>\n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nh<SUB>1</SUB>: y  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 0,      \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nh<SUB>2</SUB>: x - y  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 0,   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nh<SUB>3</SUB>: x + y  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 3,   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nh<SUB>4</SUB>: x - y  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1,   \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nh<SUB>5</SUB>: x + y  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 2, \n      \n</TD></TR></TABLE>\n\n    </I></MATH>\n<P>\n\nwe define our polyhedron <MATH><I>P := ( h<SUB>1</SUB>  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cap.gif\"> h<SUB>2</SUB>  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cap.gif\"> h<SUB>3</SUB>) - ( h<SUB>4</SUB>  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cap.gif\"> h<SUB>5</SUB>)</I></MATH>.\n<P>\n\n<CENTER>\n        <img src=\"fig/nef_example.gif\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\n<CENTER>\n        <img src=\"fig/nef_pyramids.gif\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\nThe left figure illustrates the polyhedron with\nits partially closed and partially open boundary, i.e., vertex \n<MATH><I>v<SUB>4</SUB>, v<SUB>5</SUB>, v<SUB>6</SUB></I></MATH>, and edges <MATH><I>e<SUB>4</SUB></I></MATH> and <MATH><I>e<SUB>5</SUB></I></MATH> are not part of <MATH><I>P</I></MATH>.\nThe local pyramids for the faces are <MATH><I>Pyr<SUB>P</SUB>(f<SUB>1</SUB>) =  <IMG BORDER=0 WIDTH=6 HEIGHT=28 ALIGN=MIDDLE SRC=\"cc_emptyset.gif\"> </I></MATH>\nand <MATH><I>Pyr<SUB>P</SUB>(f<SUB>2</SUB>) =  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>2</SUP></I></MATH>. Examples for the local pyramids of edges\nare the closed halfspace <MATH><I>h<SUB>2</SUB></I></MATH> for the edge <MATH><I>e<SUB>1</SUB></I></MATH>, <MATH><I>Pyr<SUB>P</SUB>(e<SUB>1</SUB>) = h<SUB>2</SUB></I></MATH>,\nand the open halfspace that is the complement of <MATH><I>h<SUB>4</SUB></I></MATH> for the \nedge <MATH><I>e<SUB>5</SUB></I></MATH>, <MATH><I>Pyr<SUB>P</SUB>(e<SUB>5</SUB>) =\n{(x,y) | x - y &lt; 1}</I></MATH>. The edge <MATH><I>e<SUB>3</SUB></I></MATH> consists actually of two\ndisconnected parts, both with the same local pyramid <MATH><I>Pyr<SUB>P</SUB>(e<SUB>3</SUB>) = h<SUB>1</SUB></I></MATH>.\nIn our data structure, we will represent the two connected\ncomponents of the edge <MATH><I>e<SUB>3</SUB></I></MATH> separately.\nThe figure on the right  \nlists all local pyramids for this example.\n<P>\n\nThe local pyramids of each vertex are represented by\nconceptually intersecting the local neighborhood with a small\n<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_varepsilon.gif\"></I></MATH>-sphere. This <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> forms a planar map on the\nsphere (see next two figures), which together with the set-selection\nmark for each item (i.e. vertices, edges, loops and faces)\nforms a two-dimensional Nef polyhedron embedded in\nthe sphere. We add the set-selection mark for the vertex and call the\nresulting structure the <I>sphere map</I> of the vertex.  \nWe use the prefix <MATH><I>s</I></MATH> to distinguish the elements of the sphere map\nfrom the three-dimensional elements. See Chapter <A HREF=\"../Nef_S2/Chapter_main.html#chapterNef_S2\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> \nfor further details.\n<P>\n\n<CENTER>\n        <img src=\"fig/sphere_map.png\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\nHaving sphere maps for all vertices of our polyhedron is a sufficient\nbut not easily accessible representation of the polyhedron. We enrich\nthe data structure with more explicit representations of all the faces\nand incidences between them.\n<P>\n\n<CENTER>\n        <img src=\"fig/snc.gif\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\nWe depart slightly from the\ndefinition of faces in a Nef polyhedron; we represent the connected\ncomponents of a face individually and do not implement additional\nbookkeeping to recover the original faces (e.g., all edges on a common\nsupporting line with the same local pyramid) as this is not needed in\nour algorithms.  We discuss features in the increasing order of \ndimension.\n<P>\n\n<DL>\n    <DT><B>edges:</B><DD> \n        We store two oppositely oriented edges for each edge\n        and have a pointer from one oriented edge to its <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> edge.\n        Such an oriented edge can be identified with an <I>svertex</I>\n        in a sphere map; it remains to link one <I>svertex</I> with\n        the corresponding <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> <I>svertex</I> in the other sphere map.\n    <DT><B>edge uses:</B><DD>\n        An edge can have many incident facets (non-manifold situation).\n        We introduce two oppositely oriented edge-uses for each incident\n        facet; one for each <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of the facet. An edge-use points \n        to its corresponding oriented edge and to its oriented facet.   \n        We can identify an edge-use with an oriented <I>sedge</I> in the \n        sphere map, or, in the special case also with an\n        <I>sloop</I>. Without mentioning it explicitly in the\n        remainder, all references to <I>sedge</I> can also refer to\n        <I>sloop</I>.\n    <DT><B>facets:</B><DD>\n        We store oriented facets as boundary cycles of oriented \n        edge-uses. We have a distinguished outer boundary cycle and \n        several (or maybe none) inner boundary cycles representing holes\n        in the facet. <A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">Boundary</A> cycles are linked in one direction. We can \n        access the other traversal direction when we switch to the oppositely\n        oriented facet, i.e., by using the <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> edge-use.\n    <DT><B>shells:</B><DD>\n        The <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> boundary decomposes into different connected\n        components, the <I>shells</I>. A shell consists of a connected set\n        of facets, edges, and vertices incident to this <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A>. Facets \n        around an edge form a radial order that is captured in the\n        radial order of <I>sedges</I> around an <I>svertex</I> in the\n        sphere map. Using this information, we can trace a shell from\n        one entry element with a graph search. We offer this graph\n        traversal (to the user) in a visitor design pattern.\n    <DT><B>volumes:</B><DD>\n        A <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> is defined by a set of shells, one outer shell containing\n        the <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> and several (or maybe none) inner shells separating voids\n        which are excluded from the <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A>.\n</DL>\n<P>\n\nFor each face we store a label, e.g., a set-selection mark, which\nindicates whether the face is part of the solid or if it is\nexcluded. We call the resulting data structure <I>Selective Nef\nComplex</I>, <I>SNC</I> for short&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ghhkm-bosnc-03\">GHH<MATH><I><SUP>+</SUP></I></MATH>03</A>]. However, in\nC<SMALL>GAL</SMALL> we identify the names and call the <I>SNC</I> data structure\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A></I>.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>15.3&nbsp;&nbsp;&nbsp;Infimaximal Box</h2>\n\n<A NAME=\"sectionNef_3InfiBox\"></A>\n<P>\n\nWe call a Nef polyhedron <I>bounded</I> if its boundary is bounded,\ni.e., finite, and <I>unbounded</I> otherwise. Note that unbounded\npoint sets can have a bounded boundary, for example, the complement of\na cube has an unbounded outer <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A>, but its boundary remains bounded.\n<P>\n\nUsing a boundary representation, it is convenient (conceptually and in\nour implementation) to consider bounded Nef polyhedra only.  Bounded\nNef polyhedra are also closed under boolean set operations. However, one\nneeds to start with bounded primitives; the conceptually nice\nhalfspaces cannot be used. Instead, we offer a construction from oriented\n2-manifolds represented in a  <I>CGAL::Polyhedron</I>, see\nSection&nbsp;<A HREF=\"Chapter_main.html#subsectionNef_3Polyhedron\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> below.\n<P>\n\nIn order to handle unbounded Nef polyhedra conceptually in the same\nway as we handle bounded Nef polyhedra, we intersect them with a\nbounding cubical <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> of size <MATH><I>[-R,R]<SUP>3</SUP></I></MATH>, where <MATH><I>R</I></MATH> is a symbolical\nunspecified value, which is finite but larger than all coordinate\nvalues that may occur in the bounded part of the polyhedron. As a\nresult, each Nef polyhedron becomes bounded.  We call the boundary of\nthe bounding <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> the <I>infimaximal\n  box</I>&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:sm-iftml-00\">SM00</A>].\n<P>\n\nWe clip lines and rays at the infimaximal box. The <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> points\nwith the infimaximal box are called <I>non-standard points</I>, which\nare points whose coordinates are <MATH><I>-R</I></MATH> or <MATH><I>R</I></MATH> in at least one\ndimension, and linear functions <MATH><I>f(R)</I></MATH> for the other dimensions. Such\nextended points (and developed from there also extended segments etc)\nare provided in C<SMALL>GAL</SMALL> with extended\nkernels - <I><A HREF=\"../Nef_2_ref/Class_Extended_cartesian.html#Cross_link_anchor_720\">CGAL::Extended_cartesian</A></I> and\n<I><A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_722\">CGAL::Extended_homogeneous</A></I>.  They are regular C<SMALL>GAL</SMALL> kernels\nwith a polynomial type as coordinate number type.\n<P>\n\nAs long as an extended kernel is used, the full functionality provided\nby the <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A></I> class is available. If a kernel that \ndoes not use polynomials to represent coordinates is used, it is not \npossible to create or load unbounded Nef\npolyhedra, but all other operations work as expected. We provided both\npossibilities, since the restriction to bounded Nef polyhedra improves\nconsiderably space requirements (plain number type instead of\npolynomial), and runtime performance.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>15.4&nbsp;&nbsp;&nbsp;Regularized Set Operations</h2>\n\n<A NAME=\"sectoinRegularized\"></A>\n<P>\n\nSince manifolds are not closed under boolean operations, Requicha\nproposes to use <I>regularized set operations</I>&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:km-st-76\">KM76</A>, <A HREF=\"../biblio.html#Biblio_cgal:r-rrstm-80\">Req80</A>].  A set is <I>regular</I>, if it equals the closure\nof its interior. A regularized set operation is defined as the \nstandard set operation followed by a regularization of the result.\nRegularized sets are closed under regularized set operations.\n<P>\n\nRegularized set operations are important since they simplify the class\nof solids to exclude lower dimensional features and the boundary\nbelongs to the point set. These properties are considered to reflect\nthe nature of physical solids more closely.\n<P>\n\nRegularized polyhedral sets are a subclass of Nef polyhedra. We provide the\n<I>regularization</I> operation as a shortcut for the consecutive execution\nof the <I>interior</I> and the <I>closure</I> operations.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>15.5&nbsp;&nbsp;&nbsp;Example Programs</h2>\n<P>\n\nThe following example gives a first impression of how to instantiate\nand use <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I>. We use the <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A></I>\nkernel.  All <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> and homogeneous kernels of C<SMALL>GAL</SMALL> are suitable\nif the number type parameter follows the usual requirements of being a\nmodel of the <I>CGAL::<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A></I> concept for the <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>\nkernels, or the <I>CGAL::<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A></I> concept for the homogeneous\nkernels, respectively. Note however, that in the current state, the\nNef polyhedron works only with C<SMALL>GAL</SMALL> kernels. The implementation\nmakes use of C<SMALL>GAL</SMALL> specific functions in kernel objects, and does not\nyet offer a designed interface to a clean kernel concept that could be\noffered by an external kernel as well.\n<P>\n\nThe example creates two Nef polyhedra - <I>N0</I> is the empty set,\nwhile <I>N1</I> represents the full space, i.e., the set of all points\nin the 3-dimensional space. The assertion assures that the empty set\nis the complement of the full space.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/simple.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Nef_polyhedron;\n\nint main() {\n  Nef_polyhedron N0(Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Content\">EMPTY</A>);\n  Nef_polyhedron N1(Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Content\">COMPLETE</A>);\n\n  CGAL_assertion (N0 == N1.complement());\n  return 0;\n}\n</pre>\n<P>\n\n<h3>15.5.1&nbsp;&nbsp;&nbsp;Construction and Comparison</h3>\n<P>\n\nThis example shows the various constructors. We can create the empty\nset, which is also the default constructor, and the full space, i.e.\nall points of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> belong to the polyhedron. We can create a\nhalfspace defined by a plane bounding it. It is only available if an\nextended kernel is used. The halfspace constructor has a second\nparameter that specifies whether the defining plane belongs to the\npoint set (<I>Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">INCLUDED</A></I>) or not\n(<I>Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">EXCLUDED</A></I>). The default value is\n<I>Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">INCLUDED</A></I>. Additionally, we can create a\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> from a <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I>, see the Section\n<A HREF=\"Chapter_main.html#subsectionNef_3Polyhedron\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> below.\n<P>\n\nWe can compute the point sets of two Nef polyhedra for equality and\nproper subset relationships. We offer the usual comparison operators\n<I>==</I>, <I>!=</I>, <I>&lt;=</I>, <I>&gt;=</I>, <I>&lt;</I> and <I>&gt;</I>.\n<P>\n\nNef polyhedra have the important feature that a representation that is\ncalled the <I>reduced W&uuml;rzburg structure</I> is unique, i.e., two\npoint sets of Nef polyhedra are equal if and only if the\nrepresentations are equal. The proof for the reduced W&uuml;rzburg\nstructure carries over to our representation and the comparison\noperators are therefore trivial to implement.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/construction.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n\ntypedef <A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_722\">CGAL::Extended_homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Nef_polyhedron;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>  <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\n\nint main() {\n  Nef_polyhedron N0;\n  Nef_polyhedron N1(Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Content\">EMPTY</A>);\n  Nef_polyhedron N2(Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Content\">COMPLETE</A>);\n  Nef_polyhedron N3(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 1, 2, 5,-1));\n  Nef_polyhedron N4(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 1, 2, 5,-1), Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">INCLUDED</A>);\n  Nef_polyhedron N5(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 1, 2, 5,-1), Nef_polyhedron::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">EXCLUDED</A>);\n\n  CGAL_assertion(N0 == N1);\n  CGAL_assertion(N3 == N4);\n  CGAL_assertion(N0 != N2);\n  CGAL_assertion(N3 != N5);\n  \n  CGAL_assertion(N4 &gt;= N5);\n  CGAL_assertion(N5 &lt;= N4);\n  CGAL_assertion(N4 &gt; N5);\n  CGAL_assertion(N5 &lt; N4);\n\n  N5 = N5.closure();\n  CGAL_assertion(N4 &gt;= N5);\n  CGAL_assertion(N4 &lt;= N5);\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>15.5.2&nbsp;&nbsp;&nbsp;Point Set Operations</h3>\n<P>\n\nAs explained in the introduction, Nef polyhedra are closed under all\nboolean set operations. The class <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> provides\nfunctions and operators for the most common ones: complement\n(<I>operator!</I>), union (<I>operator+</I>), difference\n(<I>operator-</I>), <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> (<I>operator*</I>) and symmetric\ndifference (<I>operator^</I>). Additionally, the operators <I>*=</I>,\n<I>-=</I>, <I>*=</I> and <I>^=</I> are defined.\n<P>\n\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> also provides the topological operations\n<I>interior()</I>, <I>closure()</I> and <I>boundary()</I>. With\n<I>interior()</I> one deselects all boundary items, with\n<I>boundary()</I> one deselects all volumes, and with <I>closure()</I>\none selects all boundary items.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/point_set_operations.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n\ntypedef <A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_722\">CGAL::Extended_homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Nef_polyhedron;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>  <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\n\nint main() {\n\n  Nef_polyhedron N1(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 1, 0, 0,-1));\n  Nef_polyhedron N2(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>(-1, 0, 0,-1));\n  Nef_polyhedron N3(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 0, 1, 0,-1));\n  Nef_polyhedron N4(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 0,-1, 0,-1));\n  Nef_polyhedron N5(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 0, 0, 1,-1));\n  Nef_polyhedron N6(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>( 0, 0,-1,-1));\n\n  Nef_polyhedron I1(!N1 + !N2);  // open slice in yz-plane\n  Nef_polyhedron I2(N3 - !N4);   // closed slice in xz-plane\n  Nef_polyhedron I3(N5 ^ N6);    // open slice in yz-plane\n  Nef_polyhedron Cube1(I2 * !I1);\n  Cube1 *= !I3;\n  Nef_polyhedron Cube2 = N1 * N2 * N3 * N4 * N5 * N6;\n\n  CGAL_assertion(Cube1 == Cube2);  // both are closed cube\n  CGAL_assertion(Cube1 == Cube1.closure());\n  CGAL_assertion(Cube1 == Cube1.regularization());\n  CGAL_assertion((N1 - N1.boundary()) == N1.interior()); \n  CGAL_assertion(I1.closure() == I1.complement().interior().complement());\n  CGAL_assertion(I1.regularization() == I1.interior().closure());\n  return 0;\n}\n</pre>\n<P>\n\n<h3>15.5.3&nbsp;&nbsp;&nbsp;Transformation</h3>\n<P>\n\nUsing the <I>std::transform</I> function, a Nef polyhedron can be translated, \nrotated and scaled. The usage is shown in the following example:\n<P>\n\n<pre class=\"ExampleCode\">// examples/Nef_3/transformation.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n\ntypedef <A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_722\">CGAL::Extended_homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Nef_polyhedron;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>  <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>  <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A>  <A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A>;\n\nint main() {\n\n  Nef_polyhedron N(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>(0,1,0,0));\n  <A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A> transl(CGAL::TRANSLATION, <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>(5, 7, 9));\n  <A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A> rotx90(1,0,0,\n\t\t\t      0,0,-1,\n\t\t\t      0,1,0,\n\t\t\t      1); \n  <A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A> scale(3,0,0,\n\t\t\t     0,3,0,\n\t\t\t     0,0,3,\n\t\t\t     2);\n\n  N.transform(transl);\n  CGAL_assertion(N == Nef_polyhedron(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>(0,1,0,-7)));\n  N.transform(rotx90);\n  CGAL_assertion(N == Nef_polyhedron(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>(0,0,1,-7)));\n  N.transform(scale);\n  CGAL_assertion(N == Nef_polyhedron(<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>(0,0,2,-21)));\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>15.5.4&nbsp;&nbsp;&nbsp;The Interface between <I>Polyhedron_3</I> and \n    <I>Nef_polyhedron_3</I></h3>\n\n<A NAME=\"subsectionNef_3Polyhedron\"></A>\n<P>\n\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> provides an interface for the conversion between\npolyhedral surfaces represented with the <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A></I> class\nand <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I>.  <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> represents orientable\n2-manifold objects with boundaries. However, we exclude surfaces with\nboundaries from the conversion to <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> since they\nhave no properly defined <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A>.\n<P>\n\nBoth conversion directions can only be performed if the boundary of\nthe point set is an oriented closed 2-manifold.\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> provides the function <I>is_simple()</I> and\n<I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> provides the function <I>is_closed()</I> to test for\nthis property. The usage is illustrated by the example program below.\n<P>\n\nThe conversion gives us the possibility to use several file formats.\n<I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> can read the (<TT>.off</TT>) file format and can write\nthe (<TT>.off</TT>), OpenInventor (<TT>.iv</TT>), VRML 1.0 and 2.0 (<TT>.wrl</TT>) and Wavefront Advanced Visualizer object format (<TT>.obj</TT>),\nsee Section&nbsp;<A HREF=\"../Polyhedron/Chapter_main.html#sectionPolyIO\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/interface_polyhedron.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Polyhedron_iostream.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Polyhedron;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Nef_polyhedron;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>  <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A>  <A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A>;\n\nint main() {\n  Polyhedron P;\n  std::cin &gt;&gt; P;\n  if(P.is_closed()) {\n    Nef_polyhedron N1(P);\n    Nef_polyhedron N2(N1);\n    <A HREF=\"../Kernel_23_ref/Class_Aff_transformation_3.html#Cross_link_anchor_64\">Aff_transformation_3</A> aff(CGAL::TRANSLATION, <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>(2,2,0,1));\n    N2.transform(aff);\n    N1 += N2;\n    \n    if(N1.is_simple()) {\n      N1.convert_to_Polyhedron(P);\n      std::cout &lt;&lt; P;\n    }\n    else\n      std::cerr &lt;&lt; &quot;N1 is not a 2-manifold.&quot; &lt;&lt; std::endl;\n  }\n}\n</pre>\n<P>\n\n<h3>15.5.5&nbsp;&nbsp;&nbsp;Using an Extended Kernel</h3>\n<P>\n\nThe provided extended kernels are used the same way as any other\nC<SMALL>GAL</SMALL> kernel.  The essential difference is, that coordinates are not\nrepresented by the number type that was used to parameterize the\nkernel type, but by a <I>Nef_polynomial</I> parametrized by that number\ntype.\n<P>\n\nThe example iterates all vertices of a given Nef polyhedron and decides whether\nit is an standard vertex or a vertex on the infimaximal box. Furthermore, it \ntests whether any of the vertices is at <MATH><I>(R,R,R)</I></MATH>. Recall that <MATH><I>R</I></MATH> was\nthe symbolical value, large but finite, for the size of the infimaximal box.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/extended_kernel.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>  NT;\ntypedef <A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_722\">CGAL::Extended_homogeneous</A>&lt;NT&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Nef_polyhedron;\ntypedef Nef_polyhedron::RT  RT;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>  <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef Nef_polyhedron::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>  <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\ntypedef Nef_polyhedron::Vertex_const_iterator  Vertex_const_iterator;\n\nint main() {\n\n  Nef_polyhedron N;\n  std::cin &gt;&gt; N;\n  \n  Vertex_const_iterator v;\n  for(v = N.vertices_begin(); v != N.vertices_end(); ++v) {\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p(v-&gt;point());\n    if(p.hx().degree() &gt; 0 || p.hy().degree() &gt; 0 || p.hz().degree() &gt; 0)\n      std::cout &lt;&lt; &quot;extended vertex at &quot; &lt;&lt; p &lt;&lt; std::endl;\n    else\n      std::cout &lt;&lt; &quot;standard vertex at &quot; &lt;&lt; p &lt;&lt; std::endl;\n\n    if(p == <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>(RT(0,1), RT(0,1), RT(0,1)))\n       std::cout &lt;&lt; &quot;  found vertex (right,back,top) of the infimaximal box&quot;\n                 &lt;&lt; std::endl;\n  }\n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>15.6&nbsp;&nbsp;&nbsp;File I/O</h2>\n\n<A NAME=\"sectionNef_3IO\"></A>\n<P>\n\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> provides an input and an output operator for a\nproprietary file format. It includes the complete incidence structure,\nthe geometric data, and the marks of each item.  The output depends on\nthe output operators of the geometric primitives provided by the\ntraits class, and on the output operators of the used number type.\nTherefore, it is necessary to use the same kernel and the same number\ntype for input and output operations.\n<P>\n\nWe recommend to use the C<SMALL>GAL</SMALL> kernels <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A></I>,\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A></I>, or <I><A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A></I>. We provide\ncompatibility between the input and output of these kernels.\nEspecially, it is possible to write a bounded Nef polyhedron using the\n<I><A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A></I> kernel and to read it afterwards using one\nof the two others.\n<P>\n\nUsing C<SMALL>GAL</SMALL> stream modifiers the following output formats can be chosen: \n<A HREF=\"../IOstream_ref/Enum_Mode#Enum_Mode\">ASCII</A>(<I><A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1744\">set_ascii_mode</A></I>), binary(<I><A HREF=\"../IOstream_ref/Function_set_binary_mode.html#Cross_link_anchor_1746\">set_binary_mode</A></I>) or \npretty(<I><A HREF=\"../IOstream_ref/Function_set_pretty_mode.html#Cross_link_anchor_1750\">set_pretty_mode</A></I>). The mandatory format is the <A HREF=\"../IOstream_ref/Enum_Mode#Enum_Mode\">ASCII</A> format.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/nefIO.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_723\">Extended_homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n#include &lt;fstream&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>  NT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;NT&gt;  SK;\ntypedef <A HREF=\"../Nef_2_ref/Class_Extended_homogeneous.html#Cross_link_anchor_722\">CGAL::Extended_homogeneous</A>&lt;NT&gt;  EK;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;SK&gt;  Nef_polyhedron_S;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;EK&gt;  Nef_polyhedron_E;\n\nint main() {\n  Nef_polyhedron_E E;\n  Nef_polyhedron_S S;\n\n  std::cin &gt;&gt; E;\n\n  if(E.is_bounded()) {\n    std::ofstream out(&quot;temp.nef3&quot;);\n    out &lt;&lt; E;\n    std::ifstream in(&quot;temp.nef3&quot;);\n    in &gt;&gt; S;\n  }\n}\n</pre>\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>15.7&nbsp;&nbsp;&nbsp;Further Example Programs</h2>\n<P>\n\n<h3>15.7.1&nbsp;&nbsp;&nbsp;Exploring a Sphere Map</h3>\n<P>\n\nA sphere map is explored by using the function <I>get_sphere_map</I>, which \nreturns the sphere map of the specified vertex as a <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I>.\n<I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> provides the functionality necessary for the\nexploration.\nNote, that one has to use\nthe type <I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> as specified in <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> as \nis shown in the following example.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/exploration_SM.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Vertex_const_iterator Vertex_const_iterator;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SVertex_const_handle SVertex_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SHalfedge_const_handle SHalfedge_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SHalfloop_const_handle SHalfloop_const_handle;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SFace_const_iterator SFace_const_iterator;\ntypedef <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>::SFace_cycle_const_iterator \n                           SFace_cycle_const_iterator;\n\nint main() {\n  <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A> N;\n  std::cin &gt;&gt; N;\n\n  Vertex_const_iterator v = N.vertices_begin();\n  <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> S(N.get_sphere_map(v));\n\n  int i=0;\n  SFace_const_iterator sf;\n  for(sf = S.sfaces_begin(); sf != S.sfaces_end(); sf++) {\n    SFace_cycle_const_iterator it;\n    std::cout &lt;&lt; &quot;the sface cycles of sface &quot; &lt;&lt; i++ &lt;&lt; &quot; start with an\\n&quot;;\n    for(it = sf-&gt;sface_cycles_begin(); it != sf-&gt;sface_cycles_end(); it++) {\n      if (it.is_svertex())\n        std::cout &lt;&lt; &quot;  svertex at position &quot; \n                  &lt;&lt; SVertex_const_handle(it)-&gt;point() &lt;&lt; std::endl;\n      else if (it.is_shalfedge()) \n        std::cout &lt;&lt; &quot;  shalfedge from &quot; \n                  &lt;&lt; SHalfedge_const_handle(it)-&gt;source()-&gt;point() &lt;&lt; &quot; to &quot; \n                  &lt;&lt; SHalfedge_const_handle(it)-&gt;target()-&gt;point() &lt;&lt; std::endl;\n      else if (it.is_shalfloop())\n        std::cout &lt;&lt; &quot;  shalfloop lying in the plane &quot; \n                  &lt;&lt; SHalfloop_const_handle(it)-&gt;circle() &lt;&lt; std::endl;\n      // other cases can not occur.\n    }\n  }\n  return 0;\n}\n</pre>\n<P>\n\n<h3>15.7.2&nbsp;&nbsp;&nbsp;Exploring Shells</h3>\n<P>\n\nA <I>shell</I> of a Nef polyhedron is the connected part of the\nsurface incident to a certain <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A>.  Each halffacet, sface and\nshalfedge belongs to a single shell. The figure below illustrates the\nnotion of a shell.  It shows a Nef polyhedron with two volumes and\nthree shells.\n<P>\n\n<CENTER>\n        <img src=\"fig/shells.gif\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\nThe first <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> is the outer <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> and the second <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> is the\ninterior of the cube. The first shell is the whole surface of the left\nobject. The second shell is the outer surface of the right object, and\nthe third shell is the inner surface of the right object.\n<P>\n\nIn detail, the first shell consists of two halffacets, eight halfedges\nand four vertices. The second shell consists of the eight vertices of\nthe cube plus the two endpoints of the antenna, all halffacets\noriented outwards, and all halfedges. The third shell consists of the\nsame eight vertices of the cube, plus the endpoint of the antenna\nthat is in contact with the cube, all halffacets\noriented inwards, and all halfedges (the same as for the second shell).\n<P>\n\n<CENTER>\n        <img src=\"fig/closeup.gif\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\nWe discuss how sfaces, shalfedges, and sloops belong to the shells\nwith a closeup view of the situation at the antenna foot. As you can\nsee, there are three items on the sphere map - a shalfloop for each\nhalffacet which intersects the sphere, and an svertex where the\nantenna intersects the sphere. The upper shalfloop lies on the \nhalffacet which is oriented outwards and is therefore also \noriented outwards. This shalfloop and the svertex belong to the\nsecond shell.\nThe other shalfloop lies on the inwards oriented halffacet and is \noriented inwards, too. This shalfloop belongs to the third shell.\n<P>\n\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> offers a visitor interface to explore a shell\nfollowing the well-known visitor pattern&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ghjv-dpero-95\">GHJV95</A>].\nThe interface is illustrated by the following example.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/shell_exploration.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; Nef_polyhedron;\ntypedef Nef_polyhedron::Vertex_const_handle Vertex_const_handle;\ntypedef Nef_polyhedron::Halfedge_const_handle Halfedge_const_handle;\ntypedef Nef_polyhedron::Halffacet_const_handle Halffacet_const_handle;\ntypedef Nef_polyhedron::SHalfedge_const_handle SHalfedge_const_handle;\ntypedef Nef_polyhedron::SHalfloop_const_handle SHalfloop_const_handle;\ntypedef Nef_polyhedron::SFace_const_handle SFace_const_handle;\ntypedef Nef_polyhedron::Volume_const_iterator Volume_const_iterator;\ntypedef Nef_polyhedron::Shell_entry_const_iterator Shell_entry_const_iterator;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A> <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\n\nclass Shell_explorer {\n  bool first;\n  const Nef_polyhedron&amp; N;\n  Vertex_const_handle v_min;\n\npublic:\n  Shell_explorer(const Nef_polyhedron&amp; N_) \n    : first(true), N(N_) {}\n  \n  void visit(Vertex_const_handle v) {\n    if(first || <A HREF=\"../Kernel_23_ref/Function_lexicographically_xyz_smaller.html#Cross_link_anchor_224\">CGAL::lexicographically_xyz_smaller</A>(v-&gt;point(),v_min-&gt;point())) {\n      v_min = v;\n      first=false;\n    } \n  }\n  \n  void visit(Halfedge_const_handle e) {}\n  void visit(Halffacet_const_handle f) {}\n  void visit(SHalfedge_const_handle se) {}\n  void visit(SHalfloop_const_handle sl) {}\n  void visit(SFace_const_handle sf) {}\n  \n  Vertex_const_handle&amp; minimal_vertex() { return v_min; }\n  void reset_minimal_vertex() { first = true; }\n};    \n\nint main() {\n  Nef_polyhedron N;\n  std::cin &gt;&gt; N;\n\n  int ic = 0;\n  Volume_const_iterator c;\n  Shell_explorer SE(N);\n  CGAL_forall_volumes(c,N) {\n    std::cout &lt;&lt; &quot;Volume &quot; &lt;&lt; ic++ &lt;&lt; std::endl;\n    int is = 0;\n    Shell_entry_const_iterator it;\n    CGAL_forall_shells_of(it,c) {\n      SE.reset_minimal_vertex();\n      N.visit_shell_objects(SFace_const_handle(it),SE);\n      <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p(SE.minimal_vertex()-&gt;point());\n      std::cout &lt;&lt; &quot;  minimal vertex of shell &quot; &lt;&lt; is++ \n                &lt;&lt; &quot; is at &quot; &lt;&lt; p &lt;&lt; std::endl;\n    }\n  } \n}\n</pre>\n<P>\n\nThe function <I>visit_shell_objects(SFace_const_handle sf, Visitor&amp;   V)</I> explores a shell starting at the <I>sf</I>. The second argument\nexpects any class providing the (possibly empty) functions\n<I>visit(Vertex_const_handle)</I>, <I>visit(Halfedge_const_handle)</I>\n(remember that Halfedge is the same type as SVertex),\n<I>visit(Halffacet_const_handle)</I>,\n<I>visit(SHalfedge_const_handle)</I>,\n<I>visit(SHalfloop_const_handle)</I> and\n<I>visit(SFace_const_handle)</I>.  The <I>visit_shell_objects</I>\nfunction will call <I>visit</I> for each item belonging to the shell\nonce. There are no further requirements on that class.\n<P>\n\nIn the example, the class <I>Shell_explorer</I> is passed as second argument\nto <I>visit_shell_objects</I>. Its task is to find the lexicographically\nsmallest vertex of a shell. Its internal state consists of three variables. \nThe first one is a reference to the explored Nef polyhedron. This reference\nis often necessary to retrieve information from the Nef polyhedron. The\nsecond variable <I>v_min</I> stores the smallest vertex found so far, and\nthe third variable <I>first</I> is initialized to <I>false</I> to signal that no\nvertex has been visited so far. After the first vertex has been visited \n<I>first</I> is changed to <I>true</I>.\n<P>\n\n<I>Shell_explorer</I> provides further member functions. After the\nexploration of a shell the <I>minimal_vertex</I> function retrieves the\nsmallest vertex. The <I>reset_minimal_vertex</I> function allows one to\nuse the same instance of <I>Shell_explorer</I> on multiple shells. In\nthis case, the <I>reset_minimal_vertex</I> function has to be called\nbetween the exploration of two shells.\n<P>\n\nThe example program uses the <I>Shell_explorer</I> for each shell of\nthe given Nef polyhedron once and reports the smallest vertex of each\nshell to the standard output.\n<P>\n\n<h3>15.7.3&nbsp;&nbsp;&nbsp;Point Location</h3>\n<P>\n\nThe <I>locate(<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p)</I> function locates the point <I>p</I> in the\nNef polyhedron and returns the item the point belongs to. The\n<I>locate</I> function returns an instance of <I>Object_handle</I>,\nwhich is a polymorphic handle type representing any handle type, no\nmatter if it is mutable or const.  For further usage of the result,\nthe <I>Object_handle</I> has to be casted to the concrete handle type.\nThe <I><A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A></I> function performs such a cast. It returns a\nboolean that reports the success or the failure of of the cast.\nLooking at the possible return values of the <I>locate</I> function,\nthe <I>Object_handle</I> can represent a <I>Vertex_const_handle</I>, a\n<I>Halfedge_const_handle</I>, a <I>Halffacet_handle</I>, or a\n<I>Volume_const_handle</I>. One of the four casts will succeed.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/point_location.C\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Vertex_const_handle Vertex_const_handle;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Halfedge_const_handle Halfedge_const_handle;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Halffacet_const_handle Halffacet_const_handle;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Volume_const_handle Volume_const_handle;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Object_handle Object_handle;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A> <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\n\nint main() {\n  <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A> N;\n  std::cin &gt;&gt; N;\n\n  Vertex_const_handle v;\n  Halfedge_const_handle e;\n  Halffacet_const_handle f;\n  Volume_const_handle c;\n  Object_handle o = N.locate(<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>(0,0,0));\n  if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(v,o))\n    std::cout &lt;&lt; &quot;Locating vertex&quot; &lt;&lt; std::endl;\n  else if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(e,o))\n    std::cout &lt;&lt; &quot;Locating edge&quot; &lt;&lt; std::endl;\n  else if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(f,o))\n    std::cout &lt;&lt; &quot;Locating facet&quot; &lt;&lt; std::endl;\n  else if(<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(c,o))\n    std::cout &lt;&lt; &quot;Locating <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A>&quot; &lt;&lt; std::endl;\n  //other cases can not occur\n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_8\"></a>\n        \n<h2>15.8&nbsp;&nbsp;&nbsp;Visualiation</h2>\n<P>\n\nWith the <I>Qt_widget_OpenGL</I> class an interface to OpenGL\nvisualization via Qt is offered. The class knows how to handle\nmouse movements and clicks and how to move and scale the \n3D object displayed in the widget. <I>Qt_widget_OpenGL</I> is\na basis for writing Qt widgets displaying 3D objects. \nA user can derive a new class from <I>Qt_widget_OpenGL</I> \nwhich implements the drawing method and configures the context menus.\n<P>\n\n<h3>15.8.1&nbsp;&nbsp;&nbsp;Visualizing a 3D Nef polyhedron</h3>\n<P>\n\n<I><A HREF=\"../Nef_3_ref/Class_Qt_widget_Nef_3.html#Cross_link_anchor_767\">Qt_widget_Nef_3</A></I> implements the drawing methods for displaying \ninstances of\n<I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I>. The following example shows how to set up \nan QApplication with a main widget of type <I><A HREF=\"../Nef_3_ref/Class_Qt_widget_Nef_3.html#Cross_link_anchor_767\">Qt_widget_Nef_3</A></I> and\nhow to start the viewer.\n<P>\n\n<CENTER>\n       <img src=\"./fig/visualization_SNC.png\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/visualization_SNC.C\n\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Nef_3_ref/Class_Qt_widget_Nef_3.html#Cross_link_anchor_767\">Qt_widget_Nef_3</A>.h&gt;\n#include &lt;qapplication.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>;\n\nint main(int argc, char* argv[]) {\n  <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A> N;\n  std::cin &gt;&gt; N;\n\n  QApplication a(argc, argv);\n  <A HREF=\"../Nef_3_ref/Class_Qt_widget_Nef_3.html#Cross_link_anchor_766\">CGAL::Qt_widget_Nef_3</A>&lt;<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>&gt;* w = \n    new <A HREF=\"../Nef_3_ref/Class_Qt_widget_Nef_3.html#Cross_link_anchor_766\">CGAL::Qt_widget_Nef_3</A>&lt;<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>&gt;(N);\n  a.setMainWidget(w);\n  w-&gt;show();\n  return a.exec();\n}\n#endif\n</pre>\n<P>\n\n<h3>15.8.2&nbsp;&nbsp;&nbsp;Visualizing a Sphere Map</h3>\n<P>\n\n<I><A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_745\">Qt_widget_Nef_S2</A></I> is a widget implemented on the basis of \n<I>Qt_widget_OpenGL</I>. It can be used to visualize the sphere map \nof a vertex in a <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I> using the interface between\n<I><A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A></I> and <I><A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A></I>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Nef_3/visualization_SM.C\n\n#ifndef CGAL_USE_QT\n#include &lt;iostream&gt;\nint main(int, char*){\n  std::cout &lt;&lt; &quot;Sorry, this demo needs QT...&quot; &lt;&lt; std::endl; return 0;}\n#else\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_745\">Qt_widget_Nef_S2</A>.h&gt;\n#include &lt;qapplication.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_746\">CGAL::Nef_polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt; <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::Vertex_const_iterator Vertex_const_iterator;\ntypedef <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A>::<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>;\n\nint main(int argc, char* argv[]) {\n  <A HREF=\"../Nef_3_ref/Class_Nef_polyhedron_3.html#Cross_link_anchor_747\">Nef_polyhedron_3</A> N;\n  std::cin &gt;&gt; N;\n  Vertex_const_iterator v = N.vertices_begin();\n  <A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A> S(N.get_sphere_map(v));\n\n  QApplication a(argc, argv);\n  <A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_744\">CGAL::Qt_widget_Nef_S2</A>&lt;<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>&gt;* w = \n    new <A HREF=\"../Nef_S2_ref/Class_Qt_widget_Nef_S2.html#Cross_link_anchor_744\">CGAL::Qt_widget_Nef_S2</A>&lt;<A HREF=\"../Nef_S2_ref/Class_Nef_polyhedron_S2.html#Cross_link_anchor_727\">Nef_polyhedron_S2</A>&gt;(S);\n  a.setMainWidget(w);\n  w-&gt;show();\n  return a.exec();\n}\n#endif\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Nef_3_ref/Chapter_intro.html\">3D Nef Polyhedron</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_15!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 37792.0}