{"text": "ICS 46 Spring 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 46 Spring 2 14 Project 1 Dark at the End of the Tunnel Due date and time Monday April 21 11 59pm Introduction As a very young kid I found myself fascinated by mazes Whenever I saw a maze printed on a piece of paper I was compelled to grab it and try to solve it I recall having soft covered books full of them and when those weren t satisfying enough I even tried drawing my own though with the undeveloped skills I had at the time both in terms of being able to design a challenging maze and also the more fundamental skill of being able to draw a straight line it proved to be a difficult proposition While time marched on and I became less enamored with mazes as I got older I became more interested in computer science which provided a fresh impetus to consider mazes again in particular I considered how software could generate a challenging maze and also figure out automatically how to solve one As I learned more about computer science the solutions became evident and I eventually found it an interesting problem for my students to solve It s funny how things come full circle sometimes This project asks you to implement one or more classes in C that are capable of generating two dimensional mazes of arbitrary size along with one or more classes in C that are capable of solving them The goal is to provide you with more practice and a fuller understanding of how to use recursion to solve real problems as at least one of your generators and at least one of your solvers is required to use a recursive depth first algorithm It will also provide you with an opportunity to make heavy use of pre existing classes for which you have no source code and for which only part of it will have value to you understanding how existing code works and determining what parts of it can be applied to solve your own problems are important real world programming skills that you ll need to employ as you move from sanitized coursework to real world work so I d like to help you to develop those skills here Getting started Before you begin work on this project there are a couple of chores you ll need to complete on your ICS 46 VM to get it set up to proceed Refreshing your ICS 46 VM environment Even if you previously downloaded your ICS 46 VM you may need to refresh its environment before proceeding with this project Log into your VM and issue the command ics46 version to see what version of the ICS 46 environment you currently have stored on your VM Note in particular the timestamp if you see a version with a timestamp older than the one listed below you ll want to refresh your environment by running the command ics46 refresh to download the latest one before you proceed with this project 2 14 4 5 16 53 58 Project 1 template added Creating your project directory on your ICS 45C VM A project template has been created specifically for this project containing a similar structure to the basic template you saw in Project but including a fair amount of code both source code and compiled libraries that is being provided as a starting point So you ll absolutely need to use the project1 template for this project as opposed to the basic one Decide on a name for your project directory then issue the command ics46 start project YOUR CHOSEN PROJECT NAME project1 to create your new project directory using the project1 template For example if you wanted to call your project directory proj1 you would issue the command ics46 start project proj1 project1 to create it Now you re ready to proceed The project directory Change into your project directory and take a look around to be sure you re aware of what s already available What you ll find will look a lot like the basic project template you ve seen previously and the ultimate result of building your project will be three separate programs you can run with a script called run run app runs the application a GUI that displays mazes and their solutions run exp runs any experiments you want to write as you work These are not required but they may help you to isolate issues and experiment with their solutions outside of the context of the GUI run gtest runs any Google Test unitt ests that you want to write as you work As with the experiments they are not required but this is another good tool for isolating issues figuring out how to fix them and then verifying that they re fixed More specifically here s what you ll find in your project directory A directory called lib in which there are two precompiled libraries that make up the part of the project that you won t be implementing yourself libdarkmaze so contains implementations of maze related concepts like mazes maze solutions verifiers and so on libdarkui so contains the implementation of the application s graphical user interface You will not have to implement the GUI yourself it is being provided in this library Note that these libraries are being provided in a compiled form without source code though you ll find declarations of some of their classes elsewhere see below A directory called include in which you ll find three directories darkmaze which contains declarations of classes exported by libdarkmaze so You will need to include some of these files in your own header and source files though you will not need all of them it s up to you to decide which of these is relevant to your work darkui which contains declarations of classes exported by libdarkui so This is not something you re likely to need as the only place this is likely to be useful is in the application s main function which has already been written ics46 which contains a broad based ICS 46 Library which will grow as we continue our work this quarter providing tools that will assist you and also me in implementing your projects A directory called app in which the application s main function resides This has already been completed you shouldn t have to modify it A directory called core in which you ll write your maze generators maze solvers and any additional code for this project A directory called exp in which you ll write any experiments that you d like to write outside of the context of the GUI The file expmain cpp is the entry point for the experiments which you run with the command run exp A directory called gtest in which you ll write any unit tests that you d like to write The file gtestmain cpp is the entry point and has already been written all you need to do is create new source files and place them in the gtest directory then rebuild and they will be executed automatically when you issue the command run gtest The application Your work on this project begins with an already existing already working application with a graphical user interface GUI that can display a maze and its solution and can also animate the process of generating and solving a maze The GUI window looks like this The large area with a white background is where a maze and its solution are drawn Initially this will be an empty area with a white background when you generate or a solve a maze the result will appear within that area In the example above both a maze and its solution are displayed Along the right hand side of the window are a set of controls allowing you to Choose the width and height of the maze you d like to generate The range not shown numerically is from 1 5 cells wide and 1 5 cells tall Choose what algorithm you d like to use to generate a maze There are two algorithms provided and you ll write one or more additional algorithms Depth First Provided which is a recursive depth first maze generator like one that you ll be building Kruskal s Algorithm Provided which uses a well known algorithm called Kruskal s algorithm to randomly remove walls so long as they do not cause the maze to become imperfect i e introduce two separate paths connecting any two cells Generate a new maze which will clear out any existing maze and its solution Choose what algorithm you d like to use to solve a maze There are two algorithms provided and you ll write one or more additional algorithms Breadth First Provided which uses a breadth first approach to solving a maze Depth First Provided which uses a recursive depth first algorithm for solving a maze like one that you ll be building Control whether or not the process of generating and solving mazes will be animated i e each step will be shown individually as opposed to only seeing the final result and if so at what speed the animation will progress Just below the display of the maze and its solution is a line of text that displays various messages When you first start the program it says Welcome When a maze generator or maze solver finishes this message will tell you about the result in particular whether a generated maze is perfect and whether a solution is complete and correct which is a good way to verify that your algorithms are doing what you expect them to do A brief word of warning When you start the application on your ICS 46 VM you may notice an error message like this one in your Terminal window OpenGL Warning Failed to connect to host Make sure 3D acceleration is enabled for this VM libGL error failed to load drive vboxvideo libGL error Try again with LIBGL DEBUG verbose for more details This is something you can safely ignore While the GUI was built with a library called Qt that integrates with OpenGL and provides support for 3D graphics and video playback that functionality is not being used by our application I tried turning 3D acceleration on in my VM s settings in VirtualBox but that caused many additional error messages to pop up instead so I gave up trying to solve this problem since it has no effect on our work anyway The requirements This project requires you to complete two tasks Write a maze generator that uses a recursive depth first algorithm to randomly generate a maze of arbitrary size with the result required to be a perfect maze You can also optionally write as many additional maze generators as you d like with no limitations on what algorithms or techniques you use and with no limitation that the result be a perfect maze Feel free to do anything you d like and let your creativity run wild Write a maze solver that uses a recursive depth first algorithm to traverse and solve a maze of arbitrary size with the solution extending from the maze s starting cell to its ending cell without crossing any walls You can also optionally write as many additional maze solvers as you d like with no limitations on what algorithms or techniques you use and with no limitation that the result be a correct complete maze solution Feel free to do anything you d like and let your creativity run wild A quick note about extra credit While we encourage you to explore as many maze generators and maze solvers as you d like be aware that we are not offering extra credit for generators or solvers beyond the one of each that you are required to implement You can receive a perfect score on this project while implementing only a single maze generator and a single maze solver Generating a maze Each maze generator needs to be written in its own class So to write a maze generator create a new class in the core directory of your project directory declaring the class in a header file and defining its member functions and other source code in a corresponding source file The GUI automatically displays all of the maze generators that are compiled into the program but only if you follow a couple of rules to help the GUI find and create them You must derive your class from the abstract base class MazeGenerator which is declared in a file MazeGenerator hpp in include darkmaze You can include this file by simply saying include MazeGenerator hpp since the compiler has already been configured to look in the include darkmaze directory for header files Deriving from this class obligates you to provide an implementation for this member function in your class virtual void generateMaze Maze maze where Maze is declared in the file Maze hpp also in the include darkmaze directory You must be sure that your class has a default constructor i e a constructor that takes no parameters Most likely you won t implement a constructor in your class at all if you do be sure you implement at least one that takes no parameters In the source file not in the header file as it s important that this only be done once you ll need to do two things Write this include directive near the top include ics46 factory DynamicFactory hpp Write this line of code somewhere after that include directive ICS46 DYNAMIC FACTORY REGISTER MazeGenerator name of your class display name substituting the name of your class where name of your class appears and the name you d like to see in the GUI for your maze generator where display name appears For example my KruskalMazeGenerator cpp file which has not been provided but is compiled into the libdarkmaze so library has this line near the top ICS46 DYNAMIC FACTORY REGISTER MazeGenerator KruskalMazeGenerator Kruskal s Algorithm Provided The required algorithm The required algorithm must generate a perfect maze Viewing a mze as a two dimensional matrix of square cells a perfect maze is one in which any two cells are connected by a single unique path An important consequence of a maze being perfect is that all cells in a perfect maze are reachable from the starting point by some unique path meaning that perfect mazes are guaranteed to have a solution They re also guaranteed to have a unique solution which makes them more interesting to solve To generate a perfect maze you ll use a recursive algorithm to dig tunnels of various lengths It starts with a maze in which all of the possible walls exist i e a wall exists on every side of every cell then continues removing walls until a perfect maze has been constructed Naturally it requires some care not to remove walls that would cause the maze to be imperfect in our tunnel digging algorithm we have to be sure we stop digging before we knock out walls that would lead to places we ve already been The algorithm works then by starting at a particular cell and it doesn t matter ultimately which cell you start from and does the following Mark the current cell as visited While the current cell has any adjacent cells that have not yet been visited Choose one of the unvisited adjacent cells at random Randomness is important here or your algorithm will always generate the same maze Remove the wall between the current cell and the cell you just chose Recursively call this algorithm with the chosen cell becoming the current cell As you generate your maze you ll need to call member functions on the Maze object that was provided as a parameter Don t assume anything in particular about that Maze object other than it has the correct width and height make any changes you need to make in order to achieve the correct result The animation in the GUI is automatic if animation is selected in the GUI any change you make to your maze will result in the GUI window being redrawn so you won t need to do anything special to accommodate that feature You can write as many other maze generators as you d like by following the same steps i e creating a separate class that derives from MazeGenerator registering it with the DynamicFactory giving it a display name etc All of the maze generators you write should show up in the GUI if you set them up right Naming your required maze generator so we can find it Each of your maze generators has a display name given as a string literal as the third parameter in the call to the ICS46 DYNAMIC FACTORY REGISTER macro So we know which one of your maze generators is the required one you must choose a display name for your required maze generator that has the parenthesized word Required on the end of it similar to how the provided generators have the parenthesized word Provided on the end of their names Otherwise you can name your required generator anything you d like and you can name any other generators in any way you d like except they should not have the word Required on the end of them Solving a maze Each maze solving needs to be written in its own class So to write a maze solver create a new class in the core directory of your project directory declaring the class in a header file and defining its member functions and other source code in a corresponding source file The GUI automatically displays all of the maze solvers that are compiled into the program but only if you follow similar rules to those you followed for your generators You must derive your class from the abstract base class MazeSolver which is declared in a file MazeSolver hpp in include darkmaze You can include this file by simply saying include MazeSolver hpp since the compiler has already been configured to look in the include darkmaze directory for header files Deriving from this class obligates you to provide an implementation for this member function in your class virtual void solveMaze const Maze maze MazeSolution mazeSolution where Maze is declared in the file Maze hpp and MazeSolution is declared in the file MazeSolution hpp also in the include darkmaze directory You must be sure that your class has a default constructor i e a constructor that takes no parameters Most likely you won t implement a constructor in your class at all if you do be sure you implement at least one that takes no parameters Register your class with the ICS 46 DynamicFactory just as you did with your maze solver ICS46 DYNAMIC FACTORY REGISTER MazeSolver name of your class display name substituting the name of your class where name of your class appears and the name you d like to see in the GUI for your maze solver where display name appears The required algorithm The required algorithm must solve the maze using a recursive algorithm with backtracking A backtracking algorithm is one that recursively investigates all of the possibilities by moving down a path that hopefully leads to a solution and then if that path fails backing up to the nearest place where some untried alternative is available and trying another path While you could potentially implement an algorithm like this iteratively it turns out to be a lot less work to do so recursively as the process of recursion will naturally and automatically manage details that you would otherwise have to manage yourself I ll leave the details of this algorithm as an exercise for you to figure out If you understand the maze generating algorithm above it should not be a big step to design the maze solving algorithm As you generate your maze you ll need to call member functions on the Maze and MazeSolution objects that were provided as parameters though note that the Maze has been passed as a constant because you shouldn t have to change a maze in order to solve it The animation in the GUI is automatic if animation is selected in the GUI any change you make to your maze solution will result in the GUI window being redrawn so you won t need to do anything special to accommodate that feature You can write as many other maze solvers as you d like by following the same steps i e creating a separate class that derives from MazeSolver registering it with the DynamicFactory giving it a display name etc All of the maze solvers you write should show up in the GUI if you set them up right Naming your required maze solver so we can find it Each of your maze generators has a display name given as a string literal as the third parameter in the call to the ICS46 DYNAMIC FACTORY REGISTER macro So we know which one of your maze solvers is the required one you must choose a display name for your required maze solver that has the parenthesized word Required on the end of it similar to how the provided solvers have the parenthesized word Provided on the end of their names Otherwise you can name your required solver anything you d like and you can name any other solvers in any way you d like except they should not have the word Required on the end of them Deliverables After using the gather script in your project directory to gather up your C source and header files into a single project1 tar gz file as you did in Project submit that file and only that file to Checkmate Refer back to Project if you need instructions on how to do that Follow this link for a discussion of how to submit your project via Checkmate Be aware that I ll be holding you to all of the rules specified in that document including the one that says that you re reponsible for submitting the version of the project that you want graded We won t regrade a project simply because you submitted the wrong version accidentally It s not a bad idea to look at the contents of your tarball before submitting it see Project for instructions on how to do that Can I submit after the deadline Yes it is possible subject to the late work policy for this course which is described in the section titled Late work at this link Originally written by Alex Thornton Spring 2 14 with heavy influence from a similarly named project from ICS 23 ", "_id": "http://www.ics.uci.edu/~thornton/ics46/ProjectGuide/Project1/", "title": "ics 46 spring 2014, project #1: dark at the end of the tunnel", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2014, Project #1: Dark at the End of the Tunnel</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2014<br />\r\n   Project #1: <i>Dark at the End of the Tunnel</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Monday, April 21, 11:59pm</i></b></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>As a very young kid, I found myself fascinated by mazes.  Whenever I saw a maze printed on a piece of paper, I was compelled to grab it and try to solve it.  I recall having soft-covered books full of them and, when those weren't satisfying enough, I even tried drawing my own, though with the undeveloped skills I had at the time &mdash; both in terms of being able to design a challenging maze, and also the more fundamental skill of being able to draw a straight line &mdash; it proved to be a difficult proposition.</p>\r\n\r\n<p>While time marched on and I became less enamored with mazes as I got older, I became more interested in computer science, which provided a fresh impetus to consider mazes again; in particular, I considered how software could generate a challenging maze and also figure out automatically how to solve one.  As I learned more about computer science, the solutions became evident, and I eventually found it an interesting problem for my students to solve.  It's funny how things come full-circle sometimes.</p>\r\n\r\n<p>This project asks you to implement one or more classes in C++ that are capable of generating two-dimensional mazes of arbitrary size, along with one or more classes in C++ that are capable of solving them.  The goal is to provide you with more practice and a fuller understanding of how to use recursion to solve real problems, as at least one of your generators and at least one of your solvers is required to use a recursive <i>depth-first</i> algorithm.  It will also provide you with an opportunity to make heavy use of pre-existing classes for which you have no source code, and for which only part of it will have value to you; understanding how existing code works and determining what parts of it can be applied to solve your own problems are important real-world programming skills that you'll need to employ as you move from \"sanitized\" coursework to real-world work, so I'd like to help you to develop those skills here.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Getting started</p>\r\n\r\n<p>Before you begin work on this project, there are a couple of chores you'll need to complete on your ICS 46 VM to get it set up to proceed.</p>\r\n\r\n<p class=\"subtitle\">Refreshing your ICS 46 VM environment</p>\r\n\r\n<p>Even if you previously downloaded your ICS 46 VM, you may need to refresh its environment before proceeding with this project.  Log into your VM and issue the command <b>ics46 version</b> to see what version of the ICS 46 environment you currently have stored on your VM.  Note, in particular, the timestamp; if you see a version with a timestamp older than the one listed below, you'll want to refresh your environment by running the command <b>ics46 refresh</b> to download the latest one before you proceed with this project.</p>\r\n\r\n<blockquote><pre>\r\n2014-04-05 16:53:58\r\nProject #1 template added\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Creating your project directory on your ICS 45C VM</p>\r\n\r\n<p>A project template has been created specifically for this project, containing a similar structure to the <b>basic</b> template you saw in <a href=\"../Project0\">Project #0</a>, but including a fair amount of code (both source code and compiled libraries) that is being provided as a starting point.  So you'll absolutely need to use the <b>project1</b> template for this project, as opposed to the <b>basic</b> one.</p>\r\n\r\n<p>Decide on a name for your project directory, then issue the command <b>ics46 start_project <i>YOUR_CHOSEN_PROJECT_NAME</i> project1</b> to create your new project directory using the <b>project1</b> template.  (For example, if you wanted to call your project directory <b>proj1</b>, you would issue the command <b>ics46 start_project proj1 project1</b> to create it.)  Now you're ready to proceed!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The project directory</p>\r\n\r\n<p>Change into your project directory and take a look around, to be sure you're aware of what's already available.  What you'll find will look a lot like the <b>basic</b> project template you've seen previously, and the ultimate result of building your project will be three separate programs you can run with a script called <b>run</b>:</p>\r\n\r\n<ul>\r\n  <li><b>./run app</b> runs the application, a GUI that displays mazes and their solutions.</li>\r\n  <li><b>./run exp</b> runs any experiments you want to write as you work.  These are not required, but they may help you to isolate issues and experiment with their solutions outside of the context of the GUI.</li>\r\n  <li><b>./run gtest</b> runs any Google Test unitt ests that you want to write as you work.  As with the experiments, they are not required, but this is another good tool for isolating issues, figuring out how to fix them, and then verifying that they're fixed.</li>\r\n</ul>\r\n\r\n<p>More specifically, here's what you'll find in your project directory:</p>\r\n\r\n<ul>\r\n  <li>A directory called <b>lib</b>, in which there are two precompiled libraries that make up the part of the project that you won't be implementing yourself.\r\n    <ul>\r\n      <li><b>libdarkmaze.so</b> contains implementations of maze-related concepts like mazes, maze solutions, verifiers, and so on.</li>\r\n      <li><b>libdarkui.so</b> contains the implementation of the application's graphical user interface.  You will not have to implement the GUI yourself; it is being provided in this library.</li>\r\n    </ul>\r\n  Note that these libraries are being provided in a compiled form without source code, though you'll find declarations of some of their classes elsewhere (see below).</li>\r\n  <li>A directory called <b>include</b>, in which you'll find three directories:\r\n    <ul>\r\n      <li><b>darkmaze</b>, which contains declarations of classes exported by <b>libdarkmaze.so</b>.  You will need to include some of these files in your own header and source files, though you will not need all of them; it's up to you to decide which of these is relevant to your work.</li>\r\n      <li><b>darkui</b>, which contains declarations of classes exported by <b>libdarkui.so</b>.  This is not something you're likely to need, as the only place this is likely to be useful is in the application's <b>main()</b> function, which has already been written.</li>\r\n      <li><b>ics46</b>, which contains a broad-based <i>ICS 46 Library</i>, which will grow as we continue our work this quarter, providing tools that will assist you (and also me!) in implementing your projects.</li>\r\n    </ul>\r\n  </li>\r\n  <li>A directory called <b>app</b>, in which the application's <b>main()</b> function resides.  This has already been completed; you shouldn't have to modify it.</li>\r\n  <li>A directory called <b>core</b>, in which you'll write your maze generators, maze solvers, and any additional code for this project.</li>\r\n  <li>A directory called <b>exp</b>, in which you'll write any experiments that you'd like to write outside of the context of the GUI.  The file <b>expmain.cpp</b> is the entry point for the experiments (which you run with the command <b>./run exp</b>).</li>\r\n  <li>A directory called <b>gtest</b>, in which you'll write any unit tests that you'd like to write.  The file <b>gtestmain.cpp</b> is the entry point and has already been written; all you need to do is create new source files and place them in the <b>gtest</b> directory, then rebuild, and they will be executed automatically when you issue the command <b>./run gtest</b>.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The application</p>\r\n\r\n<p>Your work on this project begins with an already-existing, already-working application with a graphical user interface (GUI) that can display a maze and its solution, and can also animate the process of generating and solving a maze.  The GUI window looks like this:</p>\r\n\r\n<p class=\"center\"><img src=\"ics46maze.png\" alt=\"ICS 46 Project #1 - Screenshot\" /></p>\r\n\r\n<p>The large area with a white background is where a maze and its solution are drawn.  Initially, this will be an empty area with a white background; when you generate or a solve a maze, the result will appear within that area.  In the example above, both a maze and its solution are displayed.</p>\r\n\r\n<p>Along the right-hand side of the window are a set of controls, allowing you to:</p>\r\n\r\n<ul>\r\n  <li>Choose the width and height of the maze you'd like to generate.  The range, not shown numerically, is from 10-50 cells wide and 10-50 cells tall.</li>\r\n  <li>Choose what algorithm you'd like to use to generate a maze.  There are two algorithms provided (and you'll write one or more additional algorithms):\r\n    <ul>\r\n      <li><b>Depth-First (Provided)</b>, which is a recursive, depth-first maze generator like one that you'll be building.</li>\r\n      <li><b>Kruskal's Algorithm (Provided)</b>, which uses a well-known algorithm called Kruskal's algorithm to randomly remove walls so long as they do not cause the maze to become imperfect (i.e., introduce two separate paths connecting any two cells).</li>\r\n    </ul>\r\n  </li>\r\n  <li>Generate a new maze, which will clear out any existing maze and its solution.</li>\r\n  <li>Choose what algorithm you'd like to use to solve a maze.  There are two algorithms provided (and you'll write one or more additional algorithms):\r\n    <ul>\r\n      <li><b>Breadth-First (Provided)</b>, which uses a breadth-first approach to solving a maze.</li>\r\n      <li><b>Depth-First (Provided)</b>, which uses a recursive, depth-first algorithm for solving a maze like one that you'll be building.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Control whether or not the process of generating and solving mazes will be animated (i.e., each step will be shown individually, as opposed to only seeing the final result) and, if so, at what speed the animation will progress.</li>\r\n</ul>\r\n\r\n<p>Just below the display of the maze and its solution is a line of text that displays various messages.  When you first start the program, it says <b>Welcome!</b>.  When a maze generator or maze solver finishes, this message will tell you about the result &mdash; in particular, whether a generated maze is perfect, and whether a solution is complete and correct &mdash; which is a good way to verify that your algorithms are doing what you expect them to do.</p>\r\n\r\n<p class=\"subtitle\">A brief word of warning</p>\r\n\r\n<p>When you start the application on your ICS 46 VM, you may notice an error message like this one in your Terminal window:</p>\r\n\r\n<blockquote><pre>\r\nOpenGL Warning: Failed to connect to host. Make sure 3D acceleration is enabled for this VM.\r\nlibGL error: failed to load drive: vboxvideo\r\nlibGL error: Try again with LIBGL_DEBUG=verbose for more details.\r\n</pre></blockquote>\r\n\r\n<p>This is something you can safely ignore.  While the GUI was built with a library called Qt that integrates with OpenGL and provides support for 3D graphics and video playback, that functionality is not being used by our application.  (I tried turning 3D acceleration on in my VM's settings in VirtualBox, but that caused many additional error messages to pop up instead, so I gave up trying to solve this problem, since it has no effect on our work anyway.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The requirements</p>\r\n\r\n<p>This project requires you to complete two tasks:</p>\r\n\r\n<ul>\r\n  <li>Write a maze generator that uses a recursive, depth-first algorithm to randomly generate a maze of arbitrary size, with the result required to be a <i>perfect maze</i>.\r\n    <ul>\r\n      <li>You can also optionally write as many additional maze generators as you'd like, with no limitations on what algorithms or techniques you use, and with no limitation that the result be a perfect maze.  Feel free to do anything you'd like and let your creativity run wild.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Write a maze solver that uses a recursive, depth-first algorithm to traverse and solve a maze of arbitrary size, with the solution extending from the maze's starting cell to its ending cell without crossing any walls.\r\n    <ul>\r\n      <li>You can also optionally write as many additional maze solvers as you'd like, with no limitations on what algorithms or techniques you use, and with no limitation that the result be a correct, complete maze solution.  Feel free to do anything you'd like and let your creativity run wild.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">A quick note about extra credit</p>\r\n\r\n<p>While we encourage you to explore as many maze generators and maze solvers as you'd like, be aware that we are not offering extra credit for generators or solvers beyond the one of each that you are required to implement.  You can receive a perfect score on this project while implementing only a single maze generator and a single maze solver.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Generating a maze</p>\r\n\r\n<p>Each maze generator needs to be written in its own class.  So, to write a maze generator, create a new class in the <b>core</b> directory of your project directory, declaring the class in a header file and defining its member functions (and other source code) in a corresponding source file.</p>\r\n\r\n<p>The GUI automatically displays all of the maze generators that are compiled into the program, but only if you follow a couple of rules to help the GUI find and create them:</p>\r\n\r\n<ul>\r\n  <li>You must derive your class from the abstract base class <b>MazeGenerator</b>, which is declared in a file <b>MazeGenerator.hpp</b> in <b>include/darkmaze</b>.  (You can include this file by simply saying <b>#include \"MazeGenerator.hpp\"</b>, since the compiler has already been configured to look in the <b>include/darkmaze</b> directory for header files.)  Deriving from this class obligates you to provide an implementation for this member function in your class:\r\n<blockquote><pre>\r\nvirtual void generateMaze(Maze& maze);\r\n</pre></blockquote>\r\n  where <b>Maze</b> is declared in the file <b>Maze.hpp</b>, also in the <b>include/darkmaze</b> directory.</li>\r\n  </li>\r\n  <li>You must be sure that your class has a default constructor (i.e., a constructor that takes no parameters).  Most likely, you won't implement a constructor in your class at all; if you do, be sure you implement at least one that takes no parameters.</li>\r\n  <li>In the source file &mdash; not in the header file, as it's important that this only be done once &mdash; you'll need to do two things:\r\n    <ul>\r\n      <li>Write this include directive near the top:\r\n<blockquote><pre>\r\n#include &lt;ics46/factory/DynamicFactory.hpp&gt;\r\n</pre></blockquote>\r\n      </li>\r\n      <li>Write this line of code somewhere after that include directive:\r\n<blockquote><pre>\r\nICS46_DYNAMIC_FACTORY_REGISTER(MazeGenerator, <b><i>name of your class</i></b>, \"<b><i>display name</i></b>\");\r\n</pre></blockquote>\r\n      substituting the name of your class where <b><i>name of your class</i></b> appears and the name you'd like to see in the GUI for your maze generator where <b><i>display name</i></b> appears.  For example, my <b>KruskalMazeGenerator.cpp</b> file (which has not been provided, but is compiled into the <b>libdarkmaze.so</b> library) has this line near the top:\r\n<blockquote><pre>\r\nICS46_DYNAMIC_FACTORY_REGISTER(MazeGenerator, KruskalMazeGenerator, \"Kruskal's Algorithm (Provided)\");\r\n</pre></blockquote>\r\n      </li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">The required algorithm</p>\r\n\r\n<p>The required algorithm must generate a <i>perfect maze</i>.  Viewing a mze as a two-dimensional matrix of square cells, a perfect maze is one in which any two cells are connected by a single unique path.  An important consequence of a maze being perfect is that all cells in a perfect maze are reachable from the starting point by some unique path, meaning that perfect mazes are guaranteed to have a solution.  They're also guaranteed to have a unique solution, which makes them more interesting to solve.</p>\r\n\r\n<p>To generate a perfect maze, you'll use a recursive algorithm to \"dig tunnels\" of various lengths.  It starts with a maze in which all of the possible walls exist (i.e., a wall exists on every side of every cell), then continues removing walls until a perfect maze has been constructed.  Naturally, it requires some care not to remove walls that would cause the maze to be imperfect; in our tunnel-digging algorithm, we have to be sure we stop digging before we knock out walls that would lead to places we've already been.</p>\r\n\r\n<p>The algorithm works, then, by starting at a particular cell (and it doesn't matter, ultimately, which cell you start from), and does the following:</p>\r\n\r\n<ul>\r\n  <li>Mark the current cell as \"visited.\"</li>\r\n  <li>While the current cell has any adjacent cells that have not yet been visited...\r\n    <ul>\r\n      <li>Choose one of the unvisited adjacent cells at random.  Randomness is important here, or your algorithm will always generate the same maze.</li>\r\n      <li>Remove the wall between the current cell and the cell you just chose.</li>\r\n      <li>Recursively call this algorithm, with the chosen cell becoming the current cell.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>As you generate your maze, you'll need to call member functions on the <b>Maze</b> object that was provided as a parameter.  Don't assume anything in particular about that <b>Maze</b> object, other than it has the correct width and height; make any changes you need to make in order to achieve the correct result.</p>\r\n\r\n<p>The animation in the GUI is automatic; if animation is selected in the GUI, any change you make to your maze will result in the GUI window being redrawn, so you won't need to do anything special to accommodate that feature.</p>\r\n\r\n<p>You can write as many other maze generators as you'd like, by following the same steps (i.e., creating a separate class that derives from <b>MazeGenerator</b>, registering it with the <b>DynamicFactory</b>, giving it a display name, etc.).  All of the maze generators you write should show up in the GUI if you set them up right.</p>\r\n\r\n<p class=\"subtitle\">Naming your required maze generator so we can find it</p>\r\n\r\n<p>Each of your maze generators has a <i>display name</i>, given as a string literal as the third parameter in the call to the <b>ICS46_DYNAMIC_FACTORY_REGISTER</b> macro.  So we know which one of your maze generators is the required one, you <i>must</i> choose a display name for your required maze generator that has the parenthesized word <b>(Required)</b> on the end of it (similar to how the provided generators have the parenthesized word <b>(Provided)</b> on the end of their names).</p>\r\n\r\n<p>Otherwise, you can name your required generator anything you'd like, and you can name any other generators in any way you'd like, except they should <i>not</i> have the word <b>(Required)</b> on the end of them.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Solving a maze</p>\r\n\r\n<p>Each maze solving needs to be written in its own class.  So, to write a maze solver, create a new class in the <b>core</b> directory of your project directory, declaring the class in a header file and defining its member functions (and other source code) in a corresponding source file.</p>\r\n\r\n<p>The GUI automatically displays all of the maze solvers that are compiled into the program, but only if you follow similar rules to those you followed for your generators:</p>\r\n\r\n<ul>\r\n  <li>You must derive your class from the abstract base class <b>MazeSolver</b>, which is declared in a file <b>MazeSolver.hpp</b> in <b>include/darkmaze</b>.  (You can include this file by simply saying <b>#include \"MazeSolver.hpp\"</b>, since the compiler has already been configured to look in the <b>include/darkmaze</b> directory for header files.)  Deriving from this class obligates you to provide an implementation for this member function in your class:\r\n<blockquote><pre>\r\nvirtual void solveMaze(const Maze& maze, MazeSolution& mazeSolution);\r\n</pre></blockquote>\r\n  where <b>Maze</b> is declared in the file <b>Maze.hpp</b> and <b>MazeSolution</b> is declared in the file <b>MazeSolution.hpp</b>, also in the <b>include/darkmaze</b> directory.</li>\r\n  </li>\r\n  <li>You must be sure that your class has a default constructor (i.e., a constructor that takes no parameters).  Most likely, you won't implement a constructor in your class at all; if you do, be sure you implement at least one that takes no parameters.</li>\r\n  <li>Register your class with the ICS 46 DynamicFactory, just as you did with your maze solver:\r\n<blockquote><pre>\r\nICS46_DYNAMIC_FACTORY_REGISTER(MazeSolver, <b><i>name of your class</i></b>, \"<b><i>display name</i></b>\");\r\n</pre></blockquote>\r\n      substituting the name of your class where <b><i>name of your class</i></b> appears and the name you'd like to see in the GUI for your maze solver where <b><i>display name</i></b> appears.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">The required algorithm</p>\r\n\r\n<p>The required algorithm must solve the maze using a recursive algorithm with <i>backtracking</i>.  A backtracking algorithm is one that recursively investigates all of the possibilities by moving down a path that hopefully leads to a solution and then, if that path fails, backing up to the nearest place where some untried alternative is available and trying another path.  While you could potentially implement an algorithm like this iteratively, it turns out to be a lot less work to do so recursively, as the process of recursion will naturally and automatically manage details that you would otherwise have to manage yourself.</p>\r\n\r\n<p>I'll leave the details of this algorithm as an exercise for you to figure out.  If you understand the maze-generating algorithm above, it should not be a big step to design the maze-solving algorithm.</p>\r\n\r\n<p>As you generate your maze, you'll need to call member functions on the <b>Maze</b> and <b>MazeSolution</b> objects that were provided as parameters, though note that the <b>Maze</b> has been passed as a constant (because you shouldn't have to change a maze in order to solve it).</p>\r\n\r\n<p>The animation in the GUI is automatic; if animation is selected in the GUI, any change you make to your maze solution will result in the GUI window being redrawn, so you won't need to do anything special to accommodate that feature.</p>\r\n\r\n<p>You can write as many other maze solvers as you'd like, by following the same steps (i.e., creating a separate class that derives from <b>MazeSolver</b>, registering it with the <b>DynamicFactory</b>, giving it a display name, etc.).  All of the maze solvers you write should show up in the GUI if you set them up right.</p>\r\n\r\n<p class=\"subtitle\">Naming your required maze solver so we can find it</p>\r\n\r\n<p>Each of your maze generators has a <i>display name</i>, given as a string literal as the third parameter in the call to the <b>ICS46_DYNAMIC_FACTORY_REGISTER</b> macro.  So we know which one of your maze solvers is the required one, you <i>must</i> choose a display name for your required maze solver that has the parenthesized word <b>(Required)</b> on the end of it (similar to how the provided solvers have the parenthesized word <b>(Provided)</b> on the end of their names).</p>\r\n\r\n<p>Otherwise, you can name your required solver anything you'd like, and you can name any other solvers in any way you'd like, except they should <i>not</i> have the word <b>(Required)</b> on the end of them.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>After using the <b>gather</b> script in your project directory to gather up your C++ source and header files into a single <b>project1.tar.gz</b> file (as you did in <a href=\"../Project0\">Project #0</a>, submit that file (and only that file) to Checkmate.  Refer back to <a href=\"../Project0\">Project #0</a> if you need instructions on how to do that.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for a discussion of how to submit your project via Checkmate.  Be aware that I'll be holding you to all of the rules specified in that document, including the one that says that you're reponsible for submitting the version of the project that you want graded.  We won't regrade a project simply because you submitted the wrong version accidentally.  (It's not a bad idea to look at the contents of your tarball before submitting it; see <a href=\"../Project0\">Project #0</a> for instructions on how to do that.)</p>\r\n\r\n<p class=\"subtitle\">Can I submit after the deadline?</p>\r\n\r\n<p>Yes, it is possible, subject to the late work policy for this course, which is described in the section titled <i>Late work</i> at <a href=\"../index.html\">this link</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Originally written by Alex Thornton, Spring 2014, with heavy influence from a similarly-named project from ICS 23.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 16763.0}