{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Polytope distance d Traits Definition An object of the class Polytope distance d Traits represents the squared distance between two convex polytopes given as the convex hulls of two finite point sets in d dimensional Euclidean space d For point sets P and Q we denote by pd P Q the distance between the convex hulls of P and Q Note that pd P Q can be degenerate i e pd P Q if P or Q is empty Two inclusion minimal subsets SP of P and SQ of Q with pd SP SQ pd P Q are called pair of support sets the points in SP and SQ are the support points A pair of support sets has size at most d 2 by size we mean SP SQ The distance between the two polytopes is realized by a pair of points p and q lying in the convex hull of SP and SQ repectively i e sqrt p q pd P Q In general neither the support sets nor the realizing points are necessarily unique The underlying algorithm can cope with all kinds of input e g P and Q may be in non convex position or points may occur more than once The algorithm computes a pair of support sets SP and SQ with realizing points p and q which remain fixed until the next set insert or clear operation include CGAL Polytope distance d h Requirements The template parameter Traits is a model for OptimisationDTraits We provide the models Optimisation d traits 2 Optimisation d traits 3 and Optimisation d traits d using the two three and d dimensional CGAL kernel respectively Types Polytope distance d Traits Point typedef to Traits Point d Point type used to represent the input points Polytope distance d Traits FT typedef to Traits FT Number type used to return the squared distance between the two polytopes Polytope distance d Traits ET typedef to Traits ET Number type used to do the exact computations in the underlying solver for quadratic programs cf Implementation Polytope distance d Traits Point iterator non mutable model of the STL concept RandomAccessIterator with value type Point Used to access the points of the two polytopes Polytope distance d Traits Support point iterator non mutable model of the STL concept RandomAccessIterator with value type Point Used to access the support points Polytope distance d Traits Coordinate iterator non mutable model of the STL concept RandomAccessIterator with value type ET Used to access the coordinates of the realizing points Creation Polytope distance d Traits poly dist Traits traits Traits int verbose std ostream stream std cout initializes poly dist to pd template class InputIterator1 class InputIterator2 Polytope distance d Traits poly dist InputIterator1 p first InputIterator1 p last InputIterator2 q first InputIterator2 q last Traits traits Traits int verbose std ostream stream std cout initializes poly dist to pd P Q with P and Q being the sets of points in the range p first p last and q first q last respectively Requirement The value type of InputIterator1 and InputIterator2 is Point Precondition All points have the same dimension advanced If verbose is set to 1 2 or 3 then some more or full verbose output of the underlying solver for quadratic programs is written to stream resp advanced Access Functions int poly dist ambient dimension returns the dimension of the points in P and Q If poly dist is pd the ambient dimension is 1 int poly dist number of points returns the number of all points of poly dist i e P Q int poly dist number of points p returns the number of points in P int poly dist number of points q returns the number of points in Q int poly dist number of support points returns the number of support points of poly dist i e SP SQ int poly dist number of support points p returns the number of support points in SP int poly dist number of support points q returns the number of support points in SQ Point iterator poly dist points p begin returns an iterator referring to the first point in P Point iterator poly dist points p end returns the corresponding past the end iterator Point iterator poly dist points q begin returns an iterator referring to the first point in Q Point iterator poly dist points q end returns the corresponding past the end iterator Support point iterator poly dist support points p begin returns an iterator referring to the first support point in SP Support point iterator poly dist support points p end returns the corresponding past the end iterator Support point iterator poly dist support points q begin returns an iterator referring to the first support point in SQ Support point iterator poly dist support points q end returns the corresponding past the end iterator Point poly dist realizing point p returns the realizing point of P Requirement An implicit conversion from ET to RT is available Precondition pd P Q is finite Point poly dist realizing point q returns the realizing point of Q Requirement An implicit conversion from ET to RT is available Precondition pd P Q is finite FT poly dist squared distance returns the squared distance of poly dist i e pd P Q 2 Requirement An implicit conversion from ET to RT is available Precondition pd P Q is finite Coordinate iterator poly dist realizing point p coordinates begin returns an iterator referring to the first coordinate of the realizing point of P Note The coordinates have a rational representation i e the first d elements of the iterator range are the numerators and the d 1 st element is the common denominator Coordinate iterator poly dist realizing point p coordinates end returns the corresponding past the end iterator Coordinate iterator poly dist realizing point q coordinates begin returns an iterator referring to the first coordinate of the realizing point of Q Note The coordinates have a rational representation i e the first d elements of the iterator range are the numerators and the d 1 st element is the common denominator Coordinate iterator poly dist realizing point q coordinates end returns the corresponding past the end iterator ET poly dist squared distance numerator returns the numerator of the squared distance of poly dist ET poly dist squared distance denominator returns the denominator of the squared distance of poly dist Predicates bool poly dist is finite returns true if pd P Q is finite i e none of the two polytopes is empty bool poly dist is zero returns true if pd P Q is zero i e the two polytopes intersect this implies degeneracy bool poly dist is degenerate returns true iff pd P Q is degenerate i e pd P Q is not finite Modifiers void poly dist clear resets poly dist to pd template class InputIterator1 class InputIterator2 void poly dist set InputIterator1 p first InputIterator1 p last InputIterator2 q first InputIterator2 q last sets poly dist to pd P Q with P and Q being the sets of points in the ranges p first p last and q first q last respectively Requirement The value type of InputIterator1 and InputIterator2 is Point Precondition All points have the same dimension template class InputIterator void poly dist set p InputIterator p first InputIterator p last sets poly dist to pd P Q with P being the set of points in the range p first p last Q remains unchanged Requirement The value type of InputIterator is Point Precondition All points in P have dimension poly dist ambient dimension if Q is not empty template class InputIterator void poly dist set q InputIterator q first InputIterator q last sets poly dist to pd P Q with Q being the set of points in the range q first q last P remains unchanged Requirement The value type of InputIterator is Point Precondition All points in Q have dimension poly dist ambient dimension if P is not empty void poly dist insert p Point p inserts p into P Precondition The dimension of p equals poly dist ambient dimension if poly dist is not pd void poly dist insert q Point q inserts q into Q Precondition The dimension of q equals poly dist ambient dimension if poly dist is not pd template class InputIterator1 class InputIterator2 void poly dist insert InputIterator1 p first InputIterator1 p last InputIterator2 q first InputIterator2 q last inserts the points in the range p first p last and q first q last into P and Q respectively and recomputes the squared distance Requirement The value type of InputIterator1 and InputIterator2 is Point Precondition All points have the same dimension If poly dist is not pd this dimension must be equal to poly dist ambient dimension template class InputIterator void poly dist insert p InputIterator p first InputIterator p last inserts the points in the range p first p last into P and recomputes the squared distance Q remains unchanged Requirement The value type of InputIterator is Point Precondition All points have the same dimension If poly dist is not empty this dimension must be equal to poly dist ambient dimension template class InputIterator void poly dist insert q InputIterator q first InputIterator q last inserts the points in the range q first q last into Q and recomputes the squared distance P remains unchanged Requirement The value type of InputIterator is Point Precondition All points have the same dimension If poly dist is not empty this dimension must be equal to poly dist ambient dimension Validity Check An object poly dist is valid iff poly dist contains all points of its defining set P poly dist is the smallest sphere containing its support set S and S is minimal i e no support point is redundant bool poly dist is valid bool verbose false int level returns true iff poly dist is valid If verbose is true some messages concerning the performed checks are written to standard error stream The second parameter level is not used we provide it only for consistency with interfaces of other classes Miscellaneous const Traits poly dist traits returns a const reference to the traits class object I O std ostream std ostream os poly dist writes poly dist to output stream os Requirement The output operator is defined for Point d std istream std istream is poly dist reads poly dist from input stream is Requirement The input operator is defined for Point d See Also CGAL Optimisation d traits 2 K ET NT CGAL Optimisation d traits 3 K ET NT CGAL Optimisation d traits d K ET NT OptimisationDTraits Implementation The problem of finding the distance between two convex polytopes given as the convex hulls of two finite point sets can be formulated as an optimization problem with linear constraints and a convex quadratic objective function The solution is obtained using our exact solver for quadratic programs GS The creation time is almost always linear in the number of points Access functions and predicates take constant time inserting a point might take up to linear time The clear operation and the check for validity each take linear time Next monotone matrix search Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Optimisation_ref/Class_Polytope_distance_d.html", "title": "polytope_distance_d&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Optimisation_ref/Polytope_distance_d.tex' -->\n<html> <head>  \n<title>Polytope_distance_d&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1204\"></A>\n\n<A NAME=\"Cross_link_anchor_1205\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1258\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Polytope_distance_d<Traits>\"></A>\n<h2><I>CGAL::Polytope_distance_d&lt;Traits&gt;</I></h2>\n<P>\n\n<A NAME=\"Index_anchor_1259\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1260\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1261\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nAn object of the class <I><A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;</I> represents the (squared) distance\nbetween two convex polytopes, given as the convex hulls of two finite point\nsets in <MATH><I>d</I></MATH>-dimensional Euclidean space <MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>d</SUB></I></MATH>. For point sets <MATH><I>P</I></MATH> and <MATH><I>Q</I></MATH>\nwe denote by <MATH><I>pd(P,Q)</I></MATH> the distance between the convex hulls of <MATH><I>P</I></MATH> and\n<MATH><I>Q</I></MATH>. Note that <MATH><I>pd(P,Q)</I></MATH> can be\ndegenerate,\ni.e.&nbsp;<MATH><I>pd(P,Q)= <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </I></MATH> if <MATH><I>P</I></MATH> or <MATH><I>Q</I></MATH> is empty.\n<P>\n\nTwo inclusion-minimal subsets <MATH><I>S<SUB>P</SUB></I></MATH> of <MATH><I>P</I></MATH> and <MATH><I>S<SUB>Q</SUB></I></MATH> of <MATH><I>Q</I></MATH> with\n<MATH><I>pd(S<SUB>P</SUB>,S<SUB>Q</SUB>)=pd(P,Q)</I></MATH> are called <I>pair of support\n  sets</I>, the\npoints in <MATH><I>S<SUB>P</SUB></I></MATH> and <MATH><I>S<SUB>Q</SUB></I></MATH> are the <I>support points</I>. A pair of support\nsets has size at most <MATH><I>d+2</I></MATH> (by size we mean <MATH><I>|S<SUB>P</SUB>|+|S<SUB>Q</SUB>|</I></MATH>). The distance\nbetween the two polytopes is <I>realized</I> by a pair of points <MATH><I>p</I></MATH> and\n<MATH><I>q</I></MATH> lying in the convex hull of <MATH><I>S<SUB>P</SUB></I></MATH> and <MATH><I>S<SUB>Q</SUB></I></MATH>, repectively,\ni.e.&nbsp;<MATH><I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(||p-q||)=pd(P,Q)</I></MATH>. In general, neither the support sets nor the\nrealizing points are necessarily unique.\n<P>\n\nThe underlying algorithm can cope with all kinds of input, e.g.&nbsp;<MATH><I>P</I></MATH> and&nbsp;<MATH><I>Q</I></MATH>\nmay be in non-convex position or points may occur more than once. The\nalgorithm computes a pair of support sets <MATH><I>S<SUB>P</SUB></I></MATH> and <MATH><I>S<SUB>Q</SUB></I></MATH> with realizing\npoints <MATH><I>p</I></MATH> and <MATH><I>q</I></MATH> which remain fixed until the next set, insert, or clear\noperation.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Polytope_distance_d.h\">CGAL/Polytope_distance_d.h</A>&gt;</I>\n<P>\n\n<H3>Requirements</H3>   \n     \n     \n<A NAME=\"Index_anchor_1262\"></A>\n<P>\n\nThe template parameter <I>Traits</I> is a model for <I><A HREF=\"Concept_OptimisationDTraits.html#Cross_link_anchor_1181\">OptimisationDTraits</A></I>.\n<P>\n\nWe provide the models <I><A HREF=\"Class_Optimisation_d_traits_2.html#Cross_link_anchor_1176\">Optimisation_d_traits_2</A></I>,\n<I><A HREF=\"Class_Optimisation_d_traits_3.html#Cross_link_anchor_1178\">Optimisation_d_traits_3</A></I>, and <I><A HREF=\"Class_Optimisation_d_traits_d.html#Cross_link_anchor_1180\">Optimisation_d_traits_d</A></I> using the\ntwo-, three-, and <MATH><I>d</I></MATH>-dimensional C<SMALL>GAL</SMALL>&nbsp;kernel, respectively.\n<P>\n\n<H3>Types</H3>   \n     \n     \n<A NAME=\"Index_anchor_1263\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;::Point\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A></I>.\n        Point type used to represent the input points.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;::FT\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::FT</I>.\n        Number type used to return the squared distance\n        between the two polytopes.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;::ET\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::ET</I>.\n        Number type used to do the exact computations in the underlying\n        solver for quadratic programs (cf.&nbsp;<B>Implementation</B>).\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL concept <I>RandomAccessIterator</I>\n        with value type <I>Point</I>. Used to access the points\n        of the two polytopes.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;::Support_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL concept <I>RandomAccessIterator</I>\n        with value type <I>Point</I>. Used to access the support points.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt;::Coordinate_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL concept <I>RandomAccessIterator</I>\n        with value type <I>ET</I>. Used to access the coordinates of\n        the realizing points.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1264\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt; poly_dist ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Traits traits = Traits(),<BR>\n\nint verbose = 0,<BR>\n\nstd::ostream&amp; stream = std::cout);</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>poly_dist</I> to <MATH><I>pd(</I></MATH>&Oslash;<MATH><I>,</I></MATH>&Oslash;<MATH><I>)</I></MATH>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator1, class InputIterator2 &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Polytope_distance_d.html#Cross_link_anchor_1205\">Polytope_distance_d</A>&lt;Traits&gt; poly_dist ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator1 p_first,<BR>\n\nInputIterator1 p_last,<BR>\n\nInputIterator2 q_first,<BR>\n\nInputIterator2 q_last,<BR>\n\nTraits traits = Traits(),<BR>\n\nint verbose = 0,<BR>\n\nstd::ostream&amp; stream = std::cout);</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>poly_dist</I> to <MATH><I>pd(P,Q)</I></MATH> with <MATH><I>P</I></MATH> and <MATH><I>Q</I></MATH> being the\n        sets of points in the range [<I>p_first</I>,<I>p_last</I>) and\n        [<I>q_first</I>,<I>q_last</I>), respectively.<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator1</I> and\n        <I>InputIterator2</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n  If <I>verbose</I> is set to <MATH><I>1</I></MATH>, <MATH><I>2</I></MATH>, or <MATH><I>3</I></MATH> then some, more, or full\n  verbose output of the underlying solver for quadratic programs is\n  written to <I>stream</I>, resp.\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Access Functions</H3>   \n     \n     \n<A NAME=\"Index_anchor_1265\"></A> \n\n   \n\n\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1266\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1267\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_ambient_dimension6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.ambient_dimension ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the dimension of the points in <MATH><I>P</I></MATH> and <MATH><I>Q</I></MATH>.\n        If <I>poly_dist</I> is <MATH><I>pd(</I></MATH>&Oslash;<MATH><I>,</I></MATH>&Oslash;<MATH><I>)</I></MATH>, the ambient dimension is <MATH><I>-1</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.number_of_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of all points of <I>poly_dist</I>, i.e.&nbsp;<MATH><I>|P|+|Q|</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_points_p6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.number_of_points_p ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of points in <MATH><I>P</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_points_q6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.number_of_points_q ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of points in <MATH><I>Q</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_support_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.number_of_support_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of support points of <I>poly_dist</I>, i.e.&nbsp;<MATH><I>|S<SUB>P</SUB>|+|S<SUB>Q</SUB>|</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_support_points_p6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.number_of_support_points_p ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of support points in <MATH><I>S<SUB>P</SUB></I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_support_points_q6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.number_of_support_points_q ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of support points in <MATH><I>S<SUB>Q</SUB></I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_p_begin6_9_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.points_p_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first point in <MATH><I>P</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_p_end6_9_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.points_p_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_q_begin6_9_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.points_q_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first point in <MATH><I>Q</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_q_end6_9_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.points_q_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_p_begin6_9_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.support_points_p_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first support point in <MATH><I>S<SUB>P</SUB></I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_p_end6_9_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.support_points_p_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_q_begin6_9_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.support_points_q_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first support point in <MATH><I>S<SUB>Q</SUB></I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_q_end6_9_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.support_points_q_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_realizing_point_p6_9_const;\"></A>\nPoint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.realizing_point_p ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the realizing point of <MATH><I>P</I></MATH>.<BR>\n\n<EM>Requirement: </EM>An implicit conversion from <I>ET</I> to <I>RT</I> is\n        available.<BR>\n\n<EM>Precondition: </EM><MATH><I>pd(P,Q)</I></MATH> is finite.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_realizing_point_q6_9_const;\"></A>\nPoint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.realizing_point_q ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the realizing point of <MATH><I>Q</I></MATH>.<BR>\n\n<EM>Requirement: </EM>An implicit conversion from <I>ET</I> to <I>RT</I> is\n        available.<BR>\n\n<EM>Precondition: </EM><MATH><I>pd(P,Q)</I></MATH> is finite.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_FT_squared_distance6_9_const;\"></A>\nFT\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.<A HREF=\"../Kernel_23_ref/Function_squared_distance.html#Cross_link_anchor_265\">squared_distance</A> ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the squared distance of <I>poly_dist</I>, i.e.&nbsp;<MATH><I>(pd(P,Q))<SUP>2</SUP></I></MATH>.<BR>\n\n<EM>Requirement: </EM>An implicit conversion from <I>ET</I> to <I>RT</I> is\n        available.<BR>\n\n<EM>Precondition: </EM><MATH><I>pd(P,Q)</I></MATH> is finite.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Coordinate_iterator_realizing_point_p_coordinates_begin69_const;\"></A>\nCoordinate_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.realizing_point_p_coordinates_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first coordinate of the\n        realizing point of <MATH><I>P</I></MATH>.<BR>\n\n<EM>Note: </EM> The coordinates have a rational\n        representation, i.e.&nbsp;the first <MATH><I>d</I></MATH> elements of the iterator\n        range are the numerators and the <MATH><I>(d+1)</I></MATH>-st element is the\n        common denominator.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Coordinate_iterator_realizing_point_p_coordinates_end69_const;\"></A>\nCoordinate_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.realizing_point_p_coordinates_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<BR>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Coordinate_iterator_realizing_point_q_coordinates_begin69_const;\"></A>\nCoordinate_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.realizing_point_q_coordinates_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first coordinate of the\n        realizing point of <MATH><I>Q</I></MATH>.<BR>\n\n<EM>Note: </EM> The coordinates have a rational\n        representation, i.e.&nbsp;the first <MATH><I>d</I></MATH> elements of the iterator\n        range are the numerators and the <MATH><I>(d+1)</I></MATH>-st element is the\n        common denominator.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Coordinate_iterator_realizing_point_q_coordinates_end69_const;\"></A>\nCoordinate_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.realizing_point_q_coordinates_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_ET_squared_distance_numerator6_9_const;\"></A>\nET\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.squared_distance_numerator ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the numerator of the squared distance of <I>poly_dist</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_ET_squared_distance_denominator6_9_const;\"></A>\nET\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.squared_distance_denominator ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the denominator of the squared distance of <I>poly_dist</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1268\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1269\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_finite6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.is_finite ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, if <MATH><I>pd(P,Q)</I></MATH> is finite,\n        i.e.&nbsp;none of the two polytopes is empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_zero6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.<A HREF=\"../NumberTypeSupport_ref/Function_is_zero.html#Cross_link_anchor_1376\">is_zero</A> ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, if <MATH><I>pd(P,Q)</I></MATH> is zero,\n        i.e.&nbsp;the two polytopes intersect (this implies degeneracy).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_degenerate6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.is_degenerate ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <MATH><I>pd(P,Q)</I></MATH> is degenerate,\n        i.e.&nbsp;<MATH><I>pd(P,Q)</I></MATH> is not finite.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1270\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1271\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear6_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    poly_dist.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    resets <I>poly_dist</I> to <MATH><I>pd(</I></MATH>&Oslash;<MATH><I>,</I></MATH>&Oslash;<MATH><I>)</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator1, class InputIterator2 &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set6_InputIterator1_p_first+_InputIterator1_p_last+_InputIterator2_q_first+_InputIterator2_q_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.set ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator1 p_first,<BR>\n\nInputIterator1 p_last,<BR>\n\nInputIterator2 q_first,<BR>\n\nInputIterator2 q_last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets <I>poly_dist</I> to <MATH><I>pd(P,Q)</I></MATH> with <MATH><I>P</I></MATH> and <MATH><I>Q</I></MATH> being the sets of\n        points in the ranges [<I>p_first</I>,<I>p_last</I>) and\n        [<I>q_first</I>,<I>q_last</I>), respectively.<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator1</I> and\n        <I>InputIterator2</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set_p6_InputIterator_p_first+_InputIterator_p_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.set_p ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator p_first,<BR>\n\nInputIterator p_last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets <I>poly_dist</I> to <MATH><I>pd(P,Q)</I></MATH> with <MATH><I>P</I></MATH> being the set of points\n        in the range [<I>p_first</I>,<I>p_last</I>) (<MATH><I>Q</I></MATH> remains unchanged).<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points in <MATH><I>P</I></MATH> have dimension\n        <I>poly_dist</I><I>.ambient_dimension()</I> if <MATH><I>Q</I></MATH> is not empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set_q6_InputIterator_q_first+_InputIterator_q_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.set_q ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator q_first,<BR>\n\nInputIterator q_last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets <I>poly_dist</I> to <MATH><I>pd(P,Q)</I></MATH> with <MATH><I>Q</I></MATH> being the set of points\n        in the range [<I>q_first</I>,<I>q_last</I>) (<MATH><I>P</I></MATH> remains unchanged).<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points in <MATH><I>Q</I></MATH> have dimension\n        <I>poly_dist</I><I>.ambient_dimension()</I> if <MATH><I>P</I></MATH> is not empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert_p6_const_Point__p9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.insert_p (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts <I>p</I> into <MATH><I>P</I></MATH>.<BR>\n\n<EM>Precondition: </EM>The dimension of <I>p</I> equals\n        <I>poly_dist</I><I>.ambient_dimension()</I> if <I>poly_dist</I> is not <MATH><I>pd(</I></MATH>&Oslash;<MATH><I>,</I></MATH>&Oslash;<MATH><I>)</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert_q6_const_Point__q9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.insert_q (  Point q)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts <I>q</I> into <MATH><I>Q</I></MATH>.<BR>\n\n<EM>Precondition: </EM>The dimension of <I>q</I> equals\n        <I>poly_dist</I><I>.ambient_dimension()</I> if <I>poly_dist</I> is not <MATH><I>pd(</I></MATH>&Oslash;<MATH><I>,</I></MATH>&Oslash;<MATH><I>)</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator1, class InputIterator2 &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_InputIterator1_p_first+_InputIterator1_p_last+_InputIterator2_q_first+_InputIterator2_q_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator1 p_first,<BR>\n\nInputIterator1 p_last,<BR>\n\nInputIterator2 q_first,<BR>\n\nInputIterator2 q_last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the points in the range [<I>p_first</I>,<I>p_last</I>)\n        and [<I>q_first</I>,<I>q_last</I>) into <MATH><I>P</I></MATH> and <MATH><I>Q</I></MATH>, respectively,\n        and recomputes the (squared) distance.<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator1</I> and\n        <I>InputIterator2</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n        If <I>poly_dist</I> is not <MATH><I>pd(</I></MATH>&Oslash;<MATH><I>,</I></MATH>&Oslash;<MATH><I>)</I></MATH>, this dimension must be equal to\n        <I>poly_dist</I><I>.ambient_dimension()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert_p6_InputIterator_p_first+_InputIterator_p_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.insert_p ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator p_first,<BR>\n\nInputIterator p_last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the points in the range [<I>p_first</I>,<I>p_last</I>) into\n        <MATH><I>P</I></MATH> and recomputes the (squared) distance (<MATH><I>Q</I></MATH> remains unchanged).<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n        If <I>poly_dist</I> is not empty, this dimension must be equal to\n        <I>poly_dist</I><I>.ambient_dimension()</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert_q6_InputIterator_q_first+_InputIterator_q_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.insert_q ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator q_first,<BR>\n\nInputIterator q_last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the points in the range [<I>q_first</I>,<I>q_last</I>) into\n        <MATH><I>Q</I></MATH> and recomputes the (squared) distance (<MATH><I>P</I></MATH> remains unchanged).<BR>\n\n<EM>Requirement: </EM>The value type of <I>InputIterator</I> is <I>Point</I>.<BR>\n\n<EM>Precondition: </EM>All points have the same dimension.\n        If <I>poly_dist</I> is not empty, this dimension must be equal to\n        <I>poly_dist</I><I>.ambient_dimension()</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Validity Check</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1272\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1273\"></A>\n<P>\n\nAn object <I>poly_dist</I> is valid, iff\n...<UL>\n  <LI><I>poly_dist</I> contains all points of its defining set <MATH><I>P</I></MATH>,\n  <LI><I>poly_dist</I> is the smallest sphere containing its support set <MATH><I>S</I></MATH>, and\n  <LI><MATH><I>S</I></MATH> is minimal, i.e. no support point is redundant.\n</UL>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6_bool_verbose_=_false+_int_level_=_0_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    poly_dist.is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    bool verbose = false,<BR>\n\nint level = 0)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>poly_dist</I> is valid. If <I>verbose</I> is\n      <I>true</I>, some messages concerning the performed checks are\n      written to standard error stream. The second parameter\n      <I>level</I> is not used, we provide it only for consistency\n      with interfaces of other classes.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1274\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1275\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Traits__traits6_9_const;\"></A>\nconst Traits&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    poly_dist.traits ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a const reference to the traits class object.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>I/O</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1276\"></A>\n<P>\n\n<A NAME=\"Index_anchor_1277\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1278\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::ostream&amp; os &lt;&lt;  poly_dist<A NAME=\"Function_std::ostream__operator_66_6_std::ostream__os+_const_Polytope_distance_d6Traits9__poly_dist9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>poly_dist</I> to output stream <I>os</I>.<BR>\n\n<EM>Requirement: </EM>The output operator is defined for <I><A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A></I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::istream&amp; is &gt;&gt;  poly_dist&amp;<A NAME=\"Function_std::istream__operator_99_6_std::istream__is+_Polytope_distance_d6Traits9_poly_dist_9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads <I>poly_dist</I> from input stream <I>is</I>.<BR>\n\n<EM>Requirement: </EM>The input operator is defined for <I><A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A></I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Optimisation_d_traits_2.html#Cross_link_anchor_1175\">CGAL::Optimisation_d_traits_2</A>&lt;K,ET,NT&gt;</I><BR>\n\n<I><A HREF=\"Class_Optimisation_d_traits_3.html#Cross_link_anchor_1177\">CGAL::Optimisation_d_traits_3</A>&lt;K,ET,NT&gt;</I><BR>\n\n<I><A HREF=\"Class_Optimisation_d_traits_d.html#Cross_link_anchor_1179\">CGAL::Optimisation_d_traits_d</A>&lt;K,ET,NT&gt;</I><BR>\n\n<I><A HREF=\"Concept_OptimisationDTraits.html#Cross_link_anchor_1181\">OptimisationDTraits</A></I>\n<P>\n\n<H3>Implementation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1279\"></A>\n<P>\n\nThe problem of finding the distance between two convex polytopes given as\nthe convex hulls of two finite point sets can be formulated as an\noptimization problem with linear constraints and a convex quadratic\nobjective function. The solution is obtained using our exact solver\nfor quadratic programs&nbsp;[<A HREF=\"../biblio.html#Biblio_gs-eegqp-00\">GS00</A>].\n<P>\n\nThe creation time is almost always linear in the number of points.  Access\nfunctions and predicates take constant time, inserting a point might take\nup to linear time.  The clear operation and the check for validity each\ntake linear time.\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_monotone_matrix_search.html\"><I>monotone_matrix_search</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_52!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39120.0}