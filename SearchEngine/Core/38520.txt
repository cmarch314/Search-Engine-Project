{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 452D Apollonius graphs Menelaos Karavelas and Mariette Yvinec This chapter describes the two dimensional Apollonius graph of CGAL We start with a few definitions in Section The software design of the 2D Apollonius graph package is described in Section In Section we discuss the geometric traits of the 2D Apollonius graph package and in Section the Apollonius graph hierarchy a data structure suitable for fast nearest neighbor queries is briefly described 45 1 Definitions Figure The Apollonius diagram left and its dual the Apollonius graph right The 2D Apollonius graph class of CGAL is designed to compute the dual of the Apollonius diagram or as it is also known the Additively weighted Voronoi diagram The algorithm that has been implemented is dynamic which means that we can perform insertions and deletions on line The corresponding CGAL class is called Apollonius graph 2 ApolloniusGraphTraits 2 ApolloniusGraphDataStructure 2 and will be discussed in more detail in the sequel The interested reader may want to refer to the paper by Karavelas and Yvinec KY 2 for the general idea as well as the details of the algorithm implemented Before describing the details of the implementation we make a brief introduction to the theory of Apollonius diagrams The Apollonius diagram is defined over a set of sites Pi ci wi i 1 n where ci is the point and wi the weight of Pi It is a subdivision of the plane into connected regions called cells associated with the sites see Fig left The cell of a site Pi is the locus of points on the plane that are closer to Pi than any other site Pj j i The distance x Pi of a point x in the plane to a site Pi is defined as x Pi x ci wi where denotes the Euclidean norm It can easily be seen that it is a generalization of the Voronoi diagram for points which can actually be obtained if all the weights wi are equal Unlike the case of points however it is possible that a site Pi might have an empty cell This can also happen in the case of the power diagram whose dual is the regular triangulation see Section If this is the case we call the site hidden these are the black circles in Fig A site which is not hidden will be referred to as visible If all weights wi are non negative the Apollonius diagram can be viewed as the Voronoi diagram of the set of circles P1 Pn where ci is the center of the circle Pi and wi its radius If the weights are allowed to be negative we need to go to 3D in order to explain what the Apollonius diagram means geometrically We identify the 2D Euclidean plane with the xy plane in 3D Then the Voronoi diagram of a set of points can be seen as the vertical projection on the xy plane of the lower envelope of a set of 3D cones defined as follows for each point p in the set of 2D points we have a cone Cp whose apex is the point p The axis of Cp is a line parallel to the z axis passing through p the angle of Cp is 45 and finally Cp is facing in the positive z direction that is Cp is contained in the positive z halfspace The Apollonius diagram corresponds to shifting the apexes of these cones in the z direction by a quantity equal to the weight Sites with negative weight will give rise to cones whose apex is in the negative z halfspace and sites with positive weight will give rise to cones whose apex is in the positive z halfspace In a manner analogous to the case of points the Apollonius diagram can then be defined as the vertical projection on the xy plane of the lower envelope of the set of shifted cones Notice that when all apexes are translated along the z direction by the same amount the projection of the lower envelope of the set of cones does not change In particular we can translate all cones by a large enough amount so that all apexes are in the positive z halfspace Algebraically this means that the Apollonius diagram does not change if we add to all weights the same quantity which in particular implies that we can assume without loss of generality that all weights are positive Given the observations above and in order to simplify our discussion of Apollonius diagrams we will from now on assume that all weights are positive and we will refer to the sites as circles The Apollonius diagram is a planar graph and so is its dual the Apollonius graph There are many ways to embed it on the plane and one such way is shown in Fig right The Apollonius graph is uniquely defined once we have the Apollonius diagram If the circles are in general position see precise definition below then the Apollonius graph is a graph with triangular faces away from the convex hull of the set of circles by triangular we mean that every face has exactly three edges Near the convex hull we may have some spikes i e vertices of degree 1 To unify our approach and handling of the Apollonius graph we add to the set of finite circles a fictitious circle at infinity which we call the site at infinity We can then connect all vertices of the outer face of the Apollonius graph to the site at infinity which gives us a graph with the property that all of its faces are now triangular However the Apollonius graph is not a triangulation for two main reasons we cannot always embed it on the plane with straight line segments that yield a triangulation and moreover we may have two faces of the graph that have two edges in common which is not allowed in a triangulation Both of these particularities appear when we consider the Apollonius graph of the set of circles in Fig right We would like to finish our brief introduction to the theory of Apollonius graphs by discussing the concept of general position We say that a set of circles is in general position if no two triplets of circles have the same tritangent circle This statement is rather technical and it is best understood in the context of points The equivalent statement for points is that we have no two triplets of points that define the same circumcircle or equivalently that no four points are co circular The statement about general position made above is a direct generalization of the much simpler to understand statement about points On the contrary when we have circles in degenerate position the Apollonius graph has faces with more than three edges on their boundary We can get a triangulated version of the graph by simply triangulating the corresponding faces in an arbitrary way In fact the algorithm that has been implemented in CGAL has the property that it always returns a valid triangulated version of the Apollonius graph By valid we mean that it contains the actual Apollonius graph i e the actual dual of the Apollonius diagram and whenever there are faces with more than three faces then they are triangulated The way that they are triangulated depends on the order of insertion and deletion of the circles in the diagram One final point has to be made about hidden circles First of all we would like to be more precise about our definition of hidden circles we say that a circle is hidden if its cell has empty interior This definition allows us to guarantee that all visible circles have cells that are two dimensional regions Geometrically the fact that a circle is hidden means that it is contained in the closure of the disk of another circle see again Fig Note that a circle contained in the union of several disks but not in the closure of any one of them is not hidden Hidden circles pose an additional difficulty to our algorithm and software design Since we allow circles to be inserted and deleted at wish it is possible that a circle that was hidden at some point in time may become visible at a later point in time for example this can happen if we delete the circle that hides it For this purpose we store hidden circles and have them reappear when they become visible We will discuss this issue in detail below For the time being it suffices to say that the user has the ability to control this behavior More specifically it is possible to discard the circles that become hidden This choice is totally natural when for example we expect to do only insertions since in this case a circle that becomes hidden will never reappear On the other hand if deletions are expected as well then we lose the ability to have the hidden circles reappear Degenerate dimensions The dimension of the Apollonius graph is in general 2 The exceptions to this rule are as follows The dimension is 1 if the Apollonius graph contains no circles The dimension is if the Apollonius graph contains exactly one visible circle The dimension is 1 is the Apollonius graph contains exactly two visible circles 45 2 Software Design The 2D Apollonius graph class Apollonius graph 2 ApolloniusGraphTraits 2 ApolloniusGraphDataStructure 2 follows the design of the triangulation package of CGAL It is parametrized by two arguments the geometric traits class It provides the basic geometric objects involved in the algorithm such as sites points etc It also provides the geometric predicates for the computation of the Apollonius graph as well as some basic constructions that can be used for example to visualize the Apollonius graph or the Apollonius diagram The geometric traits for the Apollonius graph will be discussed in more detail in the next section the Apollonius graph data structure This is essentially the same as the triangulation data structure discussed in Chapter augmented with some additional operations that are specific to Apollonius graphs The corresponding concept is that of ApolloniusGraphDataStructure 2 which in fact is a refinement of the TriangulationDataStructure 2 concept The class Triangulation data structure 2 Vb Fb is a model of the concept ApolloniusGraphDataStructure 2 A default value for the corresponding template parameter is provided so the user does not need to specify it Storing hidden sites As we have already mentioned a circle is hidden if it is contained inside some visible circle This creates a parent child relationship between visible and hidden circles the parent of a hidden circle is the visible circle that contains it If more than one visible circles contain a hidden circle then the hidden circle can be assigned to any of the visible circles arbitrarily To store hidden circles we assign to every visible circle a list This list comprises the hidden circles that are contained in the visible circle The user can access the hidden circles associated with a visible circle through an iterator called Hidden sites iterator This iterator is defined in the ApolloniusGraphVertexBase 2 concept and is implemented by its model the Apollonius graph vertex base 2 Gt StoreHidden class It is also possible to iterate through the entire set of hidden sites using an homonymous iterator defined by the Apollonius graph 2 Gt Agds class Since storing hidden sites may not be of interest in some cases e g for example this is the case if we only perform insertions in the Apollonius graph the user has the possibility of controllong this behavior More precisely the class Apollonius graph vertex base 2 Gt StoreHidden has two template parameters the second of which is a boolean value This value is by default true and it indicates that hidden sites should be stored The user can indicate that hidden sites may be discarded by setting this value to false 45 3 The Geometric Traits The predicates required for the computation of the Apollonius graph are rather complicated It is not the purpose of this document to discuss them in detail The interested reader may refer to the papers by Karavelas and Emiris for the details KE 2 KE 3 However we would like to give a brief overview of what they compute There are several predicates needed by this algorithm We will discuss the most important complicated ones It turns out that it is much easier to describe them in terms of the Apollonius diagram rather than the Apollonius graph Whenever it is applicable we will also describe their meaning in terms of the Apollonius graph The first two geometric predicates are called Is hidden 2 and Oriented side of bisector 2 The first one involves two circles say P1 and P2 It determines if P1 is hidden with respect to P2 more precisely it checks whether the circle P1 is contained in the closure of the disk defined by the circle P2 As its name indicates it determines if a circle is hidden or not The second predicate involves two circles P1 and P2 and a point q It answers the question whether q is closer to P1 or P2 Its name stems from the fact that answering the afore mentioned question is equivalent to determining the oriented side of the bisector of P1 and P2 that contains the query point q This predicate is used by the algorithm for closest neighbor queries for points The next geometric predicate is called Vertex conflict 2 and it involves four circles P1 P2 P3 and P4 see Fig The first three red circles in Fig define a tritangent circle yellow circle in Fig What we want to determine is the sign of the distance of the green circle from the yellow circle The distance between two circles K1 c1 r1 and K2 c2 r2 is defined as the distance of their centers minus their radii K1 K2 c1 c2 r1 r2 This predicate determines if a vertex in the Apollonius diagram the center of the yellow circle is destroyed when a new circle is inserted in the diagram the green circle In the Apollonius graph it tells us if a triangular face of the diagram is to be destroyed or not Figure The Vertex conflict 2 predicate The left most bottom most and top most circles define the tritangent circle in the middle We want to determine the sign of the distance of the left most circle from the one in the middle The almost horizontal curve is the bisector of the top most and bottom most circles Left the predicate returns CGAL NEGATIVE Right the predicate returns CGAL POSITIVE What we essentially want to compute when we construct incrementally a Voronoi diagram is whether the object to be inserted destroys an edge of the Voronoi diagram or not In the case of points this is really easy and it amounts to the well known incircle test In the case of circles the situation is more complicated We can have six possible outcomes as to what portion of an edge of the Apollonius diagram the new circle destroys see Fig The first two can be answered directly by the Vertex conflict 2 predicate evaluated for the two endpoints of the Apollonius diagram edge This is due to the fact that the value of the Vertex conflict 2 predicate is different for the two endpoints If the two values are the same then we need an additional test which determines if the interior of the Apollonius diagram edge is destroyed by the new circle This is what the Finite edge interior conflict 2 and Infinite edge interior conflict 2 predicates do In essense it is the same predicate same idea applied to two different types of edges in the Apollonius diagram a finite or an infinite edge An edge is infinite if its dual edge in the Apollonius graph connects the site at infinity with the vertex corresponding to a finite circle otherwise it is a finite edge Figure The 6 possible outcomes of the Finite edge interior conflict 2 predicate Top left only a neighborhood around the left most endpoint of the edge will be destroyed Top right only a neighborhood around the right most endpoint of the edge will be destroyed Middle left no portion of the edge is destroyed Middle right the entire edge will be destroyed Bottom left a neighborhood in the interior of the edge will be destroyed the regions near the endpoints remain unaffected Bottom right The neighborhood around the two endpoints will be destroyed but an interval in the interior of the edge will remain in the new diagram The last predicate that we want to discuss is called Is degenerate edge 2 It tells us whether an edge in the Apollonius diagram is degenerate that is if its two endpoints coincide In the Apollonius graph such an edge corresponds to one of the additional edges that we use to triangulate the non triangular faces The afore mentioned predicates are part of the ApolloniusGraphTraits 2 concept of CGAL CGAL also provides a model for this concept the Apollonius graph traits 2 K Method tag class The first template parameter of this class must be a model of the Kernel concept The second template parameter is a tag that indicates what operations are allowed in the computations that take place within the traits class The two possible values of the Method tag parameter are CGAL Ring tag and CGAL Sqrt field tag When CGAL Ring tag is used only ring operations are used during the evaluation of the predicates whereas if CGAL Sqrt field tag is chosen all four field operations as well as square roots are used during the predicate evaluation The Apollonius graph traits 2 K Method tag class provides exact predicates if the number type in the kernel K is an exact number type This is to be associated with the type of operations allowed for the predicate evaluation For example CGAL MP Float as number type with CGAL Ring tag as tag will give exact predicates whereas CGAL MP Float with CGAL Sqrt field tag will give inexact predicates Since using an exact number type may be too slow the Apollonius graph traits 2 K Method tag class is designed to support the dynamic filtering of CGAL through the CGAL Filtered exact CT ET mechanism In particular if CT is an inexact number type that supports the operations denoted by the tag Method tag and ET is an exact number type for these operations then kernel with number type CGAL Filtered exact CT ET will yield exact predicates for the Apollonius graph traits To give a concrete example CGAL Filtered exact double CGAL MP Float with CGAL Ring tag will produce exact predicates Another possibility for fast and exact predicate evalutation is to use the Apollonius graph filtered traits 2 CK CM EK EM FK FM class This class is the analog of a filtered kernel It takes a constructions kernel CK a filtering kernel FK and an exact kernel EK as well as the corresponding tags CM FM and EM respectively It evaluates the predicates by first using the filtering kernel and if this fails the evaluation is performed using the exact kernel The constructions are done using the kernel CK which means that they are not necessarily exact All template parameters except CK have default values which are explained in the reference manual 45 4 The Apollonius graph hierarchy The Apollonius graph hierarchy 2 ApolloniusGraphTraits 2 ApolloniusGraphDataStructure 2 class is nothing but the equivalent of the Triangulation hierarchy 2 class applied to the Apollonius graph It consists of a series of Apollonius graphs constructed in a manner analogous to the Delaunay hierarchy by Devillers Dev98 The class Apollonius graph hierarchy 2 ApolloniusGraphTraits 2 ApolloniusGraphDataStructure 2 has exactly the same interface and functionality as the Apollonius graph 2 ApolloniusGraphTraits 2 ApolloniusGraphDataStructure 2 class Using the Apollonius graph hierarchy involves an additional cost in space and time for maintaining the hierarchy Our experiments have shown that it usually pays off to use the hierarchy for inputs consisting of more than 1 circles This threshold holds for both the construction of the Apollonius diagram itself as well as for nearest neighbor queries 45 5 Examples 45 5 1 First example file examples Apollonius graph 2 example1 C include CGAL basic h standard includes include iostream include fstream include cassert the number type include CGAL MP Float h include CGAL Filtered exact h example that uses the Filtered exact number type typedef CGAL Filtered exact double CGAL MP Float NT choose the kernel include CGAL Simple cartesian h typedef CGAL Simple cartesian NT Kernel typedefs for the traits and the algorithm include CGAL Apollonius graph 2 h include CGAL Apollonius graph traits 2 h typedef CGAL Apollonius graph traits 2 Kernel Traits typedef CGAL Apollonius graph 2 Traits Apollonius graph int main std ifstream ifs data sites cin assert ifs Apollonius graph ag Apollonius graph Site 2 site read the sites and insert them in the Apollonius graph while ifs site ag insert site validate the Apollonius graph assert ag is valid true 1 std cout std endl return 45 5 2 Second example file examples Apollonius graph 2 example2 C include CGAL basic h standard includes include iostream include fstream include cassert if defined CGAL USE LEDA include CGAL leda real h elif defined CGAL USE CORE include CGAL CORE Expr h endif if defined CGAL USE LEDA defined CGAL USE CORE include CGAL Filtered exact h endif if defined CGAL USE LEDA If LEDA is present use leda real as the exact number type for Filtered exact typedef CGAL Filtered exact double leda real NT elif defined CGAL USE CORE Othwrwise if CORE is present use CORE s Expr as the exact number type for Filtered exact typedef CGAL Filtered exact double CORE Expr NT else Otherwise just use double This may cause numerical errors but it is still worth doing it to show how to define correctly the traits class typedef double NT endif include CGAL Simple cartesian h typedef CGAL Simple cartesian NT Kernel typedefs for the traits and the algorithm include CGAL Apollonius graph 2 h include CGAL Apollonius graph traits 2 h the traits class is now going to assume that the operations and sqrt are supported exactly typedef CGAL Apollonius graph traits 2 Kernel CGAL Sqrt field tag Traits typedef CGAL Apollonius graph 2 Traits Apollonius graph int main std ifstream ifs data sites cin assert ifs Apollonius graph ag Apollonius graph Site 2 site read the sites and insert them in the Apollonius graph while ifs site ag insert site validate the Apollonius graph assert ag is valid true 1 std cout std endl return 45 5 3 Third example file examples Apollonius graph 2 example3 C include CGAL basic h standard includes include iostream include fstream include cassert include CGAL basic h example that uses the filtered traits choose the representation include CGAL Simple cartesian h typedef CGAL Simple cartesian double Rep include CGAL Apollonius graph 2 h include CGAL Triangulation data structure 2 h include CGAL Apollonius graph vertex base 2 h include CGAL Triangulation face base 2 h include CGAL Apollonius graph filtered traits 2 h typedef for the traits the filtered traits class is used typedef CGAL Apollonius graph filtered traits 2 Rep Traits typedefs for the algorithm With the second template argument in the vertex base class being false we indicate that there is no need to store the hidden sites One case where this is indeed not needed is when we only do insertions like in the main program below typedef CGAL Apollonius graph vertex base 2 Traits false Vb typedef CGAL Triangulation face base 2 Traits Fb typedef CGAL Triangulation data structure 2 Vb Fb Agds typedef CGAL Apollonius graph 2 Traits Agds Apollonius graph int main std ifstream ifs data sites cin assert ifs Apollonius graph ag Apollonius graph Site 2 site read the sites and insert them in the Apollonius graph while ifs site ag insert site validate the Apollonius graph assert ag is valid true 1 std cout std endl now remove all sites std cout Removing all sites std flush while ag number of vertices ag remove ag finite vertex std cout done std endl std endl return 45 5 4 Fourth example file examples Apollonius graph 2 example4 C include CGAL basic h standard includes include iostream include fstream include cassert example that uses the filtered traits include CGAL MP Float h include CGAL Simple cartesian h constructions kernel inexact typedef CGAL Simple cartesian double CK exact kernel typedef CGAL Simple cartesian CGAL MP Float EK typedefs for the traits and the algorithm include CGAL Apollonius graph hierarchy 2 h include CGAL Apollonius graph filtered traits 2 h Type definition for the traits class In this example we explicitly define the exact kernel We also explicitly define what operations to use for the evaluation of the predicates and constructions when the filtering and the exact kernels are used respectively Note that the operations allowed for the filtering and the constructions field operations plus square roots are different from the operations allowed when the exact kernel is used ring operations typedef CGAL Sqrt field tag CM typedef CGAL Ring tag EM typedef CGAL Apollonius graph filtered traits 2 CK CM EK EM Traits Now we use the Apollonius graph hierarchy The hierarchy is faster for inputs consisting of about more than 1 sites typedef CGAL Apollonius graph hierarchy 2 Traits Apollonius graph int main std ifstream ifs data hierarchy cin assert ifs Apollonius graph ag Apollonius graph Site 2 site read the sites and insert them in the Apollonius graph while ifs site ag insert site validate the Apollonius graph assert ag is valid true 1 return Next chapter 2D Apollonius graphs Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Apollonius_graph_2/Chapter_main.html", "title": "2d apollonius graphs", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Apollonius_graph_2/main.tex' -->\n<html> <head>  \n<title>2D Apollonius graphs</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_45\"></a>\n  \n<h1>Chapter 45<BR>2D Apollonius graphs</h1>\n\n<A NAME=\"chapter-apollonius2\"></A>\n<EM>Menelaos Karavelas  and Mariette Yvinec</EM><BR>\n\n\n<P>\n\nThis chapter describes the two-dimensional Apollonius graph\nof C<SMALL>GAL</SMALL>. We start with a few definitions in \nSection&nbsp;<A HREF=\"Chapter_main.html#sec:apollonius2-definitions\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nThe software design of the 2D Apollonius graph package is described \nin Section&nbsp;<A HREF=\"Chapter_main.html#sec:apollonius2-design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nIn Section&nbsp;<A HREF=\"Chapter_main.html#sec:apollonius2-traits\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> we discuss the geometric\ntraits of the 2D Apollonius graph package and in Section\n<A HREF=\"Chapter_main.html#sec:apollonius2-hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> the Apollonius graph hierarchy, a data\nstructure suitable for fast nearest neighbor queries, is briefly\ndescribed.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>45.1&nbsp;&nbsp;&nbsp;Definitions</h2>\n\n<A NAME=\"sec:apollonius2-definitions\"></A>\n<P>\n\n<center>\n  <img border=1 src=\"./apollonius_diagram.gif\" align=center\n  alt=\"The Apollonius diagram\" title=\"The Apollonius diagram\">\n  <!-- -->\n  <img border=1 src=\"./apollonius_graph.gif\" align=center\n  alt=\"The Apollonius graph (dual of the Apollonius diagram)\"\n  title=\"The Apollonius graph (dual of the Apollonius diagram)\">\n</center>\n\n\n<font size=-1>\n\n<CENTER>\n<B>Figure:&nbsp;&nbsp;</B>The Apollonius diagram (left) and its dual the Apollonius\n  graph (right).<A NAME=\"fig-apollonius\"></A>\n</CENTER>\n\n</font>\n<P>\n\nThe 2D Apollonius graph class of C<SMALL>GAL</SMALL> is designed to compute the\ndual of the <I>Apollonius diagram</I> or, as it is also known, the\n<I>Additively weighted Voronoi diagram</I>. The algorithm that has been\nimplemented is dynamic, which means that we can perform insertions and\ndeletions on line. The corresponding C<SMALL>GAL</SMALL> class is called\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>&lt;<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphTraits_2.html#Cross_link_anchor_1075\">ApolloniusGraphTraits_2</A>,<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A>&gt;</I>\nand will be discussed in more detail in the sequel. The interested\nreader may want to refer to the paper by Karavelas and Yvinec\n[<A HREF=\"../biblio.html#Biblio_cgal:ky-dawvd-02\">KY02</A>] for the general idea as well as the details of the\nalgorithm implemented.\n<P>\n\nBefore describing the details of the implementation we make a brief\nintroduction to the theory of Apollonius diagrams.\nThe Apollonius diagram is defined over a set of sites\n<MATH><I>P<SUB>i</SUB>=(c<SUB>i</SUB>,w<SUB>i</SUB>)</I></MATH>, <MATH><I>i=1,...,n</I></MATH>, where <MATH><I>c<SUB>i</SUB></I></MATH> is the point and <MATH><I>w<SUB>i</SUB></I></MATH>\nthe weight of <MATH><I>P<SUB>i</SUB></I></MATH>. It is a subdivision of the plane into connected\nregions, called <I>cells</I>, associated with the sites (see\nFig. <A HREF=\"Chapter_main.html#fig-apollonius\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>(left)). The cell of a \nsite <MATH><I>P<SUB>i</SUB></I></MATH> is the locus of points on the plane that are\ncloser to <MATH><I>P<SUB>i</SUB></I></MATH> than any other site <MATH><I>P<SUB>j</SUB></I></MATH>, <MATH><I>j <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> i</I></MATH>.\nThe distance <MATH><I><IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\">(x, P<SUB>i</SUB>)</I></MATH> of a point <MATH><I>x</I></MATH> in the plane to a\nsite <MATH><I>P<SUB>i</SUB></I></MATH> is defined as: \n<P ALIGN=CENTER>\n<MATH><I>      <IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\">(x,P<SUB>i</SUB>)= <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> x-c<SUB>i</SUB> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> -w<SUB>i</SUB>,</I></MATH>\n<P>\n\nwhere <MATH><I> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\">  &middot;  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> </I></MATH> denotes the Euclidean norm.\nIt can easily be seen that it is a generalization of the Voronoi\ndiagram for points, which can actually be obtained if all the weights\n<MATH><I>w<SUB>i</SUB></I></MATH> are equal. Unlike the case of points, however, it is\npossible that a site <MATH><I>P<SUB>i</SUB></I></MATH> might have an empty cell. This\ncan also happen in the case of the power diagram, whose dual is the\nregular triangulation (see Section\n<A HREF=\"../Triangulation_2/Chapter_main.html#Section_2D_Triangulations_Regular\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). If this is\nthe case we call the site <I>hidden</I> (these are the black\ncircles in Fig. <A HREF=\"Chapter_main.html#fig-apollonius\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). A site which is not\nhidden will be referred to as <I>visible</I>.\n<P>\n\nIf all weights <MATH><I>w<SUB>i</SUB></I></MATH> are non-negative, the Apollonius\ndiagram can be viewed as the Voronoi diagram of the set of circles\n<MATH><I>{P<SUB>1</SUB>,..., P<SUB>n</SUB>}</I></MATH>, where <MATH><I>c<SUB>i</SUB></I></MATH> is the center of the circle <MATH><I>P<SUB>i</SUB></I></MATH>\nand <MATH><I>w<SUB>i</SUB></I></MATH> its radius. If the weights are allowed to be negative,\nwe need to go to 3D in order to explain what the Apollonius diagram\nmeans geometrically. We identify the 2D Euclidean plane with the\n<MATH><I>xy</I></MATH>-plane in 3D. Then the Voronoi diagram of a set of points can be\nseen as the vertical projection on the <MATH><I>xy</I></MATH>-plane of the lower\nenvelope of a set of 3D cones defined as follows: for each point <MATH><I>p</I></MATH>\nin the set of 2D points we have a cone <MATH><I>C<SUB>p</SUB></I></MATH> whose apex is the point\n<MATH><I>p</I></MATH>. The axis of \n<MATH><I>C<SUB>p</SUB></I></MATH> is a line <A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A> to the <MATH><I>z</I></MATH>-axis passing through <MATH><I>p</I></MATH>, the\n<A HREF=\"../Kernel_23_ref/Function_angle.html#Cross_link_anchor_153\">angle</A> of <MATH><I>C<SUB>p</SUB></I></MATH> is <MATH><I>45<SUP> <IMG BORDER=0 WIDTH=6 HEIGHT=7 ALIGN=BOTTOM SRC=\"cc_circ.gif\"> </SUP></I></MATH> and, finally <MATH><I>C<SUB>p</SUB></I></MATH> is facing in the\npositive <MATH><I>z</I></MATH>-direction (that is, <MATH><I>C<SUB>p</SUB></I></MATH> is contained in the positive\n<MATH><I>z</I></MATH>-halfspace).\nThe Apollonius diagram corresponds to shifting the\napexes of these cones in the <MATH><I>z</I></MATH>-direction by a quantity equal to the\nweight. Sites with negative weight will give rise to\ncones whose apex is in the negative <MATH><I>z</I></MATH>-halfspace and sites\nwith positive weight will give rise to cones whose apex is in the\npositive <MATH><I>z</I></MATH>-halfspace. In a manner analogous to the case of points,\nthe Apollonius diagram can then be defined as the vertical projection\non the <MATH><I>xy</I></MATH>-plane of the lower envelope of the set of shifted cones.\nNotice that when all apexes are translated along the <MATH><I>z</I></MATH>-direction by\nthe same amount, the projection of the lower envelope of the set of\ncones does not change. In particular, we can translate all cones by a\nlarge enough amount so that all apexes are in the positive\n<MATH><I>z</I></MATH>-halfspace. Algebraically, this means that the Apollonius diagram\ndoes not change if we add to all weights the same quantity, which in\nparticular, implies that we can assume without loss of generality that\nall weights are positive. Given the observations above and in order to\nsimplify our discussion of Apollonius diagrams, we will, from now on,\nassume that all weights are positive, and we will refer to the\nsites as circles.\n<P>\n\nThe Apollonius diagram is a planar graph, and so is its dual, the\nApollonius graph. There are many ways to embed it on the plane and one\nsuch way is shown in Fig. <A HREF=\"Chapter_main.html#fig-apollonius\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>(right).\nThe Apollonius graph is uniquely defined once we have\nthe Apollonius diagram. If the circles are in <I>general position</I>\n(see precise definition below), then the Apollonius graph is a graph\nwith triangular faces away from \nthe convex hull of the set of circles (by triangular we mean that\nevery face has exactly three edges). Near the convex hull we may\nhave some spikes (i.e., vertices of degree 1). To unify our approach\nand handling of the Apollonius graph we add to the set of (finite)\ncircles a fictitious circle at infinity, which we call the\n<I>site at infinity</I>. We can then connect all vertices of the outer\nface of the Apollonius graph to the site at infinity which gives us\na graph with the property that all of its faces are now\ntriangular. However, the Apollonius graph is not a triangulation for\ntwo main reasons: we cannot always embed it on the plane with straight\nline segments that yield a triangulation and, moreover, we may have two\nfaces of the graph that have two edges in common, which is not allowed\nin a triangulation. Both of these particularities appear when we\nconsider the Apollonius graph of the set of circles in\nFig. <A HREF=\"Chapter_main.html#fig-apollonius\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>(right).\n<P>\n\nWe would like to finish our brief introduction to the theory of\nApollonius graphs by discussing the concept of general position. We say\nthat a set of circles is in general position if no two triplets of\ncircles have the same tritangent circle. This statement is rather\ntechnical and it is best understood in the context of points. The\nequivalent statement for points is that we have no two triplets of\npoints that define the same circumcircle, or equivalently that no\nfour points are co-circular. The statement about general position made\nabove is a direct generalization of the (much simpler to understand)\nstatement about points. On the contrary, when we have circles in\ndegenerate position, the Apollonius graph has faces with more than\nthree edges on their boundary. We can get a triangulated version of\nthe graph by simply <I>triangulating</I> the corresponding faces in an\narbitrary way. In fact the algorithm that has been implemented in\nC<SMALL>GAL</SMALL> has the property that it always returns a valid\n<I>triangulated</I> version of the Apollonius graph. By valid we mean\nthat it contains the actual Apollonius graph (i.e., the actual dual of\nthe Apollonius diagram) and whenever there are faces with more than\nthree faces then they are triangulated. The way that they are\ntriangulated depends on the order of insertion and deletion of the\ncircles in the diagram.\n<P>\n\nOne final point has to be made about hidden circles. First of all we\nwould like to be more precise about our definition of hidden circles:\nwe say that a circle is hidden if its cell has empty interior. This\ndefinition allows us to guarantee that all visible circles have\ncells that are two-dimensional regions.\nGeometrically the fact that a circle is hidden means that it is\ncontained in the closure of the disk of another circle (see again\nFig. <A HREF=\"Chapter_main.html#fig-apollonius\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). Note that a circle contained in the union\nof several disks, but not in the closure of any one of them, is not\nhidden.\n<P>\n\nHidden circles pose an additional\ndifficulty to our algorithm and software design. Since we allow\ncircles to be inserted and deleted at wish, it is possible that a\ncircle that was hidden at some point in time, may become visible at\na later point in time; for example this can happen if we delete the\ncircle that hides it. For this purpose we store hidden circles and\nhave them reappear when they become visible. We will discuss this\nissue in detail below. For the time being it suffices to say that the\nuser has the ability to control this behavior. More specifically it is\npossible to discard the circles that become hidden. This choice is\ntotally natural when for example we expect to do only insertions,\nsince in this case a circle that becomes hidden will never\nreappear. On the other hand if deletions are expected as well, then we\nlose the ability to have the hidden circles reappear.\n<P>\n\n<b>Degenerate dimensions.</b>\n\nThe dimension of the Apollonius graph is in general 2. The exceptions\nto this rule are as follows:\n<UL>\n<LI>The dimension is <MATH><I>-1</I></MATH> if the Apollonius graph contains no circles.\n<LI>The dimension is <MATH><I>0</I></MATH> if the Apollonius graph contains exactly\n  one visible circle.\n<LI>The dimension is <MATH><I>1</I></MATH> is the Apollonius graph contains exactly\n  two visible circles.\n</UL>\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>45.2&nbsp;&nbsp;&nbsp;Software Design</h2>\n\n<A NAME=\"sec:apollonius2-design\"></A>\n<P>\n\nThe 2D Apollonius graph class\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>&lt;<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphTraits_2.html#Cross_link_anchor_1075\">ApolloniusGraphTraits_2</A>,<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A>&gt;</I>\nfollows the design of the triangulation package of C<SMALL>GAL</SMALL>. It is\nparametrized by two arguments:\n<UL>\n<LI>the <B>geometric traits</B> class. It provides the basic\n  geometric objects involved in the algorithm, such as sites, points\n  etc. It also provides the geometric predicates for the computation\n  of the Apollonius graph, as well as some basic constructions that\n  can be used, for example, to visualize the Apollonius graph or the\n  Apollonius diagram. The geometric traits for the Apollonius graph\n  will be discussed in more detail in the next section.\n<LI>the <B>Apollonius graph data structure</B>. This is essentially\n  the same as the triangulation data structure (discussed in Chapter\n  <A HREF=\"../TDS_2/Chapter_main.html#Chapter_2D_Triangulation_Data_Structure\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>), augmented with some\n  additional operations that are specific to Apollonius graphs. The\n  corresponding concept is that of\n  <I><A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A></I>, which in fact is a refinement\n  of the <I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I> concept. The class\n  <I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_966\">Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I> is a model of\n  the concept <I><A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A></I>. A default value\n  for the corresponding template parameter is provided, so the user\n  does not need to specify it.\n</UL>\n<P>\n\n<b>Storing hidden sites.</b>\n\nAs we have already mentioned a circle is hidden if it is contained\ninside some visible circle. This creates a parent-child relationship\nbetween visible and hidden circles: the parent of a hidden circle is the\nvisible circle that contains it. If more than one visible circles\ncontain a hidden circle then the hidden circle can be assigned to any of\nthe visible circles arbitrarily.\n<P>\n\nTo store hidden circles we <A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90\">assign</A> to every visible circle a list. This\nlist comprises the hidden circles that are contained in the\nvisible circle. The user can access the hidden circles associated with\na visible circle through an iterator called\n<I>Hidden_sites_iterator</I>. This iterator is defined in the\n<I><A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphVertexBase_2.html#Cross_link_anchor_1072\">ApolloniusGraphVertexBase_2</A></I> concept and is implemented by its\nmodel, the <I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_vertex_base_2.html#Cross_link_anchor_1074\">Apollonius_graph_vertex_base_2</A>&lt;Gt,StoreHidden&gt;</I>\nclass. It is also possible to iterate through the entire set of hidden\nsites using an homonymous iterator defined by the\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>&lt;Gt,Agds&gt;</I> class.\n<P>\n\nSince storing hidden sites may not be of interest in some cases (e.g.,\nfor example this is the case if we only perform insertions in the\nApollonius graph), the user has the possibility of controllong this\nbehavior. More precisely, the class\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_vertex_base_2.html#Cross_link_anchor_1074\">Apollonius_graph_vertex_base_2</A>&lt;Gt,StoreHidden&gt;</I> has two template\nparameters, the second of which is a boolean value. This value is by\ndefault <I>true</I> and it indicates that hidden sites should be\nstored. The user can indicate that hidden sites may be discarded\nby setting this value to <I>false</I>.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>45.3&nbsp;&nbsp;&nbsp;The Geometric Traits</h2>\n\n<A NAME=\"sec:apollonius2-traits\"></A>\n<P>\n\nThe predicates required for the computation of the Apollonius graph\nare rather complicated. It is not the purpose of this document to\ndiscuss them in detail. The interested reader may refer to the papers\nby Karavelas and Emiris for the details\n[<A HREF=\"../biblio.html#Biblio_cgal:ke-ppawv-02\">KE02</A>, <A HREF=\"../biblio.html#Biblio_cgal:ke-rctac-03\">KE03</A>]. However, we would like to give a brief\noverview of what they \ncompute. There are several predicates needed by this algorithm. We\nwill discuss the most important/complicated ones. It turns out that\nit is much easier to describe them in terms of the Apollonius diagram,\nrather than the Apollonius graph. Whenever it is applicable we will also\ndescribe their meaning in terms of the Apollonius graph.\n<P>\n\nThe first two geometric predicates are called\n<I>Is_hidden_2</I> and <I>Oriented_side_of_bisector_2</I>. The first one\ninvolves two circles, say <MATH><I>P<SUB>1</SUB></I></MATH> and <MATH><I>P<SUB>2</SUB></I></MATH>. It determines if <MATH><I>P<SUB>1</SUB></I></MATH> is\nhidden with respect to <MATH><I>P<SUB>2</SUB></I></MATH>; more precisely it checks whether the\ncircle <MATH><I>P<SUB>1</SUB></I></MATH> is contained in the closure of the disk defined by the\ncircle <MATH><I>P<SUB>2</SUB></I></MATH>. As its name indicates, it determines if a circle is\nhidden or not. The second predicate involves two circles <MATH><I>P<SUB>1</SUB></I></MATH> and\n<MATH><I>P<SUB>2</SUB></I></MATH> and a point <MATH><I>q</I></MATH>. It answers the question whether <MATH><I>q</I></MATH> is closer\nto <MATH><I>P<SUB>1</SUB></I></MATH> or <MATH><I>P<SUB>2</SUB></I></MATH>. Its name stems from the fact that answering the\nafore-mentioned question is equivalent to determining the oriented\nside of the <A HREF=\"../Kernel_23_ref/Function_bisector.html#Cross_link_anchor_161\">bisector</A> of <MATH><I>P<SUB>1</SUB></I></MATH> and <MATH><I>P<SUB>2</SUB></I></MATH> that contains the query point\n<MATH><I>q</I></MATH>. This predicate is used by the algorithm for closest neighbor\nqueries for points.\n<P>\n\nThe next geometric predicate is called <I>Vertex_conflict_2</I> and it\ninvolves four circles <MATH><I>P<SUB>1</SUB></I></MATH>, <MATH><I>P<SUB>2</SUB></I></MATH>, <MATH><I>P<SUB>3</SUB></I></MATH>, and <MATH><I>P<SUB>4</SUB></I></MATH> (see\nFig. <A HREF=\"Chapter_main.html#figag2vc\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). The first three (red circles in\nFig. <A HREF=\"Chapter_main.html#figag2vc\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>) define a tritangent circle (yellow\ncircle in Fig. <A HREF=\"Chapter_main.html#figag2vc\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). What we want to determine is\nthe <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of the distance of the green circle from the yellow\ncircle. The distance between two circles <MATH><I>K<SUB>1</SUB>=(c<SUB>1</SUB>,r<SUB>1</SUB>)</I></MATH> and\n<MATH><I>K<SUB>2</SUB>=(c<SUB>2</SUB>, r<SUB>2</SUB>)</I></MATH> is defined as the distance of their centers minus\ntheir radii:\n<P ALIGN=CENTER>\n<MATH><I>   <IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\">(K<SUB>1</SUB>, K<SUB>2</SUB>) =  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> c<SUB>1</SUB>-c<SUB>2</SUB> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> -r<SUB>1</SUB>-r<SUB>2</SUB>. </I></MATH>\n<P>\n\nThis predicate determines if a vertex in the Apollonius diagram\n(the center of the yellow circle) is destroyed when a new circle is\ninserted in the diagram (the green circle). In the Apollonius graph\nit tells us if a triangular face of the diagram is to be destroyed or\nnot.\n<P>\n\n<A NAME=\"figag2vc\"></A>\n\n\n  <center>\n  <img border=1 src=\"./apollonius-vertex_conflict-false.gif\" align=center\n  alt=\"The Vertex_conflict_2 predicate returns NEGATIVE\"\n  title=\"The Vertex_conflict_2 predicate returns NEGATIVE\">\n  <!-- -->\n  <img border=1 src=\"./apollonius-vertex_conflict-true.gif\" align=center\n  alt=\"The Vertex_conflict_2 predicate returns POSITIVE\"\n  title=\"The Vertex_conflict_2 predicate returns POSITIVE\">\n  </center>\n\n\n<font size=-1>\n\n<B>Figure:&nbsp;&nbsp;</B>\n    The <I>Vertex_conflict_2</I> predicate. The left-most, bottom-most\n    and top-most circles define the tritangent circle in the middle.\n    We want to determine the <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of the distance of the left-most\n    circle from the one in the middle. The almost horizontal curve is\n    the <A HREF=\"../Kernel_23_ref/Function_bisector.html#Cross_link_anchor_161\">bisector</A> of the top-most and bottom-most circles. Left: the\n    predicate returns <I>CGAL::<A HREF=\"../Kernel_23_ref/Enum_Sign#Enum_Sign\">NEGATIVE</A></I>. Right: the predicate\n    returns <I>CGAL::<A HREF=\"../Kernel_23_ref/Enum_Sign#Enum_Sign\">POSITIVE</A></I>.\n\n</font>\n<P>\n\nWhat we essentially want to compute when we construct incrementally a\nVoronoi diagram, is whether the object to be inserted destroys an edge\nof the Voronoi diagram or not. In the case of points this is really\neasy and it amounts to the well known <I>incircle</I> test. \nIn the case\nof circles the situation is more complicated. We can have six possible\noutcomes as to what portion of an edge of the Apollonius diagram the\nnew circle destroys (see Fig. <A HREF=\"Chapter_main.html#fig-ag2edgeconflict\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). The first\ntwo can be answered directly by the <I>Vertex_conflict_2</I> predicate\nevaluated for the two endpoints of the Apollonius diagram edge. This\nis due to the fact that the value of the <I>Vertex_conflict_2</I>\npredicate is different for the two endpoints. If the two values are\nthe same then we need an additional test which determines if the interior\nof the Apollonius diagram edge is destroyed by the new circle. This is\nwhat the <I>Finite_edge_interior_conflict_2</I> and\n<I>Infinite_edge_interior_conflict_2</I> predicates do. In essense, it\nis the same predicate (same idea) applied to two different types of\nedges in the Apollonius diagram: a finite or an infinite edge. An edge\nis infinite if its dual edge in the Apollonius graph connects the\nsite at infinity with the vertex corresponding to a (finite) circle; \notherwise it is a finite edge.\n<P>\n\n<center>\n  <img border=1 src=\"./apollonius-left_vertex.gif\" align=center\n  alt=\"In conflict with a neighborhood of the left-most vertex of the\n  Apollonius edge\"\n  title=\"In conflict with a neighborhood of the left-most vertex of the Apollonius edge\">\n  <!-- -->\n  <img border=1 src=\"./apollonius-right_vertex.gif\" align=center\n  alt=\"In conflict with a neighborhoof of the right-most vertex of the\n  Apollonius edge\"\n  title=\"In conflict with a neighborhoof of the right-most vertex of the Apollonius edge\"><BR>\n\n<BR>\n\n<!-- -->\n  <img border=1 src=\"./apollonius-no_conflict.gif\" align=center\n  alt=\"No conflict\" title=\"No conflict\">\n  <!-- -->\n  <img border=1 src=\"./apollonius-entire_edge.gif\" align=center\n  alt=\"In conflict with the entire Apollonius edge\"\n  title=\"In conflict with the entire Apollonius edge\"><BR>\n\n<BR>\n\n<!-- -->\n  <img border=1 src=\"./apollonius-interior.gif\" align=center\n  alt=\"In conflict with a portion of the interior of the Apollonius\n  edge\"\n  title=\"In conflict with a portion of the interior of the Apollonius edge\">\n  <!-- -->\n  <img border=1 src=\"./apollonius-both_vertices.gif\" align=center\n  alt=\"In conflict with (disjoint) neighborhoods of the vertices of\n  the Apollonius edge\"\n  title=\"In conflict with (disjoint) neighborhoods of the vertices of the Apollonius edge\">\n</center>\n\n\n<font size=-1>\n\n<B>Figure:&nbsp;&nbsp;</B>The 6 possible outcomes of the\n  <I>Finite_edge_interior_conflict_2</I> predicate.\nTop left: only a neighborhood around\n  the left-most endpoint of the edge will be destroyed. Top right:\n  only a neighborhood around the right-most endpoint of the edge will\n  be destroyed. Middle left: no portion of the edge is destroyed.\n  Middle right: the entire edge will be destroyed. Bottom left: a\n  neighborhood in the interior of the edge\n  will be destroyed; the regions near the endpoints remain\n  unaffected. Bottom right: The neighborhood around the two endpoints\n  will be destroyed, but an interval in the interior of the edge will\n  remain in the new diagram.<A NAME=\"fig-ag2edgeconflict\"></A>\n\n</font>\n<P>\n\nThe last predicate that we want to discuss is called\n<I>Is_degenerate_edge_2</I>. It tells us whether an edge in the\nApollonius diagram is degenerate, that is if its two endpoints\ncoincide. In the Apollonius graph such an edge corresponds to one of\nthe additional edges that we use to triangulate the non-triangular\nfaces.\n<P>\n\nThe afore mentioned predicates are part of the\n<I><A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphTraits_2.html#Cross_link_anchor_1075\">ApolloniusGraphTraits_2</A></I> concept of C<SMALL>GAL</SMALL>. C<SMALL>GAL</SMALL> also provides\na model for this concept, the\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1077\">Apollonius_graph_traits_2</A>&lt;K,Method_tag&gt;</I> class. The first\ntemplate parameter of this class must be a model of the <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A></I>\nconcept. The second template parameter is a tag that indicates what\noperations are allowed in the computations that take place within the\ntraits class.\nThe two possible values of the <I>Method_tag</I> parameter are\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A></I> and <I><A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A></I>. When\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A></I> is used, only ring operations are used during the\nevaluation of the predicates, whereas if <I><A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A></I> is\nchosen, all four field operations, as well as <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> roots, are used\nduring the predicate evaluation.\n<P>\n\nThe <I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1077\">Apollonius_graph_traits_2</A>&lt;K,Method_tag&gt;</I> class provides exact\npredicates if the number type in the kernel <I>K</I> is an exact number\ntype. This is to be associated with the type of operations allowed for\nthe predicate evaluation. For example <I><A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A></I> as number\ntype, with <I><A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A></I> as tag will give exact predicates,\nwhereas <I><A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A></I> with <I><A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A></I> will give\ninexact predicates.\n<P>\n\nSince using an exact number type may be too slow, the\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1077\">Apollonius_graph_traits_2</A>&lt;K,Method_tag&gt;</I> class is designed to\nsupport the dynamic filtering of C<SMALL>GAL</SMALL> through the\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;CT,ET&gt;</I> mechanism. In particular if <I>CT</I>\nis an inexact number type that supports the operations denoted by the\ntag <I>Method_tag</I> and <I>ET</I> is an exact number type for these\noperations, then kernel with number type\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;CT,ET&gt;</I> will yield exact predicates for the\nApollonius graph traits. To give a concrete example,\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;double,<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;</I> with \n<I><A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A></I> will produce exact predicates.\n<P>\n\nAnother possibility for fast and exact predicate evalutation is to use\nthe\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_filtered_traits_2.html#Cross_link_anchor_1079\">Apollonius_graph_filtered_traits_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I>\nclass. This class is the analog of a filtered kernel. It takes a\nconstructions kernel <I>CK</I>, a filtering kernel <I>FK</I> and an\nexact kernel <I>EK</I>, as well as the corresponding tags\n(<I>CM</I>, <I>FM</I> and <I>EM</I>, respectively).\nIt evaluates the predicates by first using the filtering kernel, and\nif this fails the evaluation is performed using the exact kernel. The\nconstructions are done using the kernel <I>CK</I>, which means that\nthey are not necessarily exact. All template parameters except\n<I>CK</I> have default values, which are explained in the reference\nmanual.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>45.4&nbsp;&nbsp;&nbsp;The Apollonius graph hierarchy</h2>\n\n<A NAME=\"sec:apollonius2-hierarchy\"></A>\n<P>\n\nThe <I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_hierarchy_2.html#Cross_link_anchor_1081\">Apollonius_graph_hierarchy_2</A>&lt;<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphTraits_2.html#Cross_link_anchor_1075\">ApolloniusGraphTraits_2</A>,<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A>&gt;</I> class is nothing but the equivalent of the <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A></I>\nclass, applied to the Apollonius graph. It consists of a series of\nApollonius graphs constructed in a manner analogous to the Delaunay\nhierarchy by Devillers [<A HREF=\"../biblio.html#Biblio_d-iirdt-98\">Dev98</A>]. The class\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_hierarchy_2.html#Cross_link_anchor_1081\">Apollonius_graph_hierarchy_2</A>&lt;<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphTraits_2.html#Cross_link_anchor_1075\">ApolloniusGraphTraits_2</A>,<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A>&gt;</I>\nhas exactly the same interface and functionality as the\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>&lt;<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphTraits_2.html#Cross_link_anchor_1075\">ApolloniusGraphTraits_2</A>,<A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A>&gt;</I>\nclass. Using the Apollonius graph hierarchy involves an additional\ncost in space and time for maintaining the hierarchy. Our experiments\nhave shown that it usually pays off to use the hierarchy for inputs\nconsisting of more than 1,000 circles. This threshold holds for both\nthe construction of the Apollonius diagram itself, as well as for\nnearest neighbor queries.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>45.5&nbsp;&nbsp;&nbsp;Examples</h2>\n\n<A NAME=\"sec:apollonius2-examples\"></A>\n<P>\n\n<h3>45.5.1&nbsp;&nbsp;&nbsp;First example</h3>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>/example1.C\n\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\n// the number type\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>.h&gt;\n\n\n// example that uses the <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A> number type\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;double,<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt; NT;\n\n// choose the kernel\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;NT&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\n\n// typedefs for the traits and the algorithm\n\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1077\">Apollonius_graph_traits_2</A>.h&gt;\n\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1076\">CGAL::Apollonius_graph_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;   Traits;\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1066\">CGAL::Apollonius_graph_2</A>&lt;Traits&gt;          Apollonius_graph;\n\n\n\nint main()\n{\n  std::ifstream ifs(&quot;data/sites.cin&quot;);\n  assert( ifs );\n\n  Apollonius_graph ag;\n  Apollonius_graph::Site_2 site;\n\n  // read the sites and insert them in the Apollonius graph\n  while ( ifs &gt;&gt; site ) {\n    ag.insert(site);\n  }\n\n  // validate the Apollonius graph\n  assert( ag.is_valid(true, 1) );\n  std::cout &lt;&lt; std::endl;\n\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>45.5.2&nbsp;&nbsp;&nbsp;Second example</h3>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>/example2.C\n\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\n\n#if defined CGAL_USE_LEDA\n#  include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A>.h&gt;\n#elif defined CGAL_USE_CORE\n#  include &lt;CGAL/CORE_Expr.h&gt;\n#endif\n\n#if defined CGAL_USE_LEDA || defined CGAL_USE_CORE\n#  include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>.h&gt;\n#endif\n\n\n#if defined CGAL_USE_LEDA\n// If LEDA is present use <A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A> as the exact number type for\n// <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;double,<A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A>&gt; NT;\n\n#elif defined CGAL_USE_CORE\n// Othwrwise if CORE is present use CORE's Expr as the exact number\n// type for <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;double,<A HREF=\"../NumberTypeSupport_ref/Class_CORE--Expr.html#Cross_link_anchor_1342\">CORE::Expr</A>&gt; NT;\n\n#else\n\n// Otherwise just use double. This may cause numerical errors but it\n// is still worth doing it to show how to define correctly the traits\n// class\ntypedef double NT;\n\n#endif\n\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;NT&gt;  <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\n\n\n// typedefs for the traits and the algorithm\n\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1077\">Apollonius_graph_traits_2</A>.h&gt;\n\n// the traits class is now going to assume that the operations\n// +,-,*,/ and <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A> are supported exactly\ntypedef\n<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_traits_2.html#Cross_link_anchor_1076\">CGAL::Apollonius_graph_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>,<A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A>&gt; Traits;\n\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1066\">CGAL::Apollonius_graph_2</A>&lt;Traits&gt; Apollonius_graph;\n\n\n\nint main()\n{\n  std::ifstream ifs(&quot;data/sites.cin&quot;);\n  assert( ifs );\n\n  Apollonius_graph ag;\n  Apollonius_graph::Site_2 site;\n\n  // read the sites and insert them in the Apollonius graph\n  while ( ifs &gt;&gt; site ) {\n    ag.insert(site);\n  }\n\n  // validate the Apollonius graph\n  assert( ag.is_valid(true, 1) );\n  std::cout &lt;&lt; std::endl;\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>45.5.3&nbsp;&nbsp;&nbsp;Third example</h3>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>/example3.C\n\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\n#include &lt;CGAL/basic.h&gt;\n\n// example that uses the filtered traits\n\n// choose the representation\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; Rep;\n\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_966\">Triangulation_data_structure_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_vertex_base_2.html#Cross_link_anchor_1074\">Apollonius_graph_vertex_base_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_2.html#Cross_link_anchor_947\">Triangulation_face_base_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_filtered_traits_2.html#Cross_link_anchor_1079\">Apollonius_graph_filtered_traits_2</A>.h&gt;\n\n// typedef for the traits; the filtered traits class is used\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_filtered_traits_2.html#Cross_link_anchor_1078\">CGAL::Apollonius_graph_filtered_traits_2</A>&lt;Rep&gt; Traits;\n\n// typedefs for the algorithm\n\n// With the second template argument in the vertex base class being\n// false, we indicate that there is no need to store the hidden sites.\n// One case where this is indeed not needed is when we only do\n// insertions, like in the main program below.\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_vertex_base_2.html#Cross_link_anchor_1073\">CGAL::Apollonius_graph_vertex_base_2</A>&lt;Traits,false&gt;   Vb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_2.html#Cross_link_anchor_946\">CGAL::Triangulation_face_base_2</A>&lt;Traits&gt;              Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;       Agds;\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1066\">CGAL::Apollonius_graph_2</A>&lt;Traits,Agds&gt;    Apollonius_graph;\n\n\nint main()\n{\n  std::ifstream ifs(&quot;data/sites.cin&quot;);\n  assert( ifs );\n\n  Apollonius_graph ag;\n  Apollonius_graph::Site_2 site;\n\n  // read the sites and insert them in the Apollonius graph\n  while ( ifs &gt;&gt; site ) {\n    ag.insert(site);\n  }\n\n  // validate the Apollonius graph\n  assert( ag.is_valid(true, 1) );\n  std::cout &lt;&lt; std::endl;\n\n  // now remove all sites\n  std::cout &lt;&lt; &quot;Removing all sites... &quot; &lt;&lt; std::flush;\n  while ( ag.number_of_vertices() &gt; 0 ) {\n    ag.remove( ag.finite_vertex() );\n  }\n  std::cout &lt;&lt; &quot;done!&quot; &lt;&lt; std::endl &lt;&lt; std::endl;\n\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>45.5.4&nbsp;&nbsp;&nbsp;Fourth example</h3>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_2.html#Cross_link_anchor_1067\">Apollonius_graph_2</A>/example4.C\n\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\n// example that uses the filtered traits\n\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n\n// constructions kernel (inexact)\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; CK;\n\n// exact kernel\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt; EK;\n\n\n// typedefs for the traits and the algorithm\n\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_hierarchy_2.html#Cross_link_anchor_1081\">Apollonius_graph_hierarchy_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_filtered_traits_2.html#Cross_link_anchor_1079\">Apollonius_graph_filtered_traits_2</A>.h&gt;\n\n\n// Type definition for the traits class.\n// In this example we explicitly define the exact kernel. We also\n// explicitly define what operations to use for the evaluation of the\n// predicates and constructions, when the filtering and the exact\n// kernels are used respectively.\n// Note that the operations allowed for the filtering and the\n// constructions (field operations plus <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> roots) are different\n// from the operations allowed when the exact kernel is used (ring\n// operations).\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A>  CM;\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A>        EM;\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_filtered_traits_2.html#Cross_link_anchor_1078\">CGAL::Apollonius_graph_filtered_traits_2</A>&lt;CK,CM,EK,EM&gt; Traits;\n\n// Now we use the Apollonius graph hierarchy.\n// The hierarchy is faster for inputs consisting of about more than\n// 1,000 sites\ntypedef <A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_hierarchy_2.html#Cross_link_anchor_1080\">CGAL::Apollonius_graph_hierarchy_2</A>&lt;Traits&gt; Apollonius_graph;\n\n\n\nint main()\n{\n  std::ifstream ifs(&quot;data/hierarchy.cin&quot;);\n  assert( ifs );\n\n  Apollonius_graph ag;\n  Apollonius_graph::Site_2 site;\n\n  // read the sites and insert them in the Apollonius graph\n  while ( ifs &gt;&gt; site ) {\n    ag.insert(site);\n  }\n\n  // validate the Apollonius graph\n  assert( ag.is_valid(true, 1) );\n\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Apollonius_graph_2_ref/Chapter_intro.html\">2D Apollonius graphs</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_45!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38520.0}