{"text": "This assignment is due on Monday February 7 by 7 p m in the locking box in CS 189 Turn in everything you have completed at that time we can t grade straggling assignments Summary In this assignment you will work with some realistic functional programs You ll also get experience with BNF and with issues of scoping and binding Readings and review questions This assignment covers more of Sebesta chapters 3 and 4 You should know the answers to the review questions listed below but you do not have to turn them in This list should help you identify some of the more important concepts in the text On the other hand don t infer that the topics we skip or omit are entirely unimportant Chapter 3 1 7 8 14 Chapter 4 1 2 4 6 14 16 18 23 Part I Syntax description a In the Sebesta text do the following problems in the problem set starting on page 152 pick one of the five parts of problem 2 pick two of the four parts of problem 4 problem 6 problem 8 problem 1 and problem 11 which as written is a trick question b Write an EBNF grammar for HTML documents You don t have to cover all of HTML just handle about ten of the most popular tags including A A in their basic forms Use boxed text instead of angle brackets for your nonterminals so you don t get confused with the angle brackets that are part of HTML itself Part II Scoping and binding In the Sebesta text do the following problems in the problem set starting on page 189 this is labeled problem set not review questions 2 4 6 9 Draw two contour models for problem 9 one for static scoping one for dynamic as we did in class it will help a lot The other problems in the section aren t required but if you don t feel comfortable with the scoping issues you should try to work them out Part III Functional programming in real programs a Attached to this assignment is a simple Scheme program to maintain a database of restaurant objects It s available on the lab server Load the program into EdScheme click the lambda button and play around with it for a while Evaluate restaurants in the transcript window and give commands to add remove print and search for restaurants Represent restaurant names either as double quoted strings or as Lisp lists of symbols just keep to one representation consistently You don t have to turn anything in to demonstrate your experimentation a 1 Modify the program code so that it gives the user an additional menu choice c Clear all the restaurants from the collection When the user types c the program should remove all the restaurants from the collection so that if the next command were p for example nothing would be printed This will require modifications or additions in a few places you can do the main part of the work very easily indeed with a single function call The key is to think functionally not of changing values but of describing or creating the new value a 2 The search command currently allows the user to search only for restaurants by name We know that collection select allows much more flexible searching however Modify the search collection routine in the main program to give the user a choice of searching by name or by cuisine If the user chooses to search by cuisine prompt for the type of cuisine and perform the requested search with appropriate calls to collection select Hint Consider using some of the code on the second page of the Notes on Scheme handout a 3 Now ask yourself how much code it would have taken to accomplish the same thing in C You don t have to write an answer but it s worth thinking about b Also attached to this assignment is an implementation of binary search trees in Scheme It too is available on the server Load it and experiment with it b 1 What happens when you add a duplicate item an item whose value is already in the tree b 2 Enhance the implementation by adding a count field to each node so that when a duplicate is added the count is increased and when an item is deleted its count is decreased and the node isn t actually deleted until the count reaches zero b 3 After saving a copy of your code from b 2 modify it to implement lazy deletion of nodes Instead of actually removing a node from the tree when its count gets to zero just mark it as deleted and alter the routines for searching and adding appropriately This is useful in situations where the same values enter and leave the tables repeatedly Turn in your final code for this part on paper and electronically to the ICS 141 dropbox on the Masterhit server in the lab labeled clearly with your name and student ID b 4 Go back to the original binary search tree code before you made your modifications for parts b 2 and b 3 Note that bst add and bst delete have a common structure Combine them as we did with find all matches and remove all matches in the Notes on Scheme handout You can do this on paper you do not have to turn it in electronically b 5 extra credit Once lazy deletion and a count field are implemented handling normal non lazy deletion is just a question of doing something different when the node s count gets to zero Modify your code from b 3 to let the user specify when creating the tree whether it should use lazy or normal deletion You d need to modify the constructor to take another parameter whose value would be either lazy or normal or you could make it an optional parameter using normal deletion as the default case You d store with each new tree an indication of which kind of deletion it uses and you d do that kind of deletion when called for b 6 extra credit Allow for more complex values like structures in the tree in essence building a templated class You ll need to supply key selector and key comparison functions when you create a tree b 7 extra credit Implement your favorite tree balancing algorithm c extra credit Find as many indications as you can in the Sebesta text that Sebesta doesn t get functional programming or Scheme that he doesn t treat Scheme as completely or seriously as other popular languages Look for omissions and subtleties in the wording d For some examples of the practical applications of functional programming check out the web site Functional Programming in the Real World http www cs bell labs com wadler realworld You should also take a look at www scheme com which describes a Scheme implementation that claims to generate code with the same performance as C There s nothing to turn in for this ", "_id": "http://www.ics.uci.edu/~kay/courses/141/hw/hw3.html", "title": "asst. 3 * syntax, vars, real f.p", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Saturday, February 5, 2000 4:50 PM\">\n<TITLE>Asst. 3 * Syntax, Vars, Real F.P</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"64274B8F\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Programming languages, homework, functional programming, syntax, scope, variables, semantics\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Assignment 3 on functional programming, syntax, and variables  for ICS 141, an undergraduate course in the concepts of programming languages taught by David G. Kay in the Department of Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 1999 , 2000 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"asst_3_syntax_vars_f_files/sidebar_73.gif\" WIDTH=468 HEIGHT=78>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4>This assignment is due on Monday, February\n7, by 7:00 p.m. in the locking box in CS 189.  Turn in everything you have\ncompleted at that time; we can&#39;t grade straggling assignments.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Summary:</B>  In this assignment you will\nwork with some realistic functional programs.  You&#39;ll also get experience\nwith BNF and with issues of scoping and binding.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Readings and review questions:</B>  This\nassignment covers more of Sebesta, chapters 3 and 4.  You should know the\nanswers to the review questions listed below, but you do not have to turn\nthem in.  This list should help you identify some of the more important\nconcepts in the text.  (On the other hand, don&#39;t infer that the topics\nwe skip or omit are entirely <I>un</I>important.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 3:  1, 7, 8, 14</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 4:  1, 2, 4, 6-14, 16, 18-23.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part I:</B>  Syntax description</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  In the Sebesta text, do the following\nproblems in the problem set starting on page 152: pick one of the five parts\nof problem 2; pick two of the four parts of problem 4; problem 6; problem\n8; problem 10; and problem 11 (which, as written, is a trick question).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Write an EBNF grammar for HTML\ndocuments.  You don&#39;t have to cover all of HTML; just handle about ten\nof the most popular tags (including &lt;A&gt;&lt;/A&gt;) in their basic\nforms.  Use <U>|&#160;boxed text |</U> instead of &lt;angle brackets&gt;\nfor your nonterminals, so you don&#39;t get confused with the angle brackets\nthat are part of HTML itself.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part II:</B>  Scoping and binding</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>In the Sebesta text, do the following problems\nin the problem set starting on page 189 (this is labeled &quot;problem set,&quot;\nnot &quot;review questions.&quot;): 2, 4, 6, 9.  Draw two contour models\nfor problem 9 (one for static scoping, one for dynamic), as we did in class;\nit will help a lot.  The other problems in the section aren&#39;t required,\nbut if you don&#39;t feel comfortable with the scoping issues you should\ntry to work them out.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part III:</B>  Functional programming in\nreal programs</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  Attached to this assignment is\na simple Scheme program to maintain a database of restaurant objects.  It&#39;s\navailable on the lab server.  Load the program into EdScheme (click the\nlambda button) and play around with it for a while:  Evaluate </FONT><FONT FACE=\"Courier New\">(restaurants)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nin the transcript window and give commands to add, remove, print, and search\nfor restaurants.  (Represent restaurant names either as double-quoted strings\nor as Lisp lists of symbols--just keep to one representation consistently.)\n You don&#39;t have to turn anything in to demonstrate your experimentation.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.1)</B>  Modify the program code so that\nit gives the user an additional menu choice:</FONT></P>\n<P>\n<FONT FACE=\"Courier New\">&#160;&#160; c:  Clear all the restaurants from\nthe collection</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>When the user types &#39;</FONT><FONT FACE=\"Courier New\">c</FONT><FONT FACE=\"AGaramond\" SIZE=4>&#39;,\nthe program should remove all the restaurants from the collection (so that\nif the next command were &#39;</FONT><FONT FACE=\"Courier\"><TT>p</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>&#39;,\nfor example, nothing would be printed).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>This will require modifications or additions\nin a few places; you can do the main part of the work very easily indeed,\nwith a single function call.  The key is to think functionally, not of changing\nvalues but of describing or creating the new value.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.2)</B>  The search command currently\nallows the user to search only for restaurants by name.  We know that </FONT><FONT FACE=\"Courier New\">collection-select</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nallows much more flexible searching, however.  </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Modify the </FONT><FONT FACE=\"Courier New\">search-collection</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nroutine in the main program to give the user a choice of searching by name\nor by cuisine.  If the user chooses to search by cuisine, prompt for the\ntype of cuisine and perform the requested search with appropriate calls\nto </FONT><FONT FACE=\"Courier New\">collection-select</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n  [Hint:  Consider using some of the code on the second page of the &quot;Notes\non Scheme&quot; handout.]</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.3)  </B>Now, ask yourself how much code\nit would have taken to accomplish the same thing in C++.  You don&#39;t\nhave to write an answer, but it&#39;s worth thinking about.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Also attached to this assignment\nis an implementation of binary search trees in Scheme.  It, too, is available\non the server.  Load it and experiment with it.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.1)</B>  What happens when you add a\nduplicate item (an item whose value is already in the tree)?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.2)  </B>Enhance the implementation by\nadding a &quot;count&quot; field to each node, so that when a duplicate\nis added, the count is increased, and when an item is deleted, its count\nis decreased (and the node isn&#39;t actually deleted until the count reaches\nzero).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.3)</B>  After saving a copy of your\ncode from <B>(b.2)</B>, modify it to implement &quot;lazy deletion&quot;\nof nodes:  Instead of actually removing a node from the tree when its count\ngets to zero, just mark it as deleted (and alter the routines for searching\nand adding appropriately).  This is useful in situations where the same\nvalues enter and leave the tables repeatedly.  Turn in your final code for\nthis part on paper and electronically, to the ICS 141 dropbox on the Masterhit\nserver in the lab, labeled clearly with your name and student ID.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.4)</B>  Go back to the original binary\nsearch tree code, before you made your modifications for parts <B>(b.2)</B>\nand <B>(b.3)</B>.  Note that </FONT><FONT FACE=\"Courier New\">bst-add</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">bst-delete</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nhave a common structure.  Combine them, as we did with </FONT><FONT FACE=\"Courier New\">find-all-matches</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">remove-all-matches</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nin the &quot;Notes on Scheme&quot; handout.  You can do this on paper; you\ndo not have to turn it in electronically.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.5)</B>  (extra credit)  Once lazy deletion\nand a count field are implemented, handling normal (non-lazy) deletion is\njust a question of doing something different when the node&#39;s count gets\nto zero.  Modify your code from <B>(b.3)</B> to let the user specify when\ncreating the tree whether it should use lazy or normal deletion.  You&#39;d\nneed to modify the &quot;constructor&quot; to take another parameter (whose\nvalue would be either </FONT><FONT FACE=\"Courier New\">&#39;lazy</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nor </FONT><FONT FACE=\"Courier New\">&#39;normal</FONT><FONT FACE=\"AGaramond\" SIZE=4>--or,\nyou could make it an <I>optional</I> parameter, using normal deletion as\nthe default case).  You&#39;d store with each new tree an indication of\nwhich kind of deletion it uses, and you&#39;d do that kind of deletion when\ncalled for.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.6)</B>  (extra credit)  Allow for more\ncomplex values (like structures) in the tree, in essence building a &quot;templated\nclass.&quot;  You&#39;ll need to supply key-selector and key-comparison\nfunctions when you create a tree.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.7)</B>  (extra credit)  Implement your\nfavorite tree-balancing algorithm.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)  </B>(extra credit)  Find as many indications\nas you can in the Sebesta text that Sebesta doesn&#39;t &quot;get&quot;\nfunctional programming or Scheme--that he doesn&#39;t treat Scheme as completely\nor seriously as other popular languages.  Look for omissions and subtleties\nin the wording. </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(d)</B>  For some examples of the practical\napplications of functional programming, check out the web site <A HREF=\"http://www.cs.bell-labs.com/~wadler/realworld/\">Functional Programming in the Real World</A>,\n</FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.cs.bell-labs.com/~wadler/realworld/\">http://www.cs.bell-labs.com/~wadler/realworld/</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n You should also take a look at </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.scheme.com\">www.scheme.com</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich describes a Scheme implementation that claims to generate code with\nthe same performance as C.  There&#39;s nothing to turn in for this.</FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "id": 11140.0}