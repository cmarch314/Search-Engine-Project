{"text": "Homework 6 due Friday Wk 7 required problemstopic1Your favorite sawmill charges by the length to cut a piece of lumber For example to cut a 7 foot piece at any point costs 7 cents You bring in a 29 foot board and want it cut at points 4 14 19 and 27 feet from the left end In what order should the mill cut the wood in order to minimize your cost Use dynamic programming principles to solve this problem Example To cut the board in 1 2 3 4 order it will cost 29 25 15 1 79 cents Develop and analyze asymptotic time and space an algorithm to solve the previous problem for any length of lumber and number of cuts dynamic pgm2CLR Problem 15 4 on pages 4 5 4 6 Consider the problem of neatly printing a paragraph with a monospaced font all characters having the same width on a printer The input text is a sequence of n words of lengths l1 l2 ln measured in characters We want to print this paragraph neatly on a number of lines that hold a maximum of M characters each Our criteron of neatness is as follows If a given line contains words i through j where i j and we leave exactly one space between words the number of extra space characters at the end of the line is M j i k i to j lk which must be nonnegative so that the words fit on the line We wish to minimize the sum over all lines except the last of the cubes of the numbers of extra space characters at the ends of lines Give a dynamic programming algorithm to print a paragraph of n words neatly on a printer Analyze the running time and space requirements of your algorithm printing neatly3 Consider the function f 1 1 f n i 1 to n 1 i f i for n 1 Give a divide and conquer algorithm which given n calculates f n Give and solve a recurrence as a function of n for the number of scalar multiplications required by your algorithm from part a Give a dynamic programming algorithm which given n calculates f n Find as a function of n the number of scalar multiplication operations required by your algorithm from part c Give an algorithm which given n calculates f n using only a linear number of scalar multiplications this includes multiplications and divisions Hint First find a closed form for the value of f n algorithm based on recurrence suggested problems topic4CLR Exercise 15 4 6 on page 397 Give an O n lg n time algorithm to find the longest monotonically increasing subsequence of a sequence of n numbers Hint Observe that the last element of a candidate subsequence of length i is at least as large as the last element of a candidate subsequence of length i 1 Maintain candidate subsequences by linking them through the input sequence longest increasing subsequence5CLR Problem 15 3 on page 4 5bitonic euclidean tsp6Baase Exercise 1 9 on page 477optimal bst7 Find an optimal binary search tree for the probabilities p1 p2 p3 p4 p5 5 q q1 5 q2 1 q3 15 q4 2 q5 25 optimal bst8 Find the optimal binary search tree consisting of n elements having probabilities p1 p2 pn qi 5 qi 1 for i n Give an explanation of why it is optimal optimal bst9Baase Exercise 1 16 on page 478dynamic pgm binomial coefficients1 Baase Exercise 1 21 on page 479dynamic pgm partition problem11The Strahler number of a binary tree is defined as follows An empty tree has Strahler number If the binary tree T has subtrees TL and TR the Strahler number S T of T is defined by max S TL S TR if S TL S TR S TL 1 otherwise Give an algorithm possibly recursive to find the Strahler number of a binary tree dynamic pgm12One version of the game of Nim is played with counters that are arranged in three rows A position the pattern of counters can be conveniently represented by an ordered triple of integers describing the number of counters in each row The game is played by two persons who move in turns Each move consists of removing one or more counters from one of the rows A player wins if he she removes all remaining counters i e the position results from his her move Any position in which the next player to move if he she moves correctly is guaranteed to eventually win regardless of which moves his her opponent may make is called a winning position Let WIN i j k be true iff i j k is a winning position Give a recurrence for the values of WIN including boundary conditions Using your recurrence from part a produce a polynomial time algorithm that determines whether any given position a b c is a winning position Analyze the time and space complexity of your algorithm as a function of a b c What is the complexity as a function of n when a b c n Hint A good solution would be n4 A better solution would be n3 Nim13Let T be a complete binary tree with n 2k 1 nodes The nodes are numbered in level order with the root labelled 1 its two children labelled 2 and 3 etc Let Ti be the subtree whose root is node i and so T1 T Every node i has a value VAL i which can be positive or negative or zero We define WT i to be the weight of subtree i given by the sum of all values of the nodes in Ti The problem is to find the maximum weight of all subtrees of T Give a recurrence for WT i Give a divide and conquer algorithm that finds the maximum WT i given the array VAL What are the space and time complexities of your D C algorithm Give a dynamic programming algorithm that finds the maximum WT i given the array VAL What are the space and time complexities of your dynamic programming algorithm DC dyn pgm14DPV exercise 6 4 on p 178 You are given a string of n characters s 1 n which you believe to be a corrupted text document in which all punctuation has vanished so that it looks something like itwasthebestoftimes You wish to reconstruct the document using a dictionary which is available in the form of a Boolean function dict such that for any string w dict w has value 1 if w is a valid word and has value otherwise Give a dynamic programming algorithm that determines whether the string s can be reconstituted as a sequence of valid words The running time should be at most O n2 assuming that each call to dict takes unit time In the event that the string is valid make your algorithm output the corresponding sequence of words dynamic pgm15DPV exercise 6 5 on p 178 We are given a checkerboard which has 4 rows and n columns and has an integer written in each square We are also given a set of 2n pebbles and we wish to place some or all of these on the checkerboard each pebble can be placed on exactly one square so as to maximize the sum of integers in the squares that are covered by pebbles There is one constraint for a placement of pebbles to be legal no two of them can be on horizontally or vertically adjacent squares diagonal adjacency is fine Determine the number of legal patterns that can occur in any column in isolation ignoring the pebbles in adjacent columns and describe these patterns Call two patterns compatible if they can be placed on adjacent columns to form a legal placement Let us consider subproblems consisting of the first k columns 1 k n Each subproblem can be assigned a type which is the pattern occurring in the last column Using the notions of compatibility and type give an O n time dynamic programming algorithm for computing an optimal placement dynamic pgm Dan Hirschberg Computer Science Department University of California Irvine CA 92697 3435 dan at ics uci edu Last modified Nov 1 2 14", "_id": "http://www.ics.uci.edu/~dan/class/161/hw6.html", "title": " compsci 161 homework #6 ", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"\n      \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<HTML><HEAD>\n<TITLE> CompSci 161 Homework #6 </TITLE>\n</HEAD><BODY>\n\n<!-- <H2> Homework #6 -- due Monday Wk 7 </H2> -->\n<H2 align=center> Homework #6 -- due Friday Wk 7 </H2>\n\n<table border=1>\n<tr><th width=\"5%\">#</th>\n    <th width=\"70%\"><font color=red>required problems</font></th>\n    <th width=\"25%\">topic</th>\n<tr><td align=center>1</td>\n    <td>Your favorite sawmill charges by the length to cut a piece of lumber.\n        (For example, to cut a 7 foot piece at any point costs 7 cents.)\n        <OL type=a>\n        <LI> You bring in a 29 foot board and want it cut at points\n             4, 14, 19, and 27 feet from the left end.&nbsp;\n             In what order should the mill cut the wood in order to\n             minimize your cost?&nbsp;\n             Use dynamic programming principles to solve this problem.\n             <BR>\n             <I>Example</I>:\n             To cut the board in 1, 2, 3, 4 order it will cost\n             29+25+15+10=79 cents.\n        <LI> Develop and analyze (asymptotic time and space) an\n             algorithm to solve the previous problem for any length\n             of lumber and number of cuts.\n        </OL>\n    </td>\n    <td>dynamic pgm</td>\n<tr><td align=center>2</td>\n    <td>CLR Problem 15-4 on pages 405-406\n      <BR>Consider the problem of neatly printing a paragraph with a monospaced font\n        (all characters having the same width) on a printer.  The input text is a\n        sequence of <I>n</I> words of lengths\n        <I>l</I><sub><sub>1</sub></sub>,\n        <I>l</I><sub><sub>2</sub></sub>, ...,\n        <I>l</I><sub><sub><I>n</I></sub></sub>,\n        measured in characters.\n        We want to print this paragraph neatly on a number of lines that hold a\n        maximum of <I>M</I> characters each.  Our criteron of &#8220;neatness&#8221;\n        is as follows.\n        If a given line contains words <I>i</I> through &nbsp;<I>j</I>, where\n        <I>i&nbsp;&le;&nbsp;j</I>, and we leave exactly one space between words,\n        the number of extra space characters at the end of the line is\n        <I>M &minus; j + i</I> &minus;\n        &sum;<sub><sub><I>k=i</I>&nbsp;to&nbsp;<I>j</I></sub></sub></I>\n        (<I>l<sub><sub>k</sub></sub></I>),\n        which must be nonnegative so that the words fit on the line.\n        We wish to minimize the sum, over all lines except the last,\n        of the cubes of the numbers of extra space characters at the ends of lines.\n        Give a dynamic-programming algorithm to print a paragraph of <I>n</I>\n        words neatly on a printer.  Analyze the running time and space requirements\n        of your algorithm.\n      </td>\n    <td>printing neatly</td>\n<tr><td align=center>3</td>\n    <td> Consider the function:\n       <center>\n       <table width=\"70%\">\n       <tr><td> <I>f</I>(1) = 1</td>\n       <tr><td> <I>f</I>(<I>n</I>) =\n           &sum;<sub><sub><I>i</I>=1 to <I>n-</I>1</sub></sub>\n           ( <I>i f</I>(<I>i</I>) ), &nbsp; for <I>n</I> &gt; 1\n           </td>\n       </table>\n       </center>\n       <OL type=a>\n       <LI> Give a divide-and-conquer algorithm which,\n            given <I>n</I>, calculates <I>f</I>(<I>n</I>).\n       <LI> Give and solve a recurrence, as a function of <I>n</I>,\n            for the number of scalar multiplications required by your\n            algorithm from part (a).\n       <LI> Give a dynamic programming algorithm which,\n            given <I>n</I>, calculates <I>f</I>(<I>n</I>).\n       <LI> Find, as a function of <I>n</I>, the number of scalar\n            multiplication operations required by your algorithm\n            from part (c).\n       <LI> Give an algorithm which, given <I>n</I>,\n            calculates <I>f</I>(<I>n</I>) using only a linear number\n            of scalar multiplications (this includes\n            multiplications and divisions).<BR>\n            Hint:  First find a closed form for the value of\n            <I>f</I>(<I>n</I>).\n       </OL>\n    </td>\n    <td>algorithm based on recurrence</td>\n</table>\n\n<P>\n\n<table border=1>\n<tr><th width=\"5%\">#</th>\n    <th width=\"70%\"><font color=\"#009900\">suggested problems</font>\n<!--              -- not to be turned in  --></th>\n    <th width=\"25%\">topic</th>\n<tr><td align=center>4</td>\n    <td>CLR Exercise 15.4-6 on page 397\n     <BR>Give an <I>O</I>(<I>n</I> lg <I>n</I>)-time algorithm to find the longest\n         monotonically increasing subsequence of a sequence of <I>n</I> numbers.\n     <BR><I>Hint</I>: Observe that the last element of a candidate subsequence\n         of length <I>i</I> is at least as large as the last element of a\n         candidate subsequence of length <I>i</I>-1.  Maintain candidate subsequences\n         by linking them through the input sequence.)\n    </td>\n    <td>longest increasing subsequence</td>\n<tr><td align=center>5</td>\n    <td>CLR Problem 15-3 on page 405</td>\n    <td>bitonic euclidean tsp</td>\n<tr><td align=center>6</td>\n    <td>Baase Exercise 10.9 on page 477</td>\n    <td>optimal bst</td>\n<tr><td align=center>7</td>\n    <td> Find an optimal binary search tree for the probabilities\n         <center>\n           <I>p</I><sub>1</sub> = <I>p</I><sub>2</sub> =\n           <I>p</I><sub>3</sub> = <I>p</I><sub>4</sub> =\n           <I>p</I><sub>5</sub> = 0.05\n         </center>\n         <center>\n           <I>q</I><sub>0</sub>=0.0, <I>q</I><sub>1</sub>=0.05,\n           <I>q</I><sub>2</sub>=0.10, <I>q</I><sub>3</sub>=0.15,\n           <I>q</I><sub>4</sub>=0.20, <I>q</I><sub>5</sub>=0.25\n         </center>\n    </td>\n    <td>optimal bst</td>\n<tr><td align=center>8</td>\n    <td> Find <I>the</I> optimal binary search tree consisting of\n         <I>n</I> elements having probabilities\n         <center>\n           <I>p</I><sub>1</sub> = <I>p</I><sub>2</sub> = ... =\n           <I>p</I><sub>n</sub> = 0.0\n         </center>\n         <center>\n           <I>q</I><sub><I>i</I></sub> &lt;\n           0.5 <I>q</I><sub><I>i </I>+1</sub>,\n           for 0 <U>&lt;</U> <I>i</I> &lt; <I>n</I>\n         </center>\n         Give an explanation of why it is optimal.\n     </td>\n    <td>optimal bst</td>\n<tr><td align=center>9</td>\n    <td>Baase Exercise 10.16 on page 478</td>\n    <td>dynamic pgm - binomial coefficients</td>\n<tr><td align=center>10</td>\n    <td>Baase Exercise 10.21 on page 479</td>\n    <td>dynamic pgm - partition problem</td>\n<tr><td align=center>11</td>\n    <td>The <I>Strahler number</I> of a binary tree is defined as\n        follows:<BR>\n        An empty tree has Strahler number 0.&nbsp;\n        If the binary tree <I>T</I> has subtrees <I>T<sub>L</sub></I>\n        and <I>T<sub>R</sub></I>,\n        the Strahler number <I>S</I>(<I>T</I>) of <I>T</I> is defined by\n\n<center>\n        <BR>\n            max{ <I>S</I>(<I>T<sub>L</sub></I>),<I>S</I>(<I>T<sub>R</sub></I>) },\n        &nbsp; &nbsp; &nbsp; &nbsp;\n           if <I>S</I>(<I>T<sub>L</sub></I>) &ne; <I>S</I>(<I>T<sub>R</sub></I>)\n        <BR><BR>\n           <I>S</I>(<I>T<sub>L</sub></I>) + 1,\n        &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; otherwise\n        <BR><BR>\n</center>\n\n        Give an algorithm (possibly recursive)\n        to find the Strahler number of a binary tree.\n    </td>\n    <td>dynamic pgm</td>\n<tr><td align=center>12</td>\n    <td>One version of the game of Nim is played with counters that are\n        arranged in three rows.&nbsp;\n        A <I>position</I> (the pattern of counters) can be\n        conveniently represented by an ordered triple of integers\n        describing the number of counters in each row.\n        <P>\n        The game is played by two persons who move in turns.&nbsp;\n        Each move consists of removing one or more counters from one of\n        the rows.&nbsp;  A player wins if he/she removes all remaining\n        counters, <I>i.e.</I>, the position &lt;0,0,0&gt; results\n        from his/her move.\n        <P>\n        Any position in which the next player to move, if he/she moves\n        correctly, is guaranteed to eventually win (regardless of which\n        moves his/her opponent may make) is called a\n        <I>winning position</I>.&nbsp;\n        Let <I>WIN</I>(<I>i,&nbsp;j,&nbsp;k</I>) be true iff\n        &lt;<I>i,&nbsp;j,&nbsp;k</I>&gt; is a winning position.\n        <OL type=a>\n        <LI>Give a recurrence for the values of <I>WIN</I>,\n            including boundary conditions.\n        <LI>Using your recurrence from part a, produce a polynomial-time\n            algorithm that determines whether any given position\n            &lt;<I>a,&nbsp;b,&nbsp;c</I>&gt; is a winning position.\n        <LI>Analyze the time and space complexity of your algorithm as a\n            function of <I>a</I>, <I>b</I>, <I>c</I>.\n            What is the complexity as a function of <I>n</I>\n            when <I>a=b=c=n</I>?\n<BR>Hint: A good solution would be &theta;(<I>n</I><sup>4</sup>).\nA better solution would be &theta;(<I>n</I><sup>3</sup>).\n        </OL>\n    </td>\n    <td>Nim</td>\n<tr><td align=center>13</td>\n    <td>Let <I>T</I> be a complete binary tree with\n<I>n</I> = 2<sup><I>k</I></sup>-1 nodes.\nThe nodes are numbered in level order with the root labelled 1,\nits two children labelled 2 and 3, etc.\nLet <I>T<sub>i</sub></I> be the subtree whose root is node <I>i</I>,\nand so <I>T</I><sub>1</sub> = <I>T</I>.\nEvery node <I>i</I> has a value VAL[<I>i</I>] which can be positive\nor negative or zero.\nWe define WT(<I>i</I>) to be the weight of subtree <I>i</I>,\ngiven by the sum of all values of the nodes in <I>T<sub>i</sub></I>.\nThe problem is to find the maximum weight of all subtrees of <I>T</I>.\n   <OL type=a>\n   <LI> Give a recurrence for WT(<i>i</I>).\n   <LI> Give a divide-and-conquer algorithm that finds the\n        maximum WT(<I>i</I>) given the array VAL.\n   <LI> What are the space and time complexities of your D&amp;C algorithm?\n   <LI> Give a dynamic programming algorithm that finds the\n        maximum WT(<I>i</I>) given the array VAL.\n   <LI> What are the space and time complexities of your dynamic programming algorithm?\n   </OL>\n    </td>\n    <td>DC+dyn pgm</td>\n<tr><td align=center>14</td>\n    <td>DPV exercise 6.4 on p.178 <BR>\n        You are given a string of <I>n</I> characters <I>s</I>[1...<I>n</I>],\n        which you believe to be a corrupted text document in which all\n        punctuation has vanished (so that it looks something like\n        \"<TT>itwasthebestoftimes</TT>...\").&nbsp;\n        You wish to reconstruct the document using a dictionary, which\n        is available in the form of a Boolean function <TT>dict</TT>(*)\n        such that, for any string <I>w</I>, <TT>dict</TT>(<I>w</I>) has\n        value 1 if <I>w</I> is a valid word, and has value 0 otherwise.\n       <OL type=a>\n       <LI> Give a dynamic programming algorithm that determines\n            whether the string <I>s</I>[*] can be reconstituted\n            as a sequence of valid words.&nbsp;\n            The running time should be at most <I>O</I>(<I>n</I><sup>2</sup>),\n            assuming that each call to <TT>dict</TT> takes unit time.\n       <LI> In the event that the string is valid, make your algorithm\n            output the corresponding sequence of words.\n       </OL>\n       </td>\n    <td>dynamic pgm</td>\n<tr><td align=center>15</td>\n    <td>DPV exercise 6.5 on p.178 <BR>\n       We are given a checkerboard which has 4 rows and <I>n</I> columns,\n       and has an integer written in each square.&nbsp;\n       We are also given a set of 2<I>n</I> pebbles, and we wish to place\n       some or all of these on the checkerboard (each pebble can be\n       placed on exactly one square) so as to maximize the sum of\n       integers in the squares that are covered by pebbles.&nbsp;\n       There is one constraint: for a placement of pebbles to be legal,\n       no two of them can be on horizontally or vertically adjacent\n       squares (diagonal adjacency is fine).\n       <OL type=a>\n       <LI> Determine the number of legal <I>patterns</I> that can occur\n            in any column (in isolation, ignoring the pebbles in\n            adjacent columns) and describe these patterns.\n       </OL>\n<P>\nCall two patterns <I>compatible</I> if they can be placed on adjacent\ncolumns to form a legal placement.&nbsp;\nLet us consider subproblems consisting of the first <I>k</I> columns\n1&le;<I>k</I>&le;<I>n</I>.&nbsp;\nEach subproblem can be assigned a <I>type</I>,\nwhich is the pattern occurring in the last column.\n       <OL type=a start=2>\n       <LI> Using the notions of compatibility and type, give an\n            <I>O</I>(<I>n</I>)-time dynamic programming algorithm\n            for computing an optimal placement.\n       </OL>\n       </td>\n    <td>dynamic pgm</td>\n</table>\n\n<HR>\n<A HREF=\"http://www.ics.uci.edu/~dan\">\nDan Hirschberg </A> <BR>\n<ADDRESS>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3435\n</ADDRESS>\n<tt>dan at ics.uci.edu</tt><br>\n\nLast modified: Nov 10, 2014\n</BODY></HTML>\n", "id": 2057.0}