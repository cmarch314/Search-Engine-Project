{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL box self intersection d Definition The function box self intersection d computes the pairwise intersecting boxes in a sequence of iso oriented boxes in arbitrary dimension The sequence of boxes is given with as a random access iterator range and will be reordered in the course of the algorithm For each intersecting pair of boxes a callback function object is called with the two intersecting boxes as argument the first argument is a box from the sequence the second argument is a copy of a box from the sequence The performance of the algorithm can be tuned with a cutoff parameter see the implementation section of the CGAL box intersection d function on page The algorithm creates a second copy of the boxes and reorders the boxes in the course of the algorithm Now depending on the size of a box it can be faster to copy the boxes or to work with pointers to boxes and copy only pointers We offer automatic support for both options To simplify the description let us call the value type of the iterators box handle The box handle can either be our box type itself or a pointer or const pointer to the box type A d dimensional iso oriented box is defined as the Cartesian product of d intervals We call the box half open if the d intervals loi hii i d are half open intervals and we call the box closed if the d intervals loi hii i d are closed intervals Note that closed boxes support zero width boxes and they can intersect at their boundaries while non empty half open boxes always have a positive volume and they only intersect iff their interiors overlap The distinction between closed or half open boxes does not require a different representation of boxes just a different interpretation when comparing boxes which is selected with the topology parameter and its two values CGAL Box intersection d HALF OPEN and CGAL Box intersection d CLOSED In addition a box has an unique id number It is used to order boxes consistently in each dimension even if boxes have identical coordinates In consequence the algorithm guarantees that a pair of intersecting boxes is reported only once This self intersection function creates internally a second copy of the box sequence The copying has to preserve the id number of boxes Note that this implies that the address of the box is not sufficient for the id number if boxes are copied by value Boxes of equal id number are not reported as intersecting pairs since they are always intersecting trivially The algorithm uses a traits class of the BoxIntersectionTraits d concept to access the boxes A default traits class is provided that assumes that the box type is a model of the BoxIntersectionBox d concept and that the box handle i e the iterators value type is identical to the box type or a pointer to the box type include CGAL box intersection d h template class RandomAccessIterator class Callback void box self intersection d RandomAccessIterator begin RandomAccessIterator end Callback callback std ptrdiff t cutoff 1 Box intersection d Topology topology Box intersection d CLOSED Invocation of box intersection with default box traits CGAL Box intersection d Box traits d Box handle where Box handle corresponds to the iterator value type of RandomAccessIterator template class RandomAccessIterator class Callback class BoxTraits void box self intersection d RandomAccessIterator begin RandomAccessIterator end Callback callback BoxTraits box traits std ptrdiff t cutoff 1 Box intersection d Topology topology Box intersection d CLOSED Invocation with custom box traits Requirements RandomAccessIterator must be a mutable random access iterator We call its value type Box handle in the following Callback must be of the BinaryFunction concept The Box handle must be convertible to both argument types The return type is not used and can be void The Box handle must be a model of the Assignable concept In addition if the default box traits is used the Box handle must be a class type T or a pointer to a class type T where T must be a model of the BoxIntersectionBox d concept In both cases the default box traits specializes to a suitable implementation BoxTraits must be of the BoxIntersectionTraits d concept See Also CGAL box intersection d CGAL box self intersection all pairs d CGAL Box intersection d Box traits d BoxHandle BoxIntersectionBox d BoxIntersectionTraits d Implementation See the implementation section of the CGAL box intersection d function on page Example The box implementation provided with CGAL Box intersection d Box d double 2 has a special constructor for the CGAL bounding box type CGAL Bbox 2 and similar for dimension 3 We use this in the example to create 3 3 boxes in a grid layout The default policy of the box type implements the id number with an explicit counter in the boxes which is the default choice since it always works We use the id number in our callback function to report the result of the intersection algorithm call The result will be 2 pairwise intersections but the order in which they are reported is non intuitive file examples Box intersection d minimal self C include CGAL box intersection d h include CGAL Bbox 2 h include iostream typedef CGAL Box intersection d Box d double 2 Box typedef CGAL Bbox 2 Bbox 9 boxes of a grid Box boxes 9 Bbox 1 1 Bbox 1 2 1 Bbox 2 3 1 low Bbox 1 1 2 Bbox 1 1 2 2 Bbox 2 1 3 2 middle Bbox 2 1 3 Bbox 1 2 2 3 Bbox 2 2 3 3 upper void callback const Box a const Box b std cout box a id intersects box b id std endl int main CGAL box self intersection d boxes boxes 9 callback return Next box self intersection all pairs d Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Box_intersection_d_ref/Function_box_self_intersection_d.html", "title": "box_self_intersection_d", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Box_intersection_d_ref/box_self_intersection_d.tex' -->\n<html> <head>  \n<title>box_self_intersection_d</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1237\"></A>\n\n<A NAME=\"Cross_link_anchor_1238\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1311\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Function.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::box_self_intersection_d\"></A>\n<h2><I>CGAL::box_self_intersection_d</I></h2>\n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1312\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1313\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe function <I><A HREF=\"Function_box_self_intersection_d.html#Cross_link_anchor_1238\">box_self_intersection_d</A></I> computes the pairwise intersecting boxes\nin a sequence of iso-oriented boxes in arbitrary dimension.\nThe sequence of boxes is given with as a random-access iterator\nrange and will be reordered in the course of the algorithm. For each\nintersecting pair of boxes a <I>callback</I> function object is called\nwith the two intersecting boxes as argument; the first argument is a\nbox from the sequence, the second argument is a copy of a box from the\nsequence.  The performance of the algorithm can be tuned with a\n<I>cutoff</I> parameter, see the implementation section of the\n<I><A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A></I> function on page\n<A HREF=\"Function_box_intersection_d.html#ccRef_CGAL::box_intersection_d\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nThe algorithm creates a second copy of the boxes and reorders the\nboxes in the course of the algorithm. Now, depending on the size of a\nbox it can be faster to copy the boxes, or to work with pointers to\nboxes and copy only pointers. We offer automatic support for both\noptions. To simplify the description, let us call the <I>value_type</I>\nof the iterators <I>box handle</I>.  The <I>box handle</I> can\neither be our box type itself or a pointer (or const pointer) to the\nbox type.\n<P>\n\nA <MATH><I>d</I></MATH>-dimensional iso-oriented box is defined as the <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> product\nof <MATH><I>d</I></MATH> intervals. We call the box <I>half-open</I> if the <MATH><I>d</I></MATH>\nintervals <MATH><I>{ [lo<SUB>i</SUB>,hi<SUB>i</SUB>) | 0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i &lt; d}</I></MATH> are half-open intervals,\nand we call the box <I>closed</I> if the <MATH><I>d</I></MATH> intervals <MATH><I>{ [lo<SUB>i</SUB>,hi<SUB>i</SUB>]\n| 0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i &lt; d}</I></MATH> are closed intervals. Note that closed boxes support\nzero-width boxes and they can intersect at their boundaries, while\nnon-empty half-open boxes always have a positive <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> and they only\nintersect iff their interiors overlap.  The distinction between closed\nor half-open boxes does not require a different representation of\nboxes, just a different interpretation when comparing boxes, which is\nselected with the <I>topology</I> parameter and its two values,\n<I>CGAL::Box_intersection_d::HALF_OPEN</I> and\n<I>CGAL::Box_intersection_d::CLOSED</I>.\n<P>\n\nIn addition, a box has an unique <I>id</I>-number. It is used to order\nboxes consistently in each dimension even if boxes have identical\ncoordinates. In consequence, the algorithm guarantees that a pair of\nintersecting boxes is reported only once.  This self-<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\nfunction creates internally a second copy of the box sequence. The\ncopying has to preserve the <I>id</I>-number of boxes.  Note that this\nimplies that the address of the box is not sufficient for the\n<I>id</I>-number if boxes are copied by value. Boxes of equal\n<I>id</I>-number are not reported as intersecting pairs since they are\nalways intersecting trivially.\n<P>\n\nThe algorithm uses a traits class of the <I><A HREF=\"Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I>\nconcept to access the boxes. A default traits class is provided that\nassumes that the box type is a model of the <I><A HREF=\"Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I>\nconcept and that the box handle, i.e., the iterators value type, is\nidentical to the box type or a pointer to the box type.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/box_intersection_d.h\">CGAL/box_intersection_d.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator, class Callback &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_self_intersection_d6_RandomAccessIterator_begin+_RandomAccessIterator_end+_Callback_callback+_std::ptrdiff_t_cutoff_=_10+_Box_intersection_d::Topology_topology_=_Box_intersection_d::CLOSED9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Function_box_self_intersection_d.html#Cross_link_anchor_1238\">box_self_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator begin,<BR>\n\nRandomAccessIterator end,<BR>\n\nCallback callback,<BR>\n\nstd::ptrdiff_t cutoff = 10,<BR>\n\nBox_intersection_d::Topology topology = Box_intersection_d::CLOSED)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Invocation of box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> with default box traits\n    <I><A HREF=\"Class_Box_intersection_d--Box_traits_d.html#Cross_link_anchor_1245\">CGAL::Box_intersection_d::Box_traits_d</A>&lt;Box_handle&gt;</I>, where\n    <I>Box_handle</I> corresponds to the iterator value type  of\n    <I>RandomAccessIterator</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator, class Callback, class BoxTraits &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_self_intersection_d6_RandomAccessIterator_begin+_RandomAccessIterator_end+_Callback_callback+_BoxTraits_box_traits+_std::ptrdiff_t_cutoff_=_10+_Box_intersection_d::Topology_topology_=_Box_intersection_d::CLOSED9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Function_box_self_intersection_d.html#Cross_link_anchor_1238\">box_self_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator begin,<BR>\n\nRandomAccessIterator end,<BR>\n\nCallback callback,<BR>\n\nBoxTraits box_traits,<BR>\n\nstd::ptrdiff_t cutoff = 10,<BR>\n\nBox_intersection_d::Topology topology = Box_intersection_d::CLOSED)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Invocation with custom box traits.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Requirements</H3>\n<P>\n\n<UL>\n  <LI><I>RandomAccessIterator</I> must be a mutable random-access\n    iterator. We call its value type <I>Box_handle</I> in the following.\n  <LI><I>Callback</I> must be of the <I>BinaryFunction</I> concept. \n    The <I>Box_handle</I> must be convertible to both argument types. The\n    return type is not used and can be <I>void</I>.\n  <LI>The <I>Box_handle</I> must be a model of the <I>Assignable</I> concept.\n  <LI>In addition, if the default box traits is used the <I>Box_handle</I> must\n    be a class type <I>T</I> or a pointer to a class type <I>T</I>, where\n    <I>T</I> must be a model of the <I><A HREF=\"Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I> concept.\n    In both cases, the default box traits specializes to a suitable\n    implementation.\n  <LI><I>BoxTraits</I> must be of the <I><A HREF=\"Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I> concept.\n</UL>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A></I><BR>\n\n<I><A HREF=\"Function_box_self_intersection_all_pairs_d.html#Cross_link_anchor_1239\">CGAL::box_self_intersection_all_pairs_d</A></I>\n<P>\n\n<I><A HREF=\"Class_Box_intersection_d--Box_traits_d.html#Cross_link_anchor_1245\">CGAL::Box_intersection_d::Box_traits_d</A>&lt;BoxHandle&gt;</I><BR>\n\n<I><A HREF=\"Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I><BR>\n\n<I><A HREF=\"Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I>\n<P>\n\n<H3>Implementation</H3>\n<P>\n\nSee the implementation section of the <I><A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A></I>\nfunction on page&nbsp;<A HREF=\"Function_box_intersection_d.html#ccRef_CGAL::box_intersection_d\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe box implementation provided with\n<I><A HREF=\"Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;double,2&gt;</I> has a special\nconstructor for the C<SMALL>GAL</SMALL> bounding box type <I><A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_41\">CGAL::Bbox_2</A></I> (and\nsimilar for dimension 3). We use this in the example to create <MATH><I>3\n &times; 3</I></MATH> <I>boxes</I> in a grid layout.\n<P>\n\nThe default policy of the box type implements the <I>id</I>-number with\nan explicit counter in the boxes, which is the default choice since it\nalways works. We use the <I>id</I>-number in our callback function to\nreport the result of the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm call. The result will\nbe 20 pairwise intersections, but the order in which they are reported\nis non-intuitive.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/minimal_self.C\n#include &lt;CGAL/<A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_42\">Bbox_2</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;double,2&gt; Box;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_41\">CGAL::Bbox_2</A>                              Bbox;\n\n// 9 boxes of a grid\nBox boxes[9] = { Bbox( 0,0,1,1), Bbox( 1,0,2,1), Bbox( 2,0,3,1), // low\n                 Bbox( 0,1,1,2), Bbox( 1,1,2,2), Bbox( 2,1,3,2), // middle\n                 Bbox( 0,2,1,3), Bbox( 1,2,2,3), Bbox( 2,2,3,3)};// upper\n\nvoid callback( const Box&amp; a, const Box&amp; b ) {\n    std::cout &lt;&lt; &quot;box &quot; &lt;&lt; a.id() &lt;&lt; &quot; intersects box &quot; &lt;&lt; b.id() &lt;&lt; std::endl;\n}\n\nint main() {\n    <A HREF=\"Function_box_self_intersection_d.html#Cross_link_anchor_1237\">CGAL::box_self_intersection_d</A>( boxes, boxes+9, callback);\n    return 0;\n}\n\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_box_self_intersection_all_pairs_d.html\"><I>box_self_intersection_all_pairs_d</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_58!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38105.0}