{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 353D Triangulations Sylvain Pion and Monique Teillaud The basic 3D triangulation class of CGAL is primarily designed to represent the triangulations of a set of points A in 3 It is a partition of the convex hull of A into tetrahedra whose vertices are the points of A Together with the unbounded cell having the convex hull boundary as its frontier the triangulation forms a partition of 3 Its cells 3 faces are such that two cells either do not intersect or share a common facet 2 face edge 1 face or vertex face 35 1 Representation In order to deal only with tetrahedra which is convenient for many applications the unbounded cell can be subdivided into tetrahedra by considering that each convex hull facet is incident to an infinite cell having as fourth vertex an auxiliary vertex called the infinite vertex In that way each facet is incident to exactly two cells and special cases at the boundary of the convex hull are simple to deal with The class Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 of CGAL implements this point of view and therefore considers the triangulation of the set of points as a set of finite and infinite tetrahedra Notice that the infinite vertex has no significant coordinates and that no geometric predicate can be applied on it A triangulation is a collection of vertices and cells that are linked together through incidence and adjacency relations Each cell gives access to its four incident vertices and to its four adjacent cells Each vertex gives access to one of its incident cells The four vertices of a cell are indexed with 1 2 and 3 in positive orientation the positive orientation being defined by the orientation of the underlying Euclidean space 3 see Figure The neighbors of a cell are also indexed with 1 2 3 in such a way that the neighbor indexed by i is opposite to the vertex with the same index Figure Orientation of a cell 3 dimensional case As in the underlying combinatorial triangulation see Chapter edges 1 faces and facets 2 faces are not explicitly represented a facet is given by a cell and an index the facet i of a cell c is the facet of c that is opposite to the vertex with index i and an edge is given by a cell and two indices the edge i j of a cell c is the edge whose endpoints are the vertices of c with indices i and j See Figure Degenerate Dimensions The class Triangulation 3 can also deal with triangulations whose dimension d is less than 3 A triangulation of a set of points in d covers the whole space d and consists of cells having d 1 vertices some of them are infinite they are obtained by linking the additional infinite vertex to each facet of the convex hull of the points dimension 2 when a triangulation only contains coplanar points which is the case when there are only three points it consists of triangular faces dimension 1 the triangulation contains only collinear points which is the case when there are only two points it consists of edges dimension the triangulation contains only one finite point dimension 1 this is a convention to handle the case when the only vertex of the triangulation is the infinite one The same cell class is used in all cases triangular faces in 2D can be considered as degenerate cells having only three vertices resp neighbors numbered 1 2 edges in 1D have only two vertices resp neighbors numbered and 1 The implicit representation of facets resp edges still holds for degenerate dimensions i e dimensions 3 in dimension 2 each cell has only one facet of index 3 and 3 edges 1 1 2 and 2 in dimension 1 each cell has one edge 1 Validity A triangulation of 3 is said to be locally valid iff a b Its underlying combinatorial graph the triangulation data structure is locally valid see Section of Chapter c Any cell has its vertices ordered according to positive orientation See Figure When the triangulation is degenerated into a triangulation of dimension 2 the geometric validity reduces to c 2D For any two adjacent triangles u v w1 and u v w2 with common edge u v w1 and w2 lie on opposite sides of u v in the plane When all the points are collinear this condition becomes c 1D For any two adjacent edges u v and v w u and w lie on opposite sides of the common vertex v on the line The is valid method provided in Triangulation 3 checks the local validity of a given triangulation This does not always ensure global validity MNS 96 DLPT98 but it is sufficient for practical cases 35 2 Delaunay Triangulation The class Delaunay triangulation 3 represents a three dimensional Delaunay triangulation Delaunay triangulations have the specific empty sphere property that is the circumscribing sphere of each cell of such a triangulation does not contain any other vertex of the triangulation in its interior These triangulations are uniquely defined except in degenerate cases where five points are cospherical Note however that the CGAL implementation computes a unique triangulation even in these cases This implementation is fully dynamic it supports both insertions of points and vertex removal The user is advised to use the class Triangulation hierarchy 3 in order to benefit from an increased efficiency for large data sets 35 3 Regular Triangulation The class Regular triangulation 3 implements incremental regular triangulations also known as weighted Delaunay triangulations Let S w be a set of weighted points in 3 Let p w p wp p 3 wp and z w z wz z 3 wz be two weighted points A weighted point p w p wp can also be seen as a sphere of center p and radius wp The power product between p w and z w is defined as p w z w p z 2 wp wz where p z is the Euclidean distance between p and z p w and z w are said to be orthogonal iff p w z w see Figure Figure Orthogonal weighted points picture in 2D Four weighted points have a unique common orthogonal weighted point called the power sphere The weighted point orthogonal to three weighted points in the plane defined by these three points is called the power circle The power segment will denote the weighted point orthogonal to two weighted points on the line defined by these two points A sphere z w is said to be regular if p w S w p w z w A triangulation of S w is regular if the power spheres of all simplices are regular The regular triangulation of S w is in fact the projection onto 3 of the convex hull of the four dimensional points p p O 2 wp for p w p wp S w Note that all points of S w do not necessarily appear as vertices of the regular triangulation To know more about regular triangulations see for example ES96 When all weights are power spheres are nothing more than circumscribing spheres and the regular triangulation is exactly the Delaunay triangulation 35 4 Triangulation hierarchy The class Triangulation hierarchy 3 implements a triangulation augmented with a data structure that allows fast point location queries Thus it allows fast construction of the triangulation As proved in Dev 2 this structure has an optimal behavior when it is built for Delaunay triangulations Note that since the algorithms that are provided are randomized the running time of constructing a triangulation with a hierarchy may be improved when shuffling the data points 35 5 Software Design The main classes Triangulation 3 Delaunay triangulation 3 and Regular triangulation 3 are connected to each other by the derivation diagram shown in Figure This diagram also shows two other classes Triangulation utils 3 which provides a set of tools operating on the indices of vertices in cells and Triangulation hierarchy 3 which implements a hierarchy of triangulations suitable for speeding up point location Figure Derivation diagram of the 3D triangulation classes The three main classes Triangulation 3 Delaunay triangulation 3 and Regular triangulation 3 provide high level geometric functionality such as location of a point in the triangulation DPT 2 insertion and possibly removal of a point DT 3 and are responsible for the geometric validity They are built as layers on top of a triangulation data structure which stores their combinatorial structure This separation between the geometry and the combinatorics is reflected in the software design by the fact that these three triangulation classes take two template parameters the geometric traits class which provides the type of points to use as well as the elementary operations on them predicates and constructions The concepts for these parameters are described in more details in Section the triangulation data structure class which stores their combinatorial structure described in Section of Chapter The class Triangulation hierarchy 3 is parameterized by a class which at the moment can only be Delaunay triangulation 3 It fetches its geometric traits from this parameter directly 35 5 1 The Geometric Traits Parameter The first template parameter of the triangulation class Triangulation 3 TriangulationTraits 3 TriangulationDataStructure 3 is the geometric traits class described by the concept TriangulationTraits 3 It must define the types of the geometric objects points segments triangles and tetrahedra forming the triangulation together with a few geometric predicates on these objects orientation in space orientation in case of coplanar points order of collinear points In addition to the requirements described before the geometric traits class of Delaunay triangulation 3 must define predicates to test for the empty sphere property It is described by the concept DelaunayTriangulationTraits 3 which refines TriangulationTraits 3 The kernels provided by CGAL Cartesian Homogeneous Simple cartesian Simple homogeneous and Filtered kernel can all be used as models for the geometric traits parameter They supply the user with all the functionalities described for the concepts TriangulationTraits 3 and DelaunayTriangulationTraits 3 In addition the predefined kernels Exact predicates inexact constructions kernel and Exact predicates exact constructions kernel can also be used the later being recommended when the dual construction is used In order to be used as the traits class for Regular triangulation 3 a class must provide functions to compute the power tests see Section Regular triangulation euclidean traits 3 R Weight is a traits class designed to be used by the class Regular triangulation 3 RegularTriangulationTraits 3 TriangulationDataStructure 3 It provides Weighted point a class for weighted points needed by the regular triangulation which derives from the three dimensional point class R Point 3 It supplies the user with all the functionalities described for the concept RegularTriangulationTraits 3 It can be used as a traits class for Regular triangulation 3 RegularTriangulationTraits 3 TriangulationDataStructure 3 There is also another model of the traits concept Regular triangulation filtered traits 3 FK which is providing filtered predicates exact and efficient 35 5 2 The Triangulation Data Structure Parameter The second template parameter of the main classes Triangulation 3 Delaunay triangulation 3 and Regular triangulation 3 is a triangulation data structure class This class can be seen as a container for the cells and vertices maintaining incidence and adjacency relations see Chapter A model of this triangulation data structure is Triangulation data structure 3 and it is described by the TriangulationDataStructure 3 concept This model is itself parameterized by a vertex base and a cell base classes which gives the possibility to customize the vertices and cells used by the triangulation data structure and hence by the geometric triangulation using it Depending on the kind of triangulation used the requirements on the vertex and cell base classes vary and are expressed by various concepts following the refinement diagram shown in Figure Figure Concepts refinement hierarchy for the vertex and cell base classes parameters A default value for the triangulation data structure parameter is provided in all the triangulation classes so it need not be specified by the user unless he wants to use a different triangulation data structure or a different vertex or cell base class 35 5 3 Flexibility of the Design In order to satisfy as many uses as possible a design has been selected that allows to exchange different parts to meet the users needs while still re using a maximum of the provided functionalities We have already seen that the main triangulation classes are parameterized by a geometric traits class and a triangulation data structure TDS so that each of them can be interchanged with alternate implementations The most useful flexibility is the ability given to the user to add his own data in the vertices and cells by providing his own vertex and cell base classes to Triangulation data structure 3 The Figure shows in more detail the flexibility that is provided and the place where the user can insert his own vertex and or cell base classes Figure Triangulation software design 35 5 4 Backward compatibility Starting with CGAL release 3 the design of the triangulation data structure has been changed in order to give the possibility to store handles an entity akeen to pointers directly in the vertex and cell base classes Previously void pointers were stored there instead and later converted internally to handles but this happened to be too restrictive for some uses The difference is visible to the user when he provides his own vertex or cell base class Previously something like the following had to be written template class GT class My vertex public Triangulation vertex base GT typedef Triangulation vertex base GT Vb public typedef typename Vb Point Point My vertex My vertex const Point p Vb p My vertex const Point p void c Vb p c typedef Cartesian double GT typedef Triangulation data structure 3 My vertex GT Triangulation cell base 3 GT My TDS typedef Triangulation 3 GT My TDS Tr While now there are three possibilities The simplest one is to use the class Triangulation vertex base with info 3 and this approach is illustrated in a following subsection The most complicated one and probably useless for almost all cases is to write a vertex base class from scratch following the documented requirements This is mostly useless because most of the time it is enough to derive from the models that CGAL provides and add the desired features In this case when the user needs to access some type that depends on the triangulation data structure typically handles then he should write something like template class GT class Vb Triangulation vertex base GT class My vertex public Vb public typedef typename Vb Point Point typedef typename Vb Cell handle Cell handle template class TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 typedef My vertex GT Vb2 Other My vertex My vertex const Point p Vb p My vertex const Point p Cell handle c Vb p c The rest has not changed The changes that need to be made are the following My vertex is now parameterized by the vertex base class it derives from a nested template class Rebind TDS must be defined void must be changed to Cell handle and you need to extract the Cell handle type from the vertex base class that My vertex derives from The situation is exactly similar for cell base classes Section provides more detailed information 35 6 Examples 35 6 1 Basic example This example shows the incremental construction of a 3D triangulation the location of a point and how to perform elementary operations on indices in a cell It uses the default parameter of the Triangulation 3 class examples Triangulation 3 example simple C include CGAL Exact predicates inexact constructions kernel h include CGAL Triangulation 3 h include iostream include fstream include cassert include list include vector struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation 3 K Triangulation typedef Triangulation Cell handle Cell handle typedef Triangulation Vertex handle Vertex handle typedef Triangulation Locate type Locate type typedef Triangulation Point Point int main construction from a list of points std list Point L L push front Point L push front Point 1 L push front Point 1 Triangulation T L begin L end int n T number of vertices insertion from a vector std vector Point V 3 V Point 1 V 1 Point 1 1 1 V 2 Point 2 2 2 n n T insert V begin V end assert n 6 6 points have been inserted assert T is valid checking validity of T Locate type lt int li lj Point p Cell handle c T locate p lt li lj p is the vertex of c of index li assert lt Triangulation VERTEX assert c vertex li point p Vertex handle v c vertex li 1 3 v is another vertex of c Cell handle nc c neighbor li nc neighbor of c opposite to the vertex associated with p nc must have vertex v int nli assert nc has vertex v nli nli is the index of v in nc std ofstream oFileT output std ios out writing file output oFileT T Triangulation T1 std ifstream iFileT output std ios in reading file output iFileT T1 assert T1 is valid assert T1 number of vertices T number of vertices assert T1 number of cells T number of cells return 35 6 2 Changing the vertex base The following two examples show how the user can plug his own vertex base in a triangulation Changing the cell base is similar Adding a color When the user doesn t need to add a type in a vertex which depends on the TriangulationDataStructure 3 e g a Vertex handle or Cell handle then he can use the Triangulation vertex base with info 3 class to add his own information easily in the vertices The example below shows how to add a CGAL Color this way file examples Triangulation 3 example color C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 3 h include CGAL Triangulation vertex base with info 3 h include CGAL IO Color h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base with info 3 CGAL Color K Vb typedef CGAL Triangulation data structure 3 Vb Tds typedef CGAL Delaunay triangulation 3 K Tds Delaunay typedef Delaunay Point Point int main Delaunay T T insert Point T insert Point 1 T insert Point 1 T insert Point 1 T insert Point 2 2 2 T insert Point 1 1 Set the color of finite vertices of degree 6 to red Delaunay Finite vertices iterator vit for vit T finite vertices begin vit T finite vertices end vit if T degree vit 6 vit info CGAL RED return Adding handles When the user needs to add a type in a vertex which depends on the TriangulationDataStructure 3 e g a Vertex handle or Cell handle then he has to derive his own vertex base class as the following example shows file examples Triangulation 3 example adding handles C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 3 h include CGAL Triangulation vertex base 3 h template class GT class Vb CGAL Triangulation vertex base 3 GT class My vertex base public Vb public typedef typename Vb Vertex handle Vertex handle typedef typename Vb Cell handle Cell handle typedef typename Vb Point Point template class TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 typedef My vertex base GT Vb2 Other My vertex base My vertex base const Point p Vb p My vertex base const Point p Cell handle c Vb p c Vertex handle vh Cell handle ch struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation data structure 3 My vertex base K Tds typedef CGAL Delaunay triangulation 3 K Tds Delaunay typedef Delaunay Vertex handle Vertex handle typedef Delaunay Point Point int main Delaunay T Vertex handle v T insert Point Vertex handle v1 T insert Point 1 Vertex handle v2 T insert Point 1 Vertex handle v3 T insert Point 1 Vertex handle v4 T insert Point 2 2 2 Vertex handle v5 T insert Point 1 1 Now we can link the vertices as we like v vh v1 v1 vh v2 v2 vh v3 v3 vh v4 v4 vh v5 v5 vh v return 35 6 3 Use of the Delaunay hierarchy file examples Triangulation 3 example hierarchy C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 3 h include CGAL Triangulation hierarchy 3 h include cassert include vector struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 3 K Vb typedef CGAL Triangulation hierarchy vertex base 3 Vb Vbh typedef CGAL Triangulation data structure 3 Vbh Tds typedef CGAL Delaunay triangulation 3 K Tds Dt typedef CGAL Triangulation hierarchy 3 Dt Dh typedef Dh Vertex iterator Vertex iterator typedef Dh Vertex handle Vertex handle typedef Dh Point Point int main Dh T insertion of points on a 3D grid std vector Vertex handle V for int z z 5 z for int y y 5 y for int x x 5 x V push back T insert Point x y z assert T is valid assert T number of vertices 125 assert T dimension 3 removal of the vertices in random order std random shuffle V begin V end for int i i 125 i T remove V i assert T is valid assert T number of vertices return 35 6 4 Finding the cells in conflict with a point in a Delaunay triangulation file examples Triangulation 3 example find conflicts C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 3 h include CGAL point generators 3 h include vector include cassert struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Delaunay triangulation 3 K Delaunay typedef Delaunay Point Point typedef Delaunay Cell handle Cell handle typedef Delaunay Facet Facet int main Delaunay T CGAL Random points in sphere 3 Point rnd First make sure the triangulation is 3D T insert Point T insert Point 1 T insert Point 1 T insert Point 1 assert T dimension 3 Inserts 1 random points if and only if their insertion in the Delaunay tetrahedralization conflicts with an even number of cells for int i i 1 i Point p rnd Locate the point Delaunay Locate type lt int li lj Cell handle c T locate p lt li lj if lt Delaunay VERTEX continue Point already exists Get the cells that conflict with p in a vector V and a facet on the boundary of this hole in f std vector Cell handle V Facet f T find conflicts p c CGAL Oneset iterator Facet f Get one boundary facet std back inserter V Conflict cells in V if V size 1 Even number of conflict cells T insert in hole p V begin V end f first f second std cout Final triangulation has T number of vertices vertices std endl return 35 6 5 Regular triangulation This example shows the building of a regular triangulation In this triangulation points have an associated weight and some points can be hidden and do not result in vertices in the triangulation Another difference is that a specific traits class has to be used at least at the moment file examples Triangulation 3 example regular C include CGAL Exact predicates inexact constructions kernel h include CGAL Regular triangulation 3 h include CGAL Regular triangulation euclidean traits 3 h include cassert include vector struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Regular triangulation euclidean traits 3 K Traits typedef Traits RT Weight typedef Traits Bare point Point typedef Traits Weighted point Weighted point typedef CGAL Regular triangulation 3 Traits Rt typedef Rt Vertex iterator Vertex iterator typedef Rt Vertex handle Vertex handle int main Rt T insertion of points on a 3D grid std vector Vertex handle V for int z z 5 z for int y y 5 y for int x x 5 x Point p x y z Weight w x y z y x 2 let s say this is the weight Weighted point wp p w V push back T insert wp assert T is valid assert T dimension 3 std cout Number of vertices T number of vertices std endl return 35 7 Design and Implementation History Monique Teillaud started to work on the 3D triangulation packages in 1997 following the design of the 2D triangulation packages The notions of degenerate dimensions and infinite vertex were formalized Tei99 and induced changes in the 2D triangulation packages The packages were first released in CGAL 2 1 They contained basic functionalities on triangulations Delaunay triangulations regular triangulations A first version of removal of a vertex from a Delaunay triangulation was released in CGAL 2 2 However this removal became really robust only in CGAL 2 3 after some research that allowed to deal with degenerate cases quite easily DT 3 Andreas Fabri implemented this revised version of the removal and a faster removal algorithm for CGAL 3 In 2 Sylvain Pion started working on these packages He improved the efficiency of triangulations in CGAL 2 3 and 2 4 in several ways BDP 2 he implemented the Delaunay hierarchy Dev 2 in 2 3 he improved the memory footprint in 2 4 and 3 he also performed work on arithmetic filters DP 3 see Support Library and Kernel to improve the speed of triangulations He changed the design in CGAL 3 allowing users to add handles in his own vertices and cells The authors wish to thank Jean Daniel Boissonnat Olivier Devillers and Mariette Yvinec for helpful discussions BDTY Next chapter 3D Triangulations Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Triangulation_3/Chapter_main.html", "title": "3d triangulations", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Triangulation_3/main.tex' -->\n<html> <head>  \n<title>3D Triangulations</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_35\"></a>\n  \n<h1>Chapter 35<BR>3D Triangulations</h1>\n\n<A NAME=\"chapter-Triangulation3\"></A>\n<EM>Sylvain Pion  and Monique Teillaud</EM><BR>\n\n\n<P>\n\n<img border=0 src=\"./sphere.gif\" align=center width=30%>\n<img border=0 src=\"./grid.gif\" align=center width=30%>\n<P>\n\nThe basic 3D-triangulation class of C<SMALL>GAL</SMALL> is primarily designed to\nrepresent the triangulations of a set of points <MATH><I>A</I></MATH> in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>.  It is\na partition of the convex hull of <MATH><I>A</I></MATH> into tetrahedra whose vertices\nare the points of <MATH><I>A</I></MATH>.  Together with the unbounded cell having the\nconvex hull boundary as its frontier, the triangulation forms a\npartition of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>. Its cells (<MATH><I>3</I></MATH>-faces) are such that two cells\neither do not intersect or share a common facet (<MATH><I>2</I></MATH>-face), edge\n(<MATH><I>1</I></MATH>-face) or vertex (<MATH><I>0</I></MATH>-face).\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>35.1&nbsp;&nbsp;&nbsp;Representation</h2>\n\n<A NAME=\"Triangulation3-sec-intro\"></A>\n<P>\n\nIn order to deal\nonly with tetrahedra, which is convenient for many applications, the\nunbounded cell can be subdivided into tetrahedra by considering that\neach convex hull facet is incident to an <I>infinite cell</I> having as\nfourth vertex an auxiliary vertex called the <I>infinite vertex</I>.  In\nthat way, each facet is incident to exactly two cells and special cases\nat the boundary of the convex hull are simple to deal with.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;</I> of C<SMALL>GAL</SMALL> implements this\npoint of view and therefore considers the triangulation of the set\nof points as a set of finite and infinite tetrahedra.  Notice that the\ninfinite vertex has no significant coordinates and that no\ngeometric predicate can be applied on it.\n<P>\n\nA triangulation is a collection of vertices and cells that are linked\ntogether through incidence and adjacency relations. Each cell gives\naccess to its four incident vertices and to its four adjacent\ncells. Each vertex gives access to one of its incident cells.\n<P>\n\nThe four vertices of a cell are indexed with 0, 1, 2 and 3 in positive\n<A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>, the positive <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> being defined by the <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>\nof the underlying Euclidean space <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> (see\nFigure&nbsp;<A HREF=\"Chapter_main.html#Triangulation3-fig-orient\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). The neighbors of a cell are also\nindexed with 0, 1, 2, 3 in such a way that the neighbor indexed by <MATH><I>i</I></MATH>\nis <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex with the same index.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B><A HREF=\"../Kernel_23_ref/Enum_Orientation.html#Cross_link_anchor_114\">Orientation</A> of a cell (3-dimensional case).\n<A NAME=\"Triangulation3-fig-orient\"></A>\n\n<CENTER>\n<img border=0 src=\"./orient.gif\" align=center alt=\"Orientation of a cell \n(3-dimensional case)\">\n</CENTER>\n<P>\n\nAs in the underlying combinatorial triangulation (see\nChapter&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#chapter-TDS3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>), edges (<MATH><I>1</I></MATH>-faces) and facets (<MATH><I>2</I></MATH>-faces)\nare not explicitly \nrepresented: a facet is given by a cell and an index (the facet\n<I>i</I> of a cell <I>c</I> is the facet of <I>c</I> that is <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to\nthe vertex with index <I>i</I>) and an edge is given by a cell and two\nindices (the edge <I>(i,j)</I> of a cell <I>c</I> is the edge whose\nendpoints are the vertices of <I>c</I> with indices <I>i</I> and\n<I>j</I>). See Figure&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-fig-repres\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<b>Degenerate Dimensions</b>\n\nThe class <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I> can also deal with\ntriangulations whose dimension <MATH><I>d</I></MATH> is less than&nbsp;3. A triangulation of a\nset of points in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> covers the whole space <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> and consists of\ncells having <MATH><I>d+1</I></MATH> vertices: some of them are infinite, they are\nobtained by linking the additional infinite vertex to each facet of\nthe convex hull of the points.\n<UL>\n<LI> <I>dimension 2:</I> when a triangulation only contains\n<A HREF=\"../Kernel_23_ref/Function_coplanar.html#Cross_link_anchor_197\">coplanar</A> points (which is the case when there are only three points), \nit consists of triangular faces.\n<LI> <I>dimension 1:</I> the triangulation contains only <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A> \npoints (which is the case when there are only two points), it consists\nof edges.\n<LI> <I>dimension 0:</I> the triangulation contains only one\nfinite point.\n<LI> <I>dimension -1:</I> this is a convention to handle the case\nwhen the only vertex of the triangulation is the infinite one.\n</UL>\n<P>\n\nThe same cell class is used in all cases: triangular faces in\n2D can be considered as degenerate cells, having only three vertices\n(resp. neighbors) numbered <MATH><I>(0,1,2)</I></MATH>;\nedges in 1D have only two vertices (resp. neighbors) numbered <MATH><I>0</I></MATH> and <MATH><I>1</I></MATH>.\n<P>\n\nThe implicit representation of facets (resp. edges) still holds\nfor degenerate dimensions (<I>i.e.</I> dimensions <MATH><I>&lt;3</I></MATH>): in\ndimension&nbsp;2, each cell has only one facet of index 3, and 3 edges\n<MATH><I>(0,1)</I></MATH>, <MATH><I>(1,2)</I></MATH> and <MATH><I>(2,0)</I></MATH>; in dimension&nbsp;1, each cell has one edge\n<MATH><I>(0,1)</I></MATH>.\n<P>\n\n<b>Validity</b>\n\nA triangulation of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> is said to be <I>locally valid</I> iff\n<P>\n\n<B>(a)-(b)</B> Its underlying combinatorial graph, the triangulation\ndata structure, is <I>locally valid</I> \n(see Section&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> of Chapter&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#chapter-TDS3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>)<BR>\n\n<B>(c)</B> Any cell has its vertices ordered according to positive\n<A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>. See Figure&nbsp;<A HREF=\"Chapter_main.html#Triangulation3-fig-orient\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nWhen the triangulation is degenerated into a triangulation of\ndimension&nbsp;2, the  geometric validity reduces to:\n<P>\n\n<B>(c-2D)</B> For any two adjacent triangles <MATH><I>(u,v,w<SUB>1</SUB>)</I></MATH> and <MATH><I>(u,v,w<SUB>2</SUB>)</I></MATH> with\ncommon edge <MATH><I>(u,v)</I></MATH>, <MATH><I>w<SUB>1</SUB></I></MATH> and <MATH><I>w<SUB>2</SUB></I></MATH> lie on <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> sides of <MATH><I>(u,v)</I></MATH>\nin the plane.\n<P>\n\nWhen all the points are <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A>, this condition becomes:\n<P>\n\n<B>(c-1D)</B> For any two adjacent edges <MATH><I>(u,v)</I></MATH> and <MATH><I>(v,w)</I></MATH>, <MATH><I>u</I></MATH> and\n<MATH><I>w</I></MATH> lie on <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> sides of the common vertex <MATH><I>v</I></MATH> on the line.\n<P>\n\nThe <I>is_valid()</I> method provided in <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I> checks\nthe local validity of a given triangulation. This does not always\nensure global validity [<A HREF=\"../biblio.html#Biblio_mnssssu-cgpvg-96\">MNS<MATH><I><SUP>+</SUP></I></MATH>96</A>, <A HREF=\"../biblio.html#Biblio_dlpt-ccpps-98\">DLPT98</A>] but it is \nsufficient for practical cases.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>35.2&nbsp;&nbsp;&nbsp;Delaunay Triangulation</h2>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> represents a three-dimensional\nDelaunay triangulation.\n<P>\n\nDelaunay triangulations have the specific <I>empty sphere property</I>,\nthat is, the circumscribing sphere of each cell of such a triangulation\ndoes not contain any other vertex of the triangulation in its interior.\nThese triangulations are uniquely defined except in degenerate cases\nwhere five points are cospherical.  Note however that the C<SMALL>GAL</SMALL> implementation\ncomputes a unique triangulation even in these cases.\n<P>\n\nThis implementation is fully dynamic: it supports both insertions of points\nand vertex removal.\nThe user is advised to use the class <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A></I> in\norder to benefit from an increased efficiency for large data sets.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>35.3&nbsp;&nbsp;&nbsp;Regular Triangulation</h2>\n \n<A NAME=\"Triangulation3-sec-class-Regulartriangulation\"></A>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A></I> implements incremental regular\ntriangulations, also known as weighted Delaunay triangulations.\n<P>\n\nLet <MATH><I>S<SUP>(w)</SUP></I></MATH> be a set of weighted points in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>. Let\n<MATH><I>p<SUP>(w)</SUP>=(p,w<SUB>p</SUB>), p <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP>, w<SUB>p</SUB> <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> </I></MATH> and \n<MATH><I>z<SUP>(w)</SUP>=(z,w<SUB>z</SUB>), z <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP>, w<SUB>z</SUB> <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> </I></MATH> be two weighted points. \nA weighted point\n<MATH><I>p<SUP>(w)</SUP>=(p,w<SUB>p</SUB>)</I></MATH> can also be seen as a sphere of center <MATH><I>p</I></MATH> and\nradius <MATH><I>w<SUB>p</SUB></I></MATH>. \nThe <I>power product</I> between <MATH><I>p<SUP>(w)</SUP></I></MATH> and <MATH><I>z<SUP>(w)</SUP></I></MATH> is\ndefined as \n<P ALIGN=CENTER>\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUP>(w)</SUP>,z<SUP>(w)</SUP>) =  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> p-z <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <SUP>2</SUP>-w<SUB>p</SUB>-w<SUB>z</SUB></I></MATH>\n<P>\n\nwhere <MATH><I> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> p-z <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> </I></MATH> is the Euclidean distance between <MATH><I>p</I></MATH> and <MATH><I>z</I></MATH>. \n <MATH><I>p<SUP>(w)</SUP></I></MATH> and <MATH><I>z<SUP>(w)</SUP></I></MATH>\nare said to be <I>orthogonal</I> iff <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUP>(w)</SUP>,z<SUP>(w)</SUP>)\n= 0</I></MATH> (see Figure&nbsp;<A HREF=\"Chapter_main.html#Triangulation3-fig-ortho\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Orthogonal weighted points (picture in 2D).\n<A NAME=\"Triangulation3-fig-ortho\"></A>\n\n<CENTER>\n<img border=0 src=\"./ortho.gif\" align=center alt=\"Orthogonal weighted\npoints (picture in 2D)\"> \n</CENTER>\n<P>\n\nFour weighted points have a unique common orthogonal weighted point\ncalled the <I>power sphere</I>.  The weighted point orthogonal to\nthree weighted points in the plane defined by these three points is\ncalled the <I>power circle</I>. The\n<I>power segment</I> will denote the weighted point orthogonal to\ntwo weighted points on the line defined by these two points.\n<P>\n\nA sphere <MATH><I>z<SUP>(w)</SUP></I></MATH> is said to be\n<I>regular</I> if <MATH><I> <IMG BORDER=0 WIDTH=9 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_forall.gif\"> p<SUP>(w)</SUP> <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> S<SUP>(w)</SUP>,\n<IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUP>(w)</SUP>,z<SUP>(w)</SUP>) <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 0</I></MATH>.\n<P>\n\nA triangulation of <MATH><I>S<SUP>(w)</SUP></I></MATH> is <I>regular</I> if the power spheres\nof all simplices are regular.\n<P>\n\nThe regular triangulation of\n<MATH><I>S<SUP>(w)</SUP></I></MATH> is in fact the projection onto <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> of the convex hull \nof the four-dimensional points <MATH><I>(p, <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> p-O <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <SUP>2</SUP>-w<SUB>p</SUB>),</I></MATH> for\n<MATH><I>p<SUP>(w)</SUP>=(p,w<SUB>p</SUB>) <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> S<SUP>(w)</SUP></I></MATH>. \nNote that all points of <MATH><I>S<SUP>(w)</SUP></I></MATH> do not\nnecessarily appear as vertices of the regular\ntriangulation. To know more about regular triangulations, see for\nexample [<A HREF=\"../biblio.html#Biblio_es-itfwr-96\">ES96</A>].\n<P>\n\nWhen all weights are 0, power spheres are nothing more than\ncircumscribing spheres, and the regular triangulation is exactly the\nDelaunay triangulation.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>35.4&nbsp;&nbsp;&nbsp;Triangulation hierarchy</h2>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A></I> implements a\ntriangulation augmented with a data structure that allows fast point\nlocation queries. Thus, it allows fast construction of the\ntriangulation. As proved in&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:d-dh-02\">Dev02</A>], this structure has an\noptimal behavior when it is built for Delaunay triangulations.\n<P>\n\nNote that, since the algorithms that are provided are randomized, the\nrunning time of constructing a triangulation with a hierarchy may be\nimproved when shuffling the data points.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>35.5&nbsp;&nbsp;&nbsp;Software Design</h2>\n\n<A NAME=\"Triangulation3-sec-design\"></A>\n<P>\n\nThe main classes <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I>, <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> and\n<I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A></I> are connected to each other by the\nderivation diagram shown in Figure&nbsp;<A HREF=\"Chapter_main.html#t3_derivation\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.  This diagram\nalso shows two other classes: <I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_utils_3.html#Cross_link_anchor_1014\">Triangulation_utils_3</A></I>, which provides\na set of tools operating on the indices of vertices in cells,\nand <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A></I>, which implements a hierarchy of\ntriangulations suitable for speeding up point location.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Derivation diagram of the 3D triangulation classes.\n<A NAME=\"t3_derivation\"></A>\n\n<CENTER>\n<img border=0 src=\"./derivation.gif\" align=center\n alt=\"Derivation diagram of the 3D triangulation classes\"> \n</CENTER>\n<P>\n\nThe three main classes (<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I>, <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I>\nand <I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A></I>) provide high-level geometric functionality\nsuch as location of a point in the triangulation&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:dpt-wt-02\">DPT02</A>], insertion\nand possibly removal of a point&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:dt-pvr3d-03\">DT03</A>], and are responsible for the\ngeometric validity.  They are built as layers on top of a triangulation data\nstructure, which stores their combinatorial structure.  This separation between\nthe geometry and the combinatorics is reflected in the software design by the\nfact that these three triangulation classes take two template parameters :\n<P>\n\n<UL>\n<LI> the <B>geometric traits</B> class, which provides the type of points\nto use as well as the elementary operations on them (predicates and\nconstructions).  The concepts for these parameters are described in more\ndetails in Section&nbsp;<A HREF=\"Chapter_main.html#Triangulation3-sec-Traits\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<LI> the <B>triangulation data structure</B> class, which stores their\ncombinatorial structure, described in Section&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> of\nChapter&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#chapter-TDS3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n</UL>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A></I> is parameterized by a class, which at\nthe moment can only be <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I>.  It fetches its\ngeometric traits from this parameter directly.\n<P>\n\n<h3>35.5.1&nbsp;&nbsp;&nbsp;The Geometric Traits Parameter</h3>\n\n<A NAME=\"Triangulation3-sec-Traits\"></A>\n<P>\n\nThe first template parameter of the triangulation class\n<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A>, <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;</I>\nis the geometric traits class, described by the concept\n<I><A HREF=\"../Triangulation_3_ref/Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A></I>.  It must define the types of the geometric objects\n(points, segments, triangles and tetrahedra) forming the triangulation together\nwith a few geometric predicates on these objects: <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> in space,\n<A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> in case of <A HREF=\"../Kernel_23_ref/Function_coplanar.html#Cross_link_anchor_197\">coplanar</A> points, order of <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A> points.\n<P>\n\nIn addition to the requirements described before, the geometric traits\nclass of <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> must define predicates to test for the\n<I>empty sphere property</I>.  It is described by the concept\n<I><A HREF=\"../Triangulation_3_ref/Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A></I>, which refines <I><A HREF=\"../Triangulation_3_ref/Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A></I>.\n<P>\n\nThe kernels provided by CGAL: <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A></I>, <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A></I>,\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A></I>, <I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A></I> and\n<I><A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_12\">Filtered_kernel</A></I> can all be used as models for the geometric traits\nparameter.\nThey supply the user with all the functionalities described for the concepts\n<I><A HREF=\"../Triangulation_3_ref/Concept_TriangulationTraits_3.html#Cross_link_anchor_979\">TriangulationTraits_3</A></I> and\n<I><A HREF=\"../Triangulation_3_ref/Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A></I>.\nIn addition, the predefined kernels\n<I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A></I> and\n<I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel.html#Cross_link_anchor_34\">Exact_predicates_exact_constructions_kernel</A></I>\ncan also be used, the later being recommended when the dual construction is\nused.\n<P>\n\nIn order to be used as the traits class for <I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A></I>,\na class must provide functions to compute the <I>power tests</I>\n(see Section&nbsp;<A HREF=\"Chapter_main.html#Triangulation3-sec-class-Regulartriangulation\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_euclidean_traits_3.html#Cross_link_anchor_983\">Regular_triangulation_euclidean_traits_3</A>&lt;R,Weight&gt;</I> is a traits class \n designed to be used by the class\n<I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Concept_RegularTriangulationTraits_3.html#Cross_link_anchor_981\">RegularTriangulationTraits_3</A>, <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;</I>. It provides\n<I><A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A></I>, a class for weighted points\nneeded by the regular triangulation, which derives from the three dimensional\npoint class <I>R::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A></I>.\nIt supplies the user with all the functionalities \ndescribed for the concept <I><A HREF=\"../Triangulation_3_ref/Concept_RegularTriangulationTraits_3.html#Cross_link_anchor_981\">RegularTriangulationTraits_3</A></I>. \nIt can be used as a traits class for\n<I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Concept_RegularTriangulationTraits_3.html#Cross_link_anchor_981\">RegularTriangulationTraits_3</A>, <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;</I>.\n<P>\n\nThere is also another model of the traits concept,\n<I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_filtered_traits_3.html#Cross_link_anchor_985\">Regular_triangulation_filtered_traits_3</A>&lt;FK&gt;</I>, which is providing filtered\npredicates (exact and efficient).\n<P>\n\n<h3>35.5.2&nbsp;&nbsp;&nbsp;The Triangulation Data Structure Parameter</h3>\n\n<A NAME=\"Triangulation3-sec-tds\"></A>\n<P>\n\nThe second template parameter of the main classes (<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I>,\n<I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> and <I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A></I>) is a\ntriangulation data structure class.  This class can be seen as a container for\nthe cells and vertices maintaining incidence and adjacency relations (see\nChapter&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#chapter-TDS3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).  A model of this triangulation data structure is\n<I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A></I>,\nand it is described by the <I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I> concept\n.  This model is itself\nparameterized by a vertex base and a cell base classes, which gives the\npossibility to customize the vertices and cells used by the triangulation data\nstructure, and hence by the geometric triangulation using it.  Depending on the\nkind of triangulation used, the requirements on the vertex and cell base\nclasses vary, and are expressed by various concepts, following the refinement\ndiagram shown in Figure&nbsp;<A HREF=\"Chapter_main.html#T3-concept-hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Concepts refinement hierarchy for the vertex and cell base classes\nparameters.\n<A NAME=\"T3-concept-hierarchy\"></A>\n\n<CENTER>\n<img border=0 src=\"./concept_hierarchy.gif\" align=center\n alt=\"Concepts refinement hierarchy for the vertex and cell base classes\nparameters.\">\n</CENTER>\n<P>\n\nA default value for the triangulation data structure parameter is provided in\nall the triangulation classes, so it need not be specified by the user unless\nhe wants to use a different triangulation data structure or a different vertex\nor cell base class.\n<P>\n\n<h3>35.5.3&nbsp;&nbsp;&nbsp;Flexibility of the Design</h3>\n<P>\n\nIn order to satisfy as many uses as possible, a design has been selected that\nallows to exchange different parts to meet the users' needs, while still\nre-using a maximum of the provided functionalities.  We have already seen that\nthe main triangulation classes are parameterized by a geometric traits class\nand a triangulation data structure (TDS), so that each of them can be\ninterchanged with alternate implementations.\n<P>\n\nThe most useful flexibility is the ability given to the user to add his own\ndata in the vertices and cells by providing his own vertex and cell base\nclasses to <I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A></I>.  The\nFigure&nbsp;<A HREF=\"Chapter_main.html#T3-fig-layers\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> shows in more detail the flexibility that is\nprovided, and the place where the user can insert his own vertex and/or cell\nbase classes.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Triangulation software design.\n<A NAME=\"T3-fig-layers\"></A>\n\n<CENTER>\n<img border=0 src=\"./design.gif\" align=center\n alt=\"Triangulation software design\">\n</CENTER>\n<P>\n\n<h3>35.5.4&nbsp;&nbsp;&nbsp;Backward compatibility</h3>\n\n<A NAME=\"T3-sec-compat\"></A>\n<P>\n\nStarting with C<SMALL>GAL</SMALL> release 3.0, the design of the triangulation data\nstructure has been changed in order to give the possibility to store handles\n(an entity akeen to pointers) directly in the vertex and cell base classes.\nPreviously, <TT>void*</TT> pointers were stored there instead, and later\nconverted internally to handles, but this happened to be too restrictive for\nsome uses.\n<P>\n\nThe difference is visible to the user when he provides his own vertex or cell\nbase class.  Previously, something like the following had to be written:\n<P>\n\n<pre class=\"ExampleCode\">\n...\ntemplate &lt; class GT &gt;\nclass My_vertex\n  : public Triangulation_vertex_base&lt;GT&gt;\n{\n  typedef Triangulation_vertex_base&lt;GT&gt;  Vb;\npublic:\n  typedef typename Vb::Point             Point;\n\n  My_vertex() {}\n  My_vertex(const Point&amp;p)          : Vb(p) {}\n  My_vertex(const Point&amp;p, void *c) : Vb(p, c) {}\n...\n};\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;double&gt;                                               GT;\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A>&lt;My_vertex&lt;GT&gt;,\n                                       <A HREF=\"../Triangulation_3_ref/Class_Triangulation_cell_base_3.html#Cross_link_anchor_990\">Triangulation_cell_base_3</A>&lt;GT&gt; &gt;  My_TDS;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;GT, My_TDS&gt;                                     Tr;\n...\n</pre>\n<P>\n\nWhile now, there are three possibilities.  The simplest one is to use the\nclass <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_with_info_3.html#Cross_link_anchor_996\">Triangulation_vertex_base_with_info_3</A></I>, and this approach is\nillustrated in a following subsection&nbsp;<A HREF=\"Chapter_main.html#Triangulation3-sec-examples-color\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nThe most complicated one, and probably useless for almost all cases, is to\nwrite a vertex base class from scratch, following the documented requirements.\nThis is mostly useless because most of the time it is enough to derive from\nthe models that C<SMALL>GAL</SMALL> provides, and add the desired features.\nIn this case, when the user needs to access some type that depends on the\ntriangulation data structure (typically handles), then he should write\nsomething like:\n<pre class=\"ExampleCode\">\n...\ntemplate &lt; class GT, class Vb = Triangulation_vertex_base&lt;GT&gt; &gt;\nclass My_vertex\n  : public Vb\n{\npublic:\n  typedef typename Vb::Point           Point;\n  typedef typename Vb::Cell_handle     Cell_handle;\n\n  template &lt; class TDS2 &gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other  Vb2;\n    typedef My_vertex&lt;GT, Vb2&gt;                             Other;\n  };\n\n  My_vertex() {}\n  My_vertex(const Point&amp;p)                : Vb(p) {}\n  My_vertex(const Point&amp;p, Cell_handle c) : Vb(p, c) {}\n...\n};\n... // The rest has not changed\n</pre>\n<P>\n\nThe changes that need to be made are the following:\n<UL>\n<LI> <I>My_vertex</I> is now parameterized by the vertex base class it\n        derives from.\n<LI> a nested template class <I>Rebind_TDS</I> must be defined.\n<LI> <TT>void*</TT> must be changed to <I>Cell_handle</I>, and you need to\n        extract the <I>Cell_handle</I> type from the vertex base class that\n        <I>My_vertex</I> derives from.\n</UL>\n<P>\n\nThe situation is exactly similar for cell base classes.\nSection&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> provides more detailed information.\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>35.6&nbsp;&nbsp;&nbsp;Examples</h2>\n\n<A NAME=\"Triangulation3-sec-examples\"></A>\n\n<h3>35.6.1&nbsp;&nbsp;&nbsp;Basic example</h3>\n\nThis example shows the incremental construction of a 3D triangulation, the\nlocation of a point and how to perform elementary operations on indices in a\ncell. It uses the default parameter of the <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I> class.\n<P>\n\n<pre class=\"ExampleCode\">// examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_simple.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_971\">CGAL::Triangulation_3</A>&lt;K&gt;      Triangulation;\n\ntypedef Triangulation::Cell_handle    Cell_handle;\ntypedef Triangulation::Vertex_handle  Vertex_handle;\ntypedef Triangulation::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A>    <A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A>;\ntypedef Triangulation::Point          Point;\n\nint main()\n{\n  // construction from a list of points :\n  std::list&lt;Point&gt; L;\n  L.push_front(Point(0,0,0));\n  L.push_front(Point(1,0,0));\n  L.push_front(Point(0,1,0));\n\n  Triangulation T(L.begin(), L.end());\n\n  int n = T.number_of_vertices();\n\n  // insertion from a vector :\n  std::vector&lt;Point&gt; V(3);\n  V[0] = Point(0,0,1);\n  V[1] = Point(1,1,1);\n  V[2] = Point(2,2,2);\n\n  n = n + T.insert(V.begin(), V.end());\n\n  assert( n == 6 );       // 6 points have been inserted\n  assert( T.is_valid() ); // checking validity of T\n\n  <A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> lt;\n  int li, lj;\n  Point p(0,0,0);\n  Cell_handle c = T.locate(p, lt, li, lj);\n  // p is the vertex of c of index li :\n  assert( lt == Triangulation::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">VERTEX</A> );\n  assert( c-&gt;vertex(li)-&gt;point() == p );\n\n  Vertex_handle v = c-&gt;vertex( (li+1)&amp;3 );\n  // v is another vertex of c\n  Cell_handle nc = c-&gt;neighbor(li);\n  // nc = neighbor of c <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex associated with p\n  // nc must have vertex v :\n  int nli;\n  assert( nc-&gt;has_vertex( v, nli ) );\n  // nli is the index of v in nc\n\n  std::ofstream oFileT(&quot;output&quot;,std::ios::out);\n  // writing file output; \n  oFileT &lt;&lt; T; \n\n  Triangulation T1;\n  std::ifstream iFileT(&quot;output&quot;,std::ios::in);\n  // reading file output; \n  iFileT &gt;&gt; T1; \n  assert( T1.is_valid() );\n  assert( T1.number_of_vertices() == T.number_of_vertices() );\n  assert( T1.number_of_cells() == T.number_of_cells() );\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>35.6.2&nbsp;&nbsp;&nbsp;Changing the vertex base</h3>\n\nThe following two examples show how the user can plug his own vertex base in a\ntriangulation.  Changing the cell base is similar.\n<P>\n\n<h4>Adding a color</h4>\n\n<A NAME=\"Triangulation3-sec-examples-color\"></A>\nWhen the user doesn't need to add a type in a vertex which depends on the\n<I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I> (e.g. a <I>Vertex_handle</I> or\n<I>Cell_handle</I>), then he can use the\n<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_with_info_3.html#Cross_link_anchor_996\">Triangulation_vertex_base_with_info_3</A></I> class to add his own information\neasily in the vertices.  The example below shows how to add a <I><A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A></I>\nthis way.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_color.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_with_info_3.html#Cross_link_anchor_996\">Triangulation_vertex_base_with_info_3</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1754\">Color</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_with_info_3.html#Cross_link_anchor_995\">CGAL::Triangulation_vertex_base_with_info_3</A>&lt;<A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A>, K&gt; Vb;\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;Vb&gt;                    Tds;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K, Tds&gt;                      Delaunay;\n\ntypedef Delaunay::Point   Point;\n\nint main()\n{\n  Delaunay T;\n\n  T.insert(Point(0,0,0));\n  T.insert(Point(1,0,0));\n  T.insert(Point(0,1,0));\n  T.insert(Point(0,0,1));\n  T.insert(Point(2,2,2));\n  T.insert(Point(-1,0,1));\n\n  // Set the color of finite vertices of degree 6 to red.\n  Delaunay::Finite_vertices_iterator vit;\n  for (vit = T.finite_vertices_begin(); vit != T.finite_vertices_end(); ++vit)\n      if (T.degree(vit) == 6)\n          vit-&gt;info() = CGAL::RED;\n\n  return 0;\n}\n</pre>\n<P>\n\n<h4>Adding handles</h4>\n\nWhen the user needs to add a type in a vertex which depends on the\n<I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I> (e.g. a <I>Vertex_handle</I> or\n<I>Cell_handle</I>), then he has to derive his own vertex base class,\nas the following example shows.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_adding_handles.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994\">Triangulation_vertex_base_3</A>.h&gt;\n\ntemplate &lt; class GT, class Vb = <A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_3.html#Cross_link_anchor_993\">CGAL::Triangulation_vertex_base_3</A>&lt;GT&gt; &gt;\nclass My_vertex_base\n  : public Vb\n{\npublic:\n  typedef typename Vb::Vertex_handle  Vertex_handle;\n  typedef typename Vb::Cell_handle    Cell_handle;\n  typedef typename Vb::Point          Point;\n\n  template &lt; class TDS2 &gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other  Vb2;\n    typedef My_vertex_base&lt;GT, Vb2&gt;                        Other;\n  };\n\n  My_vertex_base() {}\n\n  My_vertex_base(const Point&amp; p)\n    : Vb(p) {}\n\n  My_vertex_base(const Point&amp; p, Cell_handle c)\n    : Vb(p, c) {}\n\n  Vertex_handle   vh;\n  Cell_handle     ch;\n};\n\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;My_vertex_base&lt;K&gt; &gt;    Tds;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K, Tds&gt;                      Delaunay;\n\ntypedef Delaunay::Vertex_handle    Vertex_handle;\ntypedef Delaunay::Point            Point;\n\nint main()\n{\n  Delaunay T;\n\n  Vertex_handle v0 = T.insert(Point(0,0,0));\n  Vertex_handle v1 = T.insert(Point(1,0,0));\n  Vertex_handle v2 = T.insert(Point(0,1,0));\n  Vertex_handle v3 = T.insert(Point(0,0,1));\n  Vertex_handle v4 = T.insert(Point(2,2,2));\n  Vertex_handle v5 = T.insert(Point(-1,0,1));\n\n  // Now we can link the vertices as we like.\n  v0-&gt;vh = v1;\n  v1-&gt;vh = v2;\n  v2-&gt;vh = v3;\n  v3-&gt;vh = v4;\n  v4-&gt;vh = v5;\n  v5-&gt;vh = v0;\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>35.6.3&nbsp;&nbsp;&nbsp;Use of the Delaunay hierarchy</h3>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_hierarchy.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A>.h&gt;\n\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_3.html#Cross_link_anchor_993\">CGAL::Triangulation_vertex_base_3</A>&lt;K&gt;             Vb;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_vertex_base_3.html#Cross_link_anchor_997\">CGAL::Triangulation_hierarchy_vertex_base_3</A>&lt;Vb&gt;  Vbh;\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;Vbh&gt;        Tds;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K,Tds&gt;            Dt;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_975\">CGAL::Triangulation_hierarchy_3</A>&lt;Dt&gt;              Dh;\n\ntypedef Dh::Vertex_iterator Vertex_iterator;\ntypedef Dh::Vertex_handle   Vertex_handle;\ntypedef Dh::Point           Point;\n\nint main()\n{\n  Dh T;\n\n  // insertion of points on a 3D grid\n  std::vector&lt;Vertex_handle&gt; V;\n  \n  for (int z=0 ; z&lt;5 ; z++)\n    for (int y=0 ; y&lt;5 ; y++)\n      for (int x=0 ; x&lt;5 ; x++) \n\t  V.push_back(T.insert(Point(x,y,z)));\n\n  assert( T.is_valid() );\n  assert( T.number_of_vertices() == 125 );\n  assert( T.dimension() == 3 );\n\n  // removal of the vertices in random order\n  std::random_shuffle(V.begin(), V.end());\n\n  for (int i=0; i&lt;125; ++i)\n    T.remove(V[i]);\n\n  assert( T.is_valid() );\n  assert( T.number_of_vertices() == 0 );\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>35.6.4&nbsp;&nbsp;&nbsp;Finding the cells in conflict with a point in a Delaunay\ntriangulation</h3>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_find_conflicts.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K&gt;        Delaunay;\ntypedef Delaunay::Point                          Point;\ntypedef Delaunay::Cell_handle                    Cell_handle;\ntypedef Delaunay::Facet                          Facet;\n\nint main()\n{\n  Delaunay T;\n  <A HREF=\"../Generator_ref/Class_Random_points_in_sphere_3.html#Cross_link_anchor_1697\">CGAL::Random_points_in_sphere_3</A>&lt;Point&gt; rnd;\n\n  // First, make sure the triangulation is 3D.\n  T.insert(Point(0,0,0));\n  T.insert(Point(1,0,0));\n  T.insert(Point(0,1,0));\n  T.insert(Point(0,0,1));\n\n  assert(T.dimension() == 3);\n\n  // Inserts 100 random points if and only if their insertion\n  // in the Delaunay tetrahedralization conflicts with\n  // an even number of cells.\n  for (int i = 0; i != 100; ++i) {\n    Point p = *rnd++;\n\n    // Locate the point\n    Delaunay::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> lt;\n    int li, lj;\n    Cell_handle c = T.locate(p, lt, li, lj);\n    if (lt == Delaunay::<A HREF=\"../Planar_map_ref/Class_Planar_map_2#Enum_Locate_type\">VERTEX</A>)\n      continue; // Point already exists\n\n    // Get the cells that conflict with p in a vector V,\n    // and a facet on the boundary of this hole in f.\n    std::vector&lt;Cell_handle&gt; V;\n    Facet f;\n\n    T.find_conflicts(p, c,\n                     <A HREF=\"../STL_Extension_ref/Class_Oneset_iterator.html#Cross_link_anchor_1455\">CGAL::Oneset_iterator</A>&lt;Facet&gt;(f), // Get one boundary facet\n                     std::back_inserter(V));          // Conflict cells in V\n\n    if ((V.size() &amp; 1) == 0)  // Even number of conflict cells ?\n      T.insert_in_hole(p, V.begin(), V.end(), f.first, f.second);\n  }\n\n  std::cout &lt;&lt; &quot;Final triangulation has &quot; &lt;&lt; T.number_of_vertices()\n            &lt;&lt; &quot; vertices.&quot; &lt;&lt; std::endl;\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>35.6.5&nbsp;&nbsp;&nbsp;Regular triangulation</h3>\n\nThis example shows the building of a regular triangulation.  In this\ntriangulation, points have an associated weight, and some points can\nbe hidden and do not result in vertices in the triangulation.\nAnother difference is that a specific traits class has to be used\n(at least at the moment).\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_regular.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_euclidean_traits_3.html#Cross_link_anchor_983\">Regular_triangulation_euclidean_traits_3</A>.h&gt;\n\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_euclidean_traits_3.html#Cross_link_anchor_982\">CGAL::Regular_triangulation_euclidean_traits_3</A>&lt;K&gt;   Traits;\n\ntypedef Traits::RT                                          Weight;\ntypedef Traits::Bare_point                                  Point;\ntypedef Traits::<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>                              <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>;\n\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_977\">CGAL::Regular_triangulation_3</A>&lt;Traits&gt;               Rt;\n\ntypedef Rt::Vertex_iterator                                 Vertex_iterator;\ntypedef Rt::Vertex_handle                                   Vertex_handle;\n\nint main()\n{\n  Rt T;\n\n  // insertion of points on a 3D grid\n  std::vector&lt;Vertex_handle&gt; V;\n\n  for (int z=0 ; z&lt;5 ; z++)\n    for (int y=0 ; y&lt;5 ; y++)\n      for (int x=0 ; x&lt;5 ; x++) {\n\t  Point p(x, y, z);\n          Weight w = (x+y-z*y*x)*2.0; // let's say this is the weight.\n\t  <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> wp(p, w);\n\t  V.push_back(T.insert(wp));\n      }\n\n  assert( T.is_valid() );\n  assert( T.dimension() == 3 );\n\n  std::cout &lt;&lt; &quot;Number of vertices : &quot; &lt;&lt; T.number_of_vertices() &lt;&lt; std::endl;\n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>35.7&nbsp;&nbsp;&nbsp;Design and Implementation History</h2>\n<P>\n\nMonique Teillaud started to work on the 3D triangulation packages in\n1997, following the design of the 2D triangulation packages. The\nnotions of degenerate dimensions and infinite vertex were formalized\n[<A HREF=\"../biblio.html#Biblio_t-tdtc-99\">Tei99</A>] and induced changes in the 2D triangulation\npackages. The packages were first released in CGAL 2.1. They contained\nbasic functionalities on triangulations, Delaunay triangulations,\nregular triangulations.\n<P>\n\nA first version of removal of a vertex from a Delaunay triangulation\nwas released in CGAL 2.2. However, this removal became really robust\nonly in CGAL 2.3, after some research that allowed to deal with\ndegenerate cases quite easily [<A HREF=\"../biblio.html#Biblio_cgal:dt-pvr3d-03\">DT03</A>]. Andreas Fabri\nimplemented this revised version of the removal, and a faster removal\nalgorithm for CGAL 3.0.\n<P>\n\nIn 2000, Sylvain Pion started working on these packages.  He improved\nthe efficiency of triangulations in CGAL 2.3 and 2.4 in several ways\n[<A HREF=\"../biblio.html#Biblio_cgal:bdpty-tc-02\">BDP<MATH><I><SUP>+</SUP></I></MATH>02</A>]: he implemented the Delaunay hierarchy\n[<A HREF=\"../biblio.html#Biblio_cgal:d-dh-02\">Dev02</A>] in 2.3, he improved the memory footprint in 2.4 and\n3.0, he also performed work on arithmetic filters [<A HREF=\"../biblio.html#Biblio_cgal:dp-eegpd-03\">DP03</A>]\n(see Support Library and <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>) to improve the speed of\ntriangulations.\n<P>\n\nHe changed the design in CGAL 3.0, allowing users to add handles in\nhis own vertices and cells.\n<P>\n\nThe authors wish to thank Jean-Daniel Boissonnat, Olivier Devillers\nand Mariette Yvinec for helpful discussions [<A HREF=\"../biblio.html#Biblio_bdty-tcgal-00\">BDTY00</A>].\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Triangulation_3_ref/Chapter_intro.html\">3D Triangulations</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_35!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38197.0}