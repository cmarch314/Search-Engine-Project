{"text": "Statements Introduction to Computer Science I III ICS 21 22 23 Introduction Statements are like complete imperative sentences in Java each commands Java to perform some action Just as we said that Java evaluates expressions we say that Java executes statements We already have studied the Java declaration statement which declares variables and optionally initializes them We will classify many statements as control structures such statements control conditionally by repetition the execution of other statements In this lecture we will first learn how to write the simplest kind of statement in Java the expression statement and the simplest control structure in Java the block statement We will also begin discussing two analysis tools hand simulation via trace tables and statement boxing which is the statement equivalent of oval diagrams for expressions Then we will learn about Java s most important control structures starting with if statements for decisions and simple for break statements for looping We will extend our analysis tools trace tables and boxing to cover these statements Eventually we will generalize the for loop and cover two variants of looping while and do statements Finally we will begin learning about Java s try catch statement a control structure that programmers use to process exceptions Sometimes when an operator or method fails by throwing an exception it does not denote a failure of the program but is just a signal to the program that it must take some special action We will continue exploring the use of the try catch statement in our next lecture in the context of file I O Thus we can summarize the language features that we learn in this lecture by statement local declaration statement expression statement block statement if statement for statement break statement while statement do statement try catch statement We will explore the semantics of the following control structures in detail block execute a sequence of statements in order if decide which statement to execute for while do loop repeatedly execute a statement break terminate execution of a loop try catch execute a sequence of statements if one throws an exception execute an alternative sequence of statements Declaring Variables review and extension We have already discussed most aspects of the declaration statement in depth Recall that the simplest declarations start with the type of the variable followed by the name of the variable ended by a semicolon In more complex variable declarations we can specify multiple variable names each declared to be the same type the one that starts the declaration and each variable can be initialized to a value We originally specified the EBNF for each declarator as variable declarator identifier expression and said that expression could be only a literal the only kind of expression we knew at that time Now we know about much more complicated expressions including literals variables operators and methods we can use all these to declare the initial values for variables Pragmatically most intializations use either literals or calls to the Prompt methods but other form arise less frequently Here are some examples int a int b Prompt forInt Enter b int c b int d Math max c 1 1 Here the declation of a is intialized using the literal the declation of b is initialized to the result returned by calling the Prompt forInt method the declation of c is initialized using b the value of a previous declared and intialized variable finally the declation of d is initialized to the result returned by an expression involving a method call operator literal and the value of a previously declared variable c In addition Java allows the keyword final to appear optionally in local variable declaration statement final type variable declarators Semantically if such a declaration includes final then all the variables that it declares must include an initializer and the value they store must never be changed That is we cannot use any state change operators on final variables If we declared final double PI 3 14159265358979323846 Then Java would detect and report an error if we later wrote PI 3 Thus we can use final to declare named constants whose value is guaranteed by Java not to change Expression Statements We can make an expression into expression statement by appending a semicolon at its end Such a statement tells Java to evaluate the expression The EBNF rule for expression statements is simply expression statement expression In fact by discarding the option we can write just the semicolon as the simplest kind of expression statement it is a statement that does nothing But Java imposes one important syntax constraint on expression statements if the expression option is included The expression must apply a state change operator or a method call last in the expression Thus the following statements are all legal examples of expression statements each satisfies this syntax constraint average score1 score2 score3 3 gameCount counter1 counter2 counter3 System out println You have played gameCount games Recall that most state change operators have very low precedence so they will naturally be evaluated last in an expression statement Methods whose prototype lists void as the type of the result don t return a result anyway Such methods e g System out println are often called last when evaluating expression statements Note that x 1 is NOT a legal expression statement the last operator that it applies is which computes a value but does not process this value further e g doesn t store it anywhere doesn t print it Writing such an expression serves no purpose and the Java compiler detects and reports an error in this case Finally notice that this syntax constraint still allows Prompt forInt Enter values as a legal expression statement even though this method returns an int result which is not processed further Block Statements and scope Some airlines restrict you to one carry on bag If you show up with three small bags they won t let you on the plane but if you buy a fourth big bag and put your original three into the fourth everything will be fine Java s syntax sometimes forces this same kind of behavior There are places mostly inside the control structures we will study later in this reading where only one statement is allowed if you want multiple statements there you must put them inside one big statement That single big statement is called a block statement of sometimes just a block The EBNF rule for blocks is block statement statement In this EBNF rule the outer braces stand for themselves the inner ones mean repetition That is blocks are some number of statements enclosed in braces So a block itself is a statement inside which we can put other statements Although we write this EBNF rule on one line block statements in our code often span many lines with each statement inside the block appearing on its own line indented in the braces Semantically Java executes a block by sequentially executing the statements that it contains in the exact same order that they appear in the block When giving directions to humans or computers often the order in which the directions are followed is critical If the directions say To disarm the bomb cut the blue wire and then cut the red wire it would not be a good idea for us to change the order in which these wires are cut If a statement inside a block declares a variable that variable can be used in subsequent statements inside that block after Java executes all the statements in a block the block is finished executing and ALL variables declared inside the block become undeclared So such variables are called local variables because they exist only locally inside the block while its statements are executing Technically we call all those places that a variable can be used the scope of that variable So the scope of local declarations in blocks include all subsequence statements in that block Blocks themselves can be nested Any variables declared in an outer block can be used in an inner block For example Outer block int x 1 Inner block System out println x Refers to x in outer block x 3 Refers to x in outer block System out println x This example illustrates that the scope of the variable x includes the whole outer block which includes its inner block too The inner block is just one statement that is included in the outer block which is itself one bigger statement In this example Java prints 1 followed by 3 If we had moved the declaration from the outer block to the start of the inner block Java would detect and report an error at compile time Outer block Inner block int x 1 System out println x Refers to x in inner block x 3 Refers to x in inner block System out println x Error the x in the inner block is undeclared for this statement With this placement the variable x would not be accessible outside the inner block so it would be unknown in the final print method The scope of x is just the inner block in which it is declared Putting Everything Together Finally putting together everything that we have learned about Java the following block contains a variety of statements that perform a simple computation declaring variables prompting the user for values to store in these variables by calling a method performing a simple calculation with these variables storing the result in another variable with a state change operator and displaying the result in the console window double gravity meter sec sec double height meters double time sec Input gravity Prompt forDouble Enter gravity in m s s height Prompt forDouble Enter height of drop in m Calculate time Math sqrt 2 height gravity Output System out println System out println Drop time time secs Note that by intializing variables when they are declared we could simplify this code writing it as follows Both blocks ultimate produce the same results Input double gravity Prompt forDouble Enter gravity in m s s double height Prompt forDouble Enter height of drop in m Calculate double time Math sqrt 2 height gravity Output System out println System out println Drop time time secs In fact there is no need in this program for variables at all We can squeeze this entire program down to just one statement using the n escape sequence inside one huge 4 line output statement System out println nDrop time Math sqrt 2 Prompt forDouble Enter height of drop in m Prompt forDouble Enter gravity in m s s secs Although this program is the smallest yet it is a bit complicated to follow the calculation which includes two prompts to the user as part of the formula being computed Thus while smaller is generally better it isn t here sometimes storing partial calculations in nicely named variables helps us to write clearer easier to understand programs a main goal of ICS 21 Of course if the program needs to use the values entered by the user more than once we should store them in variables to avoid reprompting the user for the same information multiple times Hand Simulating State Changes As programmers we must be able to analyze our programs to verify that they are correct or detect where bugs occur the hard part and fix them an easier part The most important way to analyze code is to be able to hand simulate it The input to a hand simulation is Variables and their current values called the initial state A block of code a sequence of statements If needed values that the user enters to prompts on the console The output to a hand simulation is The same variables and their resulting values and the contents of the console called the final state During a hand simulation we construct a trace table of state changes for each statement executed in the block of code these include changes to the states of variables and changes to the state of the console what input output the program does Here is a simple example no input output of such a trace table Assume int x 5 int y 8 and the block x y y x If beginning students are asked to predict what the code does the most common response is that it swaps the values in x and y Let s see what really happens using a trace table note that a table cell shows the value stored in a variable after the statement on its line is finished StatementxyConsoleInitial States58 x y 8 y x 8 So we see that the values in the variables are not swapped but that y s initial value ends up stored in both x and y In some sense the simplest thing to do with two variables is to exchange their values yet the intuitive way to write code for this task is incorrect Don t gloss over this observation because it is very important The kind of reasoning a programmer does about state changes in code is very different from the kind of reasoning a mathematician does about equations One correct way to swap the values stored in two variables is int temp x x y y temp and the hand simulation illustrating its correctness using the same initial state StatementxytempConsoleInitial States58Undeclared int temp x 5 x y 8 y temp 5Undeclared Note how temp is shown as undeclared before the block is executed and also becomes undeclared after Java finishes executing the block But temp plays a crucial part in the computation while Java is executing the statements in the block that it is declared in As a final example let s examine the trace table for a block that does I O too Here there are no variables in the initial state the block to execute is double x y x Prompt forDouble Enter x y Math pow x 3 System out println x cubed y Finally when prompted the user will enter a 5 1 on the console StatementxyConsoleInitial StatesUndeclaredUndeclared double x y x Prompt forDouble Enter x 5 1 Enter x 5 1y Math pow x 3 132 651 System out println x cubed y UndeclaredUndeclared5 1 cubed 132 651 Here the Console column shows what is on each line on the first line the prompt and the value that the user enters on the second line the answer This is certainly a lot of work for such a simple example but if you can easily write such trace tables you can use them to debug code that has much subtler errors Boxing Statements Just as we used oval diagrams to understand the structure of expressions and their subexpressions we will use box diagrams to understand statements and in the case of control structures their substatements Right now we know three kinds of statements declaration statements expression statements and block statements Declaration statements and expression statements contain never contain substatements block statements contain substatements the statements that the block executed sequentially The example below includes multiple occurences of each of these kinds of statements Each statement appears inside a box Practice the skill of boxing statements Learn to see statements inside of statements the way a programmer does Notice how consistent indenting in the code makes this task easier if Statements In Java if statements allow us to choose whether or not to execute another statement or which one of many statements to execute like both the option and alternative forms in EBNF There are three forms of if statements in Java if if else cascaded if or cascaded if else The general form of all if statements is given by one EBNF rule if statement if expression statement else statement As a syntax constraint expression must result in a boolean value if it doesn t the Java compiler detects and reports this error Note that both if and else are keywords in Java and the test expression no matter how simple or complicated must always appear inside parentheses Finally although we write this EBNF rule on one line we write if statements in code that span at least two and often many more lines and contain indented statements An if statement discarding the option decides whether or not to execute its statement We write it as if test statement Recall that statement can also be a block Two if statement examples are if x x x if myNumber rouletteNumber myWins myPurse stakes Notice where the opening and closing brace appear for this block this is the standard style that we will always use for blocks inside if statements Semantically Java executes an if statement as follows Evaluate the test expression If it is true execute the single statement after the test If it is false skip the single statement after the test So if the test evaluates to true in the second example Java executes the block statement it executes the block by sequentially executing the two expression statements that it contains If the test evaluates to false in the second example Java skips the block statement executing neither of the statements that it contains An if else statement including the option decides which one of its two statements to execute We write it as if test statement1 else statement2 Recall that statement1 and or statement2 can also be a block Two example if else statements are if x 2 is x is even x x 2 else x 3 x 1 if x y min y max x else min x max y Semantically Java executes an if else statement as follows Evaluate the test expression If it is true execute statement1 which appears directly after the test then skip statement2 If it is false skip statement1 then execute statement2 which appears directly after the keyword else So in if else statements Java always executes one of the two substatements that it controls This is a bit different from the plain if statement which decides whether or not to execute the one statement that it controls A cascaded if or cascaded if else decides which one if any of many statements to execute The general form of the cascade if in Java is if test1 statement1 else if test2 statement2 else if test3 statement3 else else if testN statementN or if test1 statement1 else if test2 statement2 else if test3 statement3 else else if testN statementN else statementN 1 A cascaded if is built from many if else statements where each of statements in the else part is another if else statement except possibly the lst one An example cascaded if statement assuming the declaration char grade is if testScore 9 grade A else if testScore 8 grade B else if testScore 7 grade C else if testScore 6 grade D else grade F Semantically Java executes a cascaded if statement as follows Evaluate the first test expression If it is true execute the statement after the test and terminate the cascaded if don t check any more tests or execute any more statements If it is false evaluate the second test expression If it is true execute the statement after the test and terminate the cascaded if don t check any more tests or execute any more statements Continue following rules of this form until a true test is found or the last test is evaluated If the last test is true execute the statement after the test and terminate the cascaded if there are no more tests to check If the last test is false and it is an if statement terminate the cascaded if if it is an if else statement execute the statement after the else keyword So in the cascaded if exactly one statement the one after after the first true test is executed if no tests are true either no statements are executed when the last statement is an if or the statement after the last else is executed Graphically we can summarize the control flow in the three kinds of ifs as Hand Simulating if statements We can extend our use of trace tables to hand simulations of if statements We include a special Explanation column to indicate the result of evaluating test and which statement Java executes next Let s write two trace tables for hand simulating the first if statement shown above StatementxConsoleExplanationInitial State 5 if x true execute next statementx x 5 if finished StatementxConsoleExplanationInitial State5 if x false skip next statement if finished Next let s write two trace tables for hand simulating the second if else statement shown above StatementxyminmaxConsoleExplanationInitial State53 if x y true execute next statementmin y 3 1st statement in blockmax x 5 2nd statement in block block and if finished StatementxyminmaxConsoleExplanationInitial State35 if x y false execute statement after elsemin x 3 1st statement in blockmax y 5 2nd statement in block block and if finished What is the trace table for this example if the values stored in x and y are equal Does it produce the correct result Can you change the test to and still always get the same result Can there be two different ways of getting the same result Finally let s write a trace table for hand simulating the cascaded if statement shown above StatementtestScoregradeConsoleExplanationInitial State73 if testScore 9 false execute if in elseif testScore 8 false execute if in elseif testScore 7 true execute next statementgrade C C cascaded if finished A Clock Example Let s take a quick look at an interesting task that combines all the statements that we have studied Assume that we have declared the following variables for a military style clock e g represents midnight 9 3 represents 9 3am 14 23 represents 2 23 pm and 23 59 represents 11 59pm int minute in the range 59 inclusive int hour in the range 23 inclusive Also assume that the method emitBeeps takes a single int operand and emits that many beeps Finally assume that the following code is called once a minute by the operating system when we study Java threads we will learn how to arrange for such an action to occur repeatedly if minute 59 minute else emitBeeps hour 1 minute if hour 23 hour else hour Each time the code is called it advances minute and hour if necssary ensuring they store only legal values on the hour the code beeps that many times once at 1 am twice at 2am 12 times at noon 13 times at 1pm and 24 times at midnight Let s write two trace tables for hand simulating this code in two different initial situations first at 1 15 1 15am StatementhourminuteConsoleExplanationInitial State1 15 if minute 59 true execute next statementminute 16 if else finished Here the minute is incremented by 1 and nothing else happens Now lets write a trace table for the initial situation 22 59 1 59pm StatementhourminuteConsoleExplanationInitial State2259 if minute 59 false execute statement after elseemitBeeps hour 1 Beep 23 times1st statement in blockminute 2nd statement in blockif hour 23 true execute next statementhour 23 inner if else finished and outer if else finished Here much more happens the clock beeps 23 times for 11 pm and the minute is reset to while the hour advances to 23 A Caution vs in ifs Imagine that you want to write code that doubles the value stored in an int variable x but only if it stores 1 The following if statement proposes to solve the problem if x 1 x 2 x Carefully examine the test it is written as x 1 not x 1 Did you see that the first time you read it Most students don t It is a common mistake for programmers to write accidentally instead of in if tests But the good news is that the Java compiler will detect and report a syntax constraint error because the result type of the test is not boolean There are situations though where the Java compiler will not detect such a mistake will not be detected when the expression itself is of type boolean The code on the left uses and the one on the right uses boolean doIt boolean doIt if doIt true if doIt true System out println Yes System out println Yes Assume in both cases the the code evalutes to false The left test evaluates to false so it does not print the message But the right test stores true into doIt wiping out the value computed before the if AND evaluates to true by the semantics of the operator so it does print the message The Java compiler does not report any error because the type of the expression in both cases is boolean This brings us to a style point writing true or false in an if s test is unnecessary and is prone to error For any boolean expression e we can write just e instead of e true and we can write e instead of e false Avoiding the true and false literals here is the sign of a mature programmer Finally as we have already seen if you accidentally write the expression statement x the Java compiler will detect and report a syntax constraint error because the last operator applied in this expression statement is not a state change operator Older languages C and C allow these expression statements and cause programmers no end of debugging problems so Java disallowed them instead forcing them to be reported during compilation Dangling else Examine the following two if statements if test1 if test1 if test2 if test2 statement1 statement1 else else statement2 statement2 The left code looks like it has an if else inside an if The right code looks like it has an if inside and if else But what we see is based on whitespace indentation What Java sees for both is EXACTLY THE SAME TOKENS if test1 if test2 statement1 else statement2 because whitespace is removed once Java tokenizes a program So Java interprets both code fragments in exactly the same way Which interpretation does Java use for these tokens We need an extra syntax rule that helps us gree on which interpretion is the correct one an else belongs to the most recently seen if that it can belong to So Java uses the left interpretation To force the other interpretation matching the else with the first if we must use a block and write if test1 if test2 statement1 else statement2 Now the else which is outside the block cannot possibly belong to the if that is inside the block because all parts of that if statement must reside entirely in the block So the final else now belongs with the first if This is called th dangling else problem and it is hard for programmers to see We must carefully indent our if statements accurately to reflect which elses belong with which if otherwise our program will contain a subtle error that is very hard for us to locate In fact some programmers advocate ALWAYS using block in if else statements to avoid dangling elses The disadvantage of this approach is that in simple cases the extra blocks create code that is harder to read We will discuss style principles in more detail later in the quarter if Pragmatics When writing decisions determine the correct form if if else or cascaded if If you are unsure about which one is correct try the simpler forms first Indent the parts of the if and the statements that it contains to illustrate the logical structure of the if when blocks are used place the braces in the positions shown in the examples above Ensure that the indentation making the code easier for humans to read accurately reflects how Java reads the tokens e g beware of a dangling else The key to understanding an if statement is understanding its test s Ensure that for some values of its variables every test can evaluate to both true and false otherwise the test is probably wrong For example what is wrong with the following code Study it carefully and hand simulate it for a few different values of x if x 2 x 5 x Is this test really the right one probably not no int value stored in x makes the test false try to find one If it were correctly we could simplify this code by removing the whole if statement simplifying it to just x which always performs this action for Statements In Java for statements allow us to repeatedly execute another statement To begin we present a simple useful legal but incomplete form for the for statement The EBNF rule for this simplified for statement is for statement for statement We call statement the body of the for loop Although we write this EBNF rule on one line we write for statements in code that span at least two and often many more lines Finally note that for is a keyword in Java The most typical form of the for statement is for statements i e a sequence of statements inside a block Here the body of the for is a block Semantically Java executes the for statement by executing its body over and over again Thus when done executing the body Java loops back and re executes it That is why we often refer to such a statement as a for loop Such a loop runs forever or more accurately until Java executes a break statement inside the loop discussed in the next section forces Java to terminate the loop Two example for loops each infinite are for System out println You re Great int count for System out println count count The first example fills the screen with Your re Great The second example starts by displaying the value then 1 then 2 then 3 etc with the next value displayed becoming larger by one for each iteration Let s hand simulate this second example and write a trace table for it StatementcountConsoleExplanationInitial StateUndeclared int count for execute body first timeSystem out println count 1st statement in blockcount 1 last statement in blockfor execute body againSystem out println count 11st statement in blockcount 2 last statement in blockfor execute body againSystem out println count 121st statement in blockcount 3 last statement in block Of course this process continues endlessly so we cannot show a complete trace table for this code or any other infinite loop You can always terminate a program in Eclipse by using by pressing the red square in the console window if you suspect your program is in an infinite loop and you want to stop it In the next section we will explain how the break statement allows the program itself to terminate the loop break Statements The EBNF rule for the break statement is very simple break statement break Java imposes a syntax constraint that a break statement must appear inside the body of some loop Finally note that break is another keyword in Java In real programs break statements appear inside if statements which themselves are inside the bodies of loops so a typical example is if count break Semantically whenever a break statement is executed Java terminates the inner most loop that it apears in it breaks out of that loop Terminating a loop means Java next executes the statement AFTER the body of the loop it does not mean that the program terminates By putting a break statement inside an if statement the if can control based on its test whether or not the break statement is executed the test determines whether or not the loop terminates on this iteration A tyical combination of for and break statements is int countdown 3 for System out print countdown if countdown break countdown System out println Blastoff Let s hand simulate this example and write a trace table for it We call such a for break combination a count down loop StatementcountdownConsoleExplanationInitial StateUndeclared int countdown 3 3 for execute body first timeSystem out print countdown 3 1st statement in blockif countdown false skip next break statement if finishedcountdown 2 last statement in blockfor execute body againSystem out print countdown 3 2 1st statement in blockif countdown false skip next break statement if finishedcountdown 1 last statement in blockfor execute body againSystem out print countdown 3 2 1 1st statement in blockif countdown false skip next break statement if finishedcountdown last statement in blockfor execute body againSystem out print countdown 3 2 1 1st statement in blockif countdown true execute next break statement break terminate for loopSystem out println Blastoff 3 2 1 Blastoff1st statement AFTER loop body We can graphically summarize the control flow in cooperating for and break statements as More for break Examples Let s look at two more interesting kinds of loops that combine for and break The first is called a count up loop the variable x counts up to the value stored in the variable max Notice that max is declared and initialized by the value entered by the user int max Prompt forInt Enter Number to Sum To int x Stores value to add to sum int sum Stores sum that x is added to for if x max break x sum x System out println 1 2 max sum Assuming the user enters 5 when prompted let s hand simulate these statements and write a trace table for it StatementmaxxsumConsoleExplanationInitial StateUndeclaredUndeclaredUndeclared int max Prompt 5 Enter 5 int x int sum for execute body first timeif x max false skip next break statement if finishedx 1 sum x 1 last statement in blockfor execute body againif x max false skip next break statement if finishedx 2 sum x 3 last statement in blockfor execute body againif x max false skip next break statement if finishedx 3 sum x 6 last statement in blockfor execute body againif x max false skip next break statement if finishedx 4 sum x 1 last statement in blockfor execute body againif x max false skip next break statement if finishedx 5 sum x 15 last statement in blockfor execute body againif x max true execute next break statementbreak terminate for loopSystem out println Enter 51 2 5 151st statement AFTER loop body The second example is called a sentinel terminated loop Here the user enters a special value called a sentinel to inform the program that there are no more values to input The sentinel is not processed by the normal code in the loop body int count int sum for int score Prompt forInt Enter a Score 1 to Terminate if score 1 break count sum score System out println Average double sum double count Assuming the user enters the value 3 6 4 and the sentinel 1 respectively when prompted let s hand simulate these statements and write a trace table for it StatementcountsumscoreConsoleExplanationInitial StateUndeclaredUndeclaredUndeclared int count int sum for execute body first timeint score Prompt forInt 3Enter 3 if score 1 false skip next break statement if finishedcount 1 sum score 3Undeclared last statement in blockfor execute body againint score Prompt forInt 6Enter 3Enter 6 if score 1 false skip next break statement if finishedcount 2 sum score 9Undeclared last statement in blockfor execute body againint score Prompt forInt 4Enter 3Enter 6Enter 4 if score 1 false skip next break statement if finishedcount 3 sum score 13Undeclared last statement in blockfor execute body againint score Prompt forInt 1Enter 3Enter 6Enter 4Enter 1 if score 1 true execute next break statementbreak Undeclared terminate for loopSystem out println Average 4 33333331st statement AFTER loop body Notice that each time that the for loop executes its body it declares intializes then undeclares its local variable score This variable could be declared and left uninitialized before the loop as int score and then appear in the loop as just score Prompt forInt Enter a Score 1 to Terminate But because the values stored in this variable are never and should never be used outside the loop we have chosen to not even declare this variable outside the loop The fact that this variable is declared undeclared many times does not affect the correctness nor the speed of this code Compact Trace Tables When we hand simulate programs with complicated control structures most of the trace table is occupied by information relating to control structures deciding which statements to execute next as opposed to statements that actually change the state of variables or the console window Such trace tables are cumbersome to create and hard to read Compact trace tables remove all the information related to control structures and instead focus on state changes to variables and the console window To construct a compact trace table we list all variables and Console in separate columns and omit Explanation Only when the code changes the state of a variable OR the console window do we update information in the appropriate column and we always do so right beneath the last entry for this column Note that what we lose in a compact trace table we gain conciseness is an indication of the order in which different variables have their state changed because each column is shown as compactly as possible no blank entries there is no correlation among columns whose states changed Here are compact trace tables for the three standard trace tables shown above First the count down loop countdownConsoleUndeclared blank 33 23 2 13 2 1 3 2 1 3 2 1 Blastoff Next the count up loop maxxsumConsoleUndeclaredUndeclaredUndeclared blank 5 Enter Number to Sum To 5 111 2 5 15 23 36 41 515 Finally the sentinel terminated loop countsumscoreConsoleUndeclaredUndeclaredUndeclared blank 3Enter a Score 1 to Terminate 3136Enter a Score 1 to Terminate 6294Enter a Score 1 to Terminate 4313 1Enter a Score 1 to Terminate 1 Average 4 333333 Remember in a compact trace table all the blank entries are at the bottom of a column A column entry is filled in only when all the column entries on top of it have been filled in General for break while do We can write ANY looping code using the for and break that we know but there is a more general form of the for statement that allows use to write many loops more compactly and clearly When we study arrays iterators and self referential objects these forms will become more and more useful The general for statement packages all the information needed for a count down or count up loop into one locality making it easier to read write and understand The EBNF rule for the general for statement is expression list expression expression for init type variable declarators expression list for update expression list for statement identifier for for init expression for update statement Note that if we discard all the options we are back at the for statement that we have studied As a syntax constraint if the expression option in the middle of the semi colons is included its resulting type must boolean this part is called the continuation test Also each expression in an expression list must adhere to the same constraints as an expression statement it must apply a state change operator or a method call last in the expression For example we can use such a for statements to simplify the code that sums all the integers up to max int max Prompt forInt Enter Number to Sum To int sum Holds Sum of 1 x for int x 1 x What makes the for loop so powerful is the way it groups together in one locality all the information that controls the loop Here is a standard not compact trace table illustrating these semantics in the code above StatementmaxxsumConsoleExplanationInitial StateUndeclaredUndeclaredUndeclared int max 5 Enter 5 int sum for int x 1 x 1 Initialize test is true execute bodysum x 1 last statement in bodyfor int x 1 x 2 increment test is true execute bodysum x 3 last statement in bodyfor int x 1 x 3 increment test is true execute bodysum x 6 last statement in bodyfor int x 1 x 4 increment test is true execute bodysum x 1 last statement in bodyfor int x 1 x 5 increment test is true execute bodysum x 15 last statement in bodyfor int x 1 x Undeclared increment test is false terminate loopSystem out println Enter 51 2 5 151st statement AFTER loop body Note that the variable x becomes undeclared after the for statement terminates Thus we cannot refer to it after the for loop s body where we print the statistics if we did write its name there the Java compiler would detect and report an error If we did want to refer to this value AFTER the for statement finishes we could write int max Prompt forInt Enter Number to Sum To int sum Holds Sum of 1 x int x 1 for xfor while do Semantics We will now show the EBNF rule for while and do statements and explain their semantics and the general for statement by using the simple for and break statements The EBNF for while and do statements is while statement while expression statement do statement do statement while expression Semantically we can mechanically translate any general for loop while loop or do loop into an equivalent simple for loop The Java compiler performs just this kind of transformation when it generates the machine instructions corresponding to these kinds of loops for init continue update statement init for if continue break statement update while continue for statement if continue break statement or even for continue statement do for statement statement while continue if continue break For the general for statement example above this means for int x 1 x Note that the value of x is declared inside a special block the outermost one as described above this variable disappears when the for statement the outermost block shown above in the translation terminates The while and do statements and just variants where the continuation condition is always tested first or last in the loop s body In the case of the do loop the body is always executed once Pragmatically you will see many more while loops than do loops Finally most students have two problems understanding general for loops They don t realize when the update is done it is done AFTER the loop body right BEFORE continue is retested Also note that x and x x 1 are valid expression statements that can be used in update but x 1 is not because it contains no state change operator They try to use the variable declared in init outside the loop after it has terminated this variable can be used only inside the loop for break Pragmatics The following rules can help you synthesize and analyze to fix bugs loops When designing iterative code think in terms of the simple for and break statements and determine What statements belong before the loop initialization code What statements belong inside the body of the loop What condition terminates the loop Where that condition should be tested inside the loop Each iteration should allow some progress towards the termination condition of the loop making the if test true Sometimes it is easier to write the body of the loop first and then determine what initialization is necessary before the loop Sylistically write loops as shown with block braces as shown and the body of the loop slightly indented typically 2 spaces When hand simulating loops pay special attention to the first few and last few iterations certain kinds of errors occur only at the beginning or ending of a loop Ensure that all the variables are properly initialized before they are examined in expressions the Java compiler will help you here Errors due to incorrect initialization are easy to spot if we carefully hand simulate the first iteration of a loop and these are among the most frequent category of errors The break statement is the most important statement inside a loop Clearly mark break statements using white space and or special comments e g a comment sandwich Ensure that for all possible initial states of its variables a loop eventually terminates the test in the if statement containing the break will always eventually evaluate to true Most loops even in industrial code need one if break combination A loop to solve a very complicated problem may require multiple if break combinations but they can often be localized grouped together Only a loop that solves the most complicated kind of problems may require multiple if break combinations distributed throughout the loop s body It is the mark of a good programmer to write simple loops with simple terminations The most frequent occuring location for the if break is the first statement in the body of the for loop try it there first move it elsewhere if necessary Such a for break combination can also be written as a while loop Finally use the general form of the for statement to its maximum advantage to clarify your loops You may use while and do loops but the extra thought that goes into considering them and the fact that it is often harder to think of a continuation condition rather than a termination condition means that I use them infrequently preferring the for break combination Boxing if for and break Statements Continuing our analysis of boxing statements we illustrate below how to box if for and break statements as well as expression and block statements Notice that EVERYTHING that can be syntactically considered to be a statement is in its own box This includes declarations statements there are none here expression statements blocks entire if statements break statements and entire for statements General for loops are boxed in a similar manner none of the information within their parentheses are considered statements try catch The EBNF of the try catch statement is the most complex of any control structure that we have seen so far that is a tipoff that programming in Java with exception handling is interesting In fact many Java courses don t cover exceptions and exception handling until much later in the quarter But I think that the core concepts can be demonstrated early can be used to good advantage in stereotypical ways that are easy to understand and can be returned to repeatedly in more complicated contexts a spiral approach to learning The general form of a try catch statement is parameter type identifier catch clause catch parameter block statement try catch statement try block statement catch clause finally block statement Although we write the try catch statement EBNF rule on one line try catch statements written in our code often span many lines they contain mandatory blocks which can contain many statements on different lines The names of exceptions are actually special reference types Although this is getting a bit ahead of ourselves we will use the following reference types exception names ArithmeticException NumberFormatException IllegalArgumentException IllegalStateException IOException and Exception a generic name that includes all the others As a syntax constraint the right hand side of each try catch statement must have at least one catch clause or one finally there can be many of the former and a combination of both but we cannot take repetitions of catch clause and at the same time discard the finally block We could actually encode this restriction in EBNF but it would make a complicated description look even more complex The semantics of this statement as you might expect are complicated as well Java starts a try catch by sequentially executing the statements in the block statement immediately following the keyword try known as the try block just as it would execute any block One of two things happen If no statement in the try block throws an exception after the last statement in the block is executed Java executes the finally block if this option was included Java is now done with the try catch statement and executes the next statement following it If some statement in the try block throws an exception the rest of the statements in that block are skipped Java tries to find a catch clause whose parameter matches the name of the exception that was thrown the generic name Exception matches all exception names If the name is found Java executes its associate block and then Java executes the finally block if this option was included Java is now done with the try catch statement and executes the next statement following it If the name is NOT found Java executes the finally block if this option was included Java then skips code while it looks for another more outer try catch statement one whose catch clause does name the exception If one is found follow the rule above Note that it DOES NOT return to the original inner try catch statement If one is NOT found Java terminates the programs citing an uncaught exception Typically this results in a trace it prints on the console the name of the uncaught exception and what methods were active when the exception was thrown A Simple Example In this section we will present a simplified example it is not useful in real programs but is useful only to illustrate the semantics of try catch statements Recall that the operator throws an exception named ArithmeticException if its second operand is zero Let us examine the effect of placing the following try catch statement in a program int percentage some code try int attended Prompt forInt Enter attendance int capacity Prompt forInt Enter capacity percentage 1 attended capacity System out Println percentage computed ok catch ArithmeticException a System out println capacity was I ll assume percentage was 1 percentage 1 more code Here if the division succeeds percentage is set correctly the ok message is printed the try block finishes normally and execution continues afterward where it says more code because there is no finally block On the other hand if the division fails throwing ArithmeticException percentage is not set the operator is never evaluted it requires the result from the division which we have just seen has thrown an exception the ok message is skipped as Java locates the appropriate catch clause both statements in the catch clause block are executed then the try block finishes and execution again continues afterward where it says more code because there is no finally block If we replaced ArithmeticException by Exception then the code would execute identically because Exception matches all raised exceptions If we replaced ArithmeticException by any other name say IOException then Java would not find a matching exception assuming that there is no outer try catch statement to catch this exception Java would terminate the program and print a trace on the console One reason why this example is not realistic is that we can easily check whether the division will fail with an if statement and avoid the need for a try catch statement all together int percentage some code int attended Prompt forInt Enter attendance int capacity Prompt forInt Enter capacity if capacity percentage 1 attended capacity System out Println percentage computed ok else System out println capacity was I ll assume percentage was 1 percentage 1 more code In the following two examples which are much more realistic we will need a try catch statement to solve the problem we cannot use an if statement to check whether an exception is about to be thrown Prompting with try catch In this section we will present a more realistic example In fact similar code appears inside the Prompt forInt method Understanding how this code works requires a mastery of the semantics of many Java statements First we must know that the Integer parseInt method from the Java library has the following prototype int Integer parseInt String throws NumberFormatException This methods takes a String as an argument If that argument represents the value of a legal integer it returns that value as an int if it does not represent a legal integer it cannot return any reasonable value so it throws NumberFormatException Thus Integer parseInt 1 returns the int 1 and Integer parseInt 1x throws NumberFormatException There is no method that Java provides to check whether Integer parseInt will throw an exception we have to call that method to see what it does Now let us see how the following code a combination of a for loop break statement not in an if and try catch prompts the usre until he she enters a valid integer whose value is stored into answer int answer for try answer Integer parseInt Prompt forString Enter integer break catch NumberFormatException e System out println Error please enter a valid integer process answer Here the for loop repeatedly executes the try catch statement First let us see what happens if the user enters a valid integer During the first iteration of the loop Java executes the first statement the user enters a valid integer read as a String that is passed to the Integer parseInt method so this method does not throw an exception but instead returns a result that is stored in answer Thus the second statement in the block is reached this break statement terminates the entire for loop and execution continue after the for loop where it says process answer Now let us see what happens if the user enters an INVALID integer During the first iteration of the loop Java executes the first statement the user enters an invalid integer read as a String that is passed to the Integer parseInt method so this method throws a NumberFormatException Java skips the break statement and instead finds the catch matching the exception its following block prints an error message Now the try catch statement is finished but this statement is the body of a for loop so it is executed again Therefore this loop will continue executing so long as the user enters an invalid integer the first time that the user enters a valid integer see the description above its value will be stored into answer and the break statement following it will be executed to terminate the loop So generally we have designed code that potentially repeatedly performs some operation until an exception is NOT thrown In the next section we will design code that repeatedly performs some operation until an exception IS thrown e g we are anticipating that an exception will eventually terminate the loop which continues executing until it is does Together these two forms occur frequently in exception handing code Reading Files with try catch In this section we will present another realistic example In fact code similar to this will be present in most programs that read files First we must learn that the readInt method from a Java library class that I have written has the following prototype int readInt throws NumberFormatException EndOfFileException This method skips any white space in a file and returns the next integer value that it contains if it succeeds There are two ways for it to fail each denoted by a different exception name There is a value in the file but it is not an integer in this case the method throws NumberFormatException There are no more values of any type in the file in this case the method throws EndOfFileException The following code assumes the variable inputFile refer to an object representing a file we ll learn more about this in a later lecture It reads every value in a file accumulating the sum and ultimately printing it int sum for try int aValue inputFile readInt sum aValue catch EndOfFileException eofe break System out println Sum sum Let us see what happens if the file contains two integers Java starts to execute the for loop which contains just one statement a try block During this first iteration of the loop Java executes the first statement in the try block calling the readInt method reads a valid integer from the file and stores into aValue In the next statement the sum is incremented by this value The try block is finished and the for loop executes it a second time During the second iteration of the loop Java executes the first statement in the try block calling the readInt method reads another valid integer from the file stores into aValue In the next statement the sum is incremented by this new value The try block is finished and the for loop executes it a third time During the third iteration of the loop Java executes the first statement in the try block calling the readInt methods causes it to throw EndOfFileException because there are no more values in the file to read This error is caught by the catch EndOfFileException eofe clause whose block contains a break statement that terminates the for loop Java continues by executing the statement after the for loop printing the accumulated sum This code repeatedly performs some operation until an exception is thrown Note that if a non integer value appears in the file then calling the readInt method causes it to throw NumberFormatException This exception is not caught by the try catch shown above so Java terminates the program and prints a trace on the console Finally because the only place that aValue is used is to add to sum we can simplify this code a bit and write int sum for try sum inputFile readInt catch EndOfFileException eofe break System out println Sum sum Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a CA or any other student Explain which of the following state change expressions are legal and illegal Assume we have declared int a b c a b c a 2 a b c a Prompt forInt Enter a b a System out println Success In each of the following expression statements carefully apply your knowledge of syntax tokens operator precedence and associativity and semantics to explain a What values are stored in all variables whose states are changed b What is the result computed by the expression c What oval diagram illustrates parts a and b Assume that each statement is executed just after the declaration int a 3 b 5 c 8 a b c a b c c b c a b c 1 a b c 1 a b c 1 System out println b b System out println b b Explain what is displayed on the console for the top and bottom block Assume we have declared int i char c and that the ASCII equivalent of A is 65 i A System out println i c 65 System out println c Show what is displayed in the console window after Java executes the following expression statements Be very careful to show which word occurs on which lines Remember that the escape character n starts a new line System out print When in System out println the course of System out print human nevents System out print it System out print becomes System out println necessary System out print for one nation to sever Examine the following 6 blocks all are are permutations of the same three statements Classify each block as syntactically legal or illegal hint certain statement orderings are illegal because they violate a constraint on where a variable declared inside a block can be used For those blocks that are legal determine whether or not they swap of the values stored in x and y int temp x x y y temp int temp x y temp x y x y int temp x y temp x y y temp int temp x y temp x y int temp x y temp int temp x x y Examine each of the following statements determine whether it is true or false and be prepared to support your answer or show a counter example A block can be empty contain no statements A block can be unitary contain 1 statement The statements x y and y x have identical meanings If we declare int x 5 y 8 and Java executes the expression statement x y immediately followed by y 3 then both x and y now store 3 A single statement can change the state of more than one variable The following block is rejected at compile time by the Java compiler Write the error message that Java reports Explain why it makes sense to recognize this problem and report the error int a System out println a a Which of the following is easier to understand the single statement or double statement Verify that both perform the same computation myPurse stakes myWins myWins myPurse stakes Assume that we declare a char grade and guarantee that it stores a letter corresponding to a UCI grade A B C D or F Write an if statement that computes the number of quality points for that grade and stores it in int qp an A is worth 4 a B is worth 3 a C is worth 2 a D is worth 1 and an R is worth Assume that we declare int hours Write an if statement that computes the pay in cents due a worker according the following formulas 625 Hours if the hours worked is less than or equal to 4 625 Hours 725 Hours 4 if the hours worked is greather than 4 Store the result in int centsPay Try a few examples under at and over 4 hours to verify your statement is correct Assume that we declare int x y boolean isIt Write a trace table for the hand simulation of the following Java statements one where x stores 3 and y stores 5 and another where x stores 5 and y stores 3 State whether the results are the same or different in each case if x y if x y isIt true isIt true else isIt false isIt false Which statement side is equivalent to the expression statement isIt x y Assume that we declare int studentAnswer correctAnswer wrongCount Explain what is wrong with the following statement there is a syntax error if studentAnswer correctAnswer else wrongCount Explain how to fix this problem in a simple way Modify the cascaded if for computing grades so that grade stores if testScore is outside the range to 1 inclusive Write a trace table for the clock code if the clock starts at 11 59pm one minute before midnight Assume that we declare double s signum Write a cascaded if statement s that stores into signum the value 1 if X is less than if X is equal to 1 if X is greater than Assume that we declare double min x max Write a cascaded if statement s that stores into x the value min if x is less than min max if x is greater than max nothing new otherwise Assume that we declare int x y z min Write an if statement s that stores into min the minimum of the values stored in x y and z Try to do this with the minimum amount of code Re examine the cascade if that computes a course grade Which of the following statements are equivalent to it do the same thing for all values stored in testScore if testScore 6 if testScore 6 grade D grade F else if testScore 7 if testScore 7 grade C grade D else if testScore 8 if testScore 8 grade B grade C else if testScore 9 if testScore 9 grade A grade B else else grade F grade A What simple changes would correct any incorrect code Suppose that we modify the clock code to call emitBeeps at the bottom of its block and also change its argument to just hour Will this code always work as before If not for what hour and minute combination s will it fail if minute 59 minute else minute if hour 23 hour else hour emitBeeps hour Note that to be correct the code must be correct for every hour and minute There are 24x6 1 44 different possiblities which ones are crucial to check Suppose that we modify the clock code as follows Will this code always work as before If not for what hour and minute will it fail minute if minute 6 minute hour emitBeeps hour if hour 24 hour Note that to be correct the code must be correct for every hour and minute There are 24x6 1 44 different possiblities which ones are crucial to check Assume that we declare int hour storing the values through 23 as described above Write an if statement s to display on the console the hour in a standard format e g when hour stores 3 display 3am when hour stores 15 display 3pm When hour stores display 12midnight and when hour stores 12 display 12noon Try to do this with the simplest possible code Write a standard trace table for the following code when the user enter the value 3 write a compact trace table for this value and when the user enters 7 int cycleCount int test Prompt forInt Enter value to test for cycleCount if test 1 break if test 2 test test 2 else test 3 test 1 System out println Finished in cycleCount cycles The following two code fragments are identical to the original count down code but the if appears in different locations inside the loop Write a standard trace table for each showing its behavior and results Can you change the test in the if to produce the original results int countdown 3 for if countdown break System out println countdown countdown System out println Blastoff int countdown 3 for System out println countdown countdown if countdown break System out println Blastoff The following code fragment is identical to the original sentinel code but the if appears in a different location inside the loop Write a standard trace table for each showing its behavior and results int count int sum int score for score Prompt forInt Enter a Score 1 to Terminate count sum score if score 1 break System out println Average double Sum double Score Rewrite the countdown loop more compactly so that it uses a general for statement without if break in its body Rewrite the sentinel loop twice so that it uses a while loop and a do loop It can be done but what problem arises The following code can be used to ensure that the user enters a positive value Write a standard trace table for the following code assuming the user enters the values 5 1 and 8 respectively int positive for positive Prompt forInt Enter Positive Value if positive 1 break System out println Sorry positive isn t postive System out println positive positive What changes would be necessary to ensure the user entered a positive and even value Write a compact trace table for the following code assuming the user enters the values 4 5 7 3 7 8 8 11 15 5 9 and 1 respectively int zcc int p Prompt forInt Enter Value for int c c Prompt forInt Enter Value if c 1 break if p c zcc p c System out println Final zcc zcc Write a compact trace table for the following code assuming the user enters the values 4 5 7 3 7 7 8 11 15 5 9 and 1 respectively int ll int cl int p Prompt forInt Enter Value for if cl ll ll cl int c Prompt forInt Enter Value if c 1 break if p c cl else cl p c System out println Final ll ll Write code see the previous two problems for inspiration that determines whether all the values it prompts for use 1 as a sentinel are in strictly increasing order each value is greater than the one that precedes it It should store its final answer in a boolean variable named isIncreasing Write two compact trace tables for your code assuming the user enters the values 4 5 3 5 2 4 and 1 the first time and 4 5 7 7 1 the second time Write code that counts the number of strictly increasing pairs of values the user enters use 1 as a sentinel It should store its final answer in an int variable named increasingPairCount Write two compact trace tables for your code assuming the user enters the values 4 5 3 3 7 6 8 9 2 5 4 and 1 For this input it finds 5 pairs 4 5 3 7 6 8 8 9 and 2 5 Explain why the following for loop contains an error spotted by the Java compiler for int i 1 i Explain what the following for loop displays Hint it doesn t display all the even numbers from 1 to 1 How could we write a for loop to accomplish this task for int i 1 i Translate the following for loop into a for loop with a break in its body for int i 5 i i System out println i Assume that we have declared int Width Height and stored values into these variables Write a pair of nested for loops that print a rectangle of that is height by width e g if height was 5 and width was 2 it would display What is syntactically wrong with the following for loop be careful How can we rewrite it to satisfy the syntax but still do the same intended thing for int i double d velocity i d 1 Suppose that in the prompting code we always want to set answer to and terminate the loop if the user fails to enter a valid integer Change the code to implement this requirement Hint this change requires just changing the block in the catch clause Explain whether or not the code below correctly reads all the integer values in a file and prints their sum Note that this code contains a for loop in a try catch statements with no break statement the original code to solve this problem contained a try catch with a break statement in a for loop int sum try for int aValue inputFile readInt sum aValue catch EndOfFileException eofe System out println Sum sum Suppose that in the file reading code from the lecture we want to ignore any non integer values encountered but keep reading more values until there are no more in the file to read How can we change the code to implement this requirement Why might it be better not just to ignore it but print an error message and how can this be accomplished Finally why can t we modify the code above to solve this problem too Hint look at how catch clause appears in the EBNF try catch statements Failing to read an int because some non int value appears in the file will cause Java to throw the NumberFormatException ", "_id": "http://www.ics.uci.edu/~pattis/ICS-21/lectures/statements/lecture.html", "title": "statements", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Statements</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Statements</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23\r\n<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  Statements are like complete imperative sentences in Java: each commands\r\n    Java to perform some action.\r\n  Just as we said that Java evaluates expressions, we say that Java executes\r\n    statements.\r\n  We already have studied the Java declaration statement, which declares\r\n    variables (and optionally initializes them).\r\n  We will classify many statements as control structures: such statements\r\n    control (conditionally/by repetition) the execution of other statements.\r\n  <p>\r\n  In this lecture we will first learn how to write the simplest kind of\r\n    statement in Java, the expression statement, and the simplest control\r\n    structure in Java, the block statement,\r\n  We will also begin discussing two analysis tools: hand simulation via trace\r\n    tables, and statement boxing (which is the statement equivalent of oval\r\n      diagrams for expressions). \r\n  <p>\r\n  Then we will learn about Java's most important control structures,\r\n    starting with <b>if</b> statements for decisions and simple\r\n    <b>for</b>/<b>break</b> statements for looping.\r\n  We will extend our analysis tools, trace tables and boxing, to cover these\r\n    statements.\r\n  Eventually we will generalize the <b>for</b> loop and cover two variants\r\n    of looping: <b>while</b> and <b>do</b> statements.\r\n  <p>\r\n  Finally, we will begin learning about Java's <b>try-catch</b> statement:\r\n    a control structure that programmers use to process exceptions.\r\n  Sometimes when an operator or method fails by throwing an exception, it\r\n    does not denote a failure of the program, but is just a signal to the\r\n    program that it must take some special action.\r\n  We will continue exploring the use of the <b>try-catch</b> statement in\r\n    our next lecture, in the context of file I/O.\r\n  <p>\r\n  Thus, we can summarize the language features that we learn in this lecture by<p>\r\n  &nbsp &nbsp <i>statement</i> <=\r\n       <i>local-declaration-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>expression-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>block-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>if-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>for-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>break-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>while-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>do-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>try-catch--statement</i>\r\n<p>\r\n  We will explore the semantics of the following control structures in detail.\r\n  <ul>\r\n    <li>block: execute a sequence of statements in order\r\n    <li>if: decide which statement to execute\r\n    <li>for/while/do loop: repeatedly execute a statement\r\n    <li>break: terminate execution of a loop\r\n    <li>try-catch: execute a sequence of statements; if one throws an\r\n         exception, execute an alternative sequence of statements\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Declaring Variables -->\r\n\r\n<a name=\"Declarations\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Declaring Variables<br>(review and extension)</b></td>\r\n<td width =\"80%\">\r\n  We have already discussed most aspects of the\r\n  <a href=\"../voe/lecture.html#Declarations\">\r\n    <i>declaration-statement</i></a>\r\n  in depth.\r\n  Recall that the simplest declarations start with the type of the variable,\r\n    followed by the name of the variable, ended by a semicolon.\r\n  In more complex variable declarations, we can specify multiple variable\r\n    names (each declared to be the same type, the one that starts the\r\n    declaration), and each variable can be initialized to a value.\r\n  <p>\r\n  We originally specified the EBNF for each declarator as\r\n  <p>\r\n<i>&nbsp &nbsp variable-declarator</i> <= <i>identifier</i> [=<i>expression</i>]  <p>\r\n    and said that <i>expression</i> could be only a literal (the only kind of\r\n    expression we knew at that time).\r\n  Now we know about much more complicated expressions, including literals,\r\n    variables, operators, and methods; we can use all these to declare the\r\n    initial values for variables.\r\n  Pragmatically, most intializations use either literals or calls to the\r\n    <b>Prompt</b> methods, but other form arise less frequently.\r\n  Here are some examples.\r\n<pre><b>  int a = 0;\r\n  int b = Prompt.forInt(\"Enter b\");\r\n  int c = b;\r\n  int d = Math.max(c,1) + 1;</b></pre>\r\n  <p>\r\n  Here the declation of <b>a</b> is intialized using the literal <b>0</b>;\r\n    the declation of <b>b</b> is initialized to the result returned by calling\r\n      the <b>Prompt.forInt</b> method;\r\n    the declation of <b>c</b> is initialized using <b>b</b>, the value of a\r\n      previous declared and intialized variable;\r\n    finally, the declation of <b>d</b> is initialized to the result returned\r\n      by an expression involving a method call, operator, literal, and\r\n      the value of a previously declared variable (<b>c</b>).\r\n  <p>\r\n  In addition, Java allows the keyword <b>final</b> to appear optionally in\r\n   <p>\r\n&nbsp &nbsp <i>local-variable-declaration-statement</i> <= [<b>final</b>] <i>type</i> <i>variable-declarators</i> ;<p> \r\n  Semantically, if such a declaration includes <b>final</b>, then all the\r\n    variables that it declares must include an initializer and the value they\r\n    store must never be changed.\r\n  That is, we cannot use any state-change operators on <b>final</b> variables.\r\n  If we declared\r\n<b><pre>  final double PI = 3.14159265358979323846;</pre></b>\r\n  Then Java would detect and report an error if we later wrote <b>PI = 3.0</b>\r\n  Thus, we can use <b>final</b> to declare named constants, whose value is\r\n    guaranteed by Java not to change.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Expression Statements -->\r\n\r\n<a name=\"ExpressionStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Expression Statements</b></td>\r\n<td width =\"80%\">\r\n  We can make an <i>expression</i> into <i>expression statement</i> by\r\n    appending a semicolon at its end.\r\n  Such a statement tells Java to evaluate the expression.\r\n  The EBNF rule for expression statements is simply\r\n  <p>\r\n  <i>expression-statement</i> <= [<i>expression</i>] ;<br> \r\n  <p>\r\n  In fact, by discarding the option, we can write just the semicolon as the\r\n    simplest kind of expression statement: it is a statement that\r\n    \"does nothing\".\r\n  <p>\r\n  But Java imposes one important syntax constraint on expression statements:\r\n    if the <i>expression</i> option is included\r\n  <ul>\r\n    <li>The <i>expression</i> must apply a state-change operator or a method\r\n          call last in the expression.\r\n  </ul>\r\n  Thus, the following statements are all legal examples of expression\r\n    statements: each satisfies this syntax constraint..\r\n  <pre><b>    average = (score1 + score2 + score3) / 3;\r\n    gameCount++;\r\n    counter1 = counter2 = counter3 = 0;\r\n    System.out.println(\"You have played \"+gameCount+\" games\");</b></pre>\r\n  Recall that most state-change operators have very low precedence, so they\r\n    will naturally be evaluated last in an expression statement.\r\n  Methods whose prototype lists <b>void</b> as the type of the result don't\r\n    return a result anyway.\r\n  Such methods (e.g., <b>System.out.println</b>) are often called last when\r\n    evaluating expression statements.\r\n  <p>\r\n  Note that <b>x+1;</b> is NOT a legal expression statement: the last operator\r\n    that it applies is <b>+</b>, which computes a value but does not process\r\n    this value further: e.g., doesn't store it anywhere; doesn't print it.\r\n  Writing such an expression serves no purpose, and the Java compiler detects\r\n    and reports an error in this case.\r\n  <p>\r\n  Finally, notice that this syntax constraint still allows\r\n    <b>Prompt.forInt(\"Enter values\");</b> as a legal expression statement,\r\n    even though this method returns an <b>int</b> result which is not processed\r\n    further.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Blocks -->\r\n\r\n<a name=\"Blocks\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Block Statements<br>(and scope)</b></td>\r\n<td width =\"80%\">\r\n  Some airlines restrict you to one carry-on bag.\r\n  If you show up with three small bags, they won't let you on the plane; but\r\n    if you buy a fourth, big bag, and put your original three into the\r\n    fourth, everything will be fine.\r\n  <p>\r\n  Java's syntax sometimes forces this same kind of behavior.\r\n  There are places (mostly inside the control structures we will study later\r\n    in this reading) where only one statement is allowed; if you want multiple\r\n    statements there, you must put them inside one big statement.\r\n  That single, big statement is called a <i>block-statement</i>,\r\n    of sometimes just a <b>block</b>.\r\n  The EBNF rule for blocks is \r\n  <p>\r\n  <i>block-statement</i> <= {{<i>statement</i>}}<br> \r\n  <p>\r\n  In this EBNF rule, the outer braces stand for themselves, the inner ones mean\r\n     repetition.\r\n  That is, blocks are some number of statements enclosed in braces.\r\n  So, a block itself is a statement, inside which we can put other statements.\r\n  Although we write this EBNF rule on one line, <b>block</b> statements in our\r\n    code often span many lines, with each statement inside the block appearing\r\n    on its own line, indented in the braces.\r\n  <p>\r\n  Semantically, Java executes a block by sequentially executing the statements \r\n    that it contains (in the exact same order that they appear in the block).\r\n  When giving directions to humans or computers, often the order in which the\r\n    directions are followed is critical.\r\n  If the directions say, \"To disarm the bomb, cut the blue wire and then cut\r\n    the red wire\" it would not be a good idea for us to change the order in\r\n    which these wires are cut.\r\n  <p>\r\n  \r\n  If a statement inside a block declares a variable, that variable can be used\r\n    in <i>subsequent</i> statements <i>inside</i> that block; after Java\r\n    executes all the statements in a block, the block is finished executing,\r\n    and ALL variables declared inside the block become undeclared.\r\n  So, such variables are called <b>local variables</b> because they exist only \r\n    locally, inside the block, while its statements are executing.\r\n  <p>\r\n  Technically, we call all those places that a variable can be used the\r\n    <b>scope</b> of that variable.\r\n  So the scope of local declarations in blocks include all subsequence\r\n    statements in that block.\r\n  <p>\r\n  Blocks themselves can be nested.\r\n  Any variables declared in an outer block can be used in an inner block.\r\n  For example\r\n<pre><b>{ //Outer block\r\n  int x = 1;\r\n  { //Inner block\r\n    System.out.println(x);     //Refers to x in outer block\r\n    x = 3;                     //Refers to x in outer block\r\n  }\r\n  System.out.println(x);\r\n}</b></pre>\r\n  This example illustrates that the scope of the variable <b>x</b> includes the\r\n    whole outer-block, which includes its inner block too.\r\n  The inner block is just one statement that is included in the outer block\r\n    (which is itself one bigger statement).\r\n  In this example, Java prints <b>1</b> followed by <b>3</b>.\r\n  <p>\r\n  If we had moved the declaration from the outer block to the start of the\r\n    inner block, Java would detect and report an error at compile time.\r\n<pre><b>{ //Outer block\r\n  { //Inner block\r\n    int x = 1;\r\n    System.out.println(x);     //Refers to x in inner block\r\n    x = 3;                     //Refers to x in inner block\r\n  }\r\n  System.out.println(x);       //Error! the x in the inner block\r\n                               // is undeclared for this statement.\r\n}</b></pre>\r\n  With this placement, the variable <b>x</b> would not be accessible outside\r\n    the inner block, so it would be unknown in the final print method.\r\n  The scope of <b>x</b> is just the inner block in which it is declared.\r\n</td>\r\n</tbody>\r\n</table>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- A Block of COde-->\r\n\r\n<a name=\"ABlock\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Putting Everything Together</b></td>\r\n<td width =\"80%\">\r\n  Finally, putting together everything that we have learned about Java, the\r\n    following block contains a variety of statements that perform a simple\r\n    computation: declaring variables, prompting the user for values to store\r\n    in these variables (by calling a method), performing a simple calculation\r\n    with these variables (storing the result in another variable with a state\r\n    change operator) and displaying the result in the console window.<pre><b>{        \r\n  double gravity;           //meter/sec/sec\r\n  double height;            //meters\r\n  double time;              //sec\r\n\t\t  \r\n  //Input\r\n  gravity = Prompt.forDouble(\"Enter gravity (in m/s/s)\");\r\n  height  = Prompt.forDouble(\"Enter height of drop (in m)\");\r\n\t\t  \r\n  //Calculate\r\n  time = Math.sqrt(2.*height/gravity);\r\n\t\t  \r\n  //Output\r\n  System.out.println();\r\n  System.out.println(\"Drop time = \" + time + \" secs\");\r\n}</pre></b>\r\n  Note that by intializing variables when they are declared, we could\r\n   \"simplify\" this code, writing it as follows.\r\n  Both blocks ultimate produce the same results.\r\n<pre><b>{  \r\n  //Input      \r\n  double gravity = Prompt.forDouble(\"Enter gravity (in m/s/s)\");\r\n  double height  = Prompt.forDouble(\"Enter height of drop (in m)\");\r\n\r\n  //Calculate\t  \r\n  double time = Math.sqrt(2.*height/gravity);\r\n\t\t  \r\n  //Output\r\n  System.out.println();\r\n  System.out.println(\"Drop time = \" + time + \" secs\");\r\n}</pre></b>\r\n  In fact, there is no need in this program for variables at all!\r\n  We can squeeze this entire program down to just one statement, using the\r\n    <b>\\n</b> escape sequence inside one huge (4 line) output statement.\r\n<pre><b>{  \r\n  System.out.println(\"\\nDrop time = \" + \r\n      Math.sqrt(2.*Prompt.forDouble(\"Enter height of drop (in m)\")\r\n                /Prompt.forDouble(\"Enter gravity (in m/s/s)\")) +\r\n      \" secs\");\r\n}</pre></b>\r\n  Although this program is the smallest yet, it is a bit complicated to follow\r\n    the calculation, which includes two prompts to the user as part of the\r\n    formula being computed.\r\n  Thus, while smaller is generally better, it isn't here; sometimes storing\r\n    partial calculations in nicely named variables helps us to write clearer,\r\n    easier to understand programs (a main goal of ICS-21).\r\n  Of course, if the program needs to use the values entered by the user more\r\n    than once, we should store them in variables to avoid reprompting the user\r\n    for the same information multiple times.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Hand Simulation -->\r\n\r\n<a name=\"HandSimulation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Hand Simulating State Changes</b></td>\r\n<td width =\"80%\">\r\n  As programmers, we must be able to analyze our programs to verify that they\r\n    are correct, or detect where bugs occur (the hard part) and fix them (an\r\n    easier part).\r\n  The most important way to analyze code is to be able to <i>hand simulate</i>\r\n    it.\r\n  The \"input\" to a hand simulation is\r\n  <ul>\r\n    <li>Variables and their current values (called the initial state)\r\n    <li>A block of code (a sequence of statements)\r\n    <li>If needed, values that the user enters to prompts on the console\r\n  </ul>\r\n  The \"output\" to a hand simulation is\r\n  <ul>\r\n    <li>The same variables and their resulting values, and the contents of the\r\n          console (called the final state)\r\n  </ul>\r\n  During a hand simulation we construct a <i>trace table</i> of state-changes\r\n    for each statement executed in the block of code; these include changes to\r\n    the states of variables and changes to the state of the console (what\r\n    input/output the program does).\r\n  <p>\r\n  Here is a simple example (no input/output) of such a trace table.\r\n  Assume <b>int x=5; int y=8;</b> and the block <b>{x=y; y=x;}</b>\r\n  If beginning students are asked to predict what the code does, the most\r\n    common response is that it swaps the values in <b>x</b> and <b>y</b>.\r\n  Let's see what really happens using a trace table (note that a table cell\r\n    shows the value stored in a variable <i>after</i> the statement on its\r\n    line is finished).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial States</td><td>5</td><td>8</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>x=y;</td><td>8</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>y=x;</td><td>&nbsp</td><td>8</td><td>&nbsp</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  So, we see that the values in the variables are not swapped, but\r\n    that <b>y</b>'s initial value ends up stored in both <b>x</b> and <b>y</b>.\r\n  In some sense, the simplest thing to do with two variables is to exchange\r\n    their values; yet the intuitive way to write code for this task is\r\n    incorrect.\r\n  Don't gloss over this observation, because it is very important.\r\n  The kind of reasoning a programmer does about state changes in code is very\r\n    different from the kind of reasoning a mathematician does about equations.\r\n  <p>\r\n  One correct way to swap the values stored in two variables is:\r\n    <b>{int temp=x; x=y; y=temp;}</b>, and the hand simulation illustrating\r\n    its correctness (using the same initial state).\r\n  <p>  \r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>temp</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial States</td><td>5</td><td>8</td><td>Undeclared</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int temp=x;</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>x=y;</td><td>8</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>y=temp;</td><td>&nbsp</td><td>5</td><td>Undeclared</td><td>&nbsp</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note how <b>temp</b> is shown as undeclared before the block is executed and\r\n    also becomes undeclared  after Java finishes executing the block.\r\n  But <b>temp</b> plays a crucial part in the computation, while Java is\r\n    executing the statements in the block that it is declared in.\r\n  <p>\r\n  As a final example, let's examine the trace table for a block that does\r\n    I/O too.\r\n  Here there are no variables in the initial state: the block to execute is:\r\n    <b><pre>    {\r\n      double x,y;\r\n      x = Prompt.forDouble(\"Enter x\");\r\n      y = Math.pow(x,3.);\r\n      System.out.println(x + \" cubed = \" + y);\r\n    }</pre></b>\r\n  Finally, when prompted, the user will enter a 5.1 on the console.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial States</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>double x,y;</td><td>?</td><td>?</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>x = Prompt.forDouble(\"Enter x\");</td><td>5.1</td><td>&nbsp</td><td>Enter x: 5.1</td>\r\n  <tr valign=\"top\"><td>y = Math.pow(x,3.);</td><td>&nbsp</td><td>132.651</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>System.out.println(x + \" cubed = \" + y);</td><td>Undeclared</td><td>Undeclared</td><td>5.1 cubed = 132.651</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here the <b>Console</b> column shows what is on each line (on the first\r\n    line, the prompt and the value that the user enters; on the second line\r\n    the answer).\r\n  This is certainly a lot of work for such a simple example; but if you can\r\n    easily write such trace tables, you can use them to debug code that has\r\n    much subtler errors.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Boxing Simple Statements -->\r\n\r\n<a name=\"Boxing1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Boxing Statements</b></td>\r\n<td width =\"80%\">\r\n  Just as we used oval diagrams to understand the structure of expressions\r\n   (and their subexpressions), we will use box diagrams to understand\r\n    statements (and in the case of control structures, their substatements).\r\n  <p>\r\n  Right now we know three kinds of statements: declaration statements,\r\n    expression statements, and block statements.\r\n  Declaration statements and expression statements contain never contain\r\n    substatements; block statements contain substatements: the statements\r\n    that the block executed sequentially.\r\n  The example below includes multiple occurences of each of these kinds of\r\n    statements.\r\n  Each statement appears inside a box.\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/boxed1.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Practice the skill of boxing statements.\r\n  Learn to \"see\" statements inside of statements, the way a programmer does.\r\n  Notice how consistent indenting in the code makes this task easier.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- If Statements -->\r\n\r\n<a name=\"IfStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>if Statements</b></td>\r\n<td width =\"80%\">\r\n  In Java, <b>if</b> statements allow us to choose whether or not to execute\r\n  another statement, or which one of many statements to execute\r\n  (like both the option and alternative forms in EBNF).\r\n<p>\r\n  There are three forms of <b>if</b> statements in Java.\r\n  <ul>\r\n    <li><b>if</b>\r\n    <li><b>if/else</b>\r\n    <li><b>cascaded if</b> or <b>cascaded if/else</b>\r\n  </ul>\r\n  The general form of all <b>if</b> statements is given by one EBNF rule\r\n  <p>\r\n  <i>if-statement</i> <= <b>if (</b><i>expression</i></b>)</b> <i>statement</i> [<b>else</b> <i>statement</i>]\r\n  <p>\r\n  As a syntax constraint, <i>expression</i> must result in a <b>boolean</b>\r\n    value (if it doesn't, the Java compiler detects and reports this error).\r\n  Note that both <b>if</b> and <b>else</b> are keywords in Java, and the test\r\n    expression, no matter how simple or complicated, must always appear inside\r\n    parentheses.\r\n  Finally, although we write this EBNF rule on one line, we write <b>if</b>\r\n    statements in code that span at least two (and often many more) lines, and\r\n    contain indented statements.\r\n  <p>\r\n  An <b>if</b> statement (discarding the option) decides whether or not to\r\n    execute its statement.\r\n  We write it as<pre><b>   if (test)\r\n     statement</b></pre>\r\n  Recall that <b>statement</b> can also be a block.\r\n  Two <b>if</b> statement examples are  <pre><b>   if (x < 0)\r\n     x = -x;\r\n\r\n\r\n   if (myNumber == rouletteNumber) {\r\n     myWins++;\r\n     myPurse += stakes;\r\n   }</b></pre>\r\n   Notice where the opening and closing brace appear for this block: this is\r\n     the standard style that we will always use for blocks inside <b>if</b>\r\n      statements.\r\n   <p>\r\n   Semantically, Java executes an <b>if</b> statement as follows\r\n   <ul>\r\n     <li>Evaluate the <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute the (single) statement after the <b>test</b>.\r\n     <li>If it is <b>false</b>, skip the (single) statement after the <b>test</b>.\r\n   </ul>\r\n  So, if the test evaluates to <b>true</b> in the second example, Java executes\r\n    the block statement; it executes the block by sequentially executing the\r\n    two expression statements that it contains.\r\n  If the test evaluates to <b>false</b> in the second example, Java skips the\r\n    block statement (executing neither of the statements that it contains).\r\n  <p>\r\n  An <b>if/else</b> statement (including the option) decides which one of its\r\n    two statements to execute.\r\n  We write it as<pre><b>   if (test)\r\n     statement<sub>1</sub>\r\n   else\r\n     statement<sub>2</sub></b></pre>\r\n  Recall that <b>statement<sub>1</sub></b> and/or <b>statement<sub>2</sub></b>\r\n    can also be a block\r\n  Two example <b>if/else</b> statements are  <pre><b>\r\n   if (x%2 == 0)     //is x is even?\r\n     x = x/2;\r\n   else\r\n     x = 3*x+1;\r\n\r\n   if (x > y) {\r\n      min = y;\r\n      max = x;\r\n   }else{\r\n      min = x;\r\n      max = y;\r\n   }</pre></b>\r\n   Semantically, Java executes an <b>if/else</b> statement as follows\r\n   <ul>\r\n     <li>Evaluate the <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute <b>statement<sub>1</sub></b>, which\r\n           appears directly after the <b>test</b>, then skip\r\n           <b>statement<sub>2</sub></b>.\r\n     <li>If it is <b>false</b>, skip <b>statement<sub>1</sub></b>, then execute\r\n           <b>statement<sub>2</sub></b>, which appears directly after the\r\n           keyword <b>else</b>.\r\n   </ul>\r\n   So in <b>if/else</b> statements, Java always executes one of the two\r\n     substatements that it controls.\r\n   This is a bit different from the plain <b>if</b> statement, which decides\r\n     whether or not to execute the one statement that it controls.\r\n  <p>\r\n  A <b>cascaded if</b> (or <b>cascaded if/else</b>) decides which one (if any)\r\n    of many statements to execute.\r\n  The general form of the <b>cascade if</b> in Java is<pre><b>   if (test<sub>1</sub>)\r\n     statement<sub>1</sub>\r\n   else if (test<sub>2</sub>)\r\n     statement<sub>2</sub>\r\n   else if (test<sub>3</sub>)\r\n     statement<sub>3</sub>\r\n   else ...\r\n     ...\r\n   else if (test<sub>N</sub>)\r\n     statement<sub>N</sub>\r\n\r\n   <i>or </i>\r\n\r\n   if (test<sub>1</sub>)\r\n     statement<sub>1</sub>\r\n   else if (test<sub>2</sub>)\r\n     statement<sub>2</sub>\r\n   else if (test<sub>3</sub>)\r\n     statement<sub>3</sub>\r\n   else ...\r\n     ...\r\n   else if (test<sub>N</sub>)\r\n     statement<sub>N</sub>\r\n   else\r\n     statement<sub>N+1</sub>\r\n  </b></pre>\r\n  A <b>cascaded if</b> is built from many <b>if/else</b> statements, where\r\n    each of statements in the <b>else</b> part is another <b>if/else</b>\r\n    statement (except possibly the lst one).\r\n  An example <b>cascaded if</b> statement, assuming the declaration\r\n    <b>char grade;</b> is  <pre><b>   if (testScore >= 90)\r\n     grade = 'A';\r\n   else if (testScore >= 80)\r\n     grade = 'B';\r\n   else if (testScore >= 70)\r\n     grade = 'C';\r\n   else if (testScore >= 60)\r\n     grade = 'D';\r\n   else\r\n     grade = 'F';</pre></b>\r\n   Semantically, Java executes a <b>cascaded if</b> statement as follows\r\n   <ul>\r\n     <li>Evaluate the first <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute the statement after the <b>test</b>\r\n           and terminate the <b>cascaded if</b> (don't check any more tests\r\n           or execute any more statements).\r\n     <li>If it is <b>false</b>, evaluate the second <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute the statement after the <b>test</b> and\r\n           terminate the <b>cascaded if</b> (don't check any more tests\r\n           or execute any more statements).\r\n     <li>Continue following rules of this form until a <b>true</b> test is\r\n           found, or the last test is evaluated.\r\n     <li>If the last test is <b>true</b>, execute the statement after the                  <b>test</b> and terminate the <b>cascaded if</b> (there are no more\r\n           tests to check).\r\n     <li>If the last test is <b>false</b>, and it is an <b>if</b> statement,\r\n           terminate the <b>cascaded if</b>; if it is an <b>if/else</b>\r\n           statement, execute the statement after the <b>else</b> keyword.\r\n   </ul>\r\n   So in the <b>cascaded if</b>, exactly <b>one</b> statement -the one after\r\n     after the first <b>true</b> test is executed; if no tests are\r\n     <b>true</b>, either no statements are executed (when the last statement \r\n     is an <b>if</b>) or the statement after the last <b>else</b> is executed.\r\n   Graphically, we can summarize the control flow in the three kinds of\r\n      <b>if</b>s as\r\n   <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/ifcontrol.gif\"></image><p>\r\n\r\n\r\n<!-- Hand Simulations -->\r\n\r\n<a name=\"HandSimulations\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Hand Simulating if statements</b></td>\r\n<td width =\"80%\">\r\n  We can extend our use of trace tables to hand simulations of <b>if</b>\r\n     statements.\r\n  We include a special <b>Explanation</b> column to indicate the result of\r\n    evaluating <b>test</b> and which statement Java executes next.\r\n  Let's write two trace tables for hand simulating the first <b>if</b>\r\n    statement shown above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>-5</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x < 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>x = -x;</td><td>5</td><td>&nbsp</td><td><b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>5</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x < 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: skip next statement; <b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Next, let's write two trace tables for hand simulating the second\r\n    <b>if/else</b> statement shown above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>min</th><th>max</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>5</td><td>3</td><td>?</td><td>?</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x > y)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>min = y;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>max = x;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>2nd statement in block; block and <b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>min</th><th>max</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>3</td><td>5</td><td>?</td><td>?</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x > y)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute statement after <b>else</b></td>\r\n  <tr valign=\"top\"><td>min = x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>max = y;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>2nd statement in block; block and <b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  What is the trace table for this example if the values stored in <b>x</b> and\r\n    <b>y</b> are equal?\r\n  Does it produce the correct result?\r\n  Can you change the test to &gt= and still always get the same result?\r\n  Can there be two different ways of getting the same result?\r\n  <p>\r\n  Finally, let's write a trace table for hand simulating the\r\n     <b>cascaded if</b> statement shown above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>testScore</th><th>grade</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>73</td><td>?</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (testScore >= 90)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute <b>if</b> in <b>else</b></td>\r\n  <tr valign=\"top\"><td>if (testScore >= 80)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute <b>if</b> in <b>else</b></td>\r\n  <tr valign=\"top\"><td>if (testScore >= 70)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>grade = 'C';</td><td>&nbsp</td><td>'C'</td><td>&nbsp</td><td><b>cascaded if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- A Clock Example-->\r\n\r\n<a name=\"AClockExample\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Clock Example</b></td>\r\n<td width =\"80%\">\r\n  Let's take a quick look at an interesting task that combines all the\r\n    statements that we have studied.\r\n  Assume that we have declared the following variables for a \"military\" style\r\n    clock: e.g., 00:00 represents midnight, 9:03 represents 9:03am, 14:23\r\n    represents 2:23 pm, and  23:59 represents 11:59pm.\r\n<b><pre>    int minute; //in the range [0,59] inclusive\r\n    int hour;   //in the range [0..23] inclusive</pre></b>\r\n  Also assume that the method <b>emitBeeps</b> takes a single <b>int</b>\r\n    operand and emits that many beeps.\r\n  Finally, assume that the following code is called once a minute by the\r\n    operating system; when we study Java <b>threads</b> we will learn how to\r\n    arrange for such an action to occur repeatedly;.<b><pre>\r\n    if (minute != 59)\r\n      minute++;\r\n    else {\r\n      emitBeeps(hour+1);\r\n      minute = 0;\r\n      if (hour != 23)\r\n        hour++;\r\n      else\r\n        hour = 0;\r\n    }</b></pre>\r\n  Each time the code is called, it advances <b>minute</b> (and <b>hour</b>, if\r\n   necssary) ensuring they store only legal values; on the hour, the code beeps\r\n    that many times (once at 1 am, twice at 2am, ... 12 times at noon, 13 times\r\n    at 1pm, ..., and 24 times at midnight).\r\n  Let's write two trace tables for hand simulating this code in two different\r\n    initial situations: first at 10:15 (10:15am).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>hour</th><th>minute</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>10</td><td>15</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (minute != 59)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>minute++;</td><td>&nbsp</td><td>16</td><td>&nbsp</td><td><b>if/else</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here, the minute is incremented by 1, and nothing else happens.\r\n  <p>\r\n  Now lets write a trace table for the initial situation 22:59 (10:59pm).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>hour</th><th>minute</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>22</td><td>59</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (minute != 59)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute statement after <b>else</b></td>\r\n  <tr valign=\"top\"><td>emitBeeps(hour+1);</td><td>&nbsp</td><td>&nbsp</td><td>Beep 23 times</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>minute = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>2nd statement in block</td>\r\n  <tr valign=\"top\"><td>if (hour != 23)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>hour++;</td><td>23</td><td>&nbsp</td><td>&nbsp</td><td>inner <b>if/else</b> finished, and outer <b>if/else</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here, much more happens: the clock beeps 23 times (for 11:00pm) and the\r\n    minute is reset to 0 while the hour advances to 23.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- A Caution -->\r\n\r\n<a name=\"ACaution\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Caution: = vs ==<br>in ifs</b></td>\r\n<td width =\"80%\">\r\n  Imagine that you want to write code that doubles the value stored in an\r\n    <b>int</b> variable <b>x</b>, but only if it stores <b>10</b>. \r\n  The following <b>if</b> statement proposes to solve the problem\r\n<pre><b>   if (x = 10)\r\n     x = 2*x;</b></pre>\r\n  Carefully examine the test, it is written as <b>x = 10</b> not\r\n     <b>x == 10</b>.\r\n  Did you see that the first time you read it?\r\n  Most students don't.\r\n  <p>\r\n  It is a common mistake for programmers to write <b>=</b> accidentally\r\n     instead of <b>==</b>  in <b>if</b> tests.\r\n  But the good news is that the Java compiler will detect and report a\r\n   syntax constraint error, because the result type of the test is not\r\n   <b>boolean</b>.\r\n  <p>\r\n  There are situations, though, where the Java compiler will not detect such a\r\n    mistake will not be detected: when the expression itself is of type\r\n    <b>boolean</b>.\r\n  The code on the left uses <b>=</b> and the one on the right uses <b>==</b>.\r\n<pre><b>  boolean doIt = ...;                    boolean doIt = ...;\r\n  if (doIt == true)                        if (doIt = true)\r\n    System.out.println(\"Yes\");               System.out.println(\"Yes\");</b></pre>\r\n  Assume in both cases the the <b>...</b> code evalutes to <b>false</b>.\r\n  The left test evaluates to <b>false</b>, so it does not print the message.\r\n  But the right test stores <b>true</b> into <b>doIt</b> (wiping out the\r\n    value computed before the <b>if</b>) AND evaluates to <b>true</b> (by\r\n    the semantics of the <b>=</b> operator), so it does print the message.\r\n  The Java compiler does not report any error, because the type of the\r\n    expression in both cases is <b>boolean</b>.\r\n  <p>\r\n  This brings us to a style point: writing <b>== true</b> or <b>== false</b>\r\n    in an <b>if</b>'s test is unnecessary, and is prone to error.\r\n  For any <b>boolean</b> expression <b><i>e</i></b>, we can write just\r\n    <b><i>e</i></b> (instead of <b><i>e</i> == true</b>) and\r\n    we can write <b>!<i>e</i></b> (instead of <b><i>e</i> == false</b>).\r\n  Avoiding the <b>true</b> and <b>false</b> literals here is the sign of a\r\n     mature programmer. \r\n  <p>\r\n  Finally, as we have already seen, if you accidentally write the expression\r\n    statement <b>x == 0;</b> the Java compiler will detect and report a\r\n    syntax constraint error, because the last operator applied in this\r\n    expression statement is not a state-change operator.\r\n  Older languages (C and C++) allow these expression statements, and cause\r\n    programmers no  end of debugging problems, so Java disallowed them,\r\n    instead forcing them to be reported during compilation.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Dangling Else -->\r\n\r\n<a name=\"DanglingElse\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Dangling else</b></td>\r\n<td width =\"80%\">\r\n  Examine the following two <b>if</b> statements<pre><b>   if (test<sub>1</sub>)             if (test<sub>1</sub>)\r\n     if (test<sub>2</sub>)             if (test<sub>2</sub>)\r\n       statement<sub>1</sub>             statement<sub>1</sub>\r\n     else                else\r\n       statement<sub>2</sub>           statement<sub>2</sub></b></pre>\r\n  The left code looks like it has an <b>if/else</b> inside an <b>if</b>.\r\n  The right code looks like it has an <b>if</b> inside and <b>if/else</b>.\r\n  But what we see is based on whitespace/indentation.\r\n  What Java sees for both is EXACTLY THE SAME TOKENS:\r\n    <b>if (test<sub>1</sub>) if (test<sub>2</sub>) statement<sub>1</sub> else statement<sub>2</sub></b> because\r\n    whitespace is removed once Java tokenizes a program.\r\n  <p>\r\n  So, Java interprets both code fragments in exactly the same way!\r\n  Which interpretation does Java use for these tokens?\r\n  We need an extra syntax rule that helps us gree on which interpretion is\r\n     the correct one: an <b>else</b> belongs to the most recently seen\r\n     <b>if</b> that it can belong to.\r\n  So, Java uses the left interpretation.\r\n  <p>\r\n  To force the other interpretation, matching the <b>else</b> with the first\r\n     <b>if</b>, we must use a block, and write\r\n<pre><b>   if (test<sub>1</sub>) {\r\n     if (test<sub>2</sub>)\r\n       statement<sub>1</sub>\r\n   }else                 \r\n     statement<sub>2</sub></b></pre>\r\n   Now the <b>else</b> (which is outside the block) cannot possibly belong to\r\n     the <b>if</b> that is inside the block, because all parts of that\r\n     <b>if</b> statement must reside entirely in the block.\r\n   So the final <b>else</b> now belongs with the first <b>if</b>.\r\n  <p>\r\n  This is called th dangling else problem, and it is hard for programmers\r\n    to see.\r\n  We must carefully indent our <b>if</b> statements accurately, to reflect\r\n    which <b>else</b>s belong with which <b>if</b>, otherwise our program will\r\n    contain a subtle error that is very hard for us to locate.\r\n  In fact, some programmers advocate ALWAYS using block in\r\n    <b>if</b>/<b>else</b> statements to avoid dangling elses.\r\n  The disadvantage of this approach is that in simple cases, the extra\r\n    blocks create code that is harder to read.\r\n  We will discuss style principles in more detail later in the quarter.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- If Pragmatics -->\r\n\r\n<a name=\"IfPragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>if Pragmatics</b></td>\r\n<td width =\"80%\">\r\n  When writing decisions, determine the correct form: <b>if</b>,\r\n     <b>if/else</b>, or <b>cascaded if</b>.\r\n  If you are unsure about which one is correct, try the simpler forms first.\r\n  <p>\r\n  Indent the parts of the <b>if</b> and the statements that it contains to\r\n    illustrate the logical structure of the <b>if</b>; when blocks are used,\r\n    place the braces in the positions shown in the examples above.\r\n  Ensure that the indentation (making the code easier for humans to read)\r\n    accurately reflects how Java reads the tokens (e.g., beware of a dangling\r\n    else).\r\n  <p>\r\n  The key to understanding an <b>if</b> statement is understanding its test(s).\r\n  Ensure that for some values of its variables, every test can evaluate to\r\n    both <b>true</b> and <b>false</b> (otherwise the test is probably wrong).\r\n  For example, what is wrong with the following code?\r\n  <p>\r\n  Study it carefully and hand simulate it for a few different values of\r\n    <b>x</b>.\r\n<pre><b>  if (x > 2 || x < 5)\r\n    x++;</b></pre>\r\n  Is this test really the right one?\r\n    probably not: no <b>int</b> value stored in <b>x</b> makes the test\r\n    <b>false</b>; try to find one.\r\n  If it were correctly, we could simplify this code by removing the whole\r\n    <b>if</b> statement, simplifying it to just <b>x++</b>, which always\r\n    performs this action.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- For Statements -->\r\n\r\n<a name=\"ForStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>for Statements</b></td>\r\n<td width =\"80%\">\r\n  In Java, <b>for</b> statements allow us to repeatedly execute\r\n  another statement.\r\n<p>\r\n  To begin, we present a simple, useful, legal, but incomplete, form for the\r\n    <b>for</b> statement.\r\n  The EBNF rule for this simplified <b>for</b> statement is\r\n  <p>\r\n  <i>for-statement</i> <= <b>for(;;)</b> <i>statement</i>\r\n  <p>\r\n  We call <i>statement</i> the <i>body</i> of the <b>for</b> loop.\r\n  Although we write this EBNF rule on one line, we write <b>for</b> statements\r\n    in code that span at least two (and often many more) lines.\r\n  Finally, note that <b>for</b> is a keyword in Java.\r\n  <p>\r\n  The most typical form of the <b>for</b> statement is\r\n<pre><b>   for (;;) {\r\n     statements (i.e. a sequence of statements inside a block)\r\n   }</b></pre>\r\n  Here the body of the <b>for</b> is a block.\r\n  <p>\r\n  Semantically, Java executes the <b>for</b> statement by executing its body\r\n    over and over again.\r\n  Thus, when done executing the body, Java \"loops back\" and re-executes it.\r\n  That is why we often refer to such a statement as a \"for loop\".\r\n  Such a loop runs forever; or, more accurately, until Java executes a\r\n    <b>break</b> statement inside the loop (discussed in the next section)\r\n    forces Java to terminate the loop.\r\n  Two example <b>for</b> loops (each infinite) are  <pre><b>   for (;;)\r\n     System.out.println(\"You're Great!\");\r\n\r\n\r\n   int count = 0;\r\n   for (;;) {\r\n     System.out.println(count);\r\n     count++;\r\n   }</b></pre>\r\n  The first example fills the screen with <b>Your're Great!</b>.\r\n  The second example starts by displaying the value <b>0</b>, then <b>1</b>, then <b>2</b>,\r\n    then <b>3</b>, etc. with the next value displayed becoming larger by one for each\r\n    iteration.\r\n  <p> \r\n  Let's hand simulate this second example and write a trace table for it.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>count</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int count = 0;</td><td>0</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>\r\n  <tr valign=\"top\"><td>System.out.println(count);</td><td>&nbsp</td><td>0</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>1</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.println(count);</td><td>&nbsp</td><td>0<br>1</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>2</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.println(count);</td><td>&nbsp</td><td>0<br>1<br>2</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>3</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>...</td><td>...</td><td>...</td><td>...</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Of course, this process continues endlessly, so we cannot show a complete\r\n    trace table for this code or any other infinite loop.\r\n  You can always terminate a program in Eclipse by using by pressing the red \r\n    square in the console window, if you suspect your program is in an\r\n    infinite loop and you want to stop it.\r\n<p>\r\n  In the next section, we will explain how the <b>break</b> statement\r\n    allows the program itself to terminate the loop.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Break Statements -->\r\n\r\n<a name=\"BreakStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>break Statements</b></td>\r\n<td width =\"80%\">\r\n  The EBNF rule for the <b>break</b> statement is very simple\r\n  <p>\r\n  <i>break-statement</i> <= <b>break</b>;\r\n  <p>\r\n  Java imposes a syntax constraint that a <b>break</b> statement must appear\r\n    inside the body of some loop.\r\n  Finally, note that <b>break</b> is another keyword in Java.\r\n  <p>\r\n  In real programs, <b>break</b> statements appear inside <b>if</b> statements\r\n    (which themselves are inside the bodies of loops), so a typical example is\r\n<b><pre>   if (count == 0)\r\n     break;</b></pre>\r\n  Semantically, whenever a <b>break</b> statement is executed, Java terminates\r\n    the inner-most loop that it apears in; it <i>breaks</i> out of that loop.\r\n  Terminating a loop means Java next executes the statement AFTER the body of\r\n    the loop (it does not mean that the program terminates).\r\n  By putting a <b>break</b> statement inside an <b>if</b> statement, the\r\n    <b>if</b> can control (based on its <b>test</b>) whether or not the\r\n    <b>break</b> statement is executed: the <b>test</b> determines whether or\r\n    not the loop terminates on this iteration.\r\n  <p>\r\n  A tyical combination of <b>for</b> and <b>break</b> statements is\r\n<pre><b>   int countdown = 3;\r\n   for(;;) {\r\n     System.out.print(countdown + \"...\");\r\n     if (countdown == 0)\r\n       break;\r\n     countdown--;\r\n   }\r\n   System.out.println(\"Blastoff\");</b></pre>\r\n  Let's hand simulate this example and write a trace table for it.\r\n  We call such a <b>for</b>/<b>break</b> combination a <i>count down</i> loop.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <p>\r\n\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>countdown</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int countdown = 3;</td><td>3</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body first time</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>countdown--;</td><td>2</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...2...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>countdown--;</td><td>1</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...2...1...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>countdown--;</td><td>0</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...2...1...0...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement;</td>\r\n  <tr valign=\"top\"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>\r\n  <tr valign=\"top\"><td>System.out.println(\"Blastoff\");</td><td>&nbsp</td><td>3...2...1...0...Blastoff</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n   We can graphically summarize the control flow in cooperating <b>for</b> and <b>break</b> statements\r\n     as\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/forbreak.gif\"></image><p>\r\n\r\n\r\n\r\n<!-- More Examples -->\r\n\r\n<a name=\"MoreExamples\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>More for/break Examples</b></td>\r\n<td width =\"80%\">\r\n  Let's look at two more interesting kinds of loops that combine <b>for</b>\r\n     and <b>break</b>.\r\n  The first is called a <i>count up</i> loop: the variable <b>x</b> counts\r\n    up to the value stored in the variable <b>max</b>.\r\n  Notice that <b>max</b> is declared and initialized by the value entered by\r\n    the user.\r\n <b><pre>    int max = Prompt.forInt(\"Enter Number to Sum To\");\r\n    int x   = 0;       //Stores value to add to sum\r\n    int sum = 0;       //Stores sum that x is added to\r\n\r\n    for (;;) {\r\n      if (x == max)\r\n        break;\r\n      x++;\r\n      sum += x;\r\n    }\r\n    System.out.println(\"1+2+...+\" + max + \" = \" + sum);</pre></b>\r\n   Assuming the user enters <b>5</b> when prompted, let's hand simulate these\r\n     statements and write a trace table for it.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <p>\r\n\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>max</th><th>x</th><th>sum</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int max = Prompt(...);</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...: 5&nbsp</td><td>&nbsp</td>\r\n\r\n  <tr valign=\"top\"><td>int x = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int sum = 0;</td><td>&nbsp</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td>\r\n \r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>4</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>10</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>15</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement</td>\r\n  <tr valign=\"top\"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>\r\n\r\n  <tr valign=\"top\"><td>System.out.println(...);</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...:5<br>1+2+...+5 = 15</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThe second example is called a <i>sentinel terminated</i> loop.\r\nHere the user enters a special value (called a sentinel) to inform the program\r\n  that there are no more values to input.\r\nThe sentinel is not processed by the normal code in the loop body<b><pre>    int count = 0;\r\n    int sum   = 0;\r\n    for (;;) {\r\n      int score = Prompt.forInt(\"Enter a Score (-1 to Terminate)\");\r\n      if (score == -1)\r\n        break;\r\n      count++;\r\n      sum += score;\r\n    }\r\n    System.out.println(\"Average = \" + (double)sum/(double)count);</b></pre>\r\n   Assuming the user enters the value <b>3</b>, <b>6</b>, <b>4</b>, and the\r\n     sentinel <b>-1</b> respectively when prompted, let's hand simulate these\r\n     statements and write a trace table for it.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>count</th><th>sum</th><th>score</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int count = 0;</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int sum = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>Enter ...: 3</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= score;</td><td>&nbsp</td><td>3</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>Enter ...: 3<br>Enter ...: 6</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= score;</td><td>&nbsp</td><td>9</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>4</td><td>Enter ...: 3<br>Enter ...: 6<br>Enter ...: 4</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= score;</td><td>&nbsp</td><td>13</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>-1</td><td>Enter ...: 3<br>Enter ...: 6<br>Enter ...: 4<br>Enter ...: -1</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement</td>\r\n  <tr valign=\"top\"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>Undeclared</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>\r\n\r\n  <tr valign=\"top\"><td>System.out.println(...)</td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Average = 4.3333333</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\n  Notice that each time that the <b>for</b> loop executes its body, it\r\n    declares, intializes, then undeclares its local variable <b>score</b>.\r\n  This variable could be declared and left uninitialized before the loop, as\r\n    <b>int score;</b> and then appear in the loop as just\r\n    <b>score = Prompt.forInt(\"Enter a Score (-1 to Terminate)\");</b>.\r\n  But because the values stored in this variable are never (and should never\r\n    be)used outside the loop, we have chosen to not even declare this variable\r\n    outside the loop.\r\n  The fact that this variable is declared/undeclared many times does not\r\n    affect the correctness (nor the speed) of this code.\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Compact Trace Tables -->\r\n\r\n<a name=\"Compact\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Compact Trace Tables</b></td>\r\n<td width =\"80%\">\r\n  When we hand simulate programs with complicated control structures, most of \r\n    the trace table is occupied by information relating to control structures\r\n    deciding which statements to execute next, as opposed to statements that\r\n    actually change the state of variables or the console window.\r\n  Such trace tables are cumbersome to create and hard to read.\r\n  <p>\r\n  Compact trace tables remove all the information related to control\r\n     structures, and instead focus on state changes to variables and the\r\n     console window.\r\n  To construct a compact trace table, we list all variables and <b>Console</b>\r\n    in separate columns (and omit <b>Explanation</b>).\r\n  Only when the code changes the state of a variable OR the console window do\r\n    we update information in the appropriate column; and we always do so\r\n    right beneath the last entry for this column.\r\n  <p>\r\n  Note that what we lose in a compact trace table (we gain conciseness) is an \r\n    indication of the order in which different variables have their state\r\n    changed: because each column is shown as compactly as possible (no blank\r\n    entries); there is no correlation among columns whose states changed.\r\n  Here are compact trace tables for the three standard trace tables shown\r\n    above.\r\n  First, the <i>count down</i> loop.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">countdown</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Undeclared</td><td>(blank)</td>\r\n  <tr valign=\"top\"><td>3</td><td>3...</td>\r\n  <tr valign=\"top\"><td>2</td><td>3...2...</td>\r\n  <tr valign=\"top\"><td>1</td><td>3...2...1...</td>\r\n  <tr valign=\"top\"><td>0</td><td>3...2...1...0...</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>3...2...1...0...Blastoff</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Next, the <i>count up</i> loop.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">max</th><th>x</th><th>sum</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>(blank)</td>\r\n  <tr valign=\"top\"><td>5</td><td>0</td><td>0</td><td>Enter Number to Sum To: 5</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>1</td><td>1</td><td>1+2+...+5 = 15</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>2</td><td>3</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>3</td><td>6</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>4</td><td>10</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>5</td><td>15</td><td>&nbsp</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n Finally, the <i>sentinel terminated</i> loop.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">count</th><th>sum</th><th>score</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>(blank)</td>\r\n  <tr valign=\"top\"><td>0</td><td>0</td><td>3</td><td>Enter a Score (-1 to Terminate): 3</td>\r\n  <tr valign=\"top\"><td>1</td><td>3</td><td>6</td><td>Enter a Score (-1 to Terminate): 6</td>\r\n  <tr valign=\"top\"><td>2</td><td>9</td><td>4</td><td>Enter a Score (-1 to Terminate): 4</td>\r\n  <tr valign=\"top\"><td>3</td><td>13</td><td>-1</td><td>Enter a Score (-1 to Terminate): -1</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Average = 4.333333</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Remember, in a compact trace table, all the blank entries are at the bottom\r\n    of a column.\r\n  A column entry is filled in only when all the column entries on top of it\r\n    have been filled in.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- General for statement -->\r\n\r\n<a name=\"GeneralFor\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>General for/break; while/do</b></td>\r\n<td width =\"80%\">\r\n  We can write ANY looping code using the <b>for</b> and <b>break</b> that we\r\n    know; but, there is a more general form of the <b>for</b> statement that\r\n    allows use to write many loops more compactly and clearly.\r\n  When we study arrays, iterators, and self referential objects, these forms\r\n    will become more and more useful.\r\n  <p>\r\n  The general <b>for</b> statement packages all the information needed for a\r\n    count-down or count-up loop into one locality, making it easier to read,\r\n    write, and understand.\r\n  The EBNF rule for the general <b>for</b> statement is\r\n  <p>\r\n  <i>expression-list</i> <= <i>expression</i>{<b>,</b><i>expression</i>}<br>\r\n  <i>for-init</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>type variable-declarators</i> | <i>expression-list</i><br>\r\n  <i>for-update</i> &nbsp &nbsp &nbsp <= <i>expression-list</i><br>\r\n  <i>for-statement</i> &nbsp<= [<i>identifier</i>:] <b>for(</b>[<i>for-init</i>]<b>;</b>[<i>expression</i>]<b>;</b>[<i>for-update</i>]<b>)</b> <i>statement</i>\r\n  <p>\r\n  Note that if we discard all the options, we are back at the <b>for(;;)</b>\r\n    statement that we have studied.\r\n  As a syntax constraint, if the <i>expression</i> option (in the middle of the\r\n    semi-colons) is included, its resulting type must <b>boolean</b>: this\r\n    part is called the continuation test.\r\n  Also, each <i>expression</i> in an <i>expression-list</i> must adhere to the\r\n    same constraints as an <i>expression-statement</i>: it must apply a\r\n    state-change operator or a method call last in the expression.\r\n  <p>\r\n  For example, we can use such a <b>for</b> statements to simplify the code\r\n    that sums all the integers up to <b>max</b>.\r\n  <b><pre>  int max = Prompt.forInt(\"Enter Number to Sum To)\";\r\n  int sum = 0;       //Holds Sum of 1..x\r\n\r\n  for (int x=1; x<=max; x++)\r\n    sum += x;\r\n  System.out.println(\"1+2+...+\" + max + \" = \" + sum);</pre></b>\r\n  The <b>for</b> loop is so powerful that it reduces the body of the loop to a\r\n     single expression statement.\r\n  <p>\r\n  Semantically the <b>for</b> loop executes as follows.\r\n  <ol>\r\n    <li>Execute the code specified in <i>for-init</i>\r\n        (in the example, the declaration <b>int x=1</b>: if <i>for-init</i> is\r\n         a declaration, the scope of the variable(s) declared is the\r\n         <b>for</b> statement; any disappear when the loop terminates.\r\n    <li>Evaluate the test as specified in the <b>boolean</b> <i>expression</i>\r\n          (in this example <b>x <= max</b>): if <b>true</b> execute the body\r\n          of the <b>for</b> loop; if <b>false</b> terminate the <b>for</b>\r\n          loop.\r\n        If the <b>expression</b> is omitted, execute the body of the <b>for</b>\r\n          loop.\r\n    <li>After executing the entire body of the <b>for</b>, evaluate\r\n          <i>for-update</i> (in the example <b>x++</b>: note that the last\r\n          operator applied here is a stat-change operator).\r\n    <li>Continue back at step 2 (in the example, checking the continuation\r\n         test for the new value stored in <b>x</b>).\r\n  </ol>\r\n  <p>\r\n  Pictorially, the semantics look like<p>\r\n  <img src=\"images/forcontrol.gif\"></image><p>\r\n  What makes the <b>for</b> loop so powerful is the way it groups together,\r\n    in one locality, all the information that controls the loop.\r\n  Here is a standard (not compact) trace table illustrating these semantics\r\n    in the code above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>max</th><th>x</th><th>sum</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int max = ...;</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...: 5&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int sum = 0;</td><td>&nbsp</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>Initialize; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>4</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>10</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>15</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>false</b> terminate loop</td>\r\n  <tr valign=\"top\"><td>System.out.println(...);</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...:5<br>1+2+...+5 = 15</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note that the variable <b>x</b> becomes undeclared after the <b>for</b>\r\n    statement terminates.\r\n  Thus, we cannot refer to it after the <b>for</b> loop's body (where we print\r\n     the statistics); if we did write its name there, the Java compiler would\r\n     detect and report an error.\r\n  If we did want to refer to this value AFTER the <b>for</b> statement\r\n    finishes, we could write\r\n  <b><pre>  int max = Prompt.forInt(\"Enter Number to Sum To)\";\r\n  int sum = 0;       //Holds Sum of 1..x\r\n\r\n  int x = 1;\r\n  for (; x<=max; x++)\r\n    sum += x;\r\n  System.out.println(\"1+2+...+\" + max + \" = \" + sum + \" and x = \" + x);</pre></b>\r\n  Here, <b>x</b> is declared before the <b>for</b> statement, not in it, so it\r\n    remains declared after the <b>for</b> statement finishes.\r\n  Note that in this <b>for</b> statement, nothing appears before the first\r\n    semi-colon. \r\n  <p>\r\n  Finally, a <b>for</b> statement can be named by an <i>identifier</i>\r\n    (see the first option in the EBNF).\r\n  Likewise, there is a more general <b>break</b> statement whose EBNF is\r\n    <p>\r\n    <i>break-statement</i> <= <b>break</b> [<i>identifier</i>] ;\r\n    <p>\r\n  In a simple <b>break</b> statement, Java terminates the inner-most\r\n    loop that the <b>break</b> apears in.\r\n  If a general <b>break</b> statement includes this option, it has a\r\n     syntax constraint that it must appear inside a loop named by that same\r\n     <i>indentifier</i>, and it terminanes that loop.\r\n  This feature is only useful for loops inside loops, and even then it is\r\n    very very rarely needed.\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\n\r\n\r\n<a name=\"WhileDo\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>for,while,do Semantics</b></td>\r\n<td width =\"80%\">\r\n  We will now show the EBNF rule for <b>while</b> and <b>do</b> statements and \r\n    explain their semantics, and the general <b>for</b> statement, by using\r\n    the simple <b>for</b> and <b>break</b> statements.\r\n  The EBNF for <b>while</b> and <b>do</b> statements is\r\n  <p>\r\n  <i>while-statement</i> <= <b>while</b>(<i>expression</i>) <i>statement</i><br>\r\n  <i>do-statement</i> &nbsp &nbsp <= <b>do</b> <i>statement</i> <b>while</b> (<i>expression</i>);\r\n  <p>\r\n  Semantically, we can mechanically translate any general <b>for</b> loop,\r\n    <b>while</b> loop, or <b>do</b> loop into an equivalent simple\r\n    <b>for(;;)</b> loop.\r\n  The Java compiler performs just this kind of transformation when it\r\n    generates the machine instructions corresponding to these kinds of loops.\r\n  <b><pre>\r\n  for (init; continue; update)       {\r\n    statement                          init;\r\n                                       for (;;) {\r\n                                         if ( !(continue) )\r\n                                           break;\r\n                                         statement\r\n                                         update\r\n                                       }\r\n                                      }\r\n\r\n\r\n   while (continue)                   for(;;) {\r\n     statement                          if ( !(continue) )\r\n                                          break;\r\n                                        statement\r\n                                      }\r\n                        or even\r\n\r\n                                     for(;continue;)\r\n                                       statement\r\n\r\n   do                                 for(;;) {\r\n     statement                          statement\r\n   while (continue)                     if ( !(continue) )\r\n                                          break;\r\n                                      }</pre></b>\r\n  For the general <b>for</b> statement example above, this means\r\n  <b><pre>  for (int x=1; x<=max; x++)      {\r\n    sum += x;                       int x=1;\r\n                                    for (;;) {\r\n                                      if (!(x<=max))\r\n                                        break\r\n                                      sum += x;\r\n                                      x++;\r\n                                    }\r\n                                  }</pre></b>\r\n  Note that the value of <b>x</b> is declared inside a special block (the\r\n    outermost one); as described above, this variable disappears when the\r\n    <b>for</b> statement (the outermost block shown above in the translation)\r\n    terminates. \r\n  <p>\r\n  The <b>while</b> and <b>do</b> statements and just variants where the\r\n     continuation condition is always tested first or last in the loop's\r\n     body.\r\n  In the case of the <b>do</b> loop, the body is always executed once.\r\n  Pragmatically, you will see many more <b>while</b> loops than <b>do</b>\r\n    loops.\r\n <p>\r\n Finally, most students have two problems understanding general <b>for</b>\r\n    loops.\r\n <ul>\r\n   <li>They don't realize when the <b>update</b> is done: it is done AFTER the\r\n         loop body, right BEFORE <b>continue</b> is retested.\r\n       Also note that <b>x++</b> and <b>x=x+1</b> are valid expression\r\n         statements that can be used in <b>update</b> (but <b>x+1</b> is not,\r\n         because it contains no state-change operator)\r\n   <li>They try to use the variable declared in <b>init</b> outside the loop,\r\n         after it has terminated: this variable can be used only inside the\r\n         loop.\r\n </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- For/Break Pragmatics -->\r\n\r\n<a name=\"ForBreakPragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>for/break Pragmatics</b></td>\r\n<td width =\"80%\">\r\n  The following rules can help you synthesize and analyze (to fix bugs) loops.\r\n  When designing iterative code, think in terms of the simple <b>for</b> and\r\n    <b>break</b> statements and determine:\r\n  <ul>\r\n    <li>What statements belong before the loop (initialization code)\r\n    <li>What statements belong inside the body of the loop\r\n    <li>What condition terminates the loop\r\n    <li>Where that condition should be tested inside the loop\r\n  </ul>\r\n  Each iteration should allow some progress towards the termination condition\r\n     of the loop (making the <b>if test true</b>).\r\n  Sometimes it is easier to write the body of the loop first, and then\r\n    determine what initialization is necessary before the loop.\r\n  <p>\r\n  Sylistically, write loops as shown, with block braces as shown and the body\r\n    of the loop slightly indented (typically 2 spaces).\r\n  <p>\r\n  When hand simulating loops, pay special attention to the first few and last\r\n    few iterations (certain kinds of errors occur only at the beginning or\r\n    ending of a loop).\r\n  Ensure that all the variables are properly initialized before they are\r\n    examined in expressions (the Java compiler will help you here).\r\n  Errors due to incorrect initialization are easy to spot if we carefully hand\r\n    simulate the first iteration of a loop (and these are among the most\r\n    frequent category of errors).\r\n  <p>\r\n  The <b>break</b> statement is the most important statement inside a loop.\r\n  Clearly mark <b>break</b> statements using white space and/or special\r\n    comments (e.g., a comment sandwich).\r\n  Ensure that for all possible initial states of its variables, a loop\r\n    eventually terminates (the <b>test</b> in the <b>if</b> statement\r\n    containing the <b>break</b> will always eventually evaluate to\r\n    <b>true</b>).\r\n  <p>\r\n  Most loops, even in industrial code, need one <b>if</b>/<b>break</b>\r\n    combination.\r\n  A loop to solve a very complicated problem may require multiple \r\n    <b>if</b>/<b>break</b> combinations, but they can often be localized\r\n    (grouped together).\r\n  Only a loop that solves the most complicated kind of problems may require\r\n    multiple <b>if</b>/<b>break</b> combinations distributed throughout the\r\n    loop's body.\r\n  <p>\r\n  It is the mark of a good programmer to write simple loops with simple\r\n      terminations.\r\n  The most frequent occuring location for the <b>if</b>/<b>break</b> is the\r\n    first statement in the body of the <b>for</b> loop (try it there first,\r\n    move it elsewhere if necessary).\r\n  Such a <b>for/break</b> combination can also be written as a <b>while</b>\r\n    loop.\r\n  <p>\r\n  Finally, use the general form of the <b>for</b> statement to its maximum \r\n    advantage, to clarify your loops.\r\n  You may use <b>while</b> and <b>do</b> loops, but the extra thought that\r\n    goes into considering them, and the fact that it is often harder to think\r\n    of a \"continuation\" condition rather than a \"termination\" condition, means\r\n    that I use them infrequently, preferring the <b>for/break</b> combination.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Boxing Statements -->\r\n\r\n<a name=\"Boxing2\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Boxing if, for, and break Statements</b></td>\r\n<td width =\"80%\">\r\n  Continuing our analysis of boxing statements, we illustrate below how to box\r\n    <b>if</b>, <b>for</b> and <b>break</b> statements (as well as expression\r\n    and block statements).\r\n  Notice that EVERYTHING that can be syntactically considered to be a\r\n    statement is in its own box.\r\n  This includes declarations statements (there are none here), expression\r\n    statements, blocks, entire <b>if</b> statements, <b>break</b> statements,\r\n    and entire <b>for</b> statements. \r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/boxed2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  General <b>for</b> loops are boxed in a similar manner; none of the\r\n    information within their parentheses are considered statements.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Try-Catch -->\r\n\r\n<a name=\"TryCatch\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>try-catch</b></td>\r\n<td width =\"80%\">\r\n  The EBNF of the <b>try-catch</b> statement is the most complex of any\r\n    control structure that we have seen so far: that is a tipoff that\r\n    programming in Java with exception handling is interesting.\r\n  In fact, many Java courses don't cover exceptions and exception handling\r\n    until much later in the quarter.\r\n  But, I think that the core concepts can be demonstrated early, can be used\r\n    to good advantage in stereotypical ways that are easy to understand, and\r\n    can be returned to repeatedly in more complicated contexts (a spiral\r\n     approach to learning).\r\n  The general form of a <b>try-catch</b> statement is\r\n  <p>\r\n  <i>parameter</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>type</i> <i>identifier</i><br>\r\n  <i>catch-clause</i> &nbsp  &nbsp &nbsp &nbsp &nbsp &nbsp<= <b>catch</b> (<i>parameter</i>) <i>block-statement</i><br>\r\n  <i>try-catch-statement</i> <= <b>try</b> <i>block-statement</i> {<i>catch-clause</i>}[<b>finally</b> <i>block-statement</i>]\r\n  <p> \r\n  Although we write the <i>try-catch-statement</i> EBNF rule on one line,\r\n    <b>try-catch</b> statements written in our code often span many \r\n    lines (they contain mandatory blocks, which can contain many statements\r\n    on different lines).\r\n  The names of exceptions are actually special reference types.\r\n  Although this is getting a bit ahead of ourselves, we will use the following\r\n    reference types/exception names: <b>ArithmeticException</b>,\r\n    <b>NumberFormatException</b>, <b>IllegalArgumentException</b>,\r\n    <b>IllegalStateException</b>, <b>IOException</b>, and <b>Exception</b>\r\n    (a generic name that includes all the others). \r\n  <p>\r\n  As a syntax constraint, the right hand side of each\r\n    <i>try-catch-statement</i> must have at least one <i>catch-clause</i> or\r\n    one <b>finally</b>; there can be many of the former, and a combination\r\n    of both, but we cannot take 0 repetitions of <i>catch-clause</i> and at\r\n    the same time discard the <b>finally</b> block.\r\n  We could actually encode this restriction in EBNF, but it would make a\r\n    complicated description look even more complex.\r\n  <p>\r\n  The semantics of this statement, as you might expect, are complicated as\r\n    well.\r\n  Java starts a <b>try-catch</b> by sequentially executing the statements\r\n    in the <i>block-statement</i> immediately following the keyword <b>try</b>\r\n   (known as the <b>try</b> block), just as it would execute any block.\r\n  One of two things happen.\r\n  <ul>\r\n    <li>If no statement in the <b>try</b> block throws an exception, after the \r\n         last statement in the block is executed, Java executes the\r\n         <b>finally</b> block (if this option was included).\r\n       Java is now done with the <b>try-catch</b> statement and executes the\r\n          next statement following it.\r\n    <p>\r\n    <li>If some statement in the <b>try</b> block throws an exception, the rest\r\n          of the statements in that block are skipped.\r\n        Java tries to find a <i>catch-clause</i> whose <i>parameter</i>\r\n          matches the name of the exception that was thrown; the generic name\r\n          <b>Exception</b> matches all exception names.\r\n        <ul>\r\n          <li>If the name is found, Java executes its associate block, and\r\n               then Java executes the <b>finally</b> block (if this option was\r\n               included).\r\n              Java is now done with the <b>try-catch</b> statement and executes\r\n                the next statement following it.\r\n          <li>If the name is NOT found, Java executes the <b>finally</b> block\r\n                (if this option was included).\r\n              Java then skips code while it looks for another, more outer\r\n                 <b>try-catch</b> statement: one whose\r\n                 <i>catch-clause</i> does name the exception.\r\n              <ul>\r\n                <li>If one is found, follow the rule above.\r\n                    Note that it DOES NOT return to the original, inner\r\n                    <b>try-catch</b> statement.\r\n                 <li>If one is NOT found, Java terminates the programs, citing\r\n                       an uncaught exception.\r\n                     Typically, this results in a trace: it prints on the\r\n                       console the name of the uncaught exception and what\r\n                       methods were active when the exception was thrown.\r\n              </ul>\r\n        </ul>\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- An Example -->\r\n\r\n<a name=\"AnExample\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Simple Example</b></td>\r\n<td width =\"80%\">\r\n  In this section we will present a simplified example: it is not useful in\r\n    real programs, but is useful only to illustrate the semantics of \r\n    <b>try-catch</b> statements.\r\n  Recall that the <b>/</b> operator throws an exception named\r\n    <b>ArithmeticException</b> if its second operand is zero.\r\n  Let us examine the effect of placing the following <b>try-catch</b>\r\n    statement in a program.\r\n<pre><b>  int percentage;\r\n  ...some code\r\n  try {\r\n    int attended = Prompt.forInt(\"Enter attendance\");\r\n    int capacity = Prompt.forInt(\"Enter capacity\");\r\n    percentage = 100*attended/capacity;\r\n    System.out.Println(\"percentage computed ok\");\r\n  }\r\n  catch (ArithmeticException a) {\r\n    System.out.println(\"capacity was 0; I'll assume percentage was 100%\");\r\n    percentage = 100;\r\n  }\r\n  ... more code</b></pre>\r\n  Here, if the division succeeds, <b>percentage</b> is set correctly, the\r\n    \"ok\" message is printed, the <b>try</b> block finishes normally, and\r\n    execution continues afterward, where it says <b>...more code</b> \r\n    (because there is no <b>finally</b> block).\r\n  <p>\r\n  On the other hand, if the division fails (throwing\r\n     <b>ArithmeticException</b>), <b>percentage</b> is not set (the <b>=</b>\r\n    operator is never evaluted; it requires the result from the division which\r\n    we have just seen has thrown an exception) the \"ok\" message is skipped as\r\n    Java locates the appropriate <i>catch-clause</i>; both statements in the\r\n    <i>catch-clause</i> block are executed, then the <b>try</b> block finishes,\r\n    and execution again continues afterward, where it says <b>...more code</b>\r\n    (because there is no <b>finally</b> block).\r\n  <p>\r\n  If we replaced <b>ArithmeticException</b> by <b>Exception</b> then the code\r\n    would execute identically, because <b>Exception</b> matches all raised\r\n    exceptions.\r\n  If we replaced <b>ArithmeticException</b> by any other name, say\r\n    <b>IOException</b> then Java would not find a matching exception;\r\n    assuming that there is no outer <b>try-catch</b> statement to catch this\r\n    exception, Java would terminate the program and print a trace on the\r\n    console.\r\n  <p>\r\n  One reason why this example is not realistic is that we can easily check\r\n    whether the division will fail with an <b>if</b> statement and avoid the\r\n    need for a <b>try-catch</b> statement all together.\r\n<pre><b>  int percentage;\r\n  ...some code\r\n  int attended = Prompt.forInt(\"Enter attendance\");\r\n  int capacity = Prompt.forInt(\"Enter capacity\");\r\n  if (capacity != 0) {\r\n    percentage = 100*attended/capacity;\r\n    System.out.Println(\"percentage computed ok\");\r\n  }else {\r\n    System.out.println(\"capacity was 0; I'll assume percentage was 100%\");\r\n    percentage = 100;\r\n  }\r\n  ... more code</b></pre>\r\n  In the following two examples, which are much more realistic, we will need a\r\n    <b>try-catch</b> statement to solve the problem: we cannot use an\r\n    <b>if</b> statement to check whether an exception is about to be thrown.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- A Prompting Example-->\r\n\r\n<a name=\"Prompting\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Prompting with try-catch</b></td>\r\n<td width =\"80%\">\r\n  In this section we will present a more realistic example.\r\n  In fact, similar code appears inside the <b>Prompt.forInt</b> method.\r\n  Understanding how this code works requires a mastery of the semantics of many\r\n    Java statements.\r\n  First, we must know that the <b>Integer.parseInt</b> method (from the Java\r\n    library) has the following prototype\r\n  <pre><b>int Integer.parseInt(String) throws NumberFormatException</b></pre>\r\n  This methods takes a <b>String</b> as an argument.\r\n  If that argument represents the value of a legal integer, it returns that\r\n    value as an <b>int</b>; if it does not represent a legal integer, it\r\n    cannot return any reasonable value, so it throws\r\n    <b>NumberFormatException</b>.\r\n  <p>\r\n  Thus  <b>Integer.parseInt(\"-10\")</b> returns the <b>int -10</b> and\r\n  <b>Integer.parseInt(\"-1x0\")</b> throws <b>NumberFormatException</b>.\r\n  There is no method that Java provides to check whether\r\n    <b>Integer.parseInt</b> will throw an exception: we have to call that\r\n    method to see what it does.\r\n  <p>\r\n  Now, let us see how the following code, a combination of a <b>for</b> loop,\r\n    <b>break</b> statement (not in an <b>if</b>!) and <b>try-catch</b>,\r\n    prompts the usre until he/she enters a valid integer, whose value is\r\n    stored into <b>answer</b>\r\n  <pre><b>  int answer;\r\n  for(;;)\r\n    try {\r\n      answer = Integer.parseInt(Prompt.forString(\"Enter integer\"));\r\n      break;\r\n    }\r\n    catch (NumberFormatException e) {\r\n      System.out.println(\"Error: please enter a valid integer\");\r\n    }\r\n  ...process answer</b></pre>\r\n  Here, the <b>for</b> loop repeatedly executes the <b>try-catch</b> statement.\r\n  First, let us see what happens if the user enters a valid integer.\r\n  During the first iteration of the loop, Java executes the first statement;\r\n    the user enters a valid integer (read as a <b>String</b> that is passed to\r\n    the <b>Integer.parseInt</b> method); so, this method does not throw an\r\n    exception, but instead returns a result that is stored in <b>answer</b>.\r\n  Thus, the second statement in the block is reached; this <b>break</b>\r\n    statement terminates the entire <b>for</b> loop, and execution continue \r\n   after the <b>for</b> loop, where it says <b>...process answer</b>.\r\n  <p> \r\n  Now, let us see what happens if the user enters an INVALID integer.\r\n  During the first iteration of the loop, Java executes the first statement;\r\n    the user enters an invalid integer (read as a <b>String</b> that is passed\r\n    to the <b>Integer.parseInt</b> method); so, this method throws a\r\n    <b>NumberFormatException</b>.\r\n  Java skips the <b>break</b> statement and instead finds the <b>catch</b>\r\n    matching the exception; its following block prints an error message.\r\n  Now the <b>try-catch</b> statement is finished; but this statement is the\r\n    body of a <b>for</b> loop, so it is executed again!\r\n  <p>\r\n  Therefore, this loop will continue executing so long as the user enters an\r\n    invalid integer; the first time that the user enters a valid integer (see\r\n    the description above) its value will be stored into <b>answer</b> and\r\n    the <b>break</b> statement following it will be executed to terminate the\r\n    loop.\r\n  <p>\r\n  So generally, we have designed code that (potentially) repeatedly performs\r\n    some operation until an exception is NOT thrown.\r\n  In the next section, we will design code that repeatedly performs some\r\n    operation until an exception IS thrown: e.g., we are anticipating that\r\n    an exception will eventually terminate the loop, which continues executing\r\n    until it is does.\r\n  Together, these two forms occur frequently in exception handing code.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- A File/Reading Example-->\r\n\r\n<a name=\"FileReading\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Reading Files with try-catch</b></td>\r\n<td width =\"80%\">\r\n  In this section we will present another realistic example.\r\n  In fact, code similar to this will be present in most programs that read\r\n     files.\r\n  First, we must learn that the <b>readInt</b> method (from a Java library\r\n    class that I have written) has the following prototype\r\n  <pre><b>int readInt() throws NumberFormatException, EndOfFileException</b></pre>\r\n  This method skips any white space in a file and returns the next integer\r\n    value that it contains (if it succeeds).\r\n  There are two ways for it to fail, each denoted by a different exception\r\n    name.\r\n  <ol>\r\n    <li>There is a value in the file, but it is not an integer; in this case\r\n          the method throws <b>NumberFormatException</b>.\r\n    <li>There are no more values (of any type) in the file; in this case the\r\n          method throws <b>EndOfFileException</b>.\r\n  </ol>\r\n  The following code assumes the variable <b>inputFile</b> refer to an object\r\n    representing a file (we'll learn more about this in a later lecture).\r\n  It reads every value in a file, accumulating the sum, and ultimately\r\n    printing it.\r\n  <pre><b>  int sum = 0;\r\n  for (;;)\r\n    try {\r\n      int aValue = inputFile.readInt();\r\n      sum += aValue;\r\n    }\r\n    catch (EndOfFileException eofe) {\r\n     break;\r\n    }\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n  Let us see what happens if the file contains two integers.\r\n  <ol>\r\n  <li>Java starts to execute the <b>for</b> loop, which contains just one\r\n     statement: a  <b>try</b> block,\r\n  During this first iteration of the loop, Java executes the first statement in\r\n    the <b>try</b>. block; calling the <b>readInt</b> method reads a valid\r\n    integer from the file and stores into <b>aValue</b>.\r\n  In the next statement the <b>sum</b> is incremented by this value.\r\n  The <b>try</b> block is finished, and the <b>for</b> loop executes it a\r\n    second time.\r\n  <li>During the second iteration of the loop, Java executes the first\r\n    statement in the <b>try</b>. block; calling the <b>readInt</b> method reads\r\n    another valid integer from the file stores into <b>aValue</b>.\r\n  In the next statement the <b>sum</b> is incremented by this new value.\r\n  The <b>try</b> block is finished, and the <b>for</b> loop executes it a\r\n    third time.\r\n  <li>During the third iteration of the loop, Java executes the first\r\n    statement in the <b>try</b>. block; calling the <b>readInt</b> methods\r\n    causes it to throw <b>EndOfFileException</b>, because there are no more\r\n    values in the file to read.\r\n  This error is caught by the <b>catch (EndOfFileException eofe)</b> clause,\r\n     whose block contains a <b>break</b> statement that terminates the\r\n     <b>for</b> loop.\r\n  Java continues by executing the statement after the <b>for</b> loop,\r\n     printing the accumulated sum.\r\n  </ol>\r\n  <p>\r\n  This code repeatedly performs some operation until an exception is\r\n     thrown.\r\n  Note that if a non-integer value appears in the file, then calling the\r\n    <b>readInt</b> method causes it to throw <b>NumberFormatException</b>.\r\n  This exception is not caught by the <b>try-catch</b> shown above, so \r\n    Java terminates the program and prints a trace on the console.\r\n  <p>\r\n  Finally, because the only place that <b>aValue</b> is used is to add to\r\n     <b>sum</b>, we can simplify this code a bit and write.\r\n  <pre><b>  int sum = 0;\r\n  for (;;)\r\n    try {\r\n      sum += inputFile.readInt();\r\n    }\r\n    catch (EndOfFileException eofe) {\r\n      break;\r\n    }\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, or any other student.\r\n  <ol>\r\n    <li>Explain which of the following state-change expressions are legal and illegal.\r\n        Assume we have declared <b>int a,b,c;</b>.\r\n        <b><pre>   a + b = c;\r\n   a = 2++;\r\n   (a = b) = c;\r\n   a = Prompt.forInt(\"Enter a\") + b;\r\n   a = System.out.println(\"Success!\");</pre></b>\r\n    \r\n    <p>\r\n    <li>In each of the following expression statements, carefully apply your knowledge of syntax\r\n          (tokens, operator precedence, and associativity) and semantics to explain (a) What values\r\n          are stored in all variables whose states are changed. (b) What is the result computed by\r\n          the expression. (c) What oval diagram illustrates parts a and b.\r\n        Assume that each statement is executed just after the declaration <b>int a=3, b=5, c=8;</b>\r\n<b><pre>   a = b++ + c;\r\n   a = b + ++c;\r\n   c = b+++c++;\r\n   a+=b+=c+=1;\r\n   a = b = c + 1;\r\n   a = (b = c) + 1;\r\n   System.out.println(\"\" + ++b + b);\r\n   System.out.println(\"\" + b++ + b);</pre></b>\r\n\r\n    <p>\r\n    <li>Explain what is displayed on the console for the top and bottom block.\r\n        Assume we have declared <b>int i; char c;</b> and that the ASCII equivalent of <b>'A'</b>\r\n          is <b>65</b>.\r\n    <pre><b>   {i = 'A';  System.out.println(i);}\r\n   {c =  65;  System.out.println(c);}</b></pre>\r\n    <p>\r\n\r\n    <li>Show what is displayed in the console window after Java executes the following expression\r\n          statements.\r\n        Be very careful to show which word occurs on which lines.\r\n        Remember that the escape character <b>\\n</b> starts a new line.\r\n    <pre><b>   System.out.print(\"When \" + \"in \");\r\n   System.out.println( \"the \"\r\n        + \"course \"\r\n        + \"of \");\r\n   System.out.print(\"human\\nevents \");\r\n   System.out.print(\"it \");\r\n   System.out.print(\"becomes \");\r\n   System.out.println(\"necessary \");\r\n   System.out.print(\"for one nation to sever...\");</b></pre>\r\n    \r\n    <p>\r\n    <li>Examine the following 6 blocks (all are are permutations of the same three\r\n          statements).\r\n        Classify each block as syntactically legal or illegal (hint: certain statement\r\n          orderings are illegal because they violate a constraint on where a variable\r\n          declared inside a block can be used).\r\n        For those blocks that are legal, determine whether or not they swap of the values\r\n          stored in <b>x</b> and <b>y</b>.<pre><b>        {int temp=x; x=y;        y=temp;}\r\n        {int temp=x; y=temp;     x=y;}\r\n        {x=y;        int temp=x; y=temp;}\r\n        {x=y;        y=temp;     int temp=x;}\r\n        {y=temp;     x=y;        int temp=x;}\r\n        {y=temp;     int temp=x; x=y;}</b></pre>\r\n\r\n    <p>\r\n    <li>Examine each of the following statements; determine whether it is true or\r\n          false (and be prepared to support your answer or show a counter example).\r\n        <ul>\r\n          <li>A block can be empty (contain no statements).\r\n          <li>A block can be unitary (contain 1 statement).\r\n          <li>The statements <b>x=y;</b> and <b>y=x;</b> have identical meanings.\r\n          <li>If we declare <b>int x=5,y=8;</b> and Java executes the expression statement\r\n                <b>x=y;</b> immediately followed by <b>y=3;</b> then\r\n                both <b>x</b> and <b>y</b> now store <b>3</b>.\r\n          <li>A single statement can change the state of more than one variable.\r\n        </ul>\r\n\r\n    <p>\r\n    <li>The following block is rejected at compile time by the Java compiler.\r\n        Write the error message that Java reports.\r\n        Explain why it makes sense to recognize this problem and report the error.\r\n<pre><b>  {\r\n    int a;\r\n    System.out.println(\"a = \" + a);\r\n  }</b></pre>\r\n\r\n    <p>\r\n    <li>Which of the following is easier to understand: the single statement or double statement?\r\n        Verify that both perform the same computation.\r\n<pre><b>  myPurse += stakes + 0*(myWins++);          myWins++;\r\n                                             myPurse += stakes;</b></pre>\r\n    <p>\r\n    <li>Assume that we declare a\r\n          <b>char grade;</b> and guarantee that it stores a letter corresponding\r\n          to a UCI grade: <b>'A'</b>, <b>'B'</b>, <b>'C'</b>, <b>'D'</b>, or <b>'F'</b>.\r\n        Write an <b>if</b> statement that computes the number of quality points for that grade\r\n          and stores it in <b>int qp;</b>\r\n        an A is worth 4, a B is worth 3, a C is worth 2, a D is worth 1, and an R is worth 0.\r\n    <p>\r\n\r\n\r\n\r\n   <li>Assume that we declare\r\n         <b>int hours;</b>\r\n       Write an <b>if</b> statement that computes the pay (in cents) due a worker according the following\r\n         formulas: <b>625*Hours</b> if the hours worked is less than or equal to 40;\r\n         <b>625*Hours + 725*(Hours-40)</b> if the hours worked is greather than 40.\r\n       Store the result in <b>int centsPay;</b>\r\n       Try a few examples under, at, and over 40 hours to verify your statement is correct.\r\n   <p>\r\n\r\n    <li>Assume that we declare \r\n           <b>int x, y; boolean isIt;</b>\r\n         Write a trace table for the hand simulation of the following Java statements: one where\r\n           <b>x</b> stores <b>3</b> and <b>y</b> stores <b>5</b>; and another where \r\n           <b>x</b> stores <b>5</b> and <b>y</b> stores <b>3</b>.\r\n         State whether the results are the same or different in each case.<b><pre>   if (x < y )            if (x < y)\r\n     isIt = true;          isIt = true;\r\n   else                  isIt = false;\r\n     isIt = false;</pre></b>\r\n      Which statement side is equivalent to the expression statement <b>isIt = (x < y);</b>\r\n    <p>\r\n\r\n    <li>Assume that we declare \r\n          <b>int studentAnswer, correctAnswer, wrongCount;</b>\r\n         Explain what is wrong with the following statement (there is a syntax error).<b><pre>   if (studentAnswer == correctAnswer)\r\n   else\r\n     wrongCount++;</pre></b>\r\n      Explain how to fix this problem in a simple way.\r\n    <p>\r\n\r\n    <li>Modify the <b>cascaded if</b> for computing grades, so that <b>grade</b> stores <b>'?'</b> if\r\n           <b>testScore</b> is outside the range <b>0</b> to <b>100</b> inclusive. \r\n     <p>\r\n\r\n     <li>Write a trace table for the clock code, if the clock starts at 11:59pm (one minute before midnight).  \r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>double s, signum;</b>\r\n         Write a cascaded <b>if</b> statement(s) that stores into <b>signum</b> the value <b>-1.</b> if <b>X</b> is less\r\n            than <b>0.</b>; <b>0.</b> if <b>X</b> is equal to <b>0.</b>; <b>1.</b> if <b>X</b> is greater than\r\n            <b>0.</b> \r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>double min, x, max;</b>\r\n         Write a cascaded <b>if</b> statement(s) that stores into <b>x</b> the value <b>min</b> if <b>x</b> is less\r\n            than <b>min</b>; <b>max</b> if <b>x</b> is greater than <b>max</b>; nothing new otherwise.\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>int x,y,z,min;</b>\r\n         Write an <b>if</b> statement(s) that stores into <b>min</b> the minimum of the values stored in\r\n            <b>x</b>, <b>y</b>, and <b>z</b>.\r\n         Try to do this with the minimum amount of code.\r\n     <p>\r\n\r\n     <li>Re-examine the <b>cascade if</b> that computes a course grade.\r\n         Which of the following statements are equivalent to it (do the same thing for all values\r\n           stored in <b>testScore</b>)?<b><pre>    if (testScore >= 60)             if (testScore < 60)\r\n      grade = 'D';                     grade = 'F';\r\n    else if (testScore >= 70)        if (testScore < 70)\r\n      grade = 'C';                     grade = 'D';\r\n    else if (testScore >= 80)        if (testScore < 80)\r\n      grade = 'B';                     grade = 'C';\r\n    else if (testScore >= 90)        if (testScore < 90)\r\n      grade = 'A';                     grade = 'B';\r\n    else                             else\r\n      grade = 'F';                     grade = 'A';</pre></b>\r\n        What simple changes would correct any incorrect code?\r\n     <p>\r\n\r\n     <li>Suppose that we modify the clock code to call <b>emitBeeps</b> at the bottom of its block,\r\n           and also change its argument to just <b>hour</b>.\r\n         Will this code always work as before?\r\n         If not, for what <b>hour</b> and <b>minute</b> combination(s) will it fail?<b><pre>\r\n     if (minute != 59)\r\n       minute++;\r\n     else {\r\n       minute = 0;\r\n       if (hour != 23)\r\n         hour++;\r\n       else\r\n         hour = 0;\r\n       emitBeeps(hour);\r\n     }</pre></b>\r\n        Note that to be correct, the code must be correct for every <b>hour</b> and <b>minute</b>.\r\n        There are 24x60 = 1,440 different possiblities; which ones are crucial to check?\r\n     <p>\r\n\r\n     <li>Suppose that we modify the clock code as follows.\r\n         Will this code always work as before?\r\n         If not, for what <b>hour</b> and <b>minute</b> will it fail?<b><pre>\r\n     minute++;\r\n     if (minute == 60} {\r\n       minute = 0;\r\n       hour++;\r\n       emitBeeps(hour);\r\n       if (hour == 24)\r\n         hour = 0;\r\n     }</pre></b><br>\r\n        Note that to be correct, the code must be correct for every <b>hour</b> and <b>minute</b>.\r\n        There are 24x60 = 1,440 different possiblities; which ones are crucial to check?\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>int hour;</b>\r\n         storing the values <b>0</b> through <b>23</b> as described above.\r\n         Write an <b>if</b> statement(s) to display on the console the hour in a standard format:\r\n           e.g., when <b>hour</b>\r\n           stores <b>3</b> display <b>3am</b>; when <b>hour</b> stores 15 display <b>3pm</b>.\r\n         When <b>hour</b> stores <b>0</b> display <b>12midnight</b> and when <b>hour</b> stores\r\n           <b>12</b> display <b>12noon</b>.\r\n         Try to do this with the simplest possible code.\r\n     <p>\r\n\r\n     <li>Write a standard trace table for the following code, when the user enter the value\r\n           <b>3</b>; write a compact trace table for this value, and when the user enters <b>7</b>.     <b><pre>  int cycleCount = 0;\r\n  int test = Prompt.forInt(\"Enter value to test\");\r\n  for (;;) {\r\n    cycleCount++;\r\n\r\n    //////////////\r\n    if (test == 1)\r\n      break;\r\n    //////////////\r\n\r\n    if (test%2 == 0)\r\n      test = test/2;\r\n    else\r\n      test = 3*test + 1;\r\n  }\r\n  System.out.println(\"Finished in \" + cycleCount + \" cycles\");</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>The following two code fragments are identical to the original count down code,\r\n           but the <b>if</b> appears in different locations inside the loop.\r\n         Write a standard trace table for each showing its behavior and results.\r\n         Can you change the <b>test</b> in the <b>if</b> to produce the original results?<b><pre>\r\n   int countdown = 3;\r\n   for (;;) {\r\n     if (countdown == 0)\r\n       break;\r\n     System.out.println(countdown + \"...\");\r\n     countdown--;\r\n   }\r\n   System.out.println(\"Blastoff\");\r\n\r\n\r\n   int countdown = 3;\r\n   for (;;) {\r\n     System.out.println(countdown + \"...\");\r\n     countdown--;\r\n     if (countdown == 0)\r\n       break;\r\n   }\r\n   System.out.println(\"Blastoff\");</pre></b>\r\n  <p>\r\n\r\n  <li>The following code fragment is identical to the original sentinel code,\r\n         but the <b>if</b> appears in a different location inside the loop.\r\n      Write a standard trace table for each showing its behavior and results.<b><pre>    int count = 0;\r\n    int sum   = 0;\r\n    int score;\r\n    for (;;) {\r\n      score = Prompt.forInt(\"Enter a Score (-1 to Terminate)\");\r\n      count++;\r\n      sum += score;\r\n      if (score == -1)\r\n        break;\r\n    }\r\n    System.out.println(\"Average = \" + (double)Sum/(double)Score);</pre></b>\r\n  <p>\r\n\r\n  <li>Rewrite the countdown loop more compactly, so that it uses a general\r\n    <b>for</b> statement (without <b>if</b>/<b>break</b> in its body).\r\n  <p>\r\n\r\n  <li>Rewrite the sentinel loop twice, so that it uses a <b>while</b>\r\n        loop and a <b>do</b> loop.\r\n      It can be done, but what problem arises?\r\n  <p>\r\n\r\n\r\n  <li>The following code can be used to ensure that the user enters a positive value.\r\n      Write a standard trace table for the following code, assuming the user enters the values\r\n        <b>-5</b>, <b>-1</b>, and <b>8</b> respectively.<b><pre>\r\n  int positive;\r\n  for (;;) {\r\n    positive = Prompt.forInt(\"Enter Positive Value\");\r\n\r\n    //////////////\r\n    if (positive >= 1)\r\n      break;\r\n    //////////////\r\n\r\n    System.out.println(\"Sorry, \" + positive + \" isn't postive!\");\r\n  }\r\n  System.out.println(\"positive = \" + positive);</pre></b>\r\n  What changes would be necessary to ensure the user entered a positive and even value?\r\n  <p>\r\n\r\n\r\n  <li>Write a compact trace table for the following code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>7</b>, <b>-3</b>, <b>-7</b>, <b>8</b>, <b>-8</b>, <b>11</b>,\r\n        <b>15</b>, <b>-5</b>, <b>9</b>, and <b>-100</b> respectively.<b><pre>  int zcc = 0;\r\n  int p = Prompt.forInt(\"Enter Value\");\r\n  for (;;) {\r\n    int c;\r\n    c = Prompt.forInt(\"Enter Value\");\r\n\r\n    //////////////\r\n    if (c == -100)\r\n      break;\r\n    //////////////\r\n\r\n    if (p < 0 != c < 0)\r\n      zcc++;\r\n\r\n    p = c;\r\n  }\r\n  System.out.println(\"Final zcc = \" + zcc);</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>Write a compact trace table for the following code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>7</b>, <b>3</b>, <b>7</b>, <b>7</b>, <b>8</b>, <b>11</b>,\r\n        <b>15</b>, <b>5</b>, <b>9</b>, and <b>-1</b> respectively.<b><pre>  int ll = 0;\r\n  int cl = 0;\r\n  int p = Prompt.forInt(\"Enter Value\");\r\n  for (;;) {\r\n    if (cl > ll)\r\n      ll = cl;\r\n   \r\n    int c = Prompt.forInt\"Enter Value\")\r\n\r\n    //////////////\r\n    if (c == -1)\r\n      break;\r\n    //////////////\r\n\r\n    if (p < c)\r\n      cl++;\r\n    else\r\n      cl = 0\r\n\r\n    p = c;\r\n  }\r\n  System.out.println(\"Final ll = \" + ll);</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>Write code (see the previous two problems for inspiration) that determines whether all the\r\n        values it prompts for (use <b>-1</b> as a sentinel) are in strictly increasing order:\r\n        each value is greater than the one that precedes it.\r\n      It should store its final answer in a <b>boolean</b> variable named <b>isIncreasing</b>.\r\n      Write two compact trace tables for your code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>3</b>, <b>5</b>, <b>2</b>, <b>4</b>, and <b>-1</b> the\r\n        first time; and <b>4</b>, <b>5</b>, <b>7</b>, <b>7</b>, <b>-1</b> the second time.\r\n  <p>\r\n\r\n\r\n  <li>Write code that counts the number of strictly increasing pairs\r\n        of values the user enters (use <b>-1</b> as a sentinel).\r\n      It should store its final answer in an <b>int</b> variable named <b>increasingPairCount</b>.\r\n      Write two compact trace tables for your code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>3</b>, <b>3</b>, <b>7</b>, <b>6</b>, <b>8</b>, <b>9</b>, <b>2</b>,\r\n        <b>5</b>, <b>4</b>, and <b>-1</b>.\r\n      For this input, it finds 5 pairs: <b>4</b>:<b>5</b>, <b>3</b>:<b>7</b>, <b>6</b>:<b>8</b>,\r\n        <b>8</b>:<b>9</b>, and <b>2</b>:<b>5</b>.\r\n  <p>\r\n\r\n  <li>Explain why the following <b>for</b> loop contains an error spotted by the Java compiler\r\n      <b><pre>  for (int i=1; i<=10; i+1)\r\n    System.out.println(i);</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>Explain what the following <b>for</b> loop displays. Hint: it doesn't display all the\r\n        even numbers from <b>1</b> to <b>10</b>.\r\n      How could we write a <b>for</b> loop to accomplish this task?\r\n      <b><pre>  for (int i=1; i<=10 && i%2==0; i++)\r\n    System.out.println(i);</pre></b>\r\n  <p>\r\n\r\n  <li>Translate the following <b>for</b> loop into a <b>for(;;)</b> loop with a\r\n        <b>break</b> in its body.\r\n      <b><pre>  for (int i=5; i>=0; i--)\r\n    System.out.println(i);</pre></b>\r\n  <p>\r\n\r\n  <li>Assume that we have declared <b>int Width, Height;</b> and stored values into these\r\n        variables.\r\n      Write a pair of nested <b>for</b> loops that print a rectangle of <b>'*'</b> that is\r\n        <b>height</b> by <b>width</b>: e.g., if <b>height</b> was <b>5</b> and <b>width</b>\r\n        was <b>20</b> it would display\r\n      <b><pre>  ******************** \r\n  ******************** \r\n  ******************** \r\n  ******************** \r\n  ********************</pre></b>\r\n\r\n  <li>What is syntactically wrong with the following <b>for</b> loop (be careful)?\r\n      How can we rewrite it to satisfy the syntax but still do the same intended thing?\r\n      <b><pre>    for (int i = 0, double d = 0.0; velocity>0 ; i++,d+=.01)</b></pre> \r\n<p>\r\n\r\n    <li>Suppose that in the prompting code, we always want to set <b>answer</b> to <b>0</b>\r\n          and terminate the loop if the user fails to enter a valid integer.\r\n        Change the code to implement this requirement.\r\n        Hint: this change requires just changing the block in the <i>catch-clause</i>.\r\n    <p>\r\n\r\n    <li>Explain whether or not the code below correctly reads all the\r\n          integer values in a file and prints their sum.\r\n        Note that this code contains a <b>for</b> loop in a <b>try-catch</b>\r\n          statements with no <b>break</b> statement; the original code to\r\n          solve this problem contained a <b>try-catch</b> (with a <b>break</b>\r\n          statement) in a <b>for</b> loop.\r\n  <pre><b>  int sum = 0;\r\n  try {\r\n    for (;;) {\r\n      int aValue = inputFile.readInt();\r\n      sum += aValue;\r\n    }\r\n  }\r\n  catch (EndOfFileException eofe) {}\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n  <p>\r\n\r\n    <li>Suppose that in the file-reading code (from the lecture), we want to\r\n      ignore any non-integer values encountered (but keep reading more\r\n      values until there are no more in the file to read).\r\n      How can we change the code to implement this requirement?\r\n      Why might it be better not just to ignore it, but print an error\r\n        message (and how can this be accomplished)?\r\n      Finally, why can't we modify the code above to solve this problem too?\r\n      Hint: look at how <i>catch-clause</i> appears in the EBNF\r\n          <b>try-catch</b> statements. \r\n      Failing to read an <b>int</b> because some non<b>-int</b> value\r\n          appears in the file will cause Java to throw the \r\n          <b>NumberFormatException</b>.\r\n\r\n  </ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n</body>\r\n</html>\r\n", "id": 30861.0}