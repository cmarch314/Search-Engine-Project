{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 373D Triangulation Data Structure Sylvain Pion and Monique Teillaud A geometric triangulation has two aspects the combinatorial structure which gives the incidence and adjacency relations between faces and the geometric information related to the position of vertices CGAL provides 3D geometric triangulations in which these two aspects are clearly separated As described in Chapter a geometric triangulation of a set of points in d d 3 is a partition of the whole space d into cells having d 1 vertices Some of them are infinite they are obtained by linking an additional vertex at infinity to each facet of the convex hull of the points see Section The underlying combinatorial graph of such a triangulation without boundary of d can be seen as a triangulation of the topological sphere Sd in d 1 This chapter deals with 3D triangulation data structures meant to maintain the combinatorial information for 3D geometric triangulations The reader interested in geometric triangulations of 3 is advised to read Chapter 37 1 Representation In CGAL a 3D triangulation data structure is a container of cells 3 faces and vertices faces Each cell gives access to its four incident vertices and to its four adjacent cells Each vertex gives direct access to one of its incident cells which is sufficient to retrieve all the incident cells when needed The four vertices of a cell are indexed with 1 2 and 3 The neighbors of a cell are also indexed with 1 2 3 in such a way that the neighbor indexed by i is opposite to the vertex with the same index see Figure Figure Representation Edges 1 faces and facets 2 faces are not explicitly represented a facet is given by a cell and an index the facet i of a cell c is the facet of c that is opposite to the vertex of index i and an edge is given by a cell and two indices the edge i j of a cell c is the edge whose endpoints are the vertices of indices i and j of c Degenerate Dimensions As CGAL explicitly deals with all degenerate cases a 3D triangulation data structure in CGAL can handle the cases when the dimension of the triangulation is lower than 3 Thus a 3D triangulation data structure can store a triangulation of a topological sphere Sd of d 1 for any d 1 1 2 3 Let us give for each dimension the example corresponding to the triangulation data structure having a minimal number of vertices i e a simplex These examples are illustrated by presenting their usual geometric embedding dimension 3 The triangulation data structure consists of the boundary of a 4 dimensional simplex which has 5 vertices A geometric embedding consists in choosing one of these vertices to be infinite thus four of the five 3 cells become infinite the geometric triangulation has one finite tetrahedron remaining each of its facets being incident to an infinite cell See Figure Figure 4D simplex and a 3D geometric embedding dimension 2 We have 4 vertices forming one 3 dimensional simplex i e the boundary of a tetrahedron The geometric embedding in the plane results from choosing one of these vertices to be infinite then the geometric triangulation has one finite triangle whose edges are incident to the infinite triangles See Figure Figure 3D simplex and a 2D geometric embedding dimension 1 A 2 dimensional simplex a triangle has 3 vertices The geometric embedding is an edge whose vertices are linked to an infinite point See Figure Figure 2D simplex and a 1D geometric embedding The last three cases are defined uniquely dimension A dimensional triangulation is combinatorially equivalent to the boundary of a 1 dimensional simplex an edge which consists of 2 vertices One of them becomes infinite in the geometric embedding and there is only one finite vertex remaining The two vertices are adjacent dimension 1 This dimension is a convention to represent a dimensional simplex that is a sole vertex which will be geometrically embedded as an empty triangulation having only one infinite vertex dimension 2 This is also a convention The triangulation data structure has no vertex There is no associated geometric triangulation Note that the notion of infinite vertex has no meaning for the triangulation data structure The infinite vertex of the geometric embedding is a vertex that cannot be distinguished from the other vertices in the combinatorial triangulation The same cell class is used in all cases triangular faces in 2D can be considered as degenerate cells having only three vertices resp neighbors numbered 1 2 edges in 1D have only two vertices resp neighbors numbered and 1 The implicit representation of facets resp edges still holds for degenerate 3 dimensions in dimension 2 each cell has only one facet of index 3 and 3 edges 1 1 2 and 2 in dimension 1 each cell has one edge 1 Validity A 3D combinatorial triangulation is said to be locally valid iff the following is true a When a cell c has a neighbor pointer to another cell c then reciprocally this cell c has a neighbor pointer to c and c and c have three vertices in common These cells are called adjacent b The cells have a coherent orientation if two cells c1 and c2 are adjacent and share a facet with vertices u v w then the vertices of c1 are numbered v 1 u v11 v v21 w v31 and the vertices of c2 are numbered v 2 v v12 u v22 w v32 up to positive permutations of 1 2 3 In other words if we embed the triangulation in 3 then the fourth vertices v31 and v32 of c1 and c2 see the common facet in opposite orientations See Figure The set 4 of permutations of 1 2 3 has cardinality 24 and the set of positive permutations A4 has cardinality 12 Thus for a given orientation there are up to 12 different orderings of the four vertices of a cell Note that cyclic permutations are negative and so do not preserve the orientation of a cell Figure Coherent orientations of two cells 3 dimensional case The is valid method provided by Triangulation data structure 3 checks the local validity of a given triangulation data structure 37 2 Software Design The 3D triangulation data structure class of CGAL Triangulation data structure 3 is designed to be used as a combinatorial layer upon which a geometric layer can be built Ket98 This geometric layer is typically one of the 3D triangulation classes of CGAL Triangulation 3 Delaunay triangulation 3 and Regular triangulation 3 This relation is described in more details in Chapter where the Section explains other important parts of the design related to the geometry We focus here on the design of the triangulation data structure TDS itself which the Figure illustrates Figure Triangulation Data Structure software design 37 2 1 Flexibility of the Design In order for the user to be able to add his own data in the vertices and cells the design of the TDS is split into two layers In the bottom layer the vertex and cell base classes store elementary incidence and adjacency and possibly geometric or other information These classes are parameterized by the TDS which provides the handle types They can also be parameterized by a geometric traits class or anything else A vertex stores a Cell handle and a cell stores four Vertex handles and four Cell handles The middle layer is the TDS which is purely combinatorial It provides operations such as insertion of a new vertex in a given cell on a 1 or 2 face It also allows one if the dimension of the triangulation is smaller than 3 to insert a vertex so that the dimension of the triangulation is increased by one The TDS is responsible for the combinatorial integrity of the eventual geometric triangulation built on top of it the upper layer see Chapter The user has several ways to add his own data in the vertex and cell base classes used by the TDS He can either use the classes Triangulation vertex base with info and Triangulation cell base with info which allow to add one data member of a user provided type and give access to it derive his own classes from the default base classes Triangulation ds vertex base and Triangulation ds cell base or the geometric versions typically used by the geometric layer Triangulation vertex base and Triangulation cell base write his own base classes following the requirements given by the concepts TriangulationCellBase 3 and TriangulationVertexBase 3 37 2 2 Cyclic Dependency Since adjacency relations are stored in the vertices and cells it means that the vertex and cell base classes have to be able to store handles an entity akeen to pointers to their neighbors in the TDS This in turns means that the vertex and cell base classes have to know the types of these handles which are provided by the TDS So in a sense the base classes are parameterized by the TDS and the TDS is parameterized by the vertex and cell base classes This is a cycle which cannot be resolved easily The solution that we have chosen is similar to the mecanism used by the standard class std allocator the vertex and cell base classes are initially given a fake or dummy TDS template parameter whose unique purpose is to provide the types that can be used by the vertex and cell base classes such as handles Then inside the TDS itself these base classes are rebound to the real TDS type that is we obtain the same vertex and cell base classes but parameterized with the real TDS instead of the dummy one Rebinding is performed by a nested template class of the vertex and cell base classes see code below which provides a type which is the rebound vertex or cell base class1 Here is how it works schematically template class Vb class Cb class TDS typedef TDS Vb Cb Self Rebind the vertex and cell base to the actual TDS Self typedef typename Vb template Rebind TDS Self Other VertexBase typedef typename Cb template Rebind TDS Self Other CellBase further internal machinery leads to the final public types public typedef Vertex typedef Cell typedef Vertex handle typedef Cell handle template class TDS The default is some internal type faking a TDS class Triangulation ds vertex base 3 public template class TDS2 struct Rebind TDS typedef Triangulation ds vertex base 3 TDS2 Other When derivation is used for the vertex or cell base classes which is the case at the geometric level with Triangulation vertex base 3 then it gets slightly more involved because its base class has to be rebound as well template class GT class Vb Triangulation ds vertex base 3 class Triangulation vertex base 3 public Vb public template class TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 typedef Triangulation vertex base 3 GT Vb2 Other 37 2 3 Backward Compatibility The rebinding scheme has been introduced in CGAL version 3 It is incompatible with the previous versions for the cases where the user provides his own vertex or cell base class In these cases the user needs to add the rebind nested template class appropriately More informations are given in 37 3 Examples 37 3 1 Incremental construction The following example shows how to construct a 3D triangulation data structure by inserting vertices file examples Triangulation 3 example tds C include CGAL Triangulation data structure 3 h include iostream include fstream include cassert include vector typedef CGAL Triangulation data structure 3 Tds typedef Tds size type size type typedef Tds Cell handle Cell handle typedef Tds Vertex handle Vertex handle int main Tds T assert T number of vertices assert T dimension 2 assert T is valid std vector Vertex handle PV 7 PV T insert increase dimension assert T number of vertices 1 assert T dimension 1 assert T is valid each of the following insertions of vertices increases the dimension for int i 1 i 5 i PV i T insert increase dimension PV assert T number of vertices size type i 1 assert T dimension i 1 assert T is valid assert T number of cells 5 we now have a simplex in dimension 4 cell incident to PV Cell handle c PV cell int ind bool check c has vertex PV ind assert check PV is the vertex of index ind in c insertion of a new vertex in the facet opposite to PV PV 5 T insert in facet c ind assert T number of vertices 6 assert T dimension 3 assert T is valid insertion of a new vertex in c PV 6 T insert in cell c assert T number of vertices 7 assert T dimension 3 assert T is valid std ofstream oFileT output tds std ios out writing file output tds oFileT T return 37 3 2 Cross linking between a 2D and a 3D data structures This example program illustrates how to setup a 2D and a 3D triangulation data structures whose vertices respectively store vertex handles of the other one file examples Triangulation 3 example linking 2d and 3d C include CGAL Triangulation data structure 2 h include CGAL Triangulation data structure 3 h include cassert declare the 2D vertex base type parametrized by some 3D TDS template typename T3 typename Vb CGAL Triangulation ds vertex base 2 class My vertex 2 declare the 3D vertex base type parametrized by some 2D TDS template typename T2 typename Vb CGAL Triangulation ds vertex base 3 class My vertex 3 Then we have to break the dependency cycle we need to refer to a dummy 3D TDS typedef CGAL Triangulation ds vertex base 3 Triangulation data structure Dummy tds 3 the 2D TDS initially plugging a dummy 3D TDS in the vertex type to break the dependency cycle typedef CGAL Triangulation data structure 2 My vertex 2 Dummy tds 3 TDS 2 the 3D TDS here we can plug the 2D TDS directly typedef CGAL Triangulation data structure 3 My vertex 3 TDS 2 TDS 3 template typename T3 typename Vb class My vertex 2 public Vb public typedef typename Vb Face handle Face handle template typename TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 we also have to break the cycle here by hardcoding TDS 3 instead of T3 typedef My vertex 2 TDS 3 Vb2 Other My vertex 2 My vertex 2 Face handle f Vb f we store a vertex handle of the 3D TDS typename T3 Vertex handle v3 template typename T2 typename Vb class My vertex 3 public Vb public typedef typename Vb Cell handle Cell handle template typename TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 typedef My vertex 3 T2 Vb2 Other My vertex 3 My vertex 3 Cell handle c Vb c we store a vertex handle of the 2D TDS typename T2 Vertex handle v2 int main TDS 2 t2 TDS 3 t3 TDS 2 Vertex handle v2 t2 insert dim up TDS 3 Vertex handle v3 t3 insert increase dimension v2 v3 v3 v3 v2 v2 assert t2 is valid assert t3 is valid return 37 4 Design and Implementation History Monique Teillaud introduced the triangulation of the topological sphere Sd in d 1 to manage the underlying graph of geometric triangulations and handle degenerate diomensions Tei99 Sylvain Pion improved the software in several ways in particular regarding the memory management Footnotes 1 It is logically equivalent to a mechanism that does not exist yet in the C language template typedef or template aliasing Next chapter 3D Triangulation Data Structure Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/TriangulationDS_3/Chapter_main.html", "title": "3d triangulation data structure", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './TriangulationDS_3/main.tex' -->\n<html> <head>  \n<title>3D Triangulation Data Structure</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_37\"></a>\n  \n<h1>Chapter 37<BR>3D Triangulation Data Structure</h1>\n\n<A NAME=\"chapter-TDS3\"></A>\n<EM>Sylvain Pion  and Monique Teillaud</EM><BR>\n\n\n<P>\n\nA geometric triangulation has two aspects: the combinatorial structure, which\ngives the incidence and adjacency relations between faces, and the\ngeometric information related to the position of vertices.\n<P>\n\nC<SMALL>GAL</SMALL> provides 3D geometric triangulations in which these\ntwo aspects are clearly separated.\nAs described in Chapter&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#chapter-Triangulation3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, a geometric\ntriangulation of a set of points in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH>, <MATH><I>d <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 3</I></MATH> is a partition of the\nwhole space <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> into cells having <MATH><I>d+1</I></MATH> vertices. Some of them\nare infinite, they are obtained by linking an additional vertex at\ninfinity to each facet of the convex hull of the points (see\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).  \nThe underlying combinatorial graph of such a triangulation\nwithout boundary of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> can be seen as a triangulation of the\ntopological sphere <MATH><I>S<SUP>d</SUP></I></MATH> in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+1</SUP></I></MATH>.\n<P>\n\nThis chapter deals with 3D-triangulation data structures, meant to\nmaintain the combinatorial information for 3D-geometric\ntriangulations. The reader interested in geometric triangulations of\n<MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> is advised to read Chapter&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#chapter-Triangulation3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>37.1&nbsp;&nbsp;&nbsp;Representation</h2>\n\n<A NAME=\"TDS3-sec-intro\"></A>\n<P>\n\nIn C<SMALL>GAL</SMALL>, a 3D triangulation data structure is a\ncontainer of cells (<MATH><I>3</I></MATH>-faces) and vertices (<MATH><I>0</I></MATH>-faces). Each cell gives\naccess to its four incident vertices and to its four adjacent\ncells. Each vertex gives direct access to one of its incident cells, which is \nsufficient to retrieve all the incident cells when needed.\n<P>\n\nThe four vertices of a cell are indexed with 0, 1, 2 and 3.  The\nneighbors of a cell are also indexed with 0, 1, 2, 3 \nin such a way that the neighbor indexed by <MATH><I>i</I></MATH> is <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex\nwith the same index (see Figure&nbsp;<A HREF=\"Chapter_main.html#TDS3-fig-repres\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Representation.\n<A NAME=\"TDS3-fig-repres\"></A>\n\n<CENTER>\n<img border=0 src=\"./repres.gif\" align=center\nalt=\"Representation\">\n</CENTER>\n<P>\n\nEdges (<MATH><I>1</I></MATH>-faces) and facets (<MATH><I>2</I></MATH>-faces) are not explicitly\nrepresented: a facet is given by a cell and an index (the facet\n<I>i</I> of a cell <I>c</I> is the facet of <I>c</I> that is <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to\nthe vertex of index <I>i</I>) and an edge is given by a cell and two\nindices (the edge <I>(i,j)</I> of a cell <I>c</I> is the edge\nwhose endpoints are the vertices of indices <I>i</I> and <I>j</I> of\n<I>c</I>).\n<P>\n\n<b>Degenerate Dimensions</b>\n\nAs C<SMALL>GAL</SMALL> explicitly deals with all degenerate cases, a\n3D-triangulation data structure in C<SMALL>GAL</SMALL> can handle the cases when\nthe dimension of the triangulation is lower than&nbsp;3.\n<P>\n\nThus, a 3D-triangulation data structure can store a triangulation of a\ntopological sphere <MATH><I>S<SUP>d</SUP></I></MATH> of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+1</SUP></I></MATH>, for any <MATH><I>d  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {-1,0,1,2,3}</I></MATH>.\n<P>\n\nLet us give, for each dimension, the example corresponding to the\ntriangulation data structure having a minimal number of vertices, i.e. a \nsimplex. These examples are illustrated by presenting their usual\ngeometric embedding. \n<UL>\n<LI><I>dimension 3.</I> The triangulation data structure consists of\nthe boundary of a 4-dimensional simplex, which has 5 vertices. A\ngeometric embedding consists in choosing one of these vertices to be\ninfinite, thus four of the five 3-cells become infinite: the geometric\ntriangulation has one finite tetrahedron remaining, each of its facets\nbeing incident to an infinite cell. See Figure&nbsp;<A HREF=\"Chapter_main.html#TDS3-fig-topo-simplex4\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n\n<B>Figure:&nbsp;&nbsp;</B>4D simplex and a 3D geometric embedding.\n<A NAME=\"TDS3-fig-topo-simplex4\"></A>\n\n<CENTER>\n<img border=0 src=\"./topo-simplex4.gif\" align=center\nalt=\"4D simplex and a 3D geometric embedding\">\n</CENTER>\n\n \n<LI><I>dimension 2.</I> We have 4 vertices forming one 3-dimensional\nsimplex, i.e. the boundary of a tetrahedron. The geometric embedding in\nthe plane results from choosing one of these vertices to be infinite,\nthen the geometric triangulation has one finite triangle whose edges are\nincident to the infinite triangles. See Figure&nbsp;<A HREF=\"Chapter_main.html#TDS3-fig-topo-simplex3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n\n<B>Figure:&nbsp;&nbsp;</B>3D simplex and a 2D geometric embedding.\n<A NAME=\"TDS3-fig-topo-simplex3\"></A>\n\n<CENTER>\n<img border=0 src=\"./topo-simplex3.gif\" align=center\nalt=\"3D simplex and a 2D geometric embedding\">\n</CENTER>\n\n \n<LI><I>dimension 1.</I> A 2-dimensional simplex (a triangle) has 3\nvertices. The geometric embedding is an edge whose vertices are linked\nto an infinite point.  See Figure&nbsp;<A HREF=\"Chapter_main.html#TDS3-fig-topo-simplex2\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n\n<B>Figure:&nbsp;&nbsp;</B>2D simplex and a 1D geometric embedding.\n<A NAME=\"TDS3-fig-topo-simplex2\"></A>\n\n<CENTER>\n<img border=0 src=\"./topo-simplex2.gif\" align=center\nalt=\"2D simplex and a 1D geometric embedding\">\n</CENTER>\n\n \n</UL>\n<P>\n\nThe last three cases are defined uniquely:\n<UL>\n<LI><I>dimension 0.</I> A 0-dimensional triangulation is\ncombinatorially equivalent to the boundary of a 1-dimensional simplex\n(an edge), which consists of 2 vertices. One of them becomes infinite\nin the geometric embedding, and there is only one finite vertex\nremaining. The two vertices are adjacent.\n<LI><I>dimension -1.</I> This dimension is a convention to represent a \n0-dimensional simplex, that is a sole vertex, which will be\ngeometrically embedded as an ``empty'' triangulation, having only one\ninfinite vertex.\n<LI><I>dimension -2.</I> This is also a convention. The\ntriangulation data structure has no vertex. There is no associated\ngeometric triangulation.\n</UL>\n<P>\n\nNote that the notion of infinite vertex has no meaning for the\ntriangulation data structure. The infinite vertex of the geometric\nembedding is a vertex that cannot be distinguished from the other\nvertices in the combinatorial triangulation.\n<P>\n\nThe same cell class is used in all cases: triangular faces in\n2D can be considered as degenerate cells, having only three vertices\n(resp. neighbors) numbered <MATH><I>(0,1,2)</I></MATH>;\nedges in 1D have only two vertices (resp. neighbors) numbered <MATH><I>0</I></MATH> and <MATH><I>1</I></MATH>.\n<P>\n\nThe implicit representation of facets (resp. edges) still holds\nfor degenerate (<MATH><I>&lt; 3</I></MATH>) dimensions : in dimension&nbsp;2, each cell has only one\nfacet of index 3, and 3 edges <MATH><I>(0,1)</I></MATH>, <MATH><I>(1,2)</I></MATH> and <MATH><I>(2,0)</I></MATH>; in\ndimension&nbsp;1, each cell has one edge <MATH><I>(0,1)</I></MATH>.\n<P>\n\n<b>Validity</b>\n\nA 3D combinatorial triangulation is said to be <I>locally valid</I> \niff the following is true:\n<P>\n\n<B>(a)</B> When a cell <MATH><I>c</I></MATH> has a neighbor pointer to another cell <MATH><I>c'</I></MATH>,\nthen reciprocally this cell <MATH><I>c'</I></MATH> has a neighbor pointer to <MATH><I>c</I></MATH>, and\n<MATH><I>c</I></MATH> and <MATH><I>c'</I></MATH> have three vertices in common. These cells are called\nadjacent.\n<P>\n\n<B>(b)</B> The cells have a coherent <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>: if two cells <MATH><I>c<SUB>1</SUB></I></MATH>\nand <MATH><I>c<SUB>2</SUB></I></MATH> are adjacent and share a facet with vertices <MATH><I>u,v,w</I></MATH>, then\nthe vertices of <MATH><I>c<SUB>1</SUB></I></MATH> are numbered <MATH><I>(v<SUB>0</SUB><SUP>1</SUP> = u, v<SUB>1</SUB><SUP>1</SUP> = v, v<SUB>2</SUB><SUP>1</SUP> = w,\nv<SUB>3</SUB><SUP>1</SUP>)</I></MATH>, and the vertices of <MATH><I>c<SUB>2</SUB></I></MATH> are numbered <MATH><I>(v<SUB>0</SUB><SUP>2</SUP> = v, v<SUB>1</SUB><SUP>2</SUP> = u,\nv<SUB>2</SUB><SUP>2</SUP> = w, v<SUB>3</SUB><SUP>2</SUP>)</I></MATH>, up to positive permutations of <MATH><I>(0,1,2,3)</I></MATH>. In\nother words, if we embed the triangulation in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>, then the fourth\nvertices <MATH><I>v<SUB>3</SUB><SUP>1</SUP></I></MATH> and <MATH><I>v<SUB>3</SUB><SUP>2</SUP></I></MATH> of <MATH><I>c<SUB>1</SUB></I></MATH> and <MATH><I>c<SUB>2</SUB></I></MATH> see the common facet\nin <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations. See Figure&nbsp;<A HREF=\"Chapter_main.html#TDS3-fig-comborient\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nThe set <BIG><BIG><MATH><I><IMG BORDER=0 WIDTH=8 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_sigma.gif\"></I></MATH></BIG></BIG><MATH><I><SUB>4</SUB></I></MATH> of permutations of\n<MATH><I>(0,1,2,3)</I></MATH> has cardinality 24, and the set of positive permutations\n<MATH><I>A<SUB>4</SUB></I></MATH> has cardinality 12. Thus, for a given <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>, there\nare up to 12 different orderings of the four vertices of a cell. Note\nthat cyclic permutations are negative and so do not preserve the\n<A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of a cell.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Coherent orientations of two cells (3-dimensional case).\n<A NAME=\"TDS3-fig-comborient\"></A>\n\n<CENTER>\n<img border=0 src=\"./comborient.gif\" align=center alt=\"Orientation of a cell (3-dimensional case)\">\n</CENTER>\n<P>\n\nThe <I>is_valid()</I> method provided by\n<I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A></I> checks the local validity of a\ngiven triangulation data structure.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>37.2&nbsp;&nbsp;&nbsp;Software Design</h2>\n\n<A NAME=\"TDS3-sec-design\"></A>\n<P>\n\nThe 3D-triangulation data structure class of CGAL,\n<I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A></I>, is designed to be used as a combinatorial\nlayer upon which a geometric layer can be built [<A HREF=\"../biblio.html#Biblio_k-ddsps-98\">Ket98</A>]. This\ngeometric layer is typically one of the 3D-triangulation classes of C<SMALL>GAL</SMALL>:\n<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I>, <I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> and\n<I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A></I>. This relation is described in more details in\nChapter&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#chapter-Triangulation3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, where the\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> explains other important parts of the\ndesign related to the geometry.\n<P>\n\nWe focus here on the design of the triangulation data structure (TDS)\nitself, which the Figure&nbsp;<A HREF=\"Chapter_main.html#TDS3-fig-layers\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> illustrates.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Triangulation Data Structure software design.\n<A NAME=\"TDS3-fig-layers\"></A>\n\n<CENTER>\n<img border=0 src=\"./design_tds.gif\" align=center\n alt=\"Triangulation Data Structure software design\">\n</CENTER>\n<P>\n\n<h3>37.2.1&nbsp;&nbsp;&nbsp;Flexibility of the Design</h3>\n<P>\n\nIn order for the user to be able to add his own data in the vertices and cells,\nthe design of the TDS is split into two layers:\n<P>\n\n<UL>\n<LI> In the bottom layer, the (vertex and cell) base classes store\nelementary incidence and adjacency (and possibly geometric or other)\ninformation.  These classes are parameterized by the TDS which provides the\nhandle types.  (They can also be parameterized by a geometric traits class or\nanything else.) A vertex stores a <I>Cell_handle</I>, and a cell stores four\n<I>Vertex_handle</I>s and four <I>Cell_handle</I>s.\n<P>\n\n<LI> The middle layer is the TDS, which is purely combinatorial.  It\nprovides operations such as insertion of a new vertex in a given cell, on a <MATH><I>1</I></MATH>\nor <MATH><I>2</I></MATH>-face. It also allows one, if the dimension of the triangulation is\nsmaller than <MATH><I>3</I></MATH>, to insert a vertex so that the dimension of the triangulation\nis increased by one. The TDS is responsible for the combinatorial integrity of\nthe eventual geometric triangulation built on top of it (the upper layer,\nsee Chapter&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#chapter-Triangulation3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n</UL>\n<P>\n\nThe user has several ways to add his own data in the vertex and cell base classes used by the TDS.  He can either:\n<UL>\n<LI> use the classes <I>Triangulation_vertex_base_with_info</I>\nand <I>Triangulation_cell_base_with_info</I>, which allow to add one data member\nof a user provided type, and give access to it.\n<LI> derive his own classes from the default base classes\n<I>Triangulation_ds_vertex_base</I>, and <I>Triangulation_ds_cell_base</I> (or\nthe geometric versions typically used by the geometric layer,\n<I>Triangulation_vertex_base</I>, and <I>Triangulation_cell_base</I>).\n<LI> write his own base classes following the requirements given by the\nconcepts <I><A HREF=\"../Triangulation_3_ref/Concept_TriangulationCellBase_3.html#Cross_link_anchor_986\">TriangulationCellBase_3</A></I> and <I><A HREF=\"../Triangulation_3_ref/Concept_TriangulationVertexBase_3.html#Cross_link_anchor_987\">TriangulationVertexBase_3</A></I>\n.\n</UL>\n<P>\n\n<h3>37.2.2&nbsp;&nbsp;&nbsp;Cyclic Dependency</h3>\n\n<A NAME=\"tds3-cyclic\"></A>\n<P>\n\nSince adjacency relations are stored in the vertices and cells, it means that\nthe vertex and cell base classes have to be able to store handles (an entity\nakeen to pointers) to their neighbors in the TDS.  This in turns means that the\nvertex and cell base classes have to know the types of these handles, which are\nprovided by the TDS.  So in a sense, the base classes are parameterized by the\nTDS, and the TDS is parameterized by the vertex and cell base classes !\nThis is a cycle which cannot be resolved easily.\n<P>\n\nThe solution that we have chosen is similar to the mecanism used by the\nstandard class <I>std::allocator</I>: the vertex and cell base classes are\ninitially given a fake or dummy TDS template parameter, whose unique purpose\nis to provide the types that can be used by the vertex and cell base classes\n(such as handles).  Then, inside the TDS itself, these base classes are\n<I>rebound</I> to the real TDS type, that is we obtain the same vertex\nand cell base classes, but parameterized with the real TDS instead of the dummy\none.  Rebinding is performed by a nested template class of the vertex and cell\nbase classes (see code below), which provides a type which is the rebound\nvertex or cell base class<A HREF=\"#Footnote_1\"><SUP>1</SUP></A>.\n<P>\n\nHere is how it works, schematically:\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt; class Vb, class Cb &gt;\nclass TDS\n{\n  typedef TDS&lt;Vb, Cb&gt;    Self;\n\n  // Rebind the vertex and cell base to the actual TDS (Self).\n  typedef typename Vb::template Rebind_TDS&lt;Self&gt;::Other  VertexBase;\n  typedef typename Cb::template Rebind_TDS&lt;Self&gt;::Other  CellBase;\n\n  // ... further internal machinery leads to the final public types:\npublic:\n  typedef ...  Vertex;\n  typedef ...  Cell;\n  typedef ...  Vertex_handle;\n  typedef ...  Cell_handle;\n};\n\ntemplate &lt; class TDS = ... &gt;  // The default is some internal type faking a TDS\nclass <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_ds_vertex_base_3.html#Cross_link_anchor_1012\">Triangulation_ds_vertex_base_3</A>\n{\npublic:\n  template &lt; class TDS2 &gt;\n  struct Rebind_TDS {\n    typedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_ds_vertex_base_3.html#Cross_link_anchor_1012\">Triangulation_ds_vertex_base_3</A>&lt;TDS2&gt;    Other;\n  };\n...\n};\n</pre>\n<P>\n\nWhen derivation is used for the vertex or cell base classes, which is the\ncase at the geometric level with <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994\">Triangulation_vertex_base_3</A></I>, then\nit gets slightly more involved because its base class has to be rebound as\nwell:\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt; class GT, class Vb = <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_ds_vertex_base_3.html#Cross_link_anchor_1012\">Triangulation_ds_vertex_base_3</A>&lt;&gt; &gt;\nclass <A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994\">Triangulation_vertex_base_3</A> : public Vb\n{\npublic:\n  template &lt; class TDS2 &gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other  Vb2;\n    typedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994\">Triangulation_vertex_base_3</A>&lt;GT, Vb2&gt;           Other;\n  };\n...\n};\n</pre>\n<P>\n\n<h3>37.2.3&nbsp;&nbsp;&nbsp;Backward Compatibility</h3>\n\nThe rebinding scheme has been introduced in CGAL version 3.0.  It is\nincompatible with the previous versions, for the cases where the user provides\nhis own vertex or cell base class.  In these cases, the user needs to add\nthe rebind nested template class appropriately.  More informations are given\nin&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#T3-sec-compat\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>37.3&nbsp;&nbsp;&nbsp;Examples</h2>\n\n<A NAME=\"TDS3-sec-examples\"></A>\n<P>\n\n<h3>37.3.1&nbsp;&nbsp;&nbsp;Incremental construction</h3>\n\nThe following example shows how to construct a 3D triangulation data\nstructure by inserting vertices.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_tds.C\n\n#include &lt;CGAL/<A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A>.h&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;&gt;      Tds;\n\ntypedef Tds::size_type                              size_type;\ntypedef Tds::Cell_handle                            Cell_handle;\ntypedef Tds::Vertex_handle                          Vertex_handle;\n\nint main()\n{\n  Tds T;\n\n  assert( T.number_of_vertices() == 0 );\n  assert( T.dimension() == -2 );\n  assert( T.is_valid() );\n\n  std::vector&lt;Vertex_handle&gt; PV(7);\n\n  PV[0] = T.insert_increase_dimension();\n  assert( T.number_of_vertices() == 1 );\n  assert( T.dimension() == -1 );\n  assert( T.is_valid() );\n\n  // each of the following insertions of vertices increases the dimension\n  for ( int i=1; i&lt;5; i++ ) {\n    PV[i] = T.insert_increase_dimension(PV[0]);\n    assert( T.number_of_vertices() == (size_type) i+1 );\n    assert( T.dimension() == i-1 );\n    assert( T.is_valid() );\n  }\n  assert( T.number_of_cells() == 5 );\n\n  // we now have a simplex in dimension 4\n\n  // cell incident to PV[0]\n  Cell_handle c = PV[0]-&gt;cell();\n  int ind;\n  bool check = c-&gt;has_vertex( PV[0], ind );\n  assert( check );\n  // PV[0] is the vertex of index ind in c\n\n  // insertion of a new vertex in the facet <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to PV[0]\n  PV[5] = T.insert_in_facet(c, ind);\n  \n  assert( T.number_of_vertices() == 6 );\n  assert( T.dimension() == 3 );\n  assert( T.is_valid() );\n\n  // insertion of a new vertex in c\n  PV[6] = T.insert_in_cell(c);\n\n  assert( T.number_of_vertices() == 7 );\n  assert( T.dimension() == 3 );\n  assert( T.is_valid() );\n\n  std::ofstream oFileT(&quot;output_tds&quot;,std::ios::out);\n  // writing file output_tds; \n  oFileT &lt;&lt; T; \n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>37.3.2&nbsp;&nbsp;&nbsp;Cross-linking between a 2D and a 3D data structures</h3>\n\nThis example program illustrates how to setup a 2D and a 3D triangulation data\nstructures whose vertices respectively store vertex handles of the other one.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>/example_linking_2d_and_3d.C\n\n#include &lt;CGAL/<A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_966\">Triangulation_data_structure_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A>.h&gt;\n#include &lt;cassert&gt;\n\n// declare the 2D vertex base type, parametrized by some 3D TDS.\ntemplate &lt; typename T3, typename Vb = <A HREF=\"../TDS_2_ref/Class_Triangulation_ds_vertex_base_2.html#Cross_link_anchor_969\">CGAL::Triangulation_ds_vertex_base_2</A>&lt;&gt; &gt;\nclass My_vertex_2;\n\n// declare the 3D vertex base type, parametrized by some 2D TDS.\ntemplate &lt; typename T2, typename Vb = <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_ds_vertex_base_3.html#Cross_link_anchor_1011\">CGAL::Triangulation_ds_vertex_base_3</A>&lt;&gt; &gt;\nclass My_vertex_3;\n\n// Then, we have to break the dependency cycle.\n\n// we need to refer to a dummy 3D TDS.\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_ds_vertex_base_3.html#Cross_link_anchor_1011\">CGAL::Triangulation_ds_vertex_base_3</A>&lt;&gt;::Triangulation_data_structure\n        Dummy_tds_3;\n// the 2D TDS, initially plugging a dummy 3D TDS in the vertex type\n// (to break the dependency cycle).\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;My_vertex_2&lt;Dummy_tds_3&gt; &gt;  TDS_2;\n// the 3D TDS, here we can plug the 2D TDS directly.\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;My_vertex_3&lt;TDS_2&gt; &gt;        TDS_3;\n\n\ntemplate &lt; typename T3, typename Vb &gt;\nclass My_vertex_2\n  : public Vb\n{\npublic:\n  typedef typename Vb::Face_handle    Face_handle;\n\n  template &lt;typename TDS2&gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other  Vb2;\n    // we also have to break the cycle here by hardcoding TDS_3 instead of T3.\n    typedef My_vertex_2&lt;TDS_3, Vb2&gt;                        Other;\n  };\n\n  My_vertex_2() {}\n\n  My_vertex_2(Face_handle f) : Vb(f) {}\n\n  // we store a vertex handle of the 3D TDS.\n  typename T3::Vertex_handle v3;\n};\n\ntemplate &lt; typename T2, typename Vb &gt;\nclass My_vertex_3\n  : public Vb\n{\npublic:\n  typedef typename Vb::Cell_handle    Cell_handle;\n\n  template &lt;typename TDS2&gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other  Vb2;\n    typedef My_vertex_3&lt;T2, Vb2&gt;                           Other;\n  };\n\n  My_vertex_3() {}\n\n  My_vertex_3(Cell_handle c) : Vb(c) {}\n\n  // we store a vertex handle of the 2D TDS.\n  typename T2::Vertex_handle v2;\n};\n\n\nint main() {\n  TDS_2 t2;\n  TDS_3 t3;\n\n  TDS_2::Vertex_handle v2 = t2.insert_dim_up();\n  TDS_3::Vertex_handle v3 = t3.insert_increase_dimension();\n\n  v2-&gt;v3 = v3;\n  v3-&gt;v2 = v2;\n\n  assert(t2.is_valid());\n  assert(t3.is_valid());\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>37.4&nbsp;&nbsp;&nbsp;Design and Implementation History</h2>\n<P>\n\nMonique Teillaud introduced the triangulation of the topological\nsphere <MATH><I>S<SUP>d</SUP></I></MATH> in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+1</SUP></I></MATH> to manage the underlying graph of geometric\ntriangulations and handle degenerate diomensions [<A HREF=\"../biblio.html#Biblio_t-tdtc-99\">Tei99</A>].\n<P>\n\nSylvain Pion improved the software in several ways, in particular\nregarding the memory management.\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nIt is logically equivalent to a mechanism\nthat does not exist yet in the C++ language: <I>template typedef</I> or\n<I>template aliasing</I>\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../TriangulationDS_3_ref/Chapter_intro.html\">3D Triangulation Data Structure</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_37!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38802.0}