{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL box intersection d Definition The function box intersection d computes the pairwise intersecting boxes between two sequences of iso oriented boxes in arbitrary dimension The sequences of boxes are given with two random access iterator ranges and will be reordered in the course of the algorithm For each intersecting pair of boxes a callback function object is called with the two intersecting boxes as argument the first argument is a box from the first sequence the second argument a box from the second sequence The performance of the algorithm can be tuned with a cutoff parameter see the implementation section below for more details The algorithm reorders the boxes in the course of the algorithm Now depending on the size of a box it can be faster to copy the boxes or to work with pointers to boxes and copy only pointers We offer automatic support for both options To simplify the description let us call the value type of the iterators box handle The box handle can either be our box type itself or a pointer or const pointer to the box type A d dimensional iso oriented box is defined as the Cartesian product of d intervals We call the box half open if the d intervals loi hii i d are half open intervals and we call the box closed if the d intervals loi hii i d are closed intervals Note that closed boxes support zero width boxes and they can intersect at their boundaries while non empty half open boxes always have a positive volume and they only intersect iff their interiors overlap The distinction between closed or half open boxes does not require a different representation of boxes just a different interpretation when comparing boxes which is selected with the topology parameter and its two values CGAL Box intersection d HALF OPEN and CGAL Box intersection d CLOSED In addition a box has an unique id number It is used to order boxes consistently in each dimension even if boxes have identical coordinates In consequence the algorithm guarantees that a pair of intersecting boxes is reported only once Boxes with equal id number are not reported since they obviously intersect trivially The algorithm uses a traits class of the BoxIntersectionTraits d concept to access the boxes A default traits class is provided that assumes that the box type is a model of the BoxIntersectionBox d concept and that the box handle i e the iterators value type is identical to the box type or a pointer to the box type An important special application of this algorithm is the test for self intersections where the second box sequence is an identical copy of the first sequence including the preserved id number Note that this implies that the address of the box is not sufficient for the id number if boxes are copied by value To ease the use of this special case we offer a simplified version of this function with one iterator range only which then creates internally the second copy of the boxes under the name CGAL box self intersection d In the general case we distinguish between the bipartite case the boxes are from different sequences and the complete case the boxes are from the same sequence i e the self intersection case The default is the bipartite case since the complete case is typically handled with the simplified function call mentioned above However the general function call offers the setting parameter with the values CGAL Box intersection d COMPLETE and CGAL Box intersection d BIPARTITE include CGAL box intersection d h template class RandomAccessIterator1 class RandomAccessIterator2 class Callback void box intersection d RandomAccessIterator1 begin1 RandomAccessIterator1 end1 RandomAccessIterator2 begin2 RandomAccessIterator2 end2 Callback callback std ptrdiff t cutoff 1 Box intersection d Topology topology Box intersection d CLOSED Box intersection d Setting setting Box intersection d BIPARTITE Invocation of box intersection with default box traits CGAL Box intersection d Box traits d Box handle where Box handle corresponds to the iterator value type of RandomAccessIterator1 template class RandomAccessIterator1 class RandomAccessIterator2 class Callback class BoxTraits void box intersection d RandomAccessIterator1 begin1 RandomAccessIterator1 end1 RandomAccessIterator2 begin2 RandomAccessIterator2 end2 Callback callback BoxTraits box traits std ptrdiff cutoff 1 Box intersection d Topology topology Box intersection d CLOSED Box intersection d Setting setting Box intersection d BIPARTITE Invocation with custom box traits Requirements RandomAccessIterator1 and 2 must be mutable random access iterators and both value types must be the same We call this value type Box handle in the following Callback must be of the BinaryFunction concept The Box handle must be convertible to both argument types The return type is not used and can be void The Box handle must be a model of the Assignable concept In addition if the default box traits is used the Box handle must be a class type T or a pointer to a class type T where T must be a model of the BoxIntersectionBox d concept In both cases the default box traits specializes to a suitable implementation BoxTraits must be of the BoxIntersectionTraits d concept See Also CGAL box self intersection d CGAL box intersection all pairs d CGAL Box intersection d Box traits d BoxHandle BoxIntersectionBox d BoxIntersectionTraits d Implementation The implemented algorithm is described in ZE 2 as version two Its performance depends on a cutoff parameter When the size of both iterator ranges drops below the cutoff parameter the function switches from the streamed segment tree algorithm to the two way scan algorithm see ZE 2 for the details The streamed segment tree algorithm needs O n logd n k worst case running time and O n space where n is the number of boxes in both input sequences d the constant dimension of the boxes and k the output complexity i e the number of pairwise intersections of the boxes The two way scan algorithm needs O n log n l worst case running time and O n space where l is the number of pairwise overlapping intervals in one dimensions the dimension where the algorithm is used instead of the segment tree Note that l is not necessarily related to k and using the two way scan algorithm is a heuristic Unfortunately we have no general method to automatically determine an optimal cutoff parameter since it depends on the used hardware the runtime ratio between callback runtime and segment tree runtime and of course the number of boxes to be checked and their distribution In cases where the callback runtime is dominant it may be best to make the threshold parameter small Otherwise a cutoff sqrt n can lead to acceptable results For well distributed boxes the original paper ZE 2 gives optimal cutoffs in the thousands Anyway for optimal runtime some experiments to compare different cutoff parameters are recommended See also Section Example The box implementation provided with CGAL Box intersection d Box d double 2 has a special constructor for the CGAL bounding box type CGAL Bbox 2 and similar for dimension 3 We use this in the example to create 3 3 boxes in a grid layout Additionally we pick the center box and the box in the upper right corner as our second box sequence query The default policy of the box type implements the id number with an explicit counter in the boxes which is the default choice since it always works We use the id number in our callback function to report the result of the intersection algorithm call The result will be that the first query box intersects all nine boxes and the second query box intersects the four boxes in the upper right quadrant file examples Box intersection d minimal C include CGAL box intersection d h include CGAL Bbox 2 h include iostream typedef CGAL Box intersection d Box d double 2 Box typedef CGAL Bbox 2 Bbox 9 boxes of a grid Box boxes 9 Bbox 1 1 Bbox 1 2 1 Bbox 2 3 1 low Bbox 1 1 2 Bbox 1 1 2 2 Bbox 2 1 3 2 middle Bbox 2 1 3 Bbox 1 2 2 3 Bbox 2 2 3 3 upper 2 selected boxes as query center and upper right Box query 2 Bbox 1 1 2 2 Bbox 2 2 3 3 void callback const Box a const Box b std cout box a id intersects box b id std endl int main CGAL box intersection d boxes boxes 9 query query 2 callback return Next box intersection all pairs d Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Box_intersection_d_ref/Function_box_intersection_d.html", "title": "box_intersection_d", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Box_intersection_d_ref/box_intersection_d.tex' -->\n<html> <head>  \n<title>box_intersection_d</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1233\"></A>\n\n<A NAME=\"Cross_link_anchor_1234\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1305\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Function.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::box_intersection_d\"></A>\n<h2><I>CGAL::box_intersection_d</I></h2>\n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1306\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1307\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe function <I><A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A></I> computes the pairwise intersecting boxes\nbetween two sequences of iso-oriented boxes in arbitrary dimension.\nThe sequences of boxes are given with two random-access iterator\nranges and will be reordered in the course of the algorithm. For each\nintersecting pair of boxes a <I>callback</I> function object is called\nwith the two intersecting boxes as argument; the first argument is a\nbox from the first sequence, the second argument a box from the second\nsequence.  The performance of the algorithm can be tuned with a\n<I>cutoff</I> parameter, see the implementation section below for more\ndetails.\n<P>\n\nThe algorithm reorders the boxes in the course of the algorithm. Now,\ndepending on the size of a box it can be faster to copy the boxes, or\nto work with pointers to boxes and copy only pointers. We offer\nautomatic support for both options. To simplify the description, let\nus call the <I>value_type</I> of the iterators <I>box handle</I>.  The\n<I>box handle</I> can either be our box type itself or a pointer (or\nconst pointer) to the box type.\n<P>\n\nA <MATH><I>d</I></MATH>-dimensional iso-oriented box is defined as the <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> product\nof <MATH><I>d</I></MATH> intervals. We call the box <I>half-open</I> if the <MATH><I>d</I></MATH>\nintervals <MATH><I>{ [lo<SUB>i</SUB>,hi<SUB>i</SUB>) | 0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i &lt; d}</I></MATH> are half-open intervals,\nand we call the box <I>closed</I> if the <MATH><I>d</I></MATH> intervals <MATH><I>{ [lo<SUB>i</SUB>,hi<SUB>i</SUB>]\n| 0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i &lt; d}</I></MATH> are closed intervals. Note that closed boxes support\nzero-width boxes and they can intersect at their boundaries, while\nnon-empty half-open boxes always have a positive <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> and they only\nintersect iff their interiors overlap.  The distinction between closed\nor half-open boxes does not require a different representation of\nboxes, just a different interpretation when comparing boxes, which is\nselected with the <I>topology</I> parameter and its two values,\n<I>CGAL::Box_intersection_d::HALF_OPEN</I> and\n<I>CGAL::Box_intersection_d::CLOSED</I>.\n<P>\n\nIn addition, a box has an unique <I>id</I>-number. It is used to order\nboxes consistently in each dimension even if boxes have identical\ncoordinates. In consequence, the algorithm guarantees that a pair of\nintersecting boxes is reported only once. Boxes with equal\n<I>id</I>-number are not reported since they obviously intersect trivially.\n<P>\n\nThe algorithm uses a traits class of the <I><A HREF=\"Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I>\nconcept to access the boxes. A default traits class is provided that\nassumes that the box type is a model of the <I><A HREF=\"Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I>\nconcept and that the box handle, i.e., the iterators value type, is\nidentical to the box type or a pointer to the box type.\n<P>\n\nAn important special application of this algorithm is the test for\nself-intersections where the second box sequence is an identical copy\nof the first sequence including the preserved <I>id</I>-number. Note\nthat this implies that the address of the box is not sufficient for\nthe <I>id</I>-number if boxes are copied by value. To ease the use of\nthis special case we offer a simplified version of this function with\none iterator range only, which then creates internally the second copy\nof the boxes, under the name <I><A HREF=\"Function_box_self_intersection_d.html#Cross_link_anchor_1237\">CGAL::box_self_intersection_d</A></I>.\n<P>\n\nIn the general case, we distinguish between the bipartite case (the\nboxes are from different sequences) and the complete case (the boxes\nare from the same sequence, i.e., the self <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> case). The\ndefault is the bipartite case, since the complete case is typically\nhandled with the simplified function call mentioned above. However,\nthe general function call offers the <I>setting</I> parameter with the\nvalues <I>CGAL::Box_intersection_d::<A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Content\">COMPLETE</A></I> and\n<I>CGAL::Box_intersection_d::BIPARTITE</I>.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/box_intersection_d.h\">CGAL/box_intersection_d.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator1, class RandomAccessIterator2, class Callback &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_intersection_d6_RandomAccessIterator1_begin1+_RandomAccessIterator1_end1+_RandomAccessIterator2_begin2+_RandomAccessIterator2_end2+_Callback_callback+_std::ptrdiff_t_cutoff_=_10+_Box_intersection_d::Topology_topology_=_Box_intersection_d::CLOSED+_Box_intersection_d::Setting_setting_=_Box_intersection_d::BIPARTITE9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator1 begin1,<BR>\n\nRandomAccessIterator1 end1,<BR>\n\nRandomAccessIterator2 begin2,<BR>\n\nRandomAccessIterator2 end2,<BR>\n\nCallback callback,<BR>\n\nstd::ptrdiff_t cutoff = 10,<BR>\n\nBox_intersection_d::Topology topology = Box_intersection_d::CLOSED,<BR>\n\nBox_intersection_d::Setting setting = Box_intersection_d::BIPARTITE)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Invocation of box <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> with default box traits\n    <I><A HREF=\"Class_Box_intersection_d--Box_traits_d.html#Cross_link_anchor_1245\">CGAL::Box_intersection_d::Box_traits_d</A>&lt;Box_handle&gt;</I>, where\n    <I>Box_handle</I> corresponds to the iterator value type  of\n    <I>RandomAccessIterator1</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class RandomAccessIterator1, class RandomAccessIterator2, class Callback, class BoxTraits &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_box_intersection_d6_RandomAccessIterator1_begin1+_RandomAccessIterator1_end1+_RandomAccessIterator2_begin2+_RandomAccessIterator2_end2+_Callback_callback+_BoxTraits_box_traits+_std::ptrdiff_cutoff_=_10+_Box_intersection_d::Topology_topology_=_Box_intersection_d::CLOSED+_Box_intersection_d::Setting_setting_=_Box_intersection_d::BIPARTITE9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A> ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RandomAccessIterator1 begin1,<BR>\n\nRandomAccessIterator1 end1,<BR>\n\nRandomAccessIterator2 begin2,<BR>\n\nRandomAccessIterator2 end2,<BR>\n\nCallback callback,<BR>\n\nBoxTraits box_traits,<BR>\n\nstd::ptrdiff cutoff = 10,<BR>\n\nBox_intersection_d::Topology topology = Box_intersection_d::CLOSED,<BR>\n\nBox_intersection_d::Setting setting = Box_intersection_d::BIPARTITE)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Invocation with custom box traits.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Requirements</H3>\n<P>\n\n<UL>\n  <LI><I>RandomAccessIterator1</I>, and ...<I>2</I>, must be\n    mutable random-access iterators and both value types must be\n    the same. We call this value type <I>Box_handle</I> in the following.\n  <LI><I>Callback</I> must be of the <I>BinaryFunction</I> concept. \n    The <I>Box_handle</I> must be convertible to both argument types. The\n    return type is not used and can be <I>void</I>.\n  <LI>The <I>Box_handle</I> must be a model of the <I>Assignable</I> concept.\n  <LI>In addition, if the default box traits is used the <I>Box_handle</I> must \n    be a class type <I>T</I> or a pointer to a class type <I>T</I>, where\n    <I>T</I> must be a model of the <I><A HREF=\"Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I> concept.\n    In both cases, the default box traits specializes to a suitable\n    implementation.\n  <LI><I>BoxTraits</I> must be of the <I><A HREF=\"Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I> concept.\n</UL>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Function_box_self_intersection_d.html#Cross_link_anchor_1237\">CGAL::box_self_intersection_d</A></I><BR>\n\n<I><A HREF=\"Function_box_intersection_all_pairs_d.html#Cross_link_anchor_1235\">CGAL::box_intersection_all_pairs_d</A></I>\n<P>\n\n<I><A HREF=\"Class_Box_intersection_d--Box_traits_d.html#Cross_link_anchor_1245\">CGAL::Box_intersection_d::Box_traits_d</A>&lt;BoxHandle&gt;</I><BR>\n\n<I><A HREF=\"Concept_BoxIntersectionBox_d.html#Cross_link_anchor_1241\">BoxIntersectionBox_d</A></I><BR>\n\n<I><A HREF=\"Concept_BoxIntersectionTraits_d.html#Cross_link_anchor_1242\">BoxIntersectionTraits_d</A></I>\n<P>\n\n<H3>Implementation</H3>\n<P>\n\nThe implemented algorithm is described in&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>] as\nversion two.  Its performance depends on a <I>cutoff</I> parameter.\nWhen the size of both iterator ranges drops below the <I>cutoff</I>\nparameter the function switches from the streamed segment-tree\nalgorithm to the two-way-scan algorithm, see&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>]\nfor the details.\n<P>\n\nThe streamed segment-tree algorithm needs <MATH><I>O(n </I></MATH>log<MATH><I><SUP>d</SUP> (n) + k)</I></MATH>\nworst-case running time and <MATH><I>O(n)</I></MATH> space, where <MATH><I>n</I></MATH> is the number of\nboxes in both input sequences, <MATH><I>d</I></MATH> the (constant) dimension of the\nboxes, and <MATH><I>k</I></MATH> the output complexity, i.e., the number of pairwise\nintersections of the boxes. The two-way-scan algorithm needs <MATH><I>O(n </I></MATH>log<MATH><I>(n) + l)</I></MATH> worst-case running time and <MATH><I>O(n)</I></MATH> space, where <MATH><I>l</I></MATH> is the\nnumber of pairwise overlapping intervals in one dimensions (the\ndimension where the algorithm is used instead of the segment tree).\nNote that <MATH><I>l</I></MATH> is not necessarily related to <MATH><I>k</I></MATH> and using the\ntwo-way-scan algorithm is a heuristic.\n<P>\n\nUnfortunately, we have no general method to automatically determine an\noptimal cutoff parameter, since it depends on the used hardware, the\nruntime ratio between callback runtime and segment-tree runtime, and\nof course the number of boxes to be checked and their distribution. In\ncases where the callback runtime is dominant, it may be best to make\nthe threshold parameter small. Otherwise a <I>cutoff</I><MATH><I>=<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(n)</I></MATH> can\nlead to acceptable results. For well distributed boxes the original\npaper&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:ze-fsbi-02\">ZE02</A>] gives optimal cutoffs in the thousands.\nAnyway, for optimal runtime some experiments to <A HREF=\"../NumberTypeSupport_ref/Function_compare.html#Cross_link_anchor_1339\">compare</A> different\ncutoff parameters are recommended. See also\nSection&nbsp;<A HREF=\"../Box_intersection_d/Chapter_main.html#sec:box-inters-performance\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\n<H3>Example</H3>\n<P>\n\nThe box implementation provided with\n<I><A HREF=\"Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;double,2&gt;</I> has a special\nconstructor for the C<SMALL>GAL</SMALL> bounding box type <I><A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_41\">CGAL::Bbox_2</A></I> (and\nsimilar for dimension 3). We use this in the example to create <MATH><I>3\n &times; 3</I></MATH> <I>boxes</I> in a grid layout. Additionally we pick the\ncenter box and the box in the upper-right corner as our second box\nsequence <I>query</I>.\n<P>\n\nThe default policy of the box type implements the <I>id</I>-number with\nan explicit counter in the boxes, which is the default choice since it\nalways works. We use the <I>id</I>-number in our callback function to\nreport the result of the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> algorithm call. The result will\nbe that the first <I>query</I> box intersects all nine <I>boxes</I> and\nthe second <I>query</I> box intersects the four boxes in the\nupper-right quadrant.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Box_intersection_d/minimal.C\n#include &lt;CGAL/<A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1234\">box_intersection_d</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_42\">Bbox_2</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"Class_Box_intersection_d--Box_d.html#Cross_link_anchor_1243\">CGAL::Box_intersection_d::Box_d</A>&lt;double,2&gt; Box;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Bbox_2.html#Cross_link_anchor_41\">CGAL::Bbox_2</A>                              Bbox;\n                                                     // 9 boxes of a grid\nBox boxes[9] = { Bbox( 0,0,1,1), Bbox( 1,0,2,1), Bbox( 2,0,3,1), // low\n                 Bbox( 0,1,1,2), Bbox( 1,1,2,2), Bbox( 2,1,3,2), // middle\n                 Bbox( 0,2,1,3), Bbox( 1,2,2,3), Bbox( 2,2,3,3)};// upper\n// 2 selected boxes as query; center and upper right\nBox query[2] = { Bbox( 1,1,2,2), Bbox( 2,2,3,3)};\n\nvoid callback( const Box&amp; a, const Box&amp; b ) {\n    std::cout &lt;&lt; &quot;box &quot; &lt;&lt; a.id() &lt;&lt; &quot; intersects box &quot; &lt;&lt; b.id() &lt;&lt; std::endl;\n}\nint main() {\n    <A HREF=\"Function_box_intersection_d.html#Cross_link_anchor_1233\">CGAL::box_intersection_d</A>( boxes, boxes+9, query, query+2, callback);\n    return 0;\n}\n\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_box_intersection_all_pairs_d.html\"><I>box_intersection_all_pairs_d</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_58!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38552.0}