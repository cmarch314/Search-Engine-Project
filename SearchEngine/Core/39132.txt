{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 413D Alpha Shapes Tran Kai Frank Da and Mariette Yvinec Assume we are given a set S of points in 2D or 3D and we d like to have something like the shape formed by these points This is quite a vague notion and there are probably many possible interpretations the alpha shape being one of them Alpha shapes can be used for shape reconstruction from a dense unorganized set of data points Indeed an alpha shape is demarcated by a frontier which is a linear approximation of the original shape BB97 As mentionned in Edelsbrunner s and M cke s paper EM94 one can intuitively think of an alpha shape as the following Imagine a huge mass of ice cream making up the space 3 and containing the points as hard chocolate pieces Using one of those sphere formed ice cream spoons we carve out all parts of the ice cream block we can reach without bumping into chocolate pieces thereby even carving out holes in the inside eg parts not reachable by simply moving the spoon from the outside We will eventually end up with a not necessarily convex object bounded by caps arcs and points If we now straighten all round faces to triangles and line segments we have an intuitive description of what is called the alpha shape of S Here s an example for this process in 2D where our ice cream spoon is simply a circle Alpha shapes depend on a parameter from which they are named What is in the ice cream game is the squared radius of the carving spoon A very small value will allow us to eat up all of the ice cream except the chocolate points themselves Thus we already see that the alpha shape degenerates to the point set S for On the other hand a huge value of will prevent us even from moving the spoon between two points since it s way too large So we will never spoon up ice cream lying in the inside of the convex hull of S and hence the alpha shape for is the convex hull of S 1 41 1 Definitions More precisely the definition of alpha shapes is based on an underlying triangulation that may be a Delaunay triangulation in case of basic alpha shapes or a regular triangulation cf in case of weighted alpha shapes Let us consider the basic case with a Delaunay triangulation We first define the alpha complex of the set of points S The alpha complex is a subcomplex of the Delaunay triangulation For a given value of the alpha complex includes all the simplices in the Delaunay triangulation which have an empty circumsphere with squared radius equal or smaller than Here empty means that the open sphere do not include any points of S The alpha shape is then simply the domain covered by the simplices of the alpha complex see EM94 In general an alpha complex is a non connected and non pure complex This means in particular that the alpha complex may have singular faces For k d 1 a k simplex of the alpha complex is said to be singular if it is not a facet of a k 1 simplex of the complex CGAL provides two versions of the alpha shapes In the general mode the alpha shapes correspond strictly to the above definition The regularized mode provides a regularized version of the alpha shapes corresponding to the domain covered by a regularized version of the alpha complex where singular faces are removed The alpha shapes of a set of points S form a discrete family even though they are defined for all real numbers The entire family of alpha shapes can be represented through the underlying triangulation of S In this representation each k simplex of the underlying triangulation is associated with an interval that specifies for which values of the k simplex belongs to the alpha complex Relying on this fact the family of alpha shapes can be computed efficiently and relatively easily Furthermore we can select the optimal value of to get an alpha shape including all data points and having less than a given number of connected components The definition is analog in the case of weigthed alpha shapes The input set is now a set of weighted points which can be regarded as spheres and the underlying triangulation is the regular triangulation of this set Two spheres or two weighted points with centers C1 C2 and radii r1 r2 are said to be orthogonal iff C1C2 2 r12 r22 and suborthogonal iff C1C2 2 r12 r22 For a given value of the weighted alpha complex is formed with the simplices of the regular triangulation triangulation such that there is a sphere orthogonal to the weighted points associated with the vertices of the simplex and suborthogonal to all the other input weighted points Once again the alpha shape is then defined as the domain covered by a the alpha complex and arise in two versions general or regularized 41 2 Functionality The class CGAL Alpha shape 3 Dt represents the whole family of alpha shapes for a given set of points The class includes the underlying triangulation Dt of the set and associates to each k face of this triangulation an interval specifying for which values of the face belongs to the alpha complex The class CGAL Alpha shape 3 Dt provides functions to set and get the current value as well as an iterator that enumerates the values where the alpha shape changes The class provides member functions to classify for a given value of alpha the different faces of the triangulation as EXTERIOR SINGULAR REGULAR or INTERIOR with respect to the alpha shape A k face on the boundary of the alpha complex is said to be REGULAR if it is a subface of the alpha complex which is a subface of some k 1 face of the alpha complex and SINGULAR otherwise The class provides also output iterators to get for a given alpha value the vertices edges facets and cells of the different types EXTERIOR SINGULAR REGULAR or INTERIOR Finally it provides a function to determine the smallest value such that the alpha shape satisfies the following two properties ii all data points are either on the boundary or in the interior of the regularized version of the alpha shape no singular faces i The number of components is equal or less than a given number The current implementation is static that is after its construction points cannot be inserted or removed 41 3 Concepts and Models We currently do not specify concepts for the underlying triangulation type Models that work for a basic alpha shape are the classes CGAL Delaunay triangulation 3 and CGAL Triangulation hierarchy 3 templatized with a Delaunay triangulation A model that works for a weighted alpha shape is the class CGAL Regular triangulation 3 The triangulation needs a geometric traits class as argument The requirements of this class are described in the concept CGAL AlphaShapeTraits 3 for which the CGAL kernels are models in the non weighted case and for which the class CGAL Weighted alpha shape euclidean traits 3 is model in the weighted case The triangulation data structure of the triangulation with any has to be a model of the concept CGAL TriangulationDataStructure 3 However it must be parameterized with vertex and cell classes which are model of the concepts AlphaShapeVertex 3 and AlphaShapeCell 3 The package provides by default the classes CGAL Alpha shape vertex base 3 Gt and CGAL Alpha shape cell base 3 Gt 41 4 Examples 41 4 1 Example for Basic Alpha Shapes This example builds a basic alpha shape using a Delaunay triangulation as underlying triangulation examples Alpha shapes 3 example alpha C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 3 h include CGAL Alpha shape 3 h include fstream include list struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Alpha shape vertex base 3 K Vb typedef CGAL Alpha shape cell base 3 K Fb typedef CGAL Triangulation data structure 3 Vb Fb Tds typedef CGAL Delaunay triangulation 3 K Tds Triangulation 3 typedef CGAL Alpha shape 3 Triangulation 3 Alpha shape 3 typedef K Point 3 Point typedef Alpha shape 3 Alpha iterator Alpha iterator int main std list Point lp read input std ifstream is data bunny 1 int n is n std cout Reading n points std endl Point p for n n is p lp push back p compute alpha shape Alpha shape 3 as lp begin lp end std cout Alpha shape computed in REGULARIZED mode by defaut std endl find optimal alpha value Alpha iterator opt as find optimal alpha 1 std cout Optimal alpha value to get one connected component is opt std endl as set alpha opt assert as number of solid components 1 return 41 4 2 Building Basic Alpha Shapes for Many Points When many points are input in the alpha shape say more than 1 it pays off to use a triangulation hierarchy as underlying triangulation cf examples Alpha shapes 3 example big alpha C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 3 h include CGAL Triangulation hierarchy 3 h include CGAL Alpha shape 3 h include fstream include list struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Alpha shape vertex base 3 K Vb typedef CGAL Triangulation hierarchy vertex base 3 Vb Vbh typedef CGAL Alpha shape cell base 3 K Fb typedef CGAL Triangulation data structure 3 Vbh Fb Tds typedef CGAL Delaunay triangulation 3 K Tds Delaunay typedef CGAL Triangulation hierarchy 3 Delaunay Delaunay hierarchy typedef CGAL Alpha shape 3 Delaunay hierarchy Alpha shape 3 typedef K Point 3 Point typedef Alpha shape 3 Alpha iterator Alpha iterator typedef Alpha shape 3 NT NT int main Delaunay hierarchy dt std ifstream is data bunny 1 int n is n Point p std cout n points read std endl for n n is p dt insert p std cout Delaunay computed std endl compute alpha shape Alpha shape 3 as dt std cout Alpha shape computed in REGULARIZED mode by defaut std endl find optimal alpha values Alpha shape 3 NT alpha solid as find alpha solid Alpha iterator opt as find optimal alpha 1 std cout Smallest alpha value to get a solid through data points is alpha solid std endl std cout Optimal alpha value to get one connected component is opt std endl as set alpha opt assert as number of solid components 1 return 41 4 3 Example for Weighted Alpha Shapes The following examples build a weighted alpha shape requiring a regular triangulation as underlying triangulation The alpha shape is build in GENERAL mode examples Alpha shapes 3 example weight C include CGAL Simple cartesian h include CGAL MP Float h include CGAL Filtered exact h include list include CGAL Weighted alpha shape euclidean traits 3 h include CGAL Regular triangulation 3 h include CGAL Alpha shape 3 h typedef CGAL Filtered exact double CGAL MP Float NT struct K public CGAL Simple cartesian NT typedef CGAL Weighted alpha shape euclidean traits 3 K Gt typedef CGAL Alpha shape vertex base 3 Gt Vb typedef CGAL Alpha shape cell base 3 Gt Fb typedef CGAL Triangulation data structure 3 Vb Fb Tds typedef CGAL Regular triangulation 3 Gt Tds Triangulation 3 typedef CGAL Alpha shape 3 Triangulation 3 Alpha shape 3 typedef Alpha shape 3 Cell handle Cell handle typedef Alpha shape 3 Vertex handle Vertex handle typedef Alpha shape 3 Facet Facet typedef Alpha shape 3 Edge Edge typedef Gt Weighted point Weighted point typedef Gt Bare point Bare point int main std list Weighted point lwp input a small molecule lwp push back Weighted point Bare point 1 1 1 4 lwp push back Weighted point Bare point 1 1 1 4 lwp push back Weighted point Bare point 1 1 1 4 lwp push back Weighted point Bare point 1 1 1 4 lwp push back Weighted point Bare point 2 2 2 1 build alpha shape in GENERAL mode and set alpha Alpha shape 3 as lwp begin lwp end Alpha shape 3 GENERAL explore the shape It is dual to the boundary of the union std list Cell handle cells std list Facet facets std list Edge edges as get alpha shape cells std back inserter cells Alpha shape 3 INTERIOR as get alpha shape facets std back inserter facets Alpha shape 3 REGULAR as get alpha shape facets std back inserter facets Alpha shape 3 SINGULAR as get alpha shape edges std back inserter edges Alpha shape 3 SINGULAR std cout The shape has std endl std cout cells size interior tetrahedra std endl std cout facets size boundary facets std endl std cout edges size singular edges std endl return Footnotes 1 ice cream ice cream The wording of this introductory paragraphs is borrowed from Kaspar Fischer s Introduction to Alpha Shapes which can be found at http n ethz ch student fischerk alphashapes as index html The picture has been taken from Walter Luh s homepage at http www stanford edu wtilde luh cs448b alphashapes html Next chapter 3D Alpha Shapes Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Alpha_shapes_3/Chapter_main.html", "title": "3d alpha shapes", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Alpha_shapes_3/main.tex' -->\n<html> <head>  \n<title>3D Alpha Shapes</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_41\"></a>\n  \n<h1>Chapter 41<BR>3D Alpha Shapes</h1>\n <A NAME=\"I1_ChapterAlphashapes3D\"></A>\n<EM>Tran Kai Frank Da  and Mariette Yvinec</EM><BR>\n\n\n<P>\n\n<img border=0 src=\"./alphashape.gif\"  align=center  alt=\"alphashape\">\n<P>\n\nAssume we are given a set <MATH><I>S</I></MATH> of points in 2D or 3D and we'd like to\nhave something like ``the shape formed by these points.'' This is\nquite a vague notion and there are probably many possible\ninterpretations, the alpha shape  being one of them. Alpha shapes\ncan be used for shape reconstruction from a dense unorganized set of\ndata points. Indeed, an alpha shape  is demarcated by a frontier,\nwhich is a linear approximation of the original shape [<A HREF=\"../biblio.html#Biblio_bb-srmua-97t\">BB97</A>].\n<P>\n\nAs mentionned in Edelsbrunner's and M&uuml;cke's paper [<A HREF=\"../biblio.html#Biblio_em-tdas-94\">EM94</A>],\none can intuitively think of an alpha shape  as the\nfollowing. Imagine a huge mass of ice-cream making up the space <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>\nand containing the points as ``hard'' chocolate pieces. Using one of\nthose sphere-formed ice-cream spoons we carve out all parts of the\nice-cream block we can reach without bumping into chocolate pieces,\nthereby even carving out holes in the inside (eg. parts not reachable\nby simply moving the spoon from the outside). We will eventually end\nup with a (not necessarily convex) object bounded by caps, arcs and\npoints. If we now straighten all ``round'' faces to triangles and line\nsegments, we have an intuitive description of what is called the\nalpha shape  of <MATH><I>S</I></MATH>. Here's an example for this process in 2D (where\nour ice-cream spoon is simply a circle):\n<P>\n\nAlpha shapes depend on a parameter <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> from which they\nare named.                                                                  \nWhat is <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> in the ice-cream game?  <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> is the squared radius of the\ncarving spoon. A very small value will allow us to eat up all of the\nice-cream except the chocolate points themselves. Thus we already see\nthat the alpha shape  degenerates to the point-set <MATH><I>S</I></MATH> for\n<MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"> <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_rightarrow.gif\"> 0</I></MATH>. On the other hand, a huge value of <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>\nwill prevent us even from moving the spoon between two points since\nit's way too large. So we will never spoon up ice-cream lying in the\ninside of the convex hull of <MATH><I>S</I></MATH>, and hence the alpha shape  for\n<MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"> <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_rightarrow.gif\">  <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </I></MATH> is the convex hull of <MATH><I>S</I></MATH>.<A HREF=\"#Footnote_1\"><SUP>1</SUP></A>\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>41.1&nbsp;&nbsp;&nbsp;Definitions</h2>\n<P>\n\nMore precisely, the definition of alpha shapes is based on an underlying\ntriangulation that may be a Delaunay triangulation \nin case of basic alpha shapes \nor a regular triangulation \n(cf. <A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-class-Regulartriangulation\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>)\nin case of weighted alpha shapes.\n<P>\n\nLet us consider the basic case with a Delaunay triangulation.\nWe first define the alpha complex  of the set of points <MATH><I>S</I></MATH>. \nThe  alpha complex is a subcomplex \nof the Delaunay triangulation.\nFor a given value of <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>, the alpha complex includes\nall the simplices in the Delaunay triangulation which have\nan empty  circumsphere with squared radius equal or smaller than <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>.\nHere ``empty'' means  that the open sphere \ndo not include  any points of <MATH><I>S</I></MATH>.\nThe alpha shape is then simply the domain covered by the simplices\nof the alpha complex (see [<A HREF=\"../biblio.html#Biblio_em-tdas-94\">EM94</A>]).\n<P>\n\nIn general, an alpha complex is a non-connected and non-pure complex.\nThis means in particular that the alpha complex may have\nsingular faces.  For <MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> k  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> d-1</I></MATH>,\na <MATH><I>k</I></MATH>-simplex of the alpha complex  is said to be\nsingular if it is not a facet of a <MATH><I>(k+1)</I></MATH>-simplex of the complex\nCGAL provides two versions of the alpha shapes. In the general mode,\nthe alpha shapes correspond strictly to the above definition.\nThe regularized mode provides a regularized version of the alpha shapes\ncorresponding to the domain covered by a regularized version\nof the alpha complex where singular faces are removed.\n<P>\n\nThe alpha shapes of a  set of points \n<MATH><I>S</I></MATH> form a discrete family, even though they\nare defined for all real numbers <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>.\nThe entire family of alpha shapes can be represented \nthrough  the underlying triangulation of <MATH><I>S</I></MATH>. In this representation\neach <MATH><I>k</I></MATH>-simplex of the underlying triangulation is associated with an\ninterval that specifies for which values of <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> the <MATH><I>k</I></MATH>-simplex\nbelongs to the alpha complex. Relying on this fact, the family of\n alpha shapes can be computed efficiently and relatively\neasily. Furthermore, we can select the optimal value\nof  <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> to get an alpha shape including all data points\nand having   less than a given number of connected components.\n<P>\n\nThe definition is analog in the case of weigthed alpha shapes.\nThe input set is now a set of weighted points (which can be regarded\nas spheres) and the underlying triangulation \nis the regular triangulation of this set.\nTwo spheres, or two weighted points , with centers <MATH><I>C<SUB>1</SUB>, C<SUB>2</SUB></I></MATH>\nand  radii <MATH><I>r<SUB>1</SUB>, r<SUB>2</SUB> </I></MATH> are said to be orthogonal iff \n<MATH><I> C<SUB>1</SUB>C<SUB>2</SUB> <SUP>2</SUP> = r<SUB>1</SUB><SUP>2</SUP> + r<SUB>2</SUB><SUP>2</SUP></I></MATH> and suborthogonal\niff  <MATH><I> C<SUB>1</SUB>C<SUB>2</SUB> <SUP>2</SUP> &lt; r<SUB>1</SUB><SUP>2</SUP> + r<SUB>2</SUB><SUP>2</SUP></I></MATH>.\nFor a given value of <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>\nthe weighted alpha complex is formed with the simplices of the \nregular triangulation triangulation\nsuch that there is a sphere orthogonal to the weighted points associated\nwith the vertices of the simplex  and suborthogonal to all the other\ninput weighted points. Once again the alpha shape is then defined as\nthe domain covered by a the alpha complex and arise in two versions\ngeneral or regularized.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>41.2&nbsp;&nbsp;&nbsp;Functionality <A NAME=\"I1_SectAlpha_Shape_3\"></A></h2>\n<P>\n\nThe class <I><A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1029\">CGAL::Alpha_shape_3</A>&lt;Dt&gt;</I> represents the whole\nfamily of alpha shapes for a given set of points.\nThe class includes  the underlying triangulation <I>Dt</I>\nof the set,  and associates to each <MATH><I>k</I></MATH>-face of this triangulation\n an interval specifying \nfor which values of <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> the face belongs to the\nalpha complex.\n<P>\n\nThe class <I><A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1029\">CGAL::Alpha_shape_3</A>&lt;Dt&gt;</I> provides functions to set and\nget the current <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>-value, as well as an iterator that enumerates\nthe <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH> values where the alpha shape changes.\n<P>\n\nThe class provides member functions to classify for a given value\nof <MATH><I>alpha</I></MATH> the different faces of the triangulation as\n<I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">EXTERIOR</A></I>, <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">SINGULAR</A></I>, <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">REGULAR</A></I> or \n<I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">INTERIOR</A></I> with respect\nto the alpha shape. A <MATH><I>k</I></MATH> face  on the boundary of the alpha complex\nis said to be <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">REGULAR</A></I>  if it is a subface of the alpha complex\nwhich is  a subface of some <MATH><I>k+1</I></MATH> face of the alpha complex\nand <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">SINGULAR</A></I> otherwise.\n<P>\n\nThe class  provides also output iterators  to  get for a given <MATH><I>alpha</I></MATH> value\nthe vertices, edges, facets and cells of the different types\n(<I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">EXTERIOR</A></I>, <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">SINGULAR</A></I>, <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">REGULAR</A></I> or \n<I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">INTERIOR</A></I>).\n<P>\n\nFinally, it provides a function to determine \nthe smallest value <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\"></I></MATH>\nsuch that the alpha shape   satisfies the following two properties&nbsp;<BR>\n\n(ii) all data points are either on the boundary or in the interior \n   of the regularized version of the alpha shape  (no singular faces).<BR>\n\n(i) The number of components is equal or less  than a given  number .\n<P>\n\n<BR>\n\nThe current implementation is static, that is after its construction\npoints cannot be inserted or removed.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>41.3&nbsp;&nbsp;&nbsp;Concepts and Models<A NAME=\"I1_SectDtClass3D\"></A></h2>\n<P>\n\nWe currently do not specify concepts for the underlying triangulation\ntype. Models that work for a basic alpha-shape are the classes\n<I><A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A></I> and \n<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_975\">CGAL::Triangulation_hierarchy_3</A></I> templatized with a Delaunay\ntriangulation. A model that works for a weighted alpha-shape is \nthe class <I><A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_977\">CGAL::Regular_triangulation_3</A></I>.\n<P>\n\nThe triangulation needs a geometric traits class as argument.\nThe requirements of this class are described in the \nconcept <I>CGAL::<A HREF=\"../Alpha_shapes_3_ref/Concept_AlphaShapeTraits_3.html#Cross_link_anchor_1027\">AlphaShapeTraits_3</A></I> for which\nthe C<SMALL>GAL</SMALL> kernels are models in the non-weighted case, and for which\nthe class <I><A HREF=\"../Alpha_shapes_3_ref/Class_Weighted_alpha_shape_euclidean_traits_3.html#Cross_link_anchor_1038\">CGAL::Weighted_alpha_shape_euclidean_traits_3</A></I> is model\nin the weighted case.\n<P>\n\nThe triangulation data structure of the triangulation with any \nhas to be a model of the concept <I>CGAL::<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I>.\nHowever it must be parameterized with \nvertex and cell classes, which are model of the concepts\n<I><A HREF=\"../Alpha_shapes_3_ref/Concept_AlphaShapeVertex_3.html#Cross_link_anchor_1028\">AlphaShapeVertex_3</A></I> and <I><A HREF=\"../Alpha_shapes_3_ref/Concept_AlphaShapeCell_3.html#Cross_link_anchor_1026\">AlphaShapeCell_3</A></I>.\nThe package provides\nby default the classes <I><A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_vertex_base_3.html#Cross_link_anchor_1033\">CGAL::Alpha_shape_vertex_base_3</A>&lt;Gt&gt;</I> \nand <I><A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_cell_base_3.html#Cross_link_anchor_1031\">CGAL::Alpha_shape_cell_base_3</A>&lt;Gt&gt;</I>.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>41.4&nbsp;&nbsp;&nbsp;Examples</h2>\n\n\n<h3>41.4.1&nbsp;&nbsp;&nbsp;Example for Basic Alpha-Shapes<A NAME=\"I1_SectClassicAS3D\"></A></h3>\n<P>\n\nThis example builds a basic alpha shape using a  Delaunay triangulation\nas underlying triangulation.\n<P>\n\n<pre class=\"ExampleCode\">// examples/Alpha_shapes_3/example_alpha.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>.h&gt;\n\n#include &lt;fstream&gt;\n#include &lt;list&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_vertex_base_3.html#Cross_link_anchor_1033\">CGAL::Alpha_shape_vertex_base_3</A>&lt;K&gt;          Vb;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_cell_base_3.html#Cross_link_anchor_1031\">CGAL::Alpha_shape_cell_base_3</A>&lt;K&gt;            Fb;\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;Vb,Fb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K,Tds&gt;       <A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1029\">CGAL::Alpha_shape_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&gt;        <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>;\n\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>                                  Point;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::Alpha_iterator               Alpha_iterator;\n\nint main()\n{\n  std::list&lt;Point&gt; lp;\n\n  //read input\n  std::ifstream is(&quot;./data/bunny_1000&quot;);\n  int n;   \n  is &gt;&gt; n;\n  std::cout &lt;&lt; &quot;Reading &quot; &lt;&lt; n &lt;&lt; &quot; points &quot; &lt;&lt; std::endl; \n  Point p;\n  for( ; n&gt;0 ; n--)    { \n    is &gt;&gt; p;      \n    lp.push_back(p);\n  }\n  \n  // compute alpha shape  \n  <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A> as(lp.begin(),lp.end());\n  std::cout &lt;&lt; &quot;Alpha shape computed in <A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Mode\">REGULARIZED</A> mode by defaut&quot; \n\t    &lt;&lt; std::endl;\n\n  // find optimal alpha value\n  Alpha_iterator opt = as.find_optimal_alpha(1);\n  std::cout &lt;&lt; &quot;Optimal alpha value to get one connected component is &quot; \n\t    &lt;&lt;  *opt    &lt;&lt; std::endl;\n  as.set_alpha(*opt);\n  assert(as.number_of_solid_components() == 1);\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>41.4.2&nbsp;&nbsp;&nbsp;Building Basic Alpha Shapes for Many Points</h3>\n\nWhen many points are input in the alpha shape, say more than 10 000,\nit pays off to use a triangulation hierarchy as underlying triangulation\n(cf. <A HREF=\"../Triangulation_3/Chapter_main.html#T3-concept-hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\n<pre class=\"ExampleCode\">// examples/Alpha_shapes_3/example_big_alpha.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>.h&gt;\n\n#include &lt;fstream&gt;\n#include &lt;list&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_vertex_base_3.html#Cross_link_anchor_1033\">CGAL::Alpha_shape_vertex_base_3</A>&lt;K&gt;               Vb;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_vertex_base_3.html#Cross_link_anchor_997\">CGAL::Triangulation_hierarchy_vertex_base_3</A>&lt;Vb&gt;  Vbh;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_cell_base_3.html#Cross_link_anchor_1031\">CGAL::Alpha_shape_cell_base_3</A>&lt;K&gt;                 Fb;\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;Vbh,Fb&gt;     Tds;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Delaunay_triangulation_3.html#Cross_link_anchor_973\">CGAL::Delaunay_triangulation_3</A>&lt;K,Tds&gt;            Delaunay;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Triangulation_hierarchy_3.html#Cross_link_anchor_975\">CGAL::Triangulation_hierarchy_3</A>&lt;Delaunay&gt;        Delaunay_hierarchy;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1029\">CGAL::Alpha_shape_3</A>&lt;Delaunay_hierarchy&gt;          <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>;\n\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>                                  Point;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::Alpha_iterator               Alpha_iterator;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::NT                           NT;\n\nint main()\n{\n  Delaunay_hierarchy dt;\n  std::ifstream is(&quot;./data/bunny_1000&quot;);\n  int n;\n  is &gt;&gt; n;\n  Point p;\n  std::cout &lt;&lt; n &lt;&lt; &quot; points read&quot; &lt;&lt; std::endl;\n  for( ; n&gt;0 ; n--) {\n    is &gt;&gt; p;\n    dt.insert(p);\n  }\n  std::cout &lt;&lt; &quot;Delaunay computed.&quot; &lt;&lt; std::endl;\n\n  // compute alpha shape  \n  <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A> as(dt);\n  std::cout &lt;&lt; &quot;Alpha shape computed in <A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Mode\">REGULARIZED</A> mode by defaut.&quot; \n\t    &lt;&lt; std::endl;\n\n   // find optimal alpha values\n  <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::NT alpha_solid = as.find_alpha_solid();\n  Alpha_iterator opt = as.find_optimal_alpha(1);\n  std::cout &lt;&lt; &quot;Smallest alpha value to get a solid through data points is &quot; \n\t    &lt;&lt; alpha_solid &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Optimal alpha value to get one connected component is &quot; \n\t    &lt;&lt;  *opt    &lt;&lt; std::endl;\n  as.set_alpha(*opt);\n  assert(as.number_of_solid_components() == 1);\n  return 0;\n}\n</pre>\n<P>\n\n<h3>41.4.3&nbsp;&nbsp;&nbsp;Example for Weighted Alpha-Shapes<A NAME=\"I1_SectWeightedAS3D\"></A></h3>\n<P>\n\nThe following examples build a weighted alpha shape requiring a\nregular triangulation as underlying triangulation.\nThe alpha shape is build in <I><A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Mode\">GENERAL</A></I> mode.\n<P>\n\n<pre class=\"ExampleCode\">// examples/Alpha_shapes_3/example_weight.C\n\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>.h&gt;\n\n#include &lt;list&gt;\n\n#include &lt;CGAL/<A HREF=\"../Alpha_shapes_3_ref/Class_Weighted_alpha_shape_euclidean_traits_3.html#Cross_link_anchor_1039\">Weighted_alpha_shape_euclidean_traits_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_978\">Regular_triangulation_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;double, <A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt; NT;\nstruct K : public <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;NT&gt; {};\n\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Weighted_alpha_shape_euclidean_traits_3.html#Cross_link_anchor_1038\">CGAL::Weighted_alpha_shape_euclidean_traits_3</A>&lt;K&gt; Gt;\n\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_vertex_base_3.html#Cross_link_anchor_1033\">CGAL::Alpha_shape_vertex_base_3</A>&lt;Gt&gt;         Vb;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_cell_base_3.html#Cross_link_anchor_1031\">CGAL::Alpha_shape_cell_base_3</A>&lt;Gt&gt;           Fb;\ntypedef <A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A>&lt;Vb,Fb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_3_ref/Class_Regular_triangulation_3.html#Cross_link_anchor_977\">CGAL::Regular_triangulation_3</A>&lt;Gt,Tds&gt;       <A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1029\">CGAL::Alpha_shape_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&gt;        <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>;\n\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::Cell_handle          Cell_handle;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::Vertex_handle        Vertex_handle;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::Facet                Facet;\ntypedef <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::Edge                 Edge;\ntypedef Gt::<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>                  <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>;\ntypedef Gt::Bare_point                      Bare_point;\n\nint main()\n{\n  std::list&lt;<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>&gt; lwp;\n\n  //input : a small molecule\n  lwp.push_back(<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>(Bare_point( 1, -1, -1), 4));\n  lwp.push_back(<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>(Bare_point(-1,  1, -1), 4));\n  lwp.push_back(<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>(Bare_point(-1, -1,  1), 4));\n  lwp.push_back(<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>(Bare_point( 1,  1,  1), 4));\n  lwp.push_back(<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>(Bare_point( 2,  2,  2), 1));\n\n  //build alpha_shape  in <A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Mode\">GENERAL</A> mode and set alpha=0\n  <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>  as(lwp.begin(), lwp.end(), 0, <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::<A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Mode\">GENERAL</A>);\n\n  //explore the 0-shape - It is dual to the boundary of the union.\n  std::list&lt;Cell_handle&gt; cells;\n  std::list&lt;Facet&gt;       facets;\n  std::list&lt;Edge&gt;        edges;\n  as.get_alpha_shape_cells(std::back_inserter(cells), \n\t\t\t   <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::<A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">INTERIOR</A>);\n  as.get_alpha_shape_facets(std::back_inserter(facets), \n\t\t\t    <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::<A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">REGULAR</A>);\n  as.get_alpha_shape_facets(std::back_inserter(facets), \n\t\t\t    <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::<A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">SINGULAR</A>);\n  as.get_alpha_shape_edges(std::back_inserter(edges), \n\t\t\t   <A HREF=\"../Alpha_shapes_3_ref/Class_Alpha_shape_3.html#Cross_link_anchor_1030\">Alpha_shape_3</A>::<A HREF=\"../Alpha_shapes_2_ref/Class_Alpha_shape_2#Enum_Classification_type\">SINGULAR</A>);\n  std::cout &lt;&lt; &quot; The 0-shape has : &quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; cells.size() &lt;&lt; &quot; interior tetrahedra&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; facets.size() &lt;&lt; &quot; boundary facets&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; edges.size()  &lt;&lt; &quot; singular edges&quot; &lt;&lt; std::endl;\n  return 0;\n}\n</pre>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nice cream, ice cream!!!\nThe wording of this introductory paragraphs is borrowed from  Kaspar Fischer's\n`` Introduction to Alpha Shapes'' which can be found at \nhttp://n.ethz.ch/student/fischerk/alphashapes/as/index.html.\nThe picture has been taken from Walter Luh's homepage at\nhttp://www.stanford.edu/&wtilde;luh/cs448b/alphashapes.html.\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Alpha_shapes_3_ref/Chapter_intro.html\">3D Alpha Shapes</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_41!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39132.0}