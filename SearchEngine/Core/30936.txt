{"text": "HW4 Homography mosaics Due Nov 2 in EEE DropBox at 11 59 pm HW4 Homography mosaics Mosaic of 4 images aligned with homographies In this assignment again prepared by the fearless David Martin you extend the field of view of a camera by forming a mosaic from multiple photographs When images are taken with same optical center they can be aligned with a homography transformation To estimate the homography you ll need 4 pairs of corresponding points in the overlap region You ll mark these points manually We discussed in class some methods for finding them automatically The following directory contains the source images for alignment along with skeleton code Downloads Programming 2 points The first image in each example provided is the central image It s simplest to construct a mosaic from a central image and a set of peripheral images since we then need to find just one homography for each peripheral image Use the cpselect and cpcorr functions to manually select and refine at least 4 pairs of corresponding points in each overlap region between the central and peripheral images These points should be located on high contrast corners Next compute the homography using linear least squares for each set of correspondences to provide the mapping from points in the central images and points in the peripheral images You ll probably want to write two functions such as function H computeHomography x1 y1 x2 y2 function x2 y2 applyHomography H x1 y1 Note that the inverse mapping is given simply by inv H Use the central image s coordinate system for the final mosaic You need to figure out the min and max pixel coordinates when the peripheral images are mapped into the central image s coordinate system Simply apply your homographies to the peripheral images corner points to find the extent of the final mosaic Now generate a meshgrid of points to cover the mosaic send these points through each homography in turn and use interp2 to extract pixel values from the source images For each input image this produces an image the size of the final mosaic pixels that are outside the source image are set to NaN Finally assemble the mosaic from the remapped source images Use isnan I to get a mask for each one that tells you which pixels are valid and which are invalid For Part I you may simply take a pixel from any valid image Writeup 1 points Show the resulting mosaic for one of the provided examples Show also the remapped source images before they are blended into the final mosaic Show two mosaics of your own creation each with at least 3 source images Show also the remapped source images before they are blended into the final mosaic Matlab Tips Don t forget the hold on command if you want to plot one thing on top of another Running cpselect is a pain Don t do it more than once for any pair of images You can use the save and load functions to save and restore variables from your matlab workspace Do no use the full size images Resize them down so that your debugging goes fast For your final results 25 size is sufficient You can treat the central image as just another source image by using eye 3 as its homography Use linear interpolation with interp2 it s fast and looks good Just make sure you don t use nearest neighbor interpolation which looks terrible and may be the default Extra credit As detailed in the guidelines any project handed by 11 59 pm on the previous day Nov 19th will recieve 1 3 points extra credit ", "_id": "http://www.ics.uci.edu/~dramanan/teaching/cs116_winter15/hw/Project/Mosaic/", "title": "hw4: ", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n  <head>\n    <title>HW4: </title>\n  </head>\n  <body>\n    <h1>HW4: Homography mosaics </h1>\n    <h3> Due Nov 20 in EEE DropBox at 11:59 pm </h3>\n    <hr>\n\n<h2>HW4: Homography mosaics</h2>\n\n\n<a href=\"window.png\"> <img width=500 src=\"window.png\"> </a>\n<font size=\"-1\"><br>\nMosaic of 4 images aligned with homographies\n</font>\n<br>\n\n<p>\nIn this assignment, again prepared by the fearless <a href=\"http://vision.bc.edu/~dmartin/\"> David Martin<a/>, you extend the field of view of a camera by forming a mosaic from multiple photographs. \n\nWhen images are taken with same optical center, they can be aligned with a homography transformation. To estimate the homography, you'll need 4 pairs of corresponding points in the overlap region. You'll mark these points manually. We discussed in class some methods for finding them automatically.\n\nThe following directory contains the source images for alignment, along with skeleton code:\n\n<ul>\n<li><a href=\"downloads\">Downloads</a>\n</ul>\n\n<h4>Programming: [20 points]</h4>\n\n<p>\nThe first image in each example provided is the central image.  It's\nsimplest to construct a mosaic from a central image and a set of\nperipheral images, since we then need to find just one homography for\neach peripheral image.  Use the <tt>cpselect</tt> and <tt>cpcorr</tt>\n\nfunctions to manually select and refine at least 4 pairs of\ncorresponding points in each overlap region between the central and\nperipheral images.  These points should be located on high contrast\ncorners.\n\n<p>\nNext, compute the homography using linear least squares for each set\nof correspondences to provide the mapping from points in the central\nimages and points in the peripheral images.  You'll probably want \nto write two functions such as:\n\n<blockquote><tt><pre>\nfunction [H] = computeHomography(x1,y1,x2,y2)\nfunction [x2,y2] = applyHomography(H,x1,y1)\n</pre></tt></blockquote>\n\n<p>\nNote that the inverse mapping is given simply by <tt>inv(H)</tt>.\n\n<p>\nUse the central image's coordinate system for the final mosaic.  You\nneed to figure out the min and max pixel coordinates when the peripheral\nimages are mapped into the central image's coordinate system.  Simply\napply your homographies to the peripheral images' corner points to find\nthe extent of the final mosaic.\n\n<p>\nNow generate a <tt>meshgrid</tt> of points to cover the mosaic, send\nthese points through each homography in turn, and use\n\n<tt>interp2</tt> to extract pixel values from the source images.  For\neach input image, this produces an image the size of the final mosaic;\npixels that are outside the source image are set to <tt>NaN</tt>.\n\n<p>\nFinally, assemble the mosaic from the remapped source images.  Use\n<tt>isnan(I)</tt> to get a mask for each one that tells you which pixels\nare valid and which are invalid.  For Part I, you may simply take a\npixel from any valid image.\n\n<h4>Writeup: [10 points]</h4>\n\n<ol>\n\n<p><li> Show the resulting mosaic for one of the provided examples.  Show\nalso the remapped source images before they are blended into the final \nmosaic.\n\n\n<p><li> Show two mosaics of your own creation, each with at least 3 \nsource images.  Show\nalso the remapped source images before they are blended into the final \nmosaic.\n\n</ol>\n\n<h4>Matlab Tips</h4>\n\n<ol>\n\n<p><li> Don't forget the <tt>hold on</tt> command if you want to \nplot one thing on top of another.\n\n<p><li> Running <tt>cpselect</tt> is a pain.  Don't do it more than\nonce for any pair of images!  You can use the <tt>save</tt> and\n\n<tt>load</tt> functions to save and restore variables from your\nmatlab workspace.\n\n<p><li> Do no use the full size images.  Resize them down so that your\ndebugging goes fast.  For your final results, 25% size is sufficient.\n\n<p><li> You can treat the central image as just another source image\nby using <tt>eye(3)</tt> as its homography.\n\n<p><li> Use <tt>'linear'</tt> interpolation with <tt>interp2</tt>; \nit's fast and looks good.  Just make sure you don't use nearest neighbor\ninterpolation, which looks terrible and may be the default.\n\n\n</ol>\n\n<h4>Extra-credit</h4>\n    As detailed in the <a href=\"../../hw_guide.html\"> guidelines</a>, any project handed by 11:59 pm on the previous day (Nov 19th), will recieve 10% (3 points) extra credit.\n\n</p></div></center>\n</body></html>", "id": 30936.0}