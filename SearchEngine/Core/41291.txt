{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Planar map 2 Dcel Traits DefinitionAn object pm of the class Planar map 2 Dcel Traits is the subdivision of the planar induced by a set of x monotone curves such that no curve intersects the interior of any other curve The available traits and dcel classes are described below Self is an abbreviation of the Planar map 2 Dcel Traits type hereafter include CGAL Planar map 2 h Inherits FromCGAL Topological map Dcel The modifying functions insert in face interior insert from vertex insert at vertices split edge merge edge and remove edge overwrite the inherited functions and make use of the geometric information of the planar map Types Planar map 2 Dcel Traits Traits traits class Planar map 2 Dcel Traits Dcel DCEL class Planar map 2 Dcel Traits Change notification The Vertex Halfedge and Face types of the planar map are defined as part of the planar map DCEL While the face of planar map is a face of the topological map the Vertex and Halfedge have additional functionality A Vertex has the additional point and set point operations A Halfedge has the additional curve and set curve operations See concepts PlanarMapDcel 2 PlanarMapDcelVertex 2 and PlanarMapDcelHalfedge 2 Planar map 2 Dcel Traits Vertex represents a vertex of the planar map Planar map 2 Dcel Traits Halfedge represents a halfedge of the topological map Planar map 2 Dcel Traits Face represents a face of the topological map typedef typename Traits X monotone curve 2 X monotone curve 2 a curve of the planar map typedef typename Traits Point 2 Point 2 a point of the planar map Constants enum Locate type VERTEX 1 EDGE FACE UNBOUNDED VERTEX UNBOUNDED EDGE UNBOUNDED FACE an enumeration that specifies the result of point location and ray shooting operations Creation Planar map 2 Dcel Traits pm constructs an empty map containing one unbounded face which corresponds to the whole plane Planar map 2 Dcel Traits pm Self pm copy constructor advanced Point Location As described in the introduction the planar map users can define which algorithm to use in the point location queries This is done by passing an instance of some point location class instance to the map in this constructor The point location class should be a model of the PlanarMapPointLocation 2 concept The randomized trapezoidal decomposition algorithm is the one used by default in our implementation However the users can choose to use the naive or walk algorithms trading time for memory efficiency or can implement their own point location algorithm This can be done with a class derived from the Point location base Planar map The concept PlanarMapPointLocation 2 lists the set of requirements Planar map 2 Dcel Traits pm Pm point location base Self pl ptr advanced advanced Reading Planar map bool pm read istream in reads Planar map 2 Dcel Traits from the given input stream in The input stream should support the extractor operator for the Point 2 and X monotone curve 2 types of Planar map Note that the verbose format is not meant to be read template class Scanner bool pm read istream in Scanner scanner reads Planar map 2 Dcel Traits from the given input stream in using scanner The input stream should support the extractor operator for the Point 2 and X monotone curve 2 types of Planar map advanced Query Functions The following two functions are query functions Their time complexity depends on the point location strategy used Halfedge handle pm locate Point 2 p Locate type lt computes the location in pm where p lies If lt returns VERTEX then p lies on the vertex which is the target of the returned Halfedge If lt returns EDGE then p lies on the returned Halfedge If lt returns FACE then p lies on the face which is on the left of the returned Halfedge If lt returns UNBOUNDED FACE then p lies on the unbounded face and the returned Halfedge is on the boundary of a hole in the unbounded face The returned value for an empty map equals halfedges end Halfedge handle pm vertical ray shoot Point 2 p Locate type lt bool up direction if up direction is true respectively false returns the first edge of pm that intersects the upward respectively downward vertical ray emanating from p If several edges intersect the vertical ray in the same end point q the function returns the first halfedge pointing at q that is encountered when moving clockwise from pq around q In that case the value of lt will be VERTEX If the ray does not intersect any edge the value of lt will be UNBOUNDED FACE and the Halfedge returned will be null valued Otherwise the value of lt will be EDGE Postcondition the returned edge belongs to one of the CCB s of the face in which p is found null valued if none is found bool pm is point in face Point 2 p Face const handle f determines whether the given point p lies within the interior of the given face f A point lies within a face interior iff the number of intersections between the face boundary and a ray emanating from the point is even Note that if f is the unbounded face and it has no holes the point must lie within the face interior is point in face returns true if p lies within the interior of f and false otherwise advanced For some applications the users may want to have direct access to the point location strategy e g query the default strategy about the state of its internal search structure For this we have implemented the following function note that the returned pointer is const so the users cannot change the internal state const Pm point location base Self pm point location returns a const pointer to the point location strategy of the map advanced Modifiers Halfedge handle pm insert X monotone curve 2 cv Change notification en NULL inserts the curve cv into the map insert returns a handle to a new halfedge directed in the same way as the curve cv That is the curve source and target points coincide with the points of the source and target vertices of the returned halfedge respectively Precondition no curve of pm intersects cv in the interiors of the curve itself and cv Precondition cv is not equivalent to a point template X curve iterator Halfedge handle pm insert X curve iterator begin X curve iterator end Change notification en NULL iterates through a given range of curves inserting the curves into the map begin and end are input iterators that point to the first curve and past the end curve of the range respectively insert returns a handle to a new halfedge directed in the same way as the last curve in the range Precondition the curves of pm do not intersect the curves in the given range in the interiors of the curves respectively Precondition no curve in the given range is equivalent to a point advanced Specialized Insertion Functions The following functions enable the usage of information about the map which was acquired beforehand to save time in insertions It is recommended to use these functions with the naive point location strategy Halfedge handle pm insert in face interior X monotone curve 2 cv Face handle f Change notification en NULL inserts the curve cv as a new inner component of the face f insert in face interior returns a handle to a new halfedge directed in the same way as cv Precondition cv is contained completely in the interior of f no endpoint of cv coincides with a point of any vertex of the map Precondition cv is not equivalent to a point Halfedge handle pm insert from vertex X monotone curve 2 cv Vertex handle v Change notification en NULL inserts the curve cv into the map One endpoint of cv is the point of the given vertex v that is already in the map insert from vertex returns a handle to a new halfedge that has v as its source vertex Precondition v is a vertex of the map Precondition the point of v coincides with one endpoint of cv Precondition no vertex of the map has a point that coincides with the other endpoint of cv Precondition no curve of pm intersects cv in the interiors of the curve itself and cv Precondition cv is not equivalent to a point Halfedge handle pm insert at vertices X monotone curve 2 cv Vertex handle v1 Vertex handle v2 Change notification en NULL inserts the curve cv into the map The two endpoints of cv are held by the two given vertices v1 and v2 respectively that are already in the map insert at vertices returns a handle to a new halfedge that has v1 and v2 as its source and target vertices respectively Precondition v1 and v2 are vertices of the map Precondition the points of v1 and v2 coincide with the two endpoints of cv respectively Precondition no curve of pm intersects cv in the interiors of the curve itself and cv Precondition cv is not equivalent to a point Halfedge handle pm insert from vertex X monotone curve 2 cv Halfedge handle h Change notification en NULL inserts the curve cv into the map One endpoint of cv is the point of the target vertex v of the given halfedge h insert from vertex returns a handle to a new halfedge that has v as its source vertex The returened twin halfedge is inserted immediately after h in the circular list of halfedges that share the same target vertex v This method is the quick version of insert from vertex as the search for the previous halfedge in the circular list of halfedges that share the same target vertex is unnecessary saving computation time Precondition h is a halfedge of the map Precondition the point of v coincides with one endpoint of cv Precondition no vertex of the map has a point that coincides with the other endpoint of cv Precondition In the clockwise order of curves around the common point of v cv succeeds the curve of h Precondition no curve of pm intersects cv in the interiors of the curve itself and cv Precondition cv is not equivalent to a point Halfedge handle pm insert at vertices X monotone curve 2 cv Halfedge handle h1 Halfedge handle h2 Change notification en NULL inserts the curve cv into the map The two endpoints of cv are held by the two target vertices v1 and v2 of h1 and h2 respectively insert at vertices returns a handle to a new halfedge that has v1 and v2 as its source and target vertices respectively The returened halfedge is inserted immediately after h1 in the circular list of halfedges that share the same target vertex v1 Its twin halfedge is inserted immediately after h2 in the circular list of halfedges that share the same target vertex v2 This method is the quick version of insert from vertex as the search for the previous halfedges in the circular lists of halfedges that share the same target vertices is unnecessary saving computation time Precondition h1 and h2 are halfedges of the map Precondition the points of v1 and v2 coincide with the two endpoints of cv respectively Precondition In the clockwise order of curves around the common point of v1 cv succeeds the curve of h1 Precondition In the clockwise order of curves around the common point of v2 cv succeeds the curve of h2 Precondition no curve of pm intersects cv in the interiors of the curve itself and cv Precondition cv is not equivalent to a point advanced Halfedge handle pm split edge Halfedge handle e X monotone curve 2 c1 X monotone curve 2 c2 splits the edge e into e1 and e2 and add a vertex in the splitting point If the source point of e is identical to the source of the curve c1 then c1 abd c2 will be assigned to e1 and to e2 respectively and to their respective twin halfedges Otherwise the opposite will take place The returned halfedge will be e1 where e2 is e1 next halfedge Precondition the preconditions of Topological map Dcel split edge Precondition the target of the curve c1 is identical to the source of the curve c2 Precondition the source of the curve c1 is identical to the source point of e and the target of the curve c2 is identical to the target point of e or the source of the curve c1 is identical to the target point of e and the target of the curve c2 is identical to the source point of e Halfedge handle pm merge edge Halfedge handle e1 Halfedge handle e2 X monotone curve 2 cv merges the edges represented by e1 and e2 into a single edge The resulting halfedge and its twin hold the curve cv The return value is the halfedge with the same source vertex that e1 had and the same target e2 had Precondition the preconditions of Topological map Dcel merge edge Precondition the source of the curve cv is identical to the source point of e1 and the target of the curve cv is identical to the target point of e2 or the target of the curve cv is identical to the source point of e1 and the source of the curve cv is identical to the target point of e2 Face handle pm remove edge Halfedge handle e removes the edge e from pm If the operation causes two faces to merge the merged face is returned Otherwise the face to which the edge was incident is returned See AlsoTopological map Dcel PlanarMapDcel 2 Next PlanarMapPointLocation 2 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Planar_map_ref/Class_Planar_map_2", "title": "planar_map_2&lt;dcel,traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Planar_map_ref/Planar_map.tex' -->\n<html> <head>  \n<title>Planar_map_2&lt;Dcel,Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_786\"></A>\n\n<A NAME=\"Cross_link_anchor_787\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_793\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Planar_map_2<Dcel,Traits>\"></A>\n<h2><I>CGAL::Planar_map_2&lt;Dcel,Traits&gt;</I></h2>\n\n\n<A NAME=\"PM_sec:pm\"></A>\n<P>\n\n<H3>Definition</H3>An object <MATH><I>pm</I></MATH> of the class <I><A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> is the subdivision\nof the planar induced by a set of <MATH><I>x</I></MATH>-monotone curves, such that no\ncurve intersects the interior of any other curve. The available traits\nand dcel classes are described below. <I>Self</I> is an abbreviation\nof the <I><A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> type hereafter.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Planar_map_2.h\">CGAL/Planar_map_2.h</A>&gt;</I>\n<P>\n\n<H3>Inherits From</H3><I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_768\">CGAL::Topological_map</A>&lt;Dcel&gt;</I>\n<P>\n\nThe modifying functions <I>insert_in_face_interior</I>,\n    <I>insert_from_vertex</I>, <I>insert_at_vertices</I>, <I>split_edge</I>,\n    <I>merge_edge</I> and <I>remove_edge</I>\n    overwrite the inherited functions and make use\n    of the geometric information of the planar map.\n<P>\n\n<H3>Types</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;::Traits\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    traits class.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;::Dcel\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    DCEL class.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;::Change_notification\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n\n  The <I>Vertex</I>, <I>Halfedge</I> and <I>Face</I>\n  types of the planar map are defined as part of the planar map DCEL\n  While the face of planar map is a face of the topological map, the\n  Vertex and Halfedge have additional functionality. A Vertex has the\n  additional <I>point</I> and <I>set_point</I> operations. A Halfedge has\n  the additional <I>curve</I> and <I>set_curve</I> operations. \n  \n<!-- REMOVE_LINKS_END -->\n See concepts <I><A HREF=\"Concept_PlanarMapDcel_2.html#Cross_link_anchor_795\">PlanarMapDcel_2</A></I>,\n  <I><A HREF=\"Concept_PlanarMapDcelVertex_2.html#Cross_link_anchor_796\">PlanarMapDcelVertex_2</A></I> \n  and <I><A HREF=\"Concept_PlanarMapDcelHalfedge_2.html#Cross_link_anchor_797\">PlanarMapDcelHalfedge_2</A></I>\n  .\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n\n  \n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Planar_map_2&lt;Dcel,Traits&gt;::Vertex\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    represents a vertex of the planar map.\n<P>\n\n</TD></TR>\n        </TABLE>\n\n<!-- REMOVE_LINKS_END -->\n\n  \n<!-- REMOVE_LINKS_BEGIN -->\n\n  \n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Planar_map_2&lt;Dcel,Traits&gt;::Halfedge\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    represents a halfedge of the topological map.\n<P>\n\n</TD></TR>\n        </TABLE>\n\n<!-- REMOVE_LINKS_END -->\n\n  \n<!-- REMOVE_LINKS_BEGIN -->\n\n  \n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Planar_map_2&lt;Dcel,Traits&gt;::Face\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    represents a face of the topological map.\n<P>\n\n</TD></TR>\n        </TABLE>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_X_monotone_curve_2\"></A>\n<A NAME=\"Typedef_X_monotone_curve_2\"></A>\ntypedef typename Traits::X_monotone_curve_2\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    X_monotone_curve_2;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a curve of the planar map.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Point_2\"></A>\n<A NAME=\"Typedef_Point_2\"></A>\ntypedef typename Traits::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    a point of the planar map.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Constants</H3>\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A NAME=\"Function_Locate_type\"></A>\n<A NAME=\"Enum_Locate_type\"></A>\n<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> <A HREF=\"Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> { </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n    <A HREF=\"Class_Planar_map_2#Enum_Locate_type\">VERTEX</A> = 1<A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Planar_map_2#Enum_Locate_type\">EDGE</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Planar_map_2#Enum_Locate_type\">FACE</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Planar_map_2#Enum_Locate_type\">UNBOUNDED_VERTEX</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Planar_map_2#Enum_Locate_type\">UNBOUNDED_EDGE</A><A NAME=\"Function_Locate_type\"></A>\n,<BR>\n\n<A HREF=\"Class_Planar_map_2#Enum_Locate_type\">UNBOUNDED_FACE</A><A NAME=\"Function_Locate_type\"></A>\n};</TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    an enumeration that specifies the result of <I>point location</I> \n       and <I>ray shooting</I> operations.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt; pm;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    constructs an\n   ``empty map'' containing one unbounded face, which corresponds to the\n   whole plane.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt; pm (  Self pm);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    copy constructor;\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<P>\n\n<H3>Point Location</H3>\n<P>\n\nAs described in the introduction, the planar map users can define\nwhich algorithm to use in the point location queries.  This is done\nby passing an instance of some point location class instance to the map in\nthis constructor. The point location class should be a model of the\n<I><A HREF=\"Concept_PlanarMapPointLocation_2.html#Cross_link_anchor_788\">PlanarMapPointLocation_2</A></I> concept. The randomized trapezoidal\ndecomposition algorithm is the one used by default in our\nimplementation.  However, the users can choose to use the naive or\n``walk'' algorithms (trading time for memory efficiency) or can\nimplement their own point location algorithm. This can be done with a\nclass derived from the <I>Point_location_base&lt;Planar_map&gt;</I>. The concept <I><A HREF=\"Concept_PlanarMapPointLocation_2.html#Cross_link_anchor_788\">PlanarMapPointLocation_2</A></I> lists the set of requirements \n().\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt; pm ( Pm_point_location_base&lt;Self&gt; * pl_ptr);\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Reading Planar map</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_read_6istream___in9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pm.read ( istream &amp; in)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads <I><A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> from the given input stream <I>in</I>. The input\n stream should support the extractor operator (<I>&gt;&gt;</I>) for\n the <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I> and <I>X_monotone_curve_2</I> types of\n <I>Planar_map</I>. Note that the verbose format is not meant to be\n read.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class Scanner&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_read_6istream___in+_Scanner___scanner9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pm.read ( istream &amp; in,  Scanner &amp; scanner)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads <I><A HREF=\"Class_Planar_map_2.html#Cross_link_anchor_787\">Planar_map_2</A>&lt;Dcel,Traits&gt;</I> from the given input stream <I>in</I> using \n<I>scanner</I>. The input stream should support the\nextractor operator (<I>&gt;&gt;</I>) for the <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I> and\n<I>X_monotone_curve_2</I> types of <I>Planar_map</I>\n        </TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Query Functions</H3>\n<P>\n\nThe following two functions are query functions. Their time complexity\ndepends on the point location strategy used.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_locate6const_Point_2___p_+_Locate_type___lt9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pm.locate (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p,  <A HREF=\"Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> &amp; lt)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    \n<!-- REMOVE_LINKS_BEGIN -->\ncomputes the location in <I>pm</I>\n   where  <I>p</I> lies;  \n   If <I>lt</I> returns VERTEX then <I>p</I> lies on the vertex which \n   is the target of the returned <I>Halfedge</I>. If <I>lt</I> returns \n   EDGE then <I>p</I> lies on the returned <I>Halfedge</I>. If \n   <I>lt</I> returns FACE then <I>p</I> lies on the face which is on \n   the left of the returned <I>Halfedge</I> . If <I>lt</I> returns \n   UNBOUNDED_FACE then <I>p</I> lies on the unbounded face, and \n   the returned <I>Halfedge</I> is on the boundary of \n   a hole in the unbounded face.\n   The returned value for an empty map equals <I>halfedges_end()</I>.\n<!-- REMOVE_LINKS_END -->\n\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_vertical_ray_shoot6const_Point_2___p+_Locate_type___lt+_bool_up_direction_9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.vertical_ray_shoot ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p,<BR>\n\n<A HREF=\"Class_Planar_map_2#Enum_Locate_type\">Locate_type</A> &amp; lt,<BR>\n\nbool up_direction)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    if <I>up_direction</I> is <I>true</I> (respectively,\n <I>false</I>) returns the first edge of <I>pm</I> that\n   intersects the upward (respectively, downward) vertical ray emanating\n   from <I>p</I>. If several edges intersect the vertical ray\n   in the same (end)point <MATH><I>q</I></MATH>, the function returns the\n   first halfedge pointing at <MATH><I>q</I></MATH>, that is encountered when moving clockwise \n   from $pq$ around <MATH><I>q</I></MATH> . \n   In that case the value of <I>lt</I> will\n   be <A HREF=\"Class_Planar_map_2#Enum_Locate_type\">VERTEX</A> . If the ray does not intersect any edge, the value \n   of <I>lt</I> \n   will be <A HREF=\"Class_Planar_map_2#Enum_Locate_type\">UNBOUNDED_FACE</A> and the \n  \n<!-- REMOVE_LINKS_BEGIN -->\n<I>Halfedge</I>\n<!-- REMOVE_LINKS_END -->\n returned will be null\n   valued. Otherwise the value of <I>lt</I> will be <A HREF=\"Class_Planar_map_2#Enum_Locate_type\">EDGE</A>.<BR>\n\n<EM>Postcondition: </EM>the returned edge belongs to one of the CCB's of the face\n      in which <I>p</I> is found, null valued if none is \n      found. \n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_point_in_face6const_Point_2___p+_Face_const_handle_f9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pm.is_point_in_face (  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p,  Face_const_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    determines whether the given point <I>p</I> lies within the interior of\n the given face <I>f</I>. A point lies within a face interior, iff the\n number of intersections between the face boundary and a ray emanating\n from the point is even.\n Note that if <I>f</I> is the unbounded face, and it has no holes,\n the point must lie within the face interior.\n <I>is_point_in_face()</I> returns true if <I>p</I> lies within the\n interior of <I>f</I>, and false otherwise.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n    For some applications the users may want to have direct access to\n    the point location strategy (e.g., query the default strategy about\n    the state of its internal search structure). For this we have implemented \n    the following function, note that the returned pointer is <I>const</I> so\n    the users cannot change the internal state.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_const_Pm_point_location_base6Self9*_point_location69;\"></A>\nconst Pm_point_location_base&lt;Self&gt;*\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pm.point_location ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a\n       const pointer to the point location strategy of the map.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Modifiers</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert6const_X_monotone_curve_2___cv+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_monotone_curve_2 cv,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the curve <I>cv</I> into the map. <I>insert()</I> returns \n   a handle to a new halfedge directed in the same way as the curve <I>cv</I>. \n   That is, the curve source and target points coincide with the points of the \n   source and target vertices of the returned halfedge respectively.<BR>\n\n<EM>Precondition: </EM>no curve of <I>pm</I> intersects <I>cv</I> in the \n              interiors of the curve itself and <I>cv</I>.<BR>\n\n<EM>Precondition: </EM><I>cv</I> is not equivalent to a point. \n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;X_curve_iterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert6const_X_curve_iterator___begin+_const_X_curve_iterator___end+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_curve_iterator begin,<BR>\n\nX_curve_iterator end,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    iterates through a given range of curves, inserting the curves into the\n   map. <I>begin</I> and <I>end</I> are input iterators that point to the first\n   curve and past-the-end curve of the range respectively. <I>insert()</I> \n   returns a handle to a new halfedge directed in the same way as the last \n   curve in the range.<BR>\n\n<EM>Precondition: </EM>the curves of <I>pm</I> do not intersect the curves in the \n    given range in the interiors of the curves respectively.<BR>\n\n<EM>Precondition: </EM>no curve in the given range is equivalent to a point. \n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<P>\n\n<H3>Specialized Insertion Functions</H3>\n<P>\n\nThe following functions enable the usage of information about the map which \nwas acquired beforehand, to save time in insertions. It is recommended to use\nthese functions with the naive point location strategy.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert_in_face_interior6const_X_monotone_curve_2___cv+_Face_handle_f+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert_in_face_interior ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_monotone_curve_2 cv,<BR>\n\nFace_handle f,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the curve <I>cv</I> as a new inner component of the face <I>f</I>. \n   <I>insert_in_face_interior()</I> returns a handle to a new halfedge directed\n   in the same way as <I>cv</I>.<BR>\n\n<EM>Precondition: </EM><I>cv</I> is contained completely in the interior of <I>f</I>, (no\n    endpoint of <I>cv</I> coincides with a point of any vertex of the map).<BR>\n\n<EM>Precondition: </EM><I>cv</I> is not equivalent to a point. \n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert_from_vertex6const_X_monotone_curve_2___cv+_Vertex_handle_v+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert_from_vertex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_monotone_curve_2 cv,<BR>\n\nVertex_handle v,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the curve <I>cv</I> into the map. One endpoint of <I>cv</I>\n  is the point of the given vertex <I>v</I>, that is already in the map.\n   <I>insert_from_vertex</I> returns a handle to a new halfedge that has \n   <I>v</I> as its source vertex.<BR>\n\n<EM>Precondition: </EM><I>v</I> is a vertex of the map.<BR>\n\n<EM>Precondition: </EM>the point of <I>v</I> coincides with one endpoint of <I>cv</I>.<BR>\n\n<EM>Precondition: </EM>no vertex of the map has a point that coincides with the other \n    endpoint of <I>cv</I>.<BR>\n\n<EM>Precondition: </EM>no curve of <I>pm</I> intersects <I>cv</I> in the\n    interiors of the curve itself and <I>cv</I>.<BR>\n\n<EM>Precondition: </EM><I>cv</I> is not equivalent to a point. \n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert_at_vertices6const_X_monotone_curve_2___cv+_Vertex_handle_v1+_Vertex_handle_v2+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert_at_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_monotone_curve_2 cv,<BR>\n\nVertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the curve <I>cv</I> into the map. The two endpoints of <I>cv</I> are\n   held by the two given vertices <I>v1</I> and <I>v2</I> respectively, that are\n   already in the map.\n   <I>insert_at_vertices()</I> returns a handle to a new halfedge, that has\n   <I>v1</I> and <I>v2</I> as its source and target vertices respectively.<BR>\n\n<EM>Precondition: </EM><I>v1</I> and <I>v2</I> are vertices of the map.<BR>\n\n<EM>Precondition: </EM>the points of <I>v1</I> and <I>v2</I> coincide with the two \n    endpoints of <I>cv</I> respectively.<BR>\n\n<EM>Precondition: </EM>no curve of <I>pm</I> intersects <I>cv</I> in the\n    interiors of the curve itself and <I>cv</I>.<BR>\n\n<EM>Precondition: </EM><I>cv</I> is not equivalent to a point. \n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert_from_vertex6const_X_monotone_curve_2___cv+_Halfedge_handle_h+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert_from_vertex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_monotone_curve_2 cv,<BR>\n\nHalfedge_handle h,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the curve <I>cv</I> into the map. One endpoint of <I>cv</I> is the \n   point of the target vertex, <I>v</I>, of the given halfedge <I>h</I>.\n   <I>insert_from_vertex</I> returns a handle to a new halfedge that has \n   <I>v</I> as its source vertex. The returened twin halfedge is inserted \n   immediately after <I>h</I> in the circular list of halfedges that share the \n   same target vertex <I>v</I>. This method is the quick version of \n   <I>insert_from_vertex()</I>, as the search for the previous halfedge in the \n   circular list of halfedges that share the same target vertex is \n   unnecessary, saving computation time.<BR>\n\n<EM>Precondition: </EM><I>h</I> is a halfedge of the map.<BR>\n\n<EM>Precondition: </EM>the point of <I>v</I> coincides with one endpoint of <I>cv</I>.<BR>\n\n<EM>Precondition: </EM>no vertex of the map has a point that coincides with the other \n    endpoint of <I>cv</I>.<BR>\n\n<EM>Precondition: </EM>In the clockwise order of curves around the common point\n   of <I>v</I>, <I>cv</I> succeeds the curve of <I>h</I>.<BR>\n\n<EM>Precondition: </EM>no curve of <I>pm</I> intersects <I>cv</I> in the\n    interiors of the curve itself and <I>cv</I>.<BR>\n\n<EM>Precondition: </EM><I>cv</I> is not equivalent to a point. \n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_insert_at_vertices6const_X_monotone_curve_2___cv+_Halfedge_handle_h1+_Halfedge_handle_h2+_Change_notification_*_en_=_NULL9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.insert_at_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     X_monotone_curve_2 cv,<BR>\n\nHalfedge_handle h1,<BR>\n\nHalfedge_handle h2,<BR>\n\nChange_notification * en = NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the curve <I>cv</I> into the map. The two endpoints of <I>cv</I> are\n   held by the two target vertices <I>v1</I> and <I>v2</I> of <I>h1</I> and\n   <I>h2</I> respectively.\n   <I>insert_at_vertices()</I> returns a handle to a new halfedge, that has\n   <I>v1</I> and <I>v2</I> as its source and target vertices respectively.\n   The returened halfedge is inserted immediately after <I>h1</I> in the \n   circular list of halfedges that share the same target vertex <I>v1</I>. Its\n   twin halfedge is inserted immediately after <I>h2</I> in the circular list\n   of halfedges that share the same target vertex <I>v2</I>.\n   This method is the quick version of <I>insert_from_vertex()</I>, as the \n   search for the previous halfedges in the circular lists of halfedges that\n   share the same target vertices is unnecessary, saving computation time.<BR>\n\n<EM>Precondition: </EM><I>h1</I> and <I>h2</I> are halfedges of the map.<BR>\n\n<EM>Precondition: </EM>the points of <I>v1</I> and <I>v2</I> coincide with the two \n    endpoints of <I>cv</I> respectively.<BR>\n\n<EM>Precondition: </EM>In the clockwise order of curves around the common point\n   of <I>v1</I>, <I>cv</I> succeeds the curve of <I>h1</I>.<BR>\n\n<EM>Precondition: </EM>In the clockwise order of curves around the common point\n   of <I>v2</I>, <I>cv</I> succeeds the curve of <I>h2</I>.<BR>\n\n<EM>Precondition: </EM>no curve of <I>pm</I> intersects <I>cv</I> in the\n    interiors of the curve itself and <I>cv</I>.<BR>\n\n<EM>Precondition: </EM><I>cv</I> is not equivalent to a point. \n        </TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_split_edge6Halfedge_handle_e+_const_X_monotone_curve_2___c1+_const_X_monotone_curve_2___c29;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.split_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle e,<BR>\n\nX_monotone_curve_2 c1,<BR>\n\nX_monotone_curve_2 c2)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    splits the edge <I>e</I> into <I>e1</I> and  <I>e2</I> , and\n   add a vertex in the splitting point. If the source point of <I>e</I>\n   is identical to the source of the curve <I>c1</I> then\n   <I>c1</I> abd <I>c2</I> will be assigned to <I>e1</I> and\n   to <I>e2</I> respectively and to their respective twin halfedges. \n   Otherwise, the <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> will take place. The returned halfedge will\n   be <I>e1</I> where <I>e2</I> is <I>e1-&gt;next_halfedge()</I>.<BR>\n\n<EM>Precondition: </EM>the preconditions of \n      <I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;::split_edge</I>.<BR>\n\n<EM>Precondition: </EM>the target of the curve <MATH><I>c1</I></MATH>  is identical to the source of \n      the curve <MATH><I>c2</I></MATH>.<BR>\n\n<EM>Precondition: </EM>the source of the curve <MATH><I>c1</I></MATH>  is identical to the source point \n      of <I>e</I> and the target of the curve <MATH><I>c2</I></MATH> is identical to the\n      target point of <I>e</I>, or \n      the source of the curve <MATH><I>c1</I></MATH>  is identical to the target point \n      of <I>e</I> and the target of the curve <MATH><I>c2</I></MATH> is identical to the\n      source point of <I>e</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Halfedge_handle_merge_edge6Halfedge_handle_e1+_Halfedge_handle_e2+_const_X_monotone_curve_2___cv9;\"></A>\nHalfedge_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    pm.merge_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Halfedge_handle e1,<BR>\n\nHalfedge_handle e2,<BR>\n\nX_monotone_curve_2 cv)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    merges the edges represented by <I>e1</I> and <I>e2</I> into\n   a single edge. The resulting halfedge and its twin hold the curve\n   <I>cv</I>. The return value is the halfedge with the same\n   source vertex that <I>e1</I> had and the same target <I>e2</I> had.<BR>\n\n<EM>Precondition: </EM>the preconditions of \n      <I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;::merge_edge</I>.<BR>\n\n<EM>Precondition: </EM>the source of the curve <MATH><I>cv</I></MATH>  is identical to the source point \n      of <I>e1</I> and the target of the curve <MATH><I>cv</I></MATH> is identical to the\n      target point of <I>e2</I>, or \n      the target of the curve <MATH><I>cv</I></MATH>  is identical to the source point \n      of <I>e1</I> and the source of the curve <MATH><I>cv</I></MATH> is identical to the\n      target point of <I>e2</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_remove_edge6Halfedge_handle_e9;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    pm.remove_edge ( Halfedge_handle e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the edge <I>e</I> from <I>pm</I>.\n   If the operation causes two faces to merge, the merged face is returned.\n   Otherwise, the face to which the edge was incident is returned.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3><I><A HREF=\"../Topological_map_ref/Class_Topological_map.html#Cross_link_anchor_769\">Topological_map</A>&lt;Dcel&gt;</I><BR>\n\n<I><A HREF=\"Concept_PlanarMapDcel_2.html#Cross_link_anchor_795\">PlanarMapDcel_2</A></I>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Concept_PlanarMapPointLocation_2.html\"><I>PlanarMapPointLocation_2</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_20!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 41291.0}