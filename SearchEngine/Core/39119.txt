{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 49Interpolation Julia Fl totto This chapter describes CGAL s interpolation package which implements natural neighbor coordinate functions as well as different methods for scattered data interpolation most of which are based on natural neighbor coordinates The functions for computing natural neighbor coordinates in Euclidean space are described in Section the functions concerning the coordinate and neighbor computation on surfaces are discussed in Section In Section we describe the different interpolation functions Scattered data interpolation solves the following problem given measures of a function on a set of discrete data points the task is to interpolate this function on an arbitrary query point More formally let p1 pn be a set of n points in 2 or 3 and be a scalar function defined inside the convex hull of We assume that the function values are known at the points of i e to each pi we associate zi pi Sometimes the gradient of is also known at pi It is denoted gi pi The interpolation is carried out for an arbitrary query point x Except for interpolation on surfaces x must lie inside the convex hull of 49 1 Natural neighbor coordinates 49 1 1 Introduction Natural neighbor interpolation has been introduced by Sibson Sib81 to interpolate multivariate scattered data Given a set of data points the natural neighbor coordinates associated to are defined from the Voronoi diagram of When simulating the insertion of a query point x into the Voronoi diagram of the potential Voronoi cell of x steals some parts from the existing cells Figure 2D example x has five natural neighbors p1 p5 The natural neighbor coordinate 3 x is the ratio of the area of the pink polygon 3 x over the area of the total highlighted zone Let x denote the volume of the potential Voronoi cell of x and i x denote the volume of the sub cell that would be stolen from the cell of pi by the cell of x The natural neighbor coordinate of x with respect to the data point pi is defined by i x i x x A two dimensional example is depicted in Figure Various papers Sib8 Far9 Pip93 Bro97 HS show that the natural neighbor coordinates have the following properties i x i 1n i x pi barycentric coordinate property ii For any i j n i pj ij where ij is the Kronecker symbol iii i 1n i x 1 partition of unity property Furthermore Piper Pip93 shows that the coordinate functions are continuous in the convex hull of and continuously differentiable except on the data points The interpolation package of CGAL provides functions to compute natural neighbor coordinates for 2D and 3D points with respect to Voronoi diagrams as well as with respect to power diagrams only 2D i e for weighted points Refer to the reference pages natural neighbor coordinates 2 natural neighbor coordinates 3 and regular neighbor coordinates 2 In addition the package provides functions to compute natural neighbor coordinates on well sampled point set surfaces See Section and the reference page surface neighbor coordinates 3 for further information 49 1 2 Implementation Given a Delaunay triangulation or a Regular triangulation the vertices in conflict with the query point are determined The area i x are computed by triangulating the Voronoi sub cells The normalization factor x is also returned If the query point is already located and or the boundary edges of the conflict zone are already determined alternative functions allow to avoid the re computation 49 1 3 Example The signature of all coordinate computation functions is about the same file examples Interpolation nn coordinates 2 C include CGAL basic h include utility include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 2 h include CGAL natural neighbor coordinates 2 h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Delaunay triangulation 2 K Delaunay triangulation typedef std vector std pair K Point 2 K FT Point coordinate vector int main Delaunay triangulation dt for int y y 3 y for int x x 3 x dt insert K Point 2 x y coordinate computation K Point 2 p 1 2 7 Point coordinate vector coords CGAL Triple std back insert iterator Point coordinate vector K FT bool result CGAL natural neighbor coordinates 2 dt p std back inserter coords if result third std cout The coordinate computation was not successful std endl std cout The point p lies outside the convex hull std endl K FT norm result second std cout Coordinate computation successful std endl std cout Normalization factor norm std endl return Regular neighbor coordinate computation For regular neighbor coordinates it is sufficient to replace the name of the function and the type of triangulation passed as parameter A special traits class is needed file examples Interpolation rn coordinates 2 C include CGAL basic h include utility include CGAL Exact predicates inexact constructions kernel h include CGAL Regular triangulation 2 h include CGAL Regular triangulation euclidean traits 2 h include CGAL regular neighbor coordinates 2 h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Regular triangulation euclidean traits 2 K Gt typedef CGAL Regular triangulation 2 Gt Regular triangulation typedef Regular triangulation Weighted point Weighted point typedef std vector std pair Weighted point K FT Point coordinate vector int main Regular triangulation rt for int y y 3 y for int x x 3 x rt insert Weighted point K Point 2 x y coordinate computation Weighted point wp K Point 2 1 2 7 2 Point coordinate vector coords CGAL Triple std back insert iterator Point coordinate vector K FT bool result CGAL regular neighbor coordinates 2 rt wp std back inserter coords if result third std cout The coordinate computation was not successful std endl std cout The point wp point lies outside the convex hull std endl K FT norm result second std cout Coordinate computation successful std endl std cout Normalization factor norm std endl return For surface neighbor coordinates the surface normal at the query point must be provided see Section 49 2 Surface natural neighbor coordinates and surface neighbors This section introduces the functions to compute natural neighbor coordinates and surface neighbors associated to a set of sample points issued from a surface and given a query point x on We suppose that is a closed and compact surface of 3 and let p1 pn be an sample of refer to Amenta and Bern AB99 The concepts are based on the definition of Boissonnat and Fl totto BF 2 Fl 3 Both references contain a thorough description of the requirements and the mathematical properties 49 2 1 Introduction Two observations lead to the definition of surface neighbors and surface neighbor coordinates First it is clear that the tangent plane x of the surface at the point x approximates in the neighborhood of x It has been shown in BF 2 that if the surface is well sampled with respect to the curvature and the local thickness of i e it is an sample the intersection of the tangent plane x with the Voronoi cell of x in the Voronoi diagram of x has a small diameter Consequently inside this Voronoi cell the tangent plane x is a reasonable approximation of Furthermore the second observation allows to compute this intersection diagram easily one can show using Pythagoras theorem that the intersection of a three dimensional Voronoi diagram with a plane is a two dimensional power diagram The points defining the power diagram are the projections of the points in onto each point weighted with its negative square distance to Algorithms for the computation of power diagrams via the dual regular triangulation are well known and for example provided by CGAL in the class Regular triangulation 2 Gt Tds 49 2 2 Implementation Voronoi intersection diagrams In CGAL the regular triangulation dual to the intersection of a 3D Voronoi diagram with a plane can be computed by instantiating the Regular triangulation 2 Gt Tds class with the traits class Voronoi intersection 2 traits 3 K This traits class contains a point and a vector as class member which define the plane All predicates and constructions used by Regular triangulation 2 Gt Tds are replaced by the corresponding operators on three dimensional points For example the power test predicate which takes three weighted 2D points p q r of the regular triangulation and tests the power distance of a fourth point t with respect to the power circle orthogonal to p q r is replaced by a Side of plane centered sphere 2 3 predicate that tests the position of a 3D point t with respect to the sphere centered on the plane passing through the 3D points p q r This approach allows to avoid the explicit constructions of the projected points and the weights which are very prone to rounding errors Natural neighbor coordinates on surfaces The computation of natural neighbor coordinates on surfaces is based upon the computation of regular neighbor coordinates with respect to the regular triangulation that is dual to Vor x the intersection of x and the Voronoi diagram of via the function regular neighbor coordinates 2 Of course we might introduce all data points into this regular triangulation However this is not necessary because we are only interested in the cell of x It is sufficient to guarantee that all surface neighbors of the query point x are among the input points that are passed as argument to the function The sample points can be filtered for example by distance e g using range search or k nearest neighbor queries or with the help of the 3D Delaunay triangulation since the surface neighbors are necessarily a subset of the natural neighbors of the query point in this triangulation CGAL provides a function that encapsulates the filtering based on the 3D Delaunay triangulation For input points filtered by distance functions are provided that indicate whether or not points that lie outside the input range i e points that are further from x than the furthest input point can still influence the result This allows to iteratively enlarge the set of input points until the range is sufficient to certify the result Surface neighbors The surface neighbors of the query point are its neighbors in the regular triangulation that is dual to Vor x the intersection of x and the Voronoi diagram of As for surface neighbor coordinates this regular triangulation is computed and the same kind of filtering of the data points as well as the certification described above is provided 49 2 3 Examples file examples Interpolation surface neighbor coordinates 3 C example with random points on a sphere include CGAL basic h include utility include CGAL Exact predicates inexact constructions kernel h include CGAL point generators 3 h include CGAL copy n h include CGAL Origin h include CGAL surface neighbor coordinates 3 h struct K CGAL Exact predicates inexact constructions kernel typedef K FT Coord type typedef K Point 3 Point 3 typedef K Vector 3 Vector 3 typedef std vector std pair Point 3 K FT Point coordinate vector int main int n 1 std vector Point 3 points points reserve n std cout Generate n random points on a sphere std endl CGAL Random points on sphere 3 Point 3 g 1 CGAL copy n g n std back inserter points Point 3 p 1 Vector 3 normal p CGAL ORIGIN std cout Compute surface neighbor coordinates for p std endl Point coordinate vector coords CGAL Triple std back insert iterator Point coordinate vector K FT bool result CGAL surface neighbor coordinates 3 points begin points end p normal std back inserter coords K if result third Undersampling std cout The coordinate computation was not successful std endl return K FT norm result second std cout Testing the barycentric property std endl Point 3 b for std vector std pair Point 3 Coord type const iterator it coords begin it coords end it b b it second norm it first CGAL ORIGIN std cout weighted barycenter b std endl std cout squared distance CGAL squared distance p b std endl return 49 3 Interpolation methods 49 3 1 Introduction Linear precision interpolation Sibson Sib81 defines a very simple interpolant that re produces linear functions exactly The interpolation of x is given as the linear combination of the neighbors function values weighted by the coordinates Z x i i x zi Indeed if zi a bt pi for all natural neighbors of x we have Z x i i x a btpi a bt x by the barycentric coordinate property The first example in Subsection shows how the function is called Sibson s C1 continuous interpolant In Sib81 Sibson describes a second interpolation method that relies also on the function gradient gi for all pi It is C1 continuous with gradient gi at pi Spherical quadrics of the form x a bt x xtx are reproduced exactly The proof relies on the barycentric coordinate property of the natural neighbor coordinates and assumes that the gradient of at the data points is known or approximated from the function values as described in Sib81 see Section Sibson s Z1 interpolant is a combination of the linear interpolant Z and an interpolant which is the weighted sum of the first degree functions i x zi git x pi x i i x x pi i x i i x x pi Sibson observed that the combination of Z and reconstructs exactly a spherical quadric if they are mixed as follows Z1 x x Z x x x x x where x i i x x pi 2 f x pi i i x f x pi and x i i x x pi 2 where in Sibson s original work f x pi x pi CGAL contains a second implementation with f x pi x pi 2 which is less demanding on the number type because it avoids the square root computation needed to compute the distance x pi The theoretical guarantees are the same see Fl 3 Simply the smaller the slope of f around f the faster the interpolant approaches i as x pi Farin s C1 continuous interpolant Farin Far9 extended Sibson s work and realizes a C1 continuous interpolant by embedding natural neighbor coordinates in the Bernstein B zier representation of a cubic simplex If the gradient of at the data points is known this interpolant reproduces quadratic functions exactly The function gradient can be approximated from the function values by Sibson s method Sib81 see Section which is exact only for spherical quadrics Quadratic precision interpolants Knowing the gradient gi for all pi we formulate a very simple interpolant that reproduces exactly quadratic functions This interpolant is not C1 continuous in general It is defined as follows I1 x i i x zi 1 2 git x pi 49 3 2 Gradient fitting Sibson describes a method to approximate the gradient of the function f from the function values on the data sites For the data point pi we determine gi ming j j pi pi pj 2 zj zi gt pj pi where j pi is the natural neighbor coordinate of pi with respect to pi associated to pi This method works only for points inside the convex hull of the data points because for a point pi on the convex hull j pi is not defined For spherical quadrics the result is exact CGAL provides functions to approximate the gradients of all data points that are inside the convex hull There is one function for each type of natural neighbor coordinate i e natural neighbor coordinates 2 regular neighbor coordinates 2 49 3 3 Examples Linear interpolation method file examples Interpolation linear interoplation 2 C include CGAL basic h include utility include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 2 h include CGAL Interpolation traits 2 h include CGAL natural neighbor coordinates 2 h include CGAL interpolation functions h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Delaunay triangulation 2 K Delaunay triangulation typedef CGAL Interpolation traits 2 K Traits typedef K FT Coord type typedef K Point 2 Point int main Delaunay triangulation T std map Point Coord type K Less xy 2 function values typedef CGAL Data access std map Point Coord type K Less xy 2 Value access Coord type a 25 bx 1 3 by 7 for int y y 3 y for int x x 3 x K Point 2 p x y T insert p function values insert std make pair p a bx x by y coordinate computation K Point 2 p 1 3 34 std vector std pair Point Coord type coords Coord type norm CGAL natural neighbor coordinates 2 T p std back inserter coords second Coord type res CGAL linear interpolation coords begin coords end norm Value access function values std cout Tested interpolation on p interpolation res exact a bx p x by p y std endl return Sibson s C1 interpolation scheme with gradient estimation file examples Interpolation sibson interpolation 2 C include CGAL basic h include utility include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 2 h include CGAL natural neighbor coordinates 2 h include CGAL Interpolation gradient fitting traits 2 h include CGAL sibson gradient fitting h include CGAL interpolation functions h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Delaunay triangulation 2 K Delaunay triangulation typedef CGAL Interpolation gradient fitting traits 2 K Traits typedef K FT Coord type typedef K Point 2 Point typedef std map Point Coord type K Less xy 2 Point value map typedef std map Point K Vector 2 K Less xy 2 Point vector map int main Delaunay triangulation T Point value map function values Point vector map function gradients parameters for spherical function Coord type a 25 bx 1 3 by 7 c 2 for int y y 4 y for int x x 4 x K Point 2 p x y T insert p function values insert std make pair p a bx x by y c x x y y sibson gradient fitting nn 2 T std inserter function gradients function gradients begin CGAL Data access Point value map function values Traits coordiante computation K Point 2 p 1 6 1 4 std vector std pair Point Coord type coords Coord type norm CGAL natural neighbor coordinates 2 T p std back inserter coords second Sibson interpolant version without sqrt std pair Coord type bool res CGAL sibson c1 interpolation square coords begin coords end norm p CGAL Data access Point value map function values CGAL Data access Point vector map function gradients Traits if res second std cout Tested interpolation on p interpolation res first exact a bx p x by p y c p x p x p y p y std endl else std cout C 1 Interpolation not successful std endl not all function gradients are provided std endl You may resort to linear interpolation std endl return An additional example compares numerically the errors of the different interpolation functions with respect to a known function It is distributed in the examples directory Next chapter Interpolation Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Interpolation/Chapter_main.html", "title": "interpolation", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Interpolation/main.tex' -->\n<html> <head>  \n<title>Interpolation</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_49\"></a>\n  \n<h1>Chapter 49<BR>Interpolation</h1>\n\n<A NAME=\"chap:interpolation\"></A>\n<P>\n\n<EM>Julia Fl&ouml;totto</EM><BR>\n\n\n<P>\n\nThis chapter describes C<SMALL>GAL</SMALL>'s interpolation package which implements\nnatural neighbor coordinate functions as well as different\nmethods for scattered data interpolation most of which are based on\nnatural neighbor coordinates. The functions for computing natural neighbor \ncoordinates in Euclidean space are described in \nSection&nbsp;<A HREF=\"Chapter_main.html#sec:coordinates\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, \nthe functions concerning the coordinate and neighbor \ncomputation on surfaces are discussed in Section&nbsp;<A HREF=\"Chapter_main.html#sec:surface\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. \nIn Section&nbsp;<A HREF=\"Chapter_main.html#sec:interpolation\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, we describe the different interpolation \nfunctions.\n<P>\n\nScattered data interpolation solves the following problem: given\nmeasures of a function on a set of discrete data points, the task is\nto interpolate this function on an arbitrary query point.\nMore formally, let <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\">={<B>p<SUB>1</SUB></B>,...,<B>p<SUB>n</SUB></B>}</I></MATH> be a set of\n<MATH><I>n</I></MATH> points in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>2</SUP></I></MATH> or <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH> and <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\"></I></MATH> be a scalar\nfunction defined inside the convex hull of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>. We assume that\nthe function values are known at the points of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>, i.e. to\neach <MATH><I><B>p<SUB>i</SUB></B>  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> <IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>, we associate <MATH><I>z<SUB>i</SUB> =\n<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\">(<B>p<SUB>i</SUB></B>)</I></MATH>. Sometimes, the gradient of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\"></I></MATH> is also known\nat <MATH><I><B>p<SUB>i</SUB></B></I></MATH>. It is denoted <MATH><I><B>g<SUB>i</SUB></B>=  <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_nabla.gif\"> <IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\">(<B>p<SUB>i</SUB></B>)</I></MATH>. The interpolation is carried out for an arbitrary query point\n<MATH><I><B>x</B></I></MATH>. Except for interpolation on surfaces, <MATH><I><B>x</B></I></MATH> must lie \ninside the convex hull of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>.\n\n<a name=\"Section_1\"></a>\n        \n<h2>49.1&nbsp;&nbsp;&nbsp;Natural neighbor coordinates</h2>\n<A NAME=\"sec:coordinates\"></A>\n\n<h3>49.1.1&nbsp;&nbsp;&nbsp;Introduction</h3>\n\nNatural neighbor interpolation has been introduced by Sibson\n[<A HREF=\"../biblio.html#Biblio_s-bdnni-81\">Sib81</A>] to interpolate multivariate scattered data.  Given\na set of data points <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>, the natural neighbor coordinates\nassociated to <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH> are defined from the Voronoi diagram of\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>.  When simulating the insertion of a query point\n<MATH><I><B>x</B></I></MATH> into the Voronoi diagram of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>, the potential\nVoronoi cell of <MATH><I><B>x</B></I></MATH> ``steals'' some parts from the existing\ncells.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B><MATH><I>2D</I></MATH> example: <MATH><I><B>x</B></I></MATH> has five natural neighbors \n  <MATH><I><B>p<SUB>1</SUB></B>,..., <B>p<SUB>5</SUB></B></I></MATH>. \n  The natural neighbor coordinate <MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>3</SUB>(<B>x</B>)</I></MATH> is the ratio\n  of the <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A> of the pink polygon, <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\"><SUB>3</SUB>(<B>x</B>)</I></MATH>, over the <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A>\n  of the total highlighted zone.\n  <A NAME=\"fig:nn_coords\"></A>\n\n<img border=0 src=\"./nn_coords.gif\"  align=center  alt=\"nn_coords\">\n<P>\n\nLet <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\">(<B>x</B>)</I></MATH> denote the <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> of the potential Voronoi cell\nof <MATH><I><B>x</B></I></MATH> and <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\"><SUB>i</SUB>(<B>x</B>)</I></MATH> denote the <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> of the\nsub-cell that would be stolen from the cell of <MATH><I><B>p<SUB>i</SUB></B></I></MATH> by the\ncell of <MATH><I><B>x</B></I></MATH>.  The natural neighbor coordinate of <MATH><I><B>x</B></I></MATH>\nwith respect to the data point <MATH><I><B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> <IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH> is defined by\n<P ALIGN=CENTER>\n<MATH><I>\n<IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) =\n(<IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\"><SUB>i</SUB>(<B>x</B>))/(<IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\">(<B>x</B>)).</I></MATH>\n<P>\n\nA two-dimensional example\nis depicted in Figure <A HREF=\"Chapter_main.html#fig:nn_coords\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nVarious papers ([<A HREF=\"../biblio.html#Biblio_s-vidt-80\">Sib80</A>], [<A HREF=\"../biblio.html#Biblio_f-sodt-90\">Far90</A>],\n[<A HREF=\"../biblio.html#Biblio_cgal:p-plcbd-93\">Pip93</A>], [<A HREF=\"../biblio.html#Biblio_b-scaps-97\">Bro97</A>],[<A HREF=\"../biblio.html#Biblio_hs-vbihc-00\">HS00</A>]) show that\nthe natural neighbor coordinates have the following properties:\n  <UL>\n  <DT><B>(i)</B><DD> <MATH><I><B>x</B> =  <IMG BORDER=0 WIDTH=13 HEIGHT=24 ALIGN=MIDDLE SRC=\"cc_sum.gif\"> <SUB>i=1</SUB><SUP>n</SUP> <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) <B>p<SUB>i</SUB></B></I></MATH>\n    (barycentric coordinate property).\n  <DT><B>(ii)</B><DD> For any <MATH><I>i,j  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> n, <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>p<SUB>j</SUB></B>)=\n    <IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\"><SUB>ij</SUB></I></MATH>, where <MATH><I><IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\"><SUB>ij</SUB></I></MATH> is the Kronecker symbol.\n  <DT><B>(iii)</B><DD> <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=24 ALIGN=MIDDLE SRC=\"cc_sum.gif\"> <SUB>i=1</SUB><SUP>n</SUP> <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) = 1</I></MATH> (partition of unity\n    property).\n  </UL>\n  Furthermore, Piper [<A HREF=\"../biblio.html#Biblio_cgal:p-plcbd-93\">Pip93</A>] shows that the coordinate\n  functions are continuous in the convex hull of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH> and\n  continuously differentiable except on the data points <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>.<BR>\n\n<BR>\n\n\n<P>\n\nThe interpolation package of C<SMALL>GAL</SMALL> provides functions to compute\n  natural neighbor coordinates for <MATH><I>2D</I></MATH> and <MATH><I>3D</I></MATH> points with respect\n  to Voronoi diagrams as well as with respect to power diagrams (only\n  <MATH><I>2D</I></MATH>), i.e. for weighted points. Refer to the reference pages\n  <I><A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1124\">natural_neighbor_coordinates_2</A></I>,\n  <I>natural_neighbor_coordinates_3</I> and\n  <I><A HREF=\"../Interpolation_ref/Function_regular_neighbor_coordinates_2.html#Cross_link_anchor_1126\">regular_neighbor_coordinates_2</A></I>.\n<P>\n\nIn addition, the package provides functions to compute natural\n  neighbor coordinates on well sampled point set surfaces. See\n  Section&nbsp;<A HREF=\"Chapter_main.html#sec:surface\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and the reference page\n  <I><A HREF=\"../Interpolation_ref/Function_surface_neighbor_coordinates_3.html#Cross_link_anchor_1135\">surface_neighbor_coordinates_3</A></I> for further information.\n<P>\n\n<h3>49.1.2&nbsp;&nbsp;&nbsp;Implementation</h3>\n\nGiven a Delaunay triangulation or a Regular triangulation, the\nvertices in conflict with the query point are determined. The <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A>\n<MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\"><SUB>i</SUB>(<B>x</B>)</I></MATH> are computed by triangulating the Voronoi\nsub-cells.  The normalization factor <MATH><I><IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\">(<B>x</B>)</I></MATH> is also\nreturned. If the query point is already located and/or the boundary\nedges of the conflict zone are already determined, alternative\nfunctions allow to avoid the re-computation.\n<P>\n\n<h3>49.1.3&nbsp;&nbsp;&nbsp;Example</h3>\n\nThe signature of all coordinate computation functions is about the\nsame.\n<pre class=\"ExampleCode\">//\n//file: examples/Interpolation/nn_coordinates_2.C \n//\n#include &lt;CGAL/basic.h&gt;\n#include &lt;utility&gt;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1124\">natural_neighbor_coordinates_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;K&gt;             Delaunay_triangulation;\ntypedef std::vector&lt; std::pair&lt; K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>, K::FT  &gt; &gt;\n                                                      Point_coordinate_vector;\n\nint main()\n{\n  Delaunay_triangulation dt;\n  \n  for (int y=0 ; y&lt;3 ; y++)\n    for (int x=0 ; x&lt;3 ; x++) \n      dt.insert(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(x,y));\n   \n  //coordinate computation\n  K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(1.2, 0.7);\n  Point_coordinate_vector coords;\n  <A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1583\">CGAL::Triple</A>&lt;\n    std::back_insert_iterator&lt;Point_coordinate_vector&gt;, \n    K::FT, bool&gt; result = \n    <A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1123\">CGAL::natural_neighbor_coordinates_2</A>(dt, p,\n\t\t\t\t\t std::back_inserter(coords));\n  if(!result.third){\n    std::cout &lt;&lt; &quot;The coordinate computation was not successful.&quot; \n\t      &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;The point (&quot; &lt;&lt;p &lt;&lt; &quot;) lies outside the convex hull.&quot;\n\t      &lt;&lt; std::endl;\n  }\n  K::FT  norm = result.second;\n  std::cout &lt;&lt; &quot;Coordinate computation successful.&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Normalization factor: &quot; &lt;&lt;norm &lt;&lt; std::endl; \n  \n  return 0; \n}\n</pre>\n\n<h4>Regular neighbor coordinate computation</h4>\n\nFor regular neighbor coordinates, it is sufficient to replace the name\nof the function and the type of triangulation passed as parameter. A\nspecial traits class is needed.\n<pre class=\"ExampleCode\">//\n//file: examples/Interpolation/rn_coordinates_2.C \n//\n#include &lt;CGAL/basic.h&gt;\n#include &lt;utility&gt;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_euclidean_traits_2.html#Cross_link_anchor_929\">Regular_triangulation_euclidean_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Function_regular_neighbor_coordinates_2.html#Cross_link_anchor_1126\">regular_neighbor_coordinates_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_euclidean_traits_2.html#Cross_link_anchor_928\">CGAL::Regular_triangulation_euclidean_traits_2</A>&lt;K&gt; Gt;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_926\">CGAL::Regular_triangulation_2</A>&lt;Gt&gt;              Regular_triangulation;\ntypedef Regular_triangulation::<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>;\ntypedef std::vector&lt; std::pair&lt; <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>, K::FT  &gt; &gt;\n                                                       Point_coordinate_vector;\n\nint main()\n{\n  Regular_triangulation rt;\n  \n  for (int y=0 ; y&lt;3 ; y++)\n    for (int x=0 ; x&lt;3 ; x++) \n      rt.insert(<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A>(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(x,y), 0));\n   \n  //coordinate computation\n  <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> wp(K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>(1.2, 0.7),2);\n  Point_coordinate_vector  coords;\n  <A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1583\">CGAL::Triple</A>&lt;\n    std::back_insert_iterator&lt;Point_coordinate_vector&gt;, \n    K::FT, bool&gt; result = \n    <A HREF=\"../Interpolation_ref/Function_regular_neighbor_coordinates_2.html#Cross_link_anchor_1125\">CGAL::regular_neighbor_coordinates_2</A>(rt, wp,\n\t\t\t\t\t std::back_inserter(coords));\n  if(!result.third){\n    std::cout &lt;&lt; &quot;The coordinate computation was not successful.&quot; \n\t      &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;The point (&quot; &lt;&lt;wp.point() &lt;&lt; &quot;) lies outside the convex hull.&quot;\n\t      &lt;&lt; std::endl;\n  } \n  K::FT  norm = result.second;\n  std::cout &lt;&lt; &quot;Coordinate computation successful.&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Normalization factor: &quot; &lt;&lt;norm &lt;&lt; std::endl; \n  \n  return 0; \n}\n</pre>\nFor surface neighbor coordinates, the surface normal at the query\npoint must be provided, see Section&nbsp;<A HREF=\"Chapter_main.html#sec:surface\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n\n<a name=\"Section_2\"></a>\n        \n<h2>49.2&nbsp;&nbsp;&nbsp;Surface natural neighbor coordinates and surface neighbors</h2>\n<A NAME=\"sec:surface\"></A>\n<P>\n\nThis section introduces the functions to compute natural neighbor\ncoordinates and surface neighbors associated to a set of sample points\nissued from a surface <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> and given a query point\n<MATH><I><B>x</B></I></MATH> on <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH>. We suppose that <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> is a\nclosed and compact surface of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>, and let <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\">=\n{<B>p<SUB>1</SUB></B>, ...,<B>p<SUB>n</SUB></B>}</I></MATH> be an <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>-sample of\n<MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> (refer to Amenta and Bern [<A HREF=\"../biblio.html#Biblio_ab-srvf-99\">AB99</A>]). The\nconcepts are based on the definition of Boissonnat and Fl&ouml;totto\n[<A HREF=\"../biblio.html#Biblio_bf-lcss-02\">BF02</A>], [<A HREF=\"../biblio.html#Biblio_cgal:f-csapc-03\">Fl&ouml;03</A>].  Both references\ncontain a thorough description of the requirements and the\nmathematical properties.\n<P>\n\n<h3>49.2.1&nbsp;&nbsp;&nbsp;Introduction</h3>\n<P>\n\nTwo observations lead to the definition of surface neighbors and\nsurface neighbor coordinates: First, it is clear that the tangent\nplane <MATH><I><IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH> of the surface <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> at the point\n<MATH><I><B>x</B>  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> <IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> approximates <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> in the\nneighborhood of <MATH><I><B>x</B></I></MATH>. It has been shown in [<A HREF=\"../biblio.html#Biblio_bf-lcss-02\">BF02</A>]\nthat, if the surface <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> is well sampled with respect to the\ncurvature and the local thickness of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH>, i.e. it is an <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>-sample, the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\nof the tangent plane <MATH><I><IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH> with the Voronoi cell of\n<MATH><I><B>x</B></I></MATH> in the Voronoi diagram of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\">  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cup.gif\"> {<B>x</B>}</I></MATH> has a small diameter.  Consequently, inside this\nVoronoi cell, the tangent plane <MATH><I><IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH> is a reasonable\napproximation of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH>. Furthermore, the second observation\nallows to compute this <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> diagram easily: one can show using\nPythagoras' theorem that the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of a three-dimensional\nVoronoi diagram with a plane <MATH><I><IMG BORDER=0 WIDTH=13 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_H.gif\"></I></MATH> is a two-dimensional power\ndiagram. The points defining the power diagram are the projections of\nthe points in <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH> onto <MATH><I><IMG BORDER=0 WIDTH=13 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_H.gif\"></I></MATH>, each point weighted\nwith its negative <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> distance to <MATH><I><IMG BORDER=0 WIDTH=13 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_H.gif\"></I></MATH>. Algorithms for the\ncomputation of power diagrams via the dual regular triangulation are\nwell known and for example provided by C<SMALL>GAL</SMALL> in the class\n<I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Gt, Tds&gt;</I>.\n<P>\n\n<h3>49.2.2&nbsp;&nbsp;&nbsp;Implementation</h3>\n\n\n<h4>Voronoi intersection diagrams</h4>\n<P>\n\nIn C<SMALL>GAL</SMALL>, the regular triangulation dual to the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of a <MATH><I>3D</I></MATH>\nVoronoi diagram with a plane <MATH><I><IMG BORDER=0 WIDTH=13 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_H.gif\"></I></MATH> can be computed by\ninstantiating the <I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Gt, Tds&gt;</I> class with\nthe traits class <I><A HREF=\"../Interpolation_ref/Class_Voronoi_intersection_2_traits_3.html#Cross_link_anchor_1133\">Voronoi_intersection_2_traits_3</A>&lt;K&gt;</I>. This traits\nclass contains a point and a vector as class member which define the\nplane <MATH><I><IMG BORDER=0 WIDTH=13 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_H.gif\"></I></MATH>. All predicates and constructions used by\n<I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Gt, Tds&gt;</I> are replaced by the\ncorresponding operators on three-dimensional points. For example, the\npower test predicate (which takes three weighted <MATH><I>2D</I></MATH> points\n<MATH><I>p'</I></MATH>, <MATH><I>q'</I></MATH>, <MATH><I>r'</I></MATH> of the regular triangulation and tests the power\ndistance of a fourth point <MATH><I>t'</I></MATH> with respect to the power circle orthogonal\nto <MATH><I>p</I></MATH>, <MATH><I>q</I></MATH>, <MATH><I>r</I></MATH>) is replaced by a\n<I>Side_of_plane_centered_sphere_2_3</I> predicate that tests the\nposition of a <MATH><I>3D</I></MATH> point <MATH><I>t</I></MATH> with respect to the sphere centered on\nthe plane <MATH><I><IMG BORDER=0 WIDTH=13 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_H.gif\"></I></MATH> passing through the <MATH><I>3D</I></MATH> points <MATH><I>p</I></MATH>, <MATH><I>q</I></MATH>, <MATH><I>r</I></MATH>.\nThis approach allows to avoid the explicit constructions of the\nprojected points and the weights which are very prone to rounding\nerrors.\n<P>\n\n<h4>Natural neighbor coordinates on surfaces</h4>\n<P>\n\nThe computation of natural neighbor coordinates on surfaces is based\nupon the computation of regular neighbor coordinates with respect to\nthe regular triangulation that is dual to <MATH><I>Vor(<IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\">)  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cap.gif\"> <IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH>, the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of <MATH><I><IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH> and the Voronoi\ndiagram of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>, via the function\n<I><A HREF=\"../Interpolation_ref/Function_regular_neighbor_coordinates_2.html#Cross_link_anchor_1126\">regular_neighbor_coordinates_2</A></I>.\n<P>\n\nOf course, we might introduce all data points <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH> into this\nregular triangulation. However, this is not necessary because we are\nonly interested in the cell of <MATH><I><B>x</B></I></MATH>. It is sufficient to\nguarantee that all surface neighbors of the query point <MATH><I><B>x</B></I></MATH>\nare among the input points that are passed as argument to the\nfunction. The sample points <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH> can be filtered for example\nby distance, e.g. using range search or <MATH><I>k</I></MATH>-nearest neighbor queries,\nor with the help of the <MATH><I>3D</I></MATH> Delaunay triangulation since the surface\nneighbors are necessarily a subset of the natural neighbors of the\nquery point in this triangulation. C<SMALL>GAL</SMALL> provides a function that\nencapsulates the filtering based on the <MATH><I>3D</I></MATH> Delaunay triangulation.\nFor input points filtered by distance, functions are provided that\nindicate whether or not points that lie outside the input range (i.e. \npoints that are further from <MATH><I><B>x</B></I></MATH> than the furthest input\npoint) can still influence the result.  This allows to iteratively\nenlarge the set of input points until the range is sufficient to\ncertify the result.\n<P>\n\n<h4>Surface neighbors</h4>\n<P>\n\nThe surface neighbors of the query point are its neighbors in the\nregular triangulation that is dual to <MATH><I>Vor(<IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\">)  <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC=\"cc_cap.gif\"> <IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH>, the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of <MATH><I><IMG BORDER=0 WIDTH=15 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_T.gif\"><SUB>x</SUB></I></MATH> and the Voronoi\ndiagram of <MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>. As for surface neighbor coordinates, this\nregular triangulation is computed and the same kind of filtering of\nthe data points as well as the certification described above is\nprovided.\n<P>\n\n<h3>49.2.3&nbsp;&nbsp;&nbsp;Examples</h3>\n\n<pre class=\"ExampleCode\">//file: examples/Interpolation/<A HREF=\"../Interpolation_ref/Function_surface_neighbor_coordinates_3.html#Cross_link_anchor_1135\">surface_neighbor_coordinates_3</A>.C \n// example with random points on a sphere\n#include &lt;CGAL/basic.h&gt;\n#include &lt;utility&gt;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n\n#include &lt;CGAL/point_generators_3.h&gt; \n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Origin.html#Cross_link_anchor_139\">Origin</A>.h&gt;\n\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Function_surface_neighbor_coordinates_3.html#Cross_link_anchor_1135\">surface_neighbor_coordinates_3</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef K::FT                      Coord_type;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>                 <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>                <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>;\ntypedef std::vector&lt; std::pair&lt; <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>, K::FT  &gt; &gt;\n                                   Point_coordinate_vector;\n\nint main()\n{\n \n  int n=100;\n  std::vector&lt; <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt; points;\n  points.reserve(n);\n  \n  std::cout &lt;&lt; &quot;Generate &quot; &lt;&lt; n &lt;&lt; &quot; random points on a sphere.&quot; \n\t    &lt;&lt; std::endl; \n  <A HREF=\"../Generator_ref/Class_Random_points_on_sphere_3.html#Cross_link_anchor_1705\">CGAL::Random_points_on_sphere_3</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt; g(1);\n  <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( g, n, std::back_inserter(points));\n  \n  <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p(1, 0,0);\n  <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A> normal(p-<A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A>);\n  std::cout &lt;&lt; &quot;Compute surface neighbor coordinates for &quot; \n\t    &lt;&lt; p &lt;&lt; std::endl;\n  Point_coordinate_vector coords;\n  <A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1583\">CGAL::Triple</A>&lt; std::back_insert_iterator&lt;Point_coordinate_vector&gt;, \n    K::FT, bool&gt; result = \n    <A HREF=\"../Interpolation_ref/Function_surface_neighbor_coordinates_3.html#Cross_link_anchor_1134\">CGAL::surface_neighbor_coordinates_3</A>(points.begin(), points.end(), \n\t\t\t\t\t p, normal,\n\t\t\t\t\t std::back_inserter(coords), \n\t\t\t\t\t K());\n  if(!result.third){\n    //Undersampling:\n    std::cout &lt;&lt; &quot;The coordinate computation was not successful.&quot; \n\t      &lt;&lt; std::endl;\n    return 0;\n  }\n  K::FT norm = result.second;\n  \n  std::cout &lt;&lt; &quot;Testing the barycentric property &quot; &lt;&lt; std::endl;\n  <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> b(0, 0,0);\n  for(std::vector&lt; std::pair&lt; <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>, Coord_type  &gt; &gt;::const_iterator\n\tit = coords.begin(); it!=coords.end(); ++it)\n    b = b + (it-&gt;second/norm)* (it-&gt;first - <A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A>);\n  \n  std::cout &lt;&lt;&quot;    weighted barycenter: &quot; &lt;&lt; b &lt;&lt;std::endl;\n  std::cout &lt;&lt; &quot;    squared distance: &quot; &lt;&lt; \n    <A HREF=\"../Kernel_23_ref/Function_squared_distance.html#Cross_link_anchor_264\">CGAL::squared_distance</A>(p,b) &lt;&lt;std::endl;\n  return 0; \n}\n</pre>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>49.3&nbsp;&nbsp;&nbsp;Interpolation methods</h2>\n<A NAME=\"sec:interpolation\"></A>\n\n<h3>49.3.1&nbsp;&nbsp;&nbsp;Introduction</h3>\n\n\n<h4>Linear precision interpolation</h4>\n<P>\n\nSibson [<A HREF=\"../biblio.html#Biblio_s-bdnni-81\">Sib81</A>] defines a very simple interpolant that\nre-produces linear functions exactly. The interpolation of\n<MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\">(<B>x</B>)</I></MATH> is given as the linear combination of the neighbors' function\nvalues weighted by the coordinates:\n<P ALIGN=CENTER>\n<MATH><I>\n  Z<SUP>0</SUP>(<B>x</B>) =  <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB>  <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) z<SUB>i</SUB>.\n</I></MATH>\n<P>\n\nIndeed, if <MATH><I>z<SUB>i</SUB>=a + <B>b</B><SUP>t</SUP> <B>p<SUB>i</SUB></B></I></MATH> for all natural\nneighbors of <MATH><I><B>x</B></I></MATH>, we have\n<P ALIGN=CENTER>\n<MATH><I>  Z<SUP>0</SUP>(<B>x</B>) =  <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB>  <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) (a + <B>b</B><SUP>t</SUP><B>p<SUB>i</SUB></B>) = a+<B>b</B><SUP>t</SUP> <B>x</B></I></MATH>\n<P>\n\nby the barycentric coordinate property. The first example in\nSubsection&nbsp;<A HREF=\"Chapter_main.html#subsec:interpol_examples\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> shows how the function is\ncalled.\n<P>\n\n<h4>Sibson's <MATH><I>C<SUP>1</SUP></I></MATH> continuous interpolant</h4>\n\nIn [<A HREF=\"../biblio.html#Biblio_s-bdnni-81\">Sib81</A>], Sibson describes a second interpolation method\nthat relies also on the function gradient <MATH><I><B>g<SUB>i</SUB></B></I></MATH> for all <MATH><I><B>p<SUB>i</SUB></B>  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> <IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>. It is <MATH><I>C<SUP>1</SUP></I></MATH> continuous with gradient <MATH><I><B>g<SUB>i</SUB></B></I></MATH> at\n<MATH><I><B>p<SUB>i</SUB></B></I></MATH>. Spherical quadrics of the form <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\">(<B>x</B>) =a +\n<B>b</B><SUP>t</SUP> <B>x</B> +<IMG BORDER=0 WIDTH=9 HEIGHT=17 ALIGN=MIDDLE SRC=\"cc_gamma.gif\"> <B>x</B><SUP>t</SUP><B>x</B></I></MATH> are reproduced \nexactly. The\nproof relies on the barycentric coordinate property of the natural\nneighbor coordinates and assumes that the gradient of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\"></I></MATH> at the\ndata points is known or approximated from the function values as\ndescribed in [<A HREF=\"../biblio.html#Biblio_s-bdnni-81\">Sib81</A>] (see Section <A HREF=\"Chapter_main.html#s:gradient_fitting\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\nSibson's <MATH><I>Z<SUP>1</SUP></I></MATH> interpolant is a combination of the linear interpolant\n<MATH><I>Z<SUP>0</SUP></I></MATH> and an interpolant <MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\"></I></MATH> which is the weighted sum of the first\ndegree functions\n<P ALIGN=CENTER>\n<MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\"><SUB>i</SUB>(<B>x</B>) = z<SUB>i</SUB>\n+<B>g<SUB>i</SUB></B><SUP>t</SUP>(<B>x</B>-<B>p<SUB>i</SUB></B>),&nbsp;&nbsp;&nbsp;&nbsp;<IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\">(<B>x</B>)= ( <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB> (<IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>))/( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B>-<B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> )<IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\"><SUB>i</SUB>(<B>x</B>) )/( <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB>\n  (<IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>))/( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B>-<B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> )).</I></MATH>\n<P>\n\nSibson observed that the combination of <MATH><I>Z<SUP>0</SUP></I></MATH> and <MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\"></I></MATH> reconstructs exactly\na spherical quadric if they are mixed as follows:\n<P ALIGN=CENTER>\n<MATH><I>\nZ<SUP>1</SUP>(<B>x</B>) = (<IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\">(<B>x</B>) Z<SUP>0</SUP>(<B>x</B>) +\n  <IMG BORDER=0 WIDTH=10 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_beta.gif\">(<B>x</B>) <IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\">(<B>x</B>))/(<IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\">(<B>x</B>) +\n  <IMG BORDER=0 WIDTH=10 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_beta.gif\">(<B>x</B>))  where  <IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_alpha.gif\">(<B>x</B>) =\n( <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB> <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) ( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> -\n    <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <SUP>2</SUP>)/(f( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> - <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> )))/( <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB>\n  (<IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>))/(f( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> - <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> )))\n and  <IMG BORDER=0 WIDTH=10 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_beta.gif\">(<B>x</B>)=  <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB> <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>)\n <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> - <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <SUP>2</SUP>,</I></MATH>\n<P>\n\nwhere in Sibson's original work,\n<MATH><I>f( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> - <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> ) =  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> - <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> </I></MATH>.\n<P>\n\nC<SMALL>GAL</SMALL> contains a second implementation with <MATH><I>f( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> -\n<B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> ) =  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> - <B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <SUP>2</SUP></I></MATH> which is less\ndemanding on the number type because it avoids the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A>-root\ncomputation needed to compute the distance <MATH><I> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>x</B> -\n<B>p<SUB>i</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> </I></MATH>. The theoretical guarantees are the same (see\n[<A HREF=\"../biblio.html#Biblio_cgal:f-csapc-03\">Fl&ouml;03</A>]). Simply, the smaller the slope of <MATH><I>f</I></MATH>\naround <MATH><I>f(0)</I></MATH>, the faster the interpolant approaches <MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_xi.gif\"><SUB>i</SUB></I></MATH> as\n<MATH><I><B>x</B>  <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_rightarrow.gif\"> <B>p<SUB>i</SUB></B></I></MATH>.\n<P>\n\n<h4>Farin's <MATH><I>C<SUP>1</SUP></I></MATH> continuous interpolant</h4>\n<P>\n\nFarin [<A HREF=\"../biblio.html#Biblio_f-sodt-90\">Far90</A>] extended Sibson's work and realizes a <MATH><I>C<SUP>1</SUP></I></MATH>\ncontinuous interpolant by embedding natural neighbor coordinates in\nthe Bernstein-B&eacute;zier representation of a cubic simplex. If the\ngradient of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Phi.gif\"></I></MATH> at the data points is known, this interpolant\nreproduces quadratic functions exactly. The function gradient can be\napproximated from the function values by Sibson's method\n[<A HREF=\"../biblio.html#Biblio_s-bdnni-81\">Sib81</A>] (see Section <A HREF=\"Chapter_main.html#s:gradient_fitting\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>) which is exact only\nfor spherical quadrics.\n<P>\n\n<h4>Quadratic precision interpolants</h4>\n<P>\n\nKnowing the gradient <MATH><I><B>g<SUB>i</SUB></B></I></MATH> for all <MATH><I><B>p<SUB>i</SUB></B>  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> <IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\"></I></MATH>, we formulate a very simple interpolant that reproduces\nexactly quadratic functions. This interpolant is not <MATH><I>C<SUP>1</SUP></I></MATH> continuous\nin general.  It is defined as follows:\n<P ALIGN=CENTER>\n<MATH><I>\n  I<SUP>1</SUP>(<B>x</B>) =  <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>i</SUB> <IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>i</SUB>(<B>x</B>) \n  (z<SUB>i</SUB> + (1)/(2) <B>g<SUB>i</SUB></B><SUP>t</SUP> (<B>x</B> - <B>p<SUB>i</SUB></B>))  \n</I></MATH>\n<P>\n\n<h3>49.3.2&nbsp;&nbsp;&nbsp;Gradient fitting</h3>\n <A NAME=\"s:gradient_fitting\"></A>\nSibson describes a method to approximate the gradient of the function\n<MATH><I>f</I></MATH> from the function values on the data sites. For the data point\n<MATH><I><B>p<SUB>i</SUB></B></I></MATH>, we determine\n<P ALIGN=CENTER>\n<MATH><I><B>g<SUB>i</SUB></B> \n= </I></MATH><A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A><MATH><I><SUB><B>g</B></SUB> \n <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_big_sum.gif\"> <SUB>j</SUB>\n(<IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>j</SUB>(<B>p<SUB>i</SUB></B>))/( <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <B>p<SUB>i</SUB></B> - <B>p<SUB>j</SUB></B> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> <SUP>2</SUP>)\n( z<SUB>j</SUB> - (z<SUB>i</SUB> + <B>g</B><SUP>t</SUP> (<B>p<SUB>j</SUB></B> -<B>p<SUB>i</SUB></B>)) ),\n</I></MATH>\n<P>\n\nwhere <MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>j</SUB>(<B>p<SUB>i</SUB></B>)</I></MATH> is the natural neighbor coordinate\nof <MATH><I><B>p<SUB>i</SUB></B></I></MATH> with respect to <MATH><I><B>p<SUB>i</SUB></B></I></MATH> associated to\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_P.gif\">  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_setminus.gif\"> {<B>p<SUB>i</SUB></B>}</I></MATH>. This method works only for\npoints inside the convex hull of the data points because, for a point\n<MATH><I><B>p<SUB>i</SUB></B></I></MATH> on the convex hull, <MATH><I><IMG BORDER=0 WIDTH=7 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_lambda.gif\"><SUB>j</SUB>(<B>p<SUB>i</SUB></B>)</I></MATH> is not\ndefined. For spherical quadrics, the result is exact.\n<P>\n\nC<SMALL>GAL</SMALL> provides functions to approximate the gradients of all data\npoints that are inside the convex hull. There is one function for each\ntype of natural neighbor coordinate (i.e. <I><A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1124\">natural_neighbor_coordinates_2</A></I>, <I><A HREF=\"../Interpolation_ref/Function_regular_neighbor_coordinates_2.html#Cross_link_anchor_1126\">regular_neighbor_coordinates_2</A></I>).\n<P>\n\n<h3>49.3.3&nbsp;&nbsp;&nbsp;Examples</h3>\n<A NAME=\"subsec:interpol_examples\"></A>\n\n<h4>Linear interpolation method</h4>\n\n<pre class=\"ExampleCode\">//\n//file: examples/Interpolation/linear_interoplation_2.C \n//\n#include &lt;CGAL/basic.h&gt;\n#include &lt;utility&gt;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Class_Interpolation_traits_2.html#Cross_link_anchor_1122\">Interpolation_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1124\">natural_neighbor_coordinates_2</A>.h&gt;\n#include &lt;CGAL/interpolation_functions.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;K&gt;             Delaunay_triangulation;\ntypedef <A HREF=\"../Interpolation_ref/Class_Interpolation_traits_2.html#Cross_link_anchor_1121\">CGAL::Interpolation_traits_2</A>&lt;K&gt;               Traits;\ntypedef K::FT                                         Coord_type;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                    Point;\n\nint main()\n{\n  Delaunay_triangulation T;\n  std::map&lt;Point, Coord_type, K::Less_xy_2&gt; function_values;\n  typedef <A HREF=\"../Interpolation_ref/Class_Data_access.html#Cross_link_anchor_1118\">CGAL::Data_access</A>&lt; std::map&lt;Point, Coord_type, K::Less_xy_2 &gt; &gt; \n                                            Value_access;\n  \n  Coord_type a(0.25), bx(1.3), by(-0.7);\n\n  for (int y=0 ; y&lt;3 ; y++)\n    for (int x=0 ; x&lt;3 ; x++){ \n      K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(x,y);\n      T.insert(p);\n      function_values.insert(std::make_pair(p,a + bx* x+ by*y));\n    }\n  //coordinate computation\n  K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(1.3,0.34);\n  std::vector&lt; std::pair&lt; Point, Coord_type &gt; &gt; coords;\n  Coord_type norm = \n    <A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1123\">CGAL::natural_neighbor_coordinates_2</A>\n    (T, p,std::back_inserter(coords)).second;  \n \n  Coord_type res =  <A HREF=\"../Interpolation_ref/Function_linear_interpolation.html#Cross_link_anchor_1110\">CGAL::linear_interpolation</A>(coords.begin(), coords.end(), \n\t\t\t\t               norm,\n\t\t\t\t\t       Value_access(function_values));\n  \n  std::cout &lt;&lt; &quot;   Tested interpolation on &quot; &lt;&lt; p &lt;&lt; &quot; interpolation: &quot; \n\t    &lt;&lt; res &lt;&lt; &quot; exact: &quot; &lt;&lt; a + bx* p.x()+ by* p.y()&lt;&lt; std::endl;\n  return 0; \n}\n</pre>\n<P>\n\n<h4>Sibson's <MATH><I>C<SUP>1</SUP></I></MATH> interpolation scheme with gradient estimation</h4>\n\n<pre class=\"ExampleCode\">//\n//file:  examples/Interpolation/sibson_interpolation_2.C \n//\n#include &lt;CGAL/basic.h&gt;\n#include &lt;utility&gt;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1124\">natural_neighbor_coordinates_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Class_Interpolation_gradient_fitting_traits_2.html#Cross_link_anchor_1131\">Interpolation_gradient_fitting_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Interpolation_ref/Function_sibson_gradient_fitting.html#Cross_link_anchor_1128\">sibson_gradient_fitting</A>.h&gt;\n#include &lt;CGAL/interpolation_functions.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;K&gt;               Delaunay_triangulation;\ntypedef <A HREF=\"../Interpolation_ref/Class_Interpolation_gradient_fitting_traits_2.html#Cross_link_anchor_1130\">CGAL::Interpolation_gradient_fitting_traits_2</A>&lt;K&gt; Traits;\n\ntypedef K::FT                                            Coord_type;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                       Point;\ntypedef std::map&lt;Point, Coord_type, K::Less_xy_2&gt;        Point_value_map ;\ntypedef std::map&lt;Point, K::<A HREF=\"../Kernel_23_ref/Class_Vector_2.html#Cross_link_anchor_60\">Vector_2</A> , K::Less_xy_2 &gt;     Point_vector_map;\n\nint main()\n{\n  Delaunay_triangulation T;\n\n  Point_value_map function_values;\n  Point_vector_map function_gradients;\n\n  //parameters for spherical function:\n  Coord_type a(0.25), bx(1.3), by(-0.7), c(0.2);\n  for (int y=0 ; y&lt;4 ; y++)\n    for (int x=0 ; x&lt;4 ; x++){ \n      K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(x,y);\n      T.insert(p);\n      function_values.insert(std::make_pair(p,a + bx* x+ by*y + c*(x*x+y*y)));\n    }\n  sibson_gradient_fitting_nn_2(T,std::inserter(function_gradients,\n\t\t\t\t\t       function_gradients.begin()),\n\t\t\t       <A HREF=\"../Interpolation_ref/Class_Data_access.html#Cross_link_anchor_1118\">CGAL::Data_access</A>&lt;Point_value_map&gt;\n\t\t\t       (function_values), \n\t\t\t       Traits());\n  \n \n  //coordiante computation\n  K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> p(1.6,1.4);\n  std::vector&lt; std::pair&lt; Point, Coord_type &gt; &gt; coords;\n  Coord_type norm = \n    <A HREF=\"../Interpolation_ref/Function_natural_neighbor_coordinates_2.html#Cross_link_anchor_1123\">CGAL::natural_neighbor_coordinates_2</A>(T, p,std::back_inserter\n\t\t\t\t\t (coords)).second;\n  \n  \n  //Sibson interpolant: version without <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>:\n  std::pair&lt;Coord_type, bool&gt; res =  \n    CGAL::sibson_c1_interpolation_square\n    (coords.begin(),\n     coords.end(),norm,p, \n     <A HREF=\"../Interpolation_ref/Class_Data_access.html#Cross_link_anchor_1118\">CGAL::Data_access</A>&lt;Point_value_map&gt;(function_values),\n     <A HREF=\"../Interpolation_ref/Class_Data_access.html#Cross_link_anchor_1118\">CGAL::Data_access</A>&lt;Point_vector_map&gt;(function_gradients),\n     Traits());\n  if(res.second)\n    std::cout &lt;&lt; &quot;   Tested interpolation on &quot; &lt;&lt; p \n\t      &lt;&lt; &quot; interpolation: &quot; &lt;&lt; res.first &lt;&lt; &quot; exact: &quot; \n\t      &lt;&lt; a + bx * p.x()+ by * p.y()+ c*(p.x()*p.x()+p.y()*p.y()) \n\t      &lt;&lt; std::endl;\n  else\n    std::cout &lt;&lt; &quot;C^1 Interpolation not successful.&quot; &lt;&lt; std::endl \n\t      &lt;&lt; &quot; not all function_gradients are provided.&quot;  &lt;&lt; std::endl \n\t      &lt;&lt; &quot; You may resort to linear interpolation.&quot; &lt;&lt; std::endl;\n  \n  return 0; \n};\n</pre>\n<P>\n\nAn additional example compares numerically the errors of the different \ninterpolation functions with respect to a known function. \nIt is distributed in the examples directory.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Interpolation_ref/Chapter_intro.html\">Interpolation</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_49!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39119.0}