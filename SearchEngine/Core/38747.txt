{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 432D Segment Voronoi Diagrams Menelaos Karavelas This chapter describes the two dimensional segment Voronoi diagram package of CGAL We start with a few definitions in Section The software design of the 2D segment Voronoi diagram package is described in Section In Section we discuss the geometric traits of the 2D segment Voronoi diagram package and in Section the segment Voronoi diagram hierarchy a data structure suitable for fast nearest neighbor queries is briefly described 43 1 Definitions Figure The segment Voronoi diagram for a set of weakly left and strongly right intersecting sites The 2D segment Voronoi diagram package of CGAL is designed to compute the dual of the Voronoi diagram of a set of possibly intersecting segments on the plane Although we compute the dual we will often refer to the diagram itself since it is easier to explain an d understand The algorithm that has been implemented is incremental The corresponding CGAL class is called Segment Voronoi diagram 2 SegmentVoronoiDiagramTraits 2 SegmentVoronoiDiagramStructure 2 and will be discussed in more detail in the sequel The interested reader may want to refer to the paper by Karavelas Kar 4 for the general idea as well as the details of the algorithm implemented Definitions Before describing the details of the implementation we make a brief introduction to the theory of segment Voronoi diagrams The segment Voronoi diagram is defined over a set of non intersecting sites which can either be points or linear segments which we assume that are given through their endpoints The segment Voronoi diagram a subdivision of the plane into connected regions called cells associated with the sites The cell of a site ti is the locus of points on the plane that are closer to ti than any other site tj j i The distance x ti of a point x in the plane to a site ti is defined as the minimum of the Euclidean distances of x from the points in ti Hence if ti is a point pi then x ti x ti whereas if ti is a segment then x ti miny ti x y where denotes the Euclidean norm It can easily be seen that it is a generalization of the Voronoi diagram for points In many applications the restriction that sites are non intersecting is too strict Often we want to allow segments that touch at their endpoints or even segments that overlap or intersect properly at their interior for example see Fig Allowing such configurations poses certain problems More specifically when we allow segments to touch at their endpoints we may end up with pairs of segments whose bisector is two dimensional If we allow pairs of segments that intersect properly at their interior the interiors of their Voronoi cells are no longer simply connected In both cases above the resulting Voronoi diagrams are no longer instances of abstract Voronoi diagrams cf Kle89 which has a direct consequence on the efficient computation of the corresponding Voronoi diagram The remedy to these problems is to consider linear segments not as one object but rather as three namely the two endpoints and the interior This choice guarantees that all bisectors in the Voronoi diagram are one dimensional and that all Voronoi cells are simply connected Moreover we further distinguish between two cases according to the type of intersecting pair that our input data set contains A pair of sites is called weakly intersecting if they a single common point and this common point does not lie in the interior of any of the two sites A pair of sites is called strongly intersecting if they intersect and they either have more than one common point or their common point lies in the interior of at least one of the two sites As it will be seen later the two cases have different representation and thus storage requirements as well as they require a somehow different treatment on how the predicates are evaluated Having made the distinction between weakly and strongly intersecting sites and having said that segment sites are treated as three objects we are now ready to precisely define the Voronoi diagram we compute Given a set of input sites let be the set of points and open segments in the arrangement of The 2D segment Voronoi diagram package of CGAL computes the dual of the Voronoi diagram of the sites in the set The dual of the segment Voronoi diagram is uniquely defined once we have the segment Voronoi diagram If the all sites are in general position then dual graph is a graph with triangular faces away from the convex hull of the set of sites To unify our approach and handling of the dual graph we add to the set of finite sites a fictitious site at infinity which we call the site at infinity We can then connect all vertices of the outer face of the dual graph to the site at infinity which gives us a graph with the property that all of its faces are now triangular However the dual graph is not a triangulation for two main reasons we cannot always embed it on the plane with straight line segments that yield a triangulation and moreover we may have two faces of the graph that have two edges in common which is not allowed in a triangulation We would like to finish our brief introduction to the theory of segment Voronoi diagrams by discussing the concept of general position We say that a set of sites is in general position if no two triplets of sites have the same tritangent Voronoi circle This statement is rather technical and it is best understood in the context of points The equivalent statement for points is that we have no two triplets of points that define the same circumcircle or equivalently that no four points are co circular The statement about general position made above is a direct generalization of the much simpler to understand statement about points On the contrary when we have sites in degenerate position the dual graph has faces with more than three edges on their boundary We can get a triangulated version of the graph by simply triangulating the corresponding faces in an arbitrary way In fact the algorithm that has been implemented in CGAL has the property that it always returns a valid triangulated version of the dual graph of the segment Voronoi diagram By valid we mean that it contains the actual dual graph i e the actual dual of the segment Voronoi diagram and whenever there are faces with more than three faces then they are triangulated The way that they are triangulated depends on the order of insertion of the sites in the diagram One final remark has to be made with respect to the difference between the set of input sites and the set of output sites The set of input sites consists of the closed sites that the user inserts in the diagram Since segment sites are treated as three objects internally our algorithm sees only points and open segments As a result from the point of view of the algorithm the input sites have no real meaning What has real meaning is the set of sites that correspond to cells of the Voronoi diagrams and this is the set of output sites Degenerate dimensions The dimension of the segment Voronoi diagram is in general 2 The exceptions to this rule are as follows The dimension is 1 if the segment Voronoi diagram contains no sites The dimension is if the segment Voronoi diagram contains exactly one output site The dimension is 1 is the segment Voronoi diagram contains exactly two output sites 43 2 Software Design The 2D segment Voronoi diagram class Segment Voronoi diagram 2 SegmentVoronoiDiagramTraits 2 SegmentVoronoiDiagramDataStructure 2 follows the design of the triangulation package of CGAL It is parametrized by two arguments the geometric traits class It provides the basic geometric objects involved in the algorithm such as sites points etc It also provides the geometric predicates for the computation of the segment Voronoi diagram as well as some basic constructions that can be used for example to visualize the diagram The geometric traits for the segment Voronoi diagram will be discussed in more detail in the next section the segment Voronoi diagram data structure This is essentially the same as the Apollonius graph data structure discussed in Chapter augmented with some additional operations that are specific to segment Voronoi diagrams The corresponding concept is that of SegmentVoronoiDiagramDataStructure 2 which in fact is a refinement of the ApolloniusGraphDataStructure 2 concept The class Triangulation data structure 2 Vb Fb is a model of the concept SegmentVoronoiDiagramDataStructure 2 A default value for the corresponding template parameter is provided so the user does not need to specify it Strongly intersecting sites and their representation As we have mentioned above the segment Voronoi diagram package of CGAL is designed to support the computation of the segment Voronoi diagram even when the input segment sites are intersecting This choice poses certain issues for the design of the software package The major concern is the representation of the subsegments that appear in the arrangement of the these sites because the sites in the arrangement are the ones over which the diagram is actually defined A direct consequence of the choice of representation is the algebraic degree of the predicates involved in the computation of the segment Voronoi diagram as well as the storage requirements for the subsegments and points on intersection in the arrangement The case of weakly intersecting sites does not require any special treatment We can simply represent points by their coordinates and segments by their endpoints In the case of strongly intersecting sites the obvious choice to use the afore mentioned representation has severe disadvantages Consider two strongly intersecting segments ti and tj whose endpoints have homogeneous coordinates of size b Their intersection point will have homogeneous coordinates of bit size 6b O 1 This effect can be cascaded which implies that after inserting k input segments we can arrive at having points of intersection whose bit sizes are exponential with respect to k i e their homogeneous coordinates will have bit size 2kb Not only the points of intersection but also the adjacent subsegments will be represented by quantities of arbitrarily high bit size and as a result we would not be able to give a bound on the bit sizes of the coordinates of the points of intersection As a result we would not be able to give a bound on the memory needed to store these coordinates An equally important consequence is that we would also not be able to give a bound on the algebraic degree of the algebraic expressions involved in the evaluation of the predicates Such a behavior is obviously undesirable For robustness efficiency and scalability purposes it is critical that the bit size of the algebraic expressions in the predicates does not depend on the input size For this reason as well as for others to be discussed below we decided to represent sites in a implicit manner which somehow encodes the history of their construction In particular we exploit the fact that points of intersection always lie on two input segments and that segments that are not part of the input are always supported by input segments For example let us consider the configuration in Fig We assume that the segments ti piqi i 1 2 3 are inserted in that order Upon the insertion of t2 our algorithm will split the segment t1 into the subsegments p1s1 and s1q1 then add s1 and finally insert the subsegments p2s1 and s1q2 How do we represent the five new sites s1 will be represented by its two defining segments t1 and t2 The segment p1s1 will be represented by two segments a point and a boolean The first segment is t1 which is always the segment with the same support as the newly created segment The second segment is t2 and the point is p1 The boolean indicates whether the first endpoint of p1s1 is an input point in this case the boolean is equal to true The segment s1q1 will also be represented by two segments a point and a boolean namely t1 the supporting segment of s1q1 t2 and false it is the second endpoint of s1q1 that is an input point Subsegments p2s2 and s2q2 are represented analogously Consider now what happens when we insert t3 The point s2 will again be represented by two segments but not s1q1 and t3 In fact it will be represented by t1 the supporting segment of s1q1 and t3 s2q1 will be represented by two segments a point and a boolean t1 t3 and false and similarly for p3s2 and s2q3 On the other hand both endpoints of s1s2 are non input points In such a case we represent the segment by three input segments More precisely s1s2 is represented by the segments t1 the supporting segment of s1q1 t2 it defines s1 along with t1 and t3 it defines s2 along with t1 Figure Site representation The point s1 is represented by the four points p1 q1 p2 and q2 The segment p1s1 is represented by the points p1 q1 p2 q2 and a boolean which is set to true to indicate that the first endpoint in not a point of intersection The segment s1s2 is represented by the six points p1 q1 p2 q2 p3 and q3 The remaining non input points and segments in the figure are represented similarly The five different presentations two for points coordinates two input segments and three for segments two input points two input segments an input point and a boolean three input segments form a closed set of representations and thus represent any point of intersection or subsegment regardless of the number of input segments Moreover every point input or intersection has homogeneous coordinates of bit size at most 3b O 1 The supporting lines of the segments they are needed in some of the predicates have coefficients which are always of bit size 2b O 1 As a result the bit size of the expressions involved in our predicates will always be O b independently of the size of the input The SegmentVoronoiDiagramSite 2 concept encapsulates the ideas presented above A site is represented in this concept by up to four points and a boolean or up to six points depending on its type The class Segment Voronoi diagram site 2 K implements this concept Even this representation however has some degree of redundancy The endpoint of a segment appears in both the representation of the open segment site as well as the representation of the point site itself The situation becomes even worse in the presence of strongly intersecting sites a point may appear in the representation of multiple subsegments and or points of intersection To avoid this redundancy input points are stored in a container and the various types of sites input points and segments points of intersection subsegments with one or two points of intersection as endpoints only store handles to the points in the container This is achieved by the Segment Voronoi diagram storage site 2 Gt class which is a model of the corresponding concept SegmentVoronoiDiagramStorageSite 2 This concept enforces a site to be represented by up to 6 handles which are very lightweight objects instead of 6 points which are compared to handles of course very heavy objects Optimizing memory allocation There are applications where we know beforehand that the input consists of only weakly intersecting sites In these cases the site representation described above poses a significant overhead in the memory requirements of our implementation instead of representing sites with up to two points or ultimately with to two handles we require sites to store six points respectively six handles To avoid this overhead we have introduced two series of traits classes One that supports the full fledged sites and is suitable when the input consists of strongly intersecting sites This series consists of the Segment Voronoi diagram traits 2 K MTag and Segment Voronoi diagram filtered traits 2 CK CM EK EM FK FM classes One that is customized for input that contain only weakly intersecting sites This series consists of the Segment Voronoi diagram traits without intersections 2 K MTag and Segment Voronoi diagram filtered traits without intersections 2 CK CM EK EM FK FM classes The advantages of having different traits classes are as follows When the user chooses to use one of the traits classes in the second series we only store two handles per site This implies a reduction by a factor of three in the memory allocated per site with respect to the first series of traits classes In the case of the first series of traits classes we can better exploit the knowledge that have strongly intersecting sites in order to further apply geometric filters see below during the evaluation of the predicates On the contrary if the second series of traits classes is used we can avoid geometric filtering tests that have meaning only in the case of strongly intersecting sites 43 3 The Geometric Traits The predicates required for the computation of the segment Voronoi diagram are rather complicated It is not the purpose of this document to discuss them in detail The interested reader may refer to Burnikel s thesis Bur96 where it is shown that in the case of weakly intersecting sites represented in homogeneous coordinates of bit size b the maximum bit size of the algebraic expressions involved in the predicates is 4 b O 1 Given our site representation given above we can guarantee that even in the case of strongly intersecting sites the algebraic degree of the predicates remains O b independently of the size of the input What we want to focus in the remainder of this section are the different kinds of filtering techniques that we have employed in our implementation Geometric filtering Our representation of sites is coupled very naturally with what we call geometric filtering The technique amounts to performing simple geometric tests exploiting the representation of our data as well as the geometric structure inherent in our problem in order to evaluate predicates in seemingly degenerate configurations Geometric filtering can be seen as a preprocessing step before performing arithmetic filtering Roughly speaking by arithmetic filtering we mean that we first try to evaluate the predicates using a fixed precision floating point number type such as double and at the same time keep error bounds on the numerical errors of the computations we perform If the numerical errors are too big and do not permit us to evaluate the predicate we switch to an exact number type and repeat the evaluation of the predicate Geometric filtering can help by eliminating situations in which the arithmetic filter will fail thus decreasing the number of times we need to evaluate a predicate using exact arithmetic To illustrate the application and effectiveness of this approach let us consider a very simple example usage Suppose we want to determine if two non input points are identical we assume here that the input sites are represented by doubles In order to do that we need to compute their coordinates and compare them If the two points are identical the answer to our question using double arithmetic may be wrong due to numerical errors in which case we will have to reside to the more expensive exact computation Instead before testing the coordinates for equality we can use the representation of the points to potentially answer the question More specifically and this is the geometric filtering part of the computation we can first test if the defining segments of the two points are the same If they are not then we proceed to comparing their coordinates as usual Testing the defining segments for equality does not involve any arithmetic operations on the input but rather only comparisons on doubles By performing this very simple test we avoid a numerically difficult computation which could be performed thousands of times during the computation of a Voronoi diagram Geometric filtering has been implemented in all our models of the SegmentVoronoiDiagramTraits 2 concept These models are the classes Segment Voronoi diagram traits 2 K MTag Segment Voronoi diagram traits without intersections 2 K MTag Segment Voronoi diagram filtered traits 2 CK CM EK EM FK FM and Segment Voronoi diagram filtered traits without intersections 2 CK CM EK EM FK FM Arithmetic filtering As mentioned above performing computations with exact arithmetic can be very costly For this reason we have devoted considerable effort in implementing different kinds of arithmetic filtering mechanisms Presently there two ways of performing arithmetic filtering for the predicates involved in the computation of segment Voronoi diagrams The user can define his her kernel using as number type a number type of the form CGAL Filtered exact CT ET Then this kernel can be entered as the first template parameter in the Segment Voronoi diagram 2 K MTag or Segment Voronoi diagram with intersections 2 K MTag class The user can define up to three different kernels CK FK and EK default values are provided for most parameters The first kernel CK is used only for constructions The second kernel FK is the filtering kernel the traits class will attempt to compute the predicates using this kernel If the filtering kernel fails to successfully compute a predicate the exact kernel EK will be used These three kernels are then used in the Segment Voronoi diagram filtered traits 2 CK CM EK EM FK FM and Segment Voronoi diagram filtered traits without intersections 2 CK CM EK EM FK FM classes which have been implemented using the Filtered predicate EP FP mechanism Our experience so far has shown that for all reasonable and valid values of the template parameters the second method for arithmetic filtering is more efficient among the two Let s consider once more the classes Segment Voronoi diagram 2 K MTag and Segment Voronoi diagram with intersections 2 K MTag The template parameter MTag provides another degree of freedom to the user who can indicate the type of arithmetic operations to be used in the evaluation of the predicates More specifically in both classes MTag can be CGAL Sqrt field tag in which case the predicates will be evaluated using all four basic arithmetic operations plus square roots this requires of course that the number type used in the kernel K supports these operations exactly The second choices are CGAL Field tag for the Segment Voronoi diagram 2 K MTag class and CGAL Ring tag for the Segment Voronoi diagram with intersections 2 K MTag class In the first case we indicate that we want the predicates to be computed using only the four basic arithmetic operations whereas in the second case we evaluate the predicates using only ring operations Again for the predicates to be evaluated correctly the number type used in the kernel K must support the corresponding operations exactly The semantics for the template parameters CM FM and EM in the Segment Voronoi diagram filtered traits 2 CK CM EK EM FK FM and Segment Voronoi diagram filtered traits without intersections 2 CK CM EK EM FK FM classes are analogous With each of these template parameters we can control the type of arithmetic operations that are going to be used in calculations involving each of the corresponding kernels CK FK and EK When the Segment Voronoi diagram filtered traits 2 CK CM EK EM FK FM is used the possible values for CM FM and EM are CGAL Sqrt field tag and CGAL Field tag whereas if the Segment Voronoi diagram filtered traits without intersections 2 CK CM EK EM FK FM class is used the possible values are CGAL Sqrt field tag and CGAL Ring tag The semantics are the same as in the case of the Segment Voronoi diagram 2 K MTag and Segment Voronoi diagram with intersections 2 K MTag classes 43 4 The segment Voronoi diagram hierarchy The Segment Voronoi diagram hierarchy 2 SegmentVoronoiDiagramTraits 2 SSTag SegmentVoronoiDiagramDataStructure 2 class is the analogue of the Triangulation hierarchy 2 or the Apollonius graph hierarchy 2 classes applied to the segment Voronoi diagram It consists of a hierarchy of segment Voronoi diagrams constructed in a manner analogous to the Delaunay hierarchy by Devillers Dev 2 Unlike the triangulation hierarchy or the Apollonius graph hierarchy the situation here is more complicated because of two factors firstly segments are treated as three objects instead of one the two endpoints and the interior of the segments and secondly the presence of strongly intersecting sites complicates significantly the way the hierarchy is constructed The interested reader may refer to the paper by Karavelas Kar 4 for the details of the construction of the hierarchy Another alternative is to have a hybrid hierarchy that consists of the segment Voronoi diagram at the bottom most level and point Voronoi diagrams at all other levels This choice seems to work very well in practice primarily because it avoids the overhead of maintaining a Voronoi diagram for segments at the upper levels of the hierarchy However it seems much less likely to be possible to give any theoretical guarantees for its performance in contrast to the hierarchy with segment Voronoi diagrams at all levels cf Kar 4 The user can choose between the two types of hierarchies by means of the template parameter SSTag If SSTag is set to false which is also the default value the upper levels of the hierarchy consist of point Voronoi diagrams If SSTag is set to true we have segment Voronoi diagrams at all levels of the hierarchy The class Segment Voronoi diagram hierarchy 2 SegmentVoronoiDiagramTraits 2 SSTag SegmentVoronoiDiagramDataStructure 2 has exactly the same interface and functionality as the Segment Voronoi diagram 2 SegmentVoronoiDiagramTraits 2 SegmentVoronoiDiagramDataStructure 2 class Using the segment Voronoi diagram hierarchy involves an additional cost in space and time for maintaining the hierarchy Our experiments have shown that it usually pays off to use the hierarchy for inputs consisting of more than about 1 sites 43 5 Examples 43 5 1 First example The following example shows to use the segment Voronoi diagram traits in conjunction with the Filtered exact CT ET mechanism In addition it shows how to use a few of the iterators provided by the Segment Voronoi diagram 2 class in order to count a few site related quantities file svd count sites C include CGAL basic h standard includes include iostream include fstream include cassert define the number type include CGAL Quotient h include CGAL MP Float h typedef CGAL Quotient CGAL MP Float EFT define the kernel include CGAL Simple cartesian h include CGAL Filtered exact h typedef CGAL Filtered exact double EFT FT typedef CGAL Simple cartesian FT Kernel typedefs for the traits and the algorithm include CGAL Segment Voronoi diagram traits 2 h include CGAL Segment Voronoi diagram 2 h typedef CGAL Segment Voronoi diagram traits 2 Kernel Gt typedef CGAL Segment Voronoi diagram 2 Gt SVD2 using namespace std int main ifstream ifs data sitesx cin assert ifs SVD2 svd SVD2 Site 2 site while ifs site svd insert site ifs close assert svd is valid true 1 cout endl endl print the number of input and output sites cout of input sites svd number of input sites endl cout of output sites svd number of output sites endl unsigned int n ipt n iseg n opt n oseg n ptx count the number of input points and input segments SVD2 Input sites iterator iit for iit svd input sites begin iit svd input sites end iit if iit is point n ipt else n iseg count the number of output points and output segments as well as the number of points that are points of intersection of pairs of strongly intersecting sites SVD2 Output sites iterator oit for oit svd output sites begin oit svd output sites end oit if oit is segment n oseg else n opt if oit is input n ptx cout endl of input segments n iseg endl cout of input points n ipt endl endl cout of output segments n oseg endl cout of output points n opt endl endl cout of intersection points n ptx endl return 43 5 2 Second example The following example shows how to use the segment Voronoi diagram hierarchy along with the filtered traits class that supports intersecting sites file svd filtered traits C include CGAL basic h standard includes include iostream include fstream include cassert example that uses the filtered traits and the segment Voronoi diagram hierarchy choose the kernel include CGAL Simple cartesian h struct Rep public CGAL Simple cartesian double typedefs for the traits and the algorithm include CGAL Segment Voronoi diagram hierarchy 2 h include CGAL Segment Voronoi diagram filtered traits 2 h struct Gt public CGAL Segment Voronoi diagram filtered traits 2 Rep typedef CGAL Segment Voronoi diagram hierarchy 2 Gt SVD2 int main std ifstream ifs data sites cin assert ifs SVD2 svd SVD2 Site 2 site read the sites and insert them in the segment Voronoi diagram while ifs site svd insert site validate the segment Voronoi diagram assert svd is valid true 1 return 43 5 3 Third example The following example demonstrates how to recover the defining sites for the edges of the Voronoi diagram file svd voronoi vertices C include CGAL basic h standard includes include iostream include fstream include cassert include string define the kernel include CGAL Simple cartesian h include CGAL Filtered kernel h typedef CGAL Simple cartesian double CK typedef CGAL Filtered kernel CK Kernel typedefs for the traits and the algorithm include CGAL Segment Voronoi diagram traits 2 h include CGAL Segment Voronoi diagram 2 h typedef CGAL Segment Voronoi diagram traits 2 Kernel Gt typedef CGAL Segment Voronoi diagram 2 Gt SVD2 using namespace std int main ifstream ifs data sites2 cin assert ifs SVD2 svd SVD2 Site 2 site read the sites from the stream and insert them in the diagram while ifs site svd insert site ifs close validate the diagram assert svd is valid true 1 cout endl endl now walk through the non infinite edges of the dual which are dual to the edges in the Voronoi diagram and print the sites defining each Voronoi edge Each oriented Voronoi edge horizontal segment in the figure below is defined by four sites A B C and D B C D A The sites A and B define the oriented bisector on which the edge lies whereas the sites C and D along with A and B define the two endpoints of the edge These endpoints are the Voronoi vertices of the triples A B C and B A D If one of these vertices is the vertex at infinity the string infinite vertex is printed the corresponding Voronoi edge is actually a stright line or parabolic ray The sites below are printed in the order A B C D string inf vertex infinite vertex char vid A B C D SVD2 Finite edges iterator eit svd finite edges begin for int k 1 eit svd finite edges end eit k SVD2 Edge e eit get the vertices defining the Voronoi edge SVD2 Vertex handle v e first vertex svd ccw e second e first vertex svd cw e second e first vertex e second e first mirror vertex e second cout Edge k endl for int i i 4 i check if the vertex is the vertex at infinity if yes print the corresponding string otherwise print the site if svd is infinite v i cout vid i inf vertex endl else cout vid i v i site endl cout endl return Next chapter 2D Segment Voronoi Diagrams Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Segment_Voronoi_diagram_2/Chapter_main.html", "title": "2d segment voronoi diagrams", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Segment_Voronoi_diagram_2/main.tex' -->\n<html> <head>  \n<title>2D Segment Voronoi Diagrams</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_43\"></a>\n  \n<h1>Chapter 43<BR>2D Segment Voronoi Diagrams</h1>\n\n<A NAME=\"chapter-segvor2\"></A>\n<EM>Menelaos Karavelas</EM><BR>\n\n\n<P>\n\nThis chapter describes the two-dimensional segment Voronoi diagram\npackage of C<SMALL>GAL</SMALL>. We start with a few definitions in \nSection&nbsp;<A HREF=\"Chapter_main.html#sec:segvor2-definitions\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nThe software design of the 2D segment Voronoi diagram package is\ndescribed in Section&nbsp;<A HREF=\"Chapter_main.html#sec:segvor2-design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nIn Section&nbsp;<A HREF=\"Chapter_main.html#sec:segvor2-traits\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> we discuss the geometric\ntraits of the 2D segment Voronoi diagram package and in Section\n<A HREF=\"Chapter_main.html#sec:segvor2-hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> the segment Voronoi diagram hierarchy, a\ndata structure suitable for fast nearest neighbor queries, is briefly\ndescribed.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>43.1&nbsp;&nbsp;&nbsp;Definitions</h2>\n\n<A NAME=\"sec:segvor2-definitions\"></A>\n<P>\n\n<center>\n  <img border=1 src=\"./svd-weakly-bw.gif\" align=center\n  alt=\"The segment Voronoi diagram for a set of weakly intersecting sites\"\n  title=\"The segment Voronoi diagram for a set of weakly intersecting sites\">\n  <!-- -->\n  <img border=1 src=\"./svd-strongly-bw.gif\" align=center\n  alt=\"The segment Voronoi diagram for a set of strongly intersecting sites\"\n  title=\"The segment Voronoi diagram for a set of strongly intersecting sites\">\n</center>\n\n\n<font size=-1>\n\n<CENTER>\n<B>Figure:&nbsp;&nbsp;</B>The segment Voronoi diagram for a set of weakly (left) and\n  strongly (right) intersecting sites.<A NAME=\"fig-segvor\"></A>\n</CENTER>\n\n</font>\n<P>\n\nThe 2D segment Voronoi diagram package of C<SMALL>GAL</SMALL> is designed to\ncompute the dual of the Voronoi diagram of a set of possibly\nintersecting segments on the plane. Although we compute the dual, we\nwill often refer to the diagram itself, since it is easier to\nexplain an d understand. The algorithm that has been\nimplemented is incremental. The corresponding C<SMALL>GAL</SMALL> class is called\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramTraits_2.html#Cross_link_anchor_1052\">SegmentVoronoiDiagramTraits_2</A>,SegmentVoronoiDiagramStructure_2&gt;</I>\nand will be discussed in more detail in the sequel. The interested\nreader may want to refer to the paper by Karavelas\n[<A HREF=\"../biblio.html#Biblio_cgal:k-reisv-04\">Kar04</A>] for the general idea as well as the details of\nthe algorithm implemented.\n<P>\n\n<b>Definitions.</b>\n\nBefore describing the details of the implementation we make a brief\nintroduction to the theory of segment Voronoi diagrams.\nThe segment Voronoi diagram is defined over a set of non-intersecting\nsites, which can either be points or linear segments, which we assume\nthat are given through their endpoints. The segment Voronoi diagram a\nsubdivision of the plane into connected regions, called <I>cells</I>,\nassociated with the sites. The cell of a site <MATH><I>t<SUB>i</SUB></I></MATH> is the locus of\npoints on the plane that are closer to <MATH><I>t<SUB>i</SUB></I></MATH> than any other site\n<MATH><I>t<SUB>j</SUB></I></MATH>, <MATH><I>j <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> i</I></MATH>.\nThe distance <MATH><I><IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\">(x, t<SUB>i</SUB>)</I></MATH> of a point <MATH><I>x</I></MATH> in the plane to a \nsite <MATH><I>t<SUB>i</SUB></I></MATH> is defined as the minimum of the Euclidean distances of <MATH><I>x</I></MATH>\nfrom the points in <MATH><I>t<SUB>i</SUB></I></MATH>. Hence, if <MATH><I>t<SUB>i</SUB></I></MATH> is a point <MATH><I>p<SUB>i</SUB></I></MATH>, then\n<P ALIGN=CENTER>\n<MATH><I>      <IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\">(x,t<SUB>i</SUB>)= <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> x-t<SUB>i</SUB> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> ,  </I></MATH>\n<P>\n\nwhereas if <MATH><I>t<SUB>i</SUB></I></MATH>, is a segment, then\n<P ALIGN=CENTER>\n<MATH><I>      <IMG BORDER=0 WIDTH=6 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_delta.gif\">(x,t<SUB>i</SUB>)=</I></MATH><A HREF=\"../NumberTypeSupport_ref/Function_min.html#Cross_link_anchor_1394\">min</A><MATH><I><SUB>y <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> t<SUB>i</SUB></SUB> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> x-y <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> , </I></MATH>\n<P>\n\nwhere <MATH><I> <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\">  &middot;  <IMG BORDER=0 WIDTH=6 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_parallel.gif\"> </I></MATH> denotes the Euclidean norm.\nIt can easily be seen that it is a generalization of the Voronoi\ndiagram for points.\n<P>\n\nIn many applications the restriction that sites are non-intersecting\nis too strict. Often we want to allow segments that touch at their\nendpoints, or even segments that overlap or intersect properly at\ntheir interior (for example, see Fig. <A HREF=\"Chapter_main.html#fig-segvor\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). Allowing such\nconfigurations poses certain problems. More specifically, when we allow\nsegments to touch at their endpoints we may end up with pairs of\nsegments whose <A HREF=\"../Kernel_23_ref/Function_bisector.html#Cross_link_anchor_161\">bisector</A> is two-dimensional. If we allow pairs of\nsegments that intersect properly at their interior, the interiors of\ntheir Voronoi cells are no longer simply connected. In both cases\nabove the resulting Voronoi diagrams are no longer instances of\nabstract Voronoi diagrams (cf. [<A HREF=\"../biblio.html#Biblio_k-cavd-89\">Kle89</A>]), which has a direct\nconsequence on the efficient computation of the corresponding Voronoi\ndiagram. The remedy to these problems is to consider linear segments\nnot as one object, but rather as three, namely the two endpoints and\nthe interior. This choice guarantees that all bisectors in the Voronoi\ndiagram are one-dimensional and that all Voronoi cells are simply\nconnected. Moreover, we further distinguish between two cases,\naccording to the type of intersecting pair that our input data set\ncontains. A pair of sites is called <I>weakly intersecting</I> if they\na single common point and this common point does not lie in the\ninterior of any of the two sites. A pair of sites is called\n<I>strongly intersecting</I> if they intersect and they either have\nmore than one common point or their common point lies in the interior\nof at least one of the two sites. As it will be seen later the two\ncases have different representation (and thus storage) requirements,\nas well as they require a somehow different treatment on how the\npredicates are evaluated. Having made the distinction between weakly\nand strongly intersecting sites, and having said that segment sites\nare treated as three objects, we are now ready to precisely define the\nVoronoi diagram we compute. Given a set <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> of input sites,\nlet <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"><SUB><IMG BORDER=0 WIDTH=14 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_A.gif\"></SUB></I></MATH> be the set of points and\n(open) segments in the arrangement <MATH><I><IMG BORDER=0 WIDTH=14 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_A.gif\">(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></MATH> of\n<MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH>. The 2D segment Voronoi diagram package of C<SMALL>GAL</SMALL> computes the dual of the Voronoi diagram of the sites in the set \n<MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"><SUB><IMG BORDER=0 WIDTH=14 HEIGHT=14 ALIGN=BOTTOM SRC=\"cc_mathcal_A.gif\"></SUB></I></MATH>.\n<P>\n\nThe dual of the segment Voronoi diagram is uniquely defined once we\nhave the segment Voronoi diagram. If the all sites are in\n<I>general position</I>, then dual graph is a graph with triangular\nfaces away from the convex hull of the set of sites. To unify our approach\nand handling of the dual graph we add to the set of (finite) sites\na fictitious site at infinity, which we call the\n<I>site at infinity</I>. We can then connect all vertices of the outer\nface of the dual graph to the site at infinity which gives us\na graph with the property that all of its faces are now\ntriangular. However, the dual graph is not a triangulation for\ntwo main reasons: we cannot always embed it on the plane with straight\nline segments that yield a triangulation and, moreover, we may have two\nfaces of the graph that have two edges in common, which is not allowed\nin a triangulation.\n<P>\n\nWe would like to finish our brief introduction to the theory of\nsegment Voronoi diagrams by discussing the concept of general\nposition. We say that a set of sites is in general position if no two\ntriplets of sites have the same tritangent Voronoi circle. This\nstatement is rather technical and it is best understood in the context\nof points. The equivalent statement for points is that we have no two\ntriplets of points that define the same circumcircle, or equivalently\nthat no four points are co-circular. The statement about general\nposition made above is a direct generalization of the (much simpler to\nunderstand) statement about points. On the contrary, when we have\nsites in degenerate position, the dual graph has faces with more than\nthree edges on their boundary. We can get a triangulated version of\nthe graph by simply <I>triangulating</I> the corresponding faces in an\narbitrary way. In fact the algorithm that has been implemented in\nC<SMALL>GAL</SMALL> has the property that it always returns a valid\n<I>triangulated</I> version of the dual graph of the segment Voronoi\ndiagram. By valid we mean that it contains the actual dual graph\n(i.e., the actual dual of the segment Voronoi diagram) and whenever\nthere are faces with more than three faces then they are\ntriangulated. The way that they are triangulated depends on the order\nof insertion of the sites in the diagram.\n<P>\n\nOne final remark has to be made with respect to the difference between\nthe set of <I>input sites</I> and the set of <I>output sites</I>. The\nset of input sites consists of the closed sites that the user inserts\nin the diagram. Since segment sites are treated as three objects,\ninternally our algorithm sees only points and open segments. As a\nresult, from the point of view of the algorithm, the input sites have\nno real meaning. What has real meaning is the set of sites that\ncorrespond to cells of the Voronoi diagrams and this is the set of\noutput sites.\n<P>\n\n<b>Degenerate dimensions.</b>\n\nThe dimension of the segment Voronoi diagram is in general 2. The\nexceptions to this rule are as follows:\n<UL>\n<LI>The dimension is <MATH><I>-1</I></MATH> if the segment Voronoi diagram contains no\n  sites.\n<LI>The dimension is <MATH><I>0</I></MATH> if the segment Voronoi diagram contains exactly\n  one (output) site.\n<LI>The dimension is <MATH><I>1</I></MATH> is the segment Voronoi diagram contains exactly\n  two (output) sites.\n</UL>\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>43.2&nbsp;&nbsp;&nbsp;Software Design</h2>\n\n<A NAME=\"sec:segvor2-design\"></A>\n<P>\n\nThe 2D segment Voronoi diagram class\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramTraits_2.html#Cross_link_anchor_1052\">SegmentVoronoiDiagramTraits_2</A>,<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramDataStructure_2.html#Cross_link_anchor_1048\">SegmentVoronoiDiagramDataStructure_2</A>&gt;</I>\nfollows the design of the triangulation package of C<SMALL>GAL</SMALL>. It is\nparametrized by two arguments:\n<UL>\n<LI>the <B>geometric traits</B> class. It provides the basic\n  geometric objects involved in the algorithm, such as sites, points\n  etc. It also provides the geometric predicates for the computation\n  of the segment Voronoi diagram, as well as some basic constructions\n  that can be used, for example, to visualize the diagram.\n  The geometric traits for the segment Voronoi diagram will be\n  discussed in more detail in the next section.\n<LI>the <B>segment Voronoi diagram data structure</B>. This is\n  essentially the same as the Apollonius graph data structure (discussed\n  in Chapter <A HREF=\"../Apollonius_graph_2/Chapter_main.html#sec:apollonius2-design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>), augmented with some\n  additional operations that are specific to segment Voronoi\n  diagrams. The corresponding concept is that of\n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramDataStructure_2.html#Cross_link_anchor_1048\">SegmentVoronoiDiagramDataStructure_2</A></I>, which in fact is a refinement\n  of the <I><A HREF=\"../Apollonius_graph_2_ref/Concept_ApolloniusGraphDataStructure_2.html#Cross_link_anchor_1071\">ApolloniusGraphDataStructure_2</A></I> concept. The class\n  <I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_966\">Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I> is a model of\n  the concept <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramDataStructure_2.html#Cross_link_anchor_1048\">SegmentVoronoiDiagramDataStructure_2</A></I>. A default value\n  for the corresponding template parameter is provided, so the user\n  does not need to specify it.\n</UL>\n<P>\n\n<b>Strongly intersecting sites and their representation.</b>\n\nAs we have mentioned above, the segment Voronoi diagram package of\nC<SMALL>GAL</SMALL> is designed to support the computation of the segment Voronoi\ndiagram even when the input segment sites are intersecting. This\nchoice poses certain issues for the design of the software\npackage. The major concern is the representation of the subsegments\nthat appear in the arrangement of the these sites, because the sites\nin the arrangement are the ones over which the diagram is actually\ndefined. A direct consequence of the choice of representation is the\nalgebraic degree of the predicates involved in the computation of the\nsegment Voronoi diagram, as well as the storage requirements for the\nsubsegments and points on <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> in the arrangement.\n<P>\n\nThe case of weakly intersecting sites does not require any special\ntreatment. We can simply represent points by their coordinates and\nsegments by their endpoints.\nIn the case of strongly intersecting sites,\nthe obvious choice to use the afore-mentioned representation\nhas severe disadvantages. Consider two\nstrongly intersecting segments <MATH><I>t<SUB>i</SUB></I></MATH> and <MATH><I>t<SUB>j</SUB></I></MATH>, whose endpoints have\nhomogeneous coordinates of size <MATH><I>b</I></MATH>. Their <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> point will\nhave homogeneous coordinates of bit size <MATH><I>6b+O(1)</I></MATH>. This effect can be\ncascaded, which implies that after inserting <MATH><I>k</I></MATH> (input) segments we\ncan arrive at having points of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> whose bit sizes are\nexponential with respect to <MATH><I>k</I></MATH>, i.e., their homogeneous coordinates\nwill have bit size <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Omega.gif\">(2<SUP>k</SUP>b)</I></MATH>. Not only the points of\n<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>, but also the adjacent subsegments will be represented by\nquantities of arbitrarily high bit size, and as a result we would not\nbe able to give a bound on the bit sizes of the coordinates of the\npoints of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>. As a result, we would not be able to give\na bound on the memory needed to store these coordinates. An equally\nimportant consequence is that we would also not be able to give a\nbound on the algebraic degree of the algebraic expressions involved in\nthe evaluation of the predicates.\n<P>\n\nSuch a behavior is obviously undesirable. For robustness, efficiency,\nand scalability purposes, it is critical that the bit size of the\nalgebraic expressions in the predicates does not depend on the input\nsize. For this reason, as well as for others to be discussed below,\nwe decided to represent sites in a implicit manner, which somehow\nencodes the history of their construction. In particular, we exploit\nthe fact that points of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> always lie on two input segments,\nand that segments that are not part of the input are always supported\nby input segments.\n<P>\n\nFor example, let us consider the configuration in\nFig. <A HREF=\"Chapter_main.html#fig:segvor2-siterep\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. We assume that the segments\n<MATH><I>t<SUB>i</SUB>=p<SUB>i</SUB>q<SUB>i</SUB></I></MATH>, <MATH><I>i=1,2,3</I></MATH>, are inserted in that order. Upon the\ninsertion of <MATH><I>t<SUB>2</SUB></I></MATH>, our algorithm will split the segment <MATH><I>t<SUB>1</SUB></I></MATH> into\nthe subsegments\n<MATH><I>p<SUB>1</SUB>s<SUB>1</SUB></I></MATH> and <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH>, then add <MATH><I>s<SUB>1</SUB></I></MATH>, and finally insert the\nsubsegments <MATH><I>p<SUB>2</SUB>s<SUB>1</SUB></I></MATH> and <MATH><I>s<SUB>1</SUB>q<SUB>2</SUB></I></MATH>. How do we represent the five new\nsites? <MATH><I>s<SUB>1</SUB></I></MATH> will be represented by its two defining segments <MATH><I>t<SUB>1</SUB></I></MATH>\nand <MATH><I>t<SUB>2</SUB></I></MATH>. The segment <MATH><I>p<SUB>1</SUB>s<SUB>1</SUB></I></MATH> will be represented by two segments, a\npoint, and a boolean. The first segment is <MATH><I>t<SUB>1</SUB></I></MATH>, which is always the\nsegment with the same support as the newly created segment. The second\nsegment is <MATH><I>t<SUB>2</SUB></I></MATH> and the point is <MATH><I>p<SUB>1</SUB></I></MATH>. The boolean indicates whether\nthe first endpoint of <MATH><I>p<SUB>1</SUB>s<SUB>1</SUB></I></MATH> is an input point; in this case the\nboolean is equal to <I>true</I>. The segment <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH> will also be\nrepresented by two segments, a point, and a boolean, namely, <MATH><I>t<SUB>1</SUB></I></MATH>\n(the supporting segment of <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH>), <MATH><I>t<SUB>2</SUB></I></MATH> and <I>false</I> (it is the\nsecond endpoint of <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH> that is an input point). Subsegments\n<MATH><I>p<SUB>2</SUB>s<SUB>2</SUB></I></MATH> and <MATH><I>s<SUB>2</SUB>q<SUB>2</SUB></I></MATH> are represented analogously.\nConsider now what happens when we insert <MATH><I>t<SUB>3</SUB></I></MATH>. The point \n<MATH><I>s<SUB>2</SUB></I></MATH> will again be represented by two segments, but not <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH> and\n<MATH><I>t<SUB>3</SUB></I></MATH>. In fact, it will be represented by <MATH><I>t<SUB>1</SUB></I></MATH> (the supporting\nsegment of <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH>) and <MATH><I>t<SUB>3</SUB></I></MATH>. <MATH><I>s<SUB>2</SUB>q<SUB>1</SUB></I></MATH> will be represented\nby two segments, a point, and a boolean (<MATH><I>t<SUB>1</SUB></I></MATH>, <MATH><I>t<SUB>3</SUB></I></MATH> and\n<I>false</I>), and similarly for <MATH><I>p<SUB>3</SUB>s<SUB>2</SUB></I></MATH> and <MATH><I>s<SUB>2</SUB>q<SUB>3</SUB></I></MATH>. On the other\nhand, both endpoints of <MATH><I>s<SUB>1</SUB>s<SUB>2</SUB></I></MATH> are non-input points. In such a\ncase we represent the segment by three input segments.\nMore precisely, <MATH><I>s<SUB>1</SUB>s<SUB>2</SUB></I></MATH> is represented by the segments <MATH><I>t<SUB>1</SUB></I></MATH> (the\nsupporting segment of <MATH><I>s<SUB>1</SUB>q<SUB>1</SUB></I></MATH>), <MATH><I>t<SUB>2</SUB></I></MATH> (it defines <MATH><I>s<SUB>1</SUB></I></MATH> along with\n<MATH><I>t<SUB>1</SUB></I></MATH>) and <MATH><I>t<SUB>3</SUB></I></MATH> (it defines <MATH><I>s<SUB>2</SUB></I></MATH> along with <MATH><I>t<SUB>1</SUB></I></MATH>).\n<P>\n\n<center>\n    <img border=1 src=\"./svd-rep.gif\" align=center\n    alt=\"Site representation\" title=\"Site representation\">\n    </center>\n  \n  \n    <font size=-1>\n  \n  <CENTER>\n    <B>Figure:&nbsp;&nbsp;</B>Site representation. The point <MATH><I>s<SUB>1</SUB></I></MATH> is represented by the\n      four points <MATH><I>p<SUB>1</SUB></I></MATH>, <MATH><I>q<SUB>1</SUB></I></MATH>, <MATH><I>p<SUB>2</SUB></I></MATH> and <MATH><I>q<SUB>2</SUB></I></MATH>. The segment <MATH><I>p<SUB>1</SUB>s<SUB>1</SUB></I></MATH> is\n      represented by the points <MATH><I>p<SUB>1</SUB></I></MATH>, <MATH><I>q<SUB>1</SUB></I></MATH>, <MATH><I>p<SUB>2</SUB></I></MATH>, <MATH><I>q<SUB>2</SUB></I></MATH> and a boolean\n      which is set to <I>true</I> to indicate that the first endpoint in\n      not a point of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>. The segment <MATH><I>s<SUB>1</SUB>s<SUB>2</SUB></I></MATH> is represented by\n      the six points: <MATH><I>p<SUB>1</SUB></I></MATH>, <MATH><I>q<SUB>1</SUB></I></MATH>, <MATH><I>p<SUB>2</SUB></I></MATH>, <MATH><I>q<SUB>2</SUB></I></MATH>, <MATH><I>p<SUB>3</SUB></I></MATH> and <MATH><I>q<SUB>3</SUB></I></MATH>. The\n      remaining (non-input) points and segments in the figure are\n      represented similarly.<A NAME=\"fig:segvor2-siterep\"></A>\n  </CENTER>\n  \n    </font>\n<P>\n\nThe five different presentations, two for points (coordinates; two\ninput segments) and three for segments (two input points; two input\nsegments, an input point and a boolean; three input segments),\nform a closed set of representations and thus represent\nany point of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> or subsegment regardless of the number of\ninput segments. Moreover, every point (input or <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>) has\nhomogeneous coordinates of bit size at most <MATH><I>3b+O(1)</I></MATH>.\nThe supporting lines of the segments (they are needed in some of\nthe predicates) have coefficients which are always of bit size\n<MATH><I>2b+O(1)</I></MATH>. As a result, the bit size of the expressions involved in\nour predicates will always be <MATH><I>O(b)</I></MATH>, independently of the\nsize of the input.\nThe <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramSite_2.html#Cross_link_anchor_1042\">SegmentVoronoiDiagramSite_2</A></I> concept encapsulates the ideas\npresented above. A site is represented in this concept by up to four\npoints and a boolean, or up to six points, depending on its type. The\nclass <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_site_2.html#Cross_link_anchor_1044\">Segment_Voronoi_diagram_site_2</A>&lt;K&gt;</I> implements this\nconcept.\n<P>\n\nEven this representation, however, has some degree of redundancy. The\nendpoint of a segment appears in both the representation of the (open)\nsegment site as well as the representation of the point site\nitself. The situation becomes even worse in the presence of strongly\nintersecting sites: a \npoint may appear in the representation of multiple subsegments and/or\npoints of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>. To avoid this redundancy, input points are\nstored in a container, and the various types of sites (input points\nand segments, points of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>, subsegments with one or two\npoints of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> as endpoints) only store handles to the points\nin the container. This is achieved by the\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_storage_site_2.html#Cross_link_anchor_1047\">Segment_Voronoi_diagram_storage_site_2</A>&lt;Gt&gt;</I> class which is a\nmodel of the corresponding concept:\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramStorageSite_2.html#Cross_link_anchor_1045\">SegmentVoronoiDiagramStorageSite_2</A></I>. This concept enforces a site\nto be represented by up to 6 handles (which are very lightweight\nobjects) instead of 6 points, which are, compared to handles of\ncourse, very heavy objects.\n<P>\n\n<b>Optimizing memory allocation.</b>\n\nThere are applications where we know beforehand that the input\nconsists of only weakly intersecting sites. In these cases the site\nrepresentation described above poses a significant overhead in the\nmemory requirements of our implementation: instead of representing\nsites with up to two points (or ultimately with to two handles), we\nrequire sites to store six points (respectively, six handles). To\navoid this overhead we have introduced two series of traits classes:\n<UL>\n<LI>One that supports the full-fledged sites, and is suitable when\n  the input consists of strongly intersecting sites. This series\n  consists of the \n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_2.html#Cross_link_anchor_1054\">Segment_Voronoi_diagram_traits_2</A>&lt;K,MTag&gt;</I> and\n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1058\">Segment_Voronoi_diagram_filtered_traits_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I> \n  classes.\n<LI>One that is customized for input that contain only weakly\n  intersecting sites. This series consists of the\n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_without_intersections_2.html#Cross_link_anchor_1056\">Segment_Voronoi_diagram_traits_without_intersections_2</A>&lt;K,MTag&gt;</I> and\n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_without_intersections_2.html#Cross_link_anchor_1060\">Segment_Voronoi_diagram_filtered_traits_without_intersections_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I>\n  classes.\n</UL>\nThe advantages of having different traits classes are as follows:\n<UL>\n<LI>When the user chooses to use one of the traits classes in the\n  second series we only store two handles per site. This implies a\n  reduction by a factor of three in the memory allocated per site with\n  respect to the first series of traits classes.\n<LI>In the case of the first series of traits classes, we can better\n  exploit the knowledge that have strongly intersecting sites, in\n  order to further apply geometric filters (see below) during the\n  evaluation of the predicates. On the contrary, if the second series\n  of traits classes is used, we can avoid geometric filtering tests\n  that have meaning only in the case of strongly intersecting sites.\n</UL>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>43.3&nbsp;&nbsp;&nbsp;The Geometric Traits</h2>\n\n<A NAME=\"sec:segvor2-traits\"></A>\n<P>\n\nThe predicates required for the computation of the segment Voronoi\ndiagram are rather complicated. It is not the purpose of this document to\ndiscuss them in detail. The interested reader may refer to Burnikel's\nthesis [<A HREF=\"../biblio.html#Biblio_b-ecvdl-96\">Bur96</A>], where it is shown that in the case of weakly\nintersecting sites represented in homogeneous coordinates of bit size\n<MATH><I>b</I></MATH>, the maximum bit size of the algebraic expressions involved in the\npredicates is <MATH><I>40b+O(1)</I></MATH>. Given our site representation given above we\ncan guarantee that even in the case of strongly intersecting sites,\nthe algebraic degree of the predicates remains <MATH><I>O(b)</I></MATH>, independently\nof the size of the input. What we want to focus in the remainder of\nthis section are the different kinds of filtering techniques that we\nhave employed in our implementation.\n<P>\n\n<b>Geometric filtering.</b>\n\nOur representation of sites is coupled very naturally, with what we\ncall <I>geometric filtering</I>. The technique\namounts to performing simple geometric tests exploiting the\nrepresentation of our data, as well as the geometric structure\ninherent in our problem, in order to evaluate predicates in seemingly\ndegenerate configurations. Geometric filtering can be seen as a\npreprocessing step before performing arithmetic filtering.\nRoughly speaking, by arithmetic filtering we mean that we first try to\nevaluate the predicates using a fixed-precision floating-point number\ntype (such as <TT>double</TT>), and at the same time keep error bounds on\nthe numerical errors of the computations we perform. If the numerical\nerrors are too big and do not permit us to evaluate the predicate, we\nswitch to an exact number type, and repeat the evaluation of the\npredicate. Geometric filtering can help by eliminating situations in\nwhich the arithmetic filter will fail, thus decreasing the number\nof times we need to evaluate a predicate using exact arithmetic.\n<P>\n\nTo illustrate the application and effectiveness of this approach,\nlet us consider a very simple example usage.\nSuppose we want to determine if two non-input points are\nidentical (we assume here that the input sites are represented by\n<I>double</I>s). In order to do that we need to compute their\ncoordinates and <A HREF=\"../NumberTypeSupport_ref/Function_compare.html#Cross_link_anchor_1339\">compare</A> them. If the two points are identical, the\nanswer to our question using <I>double</I> arithmetic may be \nwrong (due to numerical errors), in which case we will have to reside\nto the more expensive exact computation. Instead, before testing the\ncoordinates for equality, we can use the representation of the points\nto potentially answer the question. More specifically, and this is the\ngeometric filtering part of the computation, we can first\ntest if the defining segments of the two points are the same. If they\nare not, then we proceed to comparing their coordinates as\nusual. Testing the defining segments for equality does not involve any\narithmetic operations on the input, but rather only comparisons on\n<I>double</I>s. By performing this very simple test we avoid a\nnumerically difficult computation, which could be performed\nthousands of times during the computation of a Voronoi diagram.\n<P>\n\nGeometric filtering has been implemented in all our models of the\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramTraits_2.html#Cross_link_anchor_1052\">SegmentVoronoiDiagramTraits_2</A></I> concept. These models are the\nclasses:\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_2.html#Cross_link_anchor_1054\">Segment_Voronoi_diagram_traits_2</A>&lt;K,MTag&gt;</I>,\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_without_intersections_2.html#Cross_link_anchor_1056\">Segment_Voronoi_diagram_traits_without_intersections_2</A>&lt;K,MTag&gt;</I>,\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1058\">Segment_Voronoi_diagram_filtered_traits_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I> and\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_without_intersections_2.html#Cross_link_anchor_1060\">Segment_Voronoi_diagram_filtered_traits_without_intersections_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I>.\n<P>\n\n<b>Arithmetic filtering.</b>\n\nAs mentioned above, performing computations with exact arithmetic\ncan be very costly. For this reason we have devoted considerable\neffort in implementing different kinds of arithmetic filtering\nmechanisms. Presently, there two ways of performing arithmetic\nfiltering for the predicates involved in the computation of\nsegment Voronoi diagrams:\n<OL>\n<LI>The user can define his/her kernel using as number type, a\n  number type of the form <I><A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;CT,ET&gt;</I>. Then this\n  kernel can be entered as the first template parameter in the\n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;K,MTag&gt;</I> or\n  <I>Segment_Voronoi_diagram_with_intersections_2&lt;K,MTag&gt;</I> class.\n<LI>The user can define up to three different kernels <I>CK</I>,\n  <I>FK</I> and <I>EK</I> (default values are provided for most\n  parameters). The first kernel <I>CK</I> is used only for\n  constructions. The second kernel <I>FK</I> is the filtering kernel:\n  the traits class will attempt to compute the predicates using this\n  kernel. If the filtering kernel fails to successfully compute a\n  predicate, the exact kernel <I>EK</I> will be used. These three\n  kernels are then used in the \n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1058\">Segment_Voronoi_diagram_filtered_traits_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I> and\n  <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_without_intersections_2.html#Cross_link_anchor_1060\">Segment_Voronoi_diagram_filtered_traits_without_intersections_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I>\n  classes, which have been implemented using the\n  <I><A HREF=\"../Kernel_23_ref/Class_Filtered_predicate.html#Cross_link_anchor_16\">Filtered_predicate</A>&lt;EP,FP&gt;</I> mechanism.\n</OL>\nOur experience so far has shown that for all reasonable and valid\nvalues of the template parameters, the second method for arithmetic\nfiltering is more efficient among the two.\n<P>\n\nLet's consider once more the classes\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;K,MTag&gt;</I> and \n<I>Segment_Voronoi_diagram_with_intersections_2&lt;K,MTag&gt;</I>.\nThe template parameter <I>MTag</I> provides another degree of freedom\nto the user, who can indicate the type of arithmetic operations to\nbe used in the evaluation of the predicates. More specifically, in\nboth classes, <I>MTag</I> can be <I><A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A></I>, in\nwhich case the predicates will be evaluated using all four basic\narithmetic operations plus <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> roots; this requires, of course,\nthat the number type used in the kernel <I>K</I> supports these\noperations exactly. The second choices are <I><A HREF=\"../NumberTypeSupport_ref/Class_Field_tag.html#Cross_link_anchor_1349\">CGAL::Field_tag</A></I> for\nthe <I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;K,MTag&gt;</I> class, and\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A></I> for the\n<I>Segment_Voronoi_diagram_with_intersections_2&lt;K,MTag&gt;</I>\nclass. In the first case we indicate that we want the predicates to be\ncomputed using only the four basic arithmetic operations, whereas in\nthe second case we evaluate the predicates using only ring operations.\nAgain, for the predicates to be evaluated correctly, the number type\nused in the kernel <I>K</I> must support the corresponding operations\nexactly.\n<P>\n\nThe semantics for the template parameters <I>CM</I>, <I>FM</I> and\n<I>EM</I> in the\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1058\">Segment_Voronoi_diagram_filtered_traits_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I> and \n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_without_intersections_2.html#Cross_link_anchor_1060\">Segment_Voronoi_diagram_filtered_traits_without_intersections_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I>\nclasses are analogous. With each of these template parameters we can\ncontrol the type of arithmetic operations that are going to be used in\ncalculations involving each of the corresponding kernels <I>CK</I>,\n<I>FK</I> and <I>EK</I>. When the\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1058\">Segment_Voronoi_diagram_filtered_traits_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I> is\nused the possible values for <I>CM</I>, <I>FM</I> and <I>EM</I> are\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A></I> and <I><A HREF=\"../NumberTypeSupport_ref/Class_Field_tag.html#Cross_link_anchor_1349\">CGAL::Field_tag</A></I>, whereas if the \n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_without_intersections_2.html#Cross_link_anchor_1060\">Segment_Voronoi_diagram_filtered_traits_without_intersections_2</A>&lt;CK,CM,EK,EM,FK,FM&gt;</I>\nclass is used, the possible values are <I><A HREF=\"../NumberTypeSupport_ref/Class_Sqrt_field_tag.html#Cross_link_anchor_1415\">CGAL::Sqrt_field_tag</A></I> and\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Ring_tag.html#Cross_link_anchor_1407\">CGAL::Ring_tag</A></I>. The semantics are the same as in the case of the \n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;K,MTag&gt;</I> and \n<I>Segment_Voronoi_diagram_with_intersections_2&lt;K,MTag&gt;</I> classes.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>43.4&nbsp;&nbsp;&nbsp;The segment Voronoi diagram hierarchy</h2>\n\n<A NAME=\"sec:segvor2-hierarchy\"></A>\n<P>\n\nThe\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_hierarchy_2.html#Cross_link_anchor_1062\">Segment_Voronoi_diagram_hierarchy_2</A>&lt;<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramTraits_2.html#Cross_link_anchor_1052\">SegmentVoronoiDiagramTraits_2</A>,   SSTag, <A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramDataStructure_2.html#Cross_link_anchor_1048\">SegmentVoronoiDiagramDataStructure_2</A>&gt;</I> class is the analogue\nof the <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A></I> or the\n<I><A HREF=\"../Apollonius_graph_2_ref/Class_Apollonius_graph_hierarchy_2.html#Cross_link_anchor_1081\">Apollonius_graph_hierarchy_2</A></I> classes, applied to the segment\nVoronoi diagram. It consists of a hierarchy of\nsegment Voronoi diagrams constructed in a manner analogous to the\nDelaunay hierarchy by Devillers [<A HREF=\"../biblio.html#Biblio_cgal:d-dh-02\">Dev02</A>]. Unlike the\ntriangulation hierarchy or the Apollonius graph hierarchy, the\nsituation here is more complicated because of two factors: firstly,\nsegments are treated as three objects instead of one (the two\nendpoints and the interior of the segments), and secondly, the\npresence of strongly intersecting sites complicates significantly the\nway the hierarchy is constructed. The interested reader may refer to\nthe paper by Karavelas [<A HREF=\"../biblio.html#Biblio_cgal:k-reisv-04\">Kar04</A>] for the details of the\nconstruction of the hierarchy.\nAnother alternative is to have a hybrid hierarchy that consists of the\nsegment Voronoi diagram at the bottom-most level and point Voronoi\ndiagrams at all other levels. This choice seems to work very well in\npractice , primarily because it avoids the overhead of maintaining a\nVoronoi diagram for segments at the upper levels of the\nhierarchy. However, it seems much less likely to be possible to give\nany theoretical guarantees for its performance, in contrast to the\nhierarchy with segment Voronoi diagrams at all levels\n(cf. [<A HREF=\"../biblio.html#Biblio_cgal:k-reisv-04\">Kar04</A>]). The user can choose between the two\ntypes of hierarchies by means of the template parameter\n<I>SSTag</I>. If <I>SSTag</I> is set to <I>false</I> (which is also the\ndefault value), the upper levels of the hierarchy consist of point\nVoronoi diagrams. If <I>SSTag</I> is set to <I>true</I>, we have segment\nVoronoi diagrams at all levels of the hierarchy.\n<P>\n\nThe class\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_hierarchy_2.html#Cross_link_anchor_1062\">Segment_Voronoi_diagram_hierarchy_2</A>&lt;<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramTraits_2.html#Cross_link_anchor_1052\">SegmentVoronoiDiagramTraits_2</A>,   SSTag, <A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramDataStructure_2.html#Cross_link_anchor_1048\">SegmentVoronoiDiagramDataStructure_2</A>&gt;</I>\nhas exactly the same interface and functionality as the\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>&lt;<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramTraits_2.html#Cross_link_anchor_1052\">SegmentVoronoiDiagramTraits_2</A>,<A HREF=\"../Segment_Voronoi_diagram_2_ref/Concept_SegmentVoronoiDiagramDataStructure_2.html#Cross_link_anchor_1048\">SegmentVoronoiDiagramDataStructure_2</A>&gt;</I>\nclass. Using the segment Voronoi diagram hierarchy involves an\nadditional cost in space and time for maintaining the hierarchy. Our\nexperiments have shown that it usually pays off to use the hierarchy\nfor inputs consisting of more than about 1,000 sites.\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>43.5&nbsp;&nbsp;&nbsp;Examples</h2>\n\n<A NAME=\"sec:segvor2-examples\"></A>\n<P>\n\n<h3>43.5.1&nbsp;&nbsp;&nbsp;First example</h3>\n<P>\n\nThe following example shows to use the segment Voronoi diagram traits\nin conjunction with the <I><A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>&lt;CT,ET&gt;</I> mechanism. In\naddition it shows how to use a few of the iterators provided by the\n<I><A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A></I> class in order to count a few\nsite-related quantities.\n<P>\n\n<pre class=\"ExampleCode\">// file: svd-count-sites.C\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\n// define the number type\n#  include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>.h&gt;\n#  include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A>.h&gt;\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1403\">CGAL::Quotient</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1399\">CGAL::MP_Float</A>&gt;  EFT;\n\n// define the kernel\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1352\">Filtered_exact</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Filtered_exact.html#Cross_link_anchor_1351\">CGAL::Filtered_exact</A>&lt;double,EFT&gt;  FT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;FT&gt;        <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\n\n// typedefs for the traits and the algorithm\n#include &lt;CGAL/<A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_2.html#Cross_link_anchor_1054\">Segment_Voronoi_diagram_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>.h&gt;\n\ntypedef <A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_2.html#Cross_link_anchor_1053\">CGAL::Segment_Voronoi_diagram_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Gt;\ntypedef <A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1040\">CGAL::Segment_Voronoi_diagram_2</A>&lt;Gt&gt;             SVD2;\n\nusing namespace std;\n\nint main() {\n  ifstream ifs(&quot;data/sitesx.cin&quot;);\n  assert( ifs );\n\n  SVD2          svd;\n  SVD2::Site_2  site;\n\n  while ( ifs &gt;&gt; site ) { svd.insert( site ); }\n\n  ifs.close();\n\n  assert( svd.is_valid(true, 1) );\n  cout &lt;&lt; endl &lt;&lt; endl;\n\n  // print the number of input and output sites\n  cout &lt;&lt; &quot;# of input sites : &quot; &lt;&lt; svd.number_of_input_sites() &lt;&lt; endl;\n  cout &lt;&lt; &quot;# of output sites: &quot; &lt;&lt; svd.number_of_output_sites() &lt;&lt; endl;\n\n  unsigned int n_ipt(0), n_iseg(0), n_opt(0), n_oseg(0), n_ptx(0);\n\n  // count the number of input points and input segments\n  SVD2::Input_sites_iterator iit;\n  for (iit = svd.input_sites_begin(); iit != svd.input_sites_end(); ++iit)\n    {\n      if ( iit-&gt;is_point() ) { n_ipt++; } else { n_iseg++; }\n    }\n\n  // count the number of output points and output segments, as well\n  // as the number of points that are points of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of pairs\n  // of strongly intersecting sites\n  SVD2::Output_sites_iterator oit;\n  for (oit = svd.output_sites_begin(); oit != svd.output_sites_end(); ++oit)\n    {\n      if ( oit-&gt;is_segment() ) { n_oseg++; } else {\n        n_opt++;\n        if ( !oit-&gt;is_input() ) { n_ptx++; }\n      }\n    }\n\n  cout &lt;&lt; endl &lt;&lt; &quot;# of input segments:  &quot; &lt;&lt; n_iseg &lt;&lt; endl;\n  cout &lt;&lt; &quot;# of input points:    &quot; &lt;&lt; n_ipt &lt;&lt; endl &lt;&lt; endl;\n  cout &lt;&lt; &quot;# of output segments: &quot; &lt;&lt; n_oseg &lt;&lt; endl;\n  cout &lt;&lt; &quot;# of output points:   &quot; &lt;&lt; n_opt &lt;&lt; endl &lt;&lt; endl;\n  cout &lt;&lt; &quot;# of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> points: &quot; &lt;&lt; n_ptx &lt;&lt; endl;\n\n  return 0;\n}\n</pre>\n<P>\n\n<h3>43.5.2&nbsp;&nbsp;&nbsp;Second example</h3>\n<P>\n\nThe following example shows how to use the segment Voronoi diagram\nhierarchy along with the filtered traits class that supports\nintersecting sites.\n<P>\n\n<pre class=\"ExampleCode\">// file: svd-filtered-traits.C\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\n// example that uses the filtered traits and\n// the segment Voronoi diagram hierarchy\n\n// choose the kernel\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n\nstruct Rep : public <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; {};\n\n// typedefs for the traits and the algorithm\n#include &lt;CGAL/<A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_hierarchy_2.html#Cross_link_anchor_1062\">Segment_Voronoi_diagram_hierarchy_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1058\">Segment_Voronoi_diagram_filtered_traits_2</A>.h&gt;\n\nstruct Gt\n  : public <A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_filtered_traits_2.html#Cross_link_anchor_1057\">CGAL::Segment_Voronoi_diagram_filtered_traits_2</A>&lt;Rep&gt; {};\n\ntypedef <A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_hierarchy_2.html#Cross_link_anchor_1061\">CGAL::Segment_Voronoi_diagram_hierarchy_2</A>&lt;Gt&gt;  SVD2;\n\n\nint main()\n{\n  std::ifstream ifs(&quot;data/sites.cin&quot;);\n  assert( ifs );\n\n  SVD2          svd;\n  SVD2::Site_2  site;\n\n  // read the sites and insert them in the segment Voronoi diagram\n  while ( ifs &gt;&gt; site ) {\n    svd.insert(site);\n  }\n\n  // validate the segment Voronoi diagram\n  assert( svd.is_valid(true, 1) );\n\n  return 0;\n}\n\n\n</pre>\n<P>\n\n<h3>43.5.3&nbsp;&nbsp;&nbsp;Third example</h3>\n<P>\n\nThe following example demonstrates how to recover the defining sites\nfor the edges of the Voronoi diagram.\n<P>\n\n<pre class=\"ExampleCode\">// file: svd-voronoi-vertices.C\n#include &lt;CGAL/basic.h&gt;\n\n// standard includes\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n\n// define the kernel\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_12\">Filtered_kernel</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;    CK;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_11\">CGAL::Filtered_kernel</A>&lt;CK&gt;         <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\n\n// typedefs for the traits and the algorithm\n#include &lt;CGAL/<A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_2.html#Cross_link_anchor_1054\">Segment_Voronoi_diagram_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1041\">Segment_Voronoi_diagram_2</A>.h&gt;\n\ntypedef <A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_traits_2.html#Cross_link_anchor_1053\">CGAL::Segment_Voronoi_diagram_traits_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Gt;\ntypedef <A HREF=\"../Segment_Voronoi_diagram_2_ref/Class_Segment_Voronoi_diagram_2.html#Cross_link_anchor_1040\">CGAL::Segment_Voronoi_diagram_2</A>&lt;Gt&gt;             SVD2;\n\nusing namespace std;\n\nint main()\n{\n  ifstream ifs(&quot;data/sites2.cin&quot;);\n  assert( ifs );\n\n  SVD2          svd;\n  SVD2::Site_2  site;\n\n  // read the sites from the stream and insert them in the diagram\n  while ( ifs &gt;&gt; site ) { svd.insert( site ); }\n\n  ifs.close();\n\n  // validate the diagram\n  assert( svd.is_valid(true, 1) );\n  cout &lt;&lt; endl &lt;&lt; endl;\n\n  /*\n  // now walk through the non-infinite edges of the dual (which are\n  // dual to the edges in the Voronoi diagram) and print the sites\n  // defining each Voronoi edge.\n  //\n  // Each oriented Voronoi edge (horizontal segment in the figure\n  // below) is defined by four sites A, B, C and D.\n  //\n  //     \\                     /\n  //      \\         B         /\n  //       \\                 /\n  //     C  -----------------  D\n  //       /                 \\\n  //      /         A         \\\n  //     /                     \\\n  //\n  // The sites A and B define the (oriented) <A HREF=\"../Kernel_23_ref/Function_bisector.html#Cross_link_anchor_161\">bisector</A> on which the\n  // edge lies whereas the sites C and D, along with A and B define\n  // the two endpoints of the edge. These endpoints are the Voronoi\n  // vertices of the triples A, B, C and B, A, D.\n  // If one of these vertices is the vertex at infinity the string\n  // &quot;infinite vertex&quot; is printed; the corresponding Voronoi edge is\n  // actually a stright-line or parabolic ray.\n  // The sites below are printed in the order A, B, C, D.\n  */\n\n  string inf_vertex(&quot;infinite vertex&quot;);\n  char vid[] = {'A', 'B', 'C', 'D'};\n\n  SVD2::Finite_edges_iterator eit = svd.finite_edges_begin();\n  for (int k = 1; eit != svd.finite_edges_end(); ++eit, ++k) {\n    SVD2::Edge e = *eit;\n    // get the vertices defining the Voronoi edge\n    SVD2::Vertex_handle v[] = { e.first-&gt;vertex( svd.ccw(e.second) ),\n                                e.first-&gt;vertex( svd.cw(e.second) ),\n                                e.first-&gt;vertex( e.second ),\n                                e.first-&gt;mirror_vertex(e.second) };\n\n    cout &lt;&lt; &quot;--- Edge &quot; &lt;&lt; k &lt;&lt; &quot; ---&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; 4; i++) {\n      // check if the vertex is the vertex at infinity; if yes, print\n      // the corresponding string, otherwise print the site\n      if ( svd.is_infinite(v[i]) ) {\n        cout &lt;&lt; vid[i] &lt;&lt; &quot;: &quot; &lt;&lt; inf_vertex &lt;&lt; endl;\n      } else {\n        cout &lt;&lt; vid[i] &lt;&lt; &quot;: &quot; &lt;&lt; v[i]-&gt;site() &lt;&lt; endl;\n      }\n    }\n    cout &lt;&lt; endl;\n  }\n\n  return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Segment_Voronoi_diagram_2_ref/Chapter_intro.html\">2D Segment Voronoi Diagrams</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_43!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38747.0}