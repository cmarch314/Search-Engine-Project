{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Well Behaved Classes The moniker for this code example is WellBehavedClasses Background As we ve talked about previously C classes provide a way to define new data types There is no deep distinction between user defined types and built in types we can build our own types to have all of the same flexibility that the built in types have Additionally classes do not automatically introduce extra cost into our program in terms of memory or time unless we do things with them that introduce that cost They do however provide a design win the ability to encapsulate a set of data along with a set of operations that can safely manipulate that data It s often the case in programming that we have to trade away some performance in order to achieve design clarity C classes if we use them carefully allow us to have both However in order to use C classes effectively it becomes necessary to do a few things that will seem foreign if you ve seen classes in most of the other programming languages that offer them As usual C gives us more knobs that we can turn to control efficiency and design flexibility at the cost of additional complexity And in some cases turning those knobs appropriately is paramount not only for achieving performance but also for achieving correctness What is a well behaved class This example explores how to build what I call a well behaved class The term well behaved is a little bit loose but here are some things that objects of a well behaved class do They clean up after themselves automatically when they die meaning that deleting an object is all that needs to be done to ensure that no other resources memory open files etc associated with that object are leaked They can be passed to functions by value and preserve the usual semantics i e changing the object within the function does not have any effect on the original They can be assigned into existing objects of the same type with the appropriate copying and cleanup again done automatically They can be const while preserving the ability to perform whatever operations do not violate the promise of const i e operations that do not change the publicly observable state of the object They shouldn t do unnecessary work or use memory or other resources unnecessarily They should be efficient Note that the term unnecessary is in the eye of the beholder the goal isn t always to be absolutely as fast as possible when that goal trades off against other desirable properties like readability maintainability or separation of concerns The std string class in the C standard library has these properties so we can expect it to be as clean and easy to use as an int albeit potentially slower since string operations like concatenation obviously take more time than say integer addition We should want the same for our classes Our ArrayList class In this example we build an ArrayList class which very roughly parallels the behavior of a class built into the C standard library which we ll explore in detail relatively soon called std vector Our ArrayList is an array based list it stores a sequence of elements indexed consecutively starting at zero providing constant time access to any element given its index Unlike an array though our ArrayList provides a few conveniences It handles all of the necessary dynamic array allocation and deallocation At any given time an ArrayList contains one dynamically allocated array It keeps track of the capacity of the underlying array as well as tracking how many elements are currently being stored in the list which we ll call the ArrayList s size If there are n elements stored in the list they will always occupy the first n cells of the underlying array but the underlying array may have empty space available As elements are added and the underlying array fills the ArrayList allocates new arrays and copies existing elements into them so there is no theoretical limit on how many elements that can be stored though there is obviously a practical limit since machines only have so much memory Being well behaved we expect to be able to do many things with our ArrayList once it s built without having to worry too much about confusing error prone details We should expect to be able to Allocate ArrayLists statically or dynamically Add elements to ArrayLists without worrying about running out of space because of the array reallocations that are done internally when the arrays fill Pass ArrayLists by value or by reference while preserving the appropriate semantics Declare const ArrayLists whose elements we can read but not write These are the things we want to achieve In order to get there though we ll need to learn some features of C that we haven t seen yet The Big Three Classes whose objects manage resources that live outside of themselves such as dynamically allocated memory open files open connections to networks etc generally require three new kinds of functions to be implemented A destructor We ve seen previously that constructors are called just after an object is created their job is to initialize the newly created object Destructors are called just before an object s death and they perform whatever cleanup is necessary aside from the destruction of the member variables which is handled automatically A copy constructor which is used to initialize new objects that are created as copies of existing ones e g because an object has been passed by value or because one object has been used to explicitly initialize another An overloaded assignment operator which is called every time an existing object is assigned into another existing object Note that this is distinct from what a copy constructor does copy constructors initialize newly created objects while the assignment operator is invoked when you have two objects already and one is being assigned into the other These three functions together are sometimes called The Big Three because the need to write one of them usually implies the need to write all three of them and because they play a vital role in allowing many kinds of objects to manage resources properly Not all classes require the Big Three because defaults are generated if you don t write them Any class whose member variables are all of well behaved classes will generally work just fine because the defaults are sensible in that case By default destroying an object destroys its member variables Constructors initialize member variables in the order they re listed in the class declaration just before the body of the constructor is executed Destructors destroy them in the opposite order just after the body of the destructor is executed A default destructor has an empty body meaning it only destroys the member variables But if those member variables are all well behaved they clean up any necessary resources automatically when they die so there s nothing else the destructor needs to do By default creating a copy of an object copies its member variables one by one into the new object If those member variables are all well behaved they support the appropriate copying semantics already so nothing special needs to be done By default assigning an object assigns its member variables one by one from the source object into the target object in place of the original member variables in the target object If those member variables are well behaved they support assignment already Most of the built in types in C can be thought of as well behaved Pointers are a notable exception though because destroying a pointer doesn t destroy what the pointer points to For this reason our ArrayList class requires the Big Three because the dynamically allocated arrays require manual management we ll manually create them with the new operator and destroy them with delete Placing that manual memory management into the Big Three means that code that uses our ArrayList class can remain blissfully unaware of these details while still achieving the kind of performance it could achieve by managing the arrays itself That s a big win indeed A couple of additional notes I ve introduced a couple of additional twists here that we didn t cover in lecture these are things we ll see again later but they fit nicely into this example so I ve extended it to include them Note also that the Big Three became the Big Four or Five in the C 11 standard because of the inclusion of a new feature called moving I left that out of this example because it s a performance optimization but isn t something necessary for a class to be considered well behaved We may see move constructors and move assignment operators later in this course but we ll wait on it all things in time The code The official moniker for this code example is WellBehavedClasses so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code WellBehavedClasses to download the code example into your project directory s app directory Alternatively you can click the link to the tarball below WellBehavedClasses tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/WellBehavedClasses/", "title": "ics 45c fall 2014, code example: well-behaved classes", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Well-Behaved Classes</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Well-Behaved Classes</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>WellBehavedClasses</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>As we've talked about previously, C++ classes provide a way to define new data types.  There is no deep distinction between user-defined types and built-in types; we can build our own types to have all of the same flexibility that the built-in types have.  Additionally, classes do not automatically introduce extra cost into our program &mdash; in terms of memory or time &mdash; unless we do things with them that introduce that cost.  They do, however, provide a design win: the ability to encapsulate a set of data along with a set of operations that can safely manipulate that data.  It's often the case in programming that we have to trade away some performance in order to achieve design clarity; C++ classes (if we use them carefully) allow us to have both.</p>\r\n\r\n<p>However, in order to use C++ classes effectively, it becomes necessary to do a few things that will seem foreign if you've seen classes in most of the other programming languages that offer them.  As usual, C++ gives us more knobs that we can turn to control efficiency and design flexibility, at the cost of additional complexity.  And, in some cases, turning those knobs appropriately is paramount not only for achieving performance, but also for achieving correctness.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What is a \"well-behaved\" class?</p>\r\n\r\n<p>This example explores how to build what I call a \"well-behaved\" class.  The term \"well-behaved\" is a little bit loose, but here are some things that objects of a well-behaved class do.</p>\r\n\r\n<ul>\r\n  <li>They clean up after themselves automatically when they die, meaning that deleting an object is all that needs to be done to ensure that no other resources (memory, open files, etc.) associated with that object are leaked.</li>\r\n  <li>They can be passed to functions by value and preserve the usual semantics (i.e., changing the object within the function does not have any effect on the original).</li>\r\n  <li>They can be assigned into existing objects of the same type, with the appropriate copying and cleanup, again, done automatically.</li>\r\n  <li>They can be <b>const</b>, while preserving the ability to perform whatever operations do not violate the promise of <b>const</b> (i.e., operations that do not change the publicly observable state of the object).</li>\r\n  <li>They shouldn't do unnecessary work or use memory or other resources unnecessarily.  They should be efficient.  (Note that the term \"unnecessary\" is in the eye of the beholder; the goal isn't always to be absolutely as fast as possible, when that goal trades off against other desirable properties like readability, maintainability, or separation of concerns.)</li>\r\n</ul>\r\n\r\n<p>The <b>std::string</b> class in the C++ standard library has these properties, so we can expect it to be as clean and easy-to-use as an <b>int</b> &mdash; albeit potentially slower, since string operations like concatenation obviously take more time than, say, integer addition.  We should want the same for our classes.</li>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Our ArrayList class</p>\r\n\r\n<p>In this example, we build an ArrayList class, which very roughly parallels the behavior of a class built into the C++ standard library (which we'll explore in detail relatively soon) called <b>std::vector</b>.  Our ArrayList is an array-based list; it stores a sequence of elements, indexed consecutively starting at zero, providing constant-time access to any element given its index.  Unlike an array, though, our ArrayList provides a few conveniences:</p>\r\n\r\n<ul>\r\n  <li>It handles all of the necessary dynamic array allocation and deallocation.  At any given time, an ArrayList contains one dynamically-allocated array.</li>\r\n  <li>It keeps track of the capacity of the underlying array, as well as tracking how many elements are currently being stored in the list (which we'll call the ArrayList's <i>size</i>).  If there are <i>n</i> elements stored in the list, they will always occupy the first <i>n</i> cells of the underlying array, but the underlying array may have empty space available.</li>\r\n  <li>As elements are added and the underlying array fills, the ArrayList allocates new arrays and copies existing elements into them, so there is no theoretical limit on how many elements that can be stored (though there is obviously a practical limit, since machines only have so much memory).</li>\r\n</ul>\r\n\r\n<p>Being well-behaved, we expect to be able to do many things with our ArrayList once it's built, without having to worry too much about confusing, error-prone details.  We should expect to be able to:</p>\r\n\r\n<ul>\r\n  <li>Allocate ArrayLists statically or dynamically.</li>\r\n  <li>Add elements to ArrayLists without worrying about running out of space (because of the array reallocations that are done internally when the arrays fill).</li>\r\n  <li>Pass ArrayLists by value or by reference, while preserving the appropriate semantics.</li>\r\n  <li>Declare <b>const</b> ArrayLists, whose elements we can read but not write.</li>\r\n</ul>\r\n\r\n<p>These are the things we want to achieve.  In order to get there, though, we'll need to learn some features of C++ that we haven't seen yet.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">\"The Big Three\"</p>\r\n\r\n<p>Classes whose objects manage resources that live outside of themselves &mdash; such as dynamically-allocated memory, open files, open connections to networks, etc. &mdash; generally require three new kinds of functions to be implemented.</p>\r\n\r\n<ul>\r\n  <li>A <i>destructor</i>.  We've seen previously that <i>constructors</i> are called just after an object is created; their job is to initialize the newly-created object.  Destructors are called just before an object's death, and they perform whatever cleanup is necessary (aside from the destruction of the member variables, which is handled automatically).</li>\r\n  <li>A <i>copy constructor</i>, which is used to initialize new objects that are created as copies of existing ones (e.g., because an object has been passed by value, or because one object has been used to explicitly initialize another).</li>\r\n  <li>An <i>overloaded assignment operator</i>, which is called every time an existing object is assigned into another existing object.  Note that this is distinct from what a copy constructor does; copy constructors initialize <i>newly-created</i> objects, while the assignment operator is invoked when you have two objects already, and one is being assigned into the other.</li>\r\n</ul>\r\n\r\n<p>These three functions, together, are sometimes called <i>The Big Three</i>, because the need to write one of them usually implies the need to write all three of them, and because they play a vital role in allowing many kinds of objects to manage resources properly.</p>\r\n\r\n<p>Not all classes require the Big Three, because defaults are generated if you don't write them.  Any class whose member variables are all of well-behaved classes will generally work just fine, because the defaults are sensible in that case:</p>\r\n\r\n<ul>\r\n  <li>By default, destroying an object destroys its member variables.  Constructors initialize member variables in the order they're listed in the class declaration, just before the body of the constructor is executed.  Destructors destroy them in the opposite order, just <i>after</i> the body of the destructor is executed.  A default destructor has an empty body, meaning it <i>only</i> destroys the member variables.  But if those member variables are all well-behaved, they clean up any necessary resources automatically when they die, so there's nothing else the destructor needs to do.</li>\r\n  <li>By default, creating a copy of an object copies its member variables, one by one, into the new object.  If those member variables are all well-behaved, they support the appropriate copying semantics already, so nothing special needs to be done.</li>\r\n  <li>By default, assigning an object assigns its member variables one by one from the source object into the target object, in place of the original member variables in the target object.  If those member variables are well-behaved, they support assignment already.</li>\r\n</ul>\r\n\r\n<p>Most of the built-in types in C++ can be thought of as well-behaved.  Pointers are a notable exception, though, because destroying a pointer doesn't destroy what the pointer points to.  For this reason, our ArrayList class requires the Big Three, because the dynamically-allocated arrays require manual management &mdash; we'll manually create them with the <b>new</b> operator and destroy them with <b>delete[ ]</b>.  Placing that manual memory management into the Big Three means that code that uses our ArrayList class can remain blissfully unaware of these details, while still achieving the kind of performance it could achieve by managing the arrays itself.  That's a big win indeed.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">A couple of additional notes</p>\r\n\r\n<p>I've introduced a couple of additional twists here that we didn't cover in lecture; these are things we'll see again later, but they fit nicely into this example, so I've extended it to include them.</p>\r\n\r\n<p>Note, also, that the Big Three became the Big Four or Five in the C++11 standard, because of the inclusion of a new feature called <i>moving</i>.  I left that out of this example, because it's a performance optimization, but isn't something necessary for a class to be considered well-behaved.  We may see <i>move constructors</i> and <i>move assignment operators</i> later in this course, but we'll wait on it; all things in time.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>WellBehavedClasses</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code WellBehavedClasses</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"WellBehavedClasses.tar.gz\">WellBehavedClasses.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 22.0}