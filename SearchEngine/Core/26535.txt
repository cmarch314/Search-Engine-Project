{"text": "ICS 32 Winter 2 15 News Course Reference Schedule Project Guide Code Examples About Alex ICS 32 Winter 2 15 Code Example Protocols Background Protocols When you write a program that will store data in a file and read it back again later you have to decide on a file format which specifies in detail what the data will look like once it s stored in the file There are many existing file formats like the JPEG format for image files but you can define your own too if a pre existing format is not appropriate for your particular use When you write programs that communicate with one another using sockets you have a similar problem the program on each side of the connection will be sending data to the other Without an agreement about what that data will look the data sent from one program won t make sense to the other So when programs communicate across sockets you will always need them to agree on a protocol which specifies what each program will send and expect to receive As with file formats there are well known protocols already defined for specific purposes like the HTTP protocol that describes how data is transferred over the web or the SMTP protocol that is used to send email but you can also define your own protocol if you need something specific for your particular use What s important is that both programs implement the same protocol and that each program knows its role in that protocol The Yackety protocol In lecture we wrote a client program that interacted with a tiny Internet based service I built called Yackety similar to Twitter which allows for the broadcasting of short messages Yackety itself is a server program other programs can interact with it by connecting to it via a socket and then sending and receiving text in a predefined format called the Yackety protocol The Yackety protocol like other protocols governs what each program a Yackety client and the Yackety server is required to send and can expect to receive in return The Yackety protocol is made up of lines of text send back and forth between the client and the server Each line is terminated with a newline sequence which is made up of the Python string r n The protocol is as follows The client connects to the Yackety serverThe Yackety server accepts the connectionThe client sends a line consisting of the word YACKETY HELLO followed by a space followed by a username The username must begin with an symbol and must consist of at least one character following the symbol If the server accepts the username it responds with YACKETY HELLO If not it responds with YACKETY INVALID USERNAME Once the server has accepted the username the client is considered logged in there is no password From that point the client can send one of three commands The line YACKETY SEND message where message can be any arbitrary short text message The server will respond with YACKETY SENT and the message will become available to other clients The line YACKETY LAST number of messages where number of messages is a positive integer such as 1 The server will respond with two things The line YACKETY MESSAGE COUNT number of messages where number of messages is a positive integer such as 1 The number of messages may be less than the number sent from the client if the Yackety server has fewer messages stored than the client asked for If number of messages sent from the server is the number n this will be followed by n lines each of which is YACKETY MESSAGE followed by a space followed by a username followed by a space folllowed by the text of a message In total these will be the n most recently sent messages in the reverse of the order they were sent i e the most recent message first the second most recent message second and so on The line YACKETY GOODBYE in which case the server will respond with YACKETY GOODBYE and close the connection the interaction between the client and the server is now over An example session follows ClientServerinitiates a connectionaccepts the connectionYACKETY HELLO alexYACKETY HELLOYACKETY SEND This is a testYACKETY SENTYACKETY SEND Another messageYACKETY SENTYACKETY LAST 3YACKETY MESSAGE COUNT 3YACKETY MESSAGE alex Another messageYACKETY MESSAGE alex This is a testYACKETY MESSAGE boo I am the greatestYACKETY GOODBYEYACKETY GOODBYEcloses the connectioncloses the connection What we wanted to build The protocol described above is not intended for human use any more than the HTTP protocol which governs how web browsers download web pages is intended for people A web browser has the knowledge of the HTTP protocol embedded within it behind the scenes when you visit a web page a conversation between your web browser and a web server commences with HTTP defining what that conversation will look like But the conversation itself is invisible to users of a web browser someone using a browser simply sees some kind of progress indication and ultimately the web page Similarly we might like to build a Yackety client whose job is to provide a user with the ability to use the Yackety service without having to know the details of hosts ports sockets and protocols Modules and import Be sure you read the sections in the textbook Chapter 7 1 7 2 and 7 4 that discuss modules the import statement and namespaces This is critical knowledge necessary for writing programs with more than one module As programs get larger we re best off separating them into modules that contain related subsets of functionality for example in a program that interacts with the Yackety service using the Yackety protocol we would be better off isolating the protocol itself in its own module then building a user interface or whatever other outer shell we need in a separate module This has a number of benefits e g keeping a large complex program organized allowing us to put more than one outer shell around the protocol code and we ll expect you to begin doing this as you implement your projects going forward In Python programs we can think of modules as collections of functions classes and constants Of those some are what you might call public they re the ones that you expect other modules to need in order to solve their problems Others are what you might call private they re the ones that are used as utilities within a module to allow you to break up what might otherwise be large complex functions into smaller pieces But they re not the core functionality that the module is intending to provide to other modules and they are the things that you expect to change be added and disappear as you tweak your implementation Python programmers traditionally separate the public from the private by prefixing the names of private functions classes and constants with a single underscore character Since the private functions by nature are the ones that are more likely to be changed added or removed over time the underscore is a sort of warning to users of the module that they should exercise caution and quite probably stay away from such functions because they re likely to change in ways that will break callers We ll adopt the underscore convention for private members of modules here and from now on Taking the opportunity to think about design While we could have implemented our protocol in one long function we opted for an approach I ve advocated a lot this quarter breaking it into progressively smaller functions with meaningful names and well named parameters This code example in my view is a good example of why we should want to do that because there s a fair amount of complexity here that s worth isolating so we can think about one thing at a time instead of everything A word of warning It should be noted that this isn t code that you re going to be able to copy and paste in whole into your Project 2 solution as the protocol you re implementing in the project and your program s interaction with it is different from this one But there are ideas and techniques here that translate to your work on the project the trick is being sure that you understand what s being done in this example and why before you attempt to use these ideas in your own programs because part of what s important is understanding what parts of this example fit the problem you re solving in the project and which don t The code Below are links to a complete Yackety client along with a module that implements the Yackety protocol There have been a few minor updates to the design since the lecture but the code is mostly the same as what we wrote in class yackety py an implementation of the Yackety protocolyackety ui py a console user interface for Yackety Remember to download these files and place them in the same directory It s important that they re in the same directory so that Python will be able to find them when one imports the other There are fancier things that we can do but we generally keep all of the modules that comprise our programs in a single directory until they get much much larger Trying out the example client A Yackety server like the one we connected to during lecture is now running on the same machine where the Connect Four server for Project 2 is running See a previously sent email for an indication of where that is The Yackety server is listening on port 6543 Note that you ll need to make one update to the code setting the value of the YACKETY HOST constant defined in yackety ui py before you can successfully run it ", "_id": "http://www.ics.uci.edu/~thornton/ics32/CodeExamples/Protocols/", "title": "ics 32 winter 2015, code example: protocols", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2015, Code Example: Protocols</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2015 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2015<br />\r\n   Code Example: Protocols</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p class=\"subtitle\">Protocols</p>\r\n\r\n<p>When you write a program that will store data in a file and read it back again later, you have to decide on a <i>file format</i>, which specifies, in detail, what the data will look like once it's stored in the file.  There are many existing file formats, like the JPEG format for image files, but you can define your own, too, if a pre-existing format is not appropriate for your particular use.</p>\r\n\r\n<p>When you write programs that communicate with one another using sockets, you have a similar problem: the program on each side of the connection will be sending data to the other.  Without an agreement about what that data will look, the data sent from one program won't make sense to the other.  So, when programs communicate across sockets, you will always need them to agree on a <i>protocol</i>, which specifies what each program will send and expect to receive.  As with file formats, there are well-known protocols already defined for specific purposes &mdash; like the HTTP protocol that describes how data is transferred over the web, or the SMTP protocol that is used to send email &mdash; but you can also define your own protocol if you need something specific for your particular use.  What's important is that both programs implement the same protocol, and that each program knows its role in that protocol.</p>\r\n\r\n<p class=\"subtitle\">The Yackety protocol</p>\r\n\r\n<p>In lecture, we wrote a client program that interacted with a tiny Internet-based service I built called Yackety, similar to <a href=\"http://twitter.com/\">Twitter</a>, which allows for the broadcasting of short messages.  Yackety itself is a server program; other programs can interact with it by connecting to it via a socket and then sending and receiving text in a predefined format called the <i>Yackety protocol</i>.  The Yackety protocol, like other protocols, governs what each program &mdash; a Yackety client and the Yackety server &mdash; is required to send and can expect to receive in return.</p>\r\n\r\n<p>The Yackety protocol is made up of lines of text send back and forth between the client and the server.  Each line is terminated with a <i>newline sequence</i>, which is made up of the Python string '\\r\\n'.  The protocol is as follows:</p>\r\n\r\n<ul>\r\n  <li>The client connects to the Yackety server</li>\r\n  <li>The Yackety server accepts the connection</li>\r\n  <li>The client sends a line consisting of the word <b>YACKETY_HELLO</b>, followed by a space, followed by a username.  The username must begin with an @ symbol and must consist of at least one character following the @ symbol.</li>\r\n  <li>If the server accepts the username, it responds with <b>YACKETY_HELLO</b>.  If not, it responds with <b>YACKETY_INVALID_USERNAME</b>.</li>\r\n  <li>Once the server has accepted the username, the client is considered logged in &mdash; there is no password.  From that point, the client can send one of three commands:\r\n    <ul>\r\n      <li>The line <b>YACKETY_SEND <i>message</i></b>, where <i>message</i> can be any arbitrary, short text message.  The server will respond with <b>YACKETY_SENT</b> and the message will become available to other clients.</li>\r\n      <li>The line <b>YACKETY_LAST <i>number_of_messages</i></b>, where <i>number_of_messages</i> is a positive integer such as <b>10</b>.  The server will respond with two things:\r\n        <ul>\r\n          <li>The line <b>YACKETY_MESSAGE_COUNT <i>number_of_messages</i></b>, where <i>number_of_messages</i> is a positive integer such as <b>10</b>.  The number of messages may be less than the number sent from the client if the Yackety server has fewer messages stored than the client asked for.</li>\r\n          <li>If <i>number_of_messages</i> sent from the server is the number <i>n</i>, this will be followed by <i>n</i> lines, each of which is <b>YACKETY_MESSAGE</b>, followed by a space, followed by a username, followed by a space, folllowed by the text of a message.  In total, these will be the <i>n</i> most-recently-sent messages, in the reverse of the order they were sent (i.e., the most recent message first, the second-most-recent message second, and so on).</li>\r\n        </ul>\r\n      </li>\r\n      <li>The line <b>YACKETY_GOODBYE</b>, in which case the server will respond with <b>YACKETY_GOODBYE</b> and close the connection; the interaction between the client and the server is now over.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>An example session follows:</p>\r\n\r\n<table class=\"normal\">\r\n  <tr class=\"top\">\r\n    <td>Client</td>\r\n    <td>Server</td>\r\n  </tr>\r\n  <tr>\r\n    <td><i>initiates a connection</i></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><i>accepts the connection</i></td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>YACKETY_HELLO @alex</b></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_HELLO</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>YACKETY_SEND This is a test</b></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_SENT</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>YACKETY_SEND Another message</b></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_SENT</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>YACKETY_LAST 3</b></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_MESSAGE_COUNT 3</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_MESSAGE @alex Another message</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_MESSAGE @alex This is a test</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_MESSAGE @boo I am the greatest</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td><b>YACKETY_GOODBYE</b></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><b>YACKETY_GOODBYE</b></td>\r\n  </tr>\r\n  <tr>\r\n    <td></td>\r\n    <td><i>closes the connection</i></td>\r\n  </tr>\r\n  <tr>\r\n    <td><i>closes the connection</i></td>\r\n    <td></td>\r\n  </tr>\r\n</table>\r\n\r\n<p class=\"subtitle\">What we wanted to build</p>\r\n\r\n<p>The protocol described above is not intended for human use, any more than the HTTP protocol &mdash; which governs how web browsers download web pages &mdash; is intended for people.  A web browser has the knowledge of the HTTP protocol embedded within it; behind the scenes, when you visit a web page, a conversation between your web browser and a <i>web server</i> commences, with HTTP defining what that conversation will look like.  But the conversation itself is invisible to users of a web browser; someone using a browser simply sees some kind of progress indication and, ultimately, the web page.</p>\r\n\r\n<p>Similarly, we might like to build a Yackety client, whose job is to provide a user with the ability to use the Yackety service without having to know the details of hosts, ports, sockets, and protocols.</p>\r\n\r\n<p class=\"subtitle\">Modules and <i>import</i></p>\r\n\r\n<p>Be sure you read the sections in the textbook &mdash; Chapter 7.1, 7.2, and 7.4 &mdash; that discuss modules, the <b>import</b> statement, and namespaces.  \r\nThis is critical knowledge necessary for writing programs with more than one module.</p>\r\n\r\n<p>As programs get larger, we're best off separating them into modules that contain related subsets of functionality; for example, in a program that interacts with the Yackety service using the Yackety protocol, we would be better off isolating the protocol itself in its own module, then building a user interface (or whatever other \"outer shell\" we need) in a separate module.  This has a number of benefits &mdash; e.g., keeping a large complex program organized, allowing us to put more than one \"outer shell\" around the protocol code &mdash; and we'll expect you to begin doing this as you implement your projects going forward.</p>\r\n\r\n<p>In Python programs, we can think of modules as collections of functions, classes, and constants.  Of those, some are what you might call <i>public</i>; they're the ones that you expect other modules to need in order to solve their problems.  Others are what you might call <i>private</i>; they're the ones that are used as utilities within a module, to allow you to break up what might otherwise be large, complex functions into smaller pieces.  But they're not the core functionality that the module is intending to provide to other modules, and they are the things that you expect to change, be added, and disappear as you tweak your implementation.</p>\r\n\r\n<p>Python programmers traditionally separate the \"public\" from the \"private\" by prefixing the names of \"private\" functions, classes, and constants with a single underscore ('_') character.  Since the private functions, by nature, are the ones that are more likely to be changed, added, or removed over time, the underscore is a sort of warning to users of the module that they should exercise caution and quite probably stay away from such functions, because they're likely to change in ways that will break callers.  We'll adopt the underscore convention for private members of modules here and from now on.</p>\r\n\r\n<p class=\"subtitle\">Taking the opportunity to think about design</p>\r\n\r\n<p>While we could have implemented our protocol in one long function, we opted for an approach I've advocated a lot this quarter: breaking it into progressively smaller functions with meaningful names and well-named parameters.  This code example, in my view, is a good example of why we should want to do that, because there's a fair amount of complexity here that's worth isolating, so we can think about one thing at a time instead of everything.</p>\r\n\r\n<p class=\"subtitle\">A word of warning</p>\r\n\r\n<p>It should be noted that this isn't code that you're going to be able to copy and paste, in whole, into your <a href=\"../../ProjectGuide/Project2\">Project #2</a> solution, as the protocol you're implementing in the project (and your program's interaction with it) is different from this one.  But there are ideas and techniques here that translate to your work on the project; the trick is being sure that you understand what's being done in this example and <i>why</i> before you attempt to use these ideas in your own programs, because part of what's important is understanding what parts of this example fit the problem you're solving in the project and which don't.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>Below are links to a complete Yackety client, along with a module that implements the Yackety protocol.  There have been a few minor updates to the design since the lecture, but the code is mostly the same as what we wrote in class.</p>\r\n\r\n<ul>\r\n  <li><a href=\"yackety.py\"><b>yackety.py</b> &mdash; an implementation of the Yackety protocol</a></li>\r\n  <li><a href=\"yackety_ui.py\"><b>yackety_ui.py</b> &mdash; a console user interface for Yackety</a></li>\r\n</ul>\r\n\r\n<p>Remember to download these files and place them in the same directory.  It's important that they're in the same directory, so that Python will be able to find them when one imports the other.  (There are fancier things that we can do, but we generally keep all of the modules that comprise our programs in a single directory until they get much, much larger.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Trying out the example client</p>\r\n\r\n<p>A Yackety server like the one we connected to during lecture is now running on the same machine where the Connect Four server for <a href=\"../../ProjectGuide/Project2\">Project #2</a> is running.  (See a previously-sent email for an indication of where that is.)  The Yackety server is listening on port 6543.</p>\r\n\r\n<p>Note that you'll need to make one update to the code &mdash; setting the value of the <b>YACKETY_HOST</b> constant defined in <b>yackety_ui.py</b> &mdash; before you can successfully run it.</p>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 26535.0}