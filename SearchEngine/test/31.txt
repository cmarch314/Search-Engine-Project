{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Single Dimension Arrays The moniker for this code example is SingleDimensionArrays Background Of course you don t need to dream very big to dream up a program that has the need to store a collection of objects instead of just a single one a collection of students enrolled in a course a collection of financial instruments in an investment portfolio a collection of statements in a function if you re writing a compiler and so on It s quite common to need to store a homogeneous collection in which each element has the same type Like most programming languages C provides mechanisms for solving this problem The most basic of these mechanisms is called an array or more completely a single dimension array As we ll see later this quarter there are cleaner mechanisms than using an array but arrays serve as the raw materials for how some of those other mechanisms are built Our focus early in this course is to understand the underpinnings of C so we can build a good complete mental model of what happens while a C program executes For that reason it s a good idea for us to start with the raw materials and work our way up So we ll begin our exploration of collections by looking at arrays in some depth What is an array An array is a sequence of cells that live contiguously one directly following another in memory Each cell has an index with the first cell having the index the second cell having the index 1 and so on The cells are all of the same type e g int std string or whatever and hence they all have the same size The latter part is important that the cells of an array are uniformly sized is why accessing an array cell given its index is relatively inexpensive When an array is created it is given a size it retains that size for the rest of its life and there is no language level way to extend the size of array once it s been created And from a language level perspective there is also no way to ask an array its size as there is no standard mechanism for its size to be stored or manipulated Statically allocated arrays As with every other kind of object we ve seen in C we have a choice about how our arrays are to be allocated and where they will be stored with the most common two choices being static allocation on the run time stack via a local variable in a function or dynamic allocation on the heap using pointers and the new operator Of these static allocation is the simplest giving us the usual benefits Automatic deallocation when the array falls out of scopeA likelihood of the array being in cache a lot of the time as the current stack frame is accessed often and hence likely to be cached but also leaving us with disadvantages which can t always be overcome Run time stacks are generally limited in size given that most programs don t tend to need function calls that nest to an incredibly deep level But this imposes a limitation on how much data you can store in local variables at some point a stack frame will simply be too big to be practical And of course the larger it is the less benefit you ll see from caching Arrays must be given a size at the time they re created Statically allocated objects are given a size at compile time so a statically allocated array must have a size that is known at compile time e g a hard coded constant or another expression calculated only from constants Statically allocated objects have fixed lifetimes for example local variables in a function die when the function ends When we want more open ended lifetimes we can t use static allocation Nonetheless there are substantial use cases where we can statically allocate arrays small arrays of known size at compile time with determinant lifetimes so we ll start there We allocate arrays statically by declaring them as variables we make a variable into an array by following its name with a size in brackets void foo int a 1 Accessing individual cells to read their values or to write them is done using a similar bracket based syntax void foo int a 1 a 3 4 std cout a 3 std endl From a language perspective C arrays do not appear to know how big they are there s simply no syntax to ask the question How many cells do you have of an array Furthermore no checking is done to ensure that accesses to array cells are legal Given the array a above accesses of invalid cells such as a 12 or a 3 would be legal in the sense that they would compile at worst with warnings but nonsensical and quite possibly dangerous It s up to us as C programmers to avoid these kinds of accesses but it s important to realize that they will be allowed and may lead to such undesirable consequences as assigning values willy nilly into memory that lives outside of the array s boundaries changing the guts of some other object that might well have a complete different type Dynamically allocated arrays When a statically allocated array can t be used because you don t know the appropriate size at compile time because you know the array is too large to reasonably fit on the run time stack because you need the array to outlive the function in which it s created there exists the option of a dynamically allocated array instead Dynamically allocating an array involves the use of the new operator similar to the dynamic allocation of other objects int a new int 1 The expression new int 1 allocates a block of memory on the heap large enough to store 1 integers on the ICS 45C VM that would be 4 bytes four for each int and returns a pointer to it Interestingly the pointer s type is int arrays in general are implemented as pointers to their first cells and it s up to us to know whether a particular int is pointing to a single int or an array of ints and remember there s no standard way to ask Once you have a pointer to an array you can access its cells similarly to a statically allocated array int a new int 1 a 3 4 std cout a 3 std endl The expression a 3 results in equivalent to the hypothetical expression q where q is a pointer to an int located three cells in our case 12 bytes beyond the one that a points to When you re done with a dynamically allocated array you would need to explicitly deallocate just as you would any other dynamically allocated object However it s important to note that you use a different operator delete to do so Like delete you give delete a pointer to an array and it deallocates the array and all of the objects in all of its cells for you delete a It s up to you to know what pointers point to arrays and to use delete when it s warranted using delete instead of delete results in undefined behavior which means that compiler writers can generate any code they d like in this case some do the right thing in this case but some don t Passing arrays as parameters to functions The simplest way to pass an array as a parameter to a function regardless of how the array was allocated is to pass a pointer to its first element But since there s no way for the function to ask the array s size you would also need to pass its size as a separate parameter For example consider this function which completely fills an array of ints with zeroes void zeroFill int a unsigned int size for unsigned int i i size i a i Note that this function will gleefully write as many zeroes into memory as you tell it to regardless of the actual underlying size of the array that a points to In other words this would be legal though obviously erroneous int x new int 1 zeroFill x 5 Writes 5 zeroes to memory starting with the cell where x points It s up to us to handle these details correctly and in general we ll receive no help from the compiler to ensure this In some cases we might get warnings though in this case I d expect that to be rare to nonexistent in others we ll get crashes in still others the program will continue muddling forward with potentially bizarre behavior The moral of this story is partly that arrays are a difficult mechanism to use correctly so we re wise to use cleaner safer ones when we can afford them We ll cross that bridge a little later this quarter Pointer arithemtic Pointers are memory addresses and memory addresses are numbers So it s not entirely nonsensical to think that you can perform certain kinds of arithemtic on pointers similar to the arithemtic you can perform on ints This is called pointer arithmetic Pointer arithmetic is more limited than the arithmetic you can do on ints For example multiplication and division are not supported addition involves a pointer and a constant integer subtraction might involve a pointer and a constant integer or it might involve two pointers Consider the following short example int a 1 a is effectively a pointer to the first element of the array int b 1 b is also effectively a pointer std cout a std endl writes the address of a std cout a 1 std endl writes the address of a 1 a 1 3 stores 3 in a 1 std cout a 1 std endl writes the address of a 1 std cout a b std endl writes the distance in memory between a and b divided by the size of an int In general we can see that pointer arithmetic works by considering the type of object the pointers are said to point to For example a 1 doesn t just add the integer value 1 to the address of a instead it adds the size of an integer to the address of a or in other words calculates a position one integer beyond where a points In that sense pointer arithmetic is very much like array indexing and in fact the array indexing operations you write are ultimately translated by a compiler into the corresponding pointer arithemtic operations instead Given this technique we can write certain code differently for example our function above that zero fills an array could be written this way void zeroFill int a int size for int p a p a size p p In this version of the function p iterates over the array that a points to visiting each cell a size is the address of the cell just beyond the last cell in the array which makes an effective stopping point for the loop p means Move p so that it points to the next integer after the one that p points to now A pointer based solution like this one is potentially faster than its array indexing counterpart because it replaces the array index calculation a multiplication and an addition in each step with a simple addition the increment operation instead However I should point out that compilers with strong optimizers built into them might well recognize the pattern in the original version of our zero filling function and transform it into the pointer arithmetic version for us My general rule is to start by writing code that s clear then replace it with code with optimizations if a I find that I need them i e some part of my code is running slower than I need it to and b the optimization isn t being performed automatically The code The official moniker for this code example is SingleDimensionArrays so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code SingleDimensionArrays to download the code example into your project directory s app directory Alternatively you can click the link to the tarball below SingleDimensionArrays tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/SingleDimensionArrays/", "title": "ics 45c fall 2014, code example: single-dimension arrays", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Single-Dimension Arrays</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Single-Dimension Arrays</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>SingleDimensionArrays</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Of course, you don't need to dream very big to dream up a program that has the need to store a <i>collection</i> of objects instead of just a single one: a collection of students enrolled in a course, a collection of financial instruments in an investment portfolio, a collection of statements in a function (if you're writing a compiler), and so on.  It's quite common to need to store a <i>homogeneous collection</i>, in which each element has the same type.  Like most programming languages, C++ provides mechanisms for solving this problem.  The most basic of these mechanisms is called an <i>array</i> &mdash; or, more completely, a <i>single-dimension array</i>.</p>\r\n\r\n<p>As we'll see later this quarter, there are cleaner mechanisms than using an array, but arrays serve as the raw materials for how some of those other mechanisms are built.  Our focus early in this course is to understand the underpinnings of C++, so we can build a good, complete mental model of what happens while a C++ program executes.  For that reason, it's a good idea for us to start with the raw materials and work our way up.  So we'll begin our exploration of collections by looking at arrays in some depth.</p>\r\n\r\n<p class=\"subtitle\">What is an array?</p>\r\n\r\n<p>An array is a sequence of <i>cells</i> that live contiguously &mdash; one directly following another &mdash; in memory.  Each cell has an index, with the first cell having the index 0, the second cell having the index 1, and so on.  The cells are all of the same type (e.g., <b>int</b>, <b>std::string</b>, or whatever) and, hence, they all have the same size.  (The latter part is important: that the cells of an array are uniformly sized is why accessing an array cell, given its index, is relatively inexpensive.)</p>\r\n\r\n<p>When an array is created, it is given a size; it retains that size for the rest of its life, and there is no language-level way to extend the size of array once it's been created.  And from a language-level perspective, there is also no way to ask an array its size, as there is no standard mechanism for its size to be stored or manipulated.</p>\r\n\r\n<p class=\"subtitle\">Statically-allocated arrays</p>\r\n\r\n<p>As with every other kind of object we've seen in C++, we have a choice about how our arrays are to be allocated and where they will be stored, with the most common two choices being static allocation on the run-time stack (via a local variable in a function) or dynamic allocation on the heap (using pointers and the <b>new</b> operator).  Of these, static allocation is the simplest, giving us the usual benefits:</p>\r\n\r\n<ul>\r\n  <li>Automatic deallocation when the array falls out of scope</li>\r\n  <li>A likelihood of the array being in cache a lot of the time, as the current stack frame is accessed often and, hence, likely to be cached)</li>\r\n</ul>\r\n\r\n<p>but also leaving us with disadvantages, which can't always be overcome:</p>\r\n\r\n<ul>\r\n  <li>Run-time stacks are generally limited in size, given that most programs don't tend to need function calls that nest to an incredibly deep level.  But this imposes a limitation on how much data you can store in local variables; at some point, a stack frame will simply be too big to be practical.  (And, of course, the larger it is, the less benefit you'll see from caching.)</li>\r\n  <li>Arrays must be given a size at the time they're created.  Statically-allocated objects are given a size at compile-time, so a statically-allocated array must have a size that is known at compile-time (e.g., a hard-coded constant or another expression calculated only from constants).</li>\r\n  <li>Statically-allocated objects have fixed lifetimes; for example, local variables in a function die when the function ends.  When we want more open-ended lifetimes, we can't use static allocation.</li>\r\n</ul>\r\n\r\n<p>Nonetheless, there are substantial use cases where we can statically allocate arrays (small arrays of known size at compile time with determinant lifetimes), so we'll start there.</p>\r\n\r\n<p>We allocate arrays statically by declaring them as variables; we make a variable into an array by following its name with a size in brackets.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int a[10];\r\n    // ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Accessing individual cells &mdash; to read their values or to write them &mdash; is done using a similar bracket-based syntax.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int a[10];\r\n    a[3] = 4;\r\n    std::cout << a[3] << std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>From a language perspective, C++ arrays do not appear to know how big they are; there's simply no syntax to ask the question \"How many cells do you have?\" of an array.  Furthermore, no checking is done to ensure that accesses to array cells are legal.  Given the array <b>a</b> above, accesses of invalid cells such as <b>a[12]</b> or <b>a[-3]</b> would be legal (in the sense that they would compile, at worst, with warnings) but nonsensical and quite possibly dangerous.  It's up to us as C++ programmers to avoid these kinds of accesses, but it's important to realize that they will be allowed &mdash; and may lead to such undesirable consequences as assigning values willy-nilly into memory that lives outside of the array's boundaries, changing the guts of some other object (that might well have a complete different type!).</p>\r\n\r\n<p class=\"subtitle\">Dynamically-allocated arrays</p>\r\n\r\n<p>When a statically-allocated array can't be used &mdash; because you don't know the appropriate size at compile time, because you know the array is too large to reasonably fit on the run-time stack, because you need the array to outlive the function in which it's created &mdash; there exists the option of a <i>dynamically-allocated array</i> instead.  Dynamically allocating an array involves the use of the <b>new</b> operator, similar to the dynamic allocation of other objects.</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[10];\r\n</pre></blockquote>\r\n\r\n<p>The expression <b>new int[10]</b> allocates a block of memory on the heap large enough to store 10 integers &mdash; on the ICS 45C VM, that would be 40 bytes (four for each int) &mdash; and returns a pointer to it.  Interestingly, the pointer's type is <b>int*</b>; arrays, in general, are implemented as pointers to their first cells, and it's up to us to know whether a particular <b>int*</b> is pointing to a single <b>int</b> or an array of <b>int</b>s (and, remember, there's no standard way to ask!).</p>\r\n\r\n<p>Once you have a pointer to an array, you can access its cells similarly to a statically-allocated array:</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[10];\r\na[3] = 4;\r\nstd::cout << a[3] << std::endl;\r\n</pre></blockquote>\r\n\r\n<p>The expression <b>a[3]</b> results in equivalent to the hypothetical expression <b>*q</b>, where <b>q</b> is a pointer to an <b>int</b> located three cells (in our case, 12 bytes) beyond the one that <b>a</b> points to.</p>\r\n\r\n<p>When you're done with a dynamically-allocated array, you would need to explicitly deallocate, just as you would any other dynamically-allocated object.  However, it's important to note that you use a different operator &mdash; <b>delete[ ]</b> &mdash; to do so.  Like <b>delete</b>, you give <b>delete[ ]</b> a pointer to an array, and it deallocates the array (and all of the objects in all of its cells) for you.</p>\r\n\r\n<blockquote><pre>\r\ndelete[] a;\r\n</pre></blockquote>\r\n\r\n<p>It's up to you to know what pointers point to arrays, and to use <b>delete[ ]</b> when it's warranted; using <b>delete</b> instead of <b>delete[ ]</b> results in \"undefined behavior\" (which means that compiler writers can generate any code they'd like in this case; some do the right thing in this case, but some don't).</p>\r\n\r\n<p class=\"subtitle\">Passing arrays as parameters to functions</p>\r\n\r\n<p>The simplest way to pass an array as a parameter to a function &mdash; regardless of how the array was allocated &mdash; is to pass a pointer to its first element.  But since there's no way for the function to ask the array's size, you would also need to pass its size as a separate parameter.  For example, consider this function, which completely fills an array of <b>int</b>s with zeroes.</p>\r\n\r\n<blockquote><pre>\r\nvoid zeroFill(int* a, unsigned int size)\r\n{\r\n    for (unsigned int i = 0; i < size; i++)\r\n    {\r\n        a[i] = 0;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Note that this function will gleefully write as many zeroes into memory as you tell it to, regardless of the actual underlying size of the array that <b>a</b> points to.  In other words, this would be legal (though obviously erroneous):</p>\r\n\r\n<blockquote><pre>\r\nint* x = new int[10];\r\nzeroFill(x, 50);       // Writes 50 zeroes to memory, starting with the cell where x points!\r\n</pre></blockquote>\r\n\r\n<p>It's up to us to handle these details correctly, and, in general, we'll receive no help from the compiler to ensure this.  In some cases, we might get warnings (though, in this case, I'd expect that to be rare-to-nonexistent); in others, we'll get crashes; in still others, the program will continue muddling forward with potentially bizarre behavior.</p>\r\n\r\n<p>(The moral of this story is partly that arrays are a difficult mechanism to use correctly, so we're wise to use cleaner, safer ones when we can afford them.  We'll cross that bridge a little later this quarter.)</p>\r\n\r\n<p class=\"subtitle\">Pointer arithemtic</p>\r\n\r\n<p>Pointers are memory addresses, and memory addresses are numbers.  So it's not entirely nonsensical to think that you can perform certain kinds of arithemtic on pointers, similar to the arithemtic you can perform on <b>int</b>s.  This is called <i>pointer arithmetic</i>.  Pointer arithmetic is more limited than the arithmetic you can do on <b>int</b>s.  For example, multiplication and division are not supported; addition involves a pointer and a constant integer; subtraction might involve a pointer and a constant integer, or it might involve two pointers.</p>\r\n\r\n<p>Consider the following short example:</p>\r\n\r\n<blockquote><pre>\r\nint a[10];     // a is effectively a pointer to the first element of the array\r\nint b[10];     // b is also effectively a pointer\r\nstd::cout << a << std::endl;   // writes the address of <b>a[0]</b>\r\nstd::cout << (a + 1) << std::endl;   // writes the address of <b>a[1]</b>\r\n*(a + 1) = 3;    // stores 3 in <b>a[1]</b>\r\nstd::cout << (a - 1) << std::endl;   // writes the address of <b>a[-1]</b>\r\nstd::cout << (a - b) << std::endl;   // writes the distance in memory between <b>a[0]</b> and <b>b[0]</b> (divided by the size of an <b>int</b>)\r\n</pre></blockquote>\r\n\r\n<p>In general, we can see that pointer arithmetic works by considering the type of object the pointers are said to point to.  For example, <b>a + 1</b> doesn't just add the integer value 1 to the address of <b>a</b>; instead, it adds the <i>size of an integer</i> to the address of <b>a</b> or, in other words, calculates a position <i>one integer beyond where <b>a</b> points</i>.  In that sense, pointer arithmetic is very much like array indexing and, in fact, the array-indexing operations you write are ultimately translated by a compiler into the corresponding pointer arithemtic operations instead.</p>\r\n\r\n<p>Given this technique, we can write certain code differently; for example, our function above that zero-fills an array could be written this way:</p>\r\n\r\n<blockquote><pre>\r\nvoid zeroFill(int* a, int size)\r\n{\r\n    for (int* p = a; p < a + size; p++)\r\n    {\r\n        *p = 0;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>In this version of the function, <b>p</b> iterates over the array that <b>a</b> points to, visiting each cell.  <b>a + size</b> is the address of the cell just beyond the last cell in the array, which makes an effective stopping point for the loop.  <b>p++</b> means \"Move p so that it points to the next integer after the one that p points to now.\"</p>\r\n\r\n<p>A pointer-based solution like this one is potentially faster than its array-indexing counterpart, because it replaces the array index calculation (a multiplication and an addition) in each step with a simple addition (the increment operation) instead.  However, I should point out that compilers with strong optimizers built into them might well recognize the pattern in the original version of our zero-filling function and transform it into the pointer arithmetic version for us.  My general rule is to start by writing code that's clear, then replace it with code with optimizations if (a) I find that I need them (i.e., some part of my code is running slower than I need it to), and (b) the optimization isn't being performed automatically.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>SingleDimensionArrays</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code SingleDimensionArrays</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"SingleDimensionArrays.tar.gz\">SingleDimensionArrays.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 31.0}