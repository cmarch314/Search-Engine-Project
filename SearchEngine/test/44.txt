{"text": "ICS 45C Fall 2 14 News Course Reference Schedule Project Guide Code Examples About Alex ICS 45C Fall 2 14 Code Example Standard Input and Output The moniker for this code example is StandardInputAndOutput Background Like most programming languages C provides some built in mechanisms in its standard library for getting input into a program and output out of it There are fewer of these mechanisms built into C than you might be used to some like network based I O or graphical user interfaces are supported only in third party libraries but there are some Most notably C provides a way to perform I O via the standard input and standard output of a program along with file based I O This example focuses on the standard input What are the standard input and standard output On most operating systems when a program is started it has a handful of input and output streams associated with it by default Traditionally the simplest way to send input into a program is to send it to the program s standard input while the simplest way to get output from it is for the program to write it to its standard output The most common arrangement on Linux e g on the ICS 45C VM is for the standard input and standard output to be connected to the shell On the ICS 45C VM when you execute a program via the shell prompt by executing the run script anything sent to the program s standard output will appear in your shell window while an attempt by your program to read from its standard input can require you to type something in the shell window with the keyboard Note that it doesn t have to be this way when you run a program you can use a technique called redirection to connect standard input or standard output to other places for example you can have a program read its standard input from a file while writing its standard output to the shell prompt Even more powerful is the technique of piping which allows you to send the standard output of one program into the standard input of another automatically which enables programs to be connected together in many useful ways In the C Standard Library the standard header iostream contains declarations of a variety of things you d need in order to perform I O using the standard input and standard output Having included that header you ll have access to the objects and functions described in this example most notably you ll have An object called std cin which represents the program s standard input An object called std cout which represents the program s standard output An object called std endl which you can think of as a constant representing an end of line sequence that you d like to write to the standard output Writing some simple output to std cout Output streams like std cout provide the capability to write formatted output and know intrinsically how to format the built in types not just strings but also integers doubles etc As we ll see later this quarter you can also specify how formatting of your own types is to be done though we ll need to learn more about specifying our own types before we can go down that road Writing an object to std cout is most easily done using the operator which when used on an object stream is sometimes called the put operator because it lets you put an object on to the stream Depending on the object s type it will be formatted to an appropriate textual representation then the text will be written to the standard output A subsequent use of the operator on std cout will write another object directly afterward with no spaces included in between them Uses of the operator can be strung together into a single expression so it s not necessary to write a separate line of code for each object you want to output You ll want to exercise some judgment about how long your expressions are a good rule of thumb is not to write lines of code longer than about 8 characters To write an end of line sequence to std cout so that subsequent output will appear at the beginning of the next line you d put the object std endl on to the standard output Putting these ideas together consider the following code fragment int i 3 double d 8 75 std string s Boo std cout i d s std endl std cout s d std endl This code fragment would write the following text to the standard output 38 75Boo Boo 8 75 A couple of things to note about this There are two lines of output being written and I ve chosen to split them into two separate lines of code This is not a requirement per se you could write each object on a separate line or even write all of these objects on a single line though I ve found that maintaining some sanity in the patterns of code you write to generate output so that the shape of the code roughly mirrors the shape of what you re writing to the output helps your code to be more understandable Note that there are ways to control formatting more carefully e g specifying the number of digits to show after a decimal point but these aren t important for our current uses so we ll skip that detail for now though you can feel free to research that on your own if you re curious Reading input from std cin Just as there is an object std cout that represents a program s standard output the object std cin represents a program s standard input Reading input from std cin is relatively straightforward but there are a few things you need to know in order to do so effectively By default a program s standard input is generally connected to a text based input device For example when you run a program from a Linux shell prompt as you would when using the ICS 45C VM input is typed into the shell window when required But you ll need a mental model of how the typed input is processed Depending on what languages you ve programmed in previously you may find that you have a mental model but that it doesn t match the reality in C Reading from the standard input essentially works like this The first time you try to read anything from std cin you ll need to type an entire line of input into the shell window By an entire line I mean you can type anything you d like and then hit Enter it s the act of hitting Enter that terminates the line All of the input you typed including the newline character is stored in an input buffer Each time you read from std cin available text in the input buffer is consumed first if there s enough text available to satisfy the request that text is consumed and the input operation is completed without user intervention If all of the available text has been consumed and the request still isn t satified you ll need to type another line of text into the shell window You can think of the input buffer as having a cursor that tracks the next character that hasn t yet been read from the input buffer As characters are consumed from the input buffer this cursor moves When the cursor reaches the end of the buffer you d then need to enter another line of input into the shell window and hit Enter There is a operator in this context it s often called a get operator that allows you to consume a single object e g an integer a double from an input stream such as std cin Depending on the type of object you re trying to consume things will work a little bit differently but the general rule is that this will skip initial whitespace like spaces tabs and newlines then greedily consume characters until one is found that isn t intended to be part of the object being built If the input buffer is exhausted before the object is fully built the user will need to enter another line of input into the shell window and press Enter The precise rules for what is consumed depends on the type of variable you re reading input into A few examples with some more esoteric details sometimes left out for brevity are If you re reading into an int variable initial whitespace is skipped then optionally a minus sign might be consumed followed by however many digits appear As soon as anything else a letter a space another minus sign appears the consuming of input stops and the consumed characters are formed into a corresponding int value If the input buffer had three spaces followed by 4 7alex followed by a newline character the spaces would be thrown away 4 7 would be consumed the input buffer s cursor would point to the a in alex and the int value 4 7 would be stored If you re reading into a double variable the rules are similar initial whitespace is skipped then a number is consumed but that number might have a decimal point and more digits after them The resulting number would be stored If you re reading into a string variable the next word i e after skipping whitespace all characters up to but not including the next whitespace is stored Putting all of these ideas together into a short example consider this code fragment int i double d std string s std cin i s d If you executed this code fragment and this was the first use of std cin or the input buffer is empty the user would need to type a line of input into the shell window and hit Enter Suppose the user typed 1 CMG 475 87 and hit Enter Here s what would happen The text 1 CMG 475 875 would enter the input buffer along with a newline character at the end The cursor would be pointing to the first character The first attempt to read input is into the int variable i so the 1 would be consumed at which point i will be 1 and the input buffer s cursor will point to the space immediately following the 1 The second attempt to read input is into the std string variable s The space under the input buffer s cursor will be skipped then the word CMG will be consumed s will have the value CMG and the input buffer s cursor will now point to the space immediately following CMG The third attempt to read input is into the double variable d The space will again be skipped then 475 875 will be consumed The value of d will now be 475 875 and the input buffer s cursor will now point to the newline character immediately following 475 875 An important detail to understand at this point The input buffer is not yet empty There is still a newline character that hasn t been consumed Additionally the function std getline an input stream a string variable is a handy tool albeit one that s a little bit different than the one above It consumes all of the text in the input buffer up until it reaches a newline character storing all of the text in the given string variable Only if the input buffer was completely empty i e nothing not even a newline character will this require a user to type input into the shell window and press Enter It s important to understand that this function may store the empty string into the string variable you give it if there is nothing but a newline character in the buffer this is an important nuance to get right when you mix uses of the operator with the std getline function but not particularly hard to get right once you understand how things work One important detail to understand is that the newline character appearing at the end of each line of input is considered whitespace so you ll quite often have a newline character in the input buffer in cases where you might intuitively expect it to be empty One last tool that can be helpful is a method you can call on std cin called ignore which you can use to skip a certain number of characters in the input buffer For example std cin ignore 1 would skip one character in the input buffer i e move the input buffer s cursor forward one character For the time being we ll ignore input that is erroneous with respect to type such as the word Boo where an integer is expected as it s not a particularly interesting problem to solve and requires techniques that can be tedious to get right though you can certainly feel free to research parsing and error checking techniques if you re interested in them Practical programs are generally written to handle erroneous input in a graceful way but we need to pick our battles in this course we only have ten weeks so we ll leave this one to be fought another time The code The official moniker for this code example is StandardInputAndOutput so your best bet is to do this Create a new project using the code example project template Change into the project directory Issue the command download code StandardInputAndOutput to download the code example into your project directory s app directory Alternatively you can click the link to the tarball below StandardInputAndOutput tar gz", "_id": "http://www.ics.uci.edu/~thornton/ics45c/CodeExamples/StandardInputAndOutput/", "title": "ics 45c fall 2014, code example: console input via std::cin", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2014, Code Example: Console Input via std::cin</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2014 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2014<br />\r\n   Code Example: Standard Input and Output</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>The moniker for this code example is <b>StandardInputAndOutput</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Like most programming languages, C++ provides some built-in mechanisms in its standard library for getting input into a program and output out of it.  There are fewer of these mechanisms built into C++ than you might be used to &mdash; some, like network-based I/O or graphical user interfaces, are supported only in third-party libraries &mdash; but there are some.  Most notably, C++ provides a way to perform I/O via the <i>standard input</i> and <i>standard output</i> of a program, along with file-based I/O.  This example focuses on the standard input.</p>\r\n\r\n<p class=\"subtitle\">What are the \"standard input\" and \"standard output\"?</p>\r\n\r\n<p>On most operating systems, when a program is started, it has a handful of input and output streams associated with it by default.  Traditionally, the simplest way to send input into a program is to send it to the program's <i>standard input</i>, while the simplest way to get output from it is for the program to write it to its <i>standard output</i>.</p>\r\n\r\n<p>The most common arrangement on Linux (e.g., on the ICS 45C VM) is for the standard input and standard output to be connected to the shell.  On the ICS 45C VM, when you execute a program via the shell prompt by executing the <b>./run</b> script, anything sent to the program's standard output will appear in your shell window, while an attempt by your program to read from its standard input can require you to type something in the shell window with the keyboard.  (Note that it doesn't have to be this way; when you run a program, you can use a technique called <i>redirection</i> to connect standard input or standard output to other places; for example, you can have a program read its standard input from a file while writing its standard output to the shell prompt.  Even more powerful is the technique of <i>piping</i>, which allows you to send the standard output of one program into the standard input of another automatically, which enables programs to be connected together in many useful ways.)</p>\r\n\r\n<p>In the C++ Standard Library, the standard header <b>&lt;iostream&gt;</b> contains declarations of a variety of things you'd need in order to perform I/O using the standard input and standard output.  Having included that header, you'll have access to the objects and functions described in this example; most notably, you'll have:</p>\r\n\r\n<ul>\r\n  <li>An object called <b>std::cin</b>, which represents the program's standard input.</li>\r\n  <li>An object called <b>std::cout</b>, which represents the program's standard output.</li>\r\n  <li>An object called <b>std::endl</b>, which you can think of as a constant representing an end-of-line sequence that you'd like to write to the standard output.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Writing some simple output to std::cout</p>\r\n\r\n<p>Output streams like <b>std::cout</b> provide the capability to write formatted output, and know intrinsically how to format the built-in types (not just strings, but also integers, doubles, etc.).  As we'll see later this quarter, you can also specify how formatting of your own types is to be done, though we'll need to learn more about specifying our own types before we can go down that road.</p>\r\n\r\n<p>Writing an object to <b>std::cout</b> is most easily done using the <b>&lt;&lt;</b> operator, which, when used on an object stream, is sometimes called the \"put\" operator, because it lets you \"put\" an object on to the stream.  Depending on the object's type, it will be formatted to an appropriate textual representation, then the text will be written to the standard output.  A subsequent use of the &lt;&lt; operator on <b>std::cout</b> will write another object directly afterward, with no spaces included in between them.</p>\r\n\r\n<p>Uses of the &lt;&lt; operator can be strung together into a single expression, so it's not necessary to write a separate line of code for each object you want to output.  You'll want to exercise some judgment about how long your expressions are; a good rule of thumb is not to write lines of code longer than about 80 characters.</p>\r\n\r\n<p>To write an end-of-line sequence to <b>std::cout</b>, so that subsequent output will appear at the beginning of the next line, you'd put the object <b>std::endl</b> on to the standard output.</p>\r\n\r\n<p>Putting these ideas together, consider the following code fragment.</p>\r\n\r\n<blockquote><pre>\r\nint i = 3;\r\ndouble d = 8.75;\r\nstd::string s = \"Boo\";\r\n\r\nstd::cout &lt;&lt; i &lt;&lt; d &lt;&lt; s &lt;&lt; std::endl;\r\nstd::cout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; d &lt;&lt; std::endl;\r\n</pre></blockquote>\r\n\r\n<p>This code fragment would write the following text to the standard output:</p>\r\n\r\n<blockquote><pre>\r\n38.75Boo\r\nBoo 8.75\r\n</pre></blockquote>\r\n\r\n<p>A couple of things to note about this:</p>\r\n\r\n<ul>\r\n  <li>There are two lines of output being written and I've chosen to split them into two separate lines of code.  This is not a requirement, per se &mdash; you could write each object on a separate line, or even write all of these objects on a single line &mdash; though I've found that maintaining some sanity in the patterns of code you write to generate output, so that the \"shape\" of the code roughly mirrors the \"shape\" of what you're writing to the output, helps your code to be more understandable.</li>\r\n  <li>Note that there are ways to control formatting more carefully &mdash; e.g., specifying the number of digits to show after a decimal point &mdash; but these aren't important for our current uses, so we'll skip that detail for now, though you can feel free to research that on your own if you're curious.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Reading input from std::cin</p>\r\n\r\n<p>Just as there is an object, <b>std::cout</b>, that represents a program's standard output, the object <b>std::cin</b> represents a program's standard input.  Reading input from <b>std::cin</b> is relatively straightforward, but there are a few things you need to know in order to do so effectively.</p>\r\n\r\n<p>By default, a program's standard input is generally connected to a text-based input device.  For example, when you run a program from a Linux shell prompt, as you would when using the ICS 45C VM, input is typed into the shell window when required.  But you'll need a mental model of how the typed input is processed.  Depending on what languages you've programmed in previously, you may find that you have a mental model, but that it doesn't match the reality in C++.  Reading from the standard input essentially works like this:</p>\r\n\r\n<ul>\r\n  <li>The first time you try to read anything from <b>std::cin</b>, you'll need to type an entire line of input into the shell window.  By \"an entire line,\" I mean you can type anything you'd like and then hit Enter; it's the act of hitting Enter that terminates the line.  All of the input you typed &mdash; including the newline character! &mdash; is stored in an <i>input buffer</i>.</li>\r\n  <li>Each time you read from <b>std::cin</b>, available text in the input buffer is consumed first; if there's enough text available to satisfy the request, that text is consumed and the input operation is completed without user intervention.  If all of the available text has been consumed and the request still isn't satified, you'll need to type another line of text into the shell window.</li>\r\n  <li>You can think of the input buffer as having a <i>cursor</i> that tracks the next character that hasn't yet been read from the input buffer.  As characters are consumed from the input buffer, this cursor moves.  When the cursor reaches the end of the buffer, you'd then need to enter another line of input into the shell window and hit Enter.</li>\r\n</ul>\r\n\r\n<p>There is a <b>&gt;&gt;</b> operator &mdash; in this context, it's often called a <i>get</i> operator &mdash; that allows you to consume a single object (e.g., an integer, a double) from an input stream such as <b>std::cin</b>.  Depending on the type of object you're trying to consume, things will work a little bit differently, but the general rule is that this will skip initial whitespace (like spaces, tabs, and newlines), then greedily consume characters until one is found that isn't intended to be part of the object being built.  If the input buffer is exhausted before the object is fully built, the user will need to enter another line of input into the shell window and press Enter.</p>\r\n\r\n<p>The precise rules for what is consumed depends on the type of variable you're reading input into.  A few examples (with some more esoteric details sometimes left out for brevity) are:</p>\r\n\r\n<ul>\r\n  <li>If you're reading into an <b>int</b> variable, initial whitespace is skipped, then (optionally) a &minus; (minus sign) might be consumed, followed by however many digits appear.  As soon as anything else &mdash; a letter, a space, another minus sign &mdash; appears, the consuming of input stops and the consumed characters are formed into a corresponding <b>int</b> value.\r\n    <ul>\r\n      <li>If the input buffer had three spaces followed by <b>-407alex</b> followed by a newline character, the spaces would be thrown away, <b>-407</b> would be consumed, the input buffer's cursor would point to the <b>a</b> in <b>alex</b>, and the <b>int</b> value -407 would be stored.</li>\r\n    </ul>\r\n  </li>\r\n  <li>If you're reading into a <b>double</b> variable, the rules are similar: initial whitespace is skipped, then a number is consumed, but that number might have a decimal point and more digits after them.  The resulting number would be stored.</li>\r\n  <li>If you're reading into a <b>string</b> variable, the next \"word\" (i.e., after skipping whitespace, all characters up to <i>but not including</i> the next whitespace) is stored.</li>\r\n</ul>\r\n\r\n<p>Putting all of these ideas together into a short example, consider this code fragment:</p>\r\n\r\n<blockquote><pre>\r\nint i;\r\ndouble d;\r\nstd::string s;\r\n\r\nstd::cin >> i >> s >> d;\r\n</pre></blockquote>\r\n\r\n<p>If you executed this code fragment and this was the first use of <b>std::cin</b> (or the input buffer is empty), the user would need to type a line of input into the shell window and hit Enter.  Suppose the user typed <b>100 CMG 475.87</b> and hit Enter.  Here's what would happen:</p>\r\n\r\n<ul>\r\n  <li>The text <b>100 CMG 475.875</b> would enter the input buffer, along with a newline character at the end.  The cursor would be pointing to the first character.</li>\r\n  <li>The first attempt to read input is into the <b>int</b> variable <b>i</b>, so the <b>100</b> would be consumed, at which point <b>i</b> will be <b>100</b> and the input buffer's cursor will point to the space immediately following the <b>100</b>.</li>\r\n  <li>The second attempt to read input is into the <b>std::string</b> variable <b>s</b>.  The space under the input buffer's cursor will be skipped, then the word <b>CMG</b> will be consumed.  <b>s</b> will have the value <b>\"CMG\"</b> and the input buffer's cursor will now point to the space immediately following <b>CMG</b>.</li>\r\n  <li>The third attempt to read input is into the <b>double</b> variable <b>d</b>.  The space will again be skipped, then <b>475.875</b> will be consumed.  The value of <b>d</b> will now be <b>475.875</b> and the input buffer's cursor will now point to the newline character immediately following <b>475.875</b>.</li>\r\n  <li>An important detail to understand at this point: The input buffer is not yet empty.  There is still a newline character that hasn't been consumed!</li>\r\n</ul>\r\n\r\n<p>Additionally, the function <b>std::getline(<i>an input stream</i>, <i>a string variable</i>)</b> is a handy tool, albeit one that's a little bit different than the one above.  It consumes all of the text in the input buffer, up until it reaches a newline character, storing all of the text in the given string variable.  Only if the input buffer was <i>completely empty</i> (i.e., nothing, not even a newline character!) will this require a user to type input into the shell window and press Enter.  It's important to understand that this function may store the empty string into the string variable you give it if there is nothing but a newline character in the buffer; this is an important nuance to get right when you mix uses of the <b>&gt;&gt;</b> operator with the <b>std::getline</b> function, but not particularly hard to get right once you understand how things work.  (One important detail to understand is that the newline character appearing at the end of each line of input is considered whitespace, so you'll quite often have a newline character in the input buffer in cases where you might intuitively expect it to be empty.)</p>\r\n\r\n<p>One last tool that can be helpful is a method you can call on <b>std::cin</b> called <b>ignore</b>, which you can use to skip a certain number of characters in the input buffer.  For example, <b>std::cin.ignore(1);</b> would skip one character in the input buffer (i.e., move the input buffer's cursor forward one character).</p>\r\n\r\n<p>For the time being, we'll ignore input that is erroneous with respect to type, such as the word <b>Boo</b> where an integer is expected, as it's not a particularly interesting problem to solve and requires techniques that can be tedious to get right, though you can certainly feel free to research parsing and error-checking techniques if you're interested in them.  Practical programs are generally written to handle erroneous input in a graceful way, but we need to pick our battles in this course &mdash; we only have ten weeks! &mdash; so we'll leave this one to be fought another time.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>StandardInputAndOutput</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>code_example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download_code StandardInputAndOutput</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"StandardInputAndOutput.tar.gz\">StandardInputAndOutput.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 44.0}