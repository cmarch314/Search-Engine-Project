{"text": "Program 1 Programming using the ICS 46 Template Library ITL Stack Queue Priority Queue Set and Map ICS 46 Data Structure Implementation and Analysis Introduction This programming assignment is designed to ensure that you know how to use combinations of ITL s templated classes to model and compactly write code that solves a variety of different programming problems The kind of abstract thinking that goes into modeling solutions to these programming problems with these data types and iteration over them is critical to your development as computer scientists There are three parts to this assignment In each you will be asked to write a program cpp file that defines a few functions and has a main function which ties these functions together to solve the problem You should download the program1 project folder and use it to create an Eclipse project needing only courselib not googletest You will create each program in this project and submit each program separately in Checkmate The project folder contains boiler plated files including some typedefs that I found useful in my code you may change their names and contains all the data files you need to test debug you program Important Only one of the cpp files can be active at any time In the download all are active so I suggest that you inactivate the runoffvoting cpp and fa cpp files and work on reachable cpp first To make a progam inactive select it in the editor tab use the Ctrl a command to select all its lines and then click Source at the top left of the menu and choose Toggle Comment every line will now appear in a comment by using these same instructions you can toggle back those lines to not have comments Instead you can also use a existing working project folder remove but save all the files in its src folder and then put all the cpp files from the downloaded project s src folder into the existing working project s src folder Also put all the data files into the existing project folder not in the src folder You should work on this assignment in pairs Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early etc If you believe that it is impossible for you to work with someone because of some special reason s you should send me email stating them and asking for special permission to work alone which I do grant but not frequently Only one student should submit all parts of the the assignment but both student s names along with their UniqueID should appear in the comments at the top of each submitted cpp file It should look something like Romeo Montague UniqueID from grades spreadsheet Juliet Capulet UniqueID from grades spreadsheet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files You should familiarize yourselves with the ics46goody hpp file in the courselib src folder It contains functions useful in all these programs split and join like their counterparts in Python they use std string and vector std string prompt string and safe open This assignment has 5 parts pairs should work on each part together not split them up and do them separately Parts 1 3 are 14 points each 42 points total Part 4 is worth 1 points Part 5 is worth 8 points This skewing of points towards the simpler parts means students finishing the first three parts correctly will have a 7 average those finishing the first four parts correctly will have about an 87 average but to get an A on this assignment requires solving all parts correctly Remember I m going to be running MOSS on the parts of this assignment to check for program similarity Important The cross reference program shows an exmple of the form of code that you need to write for these programs study and understand its code before attempting to start solving these problems Questions about cross reference Post them on a Message Board in the Forum Use the array implementations supplied in the ITL for all the data types The programs in the folder you will download has include statements at the top for all the files that you need to use Along with the details of the functions I ve included the number of lines that I wrote in my solution I am supplying these number of lines not as a requirement but as a ballpark estimate of the amount of code you should write Problem 1 Reachability Problem Summary Write a program that prompts the user to enter the name of a file representing a graph Read the information in the file storing the graph in a map Print the graph Repeatedly prompt the user for a starting node in the graph and compute and print all the nodes that are reachable from it by following edges in the graph convert the algorithm for reachability described in detail below into C ITL code Input and Output Read a file of pairs of node names representing edges in a directed graph building a Map whose key is a std string source node and whose value is a Set of std string destination nodes that are each reachable from the source node key Although the supplied input files use 1 letter names your code should work for any strings use the split function in ics46goody hpp Two nodes appear on each line first the source node then the destination node with these node names separated by one semicolon character For example the input file graph1 txt contains the following lines which could appear in this order or any other c f b d a c c e d g a b e d f g f d which represent the graph Print the graph one source node per line the source nodes are printed alphabetically followed by the set of all the destination nodes that the source can immediately reach The graph above would print as Graph source destination edges a set c b b set d c set f e d set g e set d f set g d Note that the source nodes are sorted alphabetically but the Set of desintation nodes does not have to be sorted in fact it makes no sense to talk about sorted Sets we could talk about a sorted Priority Queue whose contents came from a Set Note that because node g is not a source node it is only a destination node it does not appear first on any line and appears only in the Sets for source nodes d and f Note that there are multiple data files for this program graph1 txt graph2 txt and graph3 txt test debug your program on the first file when you are done test it on the last two Draw the graph represented by each for to ensure that your code correctly prints it and computes the nodes reachable from any source node which you can do by eyeballing the graphs they are small Repeatedly prompt the user for a starting node in the graph until quit is entered and compute and print all the nodes that are reachable from it by following edges in the graph Reject any node not present as keys in the graph An example interaction processing the graph above might be Enter starting node enter quit to quit e Reachable from node name e set e d g Enter starting node enter quit to quit x x is not a source node name in the graph Enter starting node enter quit to quit a Reachable from node name a set a c b f e d g Enter starting node enter quit to quit quit Functions and Program read graph has an open file parameter it returns the Map representing the graph mine is 12 lines of code print graph has a Map parameter representing the graph it returns nothing but it prints the graph in the appropriate form mine is 7 lines of code reachable has a Map parameter representing the graph and a std string start node in the graph technically a key in the Map it returns a Set of all the nodes reachable from the start node by following edges in the graph mine is 15 lines Write a program at the bottom of this module that calls these functions to solve the problem mine is 22 lines To simplify the interaction you may prompt for the file name and specify a default value graph1 txt see my prompt string function in ics46goody hpp in the courselib src folder Here is the basic algorithm for computing reachability it is simple to explain and not very complicated to implement But you have to understand these instructions and carefully translate them into C ITL code You should hand simulate this algorithm using the graph above and verify that it produces the results you expect before coding it You might be tempted to use recursion but please don t unless recursion is done very carefully it will run forever on graphs with cycles one of the input files is a graph with cycles To compute all the reachable nodes in a graph create a Set initially empty of reached nodes and a Queue initially containing the parameter start node of nodes that we are going to explore to find nodes they can reach While the exploring queue still has nodes remove the first one and put it into the reached set if it is a key in the graph not all nodes are then for all its destination nodes that are not already in the reached set put them in the exploring queue When the exploring queue becomes empty can you argue that this always will happen there is no infinite looping return the reached set Print the set containing all these node labels When debugging this algorithm print the the entire Set and Queue contents using the standard insertion operator for these data types after every interesting change or use the debugger to observe these changes Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one sets will match if they have the same contents independent of their order You should also check that it works for other starting nodes and a variety of starting nodes in the other graphs Enter graph file name graph1 txt Graph source destination edges a set c b b set d c set f e d set g e set d f set g d Enter starting node enter quit to quit e Reachable from node name e set e d g Enter starting node enter quit to quit x x is not a source node name in the graph Enter starting node enter quit to quit a Reachable from node name a set a c b f e d g Enter starting node enter quit to quit quit Problem 2 Instant Runoff Voting Problem Summary Write a program that prompts the user to enter the name of a file representing the candidate preferences of a sequence of voters Read the information in the file storing it in a Map Print the voter preferences Repeatedly display the vote count for ballots sorted both by candidate and numerically eliminating from the election the candidate s receiving the fewest votes until one candidate the winner or no candidates a tie remain This form of election is known as instant runoff voting Every voter submits a ballot that ranks all the candidates the election from most favorite candidate to least favorite we will use a Queue for this purpose earlier candidates in the Queue are more favored than later candidates During the first ballot votes are counted for each of the candidates according to the rankings of the voters Then the candidate s with the fewest number of votes are removed from the election if more than one candidate receives the least number of votes all candidates receiving these least number of votes are removed from the election During the second ballot votes are tallied for the remaining candidates there are at least 1 fewer candidates if a voter s first ranked candidate is not still in the election then his her second ranked candidate should receive the vote but if his her second ranked candidate has been removed from the election then his her third ranked candidate should receive the vote This ballot process continues until either 1 candidate remains or candidates remain meaning that all the remaining candidates tallied the same number of votes Note that the preferences Map never changes but how it is intepreted does change since the intepretation is based on which candidates remain in the election Input and Output Read a file of voters and their ranking of the candidates separated by semicolons building a Map whose key is each voter and whose value is a Queue of candidates ranked by that voter they appear in the file in order from most favorite to least favorite For example the input file votepref1 txt contains the following lines which could appear in this order or any other A X Y Z B Y Z X C Y Z X D Z Y X E Z Y X The first line means voter A ranks candidate X first candidate Y second and candidate Z third The second line means voter B ranks candidate Y first candidate Z second and candidate X third Each line will have a unique voter and a permutation of all the candidates running Print all the associations in this Map one per line the voters are printed alphabetically using the following form Each line contains the voter and his her complete ranking of the candidates For example the file above would produce Voter Preferences A queue X Y Z rear B queue Y Z X rear C queue Y Z X rear D queue Z Y X rear E queue Z Y X rear Note that the voter names are sorted alphabetically but the Queue of preferences appears in the same order they appeared in the file There are multiple data files for this program votepref1 txt votepref2 txt votepref3 txt and votepref4 txt test debug your program on the first file when you are done test it on the rest Start with all the candidates Evaluate the ballot to determine how many votes each candidate received Print this vote count two ways sorted alphabetically and sorted numerically in decreasing order if more than one candidate receives the same number of votes they should appear sorted alphabetically Remove the candidate s receiving the fewest votes and repeat this process until only one or no candidates remain Finally print the outcome of the election a single candidate winner or a tie An example interaction processing the preferences above might be Vote count on ballot 1 with candidates alphabetically still in election set X Y Z X 1 Y 2 Z 2 Vote count on ballot 1 with candidates numerically still in election set X Y Z Y 2 Z 2 X 1 Vote count on ballot 2 with candidates alphabetically still in election set Y Z Y 3 Z 2 Vote count on ballot 2 with candidates numerically still in election set Y Z Y 3 Z 2 Winner is Y The first ballot consisted of all three candidates X Y and Z For this ballot the votes were counted and printed candidate X received the fewest number of votes so is eliminated from the next ballot The second ballot consisted of two candidates Y and Z For this ballot the votes were counted and printed candidate Z received the fewest number of votes so is eliminated from the next ballot There is only one candidate remaining so Y is declared the winner An alternative outcome might be No winner election is a tie among all the candidates remaining on the last ballot Functions and Program read voter preferences has an open file parameter it returns the Map representing each voter and his her preferences mine is 14 lines print voter preferences has a Map of voter preferences as a parameter and returns nothing it prints the title followed by the Map whose keys are in alphabetical order mine is 8 lines of code print tally has a std string title a Map of candidates and their number of votes and a function pointer as parameters and returns nothing it prints the title followed by the Map in the appropriate order order specified by the function pointer mine is 7 lines of code evaluate ballot has a Map of voter preferences and a Set of the remaining candidates as parameters it returns a tally a Map whose keys are these candidates and whose values are the number of votes they received on this ballot based on the description of instant runnoff voting Remember to count only one vote per voter for his her highest ranked candidate who is still in the election mine is 12 lines of code remaining candidates has a Map as a parameter whose keys are candidates and whose values are the number of votes they received and returns a set containing all those candidates remaining in the election the one s receiving the fewest number of votes are absent Note that if all the candidates receive the same number of votes then this function returns an empty Set mine is 11 lines Write a program at the bottom of this module the calls these functions to solve the problem mine is 34 lines of code To simplify the interaction you may prompt for the file name and specify a default value votepref1 txt see my prompt string function in ics46goody hpp in the courselib src folder Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one Enter voter preference file name votepref1 txt Voter Preferences A queue X Y Z rear B queue Y Z X rear C queue Y Z X rear D queue Z Y X rear E queue Z Y X rear Vote count on ballot 1 with candidates alphabetically still in election set X Y Z X 1 Y 2 Z 2 Vote count on ballot 1 with candidates numerically still in election set X Y Z Y 2 Z 2 X 1 Vote count on ballot 2 with candidates alphabetically still in election set Y Z Y 3 Z 2 Vote count on ballot 2 with candidates numerically still in election set Y Z Y 3 Z 2 Winner is Y You can also try processing the votepref2 txt file which leads to a No winner result and votepref3 text Problem 3 Finite Automata Problem Summary Write a program that prompts the user to enter the name of a file representing a finite automaton indicating its states and transitions each transition out of a state specifies the input and the new state Read the information in the file storing it in a Map Print the finite automaton Prompt the user to enter the name of a file storing the start state and inputs to process each line in the file contains this combination Repeatedly process these lines computing the results of the finite automaton on each input and then display a trace of the results A finite automaton FA is an machine that is sometimes called Deterministic Finite Automaton DFA An FA is described by its states and its transitions each transition for a state specifies an input and what new state in the FA that input leads to We can illustrate a FA as a graph with labelled edges see below Input and Output Read a file that describes a FA each line contains a state and an arbitrary number of input new state transitions Build a Map such that each key is a std string state and whose associated value is another Map specifying of the transitions from that state this second Map has keys that are std string inputs and associated values that are std string states The first token on each line is the std string state and the remaining tokens always coming in pairs are std string inputs and states All tokens are separated by one semicolon character For example the input file faparity txt contains the following lines which could appear in this order or any other even even 1 odd odd odd 1 even Here is a picture of the parity FA It graphically illustrates the two states even and odd and their transitions using inputs and 1 that always lead back to one of these two states Here the state even meaning it has seen an even number of 1 inputs so far is a key in the main Map It s value is a Map with two key value pairs even and 1 odd It means that in the even state if the input is a the FA stays in the even state if the input is a 1 the FA goes to the odd state And similarly the next line means that for the odd state if the input is a the FA stays in the odd state if the input is a 1 the FA goes back to the even state So seeing an input of keeps the FA in the same state seeing an input of 1 flips the FA into the other state Print the finite automaton one state and its transitions per line the states are printed alphabetically For example the file above would produce Finite Automaton Description even transitions map even 1 odd odd transitions map odd 1 even Note that there are multiple data files for this program faparity txt and fadivisibleby3 txt test debug your program on the first file when you are done test it on the last file Draw the FA represented by each for to ensure that your code correctly prints and computes with it Repeatedly process lines from a second input file computing the results of the finite automaton for a start state and its inputs then print out all the results in a special form Each line in the file contains a start state followed by a sequence of inputs The start state will be a state in the FA is a key in the outer Map the inputs may specify legal or illegal transitions may or may not be keys in some inner Map For example the input file fainputparity txt contains the following three lines even 1 1 1 1 odd 1 1 1 1 even 1 1 1 x The first line means the start state is even and the inputs are 1 1 1 and 1 The result of processing each line is to print the start state and then each input and the new state it transitions to and finally print the stop state For the parity FA and the first line in this file it should print Start state even input 1 new state odd input new state odd input 1 new state even input 1 new state odd input new state odd input 1 new state even Stop state even Functions and Program read fa has an open file parameter it returns the Map representing the finite automaton mine is 17 lines of code print fa has a Map parameter representing the fa it returns nothing but it prints the fa in the appropriate form mine is 6 lines of code process has a Map parameter representing the fa a std string parameter representing the start state and a Queue parameter representing a Queue of std string inputs it returns a Queue that contains pairs of std string that show the input and resulting state after each transition the first value on the Queue has an input that is an empty string and the start state For the example shown above process returns the following Queue queue pair even pair 1 odd pair odd pair 1 even pair 1 odd pair odd pair 1 even rear Finally if an input is illegal is not the key in some transition for the current state say x then process should terminate with the last pair in the Queue indicating a problem x None mine is 12 lines of code interpret has a Queue parameter the result produced by the process function described above it returns nothing but it prints the results of processing a fa on an input See how it prints the Queue shown above in the output further above Also see the Sample Interaction below to see how it prints input errors in the last example mine is 13 lines of code Write a program at the bottom of this module that calls these functions to solve the problem Note that the program loops over the lines in the second file mine is 23 lines of code To simplify the interaction you may prompt for the file name and specify a default value faparity txt and fainputparity txt see my prompt string function in ics46goody hpp in the courselib src folder Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one Enter file with finite automaton faparity txt Finite Automaton even transitions map even 1 odd odd transitions map odd 1 even Enter file with start state and input fainputparity txt Starting new simulation with description even 1 1 1 1 Start state even Input 1 new state odd Input new state odd Input 1 new state even Input 1 new state odd Input new state odd Input 1 new state even Stop state even Starting new simulation with description odd 1 1 1 1 Start state odd Input 1 new state even Input new state even Input 1 new state odd Input 1 new state even Input new state even Input 1 new state odd Stop state odd Starting new simulation with description even 1 1 1 x Start state even Input 1 new state odd Input new state odd Input 1 new state even Input 1 new state odd Input new state odd Input x illegal input terminated Stop state None You can also try the fadivisibleby3 txt finite automaton file which determines whether an integer sequence of digits is divisible by 3 it is if the finite automaton stops in state rem which stand for has remainder Its input file is fainputdivisibleby3 txt which represents the number 12 435 711 which is divisible by 3 followed by the number 823 which is not divisible by 3 it has a remainder of 1 when divided by 3 Problem 4 Non Deterministic FA Problem Summary Write functions and a script that solve for a Non Deterministic Finite Automaton the same problem that was solved for a Deterministic Finite Automaton in Problem 3 above A non deterministic finite automaton NDFA is machine described by its states and its transitions each transition for a state specifies an input and what state or states that what makes it non deterministic that input leads to We can illustrate an NDFA as a graph with labelled edges see below The critical difference is that an NDFA can have multiple edges with the same label going to different states we ll see how to handle such transitions below Input and Output Read a file that describes an NDFA each line contains a state and an arbitrary number of input state transitions Build a Map such that each key is a std string state and whose value is another Map specifying of the transitions from that state this second Map has keys that are std string inputs and values are Sets of std string states all the states a particular input can lead to The first token on each line is the std string state and the remaining tokens always coming in pairs are std string inputs and states here the same input can appear multiple times with different states following All tokens are separated by one semicolon character For example the input file ndfaendin 1 txt contains the following lines which could appear in this order or any other start start 1 start near near 1 end end Here is a picture of the endin 1 NDFA It graphically illustrates the three states start near and end and their transitions using inputs and 1 Here the state start is a key in the main Map It s value is a Map with two key value pairs mapping to the Set containing start and near and 1 mapping to the Set containing just start It means that in the start state if the input is a the NDFA can stay in the start state or it can go to the near state if the input is a 1 the NDFA must stay in the start state And similarly the next line means that in the near state if the input is a 1 the NDFA must go into the end state The last line means that the end state has no transitions out of it Print the NDFA one state and its transitions per line the states are printed alphabetically and the transition Map for each state is printed in the form of a standard Map a series in the form input set of states Note that the state end is a key in the main Map whose associated transitions are an empty Map For example the file above would produce Non Deterministic Finite Automaton Description end transitions map near transitions map 1 set end start transitions map set start near 1 set start Note that there are multiple data files for this program ndfaendin 1 txt ndfatrain txt txt and ndfare txt test debug your program on the first file when you are done test it on the last file Draw the NDFA represented by each for to ensure that your code correctly prints and computes with it Repeatedly process lines from a second matching input file ndfainputendin 1 txt for the example above computing the results of the non determinisitc finite automaton for a start state and its inputs then print out all the results in a special form Each line in the file contains a start state followed by a sequence of inputs The start state will be a state in the DNFA is a key in the outer MapMap For example the input file ndfainputendin 1 txt contains the following two lines start 1 1 1 1 start 1 1 1 For example the first line means the start state is start and the inputs 1 1 1 and 1 The result of processing each line is to print the start state and then each input and the new states plural it could transition to the could is what makes it non deterministic and finally print the stop states For the ndfaendin 1 NDFA and the first line in this file it should print Start state set start Input 1 new states set start Input new states set start near Input 1 new states set start end Input 1 new states set start Input new states set start near Input 1 new states set start end Stop state s set start end Note especially that in the start state if the input is a then the NDFA can either remain in the start state or go into the near state For this program we keep track of all states that the NDFA can be in using a set of new possible states For the next input 1 we can be either in the start state from the start state an input of 1 allows us to stay in the start state or the end state from the near state an input of 1 allows us to transition to the end state Thus we keep track of the set of states the NDFA can be in and the new set of states the NDFA can be in after processing the next input for each of these states In this example because end is included in the stop states this input does end in 1 Functions and Script read ndfa has an open file parameter it returns the Map representing the non deterministic finite automaton hint I used a while loop to read lines and a nested for loop to construct the Map storing each input and the Set of states it can lead to mine is 17 lines print ndfa has a Map parameter representing the NDFA it returns nothing but it prints the NDFA in the appropriate form mine is 6 lines process has a Map parameter representing the NDFA a std string parameter representing the start state and a Queue parameter representing the sequence of std string inputs it returns a Queue that contains pairs of inputs and the resulting states after each transition For the example shown above process returns the following Queue queue pair set start pair 1 set start pair set start near pair 1 set start end pair 1 set start pair set start near pair 1 set start end rear Finally if an input is illegal is not the key in some transition for the current state just ignore it mine is 13 lines interpret has a Queue parameter the result produced by process it returns nothing but it prints the results of processing an NDFA on an input See how it prints the Queue shown above in the output further above mine is 1 lines Write a script at the bottom of this module that calls these functions to solve the problem Note that the script loops over the lines in the second file mine is 23 lines Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one recall the order of values in sets is not important Enter file name of Non Determinstic Finite Automaton ndfaendin 1 txt Non Deterministic Finite Automaton Description end transitions map near transitions map 1 set end start transitions map set start near 1 set start Enter file name of start states and input ndfainputendin 1 txt Starting new simulation with description start 1 1 1 1 Start state set start Input 1 new states set start Input new states set start near Input 1 new states set start end Input 1 new states set start Input new states set start near Input 1 new states set start end Stop state s set start end Starting new simulation with description start 1 1 1 Start state set start Input 1 new states set start Input new states set start near Input 1 new states set start end Input 1 new states set start Input new states set start near Input new states set start near Stop state s set start near The ndfatrain txt file is a non deterministic finite automaton that determines whether an train sequence of characters representing different kinds of cars is a legal train according to Chapter Exercise 7 in the ENBF lecture from ICS 33 Its input file is ndfainputtrain txt whose first input represents a legal train ends when done is one possible stopping state and second input represents an illegal train The ndfare txt file is a non deterministic finite automaton translation of the regular expression a b cd Its input file is ndfainputre txt whose first input represents a matching string ends when last as one possible stopping state and input second does not match Problem 5 Word Generator Problem Summary Write a script that prompts the user to enter the order statistic a positive number and the name of a file of text Read the file of text storing a special corpus in a Map Print the corpus Map Prompt the user to enter the order statistic number of words and the number of random words to generate then print the original words followed by the words randomly generated from the corpus Your program will learn the word pattern of an author based on some order statistic and reading a large sample of the author s writing and then generate random text following the author s word patterns Input and Output After prompting for the order statistic read a file of words building a Map Here the Map s keys are Queuess of n words n is the order statistic and each key s value is a Set of all the words in the text that ever follow these n words e g if n were 2 the Map would contain a keys that are Queues of 2 words for every pair of words appearing next to each other in the text and whose values are a Set of all the words following the key no matter where the pair occurs in the text the Set stores no duplicate words The easiest way to process the words one at a time is to use an outer loop reading lines of text and an inner loop scanning all the words when the line is split using a space character To process a new word if the Queue doesn t have n words just enqueue the word if the Queue has n words use it as a key and put the new word in its associated Set then dequeue the first word and enqueue the new word so the Queue will still contain n words For a simple example the file wginput1 txt contains the following lines it could have all this information on one line or more lines a b c b a d c b a d c a a b a a d Print all the associations in the Map one per line in standard lexical order After printing all associations print the size of the smallest and largest Set that is a value in the Map Each line contains an n word Queue followed by the Set of unique words that follow them in the text In standard lexical order the keys appear in order relative to the first word in the Queue alphabetically for all first words that are the same they appear in order relative to the second word in the Queue alphabetically for all first and second words that are the same they appear in order relative to the third word in the Queue etc see the example below For example the file above would produce Corpus queue a a rear set b d queue a b rear set c a queue a d rear set c queue b a rear set d a queue b c rear set b queue c a rear set a queue c b rear set a queue d c rear set b a min max 1 2 For example queue a d end appears three times in the text above twice followed by c and once followed by nothing at the end of the file queue a b end appears twice in the file above first followed by c and second followed by a Prompt the user for the words to start with there are order statistic number of them they must be in some Queue that is a key in the corpus and the number of random words after that to generate Produce the list of all words and print it A random 1 word list after the words a and d might print as Random text queue a d c a a b a d c b a d rear In the result we start with a d specified by the user we know only c can come next then using d c we know that either b or a must come next it randomly chooses a Functions and Script read corpus has an order statistic parameter and and open file parameter it returns the Map representing the corpus of words in a file mine is 17 lines print corpus has a Map parameter representing the corpus it returns nothing but it prints the corpus in the appropriate form followed the min and max value Set sizes mine is 11 lines the queue gt function produce text has a Map parameter representing the corpus a Queue parameter representing the starting words and an int parameter representing the number of random words to generate it returns a Queue that contains the the starting words followed by the generated words Hint use two Queues of words both starting out with the starting words The first will always contain the current n words to be used as a key in the Map the second will contain all the generated words Generate a random next word from the Map using the random in set function that I wrote in this file then drop the first word from the Queue and add the generated word so it remains a Queue of size n repeat until you have generated the required number of words Warning you might have to stop prematurely if you generate the last n words in the text and if these words occur nowhere else That is because in this case there is no random word to generate following them in this case add a None to the end of the Queue of words and immediately return that Queue mine is 14 lines Write a script at the bottom of this module that calls these functions to solve the problem mine is 21 lines Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one Enter order statistic 2 Enter file name to process wginput1 txt Corpus queue a a rear set b d queue a b rear set c a queue a d rear set c queue b a rear set d a queue b c rear set b queue c a rear set a queue c b rear set a queue d c rear set b a min max 1 2 Enter 2 words to start with Enter word 1 a Enter word 2 d Enter of words to generate 1 Random text queue a d c a a b a d c b a d rear The wginput2 txt file cannot be used to generate a large number of random words for the reason explained in the Warning above With the appropriate modification we can use this same program to read generate music or DNA sequences or any other data made of symbols ", "_id": "http://www.ics.uci.edu/~pattis/ICS-46/assignments/program1/program.html", "title": "program 1", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 1</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 1</h1>\r\n<h1>\r\nProgramming using the ICS-46 Template Library (ITL):<br>\r\nStack, Queue, Priority Queue, Set, and Map\r\n</h1>\r\n<p>\r\n<h2>ICS-46: Data Structure Implementation and Analysis<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to use\r\n  combinations of ITL's templated classes to model and compactly write code\r\n  that solves a variety of different programming problems.\r\nThe kind of abstract thinking that goes into modeling solutions to these\r\n  programming problems with these data types (and iteration over them) is\r\n  critical to your development as computer scientists.\r\n<p>\r\nThere are three parts to this assignment.\r\nIn each you will be asked to write a program (<b>.cpp</b> file) that defines a\r\n  few functions and has a <b>main</b> function, which ties these functions\r\n  together to solve the problem.\r\n<p>\r\nYou should download the \r\n  <a href=\"program1.zip\">program1</a> project folder and use it to create an\r\n  Eclipse project (needing only <b>courselib</b> not <b>googletest</b>).\r\nYou will create each program in this project, and submit each program\r\n  separately in Checkmate.\r\nThe project folder contains boiler-plated files (including some <b>typedefs</b>\r\n  that I found useful in my code: you may change their names) and contains all\r\n  the data files you need to test/debug you program.\r\n<b>Important: Only one of the <b>.cpp</b> files can be active at any time.</b>\r\nIn the download, all are active; so I suggest that you inactivate the\r\n  <b>runoffvoting.cpp</b> and <b>fa.cpp</b> files and work on\r\n  <b>reachable.cpp</b> first.\r\nTo make a progam inactive, select it (in the editor tab), use the <b>Ctrl/a</b>\r\n  command to select all its lines, and then click <b>Source</b> at the top\r\n  left of the menu and choose <b>Toggle Comment</b>: every line will now appear\r\n  in a comment; by using these same instructions, you can toggle back those\r\n  lines to not have comments.\r\n<p>\r\n<b>Instead, you can also use a existing/working project folder: remove (but\r\n  save) all the files in its <b>src</b> folder and then put all the <b>.cpp</b>\r\n  files from the downloaded project's <b>src</b> folder into the\r\n  existing/working project's <b>src</b> folder.\r\nAlso put all the data files into the existing project folder, not in the\r\n <b>src</b> folder.</b>\r\n<p>\r\nYou should work on this assignment in pairs.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early, etc.\r\nIf you believe that it is impossible for you to work with someone, because of\r\n  some special reason(s), you should send me email stating them and asking for\r\n  special permission to work alone (which I do grant, but not frequently).\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  student's names (along with their UniqueID) should appear in the comments at\r\n  the top of <b>each submitted .cpp</b> file.\r\nIt should look something like\r\n<pre><b>\r\n//Romeo Montague(UniqueID from grades spreadsheet)\r\n//Juliet Capulet(UniqueID from grades spreadsheet)\r\n//We certify that we worked cooperatively on this programming\r\n//  assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  before starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can accurately\r\n  assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nYou should familiarize yourselves with the <b>ics46goody.hpp</b> file in the\r\n  <b>courselib/src</b> folder.\r\nIt contains functions useful in all these programs: <b>split</b> and <b>join</b>\r\n  (like their counterparts in Python, they use <b>std::string</b> and \r\n  <b>vector&lt;std::string></b>), <b>prompt_string</b>, and <b>safe_open</b>.\r\n<p>\r\n<p>\r\nThis assignment has 5 parts: pairs should work on each part together, not split\r\n  them up and do them separately.\r\nParts 1-3 are 14 points each (42 points total); Part 4 is worth 10 points;\r\n   Part 5 is worth 8 points.\r\nThis skewing of points towards the simpler parts means students finishing the\r\n  first three parts correctly will have a 70% average; those finishing the\r\n  first four parts correctly will have about an 87% average; but to get an A on\r\n  this assignment requires solving all parts correctly.\r\nRemember I'm going to be running MOSS on the parts of this assignment to check\r\n  for program similarity.\r\n<p>\r\n<b>Important</b>:\r\nThe <a href=\"../../programs/cross_reference.zip\">cross_reference</a>\r\n  program shows an exmple of the form of code that you need to write for these\r\n  programs: study and understand its code before attempting to start\r\n  solving these problems.\r\nQuestions about <b>cross_reference</b>? Post them on a Message Board in the\r\n  Forum.\r\n<p>\r\nUse the array implementations supplied in the ITL for all the data types.\r\nThe programs in the folder you will download has <b>#include</b> statements at\r\n  the top for all the files that you need to use.\r\n<p>\r\nAlong with the details of the functions, I've included the number of lines\r\n  that I wrote in my solution.\r\nI am supplying these number of lines <b>not</b> as a requirement, but as a\r\n  ballpark estimate of the amount of code you should write.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Reachability</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li>Write a program that prompts the user to enter the name of\r\n       a file representing a graph.\r\n<li>Read the information in the file, storing the graph in a map.\r\n\r\n<li>Print the graph.\r\n<li>Repeatedly prompt the user for a starting node in the graph, and compute and\r\n      print all the nodes that are reachable from it by following edges in the\r\n      graph: convert the algorithm for reachability, described in detail below,\r\n      into C++/ITL code.\r\n</ul>\r\n<h3>Input and Output</h3>\r\nRead a file of pairs of node names (representing edges) in a directed\r\n  graph, building a <b>Map</b> whose key is a <b>std::string</b> source node\r\n  and whose value is a <b>Set</b> of <b>std::string</b> destination nodes that\r\n  are each reachable from the source node key.\r\nAlthough the supplied input files use 1-letter names, your code should work\r\n  for any strings: use the <b>split</b> function in <b>ics46goody.hpp</b>.\r\n<p>\r\nTwo nodes appear on each line: first the source node, then the destination\r\n  node, with these node names separated by one semicolon character.\r\nFor example, the input file <b>graph1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other):\r\n<b><pre>  c;f\r\n  b;d\r\n  a;c\r\n  c;e\r\n  d;g\r\n  a;b\r\n  e;d\r\n  f;g\r\n  f;d</pre></b>\r\nwhich represent the graph\r\n<p>\r\n<image src=\"images/graph.gif\">\r\n<p>\r\nPrint the graph, one source node per line (the source nodes are printed\r\n  alphabetically) followed by the set of all the destination nodes that the\r\n  source can immediately reach.\r\nThe graph above would print as\r\n<b><pre>  Graph: source -> {destination} edges\r\n    a -> set[c,b]\r\n    b -> set[d]\r\n    c -> set[f,e]\r\n    d -> set[g]\r\n    e -> set[d]\r\n    f -> set[g,d]</pre></b>\r\n<p>\r\nNote that the source nodes are <b>sorted</b> alphabetically, but the <b>Set</b>\r\n   of desintation nodes does <b>not have to be sorted</b>:\r\n  in fact it makes no sense to talk about sorted <b>Sets</b>; we could talk\r\n  about a sorted <b>Priority Queue</b> whose contents came from a <b>Set</b>.\r\nNote that because node <b>g</b> is not a source node (it is only a\r\n  destination node), it does not appear first on any line (and appears only\r\n  in the <b>Sets</b> for source nodes <b>d</b> and <b>f</b>).\r\n<p>\r\nNote that there are multiple data files for this program: <b>graph1.txt</b>,\r\n  <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on \r\n  the first file; when you are done, test it on the last two.\r\nDraw the graph represented by each for to ensure that your code correctly\r\n  prints it and computes the nodes reachable from any source node (which you\r\n  can do by eyeballing the graphs: they are small).\r\n<p>\r\nRepeatedly prompt the user for a starting node in the graph (until <b>quit</b>\r\n  is entered) and compute and print all the nodes that are reachable from it by\r\n  following edges in the graph.\r\nReject any node not present as keys in the graph.\r\nAn example interaction (processing the graph above) might be\r\n<b><pre>  Enter starting node (enter quit to quit): e\r\n  Reachable from node name e = set[e,d,g]\r\n\r\n  Enter starting node (enter quit to quit): x\r\n    x is not a source node name in the graph\r\n\r\n  Enter starting node (enter quit to quit): a\r\n  Reachable from node name a = set[a,c,b,f,e,d,g]\r\n\r\n  Enter starting node (enter quit to quit): quit</pre></b>\r\n<h3>Functions and Program</h3>\r\n<ul>\r\n<li><b>read_graph</b> has an open (file) parameter; it returns the <b>Map</b>\r\n     representing the graph\r\n    (mine is 12 lines of code).\r\n<p>\r\n<li><b>print_graph</b> has a <b>Map</b> parameter (representing the graph); it\r\n    returns nothing, but it prints the graph in the appropriate form\r\n     (mine is 7 lines of code).\r\n<p>\r\n<li><b>reachable</b> has a <b>Map</b> parameter (representing the graph) and\r\n    a <b>std::string</b> start node in the graph (technically a key in the\r\n    <b>Map</b>); it returns a <b>Set</b> of all the nodes reachable from the\r\n    start node by  following edges in the graph\r\n   (mine is 15 lines).\r\n<p>\r\n<li>Write a program at the bottom of this module that calls these functions\r\n     to solve the problem\r\n     (mine is 22 lines).\r\n    To simplify the interaction, you may prompt for the file name and specify\r\n      a default value (<b>graph1.txt</b>): see my <b>prompt_string</b> function\r\n     in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.\r\n<p>\r\nHere is the basic algorithm for computing reachability; it is simple to explain\r\n  and not (very) complicated to implement.\r\nBut, you have to understand these instructions and carefully translate them into\r\n  C++/ITL code.\r\nYou should hand-simulate this algorithm using the graph above, and verify that\r\n  it produces the results you expect before coding it.\r\nYou might be tempted to use recursion, but please don't: unless recursion is\r\n  done very carefully, it will run forever on graphs with cycles: one of the\r\n  input files is a graph with cycles.\r\n<ol>\r\n<li>To compute all the reachable nodes in a graph, create a <b>Set</b>\r\n   (initially empty) of reached nodes and a <b>Queue</b> (initially containing\r\n   the  parameter start node) of nodes that we are going to explore (to find\r\n   nodes they can reach).\r\n<p>\r\n<li>While the <b>exploring queue</b> still has nodes, remove the first one\r\n    and put it into the <b>reached set</b>; if it is a key in the graph (not all\r\n    nodes are) then for all its destination nodes that are not already in the\r\n   <b>reached set</b>, put them in the <b>exploring queue</b>.\r\n<p>\r\n<li>When the <b>exploring queue</b> becomes empty (can you argue that this\r\n      always will happen -there is no infinite looping), return the\r\n      <b>reached set</b>.\r\n</ol>\r\n<p>\r\nPrint the set containing all these node labels.\r\nWhen debugging this algorithm, print the the entire <b>Set</b> and <b>Queue</b>\r\n  contents (using <b>&lt;&lt;</b>, the standard insertion operator for these\r\n  data types) after every interesting change, or use the debugger to observe\r\n  these changes.\r\n</ul>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one (sets will match if they have the same\r\n  contents, independent of their order).\r\nYou should also check that it works for other starting nodes, and\r\n  a variety of starting nodes in the other graphs.\r\n\r\n<b><pre>  Enter graph file name[graph1.txt]: \r\n\r\n  Graph: source -> {destination} edges\r\n    a -> set[c,b]\r\n    b -> set[d]\r\n    c -> set[f,e]\r\n    d -> set[g]\r\n    e -> set[d]\r\n    f -> set[g,d]\r\n\r\n  Enter starting node (enter quit to quit): e\r\n  Reachable from node name e = set[e,d,g]\r\n\r\n  Enter starting node (enter quit to quit): x\r\n    x is not a source node name in the graph\r\n\r\n  Enter starting node (enter quit to quit): a\r\n  Reachable from node name a = set[a,c,b,f,e,d,g]\r\n\r\n  Enter starting node (enter quit to quit): quit</pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem #2 -->\r\n\r\n<a name=\"problem6\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2: Instant Runoff Voting</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li> Write a program that prompts the user to enter the name of\r\n       a file representing the candidate preferences of a sequence of voters.\r\n<li>Read the information in the file, storing it in a <b>Map</b>.\r\n<li>Print the voter preferences.\r\n<li>Repeatedly display the vote count for ballots (sorted both by candidate\r\n      and numerically), eliminating from the election the candidate(s)\r\n      receiving the fewest votes, until one candidate (the winner) or no\r\n      candidates (a tie) remain.\r\n</ul>\r\nThis form of election is known as <b>instant runoff voting</b>.\r\nEvery voter submits a ballot that ranks all the candidates the election, from\r\n  most favorite candidate to least favorite (we will use a <b>Queue</b>\r\n  for this purpose</b>: earlier candidates in the <b>Queue</b> are more\r\n  favored than later candidates).\r\n<p>\r\nDuring the first ballot, votes are counted for each of the candidates according\r\n  to the rankings of the voters.\r\nThen the candidate(s) with the fewest number of votes are removed from the\r\n  election: if more than one candidate receives the least number of votes, all\r\n  candidates receiving these least number of votes are removed from the\r\n  election.\r\n<p>\r\nDuring the second ballot, votes are tallied for the <b>remaining candidates</b>\r\n  (there are at least 1 fewer candidates); if a voter's first ranked candidate\r\n  is not still in the  election, then his/her second ranked candidate should\r\n  receive the vote; but if his/her second ranked candidate has been removed\r\n  from the election, then his/her third ranked candidate should receive the\r\n  vote ...).\r\n<p>\r\nThis ballot process continues until either 1 candidate remains, or 0 candidates\r\n  remain (meaning that all the remaining candidates tallied the same number\r\n  of votes).\r\nNote that the preferences <b>Map</b> never changes, but how it is intepreted\r\n  does change, since the intepretation is based on which candidates remain in\r\n  the election.\r\n<h3>Input and Output</h3>\r\nRead a file of voters and their ranking of the candidates, separated\r\n  by semicolons, building a <b>Map</b> whose key is each voter and whose\r\n  value is a <b>Queue</b> of candidates ranked by that voter (they appear in the\r\n  file in order, from most favorite to least favorite).\r\n<p>\r\n\r\nFor example, the input file <b>votepref1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other):\r\n<b><pre>  A;X;Y;Z\r\n  B;Y;Z;X\r\n  C;Y;Z;X\r\n  D;Z;Y;X\r\n  E;Z;Y;X</pre></b>\r\nThe first line means, voter <b>A</b> ranks candidate <b>X</b> first,\r\n  candidate <b>Y</b> second, and candidate <b>Z</b> third.\r\nThe second line means, voter <b>B</b> ranks candidate <b>Y</b> first,\r\n  candidate <b>Z</b> second, and candidate <b>X</b> third.\r\nEach line will have a unique voter and a permutation of all the \r\n  candidates running.\r\n<p>\r\nPrint all the associations in this <b>Map</b>, one per line (the voters are\r\n  printed alphabetically) using the following form.\r\nEach line contains the voter and his/her complete ranking of the candidates.\r\nFor example, the file above would produce:\r\n<b><pre>  Voter Preferences\r\n    A -> queue[X,Y,Z]:rear\r\n    B -> queue[Y,Z,X]:rear\r\n    C -> queue[Y,Z,X]:rear\r\n    D -> queue[Z,Y,X]:rear\r\n    E -> queue[Z,Y,X]:rear</pre></b>\r\n<p>\r\nNote that the voter names are <b>sorted</b> alphabetically, but the <b>Queue</b>\r\n  of preferences appears in the same order they appeared in the file.\r\nThere are multiple data files for this program: <b>votepref1.txt</b>, \r\n  <b>votepref2.txt</b>, <b>votepref3.txt</b>, and <b>votepref4.txt</b>;\r\n  test/debug your program on the first file; when you are done, test it on the\r\n  rest.\r\n<p>\r\nStart with all the candidates.\r\nEvaluate the ballot to determine how many votes each candidate received.\r\nPrint this vote count two ways: sorted alphabetically and sorted numerically\r\n  (in decreasing order: if more than one candidate receives the same number of\r\n   votes, they should appear sorted alphabetically).\r\nRemove the candidate(s) receiving the fewest votes, and repeat this process\r\n  until only one or no candidates remain.\r\nFinally, print the outcome of the election: a single candidate winner or a tie.\r\nAn example interaction (processing the preferences above) might be\r\n<b><pre>  Vote count on ballot #1 with candidates alphabetically: still in election = set[X,Y,Z]\r\n    X -> 1\r\n    Y -> 2\r\n    Z -> 2\r\n  \r\n  Vote count on ballot #1 with candidates numerically: still in election = set[X,Y,Z]\r\n    Y -> 2\r\n    Z -> 2\r\n    X -> 1\r\n\r\n  Vote count on ballot #2 with candidates alphabetically: still in election = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Vote count on ballot #2 with candidates numerically: still in election = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\nWinner is Y</pre></b>\r\nThe first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, \r\n  and <b>Z</b>.\r\nFor this ballot, the votes were counted and printed; candidate <b>X</b>\r\n  received the fewest number of votes so is eliminated from the next ballot.\r\nThe second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.\r\nFor this ballot, the votes were counted and printed; candidate <b>Z</b>\r\n  received the fewest number of votes so is eliminated from the next ballot.\r\nThere is only one candidate remaining so <b>Y</b> is declared the winner.\r\nAn alternative outcome might be\r\n<b>No winner: election is a tie among all the candidates remaining on the last ballot</b>\r\n<h3>Functions and Program</h3>\r\n<ul>\r\n<li><b>read_voter_preferences</b> has an open (file) parameter; it returns the\r\n       <b>Map</b> representing each voter and his/her preferences\r\n      (mine is 14 lines).\r\n<p>\r\n<li><b>print_voter_preferences</b> has a <b>Map</b> of voter preferences as a\r\n         parameter and returns nothing;\r\n         it prints the title followed by the <b>Map</b> whose keys are in\r\n         alphabetical order\r\n       (mine is 8 lines of code).\r\n<p>\r\n<li><b>print_tally</b> has a <b>std::string</b> title, a <b>Map</b> of\r\n         candidates and their number of votes, and a\r\n         function pointer as parameters and returns nothing; it\r\n         prints the title followed by the <b>Map</b> in the appropriate order\r\n         order (specified  by the function pointer)\r\n       (mine is 7 lines of code).\r\n<p>\r\n<li><b>evaluate_ballot</b> has a <b>Map</b> of voter preferences and a\r\n         <b>Set</b> of the remaining candidates as parameters; it returns\r\n         a tally: a <b>Map</b> whose keys are these candidates and whose values\r\n         are the number of votes they received on this ballot, based on the\r\n         description of <b>instant runnoff voting</b>\r\n       Remember to count only one vote per voter, for his/her highest ranked\r\n         candidate who is still in the election\r\n      (mine is 12 lines of code).\r\n<p>\r\n<li><b>remaining_candidates</b> has a <b>Map</b> as a parameter whose keys are\r\n          candidates and whose values are the number of votes they received and\r\n          returns a set containing all those candidates remaining in the\r\n          election (the one(s) receiving the fewest number of votes are absent).\r\n       Note that if all the candidates receive the same number of votes, then\r\n         this function returns an empty <b>Set</b>\r\n       (mine is 11 lines).\r\n<p>\r\n<li>Write a program at the bottom of this module the calls these functions\r\n     to solve the problem\r\n     (mine is 34 lines of code).\r\n   To simplify the interaction, you may prompt for the file name and specify\r\n      a default value (<b>votepref1.txt</b>): see my <b>prompt_string</b>\r\n      function in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.\r\n</ul>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<pre><b>  Enter voter preference file name[votepref1.txt]:\r\n\r\n  Voter Preferences\r\n    A -> queue[X,Y,Z]:rear\r\n    B -> queue[Y,Z,X]:rear\r\n    C -> queue[Y,Z,X]:rear\r\n    D -> queue[Z,Y,X]:rear\r\n    E -> queue[Z,Y,X]:rear\r\n\r\n  Vote count on ballot #1 with candidates alphabetically: still in election = set[X,Y,Z]\r\n    X -> 1\r\n    Y -> 2\r\n    Z -> 2\r\n  \r\n  Vote count on ballot #1 with candidates numerically: still in election = set[X,Y,Z]\r\n    Y -> 2\r\n    Z -> 2\r\n    X -> 1\r\n\r\n  Vote count on ballot #2 with candidates alphabetically: still in election = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Vote count on ballot #2 with candidates numerically: still in election = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Winner is Y</pre></b>\r\n<p>\r\nYou can also try processing the <b>votepref2.txt</b> file (which leads to\r\n  a <b>No winner</b> result) and <b>votepref3.text</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem 3 -->\r\n\r\n<a name=\"problem3\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #3: Finite Automata</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li>Write a program that prompts the user to enter the name of\r\n       a file representing a finite automaton: indicating its <b>states</b> and\r\n       <b>transitions</b> (each transition out of a state specifies the\r\n       <b>input</b> and the new <b>state</b>).\r\n<li>Read the information in the file, storing it in a <b>Map</b>.\r\n<li>Print the finite automaton.\r\n<li>Prompt the user to enter the name of a file storing the start-state\r\n      and inputs to process (each line in the file contains this combination).\r\n<li>Repeatedly process these lines computing the results of the finite\r\n      automaton on each input, and then display a trace of the results.\r\n</ul>\r\nA <b>finite  automaton</b> (FA) is an machine that is sometimes called\r\n  Deterministic Finite Automaton (DFA).\r\nAn FA is described by its <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what\r\n  new <b>state</b> in the FA that input leads to.\r\nWe can illustrate a FA as a graph with labelled edges (see below).\r\n<p>\r\n\r\n<h3>Input and Output</h3>\r\nRead a file that describes a FA: each line contains a state and an\r\n  arbitrary number of input-&gt;new state <b>transitions</b>.\r\nBuild a <b>Map</b> such that each key is a <b>std::string</b> state and whose\r\n   associated value is another <b>Map</b> specifying of the transitions from\r\n   that state: this second <b>Map</b> has keys that are <b>std::string</b>\r\n   inputs and associated values that are <b>std::string</b> states.\r\nThe first token on each line is the <b>std::string</b> state and the remaining\r\n  tokens (always coming in pairs) are <b>std::string</b> inputs and states.\r\nAll tokens are separated by one semicolon character.\r\n<p>\r\n\r\nFor example, the input file <b>faparity.txt</b> contains the following lines\r\n  (which could appear in this order, or any other):\r\n<b><pre>  even;0;even;1;odd\r\n  odd;0;odd;1;even</pre></b>\r\nHere is a picture of the <b>parity</b> FA.\r\nIt graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)\r\n  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)\r\n  that always lead back to one of these two states.\r\n<p>\r\n\r\n<img src=\"images/parity.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>even</b> (meaning it has seen an even number of <b>1</b>\r\n  inputs so far) is a key in the main <b>Map</b>.\r\nIt's value is a <b>Map</b> with two key/value pairs <b>0</b>/<b>even</b>\r\n  and <b>1</b>/<b>odd</b>.\r\nIt means that in the <b>even</b> state, if the input is a <b>0</b> the\r\n  FA stays in the <b>even</b> state; if the input is a <b>1</b> the\r\n  FA goes to the <b>odd</b> state.\r\nAnd similarly (the next line) means that for the <b>odd</b> state, if the input\r\n  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a\r\n  <b>1</b> the FA goes back to the <b>even</b> state.\r\nSo, seeing an input of <b>0</b> keeps the FA in the same state;\r\n  seeing an input of <b>1</b> flips the FA into the other state.\r\n<p>\r\n\r\nPrint the finite automaton, one state (and its transitions) per line;\r\n  the states are printed alphabetically.\r\n<p>\r\nFor example, the file above would produce:\r\n<b><pre>  Finite Automaton Description\r\n    even transitions: map[0->even,1->odd]\r\n    odd transitions: map[0->odd,1->even]</pre></b>\r\n<p>\r\nNote that there are multiple data files for this program: <b>faparity.txt</b>\r\n  and <b>fadivisibleby3.txt</b>; test/debug your program on \r\n  the first file; when you are done, test it on the last file.\r\nDraw the FA represented by each for to ensure that your code correctly\r\n  prints and computes with it.\r\n<p>\r\nRepeatedly process lines from a second input file, computing the results of the\r\n  finite automaton for a start-state and its inputs; then print out all the\r\n  results in a special form.\r\nEach line in the file contains a start-state followed by a sequence of inputs.\r\nThe start-state will be a state in the FA (is a key in the outer <b>Map</b>)\r\n  the inputs may specify legal or illegal transitions (may or may not be keys\r\n  in some inner <b>Map</b>).\r\n<p>\r\nFor example, the input file <b>fainputparity.txt</b> contains the following\r\n  three lines:\r\n<b><pre>  even;1;0;1;1;0;1\r\n  odd;1;0;1;1;0;1\r\n  even;1;0;1;1;0;x</pre></b>\r\nThe first line means, the start-state is <b>even</b> and the\r\n  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\nThe result of processing each line is to print the start-state, and then each\r\n  input and the new state it transitions to, and finally print the stop-state.\r\nFor the <b>parity</b> FA and the first line in this file, it should print\r\n<b><pre>Start state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\nStop state = even</pre></b>\r\n<p>\r\n\r\n<h3>Functions and Program</h3>\r\n<ul>\r\n<li><b>read_fa</b> has an open (file) parameter; it returns the <b>Map</b>\r\n     representing the finite automaton\r\n     (mine is 17 lines of code).\r\n<p>\r\n<li><b>print_fa</b> has a <b>Map</b> parameter (representing the fa); it\r\n    returns nothing,  but it prints the fa in the appropriate form\r\n     (mine is 6 lines of code).\r\n<p>\r\n<li><b>process</b> has a <b>Map</b> parameter (representing the fa),\r\n    a <b>std::string</b> parameter (representing the start-state), and a\r\n    <b>Queue</b> parameter (representing a <b>Queue</b> of <b>std::string</b>\r\n    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of\r\n    <b>std::string</b> that show the input and resulting state after each\r\n    transition (the first value on the <b>Queue</b> has an input that is an\r\n    empty string and the start state).\r\n    For the example shown above, <b>process</b> returns the following\r\n    <b>Queue</b>.\r\n<b><pre>queue[pair[,even],pair[1,odd],pair[0,odd],pair[1,even],pair[1,odd],pair[0,odd],pair[1,even]]:rear</pre></b>\r\n    Finally, if an input is illegal (is not the key in some transition for the\r\n    current state), say\r\n    <b>\"x\"</b>, then <b>process</b> should terminate with the last\r\n    <b>pair</b> in the <b>Queue</b> indicating a problem: <b>(x, None)</b>\r\n   (mine is 12 lines of code).\r\n<p>\r\n<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by the\r\n    <b>process</b> function described above); it returns nothing, but it prints\r\n    the results of processing a fa on an input.\r\n    See how it prints the <b>Queue</b> shown above in the output further above.\r\n    Also see the <b>Sample Interaction</b> below to see how it prints\r\n    <i>input errors</i> (in the last example)\r\n   (mine is 13 lines of code).\r\n<p>\r\n<li>Write a program at the bottom of this module that calls these functions\r\n        to solve the problem.\r\n      Note that the program loops over the lines in the second file\r\n       (mine is 23 lines of code).\r\n    To simplify the interaction, you may prompt for the file name and specify\r\n      a default value (<b>faparity.txt</b> and <b>fainputparity.txt</b>): see\r\n      my <b>prompt_string</b> function in <b>ics46goody.hpp</b> in the\r\n      <b>courselib/src</b> folder.\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<b><pre>  Enter file with finite automaton[faparity.txt]:\r\n\r\n  Finite Automaton\r\n    even transitions: map[0->even,1->odd]\r\n    odd transitions: map[0->odd,1->even]\r\n\r\n  Enter file with start-state and input[fainputparity.txt]:\r\n  \r\n  Starting new simulation with description: even;1;0;1;1;0;1\r\n  Start state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n  Stop state = even\r\n  \r\n  Starting new simulation with description: odd;1;0;1;1;0;1\r\n  Start state = odd\r\n    Input = 1; new state = even\r\n    Input = 0; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 0; new state = even\r\n    Input = 1; new state = odd\r\n  Stop state = odd\r\n  \r\n  Starting new simulation with description: even;1;0;1;1;0;x\r\n  Start state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = x; illegal input: terminated\r\n  Stop state = None</b></pre>\r\n<p>\r\nYou can also try the <b>fadivisibleby3.txt</b> finite automaton file, which\r\n  determines whether an integer (sequence of digits) is divisible by 3: it is\r\n  if the finite automaton stops in state <b>rem0</b> (which stand for <b>has\r\n  remainder 0</b>).\r\nIts input file is <b>fainputdivisibleby3.txt</b>, which represents the \r\n  number <b>12,435,711</b>, which is divisible by <b>3</b>, followed by the\r\n  number <b>823</b>, which is not divisible by <b>3</b> (it has a remainder of\r\n  <b>1</b> when divided by <b>3</b>).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 4 -->\r\n\r\n<a name=\"problem4\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #4: Non-Deterministic FA</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<li> Write functions and a script that solve for a Non-Deterministic Finite\r\n       Automaton the same problem that was solved for a Deterministic Finite\r\n       Automaton in Problem #3 (above).\r\n<p>\r\nA non-deterministic finite automaton (NDFA) is machine described by its\r\n  <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what\r\n  <b>state</b> (or <b>states</b>: that what makes it non-deterministic) that\r\n  input leads to.\r\nWe can illustrate an NDFA as a graph with labelled edges (see below).\r\nThe critical difference is that an NDFA can have multiple edges with the same\r\n  label going to different states (we'll see how to handle such transitions\r\n  below).\r\n<p>\r\n\r\n<h3>Input and Output</h3>\r\nRead a file that describes an NDFA: each line contains a state and an\r\n  arbitrary number of input-&gt;state <b>transitions</b>.\r\nBuild a <b>Map</b> such that each key is a <b>std::string</b> state and whose\r\n   value is another <b>Map</b> specifying of the transitions from that state:\r\n   this second <b>Map</b> has keys that are <b>std::string</b> inputs and \r\n   values are <b>Sets</b> of <b>std::string</b> states: all the states a\r\n   particular input can lead to.\r\nThe first token on each line is the <b>std::string</b> state and the remaining\r\n  tokens (always coming in pairs) are <b>std::string</b> inputs and states:\r\nhere the same input can appear multiple times with different states following.\r\nAll tokens are separated by one semicolon character.\r\n<p>\r\n\r\nFor example, the input file <b>ndfaendin01.txt</b> contains the following lines\r\n  (which could appear in this order, or any other):\r\n<b><pre>  start;0;start;1;start;0;near\r\n  near;1;end\r\n  end</pre></b>\r\nHere is a picture of the <b>endin01</b> NDFA.\r\nIt graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,\r\n  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>\r\n  and <b>1</b>).\r\n<p>\r\n\r\n<img src=\"images/endin01.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>start</b> is a key in the main <b>Map</b>.\r\nIt's value is a <b>Map</b> with two key/value pairs <b>0</b> mapping to the\r\n  <b>Set</b> containing <b>start</b> and <b>near</b> and <b>1</b> mapping to\r\n  the <b>Set</b> containing just <b>start</b>.\r\nIt means that in the <b>start</b> state, if the input is a <b>0</b> the\r\n  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>\r\n  state; if the input is a <b>1</b> the NDFA must stay in the <b>start</b>\r\n  state.\r\nAnd similarly the next line means that in the <b>near</b> state, if the\r\n  input is a <b>1</b> the NDFA must go into the <b>end</b> state.\r\nThe last line means that the <b>end</b> state has no transitions out of it.\r\n<p>\r\n\r\nPrint the NDFA, one state (and its transitions) per line;\r\n  the states are printed alphabetically and the transition <b>Map</b>\r\n  for each state is printed in the form of a standard <b>Map</b>: a series in\r\n  the form <b>input -> set of states</b>.\r\nNote that the state <b>end</b> is a key in the main <b>Map</b>, whose\r\n  associated transitions are an empty <b>Map</b>.\r\n<p>\r\n\r\nFor example, the file above would produce:\r\n<b><pre>  Non_Deterministic Finite Automaton Description\r\n  end transitions: map[]\r\n  near transitions: map[1->set[end]]\r\n  start transitions: map[0->set[start,near],1->set[start]]</pre></b>\r\n<p>\r\nNote that there are multiple data files for this program:\r\n  <b>ndfaendin01.txt</b>, <b>ndfatrain.txt.txt</b>, and <b>ndfare.txt</b>;\r\n  test/debug your program on the first file; when you are done, test it on the\r\n  last file.\r\nDraw the NDFA represented by each for to ensure that your code correctly\r\n  prints and computes with it.\r\n<p>\r\nRepeatedly process lines from a second matching input file\r\n (<b>ndfainputendin01.txt</b> for the example above), computing the results of\r\n  the non-determinisitc finite automaton for a start-state and its inputs; then\r\n  print out all the results in a special form.\r\nEach line in the file contains a start-state followed by a sequence of inputs.\r\nThe start-state will be a state in the DNFA (is a key in the outer <b>Map</b)\r\n  the inputs specify transitions (which may or may not be keys in some inner\r\n  <b>Map</b>).\r\n<p>\r\nFor example, the input file <b>ndfainputendin01.txt</b> contains the following\r\n  two lines:\r\n<b><pre>  start;1;0;1;1;0;1\r\n  start;1;0;1;1;0;0</pre></b>\r\nFor example, the first line means, the start-state is <b>start</b> and the\r\n  inputs <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\n\r\nThe result of processing each line is to print the start-state, and then each\r\n  input and the new states (plural) it could transition to (the <b>could</b>\r\n  is what makes it non-deterministic), and finally print the stop-states.\r\nFor the <b>ndfaendin01</b> NDFA and the first line in this file, it should print\r\n<b><pre>  Start state = set[start]\r\n  Input = 1; new states = set[start]\r\n  Input = 0; new states = set[start,near]\r\n  Input = 1; new states = set[start,end]\r\n  Input = 1; new states = set[start]\r\n  Input = 0; new states = set[start,near]\r\n  Input = 1; new states = set[start,end]\r\nStop state(s) = set[start,end]</pre></b>\r\n<p>\r\n\r\nNote especially that in the <b>start</b> state, if the input is a <b>0</b>,\r\n  then the NDFA can either remain in the <b>start</b> state or go into the\r\n  <b>near</b> state.\r\nFor this program, we keep track of all states that the NDFA can be in,\r\n  using a <b>set</b> of <b>new possible states</b>.\r\nFor the next input, <b>1</b>, we can be either in the <b>start</b> state\r\n  (from the <b>start</b> state, an input of <b>1</b> allows us to stay in the\r\n  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state, an\r\n  input of <b>1</b> allows us to transition to the <b>end</b> state).\r\nThus, we keep track of the <b>set</b> of states the NDFA can be in, and the\r\n  new <b>set</b> of states the NDFA can be in after processing the next input\r\n  for each of these states.\r\nIn this example, because <b>'end'</b> is included in the stop-states, this\r\n  input does end in <b>01</b>.\r\n<p>\r\n<h3>Functions and Script</h3>\r\n<ul>\r\n<li><b>read_ndfa</b> has an open (file) parameter; it returns the <b>Map</b>\r\n     representing the non-deterministic finite automaton; <b>hint</b>: I used\r\n     a <b>while</b> loop to read lines and a nested <b>for</b> loop to construct\r\n     the <b>Map</b> storing each input and the <b>Set</b> of states it can lead\r\n     to (mine is 17 lines).\r\n<p>\r\n<li><b>print_ndfa</b> has a <b>Map</b> parameter (representing the NDFA); it\r\n    returns nothing,  but it prints the NDFA in the appropriate form\r\n     (mine is 6 lines).\r\n<p>\r\n<li><b>process</b> has a <b>Map</b> parameter (representing the NDFA),\r\n    a <b>std::string</b> parameter (representing the start-state), and a\r\n    <b>Queue</b> parameter (representing the sequence of <b>std::string</b>\r\n    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of \r\n    inputs and the resulting states after each transition.\r\n    For the example shown above, <b>process</b> returns the following\r\n    <b>Queue</b>.\r\n<b><pre>  queue[pair[,set[start]],pair[1,set[start]],pair[0,set[start,near]],pair[1,set[start,end]],\r\n        pair[1,set[start]],pair[0,set[start,near]],pair[1,set[start,end]]]:rear</pre></b>\r\n    Finally, if an input is illegal (is not the key in some transition for the\r\n    current state), just ignore it\r\n   (mine is 13 lines).\r\n<p>\r\n<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by\r\n    <b>process</b>; it returns nothing, but it prints the results of processing\r\n    an NDFA on an input.\r\n    See how it prints the <b>Queue</b> shown above in the output further above\r\n   (mine is 10 lines).\r\n<p>    \r\n<li>Write a script at the bottom of this module that calls these functions\r\n      to solve the problem.\r\n    Note that the script loops over the lines in the second file\r\n   (mine is 23 lines).\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one (recall the order of values in sets is\r\n  not important).\r\n<b><pre>  Enter file name of Non-Determinstic Finite Automaton[ndfaendin01.txt]: \r\n  Non_Deterministic Finite Automaton Description\r\n    end transitions: map[]\r\n    near transitions: map[1->set[end]]\r\n    start transitions: map[0->set[start,near],1->set[start]]\r\n\r\n  Enter file name of start-states and input[ndfainputendin01.txt]: \r\n\r\n  Starting new simulation with description: start;1;0;1;1;0;1\r\n  Start state = set[start]\r\n    Input = 1; new states = set[start]\r\n    Input = 0; new states = set[start,near]\r\n    Input = 1; new states = set[start,end]\r\n    Input = 1; new states = set[start]\r\n    Input = 0; new states = set[start,near]\r\n    Input = 1; new states = set[start,end]\r\n  Stop state(s) = set[start,end]\r\n\r\n  Starting new simulation with description: start;1;0;1;1;0;0\r\n  Start state = set[start]\r\n    Input = 1; new states = set[start]\r\n    Input = 0; new states = set[start,near]\r\n    Input = 1; new states = set[start,end]\r\n    Input = 1; new states = set[start]\r\n    Input = 0; new states = set[start,near]\r\n    Input = 0; new states = set[start,near]\r\n  Stop state(s) = set[start,near]</pre></b>\r\n<p>\r\nThe <b>ndfatrain.txt</b> file is a non-deterministic finite automaton\r\n  that determines whether an train (sequence of characters representing\r\n  different kinds of cars) is a legal train according to Chapter Exercise #7\r\n  in the ENBF lecture from ICS-33..\r\nIts input file is <b>ndfainputtrain.txt</b>, whose first input represents a\r\n  legal train: ends when <b>done</b> is one possible stopping state; and second\r\n  input represents an illegal train.\r\n<p>\r\nThe <b>ndfare.txt</b> file is a non-deterministic finite automaton translation\r\n  of the regular expression <b>((a*|b)cd)+</b>. \r\nIts input file is <b>ndfainputre.txt</b>, whose first input represents a\r\n  matching string: ends when <b>last</b> as one possible stopping state; and\r\n  input second does not\r\n  match.\r\n</td>\r\n</tbody>\r\n</table>\r\n  \r\n\r\n\r\n<!-- Problem #5 -->\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #5: Word Generator</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li> Write a script that prompts the user to enter the <b>order statistic</b>\r\n  (a positive number) and the name of a file of text.\r\n<li>Read the file of text, storing a special <b>corpus</b> in a <b>Map</b>.\r\n<li>Print the <b>corpus Map</b>.\r\n<li>Prompt the user to enter the order statistic number of words, and the number\r\n      of random words to generate, then print the original words followed by\r\n      the words randomly generated from the <b>corpus</b>.\r\n</ul>\r\nYour program will \"learn\" the word pattern of an author (based on some\r\n  \"order statistic\" and reading a large sample of the author's writing) and\r\n  then generate random text following the author's word patterns.\r\n<p>\r\n<h3>Input and Output</h3>\r\nAfter prompting for the order statistic, read a file of words, building a\r\n  <b>Map</b>.\r\nHere the <b>Map</b>'s keys are <b>Queues</b>s of <b>n</b> words (<b>n</b>\r\n  is the order statistic</b>) and each key's value is a <b>Set</b> of all the\r\n  words in the text that ever follow these <b>n</b> words:\r\n  e.g., if <b>n</b> were <b>2</b>, the <b>Map</b> would contain a keys that are\r\n  <b>Queue</b>s of 2 words (for every pair of words appearing next to each\r\n  other in the text) and whose values are a <b>Set</b> of all the words\r\n  following the key (no matter where the pair occurs in the text; the <b>Set</b>\r\n  stores no duplicate words).\r\n<p>\r\nThe easiest way to process the words one at a time is to use an outer loop\r\n  reading lines of text and an inner loop scanning all the words when the line\r\n  is split using a space character.\r\nTo process a new word, if the <b>Queue</b> doesn't have <b>n</b> words, just\r\n  enqueue the word; if the <b>Queue</b> has <b>n</b> words, use it as a key and\r\n  put the new word in its associated <b>Set</b>, then dequeue the first word\r\n  and enqueue the new word (so the <b>Queue</b> will still contain <b>n</b>\r\n  words).\r\n<p>\r\nFor a simple example, the file <b>wginput1.txt</b> contains the following\r\n  lines (it could have all this information on one line or more lines):\r\n<b><pre>  a b c b a d c b a d\r\n  c a a b a a d</pre></b>\r\n  \r\n<p>\r\nPrint all the associations in the <b>Map</b>, one per line in standard lexical\r\n  order.\r\n<p>\r\nAfter printing all associations, print the size of the smallest and largest\r\n  <b>Set</b> that is a value in the <b>Map</b>.\r\nEach line contains an <b>n</b> word <b>Queue</b>, followed by the <b>Set</b>\r\n   of unique words that follow them in the text.\r\nIn standard lexical order, the keys appear in order relative to the first word \r\n  in the <b>Queue</b> (alphabetically); for all first words that are the same,\r\n  they appear in order relative to the second word in the <b>Queue</b>\r\n  (alphabetically); for all first and second words that are the same, they \r\n appear in order relative to the third word in the <b>Queue</b>; etc.\r\n  (see the example below).\r\n<p>\r\nFor example, the file above would produce:\r\n<b><pre>  Corpus\r\n    queue[a,a]:rear -> set[b,d]\r\n    queue[a,b]:rear -> set[c,a]\r\n    queue[a,d]:rear -> set[c]\r\n    queue[b,a]:rear -> set[d,a]\r\n    queue[b,c]:rear -> set[b]\r\n    queue[c,a]:rear -> set[a]\r\n    queue[c,b]:rear -> set[a]\r\n    queue[d,c]:rear -> set[b,a]\r\n  min/max = 1/2</pre></b>\r\n<p>\r\nFor example, <b>queue[a,d]:end</b> appears three times in the text above, twice\r\n  followed by <b>c</b> and once followed by nothing (at the end of the file);\r\n  <b>queue[a,b]:end</b> appears twice in the file above, first followed by\r\n  <b>c</b> and second followed by <b>a</b>.\r\n<p>\r\n\r\nPrompt the user for the words to start with (there are order statistic number\r\n  of them; they must be in some <b>Queue</b> that is a key in the\r\n  <b>corpus</b>) and the number of random words after that to generate.\r\nProduce the list of all words and print it. \r\n<p>\r\nA random 10 word list, after the words <b>a</b> and <b>d</b> might\r\n  print as\r\n<pre><b>    Random text = queue[a,d,c,a,a,b,a,d,c,b,a,d]:rear</b></pre>\r\nIn the result we start with <b>a d</b> (specified by the user), we\r\n  know only <b>c</b> can come next; then using <b>d c</b> we know that\r\n  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...\r\n<p>\r\n\r\n<h3>Functions and Script</h3>\r\n<ul>\r\n<li><b>read_corpus</b> has an order statistic parameter and and open (file)\r\n     parameter; it returns the <b>Map</b> representing the corpus of\r\n     words in a file\r\n    (mine is 17 lines).\r\n<p>\r\n<li><b>print_corpus</b> has a <b>Map</b> parameter (representing the corpus);\r\n     it returns nothing, but it prints the corpus in the appropriate form\r\n     followed the min and max value <b>Set</b> sizes\r\n     (mine is 11 lines + the <b>queue_gt</b> function).\r\n<p>\r\n<li><b>produce_text</b> has a <b>Map</b> parameter (representing the corpus),\r\n    a <b>Queue</b> parameter (representing the starting words), and an\r\n    <b>int</b> parameter (representing the number of random words to generate);\r\n    it returns a <b>Queue</b> that contains the the starting words followed by\r\n    the generated words.\r\n    <p>\r\n    <b>Hint</b>: use two <b>Queue</b>s of words, both starting out with the\r\n       starting words.\r\n    The first will always contain the current <b>n</b> words to be used as a\r\n      key in the <b>Map</b>); the second will contain all the generated words.\r\n    Generate a random next word from the <b>Map</b> using the\r\n      <b>random_in_set</b> function that I wrote in this file; then \r\n      drop the first word from the <b>Queue</b> and add the generated word, so\r\n      it remains a <b>Queue</b> of size <b>n</b>; repeat until you have\r\n      generated the required number of words.\r\n    <p>\r\n    <b>Warning</b>: you might have to stop prematurely if you generate the last\r\n      <b>n</b> words in the text, and if these words occur nowhere else.\r\n    That is because in this case, there is no random word to generate following\r\n      them; in this case add a <b>\"None\"</b> to the end of the <b>Queue</b>\r\n      of words and immediately return that <b>Queue</b>\r\n    (mine is 14 lines).\r\n<p>\r\n<li>Write a script at the bottom of this module that calls these functions\r\n      to solve the problem.\r\n   (mine is 21 lines).\r\n</ul>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<pre><b>  Enter order statistic[2]: \r\n  Enter file name to process[wginput1.txt]: \r\n\r\n  Corpus\r\n    queue[a,a]:rear -> set[b,d]\r\n    queue[a,b]:rear -> set[c,a]\r\n    queue[a,d]:rear -> set[c]\r\n    queue[b,a]:rear -> set[d,a]\r\n    queue[b,c]:rear -> set[b]\r\n    queue[c,a]:rear -> set[a]\r\n    queue[c,b]:rear -> set[a]\r\n    queue[d,c]:rear -> set[b,a]\r\n  min/max = 1/2\r\n\r\n  Enter 2 words to start with\r\n  Enter word 1: a\r\n  Enter word 2: d\r\n  Enter # of words to generate: 10\r\n  Random text = queue[a,d,c,a,a,b,a,d,c,b,a,d]:rear</b></pre>\r\n<p>\r\nThe <b>wginput2.txt</b> file cannot be used to generate a large number of\r\n  random words for the reason explained in the <b>Warning</b> above.\r\n<p>\r\nWith the appropriate modification, we can use this same program to\r\n  read/generate music or DNA sequences or any other data made of symbols.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</tbody>\r\n</table>\r\n</html>\r\n", "id": 11055.0}