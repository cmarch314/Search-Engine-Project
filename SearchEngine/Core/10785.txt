{"text": "Java Design Patterns Home Foundations home Sets Relations Correspondences Ordered Sets Lattices Graphs Powersets Binary Strings Logic AIA Greek Glossary Abstracts Argument Glossaries Inquiry Cycle Legal Relations Presentations Elicitation Glossaries Goals i SCR Tracing Alloy MSCs Regular Exprs Design Patterns Javadoc Java Packages Java Types X HTML XML Schemas XSLT Design patterns are patterns of organizing program implementations They express good coding ideas that can be reused in other programs GHJV95 is the basic reference and a large number of patterns are published in other sources of which a few of the most useful are discussed here Table of contents The example Consider a group of classes that represent logical expressions These classes represent all the simple and compound elements of such expressions described in the grammars below The grammar is set up for ease of parsing Lexical elements are named in small caps and specified as regular expressions formula logicalConstant logicalVariable negation conjunction disjunction logicalConstant 1 logicalVariable a z A Za z 9 negation formula conjunction formula formula disjunction formula formula A basic Java implementation of this grammar is the formula package It and the formulaVisited package which makes use of the patterns described below are specified with javadoc documentation The Factory pattern A constructor always produces an object of a specific class the class whose constructor it is In some situations it would be more helpful to be able to construct an object belonging to a subclass without having to know ahead of time which subclass any particular object will belong to A factory is a class or method that constructs objects of a particular interface or superclass choosing which subclass is appropriate at run time For example a method that reads strings for formulas as defined in the grammar above might construct a Negation object if the top level operation in the formula is a negation or a Conjunction object if the top level was a conjunction The return type of the method would simply be Formula package formulaVisited import java io A factory for creating formulas from a reader The specific Formula subclass that is returned depends on what the reader reads Because the factory is stateless all its methods are static True and false are represented by 1 and variables are strings of letters and digits beginning with a lowercase letter the negation operator is conjunctions are in with as the infix operator and disjunctions are in with as the infix operator public class Factory Reads a character stream and returns the formula corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static public Formula factory PushbackReader in throws IOException int cc cc in read in unread cc if 1 cc throw new RuntimeException Expected formula found EOF else if cc return factoryConjunction in else if cc return factoryDisjunction in else if cc return factoryNegation in else if cc return factoryLogicalConstant in else if 1 cc return factoryLogicalConstant in else if Character isLowerCase char cc return factoryLogicalVariable in else throw new RuntimeException Expected formula found printable cc Reads a character stream and returns the conjunction corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static Formula factoryConjunction PushbackReader in throws IOException expect in Formula left factory in skipWhitespace in expect in Formula right factory in skipWhitespace in expect in return new Conjunction left right Reads a character stream and returns the disjunction corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static Formula factoryDisjunction PushbackReader in throws IOException expect in Formula left factory in skipWhitespace in expect in Formula right factory in skipWhitespace in expect in return new Disjunction left right Reads a character stream and returns the logical constant corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static LogicalConstant factoryLogicalConstant PushbackReader in throws IOException String name readName in if name equals return LogicalConstant zero else if name equals 1 return LogicalConstant one else throw new RuntimeException Expected or 1 found name Reads a character stream and returns the logical variable corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static Formula factoryLogicalVariable PushbackReader in throws IOException String name readName in expectedLowerCase name charAt return new LogicalVariable name Reads a character stream and returns the negation corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static Formula factoryNegation PushbackReader in throws IOException expect in Formula subformula factory in return new Negation subformula Reads a character stream and returns the name corresponding to it if any param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If there is a syntax error in the character stream static String readName PushbackReader in throws IOException StringBuffer name new StringBuffer int cc while 1 cc in read Character isLetterOrDigit char cc name append char cc in unread cc if name length throw new RuntimeException Name expected return name toString Skips a string of whitespace in a character stream param in A pushback reader for the stream throws IOException If the stream operations do static void skipWhitespace PushbackReader in throws IOException int cc while 1 cc in read Character isWhitespace char cc in unread cc Reads a character and throws an exception if the character is not the expected one param expected The expected character param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If the expected character was not next in the stream static void expect char expected PushbackReader in throws IOException int cc if expected cc in read throw new RuntimeException Expected found printable cc Reads a character and throws an exception if the character is not lowercase param in A pushback reader for the stream throws IOException If the stream operations do throws RuntimeException If the stream did not begin with a lowercase character static void expectedLowerCase char cc if Character isLowerCase cc throw new RuntimeException Expected lowercase found printable cc Returns a printable string representing a character param cc The character return in A string describing cc EOF if cc is 1 newline if cc is n cc in single quotes if cc is printable and the numerical value of cc otherwise static String printable int cc if 1 cc return EOF else if n cc return newline else if Character isISOControl char cc return cc else return char cc This pattern is not discussed in GHJV95 although two closely related patterns are Abstract Factory and Factory Method The Singleton pattern A singleton is the only instance of its type The singleton pattern is a way of coding a class so that only one instance of the class is constructed and that instance is reused every time an object of the class is needed It can be adapted for classes that have only two or a small finite number of distinct instances so they can be reused To write a class C that follows the Singleton pattern make its constructor private so that no one outside the class can construct one Give the class a private static variable singleton of type C and a public static method singleton with no parameters and returning a value of type C Methods outside the class call this singleton method to get an object of the class There are two ways to give the variable its value eagerly initialize the variable by calling the private constructor then the singleton method returns its value lazily initialize the variable to null then the singleton method checks to see if the variable is null gives it a non null value by calling the private constructor if so and then returns the variable s value Example the LogicalConstant class which needs no more than two distinct instances The class is reimplemented using the Singleton pattern twice once for and once for 1 uses the eager Singleton pattern and 1 uses the lazy Singleton pattern package formulaVisited A logical constant representing true or false public class LogicalConstant implements Formula static private LogicalConstant one new LogicalConstant true Returns a logical constant for 1 true The same constant is returned for every call The constant is constructed at initialization time eager initialization static public LogicalConstant one return one static private LogicalConstant zero null Returns a logical constant for false The same constant is returned for every call The constant is not constructed until the first call lazy initialization static public LogicalConstant zero if null zero zero new LogicalConstant false return zero boolean value Constructs a logical constant param value The constant s value private LogicalConstant boolean value value value public Object accept Visitor v return v visit this The Visitor pattern A visitor is an object that traverses a tree or other data structure and performs an operation for each node of the tree choosing the appropriate operation for each node based on the node s static type It allows the code that implements an operation to be localized in a single class and can reduce the cost of adding a new operation on the trees Once the node classes are set up for the visitor pattern they need not be changed if a new operation is added instead a new visitor is implemented To implement the Visitor pattern give each node class a method accept Visitor v that calls the visitor s visit C c method where C is the node class This method is textually the same for every node class the compiler sets up a call to the right visit method based on the type of the node public Object accept Visitor v return v visit this Then the visitor class is implemented with a separate visit C c method for each node class C Each visit C c method does whatever is desired for objects of that class C If a result is needed it is packaged up as some kind of object and returned Example The formula package rewritten to take visitors with a Visitor interface added to be the type of all visitors package formulaVisited A visitor to formulas The visitor traverses the syntax tree of a formula and calculates some result for each kind of formula For kinds of formulas that have subformulas the results for the subformulas are combined into the result for the formula Each formula s result is returned from the visit method public interface Visitor Calculates the result for a Conjunction public Object visit Conjunction f Calculates the result for a Disjunction public Object visit Disjunction f Calculates the result for a LogicalConstant public Object visit LogicalConstant f Calculates the result for a LogicalVariable public Object visit LogicalVariable f Calculates the result for a Negation public Object visit Negation f Now all formula classes accept visitors package formulaVisited The type of all logic formulas that accept visitors public interface Formula Accepts a visitor Each subclass implements this method as return v visit this and the compiler identifies the right link Visitor method based on the subclass which is the type of this param v The visitor return The result v calculates for this formula public Object accept Visitor v Each formula class implements the accept method by calling the visitor on itself package formulaVisited The conjunction and of two subformulas A conjunction is true if both subformulas are true and false if either or both subformulas are false public class Conjunction implements Formula Formula left Formula right Constructs the conjunction of two subformulas param left The first subformula param right The second subformula public Conjunction Formula left Formula right left left right right public Object accept Visitor v return v visit this Each visitor class implements a visit method for each type of formula with the method producing the right result for that formula type For formula classes with subformulas the visitor uses the result it produces for each subformula in making the result for the formula containing them The VisitorToString class is a good example for a Conjunction for example it uses its own results for the left subformula and the right subformula in producing the result for the Conjunction package formulaVisited A visitor that produces a string representation for each formula public class VisitorToString implements Visitor public Object visit Conjunction f return String f left accept this String f right accept this public Object visit Disjunction f return String f left accept this String f right accept this public Object visit LogicalConstant f if LogicalConstant one equals f return 1 else return public Object visit LogicalVariable f return f name public Object visit Negation f return f subformula accept this Now that the node classes are set up to accept visitors we can easily write a visitor to add any function Below is a visitor to evaluate the value of a logical formula In order to implement this visitor we need to write an Environment class that gives the truth values if any for the logical variables and the domain constant values if any for the domain variables and the truth values for the applications of each predicate to each of the domain constants The visitor is given an environment to use in determining the value of a formula we assume this environment has been set up to show for example that logical variable b represents false and that predicate P is true when applied to domain constant E12 The visitor returns Boolean FALSE if the formula being visited is false Boolean TRUE if the formula is true and null if the value of the formula can t be determined package formulaVisited import java util A visitor that evaluates each formula returning Boolean TRUE if the formula is true Boolean FALSE if the formula is false and null if its value cannot be determined The presence of undefined logical values or predicates whose value is not defined for every domain entity can result in formulas whose logical values that cannot be determined public class VisitorEvaluate implements Visitor Environment env Construct a VisitorEvaluate that evaluates formulas in the given environment param env The environment public VisitorEvaluate Environment env env env inheritDoc A conjunction is true if both its subformulas are true false if either of its subformulas is false and unknown otherwise public Object visit Conjunction f Boolean leftValue Boolean f left accept this Boolean rightValue Boolean f right accept this if leftValue booleanValue return Boolean FALSE else if rightValue booleanValue return Boolean FALSE else if leftValue booleanValue rightValue booleanValue return Boolean TRUE else return null inheritDoc A disjunction is false if both its subformulas are false true if either of its subformulas is true and unknown otherwise public Object visit Disjunction f Boolean leftValue Boolean f left accept this Boolean rightValue Boolean f right accept this if leftValue booleanValue return Boolean TRUE else if rightValue booleanValue return Boolean TRUE else if leftValue booleanValue rightValue booleanValue return Boolean FALSE else return null inheritDoc The value of link LogicalConstant one LogicalConstant one is true and the value of link LogicalConstant zero LogicalConstant zero is false public Object visit LogicalConstant f if LogicalConstant one equals f return 1 else return inheritDoc The value of a logical variable is the value the variable is bound to in the environment and unknown if the variable is bound to no value The environment used is the one with which this visitor was constructed public Object visit LogicalVariable f return env get f inheritDoc A negation is false if its subformula is true false if its subformula is true and unknown if its subformula s value is unknown public Object visit Negation f Boolean subformulaValue Boolean f subformula accept this if null subformulaValue return null else if subformulaValue booleanValue return Boolean FALSE else return Boolean TRUE References GHJV95 Erich Gamma Richard Helm Ralph Johnson and John Vlissides Design Patterns Elements of reusable object oriented software Addison Wesley 1995 2 9Sep23We1 12 Thomas A Alspaugh alspaugh at ics uci edu", "_id": "http://www.ics.uci.edu/~alspaugh/cls/shr/java-designPattern.html", "title": "design patterns", "html": "<?xml version='1.1'?>\n<!DOCTYPE html\n     PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'\n     'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>\n<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>\n<head>\n  <title>Design Patterns</title>\n  <meta name='Author' content='Thomas A. Alspaugh'/>\n  <meta name='Description' content=\"Design Patterns\"/>\n  <meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'/>\n  <meta http-equiv='Content-Style-Type' content='text/css'/>\n  <link href='../../alspaugh-uci.css' rel='stylesheet' type='text/css'/>\n  <!-- <link href='../alspaugh-uci-cls.css' rel='stylesheet' type='text/css'/> -->\n  <style type='text/css'>\n    .lex {  font-variant: small-caps;  }\n    .var {  font-style: italic;  }\n    pre  {  padding-left: 2em;  }\n    pre code {  font-size: 100%;  }\n    @media screen {\n      body     {  background: url(\"img/bg-java-designPattern.png\") repeat-y;  }\n      #TMain   {  margin-left: 10.00em;  }\n    }\n  </style>\n</head>\n<body>\n\n<div id='TBg'>\n\n<div id='THeader'>\nJava Design Patterns\n</div>\n\n<div id='TLinks1' class='Links'> <!-- - - - - - - - - - - - - - - - - - - - -->\n<p>  <a class='sc' href='../../index.html'>Home</a>\n</p>\n<div class='hr'> </div>\n<p>  <a href='index.html'>Foundations home</a>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='set.html'>Sets</a><br/>\n<a href='relation.html'>Relations</a><br/>\n<a href='correspondence.html'>Correspondences</a><br/>\n<a href='orderedSet.html'>Ordered Sets</a><br/>\n<a href='lattice.html'>Lattices</a><br/>\n<a href='graph.html'>Graphs</a><br/>\n<a href='powerset.html'>Powersets</a><br/>\n<a href='binaryString.html'>Binary Strings</a><br/>\n<a href='logicConcepts.html'>Logic</a><br/>\n<a href='allen.html'>AIA</a><br/><!-- -spell AIA -->\n<a href='greek.html'>Greek</a><br/>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='glossaryExternal.html'>Glossary</a><br/>\n<a href='goodAbstract.html'>Abstracts</a><br/>\n<a href='argument.html'>Argument</a><br/>\n<a href='ontology.html'>Glossaries</a><br/>\n<a href='inquiryCycle.html'>Inquiry Cycle</a><br/>\n<a href='hohfeld.html'>Legal Relations</a><br/>\n<a href='goodPresentation.html'>Presentations</a><br/>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='quickStart.html'>Elicitation</a><br/>\n<a href='ontology.html'>Glossaries</a><br/>\n<a href='goal.html'>Goals</a><br/>\n<a href='istar.html'>i*</a><br/>\n<a href='SCR.html'>SCR</a><br/>\n<a href='tracing.html'>Tracing</a><br/>\n</p>\n<div class='hr2'> </div>\n<p>\n<a href='alloy.html'>Alloy</a><br/>\n<a href='msc.html'>MSCs</a><br/>\n<a href='regularExpression.html'>Regular Exprs.</a><br/>\n</p><!-- -spell MSCs Exprs -->\n<div class='hr2'> </div>\n<p>\n<a href='java-designPattern.html'>Design Patterns</a><br/>\n<a href='javadoc.html'>Javadoc</a><br/>\n<a href='java-package.html'>Java Packages</a><br/>\n<a href='java-type.html'>Java Types</a><br/>\n</p>\n<div class='hr2'> </div>\n<p>\n<a href='html.html'>(X)HTML</a><br/>\n<a href='xmlSchema.html'>XML Schemas</a><br/>\n<a href='xslt.html'>XSLT</a><br/>\n</p><!-- -spell XSLT -->\n</div>\n\n\n<!-- No right column -->\n<div id='TMain'><!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->\n<!--xhtml -y -->\n\n\n<!--spell EOF GHJV IOException LogicalConstant LogicalVariable PushbackReader -->\n<!--spell RuntimeException StringBuffer VisitorEvaluate VisitorToString -->\n<!--spell Vlissides Za constant's expectedLowerCase factoryConjunction -->\n<!--spell factoryDisjunction factoryLogicalConstant factoryLogicalVariable -->\n<!--spell factoryNegation formulaVisited inheritDoc javadoc leftValue -->\n<!--spell logicalConstant logicalVariable param pushback readName -->\n<!--spell rightValue skipWhitespace subformula's subformulaValue -->\n<!--spell subformulas util env io -->\n\n\n<p>\nDesign patterns are patterns of organizing program implementations.&nbsp;\nThey express good coding ideas that can be reused in other programs.&nbsp;\n<a href='#GHJV95'>[GHJV95]</a> is the basic reference,\nand a large number of patterns are published in other sources;\nof which a few of the most useful are discussed here.&nbsp;\n</p>\n\n\n<h1>Table of contents</h1>\n<div id='ToC'>\n</div>\n\n\n<h1 id='example'>The example</h1>\n\n<p>\nConsider a group of classes that represent\nlogical expressions.&nbsp;\nThese classes represent all the simple and compound elements\nof such expressions,\ndescribed in the grammars below.&nbsp;\nThe grammar is set up for ease of parsing.&nbsp;\nLexical elements are named in <span class='lex'>small caps</span>\nand specified as regular expressions.&nbsp;\n</p>\n\n<!-- <h2>Predicate logic</h2> -->\n\n<table class='noborder'>\n<tbody>\n  <tr>\n    <td class='var'>formula\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><span class='var'>logicalConstant</span>\n      | <span class='lex'>logicalVariable</span>\n      | <span class='var'>negation</span>\n      | <span class='var'>conjunction</span>\n      | <span class='var'>disjunction</span>\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>logicalConstant\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>0</b> | <b>1</b>\n    </td>\n  </tr>\n  <tr>\n    <td class='lex'>logicalVariable\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td>[<b>a-z</b>][<b>A-Za-z0-9</b>]*\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>negation\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>~</b> <span class='var'>formula</span>\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>conjunction\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>(</b> <span class='var'>formula</span> <b>&amp;</b>\n        <span class='var'>formula</span> <b>)</b>\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>disjunction\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>[</b> <span class='var'>formula</span> <b>|</b>\n        <span class='var'>formula</span> <b>]</b>\n    </td>\n  </tr>\n</tbody>\n</table>\n\n<!--\n<h2>First-order logic</h2>\n\n<p>\nAll the productions for predicate logic, plus also:\n\n<table class='noborder'>\n<tbody>\n  <tr>\n    <td class='var'>formula\n    <td class='ce'>&rarr;\n    <td><span class='var'>predicate</span>\n      | <span class='var'>universal</span>\n      | <span class='var'>existential</span>\n  <tr>\n    <td class='lex'>predicateName\n    <td class='ce'>&rarr;\n    <td>[<b>A-Z</b>][<b>A-Za-z0-9</b>]*\n  <tr>\n    <td class='var'>predicate\n    <td class='ce'>&rarr;\n    <td><span class='lex'>predicateName</span>\n        <b>(</b> <span class='lex'>domainConstant</span> <b>)</b>\n  <tr><td><td class='ce'>|\n    <td><span class='lex'>predicateName</span>\n        <b>(</b> <span class='lex'>domainVariable</span> <b>)</b>\n  <tr>\n    <td class='lex'>domainConstant\n    <td class='ce'>&rarr;\n    <td>[<b>A-Z</b>][<b>A-Za-z0-9</b>]*\n  <tr>\n    <td class='lex'>domainVariable\n    <td class='ce'>&rarr;\n    <td>[<b>a-z</b>][<b>A-Za-z0-9</b>]*\n  <tr>\n    <td class='var'>universal\n    <td class='ce'>&rarr;\n    <td> <b>&lowast;</b> <span class='lex'>domainVariable</span>\n        <span class='var'>formula</span>\n  <tr>\n    <td class='var'>existential\n    <td class='ce'>&rarr;\n    <td> <b>+</b> <span class='lex'>domainVariable</span>\n        <span class='var'>formula</span>\n</tbody>\n</table>\n -->\n\n<p>\nA basic Java implementation of this grammar is the\n<a href='formula/'><code>formula</code></a> package.&nbsp;\nIt and the <a href='formulaVisited/'><code>formulaVisited</code></a> package,\nwhich makes use of the patterns described below,\nare specified with <a href='javadoc/index.html'>javadoc documentation</a>.&nbsp;\n</p>\n\n\n<h1 id='Factory'>The Factory pattern</h1>\n\n<p>\nA constructor always produces an object\nof a specific class, the class whose constructor it is.&nbsp;\nIn some situations,\nit would be more helpful to be able to construct\nan object belonging to a subclass,\nwithout having to know ahead of time\nwhich subclass any particular object will belong to.&nbsp;\nA factory is a class or method\nthat constructs objects of a particular interface or superclass,\nchoosing which subclass is appropriate at run-time.&nbsp;\nFor example,\na method that reads strings for formulas, as defined in the grammar above,\nmight construct a Negation object if the top-level operation in the formula\nis a negation,\nor a Conjunction object if the top level was a conjunction.&nbsp;\nThe return type of the method would simply be Formula.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\nimport java.io.*;\n\n\n/**\n  A factory for creating formulas from a reader.\n  The specific Formula subclass that is returned\n  depends on what the reader reads.\n  Because the factory is stateless,\n  all its methods are static.\n  True and false are represented by 1 and 0;\n  variables are strings of letters and digits beginning with a lowercase letter;\n  the negation operator is '~';\n  conjunctions are in () with '&amp;' as the infix operator;  and\n  disjunctions are in [] with '|' as the infix operator.\n*/\npublic class Factory {\n\n  /**\n    Reads a character stream and returns\n    the formula corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static public Formula factory(PushbackReader _in) throws IOException {\n    int cc;\n    cc = _in.read();  _in.unread(cc);\n    if /**/ ( -1 == cc) {  throw new RuntimeException(\"Expected formula, found EOF\");  }\n    else if ('(' == cc) {  return factoryConjunction    (_in);  }\n    else if ('[' == cc) {  return factoryDisjunction    (_in);  }\n    else if ('~' == cc) {  return factoryNegation       (_in);  }\n    else if ('0' == cc) {  return factoryLogicalConstant(_in);  }\n    else if ('1' == cc) {  return factoryLogicalConstant(_in);  }\n    else if (Character.isLowerCase((char) cc)) {\n      return factoryLogicalVariable(_in);\n    }\n    else {\n      throw new RuntimeException(\"Expected formula, found \" + printable(cc));\n    }\n  }\n\n  /**\n    Reads a character stream and returns\n    the conjunction corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryConjunction(PushbackReader _in) throws IOException {\n    expect('(', _in);\n    Formula left  = factory(_in);\n    skipWhitespace(_in);\n    expect('&amp;', _in);\n    Formula right = factory(_in);\n    skipWhitespace(_in);\n    expect(')', _in);\n    return new Conjunction(left, right);\n  }\n\n  /**\n    Reads a character stream and returns\n    the disjunction corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryDisjunction(PushbackReader _in) throws IOException {\n    expect('[', _in);\n    Formula left  = factory(_in);\n    skipWhitespace(_in);\n    expect('|', _in);\n    Formula right = factory(_in);\n    skipWhitespace(_in);\n    expect(']', _in);\n    return new Disjunction(left, right);\n  }\n\n  /**\n    Reads a character stream and returns\n    the logical constant corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static LogicalConstant factoryLogicalConstant(PushbackReader _in) throws IOException {\n    String name = readName(_in);\n    if /**/ (name.equals(\"0\")) {  return LogicalConstant.zero();  }\n    else if (name.equals(\"1\")) {  return LogicalConstant.one ();  }\n    else {\n      throw new RuntimeException(\"Expected 0 or 1, found \\\"\" + name + \"\\\"\");\n    }\n  }\n\n  /**\n    Reads a character stream and returns\n    the logical variable corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryLogicalVariable(PushbackReader _in) throws IOException {\n    String name = readName(_in);\n    expectedLowerCase(name.charAt(0));\n    return new LogicalVariable(name);\n  }\n\n  /**\n    Reads a character stream and returns\n    the negation corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryNegation(PushbackReader _in) throws IOException {\n    expect('~', _in);\n    Formula subformula = factory(_in);\n    return new Negation(subformula);\n  }\n\n  /**\n    Reads a character stream and returns\n    the name corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static String readName(PushbackReader _in) throws IOException {\n    StringBuffer name = new StringBuffer();\n    int cc;\n    while (-1 &lt; (cc = _in.read()) &amp;&amp; Character.isLetterOrDigit((char) cc)) {\n      name.append((char) cc);\n    }\n    _in.unread(cc);\n    if (0 == name.length()) {  throw new RuntimeException(\"Name expected\");  }\n    return name.toString();\n  }\n\n  /**\n    Skips a string of whitespace in a character stream.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n  */\n  static void skipWhitespace(PushbackReader _in) throws IOException {\n    int cc;\n    while (-1 &lt; (cc = _in.read()) &amp;&amp; Character.isWhitespace((char) cc)) {}\n    _in.unread(cc);\n  }\n\n  /**\n    Reads a character and throws an exception\n    if the character is not the expected one.\n    @param _expected The expected character.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If the expected character was not next in the stream.\n  */\n  static void expect(char _expected, PushbackReader _in) throws IOException {\n    int cc;\n    if (_expected != (cc = _in.read())) {\n      throw new RuntimeException(\"Expected '(', found \" + printable(cc));\n    }\n  }\n\n  /**\n    Reads a character and throws an exception\n    if the character is not lowercase.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If the stream did not begin with a lowercase character.\n  */\n  static void expectedLowerCase(char _cc) {\n    if (!Character.isLowerCase(_cc)) {\n      throw new RuntimeException(\"Expected lowercase, found \" + printable(_cc));\n    }\n  }\n\n  /**\n    Returns a printable string representing a character.\n    @param  _cc The character.\n    @return _in A string describing _cc: \n      \"EOF\" if _cc is -1, \"newline\" if _cc is '\\n',\n      _cc in single quotes if _cc is printable,\n      and the numerical value of _cc otherwise.\n  */\n  static String printable(int _cc) {\n    if /**/ (-1   == _cc) {  return \"EOF\";  }\n    else if ('\\n' == _cc) {  return \"newline\";  }\n    else if (Character.isISOControl((char) _cc))\n                         {  return \"\" + _cc;  }\n    else                 {  return \"'\" + (char) _cc + \"'\";  }\n  }\n\n}\n\n</pre>\n\n<p>\nThis pattern is not discussed in <a href='#GHJV95'>[GHJV95]</a>,\nalthough two closely related patterns are\n(Abstract Factory and Factory Method).&nbsp;\n</p>\n\n\n<h1 id='Singleton'>The Singleton pattern</h1>\n\n<p>\nA singleton is the only instance of its type.&nbsp;\nThe singleton pattern is a way of coding a class\nso that only one instance of the class is constructed,\nand that instance is reused every time an object of the class is needed.&nbsp;\nIt can be adapted for classes that have only two or a small finite number\nof distinct instances,\nso they can be reused.&nbsp;\n</p>\n\n<p>\nTo write a class <code>C</code> that follows the Singleton pattern,\nmake its constructor private\n(so that no one outside the class can construct one).&nbsp;\nGive the class a private static variable <code>singleton</code>\nof type <code>C</code>,\nand a public static method <code>singleton()</code>\nwith no parameters and\nreturning a value of type <code>C</code>.&nbsp;\nMethods outside the class call this <code>singleton()</code> method\nto get an object of the class.&nbsp;\n</p>\n\n<p>\nThere are two ways to give the variable its value:&nbsp;\n</p>\n\n<ol>\n  <li> <b>eagerly</b>:&nbsp; initialize the variable by calling the (private) constructor,\n    then the <code>singleton()</code> method returns its value.\n  </li>\n  <li> <b>lazily</b>:&nbsp;  initialize the variable to null;&nbsp;\n    then the <code>singleton()</code> method checks to see if the variable is null,\n    gives it a non-null value by calling the (private) constructor if so,\n    and then returns the variable's value.&nbsp;\n  </li>\n</ol>\n\n<p>Example:&nbsp; the LogicalConstant class,\nwhich needs no more than two distinct instances.&nbsp;\nThe class is reimplemented using the Singleton pattern twice,\nonce for <b>0</b> and once for <b>1</b>.&nbsp;\n<b>0</b> uses the eager Singleton pattern,\nand\n<b>1</b> uses the lazy Singleton pattern.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  A logical constant, representing true or false.\n*/\npublic class LogicalConstant implements Formula {\n  \n  static private LogicalConstant one = new LogicalConstant(true);\n  /**\n    Returns a logical constant for 1 (true).\n    The same constant is returned for every call.\n    The constant is constructed at initialization time (eager initialization).\n  */\n  static public  LogicalConstant one() {  return one;  }\n  \n  static private LogicalConstant zero = null;\n  /**\n    Returns a logical constant for 0 (false).\n    The same constant is returned for every call.\n    The constant is not constructed until the first call (lazy initialization).\n  */\n  static public  LogicalConstant zero() {\n    if (null == zero) {\n      zero = new LogicalConstant(false);\n    }\n    return zero;\n  }\n  \n  boolean value;\n  /**\n    Constructs a logical constant.\n    @param _value The constant's value.\n  */\n  private LogicalConstant(boolean _value) {  value = _value;  }\n\n  public Object accept(Visitor _v) {  return _v.visit(this);  }\n\n}\n\n</pre>\n\n\n<h1 id='Visitor'>The Visitor pattern</h1>\n\n<p>\nA visitor is an object that traverses a tree (or other data structure)\nand performs an operation for each node of the tree,\nchoosing the appropriate operation for each node\nbased on the node's static type.&nbsp;\nIt allows the code that implements an operation\nto be localized in a single class,\nand can reduce the cost of adding a new operation\non the trees.&nbsp;\nOnce the node classes are set up for the visitor pattern,\nthey need not be changed if a new operation is added;&nbsp;\ninstead, a new visitor is implemented.&nbsp;\n</p>\n\n<p>\nTo implement the Visitor pattern,\ngive each node class a method <code>accept(Visitor _v)</code>\nthat calls the visitor's <code>visit(C _c)</code> method,\nwhere <code>C</code> is the node class.&nbsp;\nThis method is textually the same for every node class;&nbsp;\nthe compiler sets up a call to the right <code>visit</code> method\nbased on the type of the node.&nbsp;\n</p>\n\n<pre>\npublic Object accept(Visitor _v) {  return _v.visit(this);  }\n</pre>\n\n<p>\nThen the visitor class is implemented\nwith a separate <code>visit(C _c)</code> method for each node class\n<code>C</code>.&nbsp;\nEach <code>visit(C _c)</code> method does whatever is desired\nfor objects of that class <code>C</code>.&nbsp;\nIf a result is needed,\nit is packaged up as some kind of object and returned.&nbsp;\n</p>\n\n<p>\nExample:&nbsp;\nThe formula package rewritten to take visitors,\nwith a <code>Visitor</code> interface added\nto be the type of all visitors:&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  A visitor to formulas.\n  The visitor traverses the syntax tree of a formula,\n  and calculates some result for each kind of formula.\n  For kinds of formulas that have subformulas,\n  the results for the subformulas are combined\n  into the result for the formula.\n  Each formula's result is returned from the visit() method.\n*/\npublic interface Visitor {\n  /**  Calculates the result for a Conjunction.  */\n  public Object visit(Conjunction _f);\n  /**  Calculates the result for a Disjunction.  */\n  public Object visit(Disjunction _f);\n  /**  Calculates the result for a LogicalConstant.  */\n  public Object visit(LogicalConstant _f);\n  /**  Calculates the result for a LogicalVariable.  */\n  public Object visit(LogicalVariable _f);\n  /**  Calculates the result for a Negation.  */\n  public Object visit(Negation _f);\n}\n\n</pre>\n\n<p>\nNow all formula classes accept visitors:\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  The type of all logic formulas that accept visitors.\n*/\npublic interface Formula {\n  /**\n    Accepts a visitor.\n    Each subclass implements this method as \n    <code>{  return _v.visit(this);  }</code>,\n    and the compiler identifies the right {@link Visitor} method\n    based on the subclass (which is the type of <code>this</code>).\n    @param _v The visitor.\n    @return The result _v calculates for this formula.\n  */\n  public Object accept(Visitor _v);\n\n}\n\n</pre>\n\n<p>\nEach formula class implements the <code>accept</code> method\nby calling the visitor on itself:&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  The conjunction (\"and\") of two subformulas.\n  A conjunction is true if both subformulas are true,\n  and false if either or both subformulas are false.\n*/\npublic class Conjunction implements Formula {\n  Formula left;\n  Formula right;\n  /**\n    Constructs the conjunction of two subformulas.\n    @param _left  The first subformula.\n    @param _right The second subformula.\n  */\n  public Conjunction(Formula _left, Formula _right) {  left = _left;  right = _right;  }\n  \n  public Object accept(Visitor _v) {  return _v.visit(this);  }\n  \n}\n\n</pre>\n\n<p>\nEach visitor class implements a <code>visit</code> method\nfor each type of formula,\nwith the method producing the right result for that formula type.&nbsp;\nFor formula classes with subformulas,\nthe visitor uses the result it produces for each subformula\nin making the result for the formula containing them.&nbsp;\nThe <code>VisitorToString</code> class is a good example;&nbsp;\nfor a Conjunction, for example,\nit uses its own results for the left subformula\nand the right subformula\nin producing the result for the Conjunction.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  A visitor that produces a string representation for each formula.\n*/\npublic class VisitorToString implements Visitor {\n  \n  public Object visit(Conjunction _f) {\n    return \"(\" + (String) _f.left .accept(this) + \n           \"&amp;\" + (String) _f.right.accept(this) + \")\";\n  }\n  \n  public Object visit(Disjunction _f) {\n    return \"[\" + (String) _f.left .accept(this) + \n           \"|\" + (String) _f.right.accept(this) + \"]\";\n  }\n  \n  public Object visit(LogicalConstant _f) {\n    if (LogicalConstant.one().equals(_f)) {  return \"1\";  }\n    else                                  {  return \"0\";  }\n  }\n  \n  public Object visit(LogicalVariable _f) {\n    return _f.name;\n  }\n  \n  public Object visit(Negation _f) {\n    return \"~\" + _f.subformula.accept(this);\n  }\n  \n}\n\n</pre>\n\n<p>\nNow that the node classes are set up to accept visitors,\nwe can easily write a visitor to add any function.&nbsp;\nBelow is a visitor to evaluate the value of a logical formula.&nbsp;\n</p>\n\n<p>\nIn order to implement this visitor,\nwe need to write an <code>Environment</code> class\nthat gives the truth values (if any) for the logical variables\nand the domain constant values (if any) for the domain variables,\nand the truth values for the applications of each predicate to\neach of the domain constants.&nbsp;\nThe visitor is given an environment to use\nin determining the value of a formula;&nbsp;\nwe assume this environment has been set up to show (for example)\nthat logical variable <code>b</code> represents false,\nand that predicate <code>P</code> is true\nwhen applied to domain constant <code>E12</code>.&nbsp;\n</p>\n\n<p>\nThe visitor returns Boolean.FALSE\nif the formula being visited is false,\nBoolean.TRUE if the formula is true,\nand <code>null</code> if the value of the formula can't be determined.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\nimport java.util.*;\n\n\n/**\n  A visitor that evaluates each formula, returning\n  Boolean.TRUE  if the formula is true,\n  Boolean.FALSE if the formula is false, and\n  null if its value cannot be determined.\n  The presence of undefined logical values,\n  or predicates whose value is not defined for every domain entity,\n  can result in formulas whose logical values that cannot be determined.\n*/\npublic class VisitorEvaluate implements Visitor {\n\n  Environment env;\n  /**\n    Construct a VisitorEvaluate that evaluates formulas\n    in the given environment.\n    @param _env The environment.\n  */\n  public VisitorEvaluate(Environment _env) {\n    env = _env;\n  }\n\n  /**\n    {@inheritDoc}\n    A conjunction is true if both its subformulas are true,\n    false if either of its subformulas is false,\n    and unknown otherwise.\n  */\n  public Object visit(Conjunction _f) {\n    Boolean leftValue  = (Boolean) _f.left .accept(this);\n    Boolean rightValue = (Boolean) _f.right.accept(this);\n    if /**/ (!leftValue .booleanValue()) {  return Boolean.FALSE;  }\n    else if (!rightValue.booleanValue()) {  return Boolean.FALSE;  }\n    else if ( leftValue .booleanValue() &amp;&amp;\n              rightValue.booleanValue()) {  return Boolean.TRUE;   }\n    else                                 {  return null;  }\n  }\n\n  /**\n    {@inheritDoc}\n    A disjunction is false if both its subformulas are false,\n    true if either of its subformulas is true,\n    and unknown otherwise.\n  */\n  public Object visit(Disjunction _f) {\n    Boolean leftValue  = (Boolean) _f.left .accept(this);\n    Boolean rightValue = (Boolean) _f.right.accept(this);\n    if /**/ ( leftValue .booleanValue()) {  return Boolean.TRUE;   }\n    else if ( rightValue.booleanValue()) {  return Boolean.TRUE;   }\n    else if (!leftValue .booleanValue() &amp;&amp;\n             !rightValue.booleanValue()) {  return Boolean.FALSE;  }\n    else                                 {  return null;  }\n  }\n\n  /**\n    {@inheritDoc}\n    The value of {@link LogicalConstant#one  LogicalConstant.one() } is true, and\n    the value of {@link LogicalConstant#zero LogicalConstant.zero()} is false.\n  */\n  public Object visit(LogicalConstant _f) {\n    if (LogicalConstant.one().equals(_f)) {  return \"1\";  }\n    else                                  {  return \"0\";  }\n  }\n\n  /**\n    {@inheritDoc}\n    The value of a logical variable is\n    the value the variable is bound to in the environment,\n    and unknown if the variable is bound to no value.\n    The environment used is the one with which this visitor was constructed.\n  */\n  public Object visit(LogicalVariable _f) {\n    return env.get(_f);\n  }\n\n  /**\n    {@inheritDoc}\n    A negation is false if its subformula is true,\n    false if its subformula is true,\n    and unknown if its subformula's value is unknown.\n  */\n  public Object visit(Negation _f) {\n    Boolean subformulaValue = (Boolean) _f.subformula.accept(this);\n    if /**/ (null == subformulaValue)        {  return null;  }\n    else if (subformulaValue.booleanValue()) {  return Boolean.FALSE;  }\n    else                                     {  return Boolean.TRUE;   }\n  }\n\n}\n\n</pre>\n\n\n<h1 id='References'>References</h1>\n\n<p id='GHJV95'>[GHJV95]&nbsp;\nErich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.&nbsp;\n<i>Design Patterns: Elements of reusable object-oriented software</i>.&nbsp;\nAddison-Wesley, 1995.\n</p>\n\n\n<!--xhtml -n -->\n</div>\n\n</div><!-- #TBg -->\n\n<div id='TFooter'>\n<div class='W3C'>\n  <a href='http://validator.w3.org/check?uri=referer'><img class='W3C'\n    src='../../img/valid-xhtml10-blue.png'\n    alt='Valid XHTML 1.0 Strict'/></a>\n  <br/>\n  <a href='http://jigsaw.w3.org/css-validator/check/referer'><img class='W3C'\n    src='../../img/vcss-blue.png'\n    alt='Valid CSS!'/></a>\n</div>\n<div class='timestamp'>2009Sep23We10:12</div>\n<div style='padding-top:1px;'>\n<a class='plain' href='./index.html' style='font-variant:small-caps;'\n>Thomas A. Alspaugh</a>\n<span style='padding-left:1em;'><span class='email ss sm'>alspaugh&nbsp;\n    <span class='ss sc sm'>at</span> &middot; ics &middot; uci &middot; edu</span>\n    <!-- -spell alspaugh uci edu --> </span>\n</div>\n</div>\n\n<!-- Google Analytics code -->\n<script type=\"text/javascript\">\nvar gaJsHost = ((\"https:\" == document.location.protocol)\n  ? \"https://ssl.\" : \"http://www.\");\ndocument.write(unescape(\"%3Cscript src='\" + gaJsHost +\n  \"google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E\"));\n</script>\n<script type=\"text/javascript\">\ntry {\nvar pageTracker = _gat._getTracker(\"UA-15281497-1\");\npageTracker._trackPageview();\n} catch(err) {}\n</script>\n\n</body>\n</html>\n\n", "id": 10785.0}