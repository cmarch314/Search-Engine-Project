{"text": "More Java Introduction to Computer Science I III ICS 21 22 23 Introduction In this short lecture we will clarify some points about the meaning of final in variable declarations introduce two operators used in conditional expressions and discuss short circuit evaluation in logical operators All these features allow us to write more compact and understandable code once we understand these language features More on final In the real world a constant is a named value that never changes Examples of constants are pi e the speed of light the mass of a proton we think etc In programs a constant is a variable whose value never changes within its scope i e during the time the variable is declared This is a slightly more liberal definition So any real world constant is a program constant but a program constant doesn t have to be a real world constant For example to compute a mortgage a program uses the current interest rate This value is not a real world constant because its value changes daily But once the program starts computing the mortgage payments the current interest rate is a constant in that program We have seen that we can declare local variables as constants by using the final access modifier recall that final restricts how we can access the variable When a variable is declared final it must be intialized its value can be examined in subsequent expressions but its value can never be changed by a state change operator We will use the terms constant and final variable interchangably If we write code that tries to change a constant the Java compiler detects and reports a syntax constraint error In fact we can use this rule to get some interesting information from the compiler every statement where we change the state of a variable We do so by changing it from a variable to a constant and then let the compiler locate all the errors where we try to change its state When we write programs we should declare constants instead of using magic literals The names of the constants will help us remember what the constant means without having to see its values what is 6 22141E23 or 2 99792458E8 Using constants instead of variables makes our programs less prone to error if we use a variable we might accidentally change what value it stores this is impossible with constants Using constants also makes it easier to change our programs in the upcoming Rocket program we can write 1 in lots of places but if we needed to change that value to 1 for a more accurate simulation we might have to search our code carefully to make the correct changes there might be other 1s in our program not refering to the time increment If instead we declared final double dT 1 here dT stands for delta change in time in our program and then used the constant dT throughout our code to change this value requires editing just this one line of code and then recompiling the program Although use of final in the example below may be a bit confusing it is perfectly legal int count int sum for final int score Prompt forInt Enter score 1 to terminate if score 1 break count sum score System out println Average sum count In this example score is declared final and indeed its value once initialized never changes in its scope the block in which score is declared When the block finishes score becomes undeclared then the for loop re executes the block redeclaring and reinitializing the score constant all over again So our use of score meets all the technical requirements for a constant Some programmers would pronounce this code excellent others would say that indicating final is not worth it What do you think Most constants specify an initializer in their declaration but surprsingly this is not necessary If the initializer is omitted it is called a blank final variable The Java compiler is smart enought to ensure a blank final variable is eventually assigned an initial value a blank final variable is not used until after it is assigned a value a blank final variable it is never reassigned another one value So it is OK to write code like final double d blank final code cannot refer to the constant d if whatever value is assigned to constant d in one if branch d else d more code care refer to but not change the constant d Any further attempt to store a value into d will be detected and reported as an error by the Java compiler When we learn how to write instance variables in classes we will see more reasonable uses of blank final Conditional Operators and There are two operators that work together in Java helping us to condense our code by allowing us to write short expressions instead of longer statements These two operators and constitute what is called a conditional expression Please constrast this with if statements which are sometimes called conditional statements the distinction between expression and statement is important The EBNF rule for a conditional expression is conditional expression expression expression expression As a syntax constraint the first expression must return a boolean result and the second two expressions must return a result of the same type it can be any type but they must match We will write conditional expressions using the following form almost always putting them in parentheses which makes reading them easier test expressionT expressionF Together and are called ternary operators not unary or binary they have three operands they are called distfix because the operators are distributed around their operands not prefix infix or postfix Semantically Java first evaluates test if it is true the result of the conditional expression is the result of evaluating expressionT if it is false the result of the conditional expression is the result of evaluating expressionF So only two of the three expressions are ever evaluated Because each conditional expression must have a unique result type and because its value can be computed by either expressionT or expressionF the Java compiler has a syntax constraint that requires these expressions to have the same type Let s look at three concrete examples of conditional expressions and the if statements that they condense One can often simplify short if statements with even shorter conditional expressions but large if statements often cannot be simplified if n x n 1 x else x 1 if pennies 1 System out println 1 penny else System out println pennies pennies System out println pennies pennies 1 penny pennies if n 2 System out println n is even else System out println n isn t even System out println n n 2 is isn t even Upon reading this code many students think that the if statements are simpler but that is because they are more familiar with if statements and less familiar with conditional expressions Most experience programmers think that the conditional expressions are simpler Of course which form you ultimately use is a matter of taste But it is important that you understand conditional expressions and can switch back and forth between them and simple if statements when it is possible Short Circuit Evaluation We have learned that binary infix operators evaluate both their operands first and then compute their resulting value Actually this ordering is correct for all but the and logical operators Instead these operators use short circuit evaluation they always evaluate their left operand first if they can compute their resulting value from this operand alone they do so without evaluating their right operand if they cannot determine the resulting value from the left operand alone then they evaluate their right operand and compute the resulting value Note that if the left operand of evaluates to false the result must be false false false as well as false true evaluate to false so the value of the right operand is irrelevant Note that if the left operand of evaluates to true the result must be true true false as well as true true evaluate to true so again the value of the right operand is irrelevant To see how we can use this short circuit property when programming assume that a program declares int totalParts badParts and increments the appropriate variables when a part is tested Next assume that if the ratio of bad parts to total parts is ever over 5 or 5 we want to recognize this problem and display a message Because we have short circuit evaluation we can simply write if totalParts double badParts double totalParts 5 System out println Too many bad parts Notice that if totalParts is zero then the left operand of is false so Java doesn t bother to evaluate the right operand Without short circuit evaluation Java would evaluate the right operand too causing an exception to be thrown because of division by zero Also if we had written the second conjunct first Java would do the division BEFORE comparing totalParts to zero which could also throw an exception So the operands to the and operators are not symmetric because short circuit evaluation is used In a programming language without short circuit evaluation we would have to write the following more complicated code to achieve safety from division by zero if totalParts if double badParts double totalParts 5 System out println Too many bad parts which requires two nested if statements instead of one As a final example suppose that we are writing a game playing program and the user must terminate the bet play loop if his her purse is or if he she elects to quit if the former is true the user shouldn t even be prompted about electively quitting he she must quit because he she has no more money With short circuit evaluation we can write one if statement that captures all these semantics if purse Prompt forBoolean Quit break Because of short circuit evaluation if purse is zero the if s test will evaluate to true before prompting the user only if purse is not zero will the user be prompted about quitting Again in a programming language without short circuit evaluation we could safely write the following more complicated code if purse break if Prompt forBoolean Quit break which requires two sequential if statements instead of one Finally short circuit evaluation actually works in conditional expressions too For example if we write the conditional expresson true 1 1 Java s result is 1 because the expression evaluates to true Java evaluates only the expression 1 and not the expression 1 If Java fully evaluated all expressions first it would throw an exception Recall the semantics of the conditional expression Java first evaluates the test if it is true the result of the conditional expression is the result of evaluating expressionT if it is false the result of the conditional expression is the result of evaluating expressionF So it uses test to determine which other expression to evaluate and only evaluates that one other expression It always evaluates two of the three expressions Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a CA or any other student Assume that we declared final int maxClassSize 5 which of the following statements would cause the Java compiler to detect and report an error Also assume int x maxClassSize System out println maxClassSize maxClassSize 5 maxClassSize 1 x maxClassSize 2 Assume that we declared final StringTokenizer st new StringTokenizer A man a plan a canal Panama which of the following statements would cause the Java compiler to detect and report an error Also assume int x String s st nextToken x st countTokens st new StringTokenizer Another string Examine the two code fragments below For each say whether it is legal and why or why not Rewrite the if statement using a conditional expression int x Prompt forInt Enter x if x final int y else final int y 1 System out println y int x Prompt forInt Enter x final int y if x y else y 1 System out println y Assume that we declare int x what is wrong with the following conditional expression System out println x non zero Translate the following if statement into an equivalent conditional expression see above if x y max x else max y Assume that we declare int minute and assign it a value between and 59 Write a conditional expression whose values is always a two digit String representing a minute e g if x stores 5 its result is 5 if x stores 25 its result is 25 ", "_id": "http://www.ics.uci.edu/~pattis/ICS-21/lectures/morejava/lecture.html", "title": "more java", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>More Java</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>More Java</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III\r\n<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this short lecture, we will clarify some points about the meaning of\r\n    <b>final</b> in variable declarations, introduce two operators used in\r\n    <b>conditional expressions</b> and discuss <b>short-circuit</b> evaluation\r\n    in logical operators\r\n  All these features allow us to write more compact and understandable code,\r\n    once we understand these language features.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Final -->\r\n\r\n<a name=\"Final\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>More on final</b></td>\r\n<td width =\"80%\">\r\n  In the real world, a constant is a named value that never changes. \r\n  Examples of constants are &pi; (pi), e, the speed of light, the mass of a\r\n    proton (we think?) etc.\r\n  In programs, a constant is a variable whose value never changes within its\r\n    scope (i.e., during the time the variable is declared).\r\n  This is a slightly more liberal definition.\r\n  So, any real-world constant is a program constant, but a program constant\r\n    doesn't have to be a real-world constant.\r\n  <p>\r\n  For example, to compute a mortgage, a program uses the current interest rate.\r\n  This value is not a real-world constant, because its value changes daily.\r\n  But, once the program starts computing the mortgage payments, the current\r\n    interest rate is a constant in that program.\r\n  <p>\r\n  We have seen that we can declare local variables as constants, by using the\r\n     <b>final</b> access modifier (recall that <b>final</b> restricts how we\r\n     can access the variable).\r\n  When a variable is declared <b>final</b> it must be intialized, its value\r\n    can be examined in subsequent expressions, but its value can never be\r\n    changed by a state-change operator.\r\n  We will use the terms <b>constant</b> and <b>final variable</b> \r\n    interchangably.\r\n  If we write code that tries to change a constant, the Java compiler detects\r\n    and reports a syntax constraint error.\r\n  In fact, we can use this rule to get some interesting information from the\r\n    compiler: every statement where we change the state of a variable.\r\n  We do so by changing it from a variable to a constant, and then let the \r\n    compiler locate all the \"errors\" where we try to change its state.\r\n  <p>\r\n  When we write programs, we should declare constants instead of using \"magic\"\r\n     literals.\r\n  The names of the constants will help us remember what the constant means\r\n    (without having to see its values: what is <b>6.022141E23</b> or\r\n    <b>2.99792458E8</b>?).\r\n  Using constants instead of variables makes our programs less prone to error:\r\n    if we use a variable, we might accidentally change what value it stores\r\n    -this is impossible with constants.\r\n  <p>\r\n  Using constants also makes it easier to change our programs: in the upcoming\r\n    Rocket program we can write <b>.01</b> in lots of places, but if we\r\n     needed to change that value to <b>.001</b> (for a more accurate\r\n     simulation), we might have to search our code carefully to make the\r\n     correct changes (there might be other <b>.01</b>s in our program not \r\n    refering to the time increment).\r\n  If instead we declared <b>final double dT = .01;</b> (here <b>dT</b>\r\n    stands for delta/change-in time) in our program, and then used the\r\n    constant <b>dT</b> throughout our code, to change this value\r\n    requires editing just this one line of code, and then recompiling the\r\n    program.\r\n  <p>\r\n  Although use of <b>final</b> in the example below may be a bit confusing, it\r\n     is perfectly legal.\r\n  <pre><b>  int count = 0;\r\n  int sum   = 0;\r\n  for (;;) {\r\n    final int score = Prompt.forInt(\"Enter score (-1 to terminate)\");\r\n    if (score == -1)\r\n      break;\r\n    count++;\r\n    sum += score;\r\n  }\r\n  System.out.println(\"Average = \" + sum/count);</b></pre>\r\n  In this example, <b>score</b> is declared <b>final</b> and indeed, its value\r\n    (once initialized) never changes in its scope: the block in which\r\n    <b>score</b> is declared.\r\n  When the block finishes, <b>score</b> becomes undeclared; then the <b>for</b>\r\n    loop re-executes the block, redeclaring and reinitializing the <b>score</b>\r\n    constant all over again.\r\n  So, our use of <b>score</b> meets all the technical requirements for a \r\n    constant.\r\n  Some programmers would pronounce this code excellent; others would say that\r\n    indicating <b>final</b> is not worth it.\r\n  What do you think?\r\n  <p>\r\n  Most constants specify an initializer in their declaration; but surprsingly,\r\n    this is not necessary.\r\n  If the initializer is omitted, it is called a <b>blank final</b> variable.\r\n  The Java compiler is smart enought to ensure\r\n    <ul>\r\n      <li>a blank final variable is eventually assigned an initial value\r\n      <li>a blank final variable is not used until after it is assigned a value\r\n      <li>a blank final variable it is never reassigned another one value.\r\n    </ul>\r\n  So, it is OK to write code like<pre><b>  final double d;     //blank final\r\n  ...code...          //cannot refer to the constant d\r\n  if (whatever)       //value is assigned to constant d in one if branch\r\n    d = ...\r\n  else\r\n    d = ...\r\n  ...more code...     //care refer to but not change the constant d</b></pre>\r\n  Any further attempt to store a value into <b>d</b> will be detected and\r\n    reported as an error by the Java compiler.\r\n  When we learn how to write instance variables in classes, we will see more\r\n    reasonable uses of blank final.\r\n  <!---\r\n  <p>\r\n  Should be in object discussion: see problem too.\r\n  Finally, recall that when we declare a constant for a reference type, we must\r\n    be a bit careful of its meaning.\r\n  A reference variable stores a reference (as its state) which refers to an\r\n     object (which stores its own state).\r\n  So, using <b>final</b> with a reference variable DOES mean that once we store\r\n    a reference into that variable, it always refers to the same object.\r\n  It DOES NOT mean that the state of the object remains unchanged: we can still\r\n    call mutator/command methods on a final variable, changing not its \r\n    state (WHICH object it refers to) but the state IN the object it refers to.\r\n   So, if we declare <b>final DiceEnsemble d = new DiceEnsemble(2,6);</b> we\r\n     CAN write <b>d.roll();</b>, but we CANNOT write\r\n     <b>d = new DiceEnsemble(1,6);</b>\r\n   Again, the difference between what is stored in a variable (a reference)\r\n     and what is stored in the object it refers to (its state) is crucial to\r\n     understanding this distinction.\r\n  --->\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Conditional Operators -->\r\n\r\n<a name=\"ConditionalOperators\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Conditional Operators ? and :</b></td>\r\n<td width =\"80%\">\r\n  There are two operators that work together in Java, helping us to condense\r\n    our code by allowing us to write short expressions instead of longer\r\n    statements.\r\n  These two operators, <b>?</b> and <b>:</b> constitute what is called a\r\n    <b>conditional expression</b>.\r\n  Please constrast this with <b>if</b> statements, which are sometimes \r\n    called <b>conditional statements</b>: the distinction between\r\n    <b>expression</b> and <b>statement</b> is important.\r\n  The EBNF rule for a conditional expression is\r\n  <p>\r\n&nbsp &nbsp <i>conditional-expression</i> <= <i>expression</i> ? <i>expression</i> : <i>expression</i>\r\n  <p>\r\n  As a syntax constraint, the first <i>expression</i> must return a \r\n    <b>boolean</b> result, and the second two <i>expression</i>s\r\n    must return a result of the same type (it can be any type, but they must\r\n    match).\r\n  <p>\r\n  We will write conditional expressions using the following form (almost\r\n    always putting them in parentheses, which makes reading them easier)\r\n  <b><pre>  (test ? expression<sub>T</sub> : expression<sub>F</sub>)</pre></b>\r\n  Together, <b>?</b> and <b>:</b> are called <b>ternary</b> operators (not\r\n    unary or binary: they have three operands); they are called <b>distfix</b>\r\n    because the operators are <b>dis</b>tributed around their operands\r\n    (not prefix, infix, or postfix).\r\n  <p>\r\n  Semantically, Java first evaluates <b>test</b>, if it is <b>true</b> the\r\n    result of the conditional expression is the result of evaluating\r\n    <b>expression<sub>T</sub></b>; if it is <b>false</b> the result of the\r\n    conditional expression is the result of evaluating\r\n    <b>expression<sub>F</sub></b>.\r\n  So, only two of the three expressions are ever evaluated.\r\n  Because each conditional expression must have a unique result type, and\r\n    because its value can be computed by either <b>expression<sub>T</sub></b>\r\n    or <b>expression<sub>F</sub></b>, the Java compiler has a syntax constraint\r\n    that requires these expressions to have the same type. \r\n  <p>\r\n  Let's look at three concrete examples of conditional expressions and the\r\n    <b>if</b> statements that they condense.\r\n  One can often simplify short <b>if</b> statements with even shorter\r\n    conditional expressions, but large <b>if</b> statements often cannot\r\n    be simplified.\r\n  <b><pre>  if (n > 0)         x = (n>0 ? 0 : 1);\r\n    x = 0;\r\n  else\r\n    x = 1;\r\n\r\n\r\n  if (pennies == 1)\r\n    System.out.println(\"1 penny\");\r\n  else\r\n    System.out.println(pennies + \" pennies\");\r\n\r\n  System.out.println(pennies + (pennies==1 ? \" penny\" : \" pennies\"));\r\n\r\n\r\n  if (n%2 == 0)\r\n    System.out.println(n + \" is even\");\r\n  else\r\n    System.out.println(n + \" isn't even\");\r\n\r\n  System.out.println(n + (n%2==0 ? \" is\" : \" isn't\") + \" even\");</pre></b>\r\n  Upon reading this code, many students think that the <b>if</b> statements are\r\n    simpler; but that is because they are more familiar with <b>if</b>\r\n    statements, and less familiar with conditional expressions.\r\n  Most experience programmers think that the conditional expressions are\r\n    simpler.\r\n  Of course, which form you ultimately use is a matter of taste.\r\n  But it is important that you understand conditional expressions, and can\r\n    switch back and forth between them and simple <b>if</b> statements,\r\n    when it is possible.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Short Circuit Evaluation -->\r\n\r\n<a name=\"ShortCircuit\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Short-Circuit Evaluation</b></td>\r\n<td width =\"80%\">\r\n  We have learned that binary infix operators evaluate both their operands \r\n   first, and then compute their resulting value.\r\n  Actually, this ordering is correct for all but the <b>&&</b> and <b>||</b>\r\n     logical operators.\r\n  Instead, these operators use <b>short-circuit</b> evaluation: they always\r\n    evaluate their left operand first; if they can compute their resulting \r\n   value from this operand alone, they do so without evaluating their right\r\n   operand; if they cannot determine the resulting value from the left operand\r\n    alone, then they evaluate their right operand and compute the resulting\r\n    value\r\n  <p>\r\n  Note that if the left operand of <b>&&</b> evaluates to <b>false</b>, the\r\n    result must be <b>false</b>: <b>false && false</b> as well as\r\n    <b>false && true</b> evaluate to <b>false</b>, so the value of the right\r\n    operand is irrelevant.\r\n  Note that if the left operand of <b>||</b> evaluates to <b>true</b>, the\r\n    result must be <b>true</b>: <b>true || false</b> as well as\r\n    <b>true || true</b> evaluate to <b>true</b>, so again the value of the\r\n    right operand is irrelevant.\r\n  <p>\r\n  To see how we can use this short-circuit property when programming, assume\r\n    that a program declares <b>int totalParts = 0, badParts = 0;</b> and\r\n    increments the appropriate variables when a part is tested.\r\n  Next, assume that if the ratio of bad parts to total parts is ever over 5%\r\n   (or <b>.05</b>) we want to recognize this problem and display a message.\r\n  Because we have short-circuit evaluation, we can simply write<b><pre>\r\n  if ( totalParts != 0 && (double)badParts/(double)totalParts > .05)\r\n    System.out.println(\"Too many bad parts\");</pre></b>\r\n  Notice that if <b>totalParts</b> is zero, then the left operand of <b>&&</b>\r\n    is <b>false</b>, so Java doesn't bother to evaluate the right operand.\r\n  Without short-circuit evaluation, Java would evaluate the right operand too,\r\n    causing an exception to be thrown because of division by zero.\r\n  Also, if we had written the second conjunct first, Java would do the division\r\n    BEFORE comparing <b>totalParts</b> to zero, which could also throw an\r\n    exception.\r\n  So, the operands to the <b>&&</b> and <b>||</b> operators are not symmetric\r\n    because short-circuit evaluation is used.\r\n  <p>\r\n  In a programming language without short-circuit evaluation, we would have to\r\n    write the following, more complicated code, to achieve safety from division\r\n    by zero.\r\n <b><pre>  if (totalParts != 0)\r\n    if ((double)badParts/(double)totalParts > .05)\r\n      System.out.println(\"Too many bad parts\");</pre></b>\r\n  which requires two, nested <b>if</b> statements, instead of one.\r\n  <p>\r\n  As a final example, suppose that we are writing a game-playing program, and\r\n    the user must terminate the bet-play loop if his/her purse is 0 or if\r\n    he/she elects to quit (if the former is true, the user shouldn't even be\r\n     prompted about electively quitting; he/she must quit because he/she has\r\n     no more money).\r\n  With short-circuit evaluation, we can write one <b>if</b> statement that\r\n    captures all these semantics\r\n  <b><pre>  if (purse == 0 || Prompt.forBoolean(\"Quit?\"))\r\n    break;</pre></b>\r\n  Because of short-circuit evaluation, if purse is zero, the <b>if</b>'s test\r\n    will evaluate to <b>true</b> before prompting the user; only if purse is\r\n    not zero will the user be prompted about quitting.\r\n  <p>\r\n  Again, in a programming language without short-circuit evaluation, we could\r\n    safely write the following, more complicated code\r\n  <b><pre>  if (purse == 0)\r\n    break;\r\n  if (Prompt.forBoolean(\"Quit?\"))\r\n    break;</pre></b>\r\n  which requires two, sequential <b>if</b> statements, instead of one.\r\n  <p>\r\n  Finally, short-circuit evaluation actually works in conditional expressions\r\n     too.\r\n  For example, if we write the conditional expresson <b>(true ? 1 : 1/0)</b>\r\n    Java's result is <b>1</b>; because the expression evaluates to <b>true</b>\r\n    Java evaluates only the expression <b>1</b> and not the expression\r\n    <b>1/0</b>.\r\n  If Java fully evaluated all expressions first, it would throw an exception.\r\n  Recall the semantics of the conditional expression:\r\n  Java first evaluates the <b>test</b>, if it is <b>true</b> the result of the\r\n    conditional expression is the result of evaluating\r\n    <b>expression<sub>T</sub></b>; if it is <b>false</b> the result of the\r\n     conditional expression is the result of evaluating\r\n     <b>expression<sub>F</sub></b>.\r\n  So, it uses <b>test</b> to determine which other expression to evaluate, and\r\n    only evaluates that one other expression.\r\n  It always evaluates two of the three expressions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, or any other student.\r\n\r\n  <ol> \r\n     <li>Assume that we declared <b>final int maxClassSize = 50;</b> which\r\n           of the following statements would cause the Java compiler to detect\r\n           and report an error. Also assume <b>int x;</b>\r\n         <ul>\r\n           <li><b>maxClassSize++;</b>\r\n           <li><b>System.out.println(maxClassSize);</b>\r\n           <li><b>maxClassSize = 50;</b>\r\n           <li><b>maxClassSize += 10;</b>\r\n           <li><b>x = maxClassSize + 2;</b>\r\n         </ul>\r\n     <p>\r\n     \r\n     <li>Assume that we declared <b>final StringTokenizer st = new StringTokenizer(\"A man, a plan, a canal: Panama\");</b> which\r\n           of the following statements would cause the Java compiler to detect\r\n           and report an error. Also assume <b>int x;</b>\r\n         <ul>\r\n           <li><b>String s = st.nextToken();</b>\r\n           <li><b>x = st.countTokens();</b>\r\n           <li><b>st = new StringTokenizer(\"Another string\");</b>\r\n         </ul>\r\n     <p>\r\n     \r\n\r\n     <li>Examine the two code fragments below.\r\n         For each, say whether it is legal and why (or why not).\r\n         Rewrite the <b>if</b> statement using a conditional expression.\r\n<pre><b>\r\n  int x = Prompt.forInt(\"Enter x\");\r\n  if (x != 0)\r\n    final int y = 0;\r\n  else\r\n    final int y = 1;\r\n  System.out.println(y);\r\n\r\n  int x = Prompt.forInt(\"Enter x\");\r\n  final int y;\r\n  if (x != 0)\r\n    y = 0;\r\n  else\r\n    y = 1;\r\n  System.out.println(y);</pre></b>\r\n<p>\r\n     \r\n     <li>Assume that we declare <b>int x;</b> what is wrong with the following\r\n           conditional expression:\r\n          <b>System.out.println(x==0 ? 0 : \"non-zero\");</b>\r\n     <p>\r\n     \r\n     <li>Translate the following <b>if</b> statement into an equivalent\r\n           conditional expression (see above).\r\n         <b><pre>  if (x>y)\r\n    max = x;\r\n  else\r\n    max = y;</pre></b>\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>int minute;</b> and assign it a value\r\n           between <b>0</b> and <b>59</b>.\r\n         Write a conditional expression whose values is always a two digit\r\n           <b>String</b> representing a <b>minute</b>: e.g.,\r\n           if <b>x</b> stores <b>5</b> its result is <b>\"05\"</b>;\r\n           if <b>x</b> stores <b>25</b> its result is <b>\"25\"</b>.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 30954.0}