{"text": "Linked List Processing Introduction to Computer Science II ICS 22 Introduction In this lecture we will continue to study a variety of methods that operate on linked lists If you study these methods carefully meaning study their code and hand simulate them on various empty and small non empty lists you will increase your understanding of complex reference manipulation and start to gain an understanding of how to write your own linked list code First we will study various linked list processing methods in isolation or in some unspecified collection class with instance variables By the end of this lecture we will examine the List interface and how it can be implemented directly via arrays and linked lists these classes contains a large number of methods that perform interesting manipulations of arrays lists Like other collection classes that we have studied this class is generic it specifies Object as the type of value where LN specifies an int instance variable Studying this code will bring us to the next programming assignment where we implement of various collection classes via linked lists including iterators We will study a few variants of linked lists which allow some methods to be written more compactly or more simply or more efficiently These include circular lists header lists trailer lists and doubly linked lists which often have both headers and trailers Although these variants are interesting linear linked lists are simpler to think about and are often very efficient and their code not too complex so they are used much more often in practice than these special variants Finally note that linked lists are an implementation technique for collection classes and other purposes Their status is the same as that of arrays a useful way to implement certain well specified state and behavior We will see and write even more collection classes implemented via linked lists often having already seen these collection classes implemented via arrays Some textbooks describe linked lists as if they were themselves a special kind of collection but I believe that this is a wrong perspective By seeing how queues are implemented via both arrays and linked lists we will see the similarity between arrays and linked lists as implementation tools Insert Front Rear We have already examined code for inserting a new value at the front and rear of a linked list The code for inserting at the front is trivial it is a single statement using no loops and therefore is in the O 1 complexity class If we assume that we are defining this method in a class that stores a front instance variable refering to the front of the linked list its first node then the method would be written as public void insertFront int newValue front new LN newValue front Here front refers to the newly constructed node whose next instance variable refers to all the original nodes in the list and might be null if the linked list were originally empty Notice that this code is very efficient it takes the same amount of time regardless of how many nodes are in the linked list This performance is very different from arrays which require a for loop to shift all their values right by one index when adding a new value at the front The code for inserting a value at rear is a bit more complicated We have already studied the folllowing code for this task public void insertRear int newValue if front null front new LN newValue null else LN r front for r next null r r next r next new LN newValue null Note that the code in the else block starts r at the front of the list and advances it until it refers to last node in the list the only node whose next is null Then the next of this node is changed to refer to a non null value a new node that becomes the rear of the linked list Notice that this code is NOT very efficient It is O N taking an amount of time proportional to the number of nodes already in the linked list for longer lists it takes more time than for shorter lists This performance is also very different from arrays which require some constant amount of time when adding a new value at the rear unless of course the size of the array has to double which requires copying all the values but by doubling array sizes we keep this problem to a minimum without allocating too much space for the array too soon In fact we saw that if we insert many values at the end of the list e g when reading a file of values into a linked list and preserving their order this problem becomes so bad that we declare an extra cache variable to always refer to the rear node in the linked list so that it does not have to be located over and over again by scanning from the front each time If we store a reference to the front of the list and a cache reference to the rear of the list we can add values at both the front or rear very quickly and advantage linked lists have over arrays Such code would be written as public void insertRear int newValue if front null front rear new LN newValue null else rear rear next new LN newValue null Search Methods In this section we will examine two search methods The first which is simpler makes no assumption about the order of the values stored in the linked list The second which builds on the first assumes that the values are stored in increasing order this method can return as soon as it finds the desired value or realizes that the value it is searching for cannot appear later in the list For both methods we assume that they are declared in a class with a front instance variable Both processes are still O N in the worst case and therefore are not as good as binary searching on ordered arrays which is O Log2N In arrays when we try to locate a value we return its index or 1 if the value does not occur in the array For linked lists we return null a reference to no object to indicate the absence of the value being searched for The first search is implemented simply as follows public LN locate int toLocate for LN r front r null r r next if r value toLocate return r return null This method either returns a reference to the first node storing toLocate in its value instance variable or null if the parameter s value appears in no node in the linked list This method may traverse the entire linked list because the value it is searching for can appear anywhere If the values in the linked list are ordered we can write a slightly more complicated method that can be more efficient public LN locate int toLocate for LN r front r null r value toLocate r r next if r value toLocate return r return null Here we terminate the for loop when r stores null or the value referred to by r has already exceeded toLocate or in the body of the loop when the vaue to locate is found at which point we still terminate the entire method Note that we can use DeMorgan s law to determine the termination condition r null r value which simplifies to r null r value toLocate Another way to write this same code is to put all the toLocate comparisons inside the loop leaving the actual for loop simplified public LN locate int toLocate for LN r front r null r r next if r value toLocate return r else if r Value toLocate return null return null Remove Methods In this section we will examine three methods for removing nodes from linked lists in the first two we specify the value stored in the node to remove and in the third we specify a reference directly to the node to remove possibly we found it via one of the previously discussed search methods In all three cases the methods in the worst case scan all the nodes in a linked list making their complexity class O N For all these methods we assume that they are declared in a class with a front instance variable Generally there will be a special case for removing nodes at the front of the list For removing nodes inside the list we will want to stop our cursor one node before the one we want to remove and then excise the required node See the following picture for details about removing the node containing the value 7 notice how r refers not to the node containing 7 but to the node preceding it The first method removes only the first occurrence if it exists of a node containing the specified value As with many mutator methods we need to check as a special case if the value is stored in the first node in which case we must alter front not the next field of some later node public void removeFirst int toRemove if front null return if front value toRemove front front next else for LN r front r next null r r next if r next value toRemove r next r next next return Certainly thinking one ahead when performing checks like r next value toRemove is a bit complicated Another way to write this method is with a ghost reference that keeps track of where r has been Let us call this value prev and use it as shown below Notice that we can drop the front null check because it is not needed verify this hand simulate the code below when front stores null public void removeFirst int toRemove for LN prev null r front r null prev r r r next if r value toRemove if prev null front front next else prev next r next return Here we simply look for r value toRemove but then go back to the ghost reference to alter prev next r next The following code removes ALL nodes that store toRemove in a linked list It uses the look ahead method and contains two more complicated loops The first removes values from the front of the list the second from all other positions int he list public void removeAll int toRemove Remove all values at front if none left return for if front null return Don t try next for loop if front value toRemove break Try next for loop else front front next Remove all values inside assumes front is not empty for LN r front r next null in body if r next value toRemove r next r next next else r r next Advance only on Note that first for loop removes all nodes storing toRemove that are located at the front of the linked list after removing these there might be no other nodes in which case this method returns before executing the second loop The second for loop removes all nodes storing toRemove after the front of the list notice how it carefully and conditionally advances r only when it does not remove a node when it does remove a node r shouldn t advance because it should be rechecked against the new node that now appears directly after the one r refers to Try hand simulating this method to remove all nodes containing 5 from a list containing the nodes 5 5 1 5 5 5 1 5 1 It is a very common mistake to write r r next in the loop header in which case sequential occurences of a value are not all removed from the linked list only the odd numbered ones are removed in each repetitive sequence Finally suppose we have a reference to the node that we want to remove from the list it may have been returned by one of the locate methods described in the previous sections We can write such code as follows Note that we are using for comparison we want to know whether the reference refer to the same object public void remove LN refToRemove if front null return if front refToRemove front front next else for LN r front r next null r r next if r next refToRemove r next r next next return Notice that we must terminate the for loop either when r next refers to null tested in the loop continuation condition refToRemove node was not in the list it also could be null or it refers to refToRemove tested in the loop body again here is a case where we must use the operator on references In this second case we excise the required node and the immediately return Utility Methods equals and copy In this section we will discuss two interesting utility methods The first determines whether two linked lists are equal We will define this term when applied to linked lists to mean that the lists have the same number of nodes and exactly the same values appear in exactly the same order Let s assume that we are defining this method in a collection class CC that also caches the number of nodes in the the linked list by storing its values in the size instance variable Of course we could always compute this value by traversing the list but lets precompute it set it to in the constructor and increment decrement it when nodes are added removed from the list We can then write this method as follows public boolean equals Object other if this other return true if other instanceof CC return false if size CC other size return false Lists are the same size Traverse and check equality for values in nodes for LN r1 front r2 CC other front r1 null r1 r1 next r2 r2 next if r1 value r2 value return false All the same no difference found return true Notice that the declaration in the for loop declares and intializes two cursors only one declaration is allowed in for loops but it can declare and initialize any number of local variables of that one type Symmetrically each cursor is advanced after each iteration of the loop Notice that the loop s continuation condition is just r1 null because we execute the for loop only when the lists are the same size we could replace this by r2 null or even the redundant less efficient r1 null r2 null Because the lists are the same size every time r1 is not null we can guarantee that r2 is not null This method in the worst case is O N because all nodes in the list must be scanned for this method to return true Next suppose that we want to make a copy of a list this means allocate the same number of nodes containing the same values linked together in the same order calling x equals x copy would always return true A simple but slow complexity class O N2 way to implement this method is shown below public CC copy CC answer new CC for LN r front r null r r next answer insertRear r value return answer Here the cursor r traverses the linked list inserting each value it finds at the end of a linked list in CC As we have seen before the insertRear method can take a lot of time when the list has many nodes If the class CC supports a reverse method a faster version can be written as follows public CC copy CC answer new CC for LN r front r null r r next answer insertFront r value answer reverse return answer Now each call to insertFront is O 1 and reverse which we will study in the next section is also O N so N inserts each O 1 followed by a reversal of O N results in the complexity class O N Or we can write an O N method by using a local cache reference as we did when reading values from a file public CC copy LN lastCache null CC answer new CC for LN r front r null r r next if lastCache null lastCache answer front new LN r value null else lastCache lastCache next new LN r value null return answer This method meets the required semantics for copying and is even more efficient than the previous method but it is more complicated to write although reverse is even more complicated see below and this method uses the same caching pattern as when reading values from files so it should be familiar Permutation Methods reverse and sort The following method reverses all the references in a linked list Again we assume only that we are defining this method in a class that stores a front instance variable public void reverse LN answer null for front null LN toMove front front front next toMove next answer answer toMove front answer This code is definitely tricky to write but here it is for use any time you need it Hand simulation here is a requirement It scans the list once so it is O N although there are lots of tricky assignments inside the loop s body Finally how do we sort linked list The fastest way it to first conver the linked list into an array which is O N and then sort the array with Arrays sort which is O NLog2N and then reconstitute the arrray back into the linked list which is O N Thus the entire process is O NLog2N the dominant term The code is written as follows It assumes that the value fields stores a refefence to an Object public void sort Comparator c Object a new Object length assume linked list length is cached LN r front for int i i a length i r r next a i r value Arrays sort a c r front for int i i a length i r r next r value a i Here we transform the problem sorting a list into one we know how to solve efficiently sorting an array and then transform the solution to the new problem the sorted array into a solution to the original one a sorted list Because the transformation from list array and array list are O N the total complexity class is O N O NLog2N O N which is just O NLog2N Generally as long as the transformations from an original problem to a new one and the new answer back to the original answer are each in a complexity class no bigger than the complexity class that solves the new problem the overall complexity class of the original problem will be the same as the complexity class of the new problem That is lots of problems can be transformed to sorting If the complexity classes for doing and undoing the transformation are no bigger than O NLog2N that will be the complexity class for solving the problem Special Lists Now we will study a few variants of linked lists which allow some methods to be written more compactly or more simply or more efficiently These include circular lists header lists trailer lists and doubly linked lists which often have both headers and trailers Although these variants are interesting linear linked lists are simpler to think about and are often very efficient and their code not too complex so they are used much more often in practice than these special variants In the code below assume that the class LN declares private Object value instead of using an int Circular Lists A circular list is a linked list whose last node refers to its first The following pictures illustrate a circular list containing one and three nodes respectively The one node version is especially interesting because its next field refers to itself since its single node is both its first and last The code to print a circular list is a bit intricate we cannot traverse the list until reaching null because there is none stored in a circular list Instead we must print the first node if it exists separately and then traverse the list until we reach the first node again public void print if front null return System out println front value for LN r front next r front r r next System out println r value Hand simulate this code to ensure that you understand it and see why attempts to come up with more compact code fails Header Lists A header list is a linked list that always contains a special header node an empty header list contains just this one node This node stores no data its value field always stores null it exists solely to simplify code that processes linked lists by ensuring that every real node in the linked list is preceded by some node This guarantee allows us to never have to change what front refers to it always refers to the header and therefore we do not need special case code to handle this now impossible option The following pictures illustrate an empty header list and one containing three String values In fact we can declare final front new LN null null because front will always refer to the same node the header And by doing so the Java compiler ensures that we do not every change this value Compare the original code written to remove a value from this list with the code below which works for header lists public void removeFirst Object toRemove for LN r front r next null r r next if toRemove equals r next value r next r next next return Hand simualate this code to ensure that you understand it Notice that this code includes no special tests concerning front but instead includes only the looping code which assumes that toRemove can be reached by following the next field of a preceding node even the real first node has a predecessor the header node Likewise the code for removeAll in a header list is simplified as well public void removeAll int toRemove for LN r front r next null in body if toRemove equals r next value r next r next next else r r next Advance only on This code now looks much like removeFirst but now the loop runs until completion no explicit return inside the loop with a special way to advance r depending on whether or not a node was removed Of course it takes a bit more space to store a header list because it always contains one extra node always just two words of memory Also although some methods can be written more simply on header lists others e g length can be more complicated and take a big longer to execute they must skip over the header node Trailer Lists A trailer list is a linked list that always contains a special trailer node an empty trailer list contains just this one node As with a header node this node stores no data its value field always stores null it exists solely to simplify code that processes linked lists by ensuring that every real node in the linked list is followed by a node The following pictures illustrate an empty trailer list and one containing three String values Although generally less useful than a header list there is one very useful operation that we can perform quickly on a trailer list removing a node that we already have a reference to Note that this node will never be the trailer it will always be a node inside the list coming before the trailer Compare the original code written to remove a node given a reference to it from this list with the code below which works for trailer lists The original code was O N this code is O 1 it needs no looping because it removes a node by actually shifting forward the value in the node following it there always is such a node in trailer lists and excising the followig node whose data is now redundant public void remove LN refToRemove refToRemove value refToRemove next value refToRemove next refToRemove next next Hand simualate this code to ensure that you understand it Sometimes it is useful to combine header and trailer nodes into one list allowing all simple methods both those simple for header lists and those simple for trailer list to be written simply The following pictures illustrate an empty header trailer list and one containing three String values All three remove methods written above operate correctly on such a header trailer list Doubly Linked Lists A doubly linked list is a non linear linked list it contains reference both to the node that comes before and after it in the linked list We would define such a doubly linked node DLN as public class DLN public DLN DLN p Object v DLN n prev p value v next n public DLN prev next public Object value The following pictures illustrate a doubly linked list containing three String values Notice that the prev reference of the first node and the next reference in the last node both store null Respectively no node precedes follows the end ones We can traverse the nodes of doubly linked lists in both directions forward and backward But methods that alter doubly linked lists often requires twice as much overhead as each node now refers to two others not one other the lists themselves occupy 5 more space than simple linear linked lists 3 words of memory not 2 The following method illustrates how to remove a node from a doubly linked list public void remove DLN refToRemove if front refToRemove front refToRemove next else refToRemove prev next refToRemove next if refToRemove next null refToRemove next prev refToRemove prev It is often useful to include both header and trailer nodes on doubly linked lists Doing so ensures that every real node has a predecessor and successor The following pictures illustrate a doubly linked list containing three String values For doubly linked lists with header and trailer nodes we can simplify the remove code to public void remove DLN refToRemove refToRemove prev next refToRemove next refToRemove next prev refToRemove prev Note that front will never equal refToRemove with a header node and likewise refToRemove next will never equal null with a trailer But to create an empty doubly linked header trailer list requires the following code front new DLN null null new DLN null null null front next prev front which is a bit convoluted Finally we can also define circular doubly linked lists and circular doubly linked lists that contain header trailer nodes the smallest of such lists contains two nodes linked both ways circularly The overhead and extra complexity of these special linked lists make them less useful than simple linear linked lists Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a TA or any other student Hand simulate some or all of the methods discussed in this lecture on empty lists and various small non empty lists Rewrite the removeAll method to use ghost references Hand simulate it on various list with various values repeated Suppose that the last node in a circularly linked list referred to a previous node but not the first one What would happen in the print method written above Rewrite the LinkedQueue iterator to support the remove method Hint use a ghost reference ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/lectures/listprocessing/lecture.html", "title": "linked list processing", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Linked List Processing</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Linked List Processing</h1>\r\n<p>\r\n<h2>Introduction to Computer Science II<br>\r\nICS-22<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture we will continue to study a variety of methods that operate on\r\n  linked lists.\r\nIf you study these methods carefully (meaning study their code and hand\r\n  simulate them on various empty and small non-empty lists) you will increase\r\n  your understanding of complex reference manipulation and start to gain an\r\n  understanding of how to write your own linked list code.\r\n<p>\r\nFirst, we will study various linked list processing methods in isolation (or\r\n  in some unspecified collection class, with instance variables).\r\nBy the end of this lecture we will examine the <b>List</b> interface, and how\r\n  it can be implemented directly via arrays and linked lists: these classes\r\n  contains a large number of methods that perform interesting manipulations of\r\n  arrays/lists.\r\nLike other collection classes that we have studied, this class is generic (it\r\n  specifies <b>Object</b> as the type of <b>value</b>, where <b>LN</b>\r\n  specifies an <b>int</b> instance variable).\r\nStudying this code will bring us to the next programming assignment, where we\r\n  implement of various collection classes via linked lists (including\r\n  iterators.\r\n<p>\r\nWe will study a few variants of linked lists, which allow some\r\n  methods to be written more compactly, or more simply, or more efficiently.\r\nThese include circular lists, header lists, trailer lists, and doubly-linked\r\n  lists (which often have both headers and trailers).\r\nAlthough these variants are interesting, linear linked lists are simpler to\r\n  think about and are often very efficient (and their code not too complex),\r\n  so they are used much more often in practice than these special variants.\r\n<p>\r\nFinally, note that linked lists are an implementation technique for collection\r\n  classes (and other purposes).\r\nTheir status is the same as that of arrays: a useful way to implement certain\r\n  well-specified state and behavior.\r\nWe will see, and write even more, collection classes implemented via linked\r\n  lists (often having already seen these collection classes implemented via\r\n  arrays).\r\nSome textbooks describe linked lists as if they were themselves a special kind\r\n  of collection, but I believe that this is a wrong perspective.\r\nBy seeing how queues are implemented via both arrays and linked lists, we will\r\n  see the similarity between arrays and linked lists as implementation tools.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Insert Front/Rear -->\r\n\r\n<a name=\"Review\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Insert Front/Rear</b></td>\r\n<td width =\"80%\">\r\nWe have already examined code for inserting a new value at the front and rear\r\n  of a linked list.\r\nThe code for inserting at the front is trivial: it is a single statement using\r\n  no loops (and therefore is in the O(1) complexity class).\r\nIf we assume that we are defining this method in a class that stores a\r\n  <b>front</b> instance variable (refering to the front of the linked list:\r\n  its first node), then the method would be written as\r\n<pre><b>  public void insertFront (int newValue)\r\n  {front = new LN(newValue,front);}</b></pre>\r\nHere, <b>front</b> refers to the newly constructed node, whose <b>next</b> \r\n instance variable refers to all the original nodes in the list (and might be\r\n  <b>null</b> if the linked list were originally  empty).\r\n<p>\r\nNotice that this code is very efficient: it takes the same amount of time\r\n  regardless of how many nodes are in the linked list.\r\nThis performance is very different from arrays, which require a <b>for</b>\r\n  loop to shift all their values right by one index, when adding a new value\r\n  at the front. \r\n<p>\r\nThe code for inserting a value at rear is a bit more complicated.\r\nWe have already studied the folllowing code for this task.\r\n<pre><b>  public void insertRear (int newValue)\r\n  {\r\n    if (front == null)\r\n      front = new LN (newValue,null);\r\n    else {\r\n      LN r = front;\r\n      for (; r.next!=null; r=r.next)\r\n        {}\r\n      r.next = new LN(newValue,null);\r\n   }</b></pre>\r\nNote that the code in the <b>else</b> block starts <b>r</b> at the front of\r\n  the list and advances it until it refers to last node in the list: the only\r\n  node whose <b>next</b> is <b>null</b>.\r\nThen, the <b>next</b> of this node is changed to refer to a non-null value: a\r\n  new node that becomes the rear of the linked list.\r\n<p>\r\nNotice that this code is NOT very efficient.\r\nIt is O(N), taking an amount of time proportional to the number of nodes\r\n  already in the linked list: for longer lists it takes more time than for\r\n  shorter lists.\r\nThis performance is also very different from arrays, which require some\r\n  constant amount of time when adding a new value at the rear -unless, of\r\n  course, the size of the array has to double, which requires copying all\r\n the values; but by doubling array sizes we keep this problem to a minimum\r\n (without allocating too much space for the array too soon).\r\n<p>\r\nIn fact, we saw that if we insert many values at the end of the list (e.g.,\r\n  when reading a file of values into a linked list and preserving their\r\n  order), this problem becomes so bad that we declare an extra \"cache\"\r\n  variable to always refer to the rear node in the linked list so that it\r\n  does not have to be located over and over again by scanning from the front\r\n  each time.\r\nIf we store a reference to the front of the list and a cache reference to the\r\n  rear of the list, we can add values at both the front or rear very quickly\r\n  (and advantage linked lists have over arrays).\r\nSuch code would be written as\r\n<pre><b>  public void insertRear (int newValue)\r\n  {\r\n    if (front == null)\r\n      front = rear = new LN (newValue,null);\r\n    else\r\n      rear = rear.next = new LN(newValue,null);\r\n  }</b></pre>\r\n\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Search Methods -->\r\n\r\n<a name=\"Search\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Search Methods</b></td>\r\n<td width =\"80%\">\r\nIn this section we will examine two search methods.\r\nThe first, which is simpler, makes no assumption about the order of the values\r\n  stored in the linked list.\r\nThe second, which builds on the first, assumes that the values are stored in\r\n  increasing order; this method can return as soon as it finds the desired\r\n  value or realizes that the value it is searching for cannot appear later in\r\n  the list.\r\nFor both methods, we assume that they are declared in a class with a\r\n <b>front</b> instance variable.\r\nBoth processes are still O(N) in the worst case, and therefore are not as good\r\n  as binary searching on ordered arrays, which is O(Log<sub>2</sub>N).\r\n<p>\r\nIn arrays, when we try to locate a value we return its index (or -1 if the\r\n  value does not occur in the array).\r\nFor linked lists, we return <b>null</b> (a reference to no object) to indicate\r\n the absence of the value being searched for.\r\nThe first search is implemented simply as follows.\r\n<pre><b>  public LN locate (int toLocate)\r\n  {\r\n    for (LN r=front; r!=null; r=r.next)\r\n      if (r.value == toLocate)\r\n         return r;\r\n\r\n    return null;\r\n  }</b></pre>\r\nThis method either returns a reference to the first node storing\r\n  <b>toLocate</b> in its <b>value</b> instance variable, or <b>null</b> (if \r\n the parameter's value appears in no node in the linked list).\r\nThis method may traverse the entire linked list, because the value it is\r\n  searching for can appear anywhere.\r\n<p>\r\nIf the values in the linked list are ordered, we can write a slightly more\r\n  complicated method that can be more efficient.\r\n  <pre><b>  public LN locate (int toLocate)\r\n  {\r\n    for (LN r=front; r!=null && r.value&lt;=toLocate; r=r.next)\r\n      if (r.value == toLocate)\r\n         return r;\r\n\r\n    return null;\r\n  }</b></pre>\r\nHere we terminate the <b>for</b> loop when <b>r</b> stores <b>null</b> or the\r\n  value referred to by <b>r</b> has already exceeded <b>toLocate</b> (or in\r\n  the body of the loop, when the vaue to locate is found -at which point we\r\n  still terminate the entire method).\r\nNote that we can use DeMorgan's law to determine the termination condition: \r\n  <b>!(r!=null && r.value<=toLocate)</b> which simplifies to\r\n  <b>r==null || r.value&gt;toLocate</b>.\r\n<p>\r\nAnother way to write this same code is to put all the <b>toLocate</b>\r\n  comparisons inside the loop, leaving the actual <b>for</b> loop simplified.\r\n  <pre><b>  public LN locate (int toLocate)\r\n  {\r\n    for (LN r=front; r!=null; r=r.next)\r\n      if (r.value == toLocate)\r\n        return r;\r\n      else if (r.Value > toLocate)\r\n        return null;\r\n\r\n    return null;\r\n  }</b></pre>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Remove Methods -->\r\n\r\n<a name=\"Remove\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Remove Methods</b></td>\r\n<td width =\"80%\">\r\nIn this section we will examine three methods for removing nodes from linked\r\n  lists: in the first two we specify the value stored in the node to remove,\r\n  and in the third we specify a reference directly to the node to remove \r\n  (possibly we found it via one of the previously discussed search methods).\r\nIn all three cases the methods, in the worst case, scan all the nodes in a\r\n  linked list, making their complexity class O(N).\r\n<p>\r\nFor all these methods, we assume that they are declared in a class with a\r\n  <b>front</b> instance variable.\r\nGenerally, there will be a special case for removing nodes at the front of the\r\n  list.\r\nFor removing nodes inside the list, we will want to stop our cursor one node\r\n  before the one we want to remove, and then excise the required node.\r\nSee the following picture for details about removing the node containing the\r\n  value <b>7</b>; notice how <b>r</b> refers not to the node containing\r\n  <b>7</b>, but to the node preceding it.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/excise.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThe first method removes only the first occurrence (if it exists) of a node\r\n  containing the specified value.\r\nAs with many mutator methods, we need to check, as a special case, if the\r\n  value is stored in the first node, in which case we must alter <b>front</b>\r\n  (not the <b>next</b> field of some later node).\r\n<pre><b>  public void removeFirst (int toRemove)\r\n  {\r\n    if (front == null)\r\n      return;\r\n\r\n    if (front.value == toRemove)\r\n      front = front.next;\r\n    else\r\n      for (LN r=front; r.next!=null; r=r.next)\r\n        if (r.next.value == toRemove) {\r\n           r.next = r.next.next;\r\n           return;\r\n        }\r\n  }</b></pre>\r\nCertainly thinking \"one ahead\" when performing checks like\r\n  <b>r.next.value == toRemove</b> is a bit complicated.\r\nAnother way to write this method is with a \"ghost\" reference that keeps track\r\n  of where <b>r</b> has been.\r\nLet us call this value <b>prev</b> and use it as shown below.\r\nNotice that we can drop the <b>front == null</b> check because it is not\r\n  needed (verify this! hand simulate the code below when <b>front</b> stores\r\n  <b>null</b>).\r\n<pre><b>  public void removeFirst (int toRemove)\r\n  {\r\n    for (LN prev=null,r=front; r!=null; prev=r,r=r.next)\r\n      if (r.value == toRemove) {\r\n        if (prev == null)\r\n           front = front.next;\r\n        else\r\n           prev.next = r.next;\r\n        return;\r\n      }\r\n  }</b></pre>\r\nHere we simply look for <b>r.value = toRemove</b>, but then go back to the\r\n  ghost reference to alter <b>prev.next = r.next;</b>\r\n<p>\r\nThe following code removes ALL nodes that store <b>toRemove</b> in a linked\r\n  list.\r\nIt uses the look ahead method and contains two, more complicated loops.\r\nThe first removes values from the front of the list; the second from all\r\n  other positions int he list\r\n <pre><b>  public void removeAll (int toRemove)\r\n  {\r\n    //Remove all values at front; if none left, return\r\n    for (;;) {\r\n      if (front==null)\r\n        return;                      //Don't try next for loop\r\n      if (front.value != toRemove)\r\n        break;                       //Try next for loop\r\n      else\r\n        front = front.next;\r\n    }\r\n    \r\n    //Remove all values inside: assumes front is not empty\r\n    for (LN r=front; r.next!=null; /*in body*/)\r\n      if (r.next.value == toRemove)\r\n        r.next = r.next.next;\r\n      else\r\n        r = r.next;                  //Advance only on !=\r\n  }</b></pre>\r\nNote that first <b>for</b> loop removes all nodes storing <b>toRemove</b> that\r\n  are located at the front of the linked list; after removing these, there\r\n  might be no other nodes, in which case this method returns before executing\r\n  the second loop.\r\nThe second <b>for</b> loop removes all nodes storing <b>toRemove</b> after the\r\n  front of the list: notice how it carefully (and conditionally) advances\r\n  <b>r</b> only when it does not remove a node; when it does remove a node\r\n  <b>r</b> shouldn't advance because it should be rechecked against the new\r\n  node that now appears directly after the one <b>r</b> refers to.\r\nTry hand simulating this method to remove all nodes containing <b>5</b> from a\r\n  list containing the nodes <b>5</b>, <b>5</b>, <b>1</b>, <b>5</b>, <b>5</b>,\r\n  <b>5</b>, <b>1</b>, <b>5</b>, <b>1</b>.\r\nIt is a very common mistake to write <b>r=r.next</b> in the loop header, in \r\n  which case sequential occurences of a value are not all removed from the\r\n  linked list (only the odd numbered ones are removed in each repetitive\r\n  sequence).\r\n<p>\r\nFinally, suppose we have a reference to the node that we want to remove from\r\n  the list (it may have been returned by one of the <b>locate</b> methods\r\n  described in the previous sections).\r\nWe can write such code as follows.\r\nNote that we are using <b>==</b> for comparison: we want to know whether the\r\n  reference refer to the same object.\r\n <pre><b>  public void remove (LN refToRemove)\r\n  {\r\n     if (front==null)\r\n       return;\r\n\r\n     if (front == refToRemove)\r\n       front = front.next;\r\n     else\r\n       for (LN r=front; r.next!=null; r=r.next)\r\n         if (r.next == refToRemove) {\r\n           r.next = r.next.next;\r\n           return;\r\n         }\r\n  }</b></pre>\r\nNotice that we must terminate the <b>for</b> loop either when <b>r.next</b>\r\n  refers to <b>null</b> (tested in the loop continuation condition:\r\n  <b>refToRemove</b> node was not in the list; it also could be <b>null</b>)\r\n  or it refers to <b>refToRemove</b> (tested in the loop body): again, here\r\n  is a case where we must use the <b>==</b> operator on references!\r\nIn this second case, we excise the required node and the immediately return. \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Utility Methods -->\r\n\r\n<a name=\"Utility\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Utility Methods: equals and copy</b></td>\r\n<td width =\"80%\">\r\nIn this section we will discuss two interesting utility methods.\r\nThe first determines whether two linked lists are equal.\r\nWe will define this term, when applied to linked lists, to mean that the lists\r\n  have the same number of nodes, and exactly the same values appear in exactly\r\n  the same order.\r\n<p>\r\nLet's assume that we are defining this method in a collection class <b>CC</b>\r\n  that also caches the number of nodes in the the linked list by storing its\r\n  values in the <b>size</b> instance variable.\r\nOf course, we could always compute this value by traversing the list, but lets\r\n  precompute it (set it to <b>0</b> in the constructor, and \r\n  increment/decrement it when nodes are added/removed from the list).\r\nWe can then write this method as follows.\r\n  <pre><b>  public boolean equals(Object other)\r\n  {\r\n    if (this == other)\r\n      return true;\r\n    if (! (other instanceof CC) )\r\n      return false;\r\n \r\n    if (size != ((CC)other).size)\r\n      return false;\r\n\r\n    //Lists are the same size\r\n    //Traverse and check equality for values in nodes\r\n    for (LN r1=front,r2=((CC)other).front; r1!=null; r1=r1.next,r2=r2.next)\r\n      if (r1.value != r2.value)\r\n         return false;\r\n    \r\n    //All the same (no difference found)\r\n    return true;\r\n  }</b></pre>\r\nNotice that the declaration in the <b>for</b> loop declares and intializes two\r\n  cursors (only one declaration is allowed in <b>for</b> loops, but it can\r\n  declare and initialize any number of local variables of that one type).\r\nSymmetrically, each cursor is advanced after each iteration of the loop.\r\nNotice that the loop's continuation condition is just <b>r1!=null</b>; because\r\n   we execute the  <b>for</b> loop only when the lists are the same size, we\r\n  could replace this by  <b>r2!=null</b> (or even the redundant/less efficient\r\n  <b>r1!=null && r2!=null</b>.\r\nBecause the lists are the same size, every time <b>r1</b> is not <b>null</b>\r\n  we can guarantee that <b>r2</b> is not <b>null</b>.\r\n<p>\r\nThis method, in the worst case, is O(N), because all nodes in the list must\r\n  be scanned for this method to return <b>true</b>.\r\nNext, suppose that we want to make a copy of a list: this means allocate the\r\n  same number of nodes, containing the same values, linked together in the\r\n  same order: calling <b>x.equals(x.copy())</b> would always return\r\n  <b>true</b>.\r\nA simple, but slow (complexity class O(N<sup>2</sup>)), way to implement this\r\n  method is shown below.\r\n  <pre><b>  public CC copy()\r\n  { \r\n     CC answer = new CC();\r\n     for (LN r=front; r!=null; r=r.next)\r\n       answer.insertRear(r.value);\r\n\r\n     return answer;\r\n  }</b></pre>\r\nHere, the cursor <b>r</b> traverses the linked list, inserting each value it\r\n  finds at the end of  a linked list (in <b>CC</b>).\r\nAs we have seen before, the <b>insertRear</b> method can take a lot of time\r\n  when the list has  many nodes.\r\nIf the class <b>CC</b> supports a <b>reverse</b> method, a faster version can\r\n  be written as follows.\r\n<pre><b>  public CC copy()\r\n  { \r\n     CC answer = new CC();\r\n     for (LN r=front; r!=null; r=r.next)\r\n       answer.insertFront(r.value);\r\n\r\n     answer.reverse();\r\n     return answer;\r\n  }</b></pre>\r\nNow, each call to <b>insertFront</b> is O(1), and <b>reverse</b> (which we will\r\n  study in the next section) is also O(N), so N inserts (each O(1)) followed by\r\n  a reversal of O(N) results in the complexity class O(N).\r\nOr, we can write an O(N) method by using a local cache reference, as we did\r\n  when reading values  from a file.\r\n   <pre><b>  public CC copy()\r\n  {\r\n    LN lastCache = null;\r\n    CC answer    = new CC();\r\n\r\n    for (LN r=front; r!=null; r=r.next)\r\n      if (lastCache == null)\r\n        lastCache = answer.front   = new LN (r.value,null);\r\n      else \r\n        lastCache = lastCache.next = new LN(r.value,null);\r\n    \r\n    return answer;\r\n  }</b></pre>\r\nThis method meets the required semantics for copying, and is even more\r\n  efficient than the previous method, but it is more complicated to write\r\n  (although <b>reverse</b> is even more complicated -see below- and \r\n  this method uses the same caching pattern as when reading values from files,\r\n  so it should be familiar).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Permutation Methods -->\r\n\r\n<a name=\"Permute\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Permutation Methods: reverse and sort</b></td>\r\n<td width =\"80%\">\r\nThe following method reverses all the references in a linked list.\r\nAgain, we assume only that we are defining this method in a class that stores a\r\n  <b>front</b> instance variable.\r\n<pre><b>  public void reverse()\r\n  {\r\n    LN answer = null;\r\n    for (;front!=null;) {\r\n      LN toMove   = front;\r\n      front       = front.next;\r\n      toMove.next = answer;\r\n      answer      = toMove; \r\n    }\r\n   \r\n    front = answer;\r\n  }</b></pre>\r\nThis code is definitely tricky to write; but here it is for use any time you\r\n  need it.\r\nHand simulation here is a requirement.\r\nIt scans the list once, so it is O(N): although there are lots of tricky\r\n  assignments inside the loop's body.\r\n<p>\r\nFinally, how do we sort linked list.\r\nThe fastest way it to first conver the linked list into an array (which is \r\n  O(N)) and then sort the array with <b>Arrays.sort</b> (which is\r\n  O(NLog<sub>2</sub>N)) and then reconstitute the arrray back into the linked\r\n  list (which is O(N)).\r\nThus, the entire process is O(NLog<sub>2</sub>N)) -the dominant term.\r\nThe code is written as follows.\r\nIt assumes that the <b>value</b> fields stores a refefence to an <b>Object</b>.\r\n<pre><b>  public void sort(Comparator c)\r\n  {\r\n    Object[] a = new Object[length];  //assume linked list length is cached\r\n    LN r = front;\r\n    for (int i=0; i&lt;a.length; i++,r=r.next)\r\n      a[i] = r.value;\r\n\r\n    Arrays.sort(a,c);\r\n\r\n    r = front;\r\n    for (int i=0; i&lt;a.length; i++,r=r.next)\r\n      r.value = a[i];\r\n  }</b></pre>\r\nHere we transform the problem (sorting a list) into one we know how to solve\r\n  efficiently (sorting an array) and then transform the solution to the \r\n  new problem (the sorted array) into a solution to the original one (a sorted\r\n  list).\r\nBecause the transformation from list->array and array->list are O(N),\r\n  the total complexity class is O(N) + O(NLog<sub>2</sub>N) + O(N) which is\r\n  just O(NLog<sub>2</sub>N).\r\n<p>\r\nGenerally, as long as the transformations from an original problem to a new\r\n  one, and the new answer back to the original answer, are each in a complexity\r\n  class no bigger than the complexity class that solves the new problem, the\r\n  overall complexity class of the original problem will be the same as the\r\n  complexity class of the new problem.\r\nThat is, lots of problems can be transformed to sorting. \r\nIf the complexity classes for doing and undoing the transformation are no\r\n  bigger than O(NLog<sub>2</sub>N), that will be the complexity class for\r\n  solving the problem.\r\n<p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Special -->\r\n\r\n<a name=\"Special\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Special Lists</b></td>\r\n<td width =\"80%\">\r\nNow we will study a few variants of linked lists, which allow some\r\n  methods to be written more compactly, or more simply, or more efficiently.\r\nThese include circular lists, header lists, trailer lists, and doubly-linked\r\n  lists (which often have both headers and trailers).\r\nAlthough these variants are interesting, linear linked lists are simpler to\r\n  think about and are often very efficient (and their code not too complex),\r\n  so they are used much more often in practice than these special variants.\r\n<p>\r\nIn the code below, assume that the class <b>LN</b> declares\r\n  <b>private Object value;</b> (instead of using an <b>int</b>).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Circular List -->\r\n\r\n<a name=\"Circular\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Circular Lists</b></td>\r\n<td width =\"80%\">\r\nA circular list is a linked list whose last node refers to its first.\r\nThe following pictures illustrate a circular list containing one and three\r\n  nodes respectively.\r\nThe one node version is especially interesting because its <b>next</b> field\r\n  refers to itself (since its single node is both its first and last).\r\n</tbody>\r\n</table>\r\n  <img src=\"images/circular.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThe code to print a circular list is a bit intricate; we cannot traverse the\r\n  list until reaching <b>null</b>, because there is none stored in a circular\r\n  list.\r\nInstead, we must print the first node (if it exists) separately, and then\r\n  traverse the list until we reach the first node again.\r\n<pre><b>  public void print ()\r\n  {\r\n    if (front == null)\r\n      return;\r\n\r\n    System.out.println(front.value);\r\n    for (LN r=front.next; r!=front; r=r.next)\r\n      System.out.println(r.value);\r\n  }</b></pre>\r\nHand simulate this code to ensure that you understand it (and see why attempts\r\n  to come up with more compact code fails).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Header List -->\r\n\r\n<a name=\"Header\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Header Lists</b></td>\r\n<td width =\"80%\">\r\nA header list is a linked list that always contains a special header node; an\r\n  empty header list contains just this one node.\r\nThis node stores no data (its <b>value</b> field always stores <b>null</b>); it\r\n  exists solely to simplify code that processes linked lists by ensuring that\r\n  every \"real\" node in the linked list is preceded by some node.\r\nThis guarantee allows us to never have to change what <b>front</b> refers to\r\n  (it always refers to the header) and therefore we do not need special-case\r\n  code to handle this (now impossible) option.\r\n<p>\r\nThe following pictures illustrate an empty header list and one containing\r\n  three <b>String</b> values.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/header.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nIn fact, we can declare <b>final front = new LN(null,null);</b> because\r\n  <b>front</b> will always refer to the same node: the header.\r\nAnd by doing so, the Java compiler ensures that we do not every change this\r\n  value.\r\n<p>\r\nCompare the original code written to remove a value from this list with the\r\n  code below, which works for header lists.\r\n<pre><b>  public void removeFirst (Object toRemove)\r\n  {\r\n    for (LN r=front; r.next!=null; r=r.next)\r\n      if (toRemove.equals(r.next.value)) {\r\n        r.next = r.next.next;\r\n        return;\r\n      }\r\n  }</b></pre>\r\nHand simualate this code to ensure that you understand it.\r\nNotice that this code includes no special tests concerning <b>front</b>, but\r\n  instead includes only the looping code, which assumes that <b>toRemove</b>\r\n  can be reached by following the <b>next</b> field of a preceding node; even\r\n  the \"real\" first node has a predecessor (the header node).\r\n<p>\r\nLikewise the code for <b>removeAll</b> in a header list is simplified as well.\r\n <pre><b>  public void removeAll (int toRemove)\r\n  {\r\n    for (LN r=front; r.next!=null; /*in body*/)\r\n      if (toRemove.equals(r.next.value))\r\n        r.next = r.next.next;\r\n      else\r\n        r = r.next;                  //Advance only on !=\r\n  }</b></pre>\r\nThis code now looks much like <b>removeFirst</b>, but now the loop runs\r\n  until completion (no explicit <b>return</b> inside the loop) with a special\r\n  way to advance <b>r</b>, depending on whether or not a node was removed.\r\n<p>\r\nOf course, it takes a bit more space to store a header list, because it always\r\n  contains one extra node (always just two words of memory).\r\nAlso, although some methods can be written more simply on header lists, others\r\n  (e.g., <b>length</b>) can be more complicated and take a big longer to\r\n  execute: they must skip over the header node.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Trailer List -->\r\n\r\n<a name=\"Trailer\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Trailer Lists</b></td>\r\n<td width =\"80%\">\r\n A trailer list is a linked list that always contains a special trailer node;\r\n  an empty trailer list  contains just this one node.\r\nAs with a header node, this node stores no data (its <b>value</b> field always\r\n  stores <b>null</b>); it exists solely to  simplify code that processes linked\r\n  lists by ensuring that every \"real\" node in the linked list is followed by a\r\n  node.\r\n<p>\r\nThe following pictures illustrate an empty trailer list and one containing\r\n  three <b>String</b> values.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/trailer.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nAlthough generally less useful than a header list, there is one very useful\r\n  operation that we can perform quickly on a trailer list: removing a node that\r\n  we already have a reference to.\r\nNote that this node will never be the trailer; it will always be a node inside\r\n  the list, coming before the trailer.\r\nCompare the original code written to remove a node (given a reference to it)\r\n  from this list with the code below, which works for trailer lists.\r\nThe original code was O(N); this code is O(1): it needs no looping, because it\r\n  \"removes\" a node by actually shifting forward the value in the node following\r\n  it (there always is such a node in trailer lists) and excising the followig\r\n  node (whose data is now redundant).\r\n<pre><b>  public void remove (LN refToRemove)\r\n  {\r\n    refToRemove.value = refToRemove.next.value;\r\n    refToRemove.next  = refToRemove.next.next;\r\n  }</b></pre>\r\nHand simualate this code to ensure that you understand it.\r\n<p>\r\nSometimes it is useful to combine header and trailer nodes into one list,\r\n  allowing all simple methods (both those simple for header lists and those\r\n  simple for trailer list) to be written simply.\r\nThe following pictures illustrate an empty header/trailer list and one\r\n  containing three <b>String</b> values.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/headertrailer.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nAll three <b>remove...</b> methods written above operate correctly on such a\r\n  header/trailer list\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Doubly-Linked List -->\r\n\r\n<a name=\"Doubly\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Doubly-Linked  Lists</b></td>\r\n<td width =\"80%\">\r\nA doubly-linked list is a non-linear linked list: it contains reference both to\r\n  the node that comes before and after it in the linked list.\r\nWe would define such a doubly-linked node (<b>DLN</b>) as\r\n   <pre><b>  public class DLN {\r\n    public DLN (DLN p, Object v, DLN n)\r\n    {prev = p; value = v; next = n;}\r\n\r\n    public DLN    prev,next;\r\n    public Object value;\r\n  }</b></pre>\r\nThe following pictures illustrate a doubly-linked list containing three\r\n  <b>String</b> values.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/doubly.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNotice that the <b>prev</b> reference of the first node and the <b>next</b>\r\n  reference in the last node both store <b>null</b>.\r\nRespectively, no node precedes/follows the end ones.\r\n<p>\r\nWe can traverse the nodes of doubly-linked lists in both directions: forward\r\n  and backward.\r\nBut methods that alter doubly-linked lists often requires twice as much\r\n  overhead (as each node now refers to two others, not one other); the lists\r\n  themselves occupy 50% more space than simple linear linked lists (3 words of\r\n  memory, not 2).\r\nThe following method illustrates how to remove a node from a doubly-linked\r\n  list.\r\n<pre><b>  public void remove (DLN refToRemove)\r\n  {\r\n     if (front == refToRemove)\r\n       front = refToRemove.next;\r\n     else\r\n       refToRemove.prev.next = refToRemove.next;\r\n\r\n     if (refToRemove.next != null)\r\n       refToRemove.next.prev = refToRemove.prev;\r\n  }</b></pre>\r\n  <p>\r\nIt is often useful to include both header and trailer nodes on doubly-linked\r\n  lists.\r\nDoing so ensures that every \"real\" node has a predecessor and successor\r\nThe following pictures illustrate a doubly-linked list containing three\r\n  <b>String</b> values.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/doublyht.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nFor doubly-linked lists with header and trailer nodes, we can simplify the\r\n  remove code to\r\n<pre><b>  public void remove (DLN refToRemove)\r\n  {\r\n    refToRemove.prev.next = refToRemove.next;\r\n    refToRemove.next.prev = refToRemove.prev;\r\n  }</b></pre>\r\nNote that <b>front</b> will never equal <b>refToRemove</b> with a header node,\r\n  and likewise <b>refToRemove.next</b> will never equal <b>null</b> with a\r\n  trailer.\r\n<p>\r\nBut, to create an empty doubly-linked header/trailer list requires the\r\n  following code:\r\n<pre><b>  front = new DLN(null,null,new DLN(null,null,null));\r\n  front.next.prev = front;</b></pre>\r\nwhich is a bit convoluted.\r\n<p>\r\nFinally, we can also define circular doubly-linked lists, and\r\n  circular doubly linked lists that contain header/trailer nodes:\r\n  the smallest of such lists contains two nodes linked both ways circularly.\r\nThe overhead and extra complexity of these special linked lists make them\r\n  less useful than simple linear linked lists.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- In Class -->\r\n<!--\r\n<a name=\"InClass\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Collection Classes Implemented Linked Lists</b></td>\r\n<td width =\"80%\">\r\nIn this section we will briefly examine how queues are implemented via linked\r\n  lists.\r\nThis includes examining a nested class (<b>QNode</b>, which takes the place\r\n  of <b>LN</b>) and an inner class used for an iterator\r\n  (<b>LinkedQueueIterator</b>).\r\nYou can download, unzip, run, and examine the linked list implementation of \r\n  a queue (and stack), along with a driver program, in the\r\n  <a href=\"../../programs/orderedcollection.zip\">\r\n    Ordered Collections Demonstration</a>.\r\nWe will discuss some, but not all, of the methods implementing the\r\n  <b>OrderedCollection</b> interface.\r\n<p>\r\nTo start, the <b>ListQueue</b> class declares the following nested class for\r\n  its own use (very similar in form to the <b>LN</b> class).\r\n<b><pre>  private static class QueueNode {\r\n    Object    value;\r\n    QueueNode next  = null;  //The default is null anyway.\r\n    \r\n    QueueNode (Object v)\r\n    {value = v; }\r\n    \r\n    public String toString()\r\n    {return \"\"+value;}\r\n  }</pre></b>\r\nNote that this class is NOT an \"inner\" class because it is declared\r\n  <b>static</b>.\r\nUnlike inner classes, nested classes do not implicitly refer to any\r\n  object, and therefore cannot access any state in objects in their outer\r\n  class.\r\nAs a result of not having a reference to the outer class object, they occupy \r\n  a bit less space.\r\nFinally, the more general (two-parameter) constructor is not needed here.\r\nThe constructor is called only in the method <b>add</b>, shown below, and its\r\n  next should always be set to <b>null</b>.\r\n<p>\r\nBecause queues need to be able to access the front quickly (<b>remove</b> and\r\n  <b>peek</b>) as well as the rear quickly (<b>add</b>), this class declares\r\n  two instance variables, both intialized implicitly to <b>null</b>.\r\n<b><pre>  private QueueNode first;\r\n  private QueueNode last;   //access only if first != null</pre></b>\r\nThe three main methods are thus implemented as follows.\r\nThe call to <b>super</b> updates a count (kept in the <b>abstract</b>\r\n  superclass) of the number of elements in the collection\r\n<b><pre>\r\n  public boolean add (Object o)\r\n  {\r\n    super.add(o);\r\n    if (first == null)\r\n      first = last = new QueueNode(o);\r\n    else\r\n      last = last.next = new QueueNode(o);\r\n    return true;\r\n  }\r\n\r\n  public Object remove ()\r\n    throws NoSuchElementException\r\n  {\r\n    super.remove();\r\n    Object answer = first.value;\r\n    first = first.next;\r\n    return answer;\r\n  }\r\n\r\n  public Object peek()\r\n    throws NoSuchElementException\r\n  {\r\n    if (isEmpty())\r\n      throw new NoSuchElementException();\r\n    return first.value;\r\n  }</pre></b>\r\nNote that the <b>clear</b> method below overrides the one defined in the\r\n  <b>abstact</b> class <b>OrderedCollection</b>: here it operates in\r\n  O(1) by just setting four variables: the inherited one peforms\r\n  N removes, which is O(N).\r\n<b><pre>  public void clear ()\r\n  {\r\n    modCount++;\r\n    objectCount = 0;\r\n    first = last = null;\r\n  }</pre></b>\r\nOf course, the <b>QueueNodes</b> that used to be in the linked list are\r\n  now unreachable, and will eventually be garbage collected (if the program\r\n  needs more space).\r\n<p>\r\nFinally, one of the most interesting aspects of this class is its iterator.\r\nThe full iterator, which is an inner class (it is a nested class that is not\r\n  <b>static</b>), is illustrated below.\r\nIt contains the standard <b>expectedModCount</b> instance variable\r\n  (used in its methods to determine whether to throw\r\n  <b>ConcurrentModificationException</b>) and a cursor to the value that\r\n  <b>next</b> will return; this value is originally taken from the <b>first</b>\r\n  instance variables stored in the outer class (which refers to the first\r\n  value in the priority queue).\r\n<b><pre>  private class LinkedQueueIterator implements Iterator {\r\n  \r\n    LinkedQueueIterator ()\r\n    {\r\n      iteratorCursor   = first;\r\n      expectedModCount = modCount;\r\n    }\r\n\r\n   \r\n    public boolean hasNext()\r\n    {return iteratorCursor != null;}\r\n\r\n   \r\n    public Object next()\r\n     throws ConcurrentModificationException, NoSuchElementException\r\n    {\r\n      if (modCount != expectedModCount)\r\n        throw new ConcurrentModificationException();\r\n      if (iteratorCursor == null)\r\n        throw new NoSuchElementException();\r\n\r\n      Object answer = iteratorCursor.value;\r\n      iteratorCursor = iteratorCursor.next;\r\n      return answer;\r\n    }\r\n   \r\n   \r\n    public void remove()\r\n      throws UnsupportedOperationException;\r\n    {throw new UnsupportedOperationException();}\r\n    \r\n    private int       expectedModCount;\r\n    private QueueNode iteratorCursor;\r\n  }</pre></b>\r\nThe <b>iterator</b> method declared in the <b>LinkedQueue</b> class returns a\r\n  reference to an object constructed from this inner class,\r\n which implements just a constructor and the methods required by the\r\n  <b>Iterator</b> interface.\r\nIt is simple written as follows.\r\n<b><pre>  public Iterator iterator()\r\n  {return new LinkedQueueIterator();}</pre></b>\r\nRecall that every object constructed from an inner class can refer to all the\r\n  instance variables in its outer class.\r\nThat is how in the linked list instance variables <b>first</b> and\r\n  <b>modCount</b> can be accessed in the constructor.\r\n</td>\r\n</tbody>\r\n</table>\r\n-->\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Hand simulate some (or all!) of the methods discussed in this lecture on\r\n      empty lists and various small non-empty lists.\r\n<p>\r\n<li>Rewrite the <b>removeAll</b> method to use ghost references. \r\n    Hand simulate it on various list with various values repeated.\r\n<p>\r\n<li>Suppose that the last node in a circularly linked list referred to a\r\n      previous node, but not the first one.\r\n    What would happen in the <b>print</b> method written above.\r\n<p>\r\n<li>Rewrite the <b>LinkedQueue</b> iterator to support the <b>remove</b>\r\n       method.\r\n    Hint: use a ghost reference.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 34522.0}