{"text": "Program 4 Hash Tables Implementing Maps Skip Lists Implementing Sets Adapters from Maps to Sets Fundamental Data Structures ICS 23 Introduction This programming assignment is designed to ensure that you know how to write code that processes Hash Tables and Skip Lists Hash tables are a data structure of a faster complexity class than BSTs for most operations i e O 1 We will reimplement a Map via a hash table Skip Lists are are a data structure of the same complexity class as BSTs but they come with a guarantee that there are no pathological skip lists and the constant for Skip List operations is typically faster than the constant for BSTs We will implement a Set via a Skip List Finally we will implement an adapter something like a decorator that allows us to adapt any implementation of a Map to a Set using the values of the keys in a Map to represent the values in a Set The code will be trivial it delegates each Set operation to similar Map operations e g checking whether a value is in a Set will be delegated to checking if that value is a key in a Map When writing your classes you will run each against my JUnit tests to verify a bit too strong of a word here that it is correct You may also find it useful to test your classes with the DriverForMap or DriverForCollection which you can run from collections jar once you build a path to this library in the project With this driver you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString Download and unzip the following Eclipse project Start and use it to start working on this program For each part of this assignmnment you will update and turn in a single java file in the project see the Checkmate submission for this assignment for more details Only one student should submit the assignment but both student s names should appear in the comments at the top of each submitted program Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review while you work on this assignment and before you turn in the files Problem 1 Map via Hash Table In this problem you will write a more efficient version of a map by implementing it as a hash table Most hash table operations are O 1 so this improves on the complexity class for most operations in a BST We will use a trailer list in each bin to store the overflows from all the collisions we use a trailer list because there is a simple algorithm for removing a node given a reference to it and not having to determine what comes before that node in the list You can test this program with TestMap a JUnit test how we will ultimately grade it and with an updated version of the WordGenerator program included in the download from Program 1 part 6 on the file huck txt also included in the download With the DriverForMap program you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString I will supply a toString method that returns a String that prints showing the structure of the hash table and reports an error message if it doesn t appear that a bin stores a trailer list The HashMap class must implement the Map interface using standard map semantics You should look at my ArrayMap class which contains code that implements the same Map interface some of which or code like it will belong in the hash table implementation Here the underlying data structure is a hash table whose node class is complete within the implementation which also includes some helper methods like hashCompression locate and doubleLength these are either completley written or just their header is specified Of course you can also look at the BSTMap class that you write in Programming Assignment 3 Here are some issues to think about when writing your class The constructors specify the maximum load factor if adding a value to the hash table increases its load factor beyond this maximum check this after the value is added double the length of the hash table rehashing all its values into the new hash table the compression function should be based on its new length To ensure that there is some chaining in the bins the default constructor used by the MapDriver and the JUnit test specifies a load factor of 2 Create the hash table as an LN and cast it to LN K V Store references to new LN K V objects in the hash table In the doubleLength method first put new trailer nodes in all the bins Then unlike my solution in Quiz 5 do add the NODE from the original table into the double length table do not construct new LN K V objects in the double length hash table reuse the old LN K V objects from the original hash table Use trailer lists in each bin in the hash table this makes some simple operations a bit harder but it makes some complicated operations removal much simpler Remember whenever you allocate a hash table new LN you must store a reference to a trailer node in each bucket no bin should ever store null Each trailer should store null in the entry and next instance variable in its LN K V object Note that I have written a toString method that can be used to nicely print a hash table it shows the bins and the linked list of associations mappings in teach bin use the t command in the driver program to help debug your methods for adding deleting from a hash table Also note this toString method includes an error if any bin is null does not contain a trailer node or if any bucket with a linked list does not end with a trailer a node whose entry and next instance variables store null This instrumented version of toString can supply you with valuable debugging information The iterator for this method does not need to and should not use extra arrays or hash tables You can iterate through the hash table directly using two variables one stores which bucket the iterator is in in case it has to advance to other buckets and one stores what LN s key value it will return next and it will traverse all the values in its chain but not the trailer node In HashMap which uses trailer nodes remove in the Iterator is fairly straightforward Ensure that you know the special way to use trailer nodes to simplifiy removal of a value both in the main remove and the remove in the iterator You should also run the updated WordGenerator program with the large text file huck txt The update allows you to comment out code to select either the ArrayMap BSTMap and its appropriate comparator or the HashMap It also tracks and prints the amount of time needed to build the map on my machine it took 18 minutes using ArrayMap and 1 second using BSTMap a speed up of a factor of over 1 when I used an order statistic of 3 Using a HashMap the time reduce to about 5 seconds All ultimately producing a map that contains 9 7 5 keys with each key mapping to a list of between 1 and 46 words Problem 2 An Adapter for Maps to Set The class SetFromMap is an adapter similar to a decorator it has constructors that take any class implementing a Map whose keys are the generic type E and its methods adapt the Map to be used like a Set E Inside SetFromMap the map instance variable which refers to the Map to which most operations are delegated is of type Map E Object which uses E as the key type and Object as the value type more on using values later So if you use SetFromMap it is natural to declared the value type for the Map to be Object but the adapter will work with other types for values Every method call contains one statement that delegates the Set operations to some similar Map operation on keys For example here is the add method public boolean add E e return map put e new Object null Which says to add e to the set put e in the map as a key with an associated value new Object this object is just a necessary placeholder the value for the key in the map all keys map to new objects whose values are almost never used see below about why we don t just map every key to null If the put method returns null it means that e was not already in the map so it is added to the set if it returns a non null value the Object from a previous put with this key then that value is already in the set and therefore it is NOT added to the set Of course add must return whether or not e was added to the set If we mapped each key to null we couldn t distinguish whether or not the key was already in the map meaning the value was already in the set Likewise all the other set methods are implemented by delgating to similar map methods The body of each method is one statement You can test your code via the TestSetAdapter JUnit test It is like the standard Set JUnit test but it prompts for a Map and then adapts it using SetFromMap Select which Map implementation you want to adapt either ArrayMap from the collections jar library BSTMap my solution from Programming Assignment 3 or the HashMap you are writing for this assignment Problem 3 Set via Skip List In this problem you will write a Skip List implementation of a set You can test this program with TestSet a JUnit test how we will ultimately grade it With the DriverForCollection program the Set interface inherits all the methods from Collection interface but unlike the List interface adds no others you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString which is especially important in this problem I will supply a toString method that returns a String that prints showing the structure of the Skip List which reports an error indicate if the Skip List has too few or extra nodes at each level The SkipListSet class must implement the Set interface using standard set semantics You should look at my ArraySet class which contains code that implements the same Set interface some of which or code like it will belong in the skip list implementation Here the underlying data structure is a skip list whose node class is complete within the implementation and has an interesting exciseLeftRight method which also includes some helper methods that I have written addNewTop build2x2 linkLeftRight linkUpDown and some helper methods you will write skipSearch skipInsert and skipDelete We will use Skip List nodes that store a value the value in the set and four references to the Skip List node up down left and right of this one Skip List nodes will store a value of null for the inf and inf nodes which act as header trailer nodes in a Skip List Ensure that you store the correct references in all these instance variables Here are some issues to think about when writing your class The hasNext and next methods in the iterator traverse the s level of the skip list The remove method in the iterator can call skipDelete similarly to how the standard remove method calls it See the Goodrich and Tamassia book and the comments in my code for more information ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/assignments/program4/program.html", "title": "program 4", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 4</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 4</h1>\r\n<h1>\r\n    Hash Tables Implementing Maps</br>\r\n    Skip Lists Implementing Sets<br>\r\n    Adapters from Maps to Sets\r\n    \r\n</h1>\r\n<p>\r\n<h2>Fundamental Data Structures<br>\r\nICS-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to\r\n  write code that processes Hash Tables and Skip Lists.\r\nHash tables are a data structure of a faster complexity class than BSTs for\r\n  most operations (i.e., O(1)).\r\nWe will reimplement a Map via a hash table.\r\nSkip Lists are are a data structure of the same complexity class as BSTs,\r\n  but they come with a guarantee that there are no pathological skip lists,\r\n  and the constant for Skip List operations is typically faster than the\r\n  constant for BSTs.\r\nWe will implement a Set via a Skip List.\r\nFinally, we will implement an adapter (something like a decorator) that allows\r\n  us to adapt\r\n  any implementation of a <b>Map</b> to a <b>Set</b>: using the values of the\r\n  keys in a <b>Map</b> to represent the values in a <b>Set</b>.\r\nThe code will be trivial; it delegates each <b>Set</b> operation to similar\r\n  <b>Map</b> operations: e.g., checking whether a value is in a <b>Set</b> will\r\n  be delegated to checking if that value is a key in a <b>Map</b>.\r\n<p>\r\nWhen writing your classes, you will run each against my JUnit tests to verify\r\n  (a bit too strong of a word here) that it is correct.\r\nYou may also find it useful to test your classes with the\r\n  <b>DriverForMap</b> or <b>DriverForCollection</b>, which you can run\r\n  from <b>collections.jar</b> once you build a path to this library in the\r\n  project.\r\nWith this driver, you can individually test any methods in your classes\r\n  interactively, and see their results (returned values and state changes,\r\n  mostly using <b>toString</b>).\r\n<p>\r\n<!---\r\nThe JUnit test also includes a speed test (be careful: it makes little\r\n  sense to compare speed tests run on two different machines, as the machines\r\n  themselves might run at different speeds).\r\nNote that a class <b>must pass all its correctness tests</b> to get any credit\r\n  for speed.\r\n<p>\r\n--->\r\nDownload and unzip the following <a href=\"program4start.zip\">Eclipse project\r\n  Start</a> and use it to start working on this program.\r\nFor each part of this assignmnment you will update and turn in a single\r\n  <b>.java</b> file in the project (see the <b>Checkmate</b> submission for\r\n  this assignment for more details).\r\n<p>\r\n<b>Only one student should submit the assignment</b>, but both student's names\r\nshould appear in the comments at the top of <b>each submitted program</b>.\r\nPlease turn in each program as you finish it, so that I can accurately assess\r\n  the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review while you work on\r\n  this assignment and before you turn in the files).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Map via Hash Table</b></td>\r\n<td width =\"80%\">\r\nIn this problem you will write a more efficient version of a map, by\r\n  implementing it as a hash table.\r\nMost hash table operations are O(1), so this improves on the complexity class\r\n  for most operations in a BST.\r\nWe will use a <b>trailer list</b> in each bin to store the overflows from all\r\n  the collisions: we use a trailer list because there is a simple algorithm for\r\n  removing a node given a reference to it (and not having to determine what\r\n  comes before that node in the list).\r\n<p>\r\nYou can test this program with <b>TestMap</b>, a JUnit test (how we will\r\n  ultimately grade it), and with an updated version of the <b>WordGenerator</b>\r\n  program (included in the download) from Program #1 part 6, on the file\r\n  <b>huck.txt</b> (also included in the download).\r\nWith the <b>DriverForMap</b> program, you can individually test any methods in\r\n  your classes interactively, and see their results (returned values and state\r\n  changes, mostly using <b>toString</b>).\r\nI will supply a <b>toString</b> method that returns a <b>String</b> that prints\r\n  showing the structure of the hash table, and reports an error message if it\r\n  doesn't appear that a bin stores a trailer list.\r\n<p>\r\nThe <b>HashMap</b> class must implement the <b>Map</b> interface using\r\n  standard map semantics.\r\nYou should look at my <b>ArrayMap</b> class, which contains code that\r\n  implements the same <b>Map</b> interface, some of which (or code like\r\n  it) will belong in the hash table implementation.\r\nHere, the underlying data structure is a hash table, whose node class is\r\n  complete within the implementation, which also includes some helper methods\r\n  like <b>hashCompression</b>, <b>locate</b>, and <b>doubleLength</b>; these\r\n  are either completley written or just their header is specified.\r\nOf course, you can also look at the <b>BSTMap</b> class that you write in\r\n  Programming Assignment #3.\r\n<p>\r\nHere are some issues to think about when writing your class.\r\n<ol>\r\n<li>The constructors specify the maximum load factor; if adding a value to the\r\n      hash table increases its load factor beyond this maximum (check this\r\n      after the value is added), double the length of the hash table, rehashing\r\n      all its values into the new hash table; the compression function should\r\n      be based on its new length.\r\n    To ensure that there is some chaining in the bins, the default constructor\r\n      used by the <b>MapDriver</b> and the JUnit test specifies a load factor\r\n      of 2.\r\n<p>\r\n<li>Create the hash table as an <b>LN[]</b> and cast it to\r\n       <b>LN&lt;K,V&gt;[]</b>.\r\n    Store references to new <b>LN&lt;K,V&gt;</b> objects in the hash table.\r\n<p>\r\n    In the <b>doubleLength</b> method, first put <b>new</b> trailer nodes in\r\n      all the  bins.\r\n    Then, unlike my solution in Quiz #5, do add the NODE from the original\r\n      table into the double-length table: do not construct <b>new </b>\r\n      <b>LN&lt;K,V&gt;</b> objects in the double-length hash table; reuse the\r\n      old  <b>LN&lt;K,V&gt;</b> objects from the original hash table.\r\n<p>\r\n<li>Use <b>trailer</b> lists in each bin in the hash table: this makes some\r\n      simple operations a bit harder, but it makes some complicated operations\r\n      (removal) much simpler.\r\n    Remember, whenever you allocate a hash table (<b>new LN[]</b>) you\r\n      must store a reference to a trailer node in each bucket: no bin should\r\n      ever store <b>null</b>.\r\n    Each trailer should store <b>null</b> in the <b>entry</b> and </b>next</b>\r\n      instance variable in its <b>LN&lt;K,V&gt;</b> object.\r\n<p>\r\n<li>Note that I have written a <b>toString</b> method that can be used to\r\n      nicely print a hash table: it shows the bins and the linked list of\r\n      associations/mappings in teach bin; use the <b>t</b> command in the\r\n      driver program to help debug your methods for adding/deleting from a\r\n      hash table.\r\n    Also note, this <b>toString</b> method includes an error if any bin\r\n      is <b>null</b> (does not contain a trailer node) or if any bucket with\r\n      a linked list does not end with a trailer (a node whose <b>entry</b> and\r\n      <b>next</b> instance variables store <b>null</b>).\r\n    This instrumented version of <b>toString</b> can supply you with valuable\r\n      debugging information.\r\n<p>\r\n<li>\r\nThe iterator for this method does not need to (and should not) use extra\r\n  arrays or hash tables.\r\nYou can iterate through the hash table directly using two variables: one\r\n  stores which bucket the iterator is in (in case it has to advance to other\r\n  buckets) and one stores what <b>LN</b>'s key/value it will return next (and\r\n  it will traverse all the values in its chain, <b>but not the trailer\r\n  node</b>).\r\nIn <b>HashMap</b>, which uses trailer nodes, <b>remove</b> in the\r\n  <b>Iterator</b> is fairly straightforward.\r\n<b>Ensure that you know the special way to use trailer nodes to simplifiy\r\n   removal of a value, both in the main remove and the remove in the\r\n   iterator</b>.\r\n</ol>\r\n<p>\r\nYou should also run the updated <b>WordGenerator</b> program, with the large\r\n   text file (huck.txt)\r\nThe update allows you to \"comment\" out code to select either the\r\n  <b>ArrayMap</b>, <b>BSTMap</b> (and its appropriate comparator), or the\r\n  <b>HashMap</b>.\r\nIt also tracks and prints the amount of time needed to build the map: on\r\n  my machine it took 18 minutes using <b>ArrayMap</b> and 1 second using\r\n  <b>BSTMap</b> (a speed-up of a factor of over 1,000), when I used an order\r\n  statistic of 3.\r\nUsing a <b>HashMap</b> the time reduce to about .5 seconds.\r\nAll ultimately producing a map that contains 90,705 keys with each key\r\n  mapping to a list of between 1 and 46 words.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 2 -->\r\n\r\n<a name=\"problem2\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2: An Adapter for Maps to Set</b></td>\r\n<td width =\"80%\">\r\nThe class <b>SetFromMap</b> is an adapter (similar to a decorator): it has\r\n  constructors that take any class implementing a <b>Map</b> whose keys are\r\n  the generic type <b>E</b> and its methods adapt the <b>Map</b> to be used\r\n  like a  <b>Set&lt;E&gt;</b>.\r\nInside <b>SetFromMap</b> the <b>map</b> instance variable, which refers to the\r\n  <b>Map</b> to which most operations are delegated, is of type\r\n  <b>Map&lt;E,Object&gt;</b>, which uses <b>E</b> as the key type\r\n  and <b>Object</b> as the value type (more on using values later).\r\nSo, if you use <b>SetFromMap</b> it is natural to declared the value type\r\n  for the <b>Map</b> to be <b>Object</b> (but the adapter will work with\r\n  other types for values).\r\n<p>\r\nEvery method call contains one statement, that delegates the <b>Set</b>\r\n  operations to some similar <b>Map</b> operation on keys.\r\nFor example, here is the <b>add</b> method.\r\n<b><pre>  public boolean add(E e) {\r\n    return map.put(e,new Object()) == null;\r\n  }</pre></b>\r\n\r\nWhich says, to <b>add</b> <b>e</b> to the set, <b>put</b> <b>e</b> in the map\r\n  as a key with an associated value <b>new Object()</b> (this object is just\r\n  a necessary placeholder: the value for the key in the map; all keys map to\r\n  new objects, whose values are almost never used: see below about why we\r\n  don't just map every key to <b>null</b>).\r\n<p>\r\nIf the <b>put</b> method returns <b>null</b> it means that <b>e</b> was not\r\n  already in the map (so it is added to the set); if it returns a non-null\r\n  value (the <b>Object</b> from a previous <b>put</b> with this key, then\r\n  that value is already in the set and therefore it is NOT added to the set.\r\nOf course <b>add</b> must return whether or not <b>e</b> was added to the set.\r\nIf we mapped each key to <b>null</b> we couldn't distinguish whether or not\r\n  the key was already in the map (meaning the value was already in the set).\r\n<p>\r\nLikewise, all the other set methods are implemented by delgating to similar\r\n  map methods.\r\n<b>The body of each method is one statement.</b>\r\n<p>\r\nYou can test your code via the <b>TestSetAdapter</b> JUnit test.\r\nIt is like the standard <b>Set</b> JUnit test, but it prompts for a\r\n  <b>Map</b> and then adapts it using <b>SetFromMap</b>.\r\nSelect which <b>Map</b> implementation you want to adapt: either\r\n   <b>ArrayMap</b> from the <b>collections.jar</b> library, <b>BSTMap</b>\r\n   (my solution from Programming Assignment #3), or the <b>HashMap</b> you\r\n   are writing for this assignment.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 3 -->\r\n\r\n<a name=\"problem3\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #3: Set via Skip List</b></td>\r\n<td width =\"80%\">\r\nIn this problem you will write a Skip List implementation of a set.\r\n<p> \r\nYou can test this program with <b>TestSet</b>, a JUnit test (how we will\r\n  ultimately grade it)\r\nWith the <b>DriverForCollection</b> program (the <b>Set</b> interface inherits\r\n  all the methods from <b>Collection</b> interface, but unlike the <b>List</b>\r\n  interface adds no others), you can individually test\r\n  any methods in your classes interactively, and see their results (returned\r\n  values and state changes, mostly using <b>toString</b>,\r\n  which is especially important in this problem).\r\nI will supply a <b>toString</b> method that returns a <b>String</b> that prints\r\n  showing the structure of the Skip List, which reports an error indicate if\r\n  the Skip List has too few or extra nodes at each level.\r\n<p>\r\nThe <b>SkipListSet</b> class must implement the <b>Set</b> interface using\r\n  standard set semantics.\r\nYou should look at my <b>ArraySet</b> class, which contains code that\r\n  implements the same <b>Set</b> interface, some of which (or code like\r\n  it) will belong in the skip list implementation.\r\nHere, the underlying data structure is a skip list, whose node class is\r\n  complete within the implementation (and has an interesting\r\n   <b>exciseLeftRight</b> method), which also includes some helper methods\r\n  that I have written: <b>addNewTop</b>, <b>build2x2</b>, <b>linkLeftRight</b>,\r\n  <b>linkUpDown</b>; and some helper methods you will write:\r\n  <b>skipSearch</b>, <b>skipInsert</b>, and <b>skipDelete</b>.\r\n<p>\r\nWe will use Skip List nodes that store a value (the value in the set) and\r\n  four references: to the Skip List node up, down, left, and right of this\r\n  one.\r\nSkip List nodes will store a value of null for the -inf and +inf nodes, which\r\n  act as header/trailer nodes in a Skip List.\r\nEnsure that you store the correct references in all these instance variables.\r\n<p>\r\nHere are some issues to think about when writing your class.\r\n<ol>\r\n<li>The <b>hasNext</b> and <b>next</b> methods in the iterator traverse the\r\n      s0 level of the skip list.\r\n<p>\r\n<li>The <b>remove</b> method in the iterator can call <b>skipDelete</b>\r\n      similarly to how the standard <b>remove</b> method calls it.\r\n</ol>\r\nSee the <a href=\"Goodrich400.pdf\">Goodrich and Tamassia book</a> and the\r\n   comments in my code for more information.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 33181.0}