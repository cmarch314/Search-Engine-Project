{"text": "ICS 32 Winter 2 15 News Course Reference Schedule Project Guide Code Examples About Alex ICS 32 Winter 2 15 Code Example Downloading data from the web Background Thus far in this course and the preceding one you ve written Python programs that read data from text files and that exchange data over a network via sockets which are two big steps that push outward the boundaries of what we can accomplish in Python However there is an elephant in the room so to speak if we think about where most of the interesting data on the Internet resides it s on the web Web sites display content and allow human users to interact with web based data while web services provide a similar ability to other programs In both cases the same fundamentals we ve already seen apply a connection is initiated by a client connecting to a server usually on the server s port 8 and a protocol is followed that governs what the conversation looks like So if we want to interact with web data the simplest example of which is to download the content of a web page we need to know enough about that protocol to be able to implement the conversation URLs When we use a browser to visit a web page all we need to do is tell the browser where we want to go and it handles the rest The notion of where you want to go is encapsulated by a URL Uniform Resource Locator which specifies a few things What protocol should be used to download the web page From what host i e an IP address or the name of a machine like www ics uci edu should the web page be downloaded Occasionally we also specify the port when we want it to be something other than the default What page on that machine should be downloaded One of the earlier code examples included a link to a short Python module called oops py The complete URL for that link is http www ics uci edu thornton ics32 CodeExamples ExceptionalControlFlow oops py Here s what that URL means The first few characters preceding the colon indicate what protocol should be used for the network conversation For most web pages that protocol will be listed as http which means that we d like to use the protocol called HTTP HyperText Transfer Protocol Another common alternative is https which uses HTTP over a secure encrypted connection to make eavesdropping substantially difficult After the colon and the two slashes is the host In this case that host is listed as www ics uci edu which is the machine on which the ICS web site is hosted It is possible also to specify a port by following the host with a colon and a port number e g www ics uci edu 8 8 The default port number for HTTP traffic is 8 and since most web sites use this port port numbers are not usually specified in a browser except in the rare instances that they re something other than the default Web services consumed by programs as opposed to human users often use alternative ports though The rest of the URL specifies what web page we d like to download from the given host using the given protocol In this case that page is thornton ics32 CodeExamples ExceptionalControlFlow oops py which is a page in the web directory that s under my control Given that information a browser will know just what it needs to do Initiate a socket connection to port 8 on www ics uci edu Use HTTP to request the page thornton ics32 CodeExamples ExceptionalControlFlow oops py Parse the HTTP response and draw the page in the browser window But browsers aren t the only programs that can have conversations using HTTP our Python programs can do it too But we need to know a little bit about HTTP in order to do so effectively Some background on HTTP HTTP HyperText Transfer Protocol is the protocol with which most web traffic on the Internet is transacted Its latest version is HTTP 1 1 though a newer version is under development We ll stick with HTTP 1 1 since it s the predominant version of HTTP used across the web today HTTP is a request response protocol which means that its conversations go something like this Client initiates connection to serverServer accepts connectionClient makes a requestServer sends a response After that single request and response both sides close the connection though there are performance optimizations available that let a client specify that the connection should be kept open if for example the client knows that it needs not just a web page s text but also several images from the same server For our purposes we ll stick with a single request and response per connection Python programs can make these requests and parse these responses but that requires us to know a little bit about the format of each HTTP requests come in a few flavors but the most common of them is called a GET which means that the client would like to get a resource a web page an image etc from the server We may see other alternatives later if we find a need for them A GET request in HTTP 1 1 looks like this GET thornton ics32 CodeExamples ExceptionalControlFlow oops py HTTP 1 1 Host www ics uci edu The first line of a GET request begins with the word GET is followed by the web resource you want to download the part of the URL that follows the protocol and host and finally is followed by HTTP 1 1 as a way to indicate what protocol we expect to be using for the conversation The second line and subsequent lines are what are called headers which allow us to specify a variety of supplementary information that the server can use to figure out how to send us a response In our case we ve included just one a header called Host which specifies the name or IP address of the host we think we re connecting to this is useful in the case that the same machine has multiple names e g more than one web site being served up by the same machine and is generally included in most HTTP requests Additional headers include specifying what browser and what version is being used so for example a server can send back different output for a small sized screen like an iPhone than to a larger sized screen like a laptop or desktop or a variety of performance optimizations that are available Using PuTTY Windows or Telnet Mac connect yourself to www ics uci edu on port 8 and try sending the request above plus a blank line following it so the server will know there are no more headers and you should get back a response very much like this one some details left out here for brevity HTTP 1 1 2 OK Date Wed 4 Feb 2 14 7 56 7 GMT Server Apache 2 2 15 CentOS Content Length 437 Content Type text plain charset UTF 8 oops py ICS 32 Winter 2 15 Code Example if name main f The first line of the response indicates that the server agrees to have an HTTP 1 1 conversation that s the HTTP 1 1 part followed by what s called a status code in this case 2 and a reason phrase in this case OK There are forty or so status codes that are defined as part of the HTTP 1 1 standard the two most common ones are 2 OK which means that everything went as planned the server s way of saying Okay cool here s the web page you asked for 4 4 Not Found which means that the server doesn t have the page that you asked to download If you ve ever seen 4 4 show up in a browser during your travels around the web this is why it s an HTTP status code geekspeak for a web page that doesn t exist The first line of the response is followed by headers just as the first line of the request is The server determines what headers to send and the details there are too numerous to list but I ve included a few of the more interesting ones in the example above Date is the date time at which the response was generated Server specifies what type of server is being run and what version As of this writing the ICS web server is running version 2 2 15 of a server called Apache which is quite common on the web Content Length specifies the length in bytes of the content that will be sent back This allows the client to know when the content has ended Content Type specifies what kind of content is being sent back e g a web page a text file audio video etc Browsers respond to the content type by deciding what to do with the content web pages are shown in the browser video is often displayed in a video plugin or an external media player etc If a browser isn t sure what to do with content it generally just asks you if you want to save the file somewhere on your hard drive After the last header is a blank line followed by the desired content in this case the contents of the file oops py that is linked from one of my code examples For those of you who are interested in the full details of HTTP the specification for it can be found here Don t feel obligated to read through it unless you re interested it s not a part of the course But if you want to get an idea of the complexity level of HTTP and why we should be so quick to want to find a library that implements all of that complexity for us take a quick look through it and note that one of the main authors of the specification Roy Fielding was completing his Ph D here at UCI at the time it was written The urllib request module in the Python standard library Unlike the protocols we ve implemented in this course which had a fairly straightforward sequence of what needed to be sent from client to server and vice versa HTTP is anything but simple It is used for everything from fetching a simple web page implementing the guts of the conversations happening behind the scenes while you use full featured web sites like Gmail and even for allowing non browsers to interact with web data e g programs that can send tweets via Twitter While we could certainly implement an HTTP conversation using the techniques we ve seen so far opening a socket connection to a server s port 8 constructing and sending a GET request parsing the response this is a very complex task In order to do the job right we would need to implement the entire specification which weighs in when printed at 114 pages Happily HTTP support is something so fundamental to the needs of so many programmers many programming language libraries include HTTP support Python is no exception Python s library includes a number of modules that implement different parts of the HTTP specification with the main trick being to understand which module you need in a given circumstance Our job in lecture was simple we just wanted to download the contents of a single web page in a Python program given its URL Your task in Project 3 is similar given the URL to information on the web that your program will need you just want to download and use that information More complex interactions require more complex tools but the interactions we ve needed thus far are the simplest ones so the simplest part of the library will suffice That module is called urllib request The urllib request module has one function that we re interested in urllib request urlopen Looking through its documentation reveals many more details than we need to know if we only want to download a web page using a GET request downloading one page can be done in the interpreter by doing just this import urllib request response urllib request urlopen http www ics uci edu thornton ics32 CodeExamples ExceptionalControlFlow oops py The urlopen function returns an object called an HTTPResponse which provides a few useful attributes and methods the most important of which is the read method which retrieves all of the content from the response i e the contents of the web page you asked for and returns a bytes object containing those contents Continuing the previous example in the interpreter Reading the content of the response i e the data following the headers data response read The data comes back as a bytes object as opposed to a string data b oops py r n r n ICS 32 Winter 2 15 r n Code Example r n r n Once we re done reading from the response we should close it response close We can decode the bytes into a string the same way we ve done before assuming that we know that the data is text and can be decoded this way The only way we can be absolutely sure is to use the information in the HTTP response headers particularly the Content Type header but that s beyond the scope of this example string data data decode encoding utf 8 This will give us a single string containing all of the data string data oops py r n r n ICS 32 Winter 2 15 r n Code Example r n r n We can then split the string into lines using the str splitlines method str split will work too but str splitlines automatically handles the differences in line endings between operating systems e g Windows uses r n while Mac Unix and Linux use n lines string data splitlines And that will give us a list of strings in which each string is one line of text lines oops py ICS 32 Winter 2 15 Code Example The code Below is a link to a short program that asks the user to type a URL as well as a path on their local hard drive then downloads the contents of that URL and saves it into a file at the specified path using the techniques demonstrated above download file py", "_id": "http://www.ics.uci.edu/~thornton/ics32/CodeExamples/URLs/", "title": "ics 32 winter 2015, code example: urls", "html": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2015, Code Example: URLs</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2015 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../CodeExamples\">Code Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2015<br />\r\n   Code Example: Downloading data from the web</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Thus far in this course and the preceding one, you've written Python programs that read data from text files and that exchange data over a network via sockets, which are two big steps that push outward the boundaries of what we can accomplish in Python.  However, there is an elephant in the room, so to speak; if we think about where most of the interesting data on the Internet resides, it's on the web.  <i>Web sites</i> display content and allow human users to interact with web-based data, while <i>web services</i> provide a similar ability to other programs.  In both cases, the same fundamentals we've already seen apply: a connection is initiated by a <i>client</i> connecting to a <i>server</i> (usually on the server's port 80), and a protocol is followed that governs what the conversation looks like.  So if we want to interact with web data &mdash; the simplest example of which is to download the content of a web page &mdash; we need to know enough about that protocol to be able to implement the conversation.</p>\r\n\r\n<p class=\"subtitle\">URLs</p>\r\n\r\n<p>When we use a browser to visit a web page, all we need to do is tell the browser where we want to go and it handles the rest.  The notion of \"where you want to go\" is encapsulated by a <i>URL (Uniform Resource Locator)</i>, which specifies a few things:</p>\r\n\r\n<ul>\r\n  <li>What protocol should be used to download the web page?</li>\r\n  <li>From what host (i.e., an IP address or the name of a machine, like <b>www.ics.uci.edu</b>) should the web page be downloaded?  Occasionally, we also specify the port, when we want it to be something other than the default.</li>\r\n  <li>What page on that machine should be downloaded?</li>\r\n</ul>\r\n\r\n<p>One of the earlier code examples included a link to a short Python module called <b>oops.py</b>.  The complete URL for that link is: <a href=\"http://www.ics.uci.edu/~thornton/ics32/CodeExamples/ExceptionalControlFlow/oops.py\">http://www.ics.uci.edu/~thornton/ics32/CodeExamples/ExceptionalControlFlow/oops.py</a>.  Here's what that URL means:</p>\r\n\r\n<ul>\r\n  <li>The first few characters (preceding the colon) indicate what protocol should be used for the network conversation.  For most web pages, that protocol will be listed as <b>http</b>, which means that we'd like to use the protocol called HTTP (HyperText Transfer Protocol).  Another common alternative is <b>https</b>, which uses HTTP over a secure (encrypted) connection, to make eavesdropping substantially difficult.</li>\r\n  <li>After the colon and the two slashes is the host.  In this case, that host is listed as <b>www.ics.uci.edu</b>, which is the machine on which the ICS web site is hosted.  It is possible also to specify a port, by following the host with a colon and a port number (e.g., <b>www.ics.uci.edu:8080</b>).  The default port number for HTTP traffic is 80, and since most web sites use this port, port numbers are not usually specified in a browser except in the rare instances that they're something other than the default.  Web services (consumed by programs, as opposed to human users) often use alternative ports, though.</li>\r\n  <li>The rest of the URL specifies what web page we'd like to download from the given host using the given protocol.  In this case, that page is <b>/~thornton/ics32/CodeExamples/ExceptionalControlFlow/oops.py</b>, which is a page in the web directory that's under my control.</li>\r\n</ul>\r\n\r\n<p>Given that information, a browser will know just what it needs to do:</p>\r\n\r\n<ul>\r\n  <li>Initiate a socket connection to port 80 on www.ics.uci.edu.</li>\r\n  <li>Use HTTP to request the page <b>/~thornton/ics32/CodeExamples/ExceptionalControlFlow/oops.py</b>.</li>\r\n  <li>Parse the HTTP response and draw the page in the browser window.</li>\r\n</ul>\r\n\r\n<p>But browsers aren't the only programs that can have conversations using HTTP; our Python programs can do it, too.  But we need to know a little bit about HTTP in order to do so effectively.</p>\r\n\r\n<p class=\"subtitle\">Some background on HTTP</p>\r\n\r\n<p><i>HTTP (HyperText Transfer Protocol)</i> is the protocol with which most web traffic on the Internet is transacted.  Its latest version is HTTP/1.1, though a newer version is under development.  We'll stick with HTTP/1.1, since it's the predominant version of HTTP used across the web today.</p>\r\n\r\n<p>HTTP is a <i>request-response protocol</i>, which means that its conversations go something like this:</p>\r\n\r\n<ul>\r\n  <li>Client initiates connection to server</li>\r\n  <li>Server accepts connection</li>\r\n  <li>Client makes a request</li>\r\n  <li>Server sends a response</li>\r\n</ul>\r\n\r\n<p>After that single request and response, both sides close the connection (though there are performance optimizations available that let a client specify that the connection should be kept open if, for example, the client knows that it needs not just a web page's text but also several images from the same server).  For our purposes, we'll stick with a single request and response per connection.</p>\r\n\r\n<p>Python programs can make these requests and parse these responses, but that requires us to know a little bit about the format of each.  HTTP requests come in a few flavors, but the most common of them is called a <i>GET</i>, which means that the client would like to \"get\" a resource (a web page, an image, etc.) from the server.  (We may see other alternatives later if we find a need for them.)  A GET request in HTTP/1.1 looks like this.</p>\r\n\r\n<blockquote><pre>\r\nGET /~thornton/ics32/CodeExamples/ExceptionalControlFlow/oops.py HTTP/1.1\r\nHost: www.ics.uci.edu\r\n</pre></blockquote>\r\n\r\n<p>The first line of a GET request begins with the word <b>GET</b>, is followed by the web resource you want to download (the part of the URL that follows the protocol and host), and finally is followed by <b>HTTP/1.1</b>, as a way to indicate what protocol we expect to be using for the conversation.</p>\r\n\r\n<p>The second line (and subsequent lines) are what are called <i>headers</i>, which allow us to specify a variety of supplementary information that the server can use to figure out how to send us a response.  In our case, we've included just one, a header called <b>Host:</b>, which specifies the name or IP address of the host we think we're connecting to; this is useful in the case that the same machine has multiple names (e.g., more than one web site being served up by the same machine), and is generally included in most HTTP requests.  Additional headers include specifying what browser (and what version) is being used &mdash; so, for example, a server can send back different output for a small-sized screen like an iPhone than to a larger-sized screen like a laptop or desktop &mdash; or a variety of performance optimizations that are available.</p>\r\n\r\n<p>Using PuTTY (Windows) or Telnet (Mac), connect yourself to <b>www.ics.uci.edu</b> on port 80 and try sending the request above (plus a blank line following it, so the server will know there are no more headers) and you should get back a response very much like this one (some details left out here for brevity).</p>\r\n\r\n<blockquote><pre>\r\nHTTP/1.1 200 OK\r\nDate: Wed, 04 Feb 2014 07:56:07 GMT\r\nServer: Apache/2.2.15 (CentOS)\r\n...\r\n...\r\nContent-Length: 437\r\nContent-Type: text/plain; charset=UTF-8\r\n\r\n# oops.py\r\n#\r\n# ICS 32 Winter 2015\r\n# Code Example\r\n...\r\n...\r\nif __name__ == '__main__':\r\n    f()\r\n</pre></blockquote>\r\n\r\n<p>The first line of the response indicates that the server agrees to have an HTTP/1.1 conversation (that's the <b>HTTP/1.1</b> part), followed by what's called a <i>status code</i> (in this case, <b>200</b>) and a <i>reason phrase</i> (in this case, <b>OK</b>).  There are forty or so status codes that are defined as part of the HTTP/1.1 standard; the two most common ones are:</p>\r\n\r\n<ul>\r\n  <li>200 (OK), which means that everything went as planned, the server's way of saying \"Okay, cool, here's the web page you asked for!\"</li>\r\n  <li>404 (Not Found), which means that the server doesn't have the page that you asked to download.  (If you've ever seen \"404\" show up in a browser during your travels around the web, this is why; it's an HTTP status code, \"geekspeak\" for a web page that doesn't exist.)</li>\r\n</ul>\r\n\r\n<p>The first line of the response is followed by <i>headers</i>, just as the first line of the request is.  The server determines what headers to send, and the details there are too numerous to list, but I've included a few of the more interesting ones in the example above:</p>\r\n\r\n<ul>\r\n  <li><b>Date</b> is the date/time at which the response was generated.</li>\r\n  <li><b>Server</b> specifies what type of server is being run and what version.  As of this writing, the ICS web server is running version 2.2.15 of a server called Apache (which is quite common on the web).</li>\r\n  <li><b>Content-Length</b> specifies the length, in bytes, of the content that will be sent back.  This allows the client to know when the content has ended.</li>\r\n  <li><b>Content-Type</b> specifies what kind of content is being sent back (e.g., a web page, a text file, audio, video, etc.).  Browsers respond to the content type by deciding what to do with the content: web pages are shown in the browser, video is often displayed in a video plugin or an external media player, etc.  If a browser isn't sure what to do with content, it generally just asks you if you want to save the file somewhere on your hard drive.</li>\r\n</ul>\r\n\r\n<p>After the last header is a blank line, followed by the desired content &mdash; in this case, the contents of the file <b>oops.py</b> that is linked from one of my code examples.</p>\r\n\r\n<p>For those of you who are interested in the full details of HTTP, the <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616.html\">specification</a> for it can be found here.  Don't feel obligated to read through it unless you're interested; it's not a part of the course.  But if you want to get an idea of the complexity level of HTTP, and why we should be so quick to want to find a library that implements all of that complexity for us, take a quick look through it (and note that one of the main authors of the specification, Roy Fielding, was completing his Ph.D. here at UCI at the time it was written).</p>\r\n\r\n<p class=\"subtitle\">The <b>urllib.request</b> module in the Python standard library</p>\r\n\r\n<p>Unlike the protocols we've implemented in this course, which had a fairly straightforward sequence of what needed to be sent from client to server and vice versa, HTTP is anything but simple.  It is used for everything from fetching a simple web page, implementing the \"guts\" of the conversations happening behind the scenes while you use full-featured web sites like Gmail, and even for allowing non-browsers to interact with web data (e.g., programs that can send tweets via Twitter).  While we could certainly implement an HTTP conversation using the techniques we've seen so far &mdash; opening a socket connection to a server's port 80, constructing and sending a GET request, parsing the response &mdash; this is a very complex task.  In order to do the job right, we would need to implement the entire specification, which weighs in (when printed) at 114 pages.</p>\r\n\r\n<p>Happily, HTTP support is something so fundamental to the needs of so many programmers, many programming language libraries include HTTP support; Python is no exception.  Python's library includes a number of modules that implement different parts of the HTTP specification, with the main trick being to understand which module you need in a given circumstance.</p>\r\n\r\n<p>Our job in lecture was simple: we just wanted to download the contents of a single web page in a Python program, given its URL.  Your task in <a href=\"../../ProjectGuide/Project3\">Project #3</a> is similar: given the URL to information on the web that your program will need, you just want to download and use that information.  More complex interactions require more complex tools, but the interactions we've needed thus far are the simplest ones, so the simplest part of the library will suffice.  That module is called <b>urllib.request</b>.</p>\r\n\r\n<p>The <b>urllib.request</b> module has one function that we're interested in: <b>urllib.request.urlopen()</b>.  Looking through its documentation reveals many more details than we need to know if we only want to download a web page using a GET request; downloading one page can be done in the interpreter by doing just this:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; import urllib.request\r\n&gt;&gt;&gt; response = urllib.request.urlopen('http://www.ics.uci.edu/~thornton/ics32/CodeExamples/ExceptionalControlFlow/oops.py')\r\n</pre></blockquote>\r\n\r\n<p>The <b>urlopen()</b> function returns an object called an <b>HTTPResponse</b>, which provides a few useful attributes and methods, the most important of which is the <b>read()</b> method, which retrieves all of the content from the response (i.e., the contents of the web page you asked for) and returns a <b>bytes</b> object containing those contents.  Continuing the previous example in the interpreter:</p>\r\n\r\n<blockquote><pre>\r\n<i>Reading the content of the response (i.e., the data following the headers)</i>\r\n&gt;&gt;&gt; data = response.read()\r\n\r\n<i>The data comes back as a <b>bytes</b> object, as opposed to a string</i>\r\n&gt;&gt;&gt; data\r\nb\"# oops.py\\r\\n#\\r\\n# ICS 32 Winter 2015\\r\\n# Code Example\\r\\n#\\r\\n.......\"\r\n\r\n<i>Once we're done reading from the response, we should close it</i>\r\n&gt;&gt;&gt; response.close()\r\n\r\n<i>We can decode the bytes into a string the same way we've done before\r\nassuming that we know that the data is text and can be decoded this way.\r\nThe only way we can be absolutely sure is to use the information in the\r\nHTTP response headers, particularly the <b>Content-Type</b> header, but\r\nthat's beyond the scope of this example.</i>\r\n&gt;&gt;&gt; string_data = data.decode(encoding = 'utf-8')\r\n\r\n<i>This will give us a single string containing all of the data</i>\r\n&gt;&gt;&gt; string_data\r\n\"# oops.py\\r\\n#\\r\\n# ICS 32 Winter 2015\\r\\n# Code Example\\r\\n#\\r\\n.......\"\r\n\r\n<i>We can then split the string into lines using the <b>str.splitlines()</b> method.\r\n<b>str.split()</b> will work, too, but <b>str.splitlines()</b> automatically handles the\r\ndifferences in line endings between operating systems (e.g., Windows uses\r\n'\\r\\n', while Mac, Unix, and Linux use '\\n').</i>\r\n&gt;&gt;&gt; lines = string_data.splitlines()\r\n\r\n<i>And that will give us a list of strings, in which each string is one line of text</i>\r\n&gt;&gt;&gt; lines\r\n['# oops.py', '#', '# ICS 32 Winter 2015', '# Code Example', '#', .......]\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>Below is a link to a short program that asks the user to type a URL, as well as a path on their local hard drive, then downloads the contents of that URL and saves it into a file at the specified path, using the techniques demonstrated above.</p>\r\n\r\n<ul>\r\n  <li><a href=\"download_file.py\">download_file.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "id": 26823.0}