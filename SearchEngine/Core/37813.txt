{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 6Geometric Object Generators Susan Hert Michael Hoffmann Lutz Kettner and Sven Sch nherr A variety of generators for geometric objects are provided in CGAL They are useful as synthetic test data sets e g for testing algorithms on degenerate object sets and for performance analysis Two kinds of point generators are provided first random point generators and second deterministic point generators Most random point generators and a few deterministic point generators are provided as input iterators The input iterators model an infinite sequence of points The function CGAL copy n can be used to copy a finite sequence see Section The iterator adaptor Counting iterator can be used to create finite iterator ranges see Section Other generators are provided as functions that write to output iterators Further functions add degeneracies or random perturbations In 2D we provide input iterators to generate random points in a disc Random points in disc 2 in a square Random points in square 2 on a circle Random points on circle 2 on a segment Random points on segment and on a square Random points on square 2 For generating grid points we provide three functions points on segment 2 points on square grid 2 that write to output iterators and an input iterator Points on segment 2 For 3D points input iterators are provided for random points uniformly distributed in a sphere Random points in sphere 3 or cube Random points in cube 3 or on the boundary of a sphere Random points on sphere 3 For generating 3D grid points we provide the function points on cube grid 3 that writes to an output iterator We also provide two functions for generating more complex geometric objects The function random convex set 2 computes a random convex planar point set of a given size where the points are drawn from a specific domain and random polygon 2 generates a random simple polygon from points drawn from a specific domain Random Perturbations Degenerate input sets like grid points can be randomly perturbed by a small amount to produce quasi degenerate test sets This challenges numerical stability of algorithms using inexact arithmetic and exact predicates to compute the sign of expressions slightly off from zero For this hte function perturb points 2 is provided Adding Degeneracies For a given point set certain kinds of degeneracies can be produced by adding new points The random selection function is useful for generating multiple copies of identical points The function random collinear points 2 adds collinearities to a point set Support Functions and Classes for Generators The function random selection chooses n items at random from a random access iterator range which is useful to produce degenerate input data sets with multiple entries of identical items 6 1 Example Generating Degenerate Point Sets We want to generate a test set of 1 points where 6 are chosen randomly in a small disc 2 are from a larger grid 1 are duplicates points and 1 collinear points A random shuffle removes the construction order from the test set See Figure for the example output file examples Generator generators example1 C include CGAL Simple cartesian h include cassert include vector include algorithm include CGAL point generators 2 h include CGAL copy n h include CGAL random selection h using namespace CGAL typedef Simple cartesian double R typedef R Point 2 Point typedef Creator uniform 2 double Point Creator typedef std vector Point Vector int main Create test point set Prepare a vector for 1 points Vector points points reserve 1 Create 6 points within a disc of radius 15 Random points in disc 2 Point Creator g 15 CGAL copy n g 6 std back inserter points Create 2 points from a 15 x 15 grid points on square grid 2 25 2 std back inserter points Creator Select 1 points randomly and append them at the end of the current vector of points random selection points begin points end 1 std back inserter points Create 1 points that are collinear to two randomly chosen points and append them to the current vector of points random collinear points 2 points begin points end 1 std back inserter points Check that we have really created 1 points assert points size 1 Use a random permutation to hide the creation history of the point set std random shuffle points begin points end default random Check range of values for Vector iterator i points begin i points end i assert i x 251 assert i x 251 assert i y 251 assert i y 251 return Figure Output of example program for point generators 6 2 Example Generating Grid Points The second example demonstrates the point generators with integer points Arithmetic with doubles is sufficient to produce regular integer grids See Figure for the example output file examples Generator generators example2 C include CGAL Simple cartesian h include cassert include vector include algorithm include CGAL point generators 2 h include CGAL copy n h using namespace CGAL typedef Simple cartesian int R typedef R Point 2 Point typedef Creator uniform 2 int Point Creator int main Create test point set Prepare a vector for 4 points std vector Point points points reserve 4 Create 25 points from a 16 x 16 grid Note that the double arithmetic is sufficient to produce exact integer grid points The distance between neighbors is 34 pixel 51 15 points on square grid 2 255 25 std back inserter points Creator Lower left corner assert points x 255 assert points y 255 Upper right corner Note that 6 points are missing to fill the grid assert points 249 x 255 6 34 assert points 249 y 255 Create 25 points within a disc of radius 15 Random points in disc 2 Point Creator g 15 CGAL copy n g 25 std back inserter points Check that we have really created 5 points assert points size 5 return Figure Output of example program for point generators working on integer points 6 3 Examples Generating Segments The following two examples illustrate the use of the generic functions from Section like Join input iterator 2 to generate composed objects from other generators here two dimensional segments from two point generators We want to generate a test set of 2 segments where one endpoint is chosen randomly from a horizontal segment of length 2 and the other endpoint is chosen randomly from a circle of radius 25 See Figure for the example output file examples Generator Segment generator example1 C include CGAL Simple cartesian h include cassert include vector include algorithm include CGAL Point 2 h include CGAL Segment 2 h include CGAL point generators 2 h include CGAL function objects h include CGAL Join input iterator h include CGAL copy n h using namespace CGAL typedef Simple cartesian double R typedef R Point 2 Point typedef Creator uniform 2 double Point Pt creator typedef R Segment 2 Segment typedef std vector Segment Vector int main Create test segment set Prepare a vector for 2 segments Vector segs segs reserve 2 Prepare point generator for the horizontal segment length 2 typedef Random points on segment 2 Point Pt creator P1 P1 p1 Point 1 Point 1 Prepare point generator for random points on circle radius 25 typedef Random points on circle 2 Point Pt creator P2 P2 p2 25 Create 2 segments typedef Creator uniform 2 Point Segment Seg creator typedef Join input iterator 2 P1 P2 Seg creator Seg iterator Seg iterator g p1 p2 CGAL copy n g 2 std back inserter segs assert segs size 2 for Vector iterator i segs begin i segs end i assert i source x 1 assert i source x 1 assert i source y assert i target x i target x i target y i target y 251 251 assert i target x i target x i target y i target y 249 249 return Figure Output of example program for the generic segment generator The second example generates a regular structure of 1 segments see Figure for the example output It uses the Points on segment 2 iterator Join input iterator 2 and Counting iterator to avoid any intermediate storage of the generated objects until they are used which in this example means copied to a window stream file examples Generator Segment generator example2 C CGAL example program for the generic segment generator using precomputed point locations include CGAL Simple cartesian h include algorithm include vector include CGAL point generators 2 h include CGAL function objects h include CGAL Join input iterator h include CGAL Counting iterator h using namespace CGAL typedef Simple cartesian double R typedef R Point 2 Point typedef R Segment 2 Segment typedef Points on segment 2 Point PG typedef Creator uniform 2 Point Segment Creator typedef Join input iterator 2 PG PG Creator Segm iterator typedef Counting iterator Segm iterator Segment Count iterator typedef std vector Segment Vector int main Create test segment set Prepare a vector for 1 segments Vector segs segs reserve 1 A horizontal like fan PG p1 Point 25 5 Point 25 5 5 Point generator PG p2 Point 25 25 Point 25 25 5 Segm iterator t1 p1 p2 Segment generator Count iterator t1 begin t1 Finite range Count iterator t1 end 5 std copy t1 begin t1 end std back inserter segs A vertical like fan PG p3 Point 5 25 Point 5 25 5 PG p4 Point 25 25 Point 25 25 5 Segm iterator t2 p3 p4 Count iterator t2 begin t2 Count iterator t2 end 5 std copy t2 begin t2 end std back inserter segs CGAL assertion segs size 1 for Vector iterator i segs begin i segs end i CGAL assertion i source x 25 CGAL assertion i source x 25 CGAL assertion i source y 25 CGAL assertion i source y 25 CGAL assertion i target x 25 CGAL assertion i target x 25 CGAL assertion i target y 25 CGAL assertion i target y 25 return Figure Output of example program for the generic segment generator using pre computed point locations Next chapter Geometric Object Generators Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Generator/Chapter_main.html", "title": "geometric object generators", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Generator/main.tex' -->\n<html> <head>  \n<title>Geometric Object Generators</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_6\"></a>\n  \n<h1>Chapter 6<BR>Geometric Object Generators</h1>\n\n<A NAME=\"chapterGenerators\"></A>\n\n<EM>Susan Hert, Michael Hoffmann, Lutz Kettner, and Sven Sch&ouml;nherr</EM><BR>\n\n\n<P>\n\nA variety of generators for geometric objects are provided in C<SMALL>GAL</SMALL>.\nThey are useful as synthetic test data sets, e.g.&nbsp;for testing\nalgorithms on degenerate object sets and for performance analysis.\n<P>\n\nTwo kinds of point generators are provided: first, random point\ngenerators and second deterministic point generators. Most random\npoint generators and a few deterministic point generators are provided\nas input iterators.  The input iterators model an infinite sequence of\npoints. The function <I><A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>()</I> can be used to copy a\nfinite sequence; see Section&nbsp;<A HREF=\"../STL_Extension_ref/Function_copy_n.html#sectionCopyN\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. The iterator adaptor\n<I><A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1458\">Counting_iterator</A></I> can be used to create finite iterator\nranges; see Section&nbsp;<A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#sectionCountingIterator\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nOther generators are provided as functions that write to output\niterators. Further functions add degeneracies or random perturbations.\n<P>\n\n<A NAME=\"Index_anchor_1522\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1523\"></A> \n\n<A NAME=\"Index_anchor_1524\"></A> \n\n   \n\nIn 2D, we provide input iterators to generate random points in a disc\n(<I><A HREF=\"../Generator_ref/Class_Random_points_in_disc_2.html#Cross_link_anchor_1696\">Random_points_in_disc_2</A></I>), \nin a <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> (<I><A HREF=\"../Generator_ref/Class_Random_points_in_square_2.html#Cross_link_anchor_1700\">Random_points_in_square_2</A></I>),\non a circle (<I><A HREF=\"../Generator_ref/Class_Random_points_on_circle_2.html#Cross_link_anchor_1702\">Random_points_on_circle_2</A></I>), \non a segment (<I>Random_points_on_segment</I>),\nand on a <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> (<I><A HREF=\"../Generator_ref/Class_Random_points_on_square_2.html#Cross_link_anchor_1708\">Random_points_on_square_2</A></I>).\nFor generating grid points we provide three functions,\n<I><A HREF=\"../Generator_ref/Function_points_on_segment_2.html#Cross_link_anchor_1673\">points_on_segment_2</A></I>,\n<I><A HREF=\"../Generator_ref/Function_points_on_square_grid_2.html#Cross_link_anchor_1677\">points_on_square_grid_2</A></I> that write to output iterators and\nan input iterator <I><A HREF=\"../Generator_ref/Class_Points_on_segment_2.html#Cross_link_anchor_1675\">Points_on_segment_2</A></I>.\n<P>\n\n<A NAME=\"Index_anchor_1525\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1526\"></A> \n\n<A NAME=\"Index_anchor_1527\"></A> \n\n   \n\nFor 3D points, input iterators are provided for random points uniformly \ndistributed in a sphere (<I><A HREF=\"../Generator_ref/Class_Random_points_in_sphere_3.html#Cross_link_anchor_1698\">Random_points_in_sphere_3</A></I>)\nor cube (<I><A HREF=\"../Generator_ref/Class_Random_points_in_cube_3.html#Cross_link_anchor_1694\">Random_points_in_cube_3</A></I>) or on the boundary of a sphere\n(<I><A HREF=\"../Generator_ref/Class_Random_points_on_sphere_3.html#Cross_link_anchor_1706\">Random_points_on_sphere_3</A></I>).\nFor generating 3D grid points, we provide the function \n<I><A HREF=\"../Generator_ref/Function_points_on_cube_grid_3.html#Cross_link_anchor_1679\">points_on_cube_grid_3</A></I> that writes to\nan output iterator.\n<P>\n\nWe also provide two functions for generating more complex geometric objects.\nThe function <I><A HREF=\"../Generator_ref/Function_random_convex_set_2.html#Cross_link_anchor_1684\">random_convex_set_2</A></I> computes a random convex planar\npoint set of a given size where the points are drawn from a specific\ndomain and <I><A HREF=\"../Generator_ref/Function_random_polygon_2.html#Cross_link_anchor_1686\">random_polygon_2</A></I> generates a random simple polygon from\npoints drawn from a specific domain.\n<P>\n\n<b>Random Perturbations</b>\n\n \n     \n<A NAME=\"Index_anchor_1528\"></A>\n<P>\n\nDegenerate input sets like grid points can be randomly perturbed by a\nsmall amount to produce <I>quasi</I>-degenerate test sets. This\nchallenges numerical stability of algorithms using inexact arithmetic and\nexact predicates to compute the <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of expressions slightly off from zero.\nFor this hte function <I><A HREF=\"../Generator_ref/Function_perturb_points_2.html#Cross_link_anchor_1671\">perturb_points_2</A></I> is provided.\n<P>\n\n<b>Adding Degeneracies</b>\n\n   \n     \n     \n<A NAME=\"Index_anchor_1529\"></A>\n<P>\n\nFor a given point set certain kinds of degeneracies can be produced\nby adding new points. The <I><A HREF=\"../Generator_ref/Function_random_selection.html#Cross_link_anchor_1688\">random_selection</A>()</I> function is\nuseful for generating multiple copies of identical points.\nThe function <I><A HREF=\"../Generator_ref/Function_random_collinear_points_2.html#Cross_link_anchor_1682\">random_collinear_points_2</A>()</I> adds collinearities to\na point set.\n<P>\n\n<b>Support Functions and Classes for Generators</b>\n<P>\n\nThe function <I><A HREF=\"../Generator_ref/Function_random_selection.html#Cross_link_anchor_1688\">random_selection</A></I> chooses <MATH><I>n</I></MATH> items at random from a random\naccess iterator range which is useful to produce degenerate input data\nsets with multiple entries of identical items.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>6.1&nbsp;&nbsp;&nbsp;Example Generating Degenerate Point Sets</h2>\n<P>\n\nWe want to generate a test set of 1000 points, where 60% are chosen\nrandomly in a small disc, 20% are from a larger grid, 10% are duplicates\npoints, and 10% <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A> points. A random shuffle removes the\nconstruction order from the test set. See Figure <A HREF=\"#PointGenerators\">\n  <IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference arrow\" WIDTH=\"10\"\n  HEIGHT=\"10\"></A> for the example output.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Generator/generators_example1.C          \n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Generator_ref/Function_random_selection.html#Cross_link_anchor_1688\">random_selection</A>.h&gt;\n\nusing namespace CGAL;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;double&gt;         R;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                       Point;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1566\">Creator_uniform_2</A>&lt;double,Point&gt;  Creator;\ntypedef std::vector&lt;Point&gt;               <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>;\n\nint main() {\n    // Create test point set. Prepare a vector for 1000 points.\n    <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A> points;\n    points.reserve(1000);\n\n    // Create 600 points within a disc of radius 150.\n    <A HREF=\"../Generator_ref/Class_Random_points_in_disc_2.html#Cross_link_anchor_1696\">Random_points_in_disc_2</A>&lt;Point,Creator&gt; g( 150.0);\n    <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( g, 600, std::back_inserter(points));\n\n    // Create 200 points from a 15 x 15 grid.\n    <A HREF=\"../Generator_ref/Function_points_on_square_grid_2.html#Cross_link_anchor_1677\">points_on_square_grid_2</A>( 250.0, 200, std::back_inserter(points),Creator());\n\n    // Select 100 points randomly and append them at the end of\n    // the current vector of points.\n    <A HREF=\"../Generator_ref/Function_random_selection.html#Cross_link_anchor_1688\">random_selection</A>( points.begin(), points.end(), 100, \n\t\t      std::back_inserter(points));\n\n    // Create 100 points that are <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A> to two randomly chosen\n    // points and append them to the current vector of points.\n    <A HREF=\"../Generator_ref/Function_random_collinear_points_2.html#Cross_link_anchor_1682\">random_collinear_points_2</A>( points.begin(), points.end(), 100,\n\t\t\t       std::back_inserter( points));\n\n    // Check that we have really created 1000 points.\n    assert( points.size() == 1000);\n\n    // Use a random permutation to hide the creation history\n    // of the point set.\n    std::random_shuffle( points.begin(), points.end(), default_random);\n\n    // Check range of values.\n    for ( <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>::iterator i = points.begin(); i != points.end(); i++){\n\tassert( i-&gt;x() &lt;=  251);\n\tassert( i-&gt;x() &gt;= -251);\n\tassert( i-&gt;y() &lt;=  251);\n\tassert( i-&gt;y() &gt;= -251);\n    }\n    return 0;\n}\n</pre>\n<P>\n\n<A NAME=\"PointGenerators\">\n  <TABLE><TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=60%>\n    <A HREF=\"./generators_prog1.gif\">Figure:</A>\n    Output of example program for point generators.\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=5% NOWRAP>\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=35% NOWRAP>\n    <A HREF=\"./generators_prog1.gif\">\n        <img src=\"./generators_prog1_small.gif\" \n             alt=\"Point Generator Example Output\"></A>\n  </TD></TR></TABLE>\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>6.2&nbsp;&nbsp;&nbsp;Example Generating Grid Points</h2>\n<P>\n\nThe second example demonstrates the point generators with integer\npoints. Arithmetic with <I>double</I>s is sufficient to produce\nregular integer grids. See Figure \n  <A HREF=\"#IntegerPointGenerators\">\n  <IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference arrow\" WIDTH=\"10\"\n  HEIGHT=\"10\"></A>\nfor the example output.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Generator/generators_example2.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n\nusing namespace CGAL;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;int&gt;         R;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                    Point;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1566\">Creator_uniform_2</A>&lt;int,Point&gt;  Creator;\n\nint main() {\n    // Create test point set. Prepare a vector for 400 points.\n    std::vector&lt;Point&gt; points;\n    points.reserve(400);\n\n    // Create 250 points from a 16 x 16 grid. Note that the double\n    // arithmetic _is_ sufficient to produce exact integer grid points.\n    // The distance between neighbors is 34 pixel = 510 / 15.\n    <A HREF=\"../Generator_ref/Function_points_on_square_grid_2.html#Cross_link_anchor_1677\">points_on_square_grid_2</A>( 255.0, 250, std::back_inserter(points),Creator());\n\n    // Lower, left corner.\n    assert( points[0].x() == -255);\n    assert( points[0].y() == -255);\n\n    // Upper, right corner. Note that 6 points are missing to fill the grid.\n    assert( points[249].x() == 255 - 6 * 34);\n    assert( points[249].y() == 255);\n\n    // Create 250 points within a disc of radius 150.\n    <A HREF=\"../Generator_ref/Class_Random_points_in_disc_2.html#Cross_link_anchor_1696\">Random_points_in_disc_2</A>&lt;Point,Creator&gt; g( 150.0);\n    <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( g, 250, std::back_inserter(points));\n\n    // Check that we have really created 500 points.\n    assert( points.size() == 500);\n    return 0;\n}\n</pre>\n<P>\n\n<A NAME=\"IntegerPointGenerators\">\n  <TABLE><TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=60%>\n    <A HREF=\"./generators_prog2.gif\">Figure:</A>\n        Output of example program for point generators working\n        on integer points.\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=5% NOWRAP>\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=35% NOWRAP>\n    <A HREF=\"./generators_prog2.gif\">\n        <img src=\"./generators_prog2_small.gif\" \n             alt=\"Integer Point Generator Example Output\"></A>\n  </TD></TR></TABLE>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>6.3&nbsp;&nbsp;&nbsp;Examples Generating Segments</h2>\n\n<A NAME=\"sec:segment_example\"></A>\n<P>\n\nThe following two examples illustrate the use of the generic functions\nfrom Section&nbsp;<A HREF=\"../STL_Extension_ref/Function_predecessor.html#sectionGenericFunctions\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> like\n<I>Join_input_iterator_2</I> to generate \ncomposed objects from other\ngenerators - here two-dimensional segments from two point generators.\n<P>\n\nWe want to generate a test set of 200 segments, where one endpoint is\nchosen randomly from a horizontal segment of length 200, and the other\nendpoint is chosen randomly from a circle of radius 250. See\nFigure <A\n  HREF=\"#SegmentGenerator\"> <IMG SRC=\"cc_ref_up_arrow.gif\"\n  ALT=\"reference arrow\" WIDTH=\"10\" HEIGHT=\"10\"></A> for the example\noutput.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Generator/Segment_generator_example1.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/function_objects.h&gt;\n#include &lt;CGAL/Join_input_iterator.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1446\">copy_n</A>.h&gt;\n\nusing namespace CGAL;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;double&gt;         R;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                       Point;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1566\">Creator_uniform_2</A>&lt;double,Point&gt;  Pt_creator;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>                     Segment;\ntypedef std::vector&lt;Segment&gt;             <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>;\n\n\nint main() {\n    // Create test segment set. Prepare a vector for 200 segments.\n    <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A> segs;\n    segs.reserve(200);\n\n    // Prepare point generator for the horizontal segment, length 200.\n    typedef  <A HREF=\"../Generator_ref/Class_Random_points_on_segment_2.html#Cross_link_anchor_1704\">Random_points_on_segment_2</A>&lt;Point,Pt_creator&gt;  P1;\n    P1 p1( Point(-100,0), Point(100,0));\n\n    // Prepare point generator for random points on circle, radius 250.\n    typedef  <A HREF=\"../Generator_ref/Class_Random_points_on_circle_2.html#Cross_link_anchor_1702\">Random_points_on_circle_2</A>&lt;Point,Pt_creator&gt;  P2;\n    P2 p2( 250);\n\n    // Create 200 segments.\n    typedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1566\">Creator_uniform_2</A>&lt; Point, Segment&gt; Seg_creator;\n    typedef Join_input_iterator_2&lt; P1, P2, Seg_creator&gt; Seg_iterator;\n    Seg_iterator g( p1, p2);\n    <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( g, 200, std::back_inserter(segs));\n\n    assert( segs.size() == 200);\n    for ( <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>::iterator i = segs.begin(); i != segs.end(); i++){\n        assert( i-&gt;source().x() &lt;=  100);\n        assert( i-&gt;source().x() &gt;= -100);\n        assert( i-&gt;source().y() ==    0);\n        assert( i-&gt;target().x() * i-&gt;target().x() + \n                i-&gt;target().y() * i-&gt;target().y() &lt;=  251*251);\n        assert( i-&gt;target().x() * i-&gt;target().x() +\n                i-&gt;target().y() * i-&gt;target().y() &gt;=  249*249);\n    }\n    return 0;\n}\n</pre>\n<P>\n\n<A NAME=\"SegmentGenerator\">\n  <TABLE><TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=60%>\n    <A HREF=\"./Segment_generator_prog1.gif\">Figure:</A>\n    Output of example program for the generic segment generator.\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=5% NOWRAP>\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=35% NOWRAP>\n    <A HREF=\"./Segment_generator_prog1.gif\">\n        <img src=\"./Segment_generator_prog1_small.gif\" \n             alt=\"Segment Generator Example Output\"></A>\n  </TD></TR></TABLE>\n<P>\n\nThe second example generates a regular structure of 100 segments; see \nFigure <A\n  HREF=\"#SegmentGeneratorFan\"> <IMG SRC=\"cc_ref_up_arrow.gif\"\n  ALT=\"reference arrow\" WIDTH=\"10\" HEIGHT=\"10\"></A> for the example\noutput. It uses the <I><A HREF=\"../Generator_ref/Class_Points_on_segment_2.html#Cross_link_anchor_1675\">Points_on_segment_2</A></I> iterator,\n<I>Join_input_iterator_2</I>\nand <I><A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1458\">Counting_iterator</A></I> to avoid any intermediate storage of the generated objects until they are\nused, which in this example means copied to a window stream.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Generator/Segment_generator_example2.C\n\n// CGAL example program for the generic segment generator\n// using precomputed point locations.\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/function_objects.h&gt;\n#include &lt;CGAL/Join_input_iterator.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1458\">Counting_iterator</A>.h&gt;\n\nusing namespace CGAL;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;double&gt;                  R;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                                Point;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A>                              Segment;\ntypedef <A HREF=\"../Generator_ref/Class_Points_on_segment_2.html#Cross_link_anchor_1675\">Points_on_segment_2</A>&lt;Point&gt;                PG;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1566\">Creator_uniform_2</A>&lt; Point, Segment&gt;        Creator;\ntypedef Join_input_iterator_2&lt; PG, PG, Creator&gt;   Segm_iterator;\ntypedef <A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1458\">Counting_iterator</A>&lt;Segm_iterator,Segment&gt;  Count_iterator;\ntypedef std::vector&lt;Segment&gt;                      <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>;\n\nint main() {\n    // Create test segment set. Prepare a vector for 100 segments.\n    <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A> segs;\n    segs.reserve(100);\n\n    // A horizontal like fan.\n    PG p1( Point(-250, -50), Point(-250, 50),50);   // Point generator.\n    PG p2( Point( 250,-250), Point( 250,250),50);\n    Segm_iterator  t1( p1, p2);                     // Segment generator.\n    Count_iterator t1_begin( t1);                   // Finite range.\n    Count_iterator t1_end( 50);\n    std::copy( t1_begin, t1_end, std::back_inserter(segs));\n\n    // A vertical like fan.\n    PG p3( Point( -50,-250), Point(  50,-250),50);\n    PG p4( Point(-250, 250), Point( 250, 250),50);\n    Segm_iterator  t2( p3, p4);\n    Count_iterator t2_begin( t2);\n    Count_iterator t2_end( 50);\n    std::copy( t2_begin, t2_end, std::back_inserter(segs));\n\n    CGAL_assertion( segs.size() == 100);\n    for ( <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>::iterator i = segs.begin(); i != segs.end(); i++){\n\tCGAL_assertion( i-&gt;source().x() &lt;=  250);\n\tCGAL_assertion( i-&gt;source().x() &gt;= -250);\n\tCGAL_assertion( i-&gt;source().y() &lt;=  250);\n\tCGAL_assertion( i-&gt;source().y() &gt;= -250);\n\tCGAL_assertion( i-&gt;target().x() &lt;=  250);\n\tCGAL_assertion( i-&gt;target().x() &gt;= -250);\n\tCGAL_assertion( i-&gt;target().y() &lt;=  250);\n\tCGAL_assertion( i-&gt;target().y() &gt;= -250);\n    }\n    return 0;\n}\n\n\n</pre>\n<P>\n\n<A NAME=\"SegmentGeneratorFan\">\n  <TABLE><TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=60%>\n    <A HREF=\"./Segment_generator_prog2.gif\">Figure:</A>\n    Output of example program for the generic segment generator using\n    pre-computed point locations.\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=5% NOWRAP>\n  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=35% NOWRAP>\n    <A HREF=\"./Segment_generator_prog2.gif\">\n        <img src=\"./Segment_generator_prog2_small.gif\" \n             alt=\"Segment Generator Example Output 2\"></A>\n  </TD></TR></TABLE>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Generator_ref/Chapter_intro.html\">Geometric Object Generators</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_6!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 37813.0}