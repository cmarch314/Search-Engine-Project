{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Min ellipse 2 Traits Definition An object of the class Min ellipse 2 Traits is the unique ellipse of smallest area enclosing a finite multi set of points in two dimensional euclidean space 2 For a point set P we denote by me P the smallest ellipse that contains all points of P Note that me P can be degenerate i e me P if P me P p if P p and me P 1 l p l q if P p q An inclusion minimal subset S of P with me S me P is called a support set the points in S are the support points A support set has size at most five and all its points lie on the boundary of me P In general neither the support set nor its size are necessarily unique The underlying algorithm can cope with all kinds of input e g P may be empty or points may occur more than once The algorithm computes a support set S which remains fixed until the next insert or clear operation include CGAL Min ellipse 2 h Requirements The template parameter Traits is a model for MinEllipse2Traits We provide the model CGAL Min ellipse 2 traits 2 K using the two dimensional CGAL kernel Types Min ellipse 2 Traits Point Typedef to Traits Point Min ellipse 2 Traits Ellipse Typedef to Traits Ellipse If you are using the predefined traits class CGAL Min ellipse 2 traits 2 K you can access the coefficients of the ellipse see the documentation of CGAL Min ellipse 2 traits 2 K and the example below Min ellipse 2 Traits Point iterator Non mutable model of the STL concept BidirectionalIterator with value type Point Used to access the points of the smallest enclosing ellipse Min ellipse 2 Traits Support point iterator Non mutable model of the STL concept RandomAccessIterator with value type Point Used to access the support points of the smallest enclosing ellipse Creation A Min ellipse 2 Traits object can be created from an arbitrary point set P and by specialized construction methods expecting no one two three four or five points as arguments The latter methods can be useful for reconstructing me P from a given support set S of P template class InputIterator Min ellipse 2 Traits min ellipse InputIterator first InputIterator last bool randomize Random random default random Traits traits Traits initializes min ellipse to me P with P being the set of points in the range first last If randomize is true a random permutation of P is computed in advance using the random numbers generator random Usually this will not be necessary however the algorithm s efficiency depends on the order in which the points are processed and a bad order might lead to extremely poor performance see example below Requirement The value type of first and last is Point Min ellipse 2 Traits min ellipse Traits traits Traits creates a variable min ellipse of type Min ellipse 2 Traits It is initialized to me the empty set Postcondition min ellipse is empty true Min ellipse 2 Traits min ellipse Point p Traits traits Traits initializes min ellipse to me p the set p Postcondition min ellipse is degenerate true Min ellipse 2 Traits min ellipse Point p Point q Traits traits Traits initializes min ellipse to me p q the set 1 l p l q Postcondition min ellipse is degenerate true Min ellipse 2 Traits min ellipse Point p1 Point p2 Point p3 Traits traits Traits initializes min ellipse to me p1 p2 p3 Min ellipse 2 Traits min ellipse Point p1 Point p2 Point p3 Point p4 Traits traits Traits initializes min ellipse to me p1 p2 p3 p4 Min ellipse 2 Traits min ellipse Point p1 Point p2 Point p3 Point p4 Point p5 Traits traits Traits initializes min ellipse to me p1 p2 p3 p4 p5 Access Functions int min ellipse number of points returns the number of points of min ellipse i e P int min ellipse number of support points returns the number of support points of min ellipse i e S Point iterator min ellipse points begin returns an iterator referring to the first point of min ellipse Point iterator min ellipse points end returns the corresponding past the end iterator Support point iterator min ellipse support points begin returns an iterator referring to the first support point of min ellipse Support point iterator min ellipse support points end returns the corresponding past the end iterator Point min ellipse support point int i returns the i th support point of min ellipse Between two modifying operations see below any call to min ellipse support point i with the same i returns the same point Precondition i min ellipse number of support points Ellipse min ellipse ellipse returns the current ellipse of min ellipse Predicates By definition an empty Min ellipse 2 Traits has no boundary and no bounded side i e its unbounded side equals the whole space 2 CGAL Bounded side min ellipse bounded side Point p returns CGAL ON BOUNDED SIDE CGAL ON BOUNDARY or CGAL ON UNBOUNDED SIDE iff p lies properly inside on the boundary of or properly outside of min ellipse resp bool min ellipse has on bounded side Point p returns true iff p lies properly inside min ellipse bool min ellipse has on boundary Point p returns true iff p lies on the boundary of min ellipse bool min ellipse has on unbounded side Point p returns true iff p lies properly outside of min ellipse bool min ellipse is empty returns true iff min ellipse is empty this implies degeneracy bool min ellipse is degenerate returns true iff min ellipse is degenerate i e if min ellipse is empty equal to a single point or equal to a segment equivalently if the number of support points is less than 3 Modifiers New points can be added to an existing min ellipse allowing to build me P incrementally e g if P is not known in advance Compared to the direct creation of me P this is not much slower because the construction method is incremental itself void min ellipse insert Point p inserts p into min ellipse and recomputes the smallest enclosing ellipse template class InputIterator void min ellipse insert InputIterator first InputIterator last inserts the points in the range first last into min ellipse and recomputes the smallest enclosing ellipse by calling insert p for each point p in first last Requirement The value type of first and last is Point void min ellipse clear deletes all points in min ellipse and sets min ellipse to the empty set Postcondition min ellipse is empty true Validity Check An object min ellipse is valid iff min ellipse contains all points of its defining set P min ellipse is the smallest ellipse spanned by its support set S and S is minimal i e no support point is redundant Note In this release only the first item is considered by the validity check bool min ellipse is valid bool verbose false int level returns true iff min ellipse contains all points of its defining set P If verbose is true some messages concerning the performed checks are written to standard error stream The second parameter level is not used we provide it only for consistency with interfaces of other classes Miscellaneous const Traits min ellipse traits returns a const reference to the traits class object I O std ostream std ostream os min ellipse writes min ellipse to output stream os Requirement The output operator is defined for Point and for Ellipse if pretty printing is used std istream std istream is min ellipse reads min ellipse from input stream is Requirement The input operator is defined for Point include CGAL IO Window stream h CGAL Window stream CGAL Window stream ws min ellipse writes min ellipse to window stream ws Requirement The window stream output operator is defined for Point and Ellipse See Also CGAL Min circle 2 Traits CGAL Min ellipse 2 traits 2 K MinEllipse2Traits Implementation We implement the incremental algorithm of Welzl with move to front heuristic Wel91 using the primitives as described in GS97a GS97b The whole implementation is described in GS98b If randomization is chosen the creation time is almost always linear in the number of points Access functions and predicates take constant time inserting a point might take up to linear time but substantially less than computing the new smallest enclosing ellipse from scratch The clear operation and the check for validity each takes linear time Example To illustrate the usage of Min ellipse 2 Traits and to show that randomization can be useful in certain cases we give an example The example also shows how the coefficents of the constructed ellipse can be accessed file examples Min ellipse 2 example Min ellipse 2 C includes include cassert include CGAL Cartesian h include CGAL Point 2 h include CGAL Min ellipse 2 h include CGAL Min ellipse 2 traits 2 h include CGAL Gmpq h typedefs typedef CGAL Gmpq NT typedef CGAL Cartesian NT K typedef CGAL Point 2 K Point typedef CGAL Min ellipse 2 traits 2 K Traits typedef CGAL Min ellipse 2 Traits Min ellipse main int main int char int n 2 Point P new Point n for int i i n i P i Point i 2 i i 1 2 3 std cout Computing ellipse without randomization std cout flush Min ellipse me1 P P n false very slow std cout done std endl std cout Computing ellipse with randomization std cout flush Min ellipse me2 P P n true fast std cout done std endl because all input points are collinear the ellipse is degenerate and equals a line segment the ellipse has two support points assert me2 is degenerate assert me2 number of support points 2 prettyprinting CGAL set pretty mode std cout std cout me2 in general the ellipse is not explicitly representable over the input number type NT when you use the default traits class CGAL Min ellipse 2 traits 2 K you can get double approximations for the coefficients of the underlying conic curve NOTE this curve only exists in the nondegenerate case me2 insert Point 1 resolves the degeneracy assert me2 is degenerate get the coefficients double r s t u v w me2 ellipse double coefficients r s t u v w std cout ellipse has the equation r x 2 s y 2 t xy u x v y w std endl delete P return EOF Next Min ellipse 2 traits 2 K Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Optimisation_ref/Class_Min_ellipse_2.html", "title": "min_ellipse_2&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Optimisation_ref/Min_ellipse_2.tex' -->\n<html> <head>  \n<title>Min_ellipse_2&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1143\"></A>\n\n<A NAME=\"Cross_link_anchor_1144\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1073\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Min_ellipse_2<Traits>\"></A>\n<h2><I>CGAL::Min_ellipse_2&lt;Traits&gt;</I></h2>\n<P>\n\n<A NAME=\"Index_anchor_1074\"></A> \n\n   \n\n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1075\"></A> \n\n   \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1076\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1077\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nAn object of the class <I><A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;</I> is the unique ellipse of smallest <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A>\nenclosing a finite (multi)set of points in two-dimensional euclidean\nspace&nbsp;<MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>2</SUB></I></MATH>.  For a point set <MATH><I>P</I></MATH> we denote by <MATH><I>me(P)</I></MATH> the smallest\nellipse that contains all points of <MATH><I>P</I></MATH>. Note that <MATH><I>me(P)</I></MATH> can be\ndegenerate,\ni.e.&nbsp;<MATH><I>me(P)=</I></MATH>&Oslash;<MATH><I></I></MATH> if\n<MATH><I>P=</I></MATH>&Oslash;<MATH><I></I></MATH>, <MATH><I>me(P)={p}</I></MATH> if <MATH><I>P={p}</I></MATH>,\nand <MATH><I>me(P) = { </I></MATH>(1-l)p + l q | 0 <= l <= 1<MATH><I> }</I></MATH> if <MATH><I>P={p,q}</I></MATH>.\n<P>\n\nAn inclusion-minimal subset <MATH><I>S</I></MATH> of <MATH><I>P</I></MATH> with <MATH><I>me(S)=me(P)</I></MATH> is called a\n<I>support set</I>,\nthe points in <MATH><I>S</I></MATH> are the <I>support points</I>.  A support set has size at\nmost five, and all its points lie on the boundary of <MATH><I>me(P)</I></MATH>. In general,\nneither the support set nor its size are necessarily unique.\n<P>\n\nThe underlying algorithm can cope with all kinds of input, e.g.&nbsp;<MATH><I>P</I></MATH> may be\nempty or points may occur more than once. The algorithm computes a support\nset <MATH><I>S</I></MATH> which remains fixed until the next insert or clear operation.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Min_ellipse_2.h\">CGAL/Min_ellipse_2.h</A>&gt;</I>\n<P>\n\n<H3>Requirements</H3>   \n     \n     \n<A NAME=\"Index_anchor_1078\"></A>\n<P>\n\nThe template parameter <I>Traits</I> is a model for <I><A HREF=\"Concept_MinEllipse2Traits.html#Cross_link_anchor_1147\">MinEllipse2Traits</A></I>.\n<P>\n\nWe provide the model <I><A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1145\">CGAL::Min_ellipse_2_traits_2</A>&lt;K&gt;</I> using the \ntwo-dimensional C<SMALL>GAL</SMALL>&nbsp;kernel.\n<P>\n\n<H3>Types</H3>   \n     \n     \n<A NAME=\"Index_anchor_1079\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;::Point\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Typedef to <I>Traits::Point  </I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;::Ellipse\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Typedef to <I>Traits::Ellipse</I>. If you \n        are using the predefined traits class \n        <I><A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1145\">CGAL::Min_ellipse_2_traits_2</A>&lt;K&gt;</I>,\n        you can access the coefficients of the ellipse, see the \n        documentation of <I><A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1145\">CGAL::Min_ellipse_2_traits_2</A>&lt;K&gt;</I> and \n        the example below.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Non-mutable model of the STL concept <I>BidirectionalIterator</I>\n        with value type <I>Point</I>. Used to access the points\n        of the smallest enclosing ellipse.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;::Support_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Non-mutable model of the STL concept <I>RandomAccessIterator</I>\n        with value type <I>Point</I>. Used to access the support points\n        of the smallest enclosing ellipse.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1080\"></A>\n<P>\n\nA <I><A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;</I> object can be created from an arbitrary point set <MATH><I>P</I></MATH> and by\nspecialized construction methods expecting no, one, two, three, four or\nfive points as arguments. The latter methods can be useful for\nreconstructing <MATH><I>me(P)</I></MATH> from a given support set <MATH><I>S</I></MATH> of <MATH><I>P</I></MATH>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\nbool randomize,<BR>\n\nRandom&amp; random = default_random,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_ellipse</I> to <MATH><I>me(P)</I></MATH> with <MATH><I>P</I></MATH> being the set of points\n        in the range [<I>first</I>,<I>last</I>). If <I>randomize</I> is\n        <I>true</I>, a random permutation of <MATH><I>P</I></MATH> is computed in\n        advance, using the random numbers generator <I>random</I>.\n        Usually, this will not be necessary, however, the algorithm's\n        efficiency depends on the order in which the points are\n        processed, and a bad order might lead to extremely poor\n        performance (see example below).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I>\n        is <I>Point</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse (  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable <I>min_ellipse</I> of type <I><A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;</I>.\n        It is initialized to\n        <MATH><I>me(</I></MATH>&Oslash;<MATH><I>)</I></MATH>, the empty set.<BR>\n\n<EM>Postcondition: </EM><I>min_ellipse</I><I>.is_empty()</I> = <I>true</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse (  Point p,  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_ellipse</I> to <MATH><I>me({p})</I></MATH>, the set <MATH><I>{p}</I></MATH>.<BR>\n\n<EM>Postcondition: </EM><I>min_ellipse</I><I>.is_degenerate()</I> = <I>true</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nPoint q,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_ellipse</I> to <MATH><I>me({p,q})</I></MATH>,\nthe set\n        <MATH><I>{ </I></MATH>(1-l)p + l q | 0 <= l <= 1<MATH><I> }</I></MATH>.<BR>\n\n<EM>Postcondition: </EM><I>min_ellipse</I><I>.is_degenerate()</I> = <I>true</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p1,<BR>\n\nPoint p2,<BR>\n\nPoint p3,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_ellipse</I> to <MATH><I>me({p1,p2,p3})</I></MATH>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p1,<BR>\n\nPoint p2,<BR>\n\nPoint p3,<BR>\n\nPoint p4,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_ellipse</I> to <MATH><I>me({p1,p2,p3,p4})</I></MATH>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt; min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p1,<BR>\n\nPoint p2,<BR>\n\nPoint p3,<BR>\n\nPoint p4,<BR>\n\nPoint p5,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_ellipse</I> to <MATH><I>me({p1,p2,p3,p4,p5})</I></MATH>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>   \n     \n     \n<A NAME=\"Index_anchor_1081\"></A> \n\n   \n\n\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1082\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1083\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.number_of_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of points of <I>min_ellipse</I>, i.e. <MATH><I>|P|</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_support_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.number_of_support_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of support points of <I>min_ellipse</I>, i.e. <MATH><I>|S|</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_begin69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.points_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first point of <I>min_ellipse</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_end69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.points_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_begin69_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.support_points_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first support point of <I>min_ellipse</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_end69_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.support_points_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Point__support_point6_int_i9_const;\"></A>\n Point\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.support_point ( int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the <I>i</I>-th support point of <I>min_ellipse</I>. Between two\n        modifying operations (see below) any call to\n        <I>min_ellipse</I><I>.support_point(i)</I> with the same <I>i</I> returns\n        the same point.<BR>\n\n<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i&lt; </I></MATH><I>min_ellipse</I><I>.number_of_support_points()</I><MATH><I></I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Ellipse__ellipse6_9_const;\"></A>\n Ellipse\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.ellipse ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the current ellipse of <I>min_ellipse</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1084\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1085\"></A>\n<P>\n\nBy definition, an empty <I><A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;</I> has no boundary and no bounded side,\ni.e. its unbounded side equals the whole space <MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>2</SUB></I></MATH>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_CGAL::Bounded_side_bounded_side6_const_Point__p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_98\">CGAL::Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.bounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>CGAL::</I><I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I>,\n        <I>CGAL::</I><I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I>, or\n        <I>CGAL::</I><I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> iff <I>p</I> lies properly\n        inside, on the boundary of, or properly outside of <I>min_ellipse</I>, resp.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_bounded_side6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.has_on_bounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies properly inside <I>min_ellipse</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_boundary6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.has_on_boundary (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies on the boundary\n        of <I>min_ellipse</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_unbounded_side6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.has_on_unbounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies properly outside of <I>min_ellipse</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_empty6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.is_empty ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_ellipse</I> is empty (this implies\n        degeneracy).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_degenerate6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.is_degenerate ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_ellipse</I> is degenerate,\n        i.e.&nbsp;if <I>min_ellipse</I> is empty, equal to a single point or equal to a\n        segment, equivalently if the number of support points is less\n        than&nbsp;3.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1086\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1087\"></A>\n<P>\n\nNew points can be added to an existing <I>min_ellipse</I>, allowing to build <MATH><I>me(P)</I></MATH>\nincrementally, e.g.&nbsp;if <MATH><I>P</I></MATH> is not known in advance. Compared to the direct\ncreation of <MATH><I>me(P)</I></MATH>, this is not much slower, because the construction\nmethod is incremental itself.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_const_Point__p9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.insert (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts <I>p</I> into <I>min_ellipse</I> and recomputes the smallest\n        enclosing ellipse.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_InputIterator_first+_InputIterator_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_ellipse.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the points in the range [<I>first</I>,<I>last</I>)\n        into <I>min_ellipse</I> and recomputes the smallest enclosing ellipse by\n        calling <I>insert(p)</I> for each point <I>p</I> in\n        [<I>first</I>,<I>last</I>).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n        <I>Point</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear6_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.clear ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    deletes all points in <I>min_ellipse</I> and sets <I>min_ellipse</I> to the empty set.<BR>\n\n<EM>Postcondition: </EM><I>min_ellipse</I><I>.is_empty()</I> = <I>true</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Validity Check</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1088\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1089\"></A>\n<P>\n\nAn object <I>min_ellipse</I> is valid, iff\n<UL>\n  <LI><I>min_ellipse</I> contains all points of its defining set <MATH><I>P</I></MATH>,\n  <LI><I>min_ellipse</I> is the smallest ellipse spanned by its support set <MATH><I>S</I></MATH>, and\n  <LI><MATH><I>S</I></MATH> is minimal, i.e. no support point is redundant.\n</UL>\n<I>Note:</I> In this release only the first item is considered by the\nvalidity check.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6_bool_verbose_=_false+_int_level_=_0_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_ellipse.is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    bool verbose = false,<BR>\n\nint level = 0)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_ellipse</I> contains all points of its\n      defining set <MATH><I>P</I></MATH>. If <I>verbose</I> is <I>true</I>, some\n      messages concerning the performed checks are written to\n      standard error stream. The second parameter <I>level</I> is not\n      used, we provide it only for consistency with interfaces of\n      other classes.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1090\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1091\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Traits__traits6_9_const;\"></A>\nconst Traits&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_ellipse.traits ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a const reference to the traits class object.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>I/O</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1092\"></A>\n<P>\n\n<A NAME=\"Index_anchor_1093\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1094\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::ostream&amp; os &lt;&lt;  min_ellipse<A NAME=\"Function_std::ostream__operator_66_6_std::ostream__os+_const_Min_ellipse_26Traits9__min_ellipse9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>min_ellipse</I> to output stream <I>os</I>.<BR>\n\n<EM>Requirement: </EM>The output operator is defined for <I>Point</I>\n        (and for <I>Ellipse</I>, if pretty printing is used).\n        </TD></TR>\n        </TABLE>\n<P>\n\n<A NAME=\"Index_anchor_1095\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1096\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::istream&amp; is &gt;&gt;  min_ellipse&amp;<A NAME=\"Function_std::istream__operator_99_6_std::istream__is+_Min_ellipse_26Traits9_min_ellipse_9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads <I>min_ellipse</I> from input stream <I>is</I>.<BR>\n\n<EM>Requirement: </EM>The input operator is defined for <I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Window_stream.h\">CGAL/IO/Window_stream.h</A>&gt;</I>\n<P>\n\n<A NAME=\"Index_anchor_1097\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1098\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1757\">CGAL::Window_stream</A>&amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     <A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1757\">CGAL::Window_stream</A>&amp; ws &lt;&lt;  min_ellipse<A NAME=\"Function_CGAL::Window_stream__operator_66_6_CGAL::Window_stream__ws+_const_Min_ellipse_26Traits9__min_ellipse9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>min_ellipse</I> to window stream <I>ws</I>.<BR>\n\n<EM>Requirement: </EM>The window stream output operator is defined for\n        <I>Point</I> and <I>Ellipse</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1138\">CGAL::Min_circle_2</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1145\">CGAL::Min_ellipse_2_traits_2</A>&lt;K&gt;</I><BR>\n\n<I><A HREF=\"Concept_MinEllipse2Traits.html#Cross_link_anchor_1147\">MinEllipse2Traits</A></I>\n<P>\n\n<H3>Implementation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1099\"></A>\n<P>\n\nWe implement the incremental algorithm of Welzl, with move-to-front\nheuristic&nbsp;[<A HREF=\"../biblio.html#Biblio_w-sedbe-91a\">Wel91</A>], using the primitives as described\nin&nbsp;[<A HREF=\"../biblio.html#Biblio_gs-epsee-97\">GS97a</A>, <A HREF=\"../biblio.html#Biblio_cgal:gs-seefe-97a\">GS97b</A>]. The whole implementation is described\nin&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:gs-seeeg-98\">GS98b</A>].\n<P>\n\nIf randomization is\nchosen, the creation time is almost always linear in the number of points.\nAccess functions and predicates take constant time, inserting a point might\ntake up to linear time, but substantially less than computing the new\nsmallest enclosing ellipse from scratch. The clear operation and the check\nfor validity each takes linear time.\n<P>\n\n<H3>Example</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1100\"></A>\n<P>\n\nTo illustrate the usage of <I><A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>&lt;Traits&gt;</I> and to show that randomization\ncan be useful in certain cases, we give an example. The example also\nshows how the coefficents of the constructed ellipse can be accessed.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>/example_Min_ellipse_2.C\n\n// includes\n#include &lt;cassert&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1144\">Min_ellipse_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1146\">Min_ellipse_2_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1362\">Gmpq</A>.h&gt;\n\n// typedefs\ntypedef  <A HREF=\"../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1361\">CGAL::Gmpq</A>                       NT;\ntypedef  <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;NT&gt;              K;\ntypedef  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;K&gt;                 Point;\ntypedef  <A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1145\">CGAL::Min_ellipse_2_traits_2</A>&lt;K&gt;  Traits;\ntypedef  <A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1143\">CGAL::Min_ellipse_2</A>&lt;Traits&gt;      Min_ellipse;\n\n// main\nint\nmain( int, char**)\n{\n    int     n = 200;\n    Point*  P = new Point[ n];\n\n    for ( int i = 0; i &lt; n; ++i)\n\tP[ i] = Point( i % 2 ? i : -i , 0);\n    // (0,0), (-1,0), (2,0), (-3,0)\n\n    std::cout &lt;&lt; &quot;Computing ellipse (without randomization)...&quot;;\n    std::cout.flush();\n    Min_ellipse  me1( P, P+n, false);    // very slow\n    std::cout &lt;&lt; &quot;done.&quot; &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; &quot;Computing ellipse (with randomization)...&quot;; \n    std::cout.flush();\n    Min_ellipse  me2( P, P+n, true);     // fast  \n    std::cout &lt;&lt; &quot;done.&quot; &lt;&lt; std::endl;\n\n    // because all input points are <A HREF=\"../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167\">collinear</A>, the ellipse is \n    // degenerate and equals a line segment; the ellipse has \n    // two support points\n    assert(me2.is_degenerate());\n    assert(me2.number_of_support_points()==2); \n\n    // prettyprinting \n    <A HREF=\"../IOstream_ref/Function_set_pretty_mode.html#Cross_link_anchor_1749\">CGAL::set_pretty_mode</A>( std::cout);\n    std::cout &lt;&lt; me2;\n\n    // in general, the ellipse is not explicitly representable \n    // over the input number type NT; when you use the default\n    // traits class <A HREF=\"Class_Min_ellipse_2_traits_2.html#Cross_link_anchor_1145\">CGAL::Min_ellipse_2_traits_2</A>&lt;K&gt;, you can \n    // get double approximations for the coefficients of the \n    // underlying conic curve. NOTE: this curve only exists \n    // in the nondegenerate case!\n\n    me2.insert(Point(0,1)); // resolves the degeneracy\n    assert(!me2.is_degenerate());\n\n    // get the coefficients\n    double r,s,t,u,v,w;\n    me2.ellipse().double_coefficients( r, s, t, u, v, w);    \n    std::cout &lt;&lt; &quot;ellipse has the equation &quot; &lt;&lt; \n      r &lt;&lt; &quot; x^2 + &quot; &lt;&lt; \n      s &lt;&lt; &quot; y^2 + &quot; &lt;&lt; \n      t &lt;&lt; &quot; xy + &quot; &lt;&lt;\n      u &lt;&lt; &quot; x + &quot; &lt;&lt;\n      v &lt;&lt; &quot; y + &quot; &lt;&lt;\n      w &lt;&lt; &quot; = 0.&quot; &lt;&lt; std::endl;\n\n    delete[] P;\n\n    return( 0);\n}\n\n// ===== EOF ==================================================================\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Min_ellipse_2_traits_2.html\"><I>Min_ellipse_2_traits_2&lt;K&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_52!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38990.0}