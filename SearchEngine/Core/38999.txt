{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Min sphere of spheres d Traits Definition An object of the class Min sphere of spheres d Traits is a data structure that represents the unique sphere of smallest volume enclosing a finite set of spheres in d dimensional Euclidean space d For a set S of spheres we denote by ms S the smallest sphere that contains all spheres of S we call ms S the minsphere of S ms S can be degenerate i e ms S if S and ms S s if S s Any sphere in S may be degenerate too i e any sphere from S may be a point Also S may contain several copies of the same sphere An inclusion minimal subset R of S with ms R ms S is called a support set for ms S the spheres in R are the support spheres A support set has size at most d 1 and all its spheres lie on the boundary of ms S A sphere s is said to lie on the boundary of a sphere s if s is contained in s and if their boundaries intersect In general the support set is not unique The algorithm computes the center and the radius of ms S and finds a support set R which remains fixed until the next insert clear or set operation We also provide a specialization of the algorithm for the case when the center coordinates and radii of the input spheres are floating point numbers This specialized algorithm uses floating point arithmetic only is very fast and especially tuned for stability and robustness Still it s output may be incorrect in some rare cases termination is guaranteed When default constructed an instance of type Min sphere of spheres d Traits represents the set S together with its minsphere ms S You can add spheres to the set S by calling insert Querying the minsphere is done by calling the routines is empty radius and center cartesian begin among others In general the radius and the Euclidean center coordinates of ms S need not be rational Consequently the algorithm computing the exact minsphere will have to deal with algebraic numbers Fortunately both the radius and the coordinates of the minsphere are numbers of the form ai bisqrt t where ai bi t and where t is the same for all coordinates and the radius Thus the exact minsphere can be described by the number t which is called the sphere s discriminant and by d 1 pairs ai bi 2 one for the radius and d for the center coordinates include CGAL Min sphere of spheres d h Note This class almost replaces CGAL Min sphere d Traits which solves the less general problem of finding the smallest enclosing ball of a set of points Min sphere of spheres d Traits is faster than CGAL Min sphere d Traits and in contrast to the latter provides a specialized implementation for floating point arithmetic which ensures correct results in a large number of cases including highly degenerate ones The only advantage of CGAL Min sphere d Traits over Min sphere of spheres d Traits is that the former can deal with points in homogeneous coordinates in which case the algorithm is division free Thus CGAL Min sphere d Traits might still be an option in case your input number type cannot efficiently divide Requirements The class Min sphere of spheres d Traits expects a model of the concept MinSphereOfSpheresTraits as its template argument Types Min sphere of spheres d Traits Sphere is a typedef to Traits Sphere Min sphere of spheres d Traits FT is a typedef to Traits FT Min sphere of spheres d Traits Result is the type of the radius and of the center coordinates of the computed minsphere When FT is an inexact number type double for instance then Result is simply FT However when FT is an exact number type then Result is a typedef to a derived class of std pair FT FT an instance of this type represents the number a bsqrt t where a is the first and b the second element of the pair and where the number t is accessed using the member function disciminant of class Min sphere of spheres d Traits Min sphere of spheres d Traits Algorithm is either CGAL LP algorithm or CGAL Farthest first heuristic As is described in the documentation of concept MinSphereOfSpheresTraits the type Algorithm reflects the method which is used to compute the minsphere Normally Algorithm coincides with Traits Algorithm However if the method Traits Algorithm should not be supported anymore in a future release then Algorithm will have another type Min sphere of spheres d Traits Support iterator non mutable model of the STL concept BidirectionalIterator with value type Sphere Used to access the support spheres defining the smallest enclosing sphere Min sphere of spheres d Traits Cartesian const iterator non mutable model of the STL concept BidirectionalIterator to access the center coordinates of the minsphere Creation Min sphere of spheres d Traits minsphere Traits traits Traits creates a variable of type Min sphere of spheres d Traits and initializes it to ms If the traits parameter is not supplied the class Traits must provide a default constructor template typename InputIterator Min sphere of spheres d Traits minsphere InputIterator first InputIterator last Traits traits Traits creates a variable minsphere of type Min sphere of spheres d Traits and inserts cf insert the spheres from the range first last Requirement The value type of first and last is Sphere If the traits parameter is not supplied the class Traits must provide a default constructor Access Functions Support iterator minsphere support begin returns an iterator referring to the first support sphere of minsphere Support iterator minsphere support end returns the corresponding past the end iterator FT minsphere discriminant returns the discriminant of minsphere This number is undefined when FT is an inexact number type When FT is exact the center coordinates and the radius of the minsphere are numbers of the form a bsqrt t where t is the discriminant of the minsphere as returned by this function Precondition minsphere is not empty and FT is an exact number type Result minsphere radius returns the radius of minsphere If FT is an exact number type then the radius of the minsphere is the real number a bsqrt t where t is the minsphere s discriminant a is the first and b the second component of the pair returned by radius Precondition minsphere is not empty Cartesian const iterator minsphere center cartesian begin returns a const iterator to the first of the Traits D center coordinates of minsphere The iterator returns objects of type Result If FT is an exact number type then a center coordinate is represented by a pair a b describing the real number a bsqrt t where t is the minsphere s discriminant cf discriminant Precondition minsphere is not empty Cartesian const iterator minsphere center cartesian end returns the corresponding past the end iterator i e center cartesian begin Traits D Precondition minsphere is not empty Predicates bool minsphere is empty returns true iff minsphere is empty i e iff ms S Modifiers void minsphere clear resets minsphere to ms with S template class InputIterator void minsphere set InputIterator first InputIterator last sets minsphere to the ms S where S is the set of spheres in the range first last Requirement The value type of first and last is Sphere void minsphere insert Sphere s inserts the sphere s into the set S of instance minsphere template class InputIterator void minsphere insert InputIterator first InputIterator last inserts the spheres in the range first last into the set S of instance minsphere Requirement The value type of first and last is Sphere Validity Check An object minsphere is valid iff minsphere contains all spheres of its defining set S minsphere is the smallest sphere containing its support set R and R is minimal i e no support sphere is redundant bool minsphere is valid returns true iff minsphere is valid When FT is inexact this routine always returns true Miscellaneous const Traits minsphere traits returns a const reference to the traits class object See AlsoCGAL Min sphere d Traits CGAL Min circle 2 Traits Implementation We implement two algorithms the LP algorithm and a heuristic MSW92 As described in the documentation of concept MinSphereOfSpheresTraits each has its advantages and disadvantages Our implementation of the LP algorithm has maximal expected running time O 2d n while the heuristic comes without any complexity guarantee In particular the LP algorithm runs in linear time for fixed dimension d These running times hold for the arithmetic model so they count the number of operations on the number type FT On the other hand the LP algorithm is for inexact number types FT much worse at handling degeneracies and should therefore not be used in such a case For exact number types FT both methods handle all kinds of degeneracies Currently we require Traits FT to be either an exact number type or double or float other inexact number types are not supported at this time Also the current implementation only handles spheres with Cartesian coordinates homogenous representation is not supported yet Example file examples Min sphere of spheres d min sphere of spheres d example d C Computes the minsphere of some random spheres This example illustrates how to use CGAL Point d and CGAL Weighted point with the Min sphere of spheres d package include CGAL Cartesian d h include CGAL Random h include CGAL Gmpq h include CGAL Min sphere of spheres d h include vector const int N 1 number of spheres const int D 3 dimension of points const int LOW HIGH 1 range of coordinates and radii typedef CGAL Gmpq FT typedef double FT typedef CGAL Cartesian d FT K typedef CGAL Min sphere of spheres d traits d K FT D Traits typedef CGAL Min sphere of spheres d Traits Min sphere typedef K Point d Point typedef Traits Sphere Sphere int main std vector Sphere S n spheres FT coord D d coordinates CGAL Random r random number generator for int i i N i for int j j D j coord j r get int LOW HIGH Point p D coord coord D random center S push back Sphere p r get int LOW HIGH and random radius Min sphere ms S begin S end check in the spheres CGAL assertion ms is valid Next MinSphereOfSpheresTraits Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Optimisation_ref/Class_Min_sphere_of_spheres_d.html", "title": "min_sphere_of_spheres_d&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Optimisation_ref/Min_sphere_of_spheres_d.tex' -->\n<html> <head>  \n<title>Min_sphere_of_spheres_d&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1166\"></A>\n\n<A NAME=\"Cross_link_anchor_1167\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1178\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Min_sphere_of_spheres_d<Traits>\"></A>\n<h2><I>CGAL::Min_sphere_of_spheres_d&lt;Traits&gt;</I></h2>\n\n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1179\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1180\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1181\"></A> \n\n   \n\n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1182\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nAn object of the class <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> is a data structure that represents\nthe unique sphere of smallest <A HREF=\"../Kernel_23_ref/Function_volume.html#Cross_link_anchor_269\">volume</A> enclosing a finite set of spheres\nin <MATH><I>d</I></MATH>-dimensional Euclidean space <MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>d</SUB></I></MATH>.  For a set <MATH><I>S</I></MATH> of spheres\nwe denote by <MATH><I>ms(S)</I></MATH> the smallest sphere that contains all spheres of\n<MATH><I>S</I></MATH>; we call <MATH><I>ms(S)</I></MATH> the <I>minsphere</I> of <MATH><I>S</I></MATH>. <MATH><I>ms(S)</I></MATH> can be\ndegenerate, i.e., <MATH><I>ms(S)=</I></MATH>&Oslash;<MATH><I></I></MATH>,\nif <MATH><I>S=</I></MATH>&Oslash;<MATH><I></I></MATH> and <MATH><I>ms(S)={s}</I></MATH>,\nif <MATH><I>S={s}</I></MATH>.  Any sphere in <MATH><I>S</I></MATH> may be degenerate, too, i.e., any\nsphere from <MATH><I>S</I></MATH> may be a point.  Also, <MATH><I>S</I></MATH> may contain several\ncopies of the same sphere.\n<P>\n\nAn inclusion-minimal subset <MATH><I>R</I></MATH> of <MATH><I>S</I></MATH> with <MATH><I>ms(R)=ms(S)</I></MATH> is called a\n<I>support set</I> for <MATH><I>ms(S)</I></MATH>; the spheres in <MATH><I>R</I></MATH> are the\n<I>support spheres</I>.  A support set has size at most <MATH><I>d+1</I></MATH>, and all\nits spheres lie on the boundary of <MATH><I>ms(S)</I></MATH>. (A sphere <MATH><I>s'</I></MATH> is said to\n<I>lie on the boundary</I> of a sphere <MATH><I>s</I></MATH>, if <MATH><I>s'</I></MATH> is contained in <MATH><I>s</I></MATH>\nand if their boundaries intersect.)  In general, the support set is\nnot unique.\n<P>\n\nThe algorithm computes the center and the radius of <MATH><I>ms(S)</I></MATH>, and finds\na support set <MATH><I>R</I></MATH> (which remains fixed until the next <I>insert()</I>,\n<I>clear()</I> or <I>set()</I> operation).  We also provide a\nspecialization of the algorithm for the case when the center\ncoordinates and radii of the input spheres are floating-point numbers.\nThis specialized algorithm uses floating-point arithmetic only, is\nvery fast and especially tuned for stability and robustness.  Still,\nit's output may be incorrect in some (rare) cases; termination is\nguaranteed.\n<P>\n\nWhen default constructed, an instance of type\n<I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> represents the set\n<MATH><I>S= <IMG BORDER=0 WIDTH=6 HEIGHT=28 ALIGN=MIDDLE SRC=\"cc_emptyset.gif\"> </I></MATH>, together with its minsphere <MATH><I>ms(S)= <IMG BORDER=0 WIDTH=6 HEIGHT=28 ALIGN=MIDDLE SRC=\"cc_emptyset.gif\"> </I></MATH>.  You can\nadd spheres to the set <MATH><I>S</I></MATH> by calling <I>insert()</I>.  Querying the\nminsphere is done by calling the routines <I>is_empty()</I>,\n<I>radius()</I> and <I>center_cartesian_begin()</I>, among others.\n<P>\n\nIn general, the radius and the Euclidean center coordinates of <MATH><I>ms(S)</I></MATH>\nneed not be rational.  Consequently, the algorithm computing the exact\nminsphere will have to deal with algebraic numbers.  Fortunately, both\nthe radius and the coordinates of the minsphere are numbers of the\nform <MATH><I>a<SUB>i</SUB>+b<SUB>i</SUB><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(t)</I></MATH>, where <MATH><I>a<SUB>i</SUB>,b<SUB>i</SUB>,t <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=12 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_mathbb_Q.gif\"> </I></MATH> and where <MATH><I>t <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 0</I></MATH> is\nthe same for all coordinates and the radius.  Thus, the exact\nminsphere can be described by the number&nbsp;<MATH><I>t</I></MATH>, which is called the\nsphere's <I>discriminant</I>, and by <MATH><I>d+1</I></MATH> pairs <MATH><I>(a<SUB>i</SUB>,b<SUB>i</SUB>) <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\">  <IMG BORDER=0 WIDTH=12 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_mathbb_Q.gif\"> <SUP>2</SUP></I></MATH>\n(one for the radius and <MATH><I>d</I></MATH> for the center coordinates).\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Min_sphere_of_spheres_d.h\">CGAL/Min_sphere_of_spheres_d.h</A>&gt;</I>\n<P>\n\n<B>Note:</B> This class (almost) replaces\n<I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;</I>, which solves the less general\nproblem of finding the smallest enclosing ball of a set of\n<I>points</I>.  <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> is faster than\n<I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;</I>, and in contrast to the latter\nprovides a specialized implementation for floating-point arithmetic\nwhich ensures correct results in a large number of cases (including\nhighly degenerate ones).  The only advantage of\n<I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;</I> over <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> is that the former\ncan deal with points in homogeneous coordinates, in which case the\nalgorithm is division-free. Thus, <I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;</I>\nmight still be an option in case your input number type cannot\n(efficiently) divide.\n<P>\n\n<H3>Requirements</H3>   \n     \n     \n<A NAME=\"Index_anchor_1183\"></A>\n<P>\n\nThe class <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> expects a model of the concept\n<I><A HREF=\"Concept_MinSphereOfSpheresTraits.html#Cross_link_anchor_1168\">MinSphereOfSpheresTraits</A></I> as its template argument.\n<P>\n\n<H3>Types</H3>   \n     \n     \n<A NAME=\"Index_anchor_1184\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;::Sphere\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    is a typedef to <I>Traits::Sphere</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;::FT\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    is a typedef to <I>Traits::FT</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;::Result\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    is the type of the radius and of the center\n  coordinates of the computed minsphere: When <I>FT</I> is an inexact\n  number type (<I>double</I>, for instance), then <I>Result</I> is\n  simply <I>FT</I>.  However, when <I>FT</I> is an exact number type,\n  then <I>Result</I> is a typedef to a derived class of\n  <I>std::pair&lt;FT,FT&gt;</I>; an instance of this type represents the\n  number <MATH><I>a+bsqrt(t)</I></MATH>, where <MATH><I>a</I></MATH> is the first and <MATH><I>b</I></MATH> the second\n  element of the pair and where the number <MATH><I>t</I></MATH> is accessed using the\n  member function <I>disciminant()</I> of class\n  <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;::Algorithm\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    is either <I>CGAL::LP_algorithm</I> or\n<I>CGAL::Farthest_first_heuristic</I>.  As is described in the\ndocumentation of concept <I><A HREF=\"Concept_MinSphereOfSpheresTraits.html#Cross_link_anchor_1168\">MinSphereOfSpheresTraits</A></I>, the type\n<I>Algorithm</I> reflects the method which is used to compute the\nminsphere.  (Normally, <I>Algorithm</I> coincides with\n<I>Traits::Algorithm</I>.  However, if the method\n<I>Traits::Algorithm</I> should not be supported anymore in a future\nrelease, then <I>Algorithm</I> will have another type.)\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;::Support_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL\nconcept\n<I>BidirectionalIterator</I>\nwith value type <I>Sphere</I>. Used\nto access the support spheres defining the smallest enclosing sphere.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;::Cartesian_const_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL\nconcept\n<I>BidirectionalIterator</I>\nto access the center coordinates of the minsphere.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1185\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt; minsphere (  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable of type <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> and initializes it to\n  <MATH><I>ms(</I></MATH>&Oslash;<MATH><I>)</I></MATH>.  If the traits\n  parameter is not supplied, the class <I>Traits</I> must provide a\n  default constructor.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; typename InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt; minsphere ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable <I>minsphere</I> of type\n                                   <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> and inserts (cf. \n                                   <I>insert()</I>) the spheres from\n                                   the range [<I>first</I>,<I>last</I>).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n<I>Sphere</I>. If the traits parameter is not supplied, the class\n<I>Traits</I> must provide a default constructor.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>   \n     \n     \n<A NAME=\"Index_anchor_1186\"></A> \n\n   \n\n\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1187\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1188\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Support_iterator_support_begin69_const;\"></A>\nSupport_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.support_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns\n  an iterator referring to the first support sphere of <I>minsphere</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Support_iterator_support_end69_const;\"></A>\nSupport_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.support_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the\n  corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_FT__discriminant6_9_const;\"></A>\n FT\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.discriminant ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the\n  discriminant of <I>minsphere</I>.  This number is undefined when <I>FT</I> is\n  an inexact number type.  When <I>FT</I> is exact, the center\n  coordinates and the radius of the minsphere are numbers of the form\n  <MATH><I>a+bsqrt(t)</I></MATH>, where <MATH><I>t</I></MATH> is the discriminant of the minsphere as\n  returned by this function.<BR>\n\n<EM>Precondition: </EM><I>minsphere</I> is not empty, and\n  <I>FT</I> is an exact number type.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Result_radius6_9_const;\"></A>\nResult\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.radius ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the radius of\n  <I>minsphere</I>.  If <I>FT</I> is an exact number type then the radius of the\n  minsphere is the real number <MATH><I>a+bsqrt(t)</I></MATH>, where <MATH><I>t</I></MATH> is the\n  minsphere's discriminant, <MATH><I>a</I></MATH> is the first and <MATH><I>b</I></MATH> the second\n  component of the pair returned by <I>radius()</I>.<BR>\n\n<EM>Precondition: </EM><I>minsphere</I> is not empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Cartesian_const_iterator_center_cartesian_begin6_9_const;\"></A>\nCartesian_const_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.center_cartesian_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a const-iterator to the first of the\n  <I>Traits::D</I> center coordinates of <I>minsphere</I>.  The iterator returns\n  objects of type <I>Result</I>.  If <I>FT</I> is an exact number type,\n  then a center coordinate is represented by a pair <MATH><I>(a,b)</I></MATH> describing\n  the real number <MATH><I>a+bsqrt(t)</I></MATH>, where <MATH><I>t</I></MATH> is the minsphere's\n  discriminant (cf.  <I>discriminant()</I>).<BR>\n\n<EM>Precondition: </EM><I>minsphere</I> is not\n  empty.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Cartesian_const_iterator_center_cartesian_end6_9_const;\"></A>\nCartesian_const_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.center_cartesian_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator, i.e. \n  <I>center_cartesian_begin()+Traits::D</I>.<BR>\n\n<EM>Precondition: </EM><I>minsphere</I> is not\n  empty.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1189\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1190\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_empty6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.is_empty ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff\n  <I>minsphere</I> is empty, i.e. iff <MATH><I>ms(S)= <IMG BORDER=0 WIDTH=6 HEIGHT=28 ALIGN=MIDDLE SRC=\"cc_emptyset.gif\"> </I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1191\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1192\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear_69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    minsphere.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    resets <I>minsphere</I> to <MATH><I>ms(</I></MATH>&Oslash;<MATH><I>)</I></MATH>, with <MATH><I>S:=  <IMG BORDER=0 WIDTH=6 HEIGHT=28 ALIGN=MIDDLE SRC=\"cc_emptyset.gif\"> </I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set6_InputIterator_first+_InputIterator_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    minsphere.set ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets <I>minsphere</I> to\n  the <MATH><I>ms(S)</I></MATH>, where <MATH><I>S</I></MATH> is the set of spheres in the range\n  [<I>first</I>,<I>last</I>).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n  <I>Sphere</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_const_Sphere__s_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.insert (  Sphere s)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the\n  sphere <I>s</I> into the set <MATH><I>S</I></MATH> of instance <I>minsphere</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_InputIterator_first+_InputIterator_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    minsphere.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the spheres in\n  the range [<I>first</I>,<I>last</I>) into the set <MATH><I>S</I></MATH> of instance\n  <I>minsphere</I>.<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n  <I>Sphere</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Validity Check</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1193\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1194\"></A> \n\n   \n \n   \n\nAn object <I>minsphere</I> is valid, iff\n<UL>\n<LI><I>minsphere</I> contains all spheres of its defining set <MATH><I>S</I></MATH>,\n<LI><I>minsphere</I> is the smallest sphere containing its support set <MATH><I>R</I></MATH>, and\n<LI><MATH><I>R</I></MATH> is minimal, i.e., no support sphere is redundant.\n</UL>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.is_valid ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff\n  <I>minsphere</I> is valid.  When <I>FT</I> is inexact, this routine always\n  returns <I>true</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1195\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1196\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Traits__traits6_9_const;\"></A>\nconst Traits&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    minsphere.traits ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a const reference to the traits class object.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3><I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1138\">CGAL::Min_circle_2</A>&lt;Traits&gt;</I><BR>\n\n\n<P>\n\n<H3>Implementation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1197\"></A>\n<P>\n\nWe implement two algorithms, the LP-algorithm and a\nheuristic&nbsp;[<A HREF=\"../biblio.html#Biblio_msw-sblp-92\">MSW92</A>].  As described in the documentation of\nconcept <I><A HREF=\"Concept_MinSphereOfSpheresTraits.html#Cross_link_anchor_1168\">MinSphereOfSpheresTraits</A></I>, each has its advantages and\ndisadvantages: Our implementation of the LP-algorithm has maximal\nexpected running time <MATH><I>O(2<SUP>d</SUP> n)</I></MATH>, while the heuristic comes without\nany complexity guarantee.  In particular, the LP-algorithm runs in\nlinear time for fixed dimension&nbsp;<MATH><I>d</I></MATH>. (These running times hold for the\narithmetic model, so they count the number of operations on\nthe number type <I>FT</I>.)\n<P>\n\nOn the other hand, the LP-algorithm is, for inexact number types\n<I>FT</I>, much worse at handling degeneracies and should therefore not\nbe used in such a case.  (For exact number types\n<I>FT</I>, both methods handle all kinds of degeneracies.)\n<P>\n\nCurrently, we require <I>Traits::FT</I> to be either an exact number\ntype or <I>double</I> or <I>float</I>; other inexact number types are\nnot supported at this time.  Also, the current implementation only\nhandles spheres with <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> coordinates; homogenous representation\nis not supported yet.\n<P>\n\n<H3>Example</H3><pre class=\"ExampleCode\">// file: examples/<A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>/min_sphere_of_spheres_d_example_d.C\n\n// Computes the minsphere of some random spheres.\n// This example illustrates how to use <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_486\">CGAL::Point_d</A> and CGAL::\n// <A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> with the <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A> package.\n\n#include &lt;CGAL/Cartesian_d.h&gt;\n#include &lt;CGAL/Random.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1362\">Gmpq</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1167\">Min_sphere_of_spheres_d</A>.h&gt;\n#include &lt;vector&gt;\n\nconst int N = 1000;                       // number of spheres\nconst int D = 3;                          // dimension of points\nconst int LOW = 0, HIGH = 10000;          // range of coordinates and radii\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1361\">CGAL::Gmpq</A>                        FT;\n//typedef double                          FT;\ntypedef CGAL::Cartesian_d&lt;FT&gt;             K;\ntypedef <A HREF=\"Class_Min_sphere_of_spheres_d_traits_d.html#Cross_link_anchor_1173\">CGAL::Min_sphere_of_spheres_d_traits_d</A>&lt;K,FT,D&gt; Traits;\ntypedef <A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt; Min_sphere;\ntypedef K::<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>                        Point;\ntypedef Traits::Sphere                    Sphere;\n\nint main () {\n  std::vector&lt;Sphere&gt; S;                  // n spheres\n  FT coord[D];                            // d coordinates\n  CGAL::Random r;                         // random number generator\n  \n  for (int i=0; i&lt;N; ++i) {\n    for (int j=0; j&lt;D; ++j)\n      coord[j] = r.get_int(LOW,HIGH);\n    Point p(D,coord,coord+D);             // random center...\n    S.push_back(Sphere(p,r.get_int(LOW,HIGH))); // ...and random radius\n  }\n  \n  Min_sphere ms(S.begin(),S.end());       // check in the spheres\n  CGAL_assertion(ms.is_valid());\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Concept_MinSphereOfSpheresTraits.html\"><I>MinSphereOfSpheresTraits</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_52!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38999.0}