{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Compact container T Allocator DefinitionAn object of the class Compact container T Allocator is a container of objects of type T It matches all the standard requirements for reversible containers except that the complexity of its iterator increment and decrement operations is not always guaranteed to be amortized constant time This container is not a standard sequence nor associative container which means the elements are stored in no particular order and it is not possible to specify a particular place in the iterator sequence where to insert new objects However all dereferenceable iterators are still valid after calls to insert and erase except those that have been erased it behaves similarly to std list The main feature of this container is that it is very memory efficient its memory size is N sizeof T o N where N is the maximum size that the container has had in its past history its capacity the memory of erased elements is not deallocated until destruction of the container or a call to clear This container has been developped in order to store large graph like data structures like the triangulation and the halfedge data structures It supports bidirectional iterators and allows a constant time amortized insert operation You cannot specify where to insert new objects i e you don t know where they will end up in the iterator sequence although insert returns an iterator pointing to the newly inserted object You can erase any element with a constant time complexity Summary of the differences with std list it is more compact in memory since it doesn t store two additional pointers for the iterator needs It doesn t deallocate elements until the destruction or clear of the container The iterator does not have constant amortized time complexity for the increment and decrement operations in all cases only when not too many elements have not been freed i e when the size is close to the capacity Iterating from begin to end takes O capacity time not size In the case where the container has a small size compared to its capacity we advise to defragment the memory by copying the container if the iterator performance is needed The iterators themselves can be used as T they provide the necessary functions to be used by Compact container traits T include CGAL Compact container h Parameters The parameter T is required to have a copy constructor and an assignment operator It also needs to provide access to an internal pointer via Compact container traits T The equality test and the relational order require the operators and for T respectively The parameter Allocator has to match the standard allocator requirements with value type T This parameter has the default value CGAL ALLOCATOR T Types Compact container T Allocator value type Compact container T Allocator reference Compact container T Allocator const reference Compact container T Allocator pointer Compact container T Allocator const pointer Compact container T Allocator size type Compact container T Allocator difference type Compact container T Allocator iterator Compact container T Allocator const iterator Compact container T Allocator reverse iterator Compact container T Allocator const reverse iterator Compact container T Allocator allocator type Creation Compact container T Allocator c Allocator a Allocator introduces an empty container eventually specifying a particular allocator a as well template class InputIterator Compact container T Allocator c InputIterator first InputIterator last Allocator a Allocator a container with copies from the range first last eventually specifying a particular allocator Compact container T Allocator c cc copy constructor Each item in cc is copied The allocator is copied The iterator order is preserved Compact container T Allocator c cc assignment Each item in cc is copied The allocator is copied Each item in c is deleted The iterator order is preserved void c swap cc swaps the contents of c and cc in constant time complexity No exception is thrown Access Member Functions iterator c begin returns a mutable iterator referring to the first element in c const iterator c begin const returns a constant iterator referring to the first element in c iterator c end returns a mutable iterator which is the past end value of c const iterator c end const returns a constant iterator which is the past end value of c reverse iterator c rbegin const reverse iterator c rbegin const reverse iterator c rend const reverse iterator c rend const bool c empty returns true iff c is empty size type c size returns the number of items in c size type c max size returns the maximum possible size of the container c size type c capacity returns the total number of elements that c can hold without requiring reallocation Allocator c get allocator returns the allocator Insertion iterator c insert T t inserts a copy of t in c and returns the iterator pointing to it template class InputIterator void c insert InputIterator first InputIterator last inserts the range first last in c template class InputIterator void c assign InputIterator first InputIterator last erases all the elements of c then inserts the range first last in c template typename T1 iterator c construct insert T1 t1 constructs an object of type T with the constructor that takes t1 as argument inserts it in c and returns the iterator pointing to it The same constructor exists for up to nine arguments Removal void c erase iterator pos removes the item pointed by pos from c void c erase iterator first iterator last removes the items from the range first last from c void c clear all items in c are deleted and the memory is deallocated After this call c is in the same state as if just default constructed Special Operation void c merge cc adds the items of cc to the end of c and cc becomes empty The time complexity is O c capacity c size Precondition cc must not be the same as c and the allocators of c and cc need to be compatible c get allocator cc get allocator Comparison Operations bool c cc test for equality Two containers are equal iff they have the same size and if their corresponding elements are equal bool c cc test for inequality returns c cc bool c cc compares in lexicographical order bool c cc returns cc c bool c cc returns c cc bool c cc returns c cc Next predecessor Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/STL_Extension_ref/Class_Compact_container.html", "title": "compact_container&lt;t, allocator&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './STL_Extension_ref/compact_container.tex' -->\n<html> <head>  \n<title>Compact_container&lt;T, Allocator&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1439\"></A>\n\n<A NAME=\"Cross_link_anchor_1440\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1425\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Compact_container<T, Allocator>\"></A>\n<h2><I>CGAL::Compact_container&lt;T, Allocator&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>An object of the class <I><A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;</I> \n  is a container of objects of type <I>T</I>.  It matches all the\n  standard requirements for reversible containers, except that\n  the complexity of its iterator increment and decrement operations\n  is not always guaranteed to be amortized constant time.\n<P>\n\nThis container is not a standard <I>sequence</I> nor <I>associative</I> container,\n  which means the elements are stored in no particular order, and it is not\n  possible to specify a particular place in the iterator sequence where to\n  insert new objects.  However, all dereferenceable iterators are\n  still valid after calls to <I>insert()</I> and <I>erase()</I>, except those\n  that have been erased (it behaves similarly to <I>std::list</I>).\n<P>\n\nThe main feature of this container is that it is very memory efficient :\n  its memory size is <I>N*sizeof(T)+o(N)</I>, where <I>N</I> is the maximum size\n  that the container has had in its past history, its <I>capacity()</I>\n  (the memory of erased elements is not deallocated until destruction of the\n  container or a call to <I>clear()</I>).  This container has been developped in\n  order to store large graph-like data structures like the triangulation and\n  the halfedge data structures.\n<P>\n\nIt supports bidirectional iterators and allows a constant time amortized\n  <I>insert()</I> operation.  You cannot specify where to insert new objects\n  (i.e. you don't know where they will end up in the iterator sequence,\n  although <I>insert()</I> returns an iterator pointing to the newly inserted\n  object).  You can erase any element with a constant time complexity.\n<P>\n\nSummary of the differences with <I>std::list</I>&nbsp;: it is more compact in\n  memory since it doesn't store two additional pointers for the iterator needs.\n  It doesn't deallocate elements until the destruction or <I>clear()</I> of the\n  container.  The iterator does not have constant amortized time complexity for\n  the increment and decrement operations in all cases, only when not too many\n  elements have not been freed (i.e. when the <I>size()</I> is close to the\n  <I>capacity()</I>).  Iterating from <I>begin()</I> to <I>end()</I> takes\n  <I>O(capacity())</I> time, not <I>size()</I>.  In the case where the container\n  has a small <I>size()</I> compared to its <I>capacity()</I>, we advise to\n  &quot;defragment the memory&quot; by copying the container if the iterator performance\n  is needed.\n<P>\n\nThe iterators themselves can be used as <I>T</I>, they provide the necessary\n  functions to be used by <I><A HREF=\"Class_Compact_container_traits.html#Cross_link_anchor_1438\">Compact_container_traits</A>&lt;T&gt;</I>.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Compact_container.h\">CGAL/Compact_container.h</A>&gt;</I>\n<P>\n\n<H3>Parameters</H3>\n<P>\n\nThe parameter <I>T</I> is required to have a copy constructor and an\n  assignment operator.  It also needs to provide access to an internal\n  pointer via <I><A HREF=\"Class_Compact_container_traits.html#Cross_link_anchor_1438\">Compact_container_traits</A>&lt;T&gt;</I>.\n<P>\n\nThe equality test and the relational order require the operators\n  <I>==</I> and <I>&lt;</I> for <I>T</I> respectively.\n<P>\n\nThe parameter <I>Allocator</I> has to match the standard allocator\n  requirements, with value type <I>T</I>.  This parameter has the default\n  value <I>CGAL_ALLOCATOR(T)</I>.\n<P>\n\n<H3>Types</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::value_type\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::reference\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::const_reference\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::pointer\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::const_pointer\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::size_type\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::difference_type\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n<TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::const_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::reverse_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::const_reverse_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n<TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt;::allocator_type\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt; c (  Allocator a = Allocator());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    introduces an empty container, eventually specifying a particular\n   allocator <I>a</I> as well.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt; c ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\nAllocator a = Allocator());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    a container with copies from the range [<I>first,last</I>), eventually\n   specifying a particular allocator.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt; c (  cc);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    copy constructor.  Each item in <I>cc</I> is copied.  The allocator\n   is copied.  The iterator order is preserved.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A HREF=\"Class_Compact_container.html#Cross_link_anchor_1440\">Compact_container</A>&lt;T, Allocator&gt; &amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c =  cc<A NAME=\"Function_Compact_container6T+_Allocator9___operator=6const_Compact_container6T+_Allocator9__cc9;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    assignment. Each item in <I>cc</I> is copied.  The allocator is copied.\n   Each item in <I>c</I> is deleted.  The iterator order is preserved.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_swap6Compact_container6T+_Allocator9__cc9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.swap (  &amp;cc)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    swaps the contents of <I>c</I> and <I>cc</I> in constant time\n   complexity.  No exception is thrown.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Member Functions</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_iterator_begin69;\"></A>\niterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.begin () \n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a mutable iterator referring to the first element in&nbsp;<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_iterator_begin69_const;\"></A>\nconst_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.begin () const\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a constant iterator referring to the first element in&nbsp;<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_iterator_end69;\"></A>\niterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.end () \n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a mutable iterator which is the past-end-value of&nbsp;<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_iterator_end69_const;\"></A>\nconst_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.end () const\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a constant iterator which is the past-end-value of&nbsp;<I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_reverse_iterator_rbegin69;\"></A>\nreverse_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.rbegin () \n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_const_reverse_iterator_rbegin69_const;\"></A>\nconst_reverse_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.rbegin () const\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_reverse_iterator_rend69;\"></A>\nreverse_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.rend () \n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_const_reverse_iterator_rend69_const;\"></A>\nconst_reverse_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.rend () const\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_empty69_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.empty ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I> iff <I>c</I> is empty.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_size69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.size ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of items in&nbsp;<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_max_size69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.max_size ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the maximum possible size of the container&nbsp;<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_capacity69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.capacity ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the total number of elements that&nbsp;<I>c</I> can hold without requiring\n   reallocation.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Allocator_get_allocator69_const;\"></A>\nAllocator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.get_allocator ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the allocator.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Insertion</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_iterator_insert6const_T__t9;\"></A>\niterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.insert (  T t)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts a copy of <I>t</I> in <I>c</I> and returns the iterator pointing\n   to it.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6InputIterator_first+_InputIterator_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.insert ( InputIterator first,  InputIterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the range [<I>first, last</I>) in <I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class InputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_assign6InputIterator_first+_InputIterator_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90\">assign</A> ( InputIterator first,  InputIterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    erases all the elements of <I>c</I>, then inserts the range\n   [<I>first, last</I>) in <I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; typename T1 &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_iterator_construct_insert6T1_t19;\"></A>\niterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.construct_insert ( T1 t1)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    constructs an object of type <I>T</I> with the constructor that takes\n   <I>t1</I> as argument, inserts it in <I>c</I>, and returns the iterator pointing\n   to it. The same constructor exists for up to nine arguments.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Removal</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase6iterator_pos9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.erase ( iterator pos)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the item pointed by <I>pos</I> from&nbsp;<I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_erase6iterator_first+_iterator_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    c.erase ( iterator first,  iterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the items from the range [<I>first, last</I>) from&nbsp;<I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    all items in <I>c</I> are deleted, and the memory is deallocated.\n   After this call, <I>c</I> is in the same state as if just default\n   constructed.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Special Operation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_merge6Compact_container6T+_Allocator9__cc9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    c.merge (  &amp;cc)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds the items of <I>cc</I> to the end of <I>c</I> and <I>cc</I> becomes empty.\n   The time complexity is O(<I>c</I>.<I>capacity()</I>-<I>c</I>.<I>size()</I>).<BR>\n\n<EM>Precondition: </EM><I>cc</I> must not be the same as <I>c</I>,\n   and the allocators of <I>c</I> and <I>cc</I> need to be compatible :\n   <I>c</I>.<I>get_allocator() == cc.get_allocator()</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Comparison Operations</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c ==  cc<A NAME=\"Function_bool_operator==6const_Compact_container6T+_Allocator9__cc9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    test for equality: Two containers are equal, iff they have the\n   same size and if their corresponding elements are equal.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c !=  cc<A NAME=\"Function_bool_operator!=6const_Compact_container6T+_Allocator9__cc9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    test for inequality: returns !(<I>c</I> <I>== cc</I>).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c &lt;  cc<A NAME=\"Function_bool_operator66const_Compact_container6T+_Allocator9__cc9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    compares in lexicographical order.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c &gt;  cc<A NAME=\"Function_bool_operator96const_Compact_container6T+_Allocator9__cc9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>cc &lt;</I> <I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c &lt;=  cc<A NAME=\"Function_bool_operator6=6const_Compact_container6T+_Allocator9__cc9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns !(<I>c</I> <I>&gt; cc</I>).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    bool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     c &gt;=  cc<A NAME=\"Function_bool_operator9=6const_Compact_container6T+_Allocator9__cc9_const;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns !(<I>c</I> <I>&lt; cc</I>).\n        </TD></TR>\n        </TABLE>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Function_predecessor.html\"><I>predecessor</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_3!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38012.0}