{"text": "Program 3 Trees Implementing Collections Priority Queue via Max Heap and Map via BST Fundamental Data Structures ICS 23 Introduction This programming assignment is designed to ensure that you know how to write code that processes trees by implementing more efficient versions of the collection classes that we have been studying First we will write a priority queue where the add remove methods are both O Log N instead of one being O 1 and one O N If we add remove N values in such a priority queue the complexity is O N Log N instead of O N 2 this gives us a way to sort in time O N Log N Second we will write a map where the get put methods are both O Log N for a well balanced tree most random BSTs are well balanced instead of each being O N as in the array implementation and worst case for pathological trees When writing your classes you will run each against my JUnit tests to verify a bit too strong of a word here that it is correct You may also find it useful to test your classes with the DriverForOrderedCollection or DriverForMap which you can run from collection jar once you build a path to this library in the project With this driver you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString Download and unzip the following Eclipse project Start and use it to start working on this program For each part of this assignmnment you will update and turn in a single java file in the project see the Checkmate submission for this assignment for more details Only one student should submit the assignment but both student s names should appear in the comments at the top of each submitted program Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review while you work on this assignment and before you turn in the files Problem 1 Priority Queue via Max Heap In this program you will write a more efficient version of a priority queue by implementing it as a max heap maximum value at the root You can test this program with TestPriorityQueue a JUnit test how we will ultimately grade it and with a Supermarket shopping simulation With the DriverForOrderedCollection program you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString The HeapPriorityQueue class must implement the PriorityQueue interface using standard priority queue semantics any in highest priority out You have already implemented this behavior using linked lists Here the underlying data structure is a heap which uses an array to represent a tree compactly so it has more similarities to the priority queue implemented by an array than the one implemented by a linked list In this representation the index of a child node can be computed from the index of its parent node and vice versa by the formulas discussed in class and reviewed below So we should think tree but program array Because the main data structure is an array even though we think tree you should examine the code in the ArrayPriorityQueue class Pay special attention to the toString shallowCopy ensureCapacity and trimToSize methods Here are some issues to think about when writing your class Array Length Size and Mapping Recall that with the simple mapping of indexes for parent i the left child is 2 i and the right is 2 i 1 for child i either left or right the parent is i 2 the first node in the heap must be stored in index 1 in the array not in index This changes how the underlying array must be allocated because an array that must store n values must be allocated to be size n 1 and the indexes 1 through n to store n values We can simplify array allocation using the familiar through n 1 allocation to store n values if we make the mapping of indexes more complex for parent i the left child is 2 i 1 and the right is 2 i 2 for child i either left or right the parent is i 1 2 Become familiar with this mapping by looking at an example heap with 1 15 values You may use either this mapping or the one described above Given the ensureCapacity and trimToSize methods work on arrays with indexes to N 1 I recommend using the mapping explained in this paragraph Choose which way you will represent the array and its mapping see above Not carefully allocating using the array can be a big source of bugs so be careful I suggest putting these mappings into four simple private static methods inHeap leftChild rightChild and parent the first determining whether or not an index is in the heap being stored and the final three each taking an int index and returning another int index to simplify your code by hiding the mapping details no matter which approach you take at a slight decrease in speed Or you can put the raw calculations directly into your code One interesting approach is to use the methods first to make debugging your code easier and then when he code works remove the methods and hardwire in the calculation If you don t find much speed difference why not go back to using the methdods because that makes the code clearer Finally you should also write private helper methods for the following three operations and call them wherever necessary swap called with two indexes it swaps the values stored in those indexes in the array representing the heap percolateUp called with one index it percolates the value at that index as high as it should go percolateDown called with one index percolates that value at that index as low as it should go The percolate methods do most of the interesting work in maintaining the heaps This code is not trivial to write but it can be written simply I wrote percolateUp in 2 lines and percolateDown in 1 lines although some of these lines are dense I suggest you constantly think about simplifying your code for these methods as an aid for writing them correctly Of course to do so you must really understand what is going on during the percolation phases hint hand simulation Recall that for the second mapping once a value reaches index there is no parent index to process for a value at index i it has a left child if 2 i 1 objectCount and it has a right child if 2 i 2 objectCount In the alternative mapping the bounds are a bit different based on both a different mapping and the fact that values are stored in indexes 1 through N instead of through N 1 Don t attempt to process non existant children This is especially true in percolate down where to find the biggest child for a possible swap we may have to check just one or both children Constructors The first two constructors create arrays of the appropriate lengths remember to do this based on which mapping you are using The array version should do the linear offline operation to build a heap discussed in class rather than adding values to the heap one at a time The iterable version should put all the values in a simple collection convert it to an array and use the array constructor to actually build the heap toString The toString method should return the heap values as an array Here is an example of what my method returns I m using the second mapping when using the DriverForOrderedCollection toString HeapPriorityQueue 3 4 a 1 c 2 b Here is an example of what my method would return if it used the first mapping when using the DriverForOrderedCollection toString HeapPriorityQueue 3 5 not used 1 a 2 c 3 b Notice that this array is of length 5 because in my code the index is not used so there is room for 4 values in the heap the heap lengths is go from 2 3 5 9 17 etc always 1 bigger than a power of 2 Iterator hasNext and Next Recall that the iterator should iterate through the values in priority order highest down to lowest But unlike the array and linked implementations the heap implementation NEVER stores all the values IN ORDER in the array so we cannot just traverse the array with each call to the next method taking O 1 time Here are two ways that I can think of to implement an iterator When constructing the iterator actually allocate another array in the iterator which contains all the values in the heap array then sort it With this approach creating an iterator even if it is not used requires O N Log N time for sorting Given this sorted array you can traverse it in the iterator as one would traverse any array with each call to next requiring O 1 time When constructing the iterator actually store a SHALLOW COPY of the HeapPriorityQueue in the iterator With this approach creating an iterator even if it is not used requires O N time Given this shallow copy each call to next can call remove on the copy of the heap to get the next value requiring O Log N time shallowCopy must work correctly for this method to work since it is copying an array it is easy to write In both these approaches the array storing the real priority queue is different from the array storing the one being iterated through Constructing the iterator and iterating through all values is O N Log N in each case Be careful don t try to use an iterator when constructing the iterator If you see infinite recursion or run out of storage space this might be your problem Iterator remove As you might expect this is going to be complicated to describe but it turns out not very hard to implement Recall that we know how to remove a value from the top of the heap put the value at the end of the array at the top and swap it down to its correct position We can remove a value from the middle of a heap almost as simply put the value at the end of the array in the middle overwriting the value there and swap it up or down to its correct position depending on how it compares to its parent and children if any You might think that the value swapped to the middle will always be less than its parent but that is not so Construct an example of a heap so that the last value is greater than the parent of the value being removed my example was a heap with 6 nodes and I think it is minmal So if we keep track of which value we have seen and are asked in the iterator to remove it we can do a linear search the REAL heap array not the one the iterator is using it is gone from there if returned by next find that value use the total operation might take O N and then use this algorithm to remove it from the REAL heap In fact you should discover that remove from the heap itself and remove from the iterator share code that can be made into a parameterized private method usable in both places for precolate up down to the correct position see percolateUp and percolateDown described in the first section of this document Implement next and hasNext first and remove at very end Feel free to ask questions to help you understand which is just one of many things questions are for If you have problems getting the iterator correct or just before you implement it test the other methods with DriverForOrderedCollection Recall the JUnit test does most of its testing using the toArray method which will not work unless the iterator works Finally try running the supermarket simulation program with the ArrayPriorityQueue and your working HeapPriorityQueue Choose 2 checkout lines one with the default number of times effectively infinite and one with 6 or fewer items Run the simulation on 5 shoppers with tracing set to true to help you understand what is happening then run it with 5 or 1 shoppers With 5 shoppers my speedup using the HeapPriorityQueue over the ArrayPriorityQueue was from 24 seconds to 1 27 seconds Problem 2 Map via BST In this program you will write a more efficient version of a map by implementing it as a binary search tree We have seen that for all but pathological trees and randomly built trees are much closer to being well balanced than pathological most operations operations have a complexity of O Log N we can say O tree height to play it safe You can test this program with TestMap a JUnit test how we will ultimately grade it and with an updated version of the WordGenerator program included in the download from Program 1 part 6 on the file huck txt also included in the download With the DriverForMap program you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString I will supply a toString method that uses recursion to return a String that prints as a tree rotated 9 degress to the left so you can more easily see the structure of the tree you are building Before running the JUnit test you must get the iterator s hasNext and next methods working correctly Otherwise many tests will fail because many tests use the iterator indirectly e g they construct sets of values by iterating through maps if the iterator works incorrectly these sets will not be constructed correctly and the JUnit test will fail for this reason not because the operations really being tested are incorrect The BSTMap class must implement the Map interface using standard map semantics You should look at my ArrayMap class which contains code that implements the same Map interface some of which or code like it will belong in the BST implementation Here the underlying data structure is a binary search tree whose node class is complete within the implementation which also includes some helper methods like locate add and remove these are either completley written or just their header is specified Here are some issues to think about when writing your class Multiple Tree Searches Because recursive helper methods that mutate the BST like insert must return a BST node I found it convenient to first call the locate helper method and based on the result call or not call one of the recursive mutator method sometimes I can manipulate the located reference directly For example in my put method my code first tries to locate the key in the tree if successful my code changes the value associated with that key not changing the structure of the tree if it fails my code inserts a new entry into the tree with the appropriate key and value At worst these two searches slow down some methods i e put remove in the map remove in the iterator by a factor of two There is a way to squeeze a bit more speed out of the code by avoiding duplicate searches But to do so required carefully changing the recursive methods and using another instance variable I suggest that you code using the double search approach until you have everything working then if you have the inclination and some more time if you explore writing the more complicated code wait until then to even start thinking about this improvement The number of changes are small but they are high in technical complexity Map Entry Recall that Map interface defines the Entry interface which we refer to as Map Entry When we build our tree we need to use a class that implements Map Entry at each node Note that the AbstractMap class which all classes that implement Map use as a superclass defines a concrete class called SimpleEntry which implements Map Entry So our code can construct and use SimpleEntry objects see its constructor toString I have written a toString method that returns a 2 d picture of the BST rotated left by 9 degrees It is usefull for quickly quickly looking at a small BST Here is an example of what my method returns when using the DriverForMap showing 5 keys and their values toString BSTMap 5 x 5 m 4 c 3 b 2 a 1 Here m is the root with 3 nodes in its left subtree whose root key is b and 1 node in it right subtree whose root key is x Iterator hasNext and Next As in the heap priority queue the iterator for this class will iterate through another data structure in this case a Stack it s maximum size will be the height of the tree We discussed this kind of iterator at the end of the notes covering Binary Search Trees and in class I ll summarize the algorithm below see the notes for details To construct the iterator allocate a Stack use an ArrayStack data structure and add to it the root if the BST isn t empty and all the left descendants of the root hasNext returns whether the Stack is empty next removes and returns the reference at the top of the Stack and adds to the Stack the root of its right subtree if it isn t empty and all the left descendants of the root of its right subtree see the code you wrote in the constructor It also remembers this reference in case the iterator s remove is called Iterator remove Use the removeAt method to delete from the BST the previous value returned by next This operation does not affect the Stack You should also run the updated WordGenerator program with the large text file huck txt The update allows you to comment out code to select either the ArrayMap or BSTMap and its appropriate comparator it is that simple to change which data structure implements the data type It also tracks and prints the amount of time needed to build the map on my machine it took 18 minutes using ArrayMap and 1 second using BSTMap a speed up of a factor of over 1 when I used an order statistic of 3 Both ultimately producing a map that contains 9 7 5 keys with each key mapping to a list of between 1 and 46 words ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/assignments/program3/program.html", "title": "program 3", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 3</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 3</h1>\r\n<h1>\r\n    Trees Implementing Collections:<br> \r\n       Priority Queue via Max-Heap and\r\n       Map via BST\r\n</h1>\r\n<p>\r\n<h2>Fundamental Data Structures<br>\r\nICS-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to write\r\n  code that processes trees, by implementing more efficient versions of the\r\n  collection classes that we have been studying.\r\nFirst, we will write a priority queue where the add/remove methods are both\r\n  O(Log N) instead of one being O(1) and one O(N).\r\nIf we add/remove N values in such a priority queue, the complexity\r\n  is O(N Log N) instead of O(N^2): this gives us a way to sort in\r\n  time O(N Log N).\r\n<p>\r\nSecond, we will write a map where the get/put methods are both O(Log N) (for a\r\n  well balanced tree: most random BSTs are well balanced) instead of each being\r\n  O(N) as in the array implementation (and worst case for pathological trees).\r\n<p>\r\nWhen writing your classes, you will run each against my JUnit tests to verify\r\n  (a bit too strong of a word here) that it is correct.\r\nYou may also find it useful to test your classes with the\r\n  <b>DriverForOrderedCollection</b> or <b>DriverForMap</b>, which you can run\r\n  from <b>collection.jar</b> once you build a path to this library in the\r\n  project.\r\nWith this driver, you can individually test any methods in your classes\r\n  interactively, and see their results (returned values and state changes,\r\n  mostly using <b>toString</b>).\r\n<p>\r\n<!--The JUnit test also includes a speed test (be careful: it makes little\r\n  sense to compare speed tests run on two different machines, as the machines\r\n  themselves might run at different speeds).\r\nNote that a class <b>must pass all its correctness tests</b> to get any credit\r\n  for speed.\r\n<p>\r\n--->\r\nDownload and unzip the following <a href=\"program3start.zip\">Eclipse project\r\n  Start</a> and use it to start working on this program.\r\nFor each part of this assignmnment you will update and turn in a single\r\n  <b>.java</b> file in the project (see the <b>Checkmate</b> submission for\r\n  this assignment for more details).\r\n<p>\r\n<b>Only one student should submit the assignment</b>, but both student's names\r\nshould appear in the comments at the top of <b>each submitted program</b>.\r\nPlease turn in each program as you finish it, so that I can accurately assess\r\n  the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review while you work on\r\n  this assignment and before you turn in the files).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Priority Queue via Max-Heap</b></td>\r\n<td width =\"80%\">\r\nIn this program you will write a more efficient version of a priority queue, by\r\n  implementing it as a max-heap (maximum value at the root).\r\nYou can test this program with <b>TestPriorityQueue</b>, a\r\n  JUnit test (how we will ultimately grade it), and with a <b>Supermarket</b>\r\n  shopping simulation.\r\nWith the <b>DriverForOrderedCollection</b> program, you can individually test\r\n  any methods in your classes interactively, and see their results (returned\r\n  values and state changes, mostly using <b>toString</b>).\r\n<p>\r\nThe <b>HeapPriorityQueue</b> class must implement the <b>PriorityQueue</b>\r\n  interface using standard priority queue semantics (any-in/highest priority\r\n  out).\r\nYou have already implemented this behavior using linked lists.\r\nHere, the underlying data structure is a heap, which uses an array to represent\r\n  a tree compactly (so it has more similarities to the priority queue\r\n  implemented by an array than the one implemented by a linked list).\r\nIn this representation, the index of a child node can be computed from the\r\n  index of its parent node, and vice versa, by the formulas discussed in class\r\n  and reviewed below.\r\nSo, we should think \"tree\" but program \"array\".\r\n<p>\r\nBecause the main data structure is an array (even though we think \"tree\"),\r\n  you should examine the code in the <b>ArrayPriorityQueue</b> class.\r\nPay special attention to the <b>toString</b>, <b>shallowCopy</b>, \r\n  <b>ensureCapacity</b>, and <b>trimToSize</b> methods.\r\n<p>\r\nHere are some issues to think about when writing your class.\r\n<ol>\r\n  <li>Array Length/Size and Mapping:\r\n  <ul>\r\n  <li>Recall that with the \"simple mapping\" of indexes (for parent <b>i</b>,\r\n        the left child is <b>2*i</b> and the right is <b>2*i+1</b>; for\r\n        child <b>i</b> (either left or right) the parent is <b>i/2</b>)\r\n        the first node in the heap must be stored in index 1 in the array\r\n        -not in index 0.\r\n      This changes how the underlying array must be allocated, because an\r\n        array that must store <b>n</b> values must be allocated to be\r\n        size <b>n+1</b> (<b>0</b>, and the indexes <b>1</b> through <b>n</b>\r\n        to store <b>n</b> values).\r\n  <p>\r\n  <li>We can simplify array allocation (using the familiar <b>0</b> through\r\n        <b>n-1</b> allocation to store <b>n</b> values) if we make the mapping\r\n        of indexes more complex: for parent <b>i</b>, the left child is\r\n        <b>2*i+1</b> and the right is <b>2*i+2</b>; for child <b>i</b>\r\n       (either left or right) the parent is <b>(i-1)/2</b>.\r\n       Become familiar with this mapping by looking at an example heap with\r\n         10-15 values.\r\n      You may use either this mapping or the one described above.\r\n      Given the <b>ensureCapacity</b> and <b>trimToSize</b> methods work on\r\n        arrays with indexes <b>0</b> to <b>N-1</b>, <b>I recommend using the\r\n        mapping explained in this paragraph.</b>\r\n  <p>\r\n  <li>Choose which way you will represent the array and its mapping (see\r\n        above).\r\n      Not carefully allocating/using the array can be a\r\n        <b>big source of bugs</b> so be careful.\r\n      I suggest putting these mappings into four simple <b>private static</b>\r\n         methods (<b>inHeap</b>, <b>leftChild</b>, <b>rightChild</b>, and\r\n        <b>parent</b>, the first determining whether or not an index is in\r\n        the heap being stored and the final three each taking an <b>int</b>\r\n        index and returning another <b>int</b> index) to simplify your code\r\n        (by hiding the mapping details), no matter which approach  you take,\r\n         at a slight decrease in speed.\r\n      Or you can put the raw calculations directly into your code.\r\n      One interesting approach is to use the methods first, to make debugging\r\n        your code easier, and then when he code works, remove the methods and\r\n        \"hardwire\" in the calculation.\r\n      If you don't find much speed difference, why not go back to using\r\n        the methdods, because that makes the code clearer.\r\n      <p>\r\n  <p>\r\n  <li>Finally, you should also write <b>private</b> helper methods for\r\n        the following three operations, and call them wherever necessary.\r\n      <ul>\r\n         <li><b>swap</b>: called with two indexes, it swaps the values\r\n               stored in those indexes in the array representing the heap.\r\n         <li><b>percolateUp</b>: called with one index, it percolates\r\n               the value at that index as high as it should go.\r\n         <li><b>percolateDown</b>: called with one index,\r\n               percolates that value at that index as low as it should go.\r\n      </ul>\r\n      <p>\r\n      The \"percolate\" methods do most of the interesting work in maintaining\r\n        the heaps.\r\n      This code is not trivial to write, but it can be written simply: I wrote\r\n        <b>percolateUp</b> in 2 lines and <b>percolateDown</b> in 10 lines,\r\n        although some of these lines are dense).\r\n      I suggest you constantly think about simplifying your code for these\r\n        methods as an aid for writing them correctly.\r\n      <p>\r\n      Of course, to do so you must really understand what is going on during\r\n        the percolation phases (hint: hand simulation).\r\n      Recall that for the second mapping, once a value reaches index\r\n        <b>0</b>, there is no parent index to process; for a value at index\r\n        <b>i</b>, it has a left child if <b>2*i+1 &lt; objectCount</b> and it\r\n        has a right child if <b>2*i+2 &lt; objectCount</b>.\r\n      In the alternative mapping the bounds are a bit different (based on both\r\n        a different mapping and the fact that values are stored in indexes\r\n        <b>1</b> through <b>N</b> instead of <b>0</b> through <b>N-1</b>).\r\n      <p>\r\n      <b>Don't attempt to process non-existant children!</b>\r\n      This is especially true in <b>percolate</b> down where to find the\r\n        biggest child for a possible swap, we may have to check just one or\r\n        both children.\r\n  </ul>\r\n  <p>\r\n  <li>Constructors:\r\n  <ul>\r\n    <li>The first two constructors create arrays of the appropriate lengths;\r\n          remember to do this based on which mapping you are using.\r\n    <p>\r\n    <li>The array version should do the linear (offline) operation to \r\n          build a heap discussed in class, rather than adding values to the\r\n          heap one at a time.\r\n    <p>\r\n    <li>The iterable version should put all the values in a simple collection,\r\n          convert it to an array, and use the array constructor to actually\r\n          build the heap.\r\n  </ul>\r\n  <p>\r\n  <li><b>toString</b>\r\n  <ul>\r\n     <li>The <b>toString</b> method should return the heap values as an\r\n            array.\r\n         Here is an example of what my method returns (I'm using the\r\n           <b>second</b> mapping) when using the\r\n           <b>DriverForOrderedCollection</b>:<p>\r\n         &nbsp; &nbsp;<b>toString = HeapPriorityQueue[3/4:[0]=a,[1]=c,[2]=b]</b>\r\n         <p>\r\n         Here is an example of what my method <b>would</b> return if it used\r\n           the <b>first</b> mapping,\r\n            when using the <b>DriverForOrderedCollection</b>:<p>\r\n         &nbsp; &nbsp;<b>toString = HeapPriorityQueue[3/5:[0]=not used,[1]=a,[2]=c,[3]=b]</b>\r\n         <p>\r\n         Notice that this array is of length 5, because in my code the index 0\r\n           is not used (so there is room for 4 values in the heap: the heap\r\n           lengths is go from 2, 3, 5, 9, 17, etc. always 1 bigger than a\r\n           power of 2).\r\n  </ul>\r\n  <p>\r\n  <li>Iterator: <b>hasNext</b> and <b>Next</b>\r\n  <ul>\r\n     <li>Recall that the iterator should iterate through the values in\r\n           priority order (highest down to lowest).\r\n         But unlike the array and linked implementations, the heap\r\n           implementation NEVER stores all the values IN ORDER in the\r\n           array, so we cannot just \"traverse\" the array, with each call\r\n           to the <b>next</b> method taking O(1) time\r\n         Here are two ways that I can think of to implement an iterator.\r\n     <p> \r\n     <ol>\r\n     <li>When constructing the iterator, actually allocate another\r\n              array in the iterator, which contains all the values\r\n              in the heap-array; then sort it.\r\n            With this approach, creating an iterator, even if it is not used,\r\n               requires O(N Log N) time (for sorting).\r\n            Given this sorted array, you can traverse it in the iterator,\r\n              as one would traverse any array, with each call to <b>next</b>\r\n              requiring O(1) time.\r\n     <p>\r\n     <li>When constructing the iterator, actually store a SHALLOW COPY of\r\n              the <b>HeapPriorityQueue</b> in the iterator.\r\n            With this approach, creating an iterator, even if it is not used,\r\n              requires O(N) time.\r\n            Given this shallow copy, each call to <b>next</b> can call\r\n               <b>remove</b> on the copy of the heap to get the next value,\r\n               requiring O(Log N) time.\r\n            <b>shallowCopy</b> must work correctly for this method to work;\r\n               since it is copying an array, it is easy to write.\r\n     </ol>\r\n     <p>\r\n     <li>In both these approaches, the array storing the \"real\" priority queue\r\n           is different from the array storing the one being iterated through.\r\n         Constructing the iterator and iterating through all values is\r\n           O(N Log N) in each case.\r\n         Be careful: <b>don't try to use an iterator when constructing the\r\n           iterator!</b>\r\n         If you see \"infinite recursion\" or run out of storage space, this\r\n           might be your problem.\r\n  </ul>\r\n  <p>\r\n  <li>Iterator: <b>remove</b>\r\n  <ul>\r\n    <li>As you might expect, this is going to be complicated to describe (but\r\n          it turns out, not very hard to implement).\r\n        Recall that we know how to remove a value from the top of the heap:\r\n          put the value at the end of the array at the top, and swap it\r\n          down to its correct position.\r\n        We can remove a value from the \"middle\" of a heap almost as simply:\r\n          put the value at the end of the array in the \"middle\" (overwriting\r\n          the value there), and swap it <b>up or down</b> to its correct\r\n          position (depending on how it compares to its parent and children\r\n          -if any).\r\n        You might think that the value swapped to the middle will always be\r\n          less than its parent, but that is not so. \r\n        Construct an example of a heap so that the last value is greater\r\n          than the parent of the value being removed: my example was a heap\r\n          with 6 nodes (and I think it is minmal).\r\n        <p>\r\n        So, if we keep track of which value we have \"seen\", and are asked\r\n          in the iterator to remove it, we can do a linear search the REAL heap\r\n          array (not the one the iterator is using, it is gone from there if\r\n          returned by <b>next</b>), find that value (use ==; the total\r\n          operation might take O(N)), and then use this algorithm to remove it\r\n          from the REAL heap.\r\n    <p>\r\n    <li>In fact, you should discover that <b>remove</b> from the heap itself\r\n          and <b>remove</b> from the iterator share code that can be made into\r\n          a parameterized <b>private</b> method, usable in both places (for\r\n          precolate up/down to the correct position: see <b>percolateUp</b>\r\n          and <b>percolateDown</b> described in the first section of this\r\n          document).\r\n    <p>\r\n    <li>Implement <b>next</b> and <b>hasNext</b> first, and <b>remove</b> at\r\n          very end.\r\n        Feel free to ask questions to help you understand -which is just one\r\n          of many things questions are for.\r\n  </ul>\r\n</ol>\r\nIf you have problems getting the iterator correct (or just before you implement\r\n  it), test the other methods with <b>DriverForOrderedCollection</b>.\r\nRecall the JUnit test does most of its testing using the <b>toArray</b>\r\n  method, which will not work unless the iterator works.\r\n<p>\r\nFinally, try running the supermarket simulation program with the\r\n  <b>ArrayPriorityQueue</b> and your working <b>HeapPriorityQueue</b>.\r\nChoose 2 checkout lines: one with the default number of times (effectively\r\n  infinite) and one with 6 or fewer items.\r\nRun the simulation on 5 shoppers with tracing set to <b>true</b> to help\r\n  you understand what is happening; then run it with 50,000 or 100,000\r\n  shoppers.\r\nWith 50,000 shoppers, my speedup using the <b>HeapPriorityQueue</b> over the\r\n  <b>ArrayPriorityQueue</b> was from 24 seconds to 1.27 seconds.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 2 -->\r\n\r\n<a name=\"problem2\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2: Map via BST</b></td>\r\n<td width =\"80%\">\r\nIn this program you will write a more efficient version of a map, by\r\n  implementing it as a binary search tree.\r\nWe have seen that for all but pathological trees (and randomly built trees are\r\n  much closer to being well-balanced than pathological), most operations\r\n  operations have a complexity of O(Log N); we can say O(tree-height) to\r\n  play it safe.\r\n<p>\r\nYou can test this program with <b>TestMap</b>, a JUnit test (how we will\r\n  ultimately grade it), and with an updated version of the\r\n  <b>WordGenerator</b> program (included in the download) from Program #1\r\n   part 6, on the file <b>huck.txt</b> (also included in the download).\r\nWith the <b>DriverForMap</b> program, you can individually test\r\n  any methods in your classes interactively, and see their results (returned\r\n  values and state changes, mostly using <b>toString</b>).\r\nI will supply a <b>toString</b> method that uses recursion to return a\r\n  <b>String</b> that prints as a tree rotated 90 degress to the left, so you\r\n  can more easily see the structure of the tree you are building.\r\n<p>\r\nBefore running the JUnit test, you must get the iterator's <b>hasNext</b> and\r\n <b>next</b> methods working correctly.\r\nOtherwise many tests will fail, because many tests use the iterator indirectly:\r\n  e.g., they construct sets of values by iterating through maps; if the\r\n  iterator works incorrectly, these sets will not be constructed correctly,\r\n  and the JUnit test will fail for this reason, not because the operations\r\n  <i>really</i> being tested are incorrect.\r\n<p>\r\nThe <b>BSTMap</b> class must implement the <b>Map</b> interface using\r\n  standard map semantics.\r\nYou should look at my <b>ArrayMap</b> class, which contains code that\r\n  implements the same <b>Map</b> interface, some of which (or code like\r\n  it) will belong in the BST implementation.\r\nHere, the underlying data structure is a binary search tree, whose node\r\n  class is complete within the implementation, which also includes some helper\r\n  methods like <b>locate</b>, <b>add</b>, and <b>remove</b>; these are either\r\n  completley written or just their header is specified.\r\n<p>\r\nHere are some issues to think about when writing your class.\r\n<ol>\r\n  <li>Multiple Tree \"Searches\"\r\n  <ul>\r\n  <li>Because recursive helper methods that mutate the BST, like <b>insert</b>,\r\n        must return a </b>BST</b> node, I found it convenient to first call the\r\n        <b>locate</b> helper method, and based on the result, call (or not\r\n        call) one of the recursive mutator method: sometimes I can manipulate\r\n        the located reference directly.\r\n      For example, in my <b>put</b> method, my code first tries to locate the\r\n        key in the tree: if successful, my code changes the value associated\r\n        with that key (not changing the structure of the tree); if it fails,\r\n        my code inserts a new entry into the tree, with the appropriate\r\n        key and value.\r\n  <p>\r\n  <li>At worst, these two searches slow down some methods (i.e., <b>put</b>, \r\n        <b>remove</b> in the map, <b>remove</b> in the iterator) by a factor\r\n        of two.\r\n      There is a way to squeeze a bit more speed out of the code, by avoiding\r\n        duplicate searches. \r\n      But, to do so required carefully changing the recursive methods and\r\n        using another instance variable.\r\n      I suggest that you code using the \"double search\" approach, until you\r\n        have everything working; then, if you have the inclination and some\r\n        more time, if you explore writing the more complicated code; \r\n        wait until then to even start thinking about this improvement.\r\n      The number of changes are small, but they are high in technical\r\n        complexity.\r\n  </ul>\r\n  <p>\r\n  <li><b>Map.Entry</b>\r\n  <ul>\r\n     <li>Recall that <b>Map</b> interface defines the <b>Entry</b> interface,\r\n           which we refer to as <b>Map.Entry</b>.\r\n         When we build our tree, we need to use a class that implements\r\n           <b>Map.Entry</b> at each node.\r\n         Note that the <b>AbstractMap</b> class (which all classes that\r\n           implement <b>Map</b> use as a superclass), defines a concrete class\r\n           called <b>SimpleEntry</b> which implements <b>Map.Entry</b>.\r\n         So, our code can construct and use <b>SimpleEntry</b> objects (see its\r\n           constructor).\r\n  </ul>\r\n  <p>\r\n  <li><b>toString</b>\r\n  <ul>\r\n     <li>I have written a <b>toString</b> method that returns a 2-d \"picture\"\r\n           of the BST (rotated left by 90 degrees)\r\n         It is usefull for quickly quickly looking at a small BST.\r\n         Here is an example of what my method returns when using the\r\n         <b>DriverForMap</b>, showing 5 keys and their values.\r\n<p>\r\n<b><pre>toString = BSTMap[5:\r\n    x->5\r\n  m->4\r\n      c->3\r\n    b->2\r\n      a->1\r\n  ]</pre></b>\r\n          Here <b>m</b> is the root, with 3 nodes in its left subtree\r\n          (whose root key is <b>b</b>) and 1 node in it right subtree\r\n          (whose root key is <b>x</b>).\r\n  <p>\r\n  </ul>\r\n  <li>Iterator: <b>hasNext</b> and <b>Next</b>\r\n  <ul>\r\n  <li>As in the heap priority queue, the iterator for this class\r\n        will iterate through another data structure: in this case a\r\n        <b>Stack</b>: it's maximum size will be the height of the tree.\r\n      We discussed this kind of iterator at the end of the notes covering\r\n        Binary Search Trees and in class.\r\n      I'll summarize the algorithm below; see the notes for details.\r\n      <p>\r\n      To construct the iterator, allocate a <b>Stack</b> (use an\r\n        <b>ArrayStack</b> data structure) and add to it the root (if the BST\r\n        isn't empty) and all the <b>left</b> descendants of the root.\r\n      <p>\r\n      <b>hasNext</b> returns whether the <b>Stack</b> is empty.\r\n      <b>next</b> removes and returns the reference at the top of the\r\n        <b>Stack</b> and adds to the <b>Stack</b> the root of its right subtree\r\n        (if it isn't empty) and all the <b>left</b> descendants of the root of\r\n        its right subtree (see the code you wrote in the constructor).\r\n      It also remembers this reference, in case the iterator's <b>remove</b> is\r\n        called</b>.\r\n  <p>\r\n  <li>Iterator: <b>remove</b>\r\n  <ul>\r\n  <li>Use the <b>removeAt</b> method to delete from the BST the previous value\r\n        returned by <b>next</b>.\r\n      This operation does not affect the <b>Stack</b>.\r\n<!---\r\nThis actually works OK, but in a very convoluted way\r\n      <p>\r\n      <b>Note:</b> When a node's value is deleted from the tree, if the node\r\n        has two children it's value must be replaced by the biggest value less\r\n        than it; <b>NOT</b> by the smallest values greater than it.\r\n      The delete code that I have written in the dowload does this replacement.\r\n      Although each of these possibilities results in a BST, only in the first\r\n        case will the iterator continue correctly.\r\n      Here is why.\r\n      <p>\r\n      Generally:\r\n      The deleted node has been iterated over, and the biggest value less than\r\n        it has also already been iterated over, but the smallest value greater\r\n        than it has not been iterated over.\r\n      If we replace the deleted node's value with the the smallest value\r\n        greater than it, the <b>Stack</b> being used for the iterator will\r\n        not be correct for continuing the iteration, in the case where the node\r\n        with this value (the smallest value greater than the removed value) has\r\n        a right subtree.\r\n      <p>\r\n      Specifically:\r\n      Add the values 10, 5, 20, 15, and 17 (in this order) to create a BST.\r\n      Use the iterator to iterate through this BST and after <b>next</b>\r\n        returns 10 (the root) call the iterator's <b>remove</b>.\r\n      At this point, the <b>Stack</b> will contain 20 below 15.\r\n      If we replace the value 10 in the root with the value 15 (the smallest\r\n        one greater than 10), the value 17 will not be iterated over.\r\nOK, actually it will, but in a very convoluted way\r\n--->\r\n  </ul>\r\n\r\n</ol>\r\n<p>\r\nYou should also run the updated <b>WordGenerator</b> program, with the large\r\n   text file (<b>huck.txt</b>)\r\nThe update allows you to \"comment\" out code to select either the\r\n  <b>ArrayMap</b> or <b>BSTMap</b> (and its appropriate comparator):\r\n  it is that simple to change which data structure implements the data\r\n  type.\r\nIt also tracks and prints the amount of time needed to build the map: on\r\n  my machine it took 18 minutes using <b>ArrayMap</b> and 1 second using\r\n  <b>BSTMap</b> (a speed-up of a factor of over 1,000), when I used an order\r\n  statistic of 3.\r\nBoth ultimately producing a map that contains 90,705 keys with each key\r\n  mapping to a list of between 1 and 46 words.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 33284.0}