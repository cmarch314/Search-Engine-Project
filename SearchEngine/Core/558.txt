{"text": "Pointers and Memory Allocation When declaring a variable the type given is the type of any expression which looks like the declaration Thus if we have the declarations int a b c d then in the code the expressions a b c and d would all evaluate to an integer Encountering the declaration you might have a hard time figuring out that d is an array of pointers to functions which return integer pointers but you do know what type it will evaluate to when used in the context given Thus you know that the statement a d 5 x y will place an integer in a even if you are not sure what happened You could similarly match types by stripping off matching levels of indirections b d 5 x y would store an integer pointer in b rather than the value of the integer Although the expression given in the declaration is generally the correct way to use the variable the relation between pointers and arrays allows for other uses Since an array name is just a pointer we can actually use the expressions b and c as well Using the alternate notation is often confusing but occasionally more clear For example the sixth element of an array declared by either of the two methods mentioned above can be accessed in either of the two following methods b 5 or b 5 Recall that the monadic operator merely takes the value at the right and performs one level of indirection on it The second method adds 5 size of the array element type to the address of array resulting in a pointer to the sixth element and then the causes an indirection on that address resulting in the value stored there The subscripted notation is merely shorthand for this For a lab your testing programs might know that the input is restricted to 1 digits but your multiplier should not know this Thus you will need to allocate one dimensional arrays of unpredictable size within these functions To do this use the system library function malloc which will give you a specified number of contiguous bytes of memory You must first in your declarations tell the compiler the type of the return value of malloc with the declaration along with your variable declarations char malloc Now let s say you want an array of 1 integers Let A be an integer pointer declared int A To get the array use the command A int malloc 1 sizeof int The sizeof function is expanded by the compiler to be the number of bytes in one element of the type given as the argument Thus if there are 4 bytes in an integer malloc will return 4 bytes beginning on a double word boundary to guarantee proper alignment of multiple byte objects you don t need to worry about this The int preceeding the function call is called a cast This changes the type of the return of malloc which is a character pointer into an integer pointer so that it may be stored in A Often casts only affect the compiler s internal representation of what a type is but occasionally they generate code to physically modify data so you should almost always use them when mixing things of differing types Always make sure after calling malloc that you actually got the space you requested Malloc will return a null pointer if it could not get you the space A null pointer can be represented in your code as a zero or as NULL if you include the standard I O file stdio h Finally the function free is used to return space to the operating system which was allocated by malloc You should give as a parameter to free exactly the pointer given to you by malloc You cannot give back part of an allocation Thus there should be exactly as many calls to free as to malloc and they should involve exactly the same blocks of memory Multi dimensional arrays C uses two implementations of arrays depending on the declaration They are the same for one dimension but different for more dimensions For example if an array is declared as int array 1 2 3 than there are exactly 6 ints of storage allocated and a reference of the form array i j k will be translated to array i 2 3 j 3 k which calculates the correct offset from the pointer array and then does an indirection on it To pass an array of this type to a procedure you must declare the parameter as proc arg int arg 2 3 You may declare the value of the first dimension but the compiler doesn t care since it is not needed You will probably not be using this kind of array since you don t have constant bounds on the sizes of any of your arrays The second type of array is a pointer vector structure where each dimension is represented by a vector of pointers of objects of the next dimension except the last dimension which consists of arrays of data This sounds like a mess but it really isn t If a three dimensional array is declared as int array and we will assume for the moment that it has been allocated space for a 1 2 3 array then there is an array of 1 pointers to pointers to ints 1 arrays of 2 pointers to ints and 6 ints The 2 elements of the 1 arrays each point to a block of 3 ints and the 1 elements of the one array each point to one of the 1 arrays The array variable points to the head of the array with 1 elements In short array points to a pointer to a pointer to an integer array points to a pointer to an integer array points to an integer and array is an integer In this case an access of the form array i j k results in an access of the form array i j k Which means Take a pointer to the main array add i to offset to the pointer to the correct second dimension array and indirect to it Now we have a pointer to one of the arrays of 2 pointers and we add j to get the offset to the next dimension and we do an indirection on that We now have a pointer to an array of 3 integers so we add k to get a pointer to the desired integer do an indirection and we have the integer Passing arrays of this type is simple you declare the parameter the same way as int arrayname Now the fun begins how to allocate memory for a pointer vector array We get memory with the function char malloc nbytes malloc returns a character pointer to a contiguous block of nbytes bytes or a NULL pointer NULL is defined in the library package stdio h if it cannot get the space As before we will assume that the variable is defined as int array and we want the dimensions to be 1 2 3 all of the stuff below could be done for an arbitrary i j k which is closer to what you need First we need an array of 1 int s so we use the following array int malloc 1 sizeof int The sizeof function returns an integer telling how many bytes are needed by something of type int and we need 1 of them The int is a cast which changes the pointer type from char to int to keep the types correct Don t forget that after this call to malloc you should check to see if array NULL Note malloc is asked for 1 int s but its return is a pointer to them so the result is an int Now that we have the 1 pointers we can get the next level of pointers for i i 1 i array i int malloc 2 sizeof int And finally we can fill in each of these pointers with an array of 3 integers for i i 1 i for j j 2 j array i j int malloc 3 sizeof int Again remember that each call to malloc must check the result Also note that we could have put the two steps above together filling each set of 2 pointers as we get them It is much more efficient to combine all similar allocations and divide up the memory after getting it It is also much easier to make mistakes When you ve convinced yourself the the following works you will understand C pointers fairly well array int malloc 1 sizeof int array int malloc 1 2 sizeof int array int malloc 1 2 3 sizeof int for j 1 j 2 j array j array j 1 3 for i 1 i 1 i array i array i 1 2 array i array i 1 2 1 3 for j 1 j 2 j array i j array i j 1 3 This is the method you should use but you will probably only need two dimensional arrays which are far easier once you understand this example Space is returned to the system with the command free pointer For returning the space to the system you always return exactly what you were given i e the exact pointer that malloc gave you You cannot return a portion of an allocation Thus there should be a perfect one to one correspondence between calls to malloc and calls to free Dan Hirschberg Computer Science Department University of California Irvine CA 92697 3435 dan at ics uci edu Last modified Jan 26 2 1 ", "_id": "http://www.ics.uci.edu/~dan/class/165/notes/memory.html", "title": " pointers and memory allocation\n", "html": "<HTML><HEAD>\n<TITLE> Pointers and Memory Allocation\n</TITLE>\n</HEAD><BODY>\n\n<H2> Pointers and Memory Allocation </H2>\n\nWhen declaring a variable, the type given is the type of any expression\nwhich looks like the declaration.  Thus, if we have the declarations\n<center>\n<tt>    int a, *b, c[], *(*d[])();</tt>\n</center>\nthen, in the code, the expressions\n<tt>a</tt>, <tt>*b</tt>, <tt>c[]</tt> and <tt>*(*d[])()</tt>\nwould all evaluate to an integer.&nbsp;\nEncountering the declaration, you might\nhave a hard time figuring out that <tt>d</tt> is an\narray of pointers to functions which return integer pointers,\nbut you <I>do</I> know what type it will evaluate to\nwhen used in the context given.&nbsp;\nThus you know that the statement\n<tt>a = *(*d[5])(x, y)</tt>\nwill place an integer in <tt>a</tt>, even if you are not\nsure what happened.&nbsp;\nYou could similarly match types by stripping\noff matching levels of indirections:&nbsp;\n<tt>b = (*d[5])(x, y)</tt> would store\nan integer pointer in <tt>b</tt> rather than the value of the integer.\n<P>\nAlthough the expression given in the declaration is generally the\n<I>correct</I> way to use the variable,\nthe relation between pointers and arrays allows for other uses.&nbsp;\nSince an array name is just a pointer, we can actually use the\nexpressions <tt>b[]</tt> and <tt>*c</tt> as well.&nbsp;\n(Using the alternate notation is\noften confusing but occasionally more clear.)&nbsp;\nFor example, the sixth\nelement of an array, declared by either of the two methods mentioned\nabove, can be accessed in either of the two following methods:&nbsp;\n<center>\n<tt>    b[5]</tt> &nbsp; or &nbsp; <tt>*(b+5)</tt>\n</center>\n(Recall that the monadic \"<tt>*</tt>\" operator merely takes the\nvalue at the right and performs one level of indirection on it.)\nThe second method adds 5*(size of the array element type) to the address\nof array, resulting in a pointer to the sixth element, and then the \"*\"\ncauses an indirection on that address, resulting in the value stored\nthere.  The subscripted notation is merely shorthand for this.\n<P>\nFor a lab, your testing programs might know that the input is restricted\nto 1000 digits, but your multiplier should not know this.&nbsp;\nThus, you will need to allocate one-dimensional arrays of unpredictable\nsize within these functions.&nbsp;\nTo do this, use the system library\nfunction <I>malloc</I> which will give you a specified number of\ncontiguous bytes of memory.&nbsp;\nYou must first, in your declarations,\ntell the compiler the type of the return value of\n<I>malloc</I> with the\ndeclaration (along with your variable declarations):&nbsp;\n<center>\n<tt>char *malloc();</tt>\n</center>\n<P>\nNow, let's say you want an array of 10 integers.&nbsp;\nLet <tt>A</tt> be\nan integer pointer (declared <tt>int *A</tt>).&nbsp;\nTo get the array, use the command:\n<center>\n<tt>    A = (int *) malloc( 10 * sizeof(int) );</tt>\n</center>\nThe <tt>sizeof()</tt> function is expanded by the compiler to be the\nnumber of bytes in one element of the type given as the argument.&nbsp;\nThus, if there are 4 bytes in\nan integer, <I>malloc</I> will return 40 bytes\n(beginning on a double-word\nboundary to guarantee proper alignment of multiple-byte objects -- you\ndon't need to worry about this).\n<P>\nThe <tt>(int *)</tt> preceeding the function call is called a\n<I>cast</I>.\nThis changes the\ntype of the return of <I>malloc</I>\n(which is a character pointer) into an\ninteger pointer so that it may be stored in <tt>A</tt>.&nbsp;\nOften casts only\naffect the compiler's internal representation of what a type is but\noccasionally they generate code to physically modify data, so you should\nalmost always use them when mixing things of differing types.\n<P>\nAlways make sure, after calling <I>malloc</I>, that you actually got the\nspace you requested.&nbsp;\n<I>Malloc</I> will return a null pointer if it could not\nget you the space.&nbsp;\nA null pointer can be represented in your code as a\nzero, or as <tt>NULL</tt>\nif you include the standard I/O file <tt>&lt;stdio.h&gt;</tt>.\n<P>\nFinally, the function <I>free</I> is used to return space to the\noperating system which was allocated by <I>malloc</I>.&nbsp;\nYou should give,\nas a parameter, to <I>free</I> exactly the pointer given to you by\n<I>malloc</I>.&nbsp;\nYou cannot give back part of an allocation.&nbsp;\nThus there\nshould be exactly as many calls to <I>free</I> as to <I>malloc</I>, and\nthey should involve exactly the same blocks of memory.\n<P>\n<H3> Multi-dimensional arrays </H3>\n\nC uses two implementations of arrays, depending on the declaration.\nThey are the same for one dimension, but different for more dimensions.\n<P>\nFor example, if an array is declared as\n<center>\n<tt>int array[10][20][30];</tt>\n</center>\nthan there are exactly 6000 ints of storage allocated, and a reference\nof the form <tt>array[i][j][k]</tt> will be translated to\n<center>\n<tt>*( array + i*20*30 + j*30 + k )</tt>\n</center>\nwhich calculates the correct offset from the pointer \"array\", and then\ndoes an indirection on it.  To pass an array of this type to a\nprocedure, you must declare the parameter as\n<center>\n<tt>proc( arg ) int arg[][20][30];</tt>\n</center>\n(You may declare the value of the first dimension, but the compiler\ndoesn't care since it is not needed.)\n<P>\nYou will probably not be using this kind of array, since you don't have\nconstant bounds on the sizes of any of your arrays.\n<P>\nThe second type of array is a pointer-vector structure, where each\ndimension is represented by a vector of pointers of objects of the next\ndimension, except the last dimension, which consists of arrays of data.\nThis sounds like a mess, but it really isn't:\n<P>\nIf a three-dimensional array is declared as\n<center>\n<tt>int ***array;</tt>\n</center>\n(and we will assume for the moment that it has been allocated space\nfor a 10*20*30 array), then there is an array of 10 pointers to pointers\nto ints, 10 arrays of 20 pointers to ints, and 6000 ints.&nbsp;\nThe 200 elements of the 10 arrays each point to a block of 30 ints,\nand the 10 elements of the one array each point\nto one of the 10 arrays.&nbsp;\nThe array variable points to the head of the array with 10 elements.\n<P>\nIn short,\n\"<tt>array</tt>\" points to a pointer to a pointer to an integer,\n\"<tt>*array</tt>\" points to a pointer to an integer,\n\"<tt>**array</tt>\" points to an integer, and\n\"<tt>***array</tt>\" is an integer.\n<P>\nIn this case, an access of the form <tt>array[i][j][k]</tt>\nresults in an access of the form\n<center>\n<tt>*( *( *(array+i) + j ) + k )</tt>\n</center>\n<P>\nWhich means:&nbsp;\nTake a pointer to the main array, add <tt>i</tt> to offset to the\npointer to the correct second dimension array and indirect to it.&nbsp;\nNow we have a pointer to one of the arrays of 20 pointers,\nand we add <tt>j</tt> to get the offset to the next dimension,\nand we do an indirection on that.&nbsp;\nWe now have a pointer to an array of 30 integers,\nso we add <tt>k</tt> to get a pointer to the desired integer,\ndo an indirection, and we have the integer.\n<P>\nPassing arrays of this type is simple,\nyou declare the parameter the same way, as \"<tt>int ***arrayname</tt>\".\n<P>\nNow the fun begins:&nbsp; how to allocate memory for a pointer-vector\narray.&nbsp;  We get memory with the function\n<center>\n<tt>char *malloc( nbytes );</tt>\n</center>\n<I>malloc</I> returns a character pointer to a contiguous block of\n<I>nbytes</I> bytes, or a <tt>NULL</tt> pointer\n(<tt>NULL</tt> is defined in the library package\n<tt>&lt;stdio.h&gt;</tt>) if it cannot get the space.\n<P>\nAs before, we will assume that the variable is defined as\n<center>\n<tt>int ***array;</tt>\n</center>\nand we want the dimensions to be 10*20*30 (all of the stuff below could\nbe done for an arbitrary i,j,k, which is closer to what you need).\n<P>\nFirst, we need an array of 10 <tt>int **</tt>'s,\nso we use the following:\n<center>\n<tt>array = (int ***) malloc( 10 * sizeof(int **) );</tt>\n</center>\nThe <I>sizeof</I> function returns an integer telling how many bytes\nare needed by something of type \"<tt>int **</tt>\",\nand we need 10 of them.&nbsp;\nThe \"<tt>(int ***)</tt>\" is a cast which changes the pointer type\nfrom \"<tt>char *</tt>\" to \"<tt>int ***</tt>\",\nto keep the types correct.&nbsp;\nDon't forget that, after this\ncall to <I>malloc</I>, you should check to see if <tt>array==NULL</tt>.\n<P>\nNote:&nbsp; <I>malloc</I> is asked for 10 <tt>int **</tt>'s\nbut its return is a pointer to them,\nso the result is an <tt>int ***</tt>.\n<P>\nNow that we have the 10 pointers, we can get the next level of\npointers:\n<pre>\n\tfor ( i = 0 ; i < 10 ; ++i ) {\n\t    array[i] = (int **) malloc( 20 * sizeof(int *) );\n\t}\n</pre>\nAnd finally, we can fill in each of these pointers with an array of 30\nintegers:\n<pre>\n\tfor ( i = 0 ; i < 10 ; ++i ) {\n\t    for ( j = 0 ; j < 20 ; ++j ) {\n\t\tarray[i][j] = (int *) malloc( 30 * sizeof(int) );\n\t    }\n\t}\n</pre>\nAgain, remember that each call to malloc must check the result.&nbsp;\nAlso note that we could have put the two steps above together,\nfilling each set of 20 pointers as we get them.\n<P>\nIt is <I>much</I> more efficient to combine all similar allocations\nand divide up the memory after getting it.&nbsp;\n(It is also <I>much</I> easier to make mistakes.)&nbsp;\nWhen you've convinced yourself the the following works, you will\nunderstand C pointers fairly well.\n<P>\n<pre>\n\tarray = (int ***) malloc( 10 * sizeof(int **) );\n\tarray[0] = (int **) malloc( 10 * 20 * sizeof( int *) );\n\tarray[0][0] = (int *) malloc( 10 * 20 * 30 * sizeof(int) );\n\tfor ( j = 1  ;  j < 20  ;  ++j ) {\n\t    array[0][j] = array[0][j-1] + 30;\n\t}\n\tfor ( i = 1  ;  i < 10  ;  ++i ) {\n\t    array[i] = array[i-1] + 20;\n\t    array[i][0] = array[i-1][20-1] + 30;\n\t    for ( j = 1  ;  j < 20  ;  ++j ) {\n\t\tarray[i][j] = array[i][j-1] + 30;\n\t    }\n\t}\n</pre>\n<P>\nThis is the method you should use, but you will probably only need two\ndimensional arrays,\nwhich are far easier once you understand this example.\n<P>\nSpace is returned to the system with the command\n<center>\n<tt>free( pointer );</tt>\n</center>\n<P>\nFor returning the space to the system, you <I>always</I>\nreturn exactly what\nyou were given, <I>i.e.</I>,\nthe exact pointer that <I>malloc</I> gave you.&nbsp;\nYou cannot return a portion of an allocation.&nbsp;\nThus there should be a perfect \none-to-one correspondence between calls to <I>malloc</I>\nand calls to <I>free</I>.\n<P>\n<HR>\n<ADDRESS>\n<A HREF=\"http://www.ics.uci.edu/~dan\">\nDan Hirschberg </A> <BR>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3435<BR>\n</ADDRESS>\n<tt>dan (at) ics.uci.edu</tt><br>\nLast modified: Jan 26, 2010\n</BODY></HTML>\n", "id": 558.0}