{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 312D Triangulations Mariette Yvinec This chapter describes the two dimensional triangulations of CGAL Section recalls the main definitions about triangulations Sections discusses the way two dimensional triangulations are represented in CGAL Section presents the overall software design of the 2D triangulations package The next sections present the different two dimensional triangulations classes available in CGAL basic triangulations section Delaunay triangulations Section regular triangulations Section constrained triangulations Section and constrained Delaunay triangulations Section Section describes a class which implements a constrained or constrained Delaunay triangulation with an additionnal data structure to describe how the constraints are refined by the edges of the triangulations Section describes a hierarchical data structure for fast point location queries At last Section explains how the user can benefit from the flexibility of CGAL triangulations using customized classes for faces and vertices 31 1 Definitions A two dimensional triangulation can be roughly described as a set T of triangular facets such that two facets either are disjoint or share a lower dimensional face edge or vertex the set of facets in T is connected for the adjacency relation the domain UT which is the union of facets in T has no singularity More precisely a triangulation can be described as a simplicial complex Let us first record a few definitions A simplicial complex is a set T of simplices such that any face of a simplex in T is a simplex in T two simplices in T either are disjoint or share a common subface The dimension d of a simplicial complex is the maximal dimension of its simplices A simplicial complex T is pure if any simplex of T is included in a simplex of T with maximal dimension Two simplexes in T with maximal dimension d are said to be adjacent if they share a d 1 dimensional subface A simplicial complex is connected if the adjacency relation defines a connected graph over the set of simplices of T with maximal dimension The union UT of all simplices in T is called the domain of T A point p in the domain of T is said to singular if its surrounding in UT is neither a topological ball nor a topological disc Then a two dimensional triangulation can be described as a two dimensional simplicial complex that is pure connected and without singularity Each facet of a triangulation can be given an orientation which in turn induces an orientation on the edges incident to that facet The orientation of two adjacent facets are said to be consistent if they induce opposite orientations on their common incident edge A triangulation is said to be orientable if the orientation of each facet can be chosen in such a way that all pairs of incident facets have consistent orientations The data stucture underlying CGAL triangulations allows to represent the combinatorics of any orientable two dimensional triangulations without boundaries On top of this data structure the 2D triangulations classes take care of the geometric embedding of the triangulation and are designed to handle planar triangulations The plane of the tiangulation may be embedded in a higher dimensional space The triangulations of CGAL are complete triangulations which means that their domain is the convex hull of their vertices Because any planar triangulation can be completed this is not a real restriction For instance a triangulation of a polygonal region can be constructed and represented as a subset of a constrained triangulation in which the region boundary edges have been input as constrained edges see Section and Strictly speaking the term face should be used to design a face of any dimension and the two dimensional faces of a triangulation should be properly called facets However following a common usage we hereafter often call faces the facets of a two dimensional triangulation 31 2 Representation The set of faces A 2D triangulation of CGAL can be viewed as a planar partition whose bounded faces are triangular and cover the convex hull of the set of vertices The single unbounded face of this partition is the complementary of the convex hull In many applications such as Kirkpatrick s hierarchy or incremental Delaunay construction it is convenient to deal with only triangular faces Therefore a fictitious vertex called the infinite vertex is added to the triangulation as well as infinite edges and infinite faces incident to it Each infinite edge is incident to the infinite vertex and to a vertex of the convex hull Each infinite face is incident to the infinite vertex and to a convex hull edge Therefore each edge of the triangulation is incident to exactly two faces and the set of faces of a triangulation is topologically equivalent to a two dimensional sphere This extends to lower dimensional triangulations arising in degenerate cases or when the triangulations as less than three vertices Including the infinite faces a one dimensional triangulation is a ring of edges and vertices topologically equivalent to a 1 sphere A zero dimensional triangulation whose domain is reduced to a single point is represented by two vertices that is topologically equivalent to a sphere Note that the infinite vertex has no significant coordinates and that no geometric predicate can be applied on it nor on an infinite face Figure Infinite vertex and infinite faces A representation based on faces and vertices Because a triangulation is a set of triangular faces with constant size complexity triangulations are not implemented as a layer on top of a planar map CGAL uses a proper internal representation of triangulations based on faces and vertices rather than on edges Such a representation saves storage space and results in faster algorithms BDTY The basic elements of the representation are vertices and faces Each triangular face gives access to its three incident vertices and to its three adjacent faces Each vertex gives access to one of its incident faces and through that face to the circular list of its incident faces The three vertices of a face are indexed with 1 and 2 in counterclockwise order The neighbor of a face are also indexed with 1 2 in such a way that the neighbor indexed by i is opposite to the vertex with the same index See Figure the functions ccw i and cw i shown on this figure compute respectively i 1 and i 1 modulo 3 The edges are not explicitly represented they are only implicitely represented through the adjacency relations of two faces Each edge has two implicit representations the edge of a face f which is opposed to the vertex indexed i can be represented as well as an edge of the neighbor i of f Figure Vertices and neighbors 31 3 Software Design The triangulations classes of CGAL provide high level geometric functionalities such as location of a point in the triangulation insertion or removal of a point They are build as a layer on top of a data structure called the triangulation data structure The triangulation data structure can be thought of as a container for the faces and vertices of the triangulation This data structure also takes care of all the combinatorial aspects of the triangulation This separation between the geometric aspect and the combinatorial part is reflected in the software design by the fact that the triangulation classes have two template parameters the first parameter stands for a geometric traits class providing the geometric primitives points segments and triangles of the triangulation and the elementary operations predicate or constructions on those objects the second parameter stands for a triangulation data structure class The concept of triangulation data structure is described in Section of Chapter The triangulation data structure defines the types used to represent the faces and vertices of the triangulation as well as additionnal types handles iterators and circulators to access and visit the faces and vertices CGAL provides the class Triangulation data structure 2 Vb Fb as a default model of triangulation data structure The class Triangulation data structure 2 Vb Fb has two template parameters standing for a vertex base class and a face base class from which the vertex and face classes are respectively derived CGAL defines concepts for these template parameters and provide default models for these concepts The vertex and base classes are templated by the geometric traits which allows them to have some knowledge of the geometric primitives of the triangulation Those default vertex and face base classes can be replaced by user customized base classes in order for example to deal with additionnal properties attached to the vertices or faces of a triangulation See section for more details on the way to make use of this flexibility The Figure summarizes the design of the triangulation package showing the three layers base classes triangulation data structure and triangulation forming this design Figure The triangulations software design The top triangulation level responsible for the geometric embedding of the triangulation comes in different flavors according to the different kind of triangulations basic Delaunay regular constrained or constrained Delaunay Each kind of triangulations correspond to a different class Figure summarizes the derivation dependancies of CGAL 2D triangulations classes Any 2D triangulation class is parametrized by a geometric traits and a triangulation data structure While a unique concept TriangulationDataStructure 2 describes the triangulation data structure requirements for any triangulation classes the concept of geometric traits actually depends on the triangulation class In general the requirements for the vertex and face base classes are described by the basic concepts TriangulationVertexBase 2 and TriangulationFaceBase 2 However some triangulation classes requires base classes implementing refinements of the basic concepts Figure The derivation tree of 2D triangulations 31 4 Basic Triangulations 31 4 1 Description The class Triangulation 2 Traits Tds serves as a base class for the other 2D triangulations classes and implements the user interface to a triangulation The vertices and faces of the triangulations are accessed through handles iterators and circulators A handle is a model of the concept Handle which basically offers the two dereference operators and A circulator is a type devoted to visit circular sequences Handles are used whenever the accessed element is not part of a sequence Iterators and circulators are used to visit all or parts of the triangulation The iterators and circulators are all bidirectional and non mutable The circulators and iterators are convertible to the handles with the same value type so that when calling a member function any handle type argument can be replaced by an iterator or a circulator with the same value type The triangulation class allows to visit the vertices and neighbors of a face in clockwise or counterclockwise order There are circulators to visit the edges or faces incident to a given vertex or the vertices adjacent to it Another circulator type allows to visit all the faces traversed by a given line Circulators step through infinite features as well as through finite ones The triangulation class offers some iterators to visit all the faces edges or vertices and also iterators to visit selectively the finite faces edges or vertices The triangulation class provides methods to test the infinite character of any feature and also methods to test the presence in the triangulation of a particular feature edge or face given its vertices The triangulation class provides a method to locate a given point with respect to a triangulation In particular this method reports wether the point coincides with a vertex of the triangulation lies on an edge in a face or outside of the convex hull In case of a degenerate lower dimensional triangulation the query point may also lie outside the triangulation affine hull The triangulation class also provides methods to locate a point with respect to a given finite face of the triangulation or with respect to its circumcircle The faces of the triangulation and their circimcircles have the counterclockwise orientation The triangulation can be modified by several functions insertion of a point removal of a vertex flipping of an edge The flipping of an edge is possible when the union of the two incident faces forms a convex body see Figure Figure Flip Implementation Locate is implemented by a line walk The walk begins at a vertex of the face which is given as an optional argument or at an arbitrary vertex of the triangulation if no optional argument is given It takes time O n in the worst case but only O sqrt n on average if the vertices are distributed uniformly at random The class Triangulation hierarchy 2 Traits Tds described in section implements a data structure designed to offer an alternate more efficient point location algorithm Insertion of a point is done by locating a face that contains the point and splitting this face into three new faces If the point falls outside the convex hull the triangulation is restored by flips Apart from the location insertion takes a time O 1 This bound is only an amortized bound for points located outside the convex hull Removal of a vertex is done by removing all adjacent triangles and retriangulating the hole Removal takes a time at most proportionnal to d 2 where d is the degree of the removed vertex which is O 1 for a random vertex The face edge and vertex iterators on finite features are derived from their counterparts visiting all finite and infinite features which are themselves derived from the corresponding iterators of the triangulation data structure Geometric Traits The geometric traits of a triangulation is required to provide the geometric objects points segments and triangles building up the triangulation together with the geometric predicates on those objects The required predicates are comparison of the x or y coordinates of two points the orientation test which computes the order type of three given point The concept TriangulationTraits 2 describes the requirements for the geometric traits class of a triangulation The CGAL kernel classes are models for this concept The CGAL library also provides dedicated models of TriangulationTraits 2 using the kernel geometric objects and predicates These classes are themselves templated with a CGAL kernel and extract the required types and predicates from the kernel The traits class Triangulation euclidean traits 2 R is designed to deal with ordinary two dimensional points The class Triangulation euclidean traits xy 3 R is a geometric traits class to build the triangulation of a terrain Such a triangulation is a two dimensional triangulation embedded in three dimensional space The data points are three dimensional points The triangulation is build according to the projections of those points on the xy plane and then lifted up to the original three dimensional data points This is especially usefull to deal with GIS terrains Instead of really projecting the three dimensional points and maintaining a mapping between each point and its projection which costs space and is error prone the traits class supplies geometric predicates that ignore the z coordinates of the points See Section for an example CGAL provides also the geometric traits classes Triangulation euclidean traits yz 3 R and Triangulation euclidean traits zx 3 R to deal with projections on the xz plane and yz plane respectively 31 4 2 Example of a Basic Triangulation The following program creates a triangulation of 2D points using the default kernel Exact predicate inexact constructions kernel as geometric traits and the default triangulation data structure The input points are read from a file and inserted in the triangulation Finally points on the convex hull are written to cout file examples Triangulation 2 triangulation prog1 C include fstream include CGAL Exact predicates inexact constructions kernel h include CGAL Triangulation 2 h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation 2 K Triangulation typedef Triangulation Vertex circulator Vertex circulator typedef Triangulation Point Point int main std ifstream in data triangulation prog1 cin std istream iterator Point begin in std istream iterator Point end Triangulation t t insert begin end Vertex circulator vc t incident vertices t infinite vertex done vc if vc do std cout vc point std endl while vc done return 31 5 Delaunay Triangulations 31 5 1 Description The class Delaunay triangulation 2 Traits Tds is designed to represent the Delaunay triangulation of a set of data points in the plane A Delaunay triangulation fulfills the following empty circle property also called Delaunay property the circumscribing circle of any facet of the triangulation contains no data point in its interior For a point set with no subset of four cocircular points the Delaunay triangulation is unique it is dual to the Voronoi diagram of the set of points The class Delaunay triangulation 2 Traits Tds derives from the class Triangulation 2 Traits Tds The class Delaunay triangulation 2 Traits Tds inherits the types defined by the basic class Triangulation 2 Traits Tds Additionnal types provided by the traits class are defined to represent the dual Voronoi diagram The class Delaunay triangulation 2 Traits Tds overwrites the member functions that insert a new point in the triangulation or remove a vertex from it to maintain the Delaunay property It also has a member function Vertex handle nearest vertex const Point p to answer nearest neighbor queries and member functions to construct the elements vertices and edges of the dual Voronoi diagram Geometric traits The geometric traits has to be a model of the concept DelaunayTriangulationTraits 2 which refines the concept TriangulationTraits 2 In particular this concept provides the side of oriented circle predicate which given four points p q r s decides the position of the point s with respect to the circle passing through p q and r The side of oriented circle predicate actually defines the Delaunay triangulation Changing this predicate allows to build variant of Delaunay triangulations for different metrics such that L1 or L metric or any metric defined by a convex object However the user of an exotic metric must be careful that the constructed triangulation has to be a triangulation of the convex hull which means that convex hull edges have to be Delaunay edges This is granted for any smooth convex metric like L2 and can be ensured for other metrics like L by the addition to the point set of well chosen sentinel points The CGAL kernel classes and the class Triangulation euclidean traits 2 R are models of the concept DelaunayTriangulationTraits 2 for the euclidean metric The traits class for terrains Triangulation euclidean traits xy 3 R Triangulation euclidean traits yz 3 R and Triangulation euclidean traits zx 3 R are also models of DelaunayTriangulationTraits 2 excapt that they do not fulfills the requirements for the duality functions and nearest vertex queries Implementation The insertion of a new point in the Delaunay triangulation is performed using first the insertion member function of the basic triangulation and second performing a sequence of flips to restore the Delaunay property The number of flips that have to be performed is O d if the new vertex has degree d in the updated Delaunay triangulation For points distributed uniformly at random each insertion takes time O 1 on average once the point has been located in the triangulation Removal calls the removal in the triangulation and then retriangulates the hole created in such a way that the Delaunay criterion is satisfied Removal of a vertex of degree d takes time O d 2 The degree d is O 1 for a random vertex in the triangulation After having performed a point location the nearest neighbor of a point is found in time O n in the worst case but in time O 1 for vertices distributed uniformly at random and any query point 31 5 2 Example a Delaunay Terrain The following code creates a Delaunay triangulation with the usual Euclidean metric for the vertical projection of a terrain model The points have elevation that is they are 3D points but the predicates used to build the Delaunay triangulation are computed using only the x and y coordinates of these points file examples Triangulation 2 terrain C include CGAL Exact predicates inexact constructions kernel h include CGAL Triangulation euclidean traits xy 3 h include CGAL Delaunay triangulation 2 h include fstream struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation euclidean traits xy 3 K Gt typedef CGAL Delaunay triangulation 2 Gt Delaunay typedef K Point 3 Point int main std ifstream in data terrain cin std istream iterator Point begin in std istream iterator Point end Delaunay dt dt insert begin end std cout dt number of vertices std endl return 31 5 3 Example Voronoi Diagram The following code computes the edges of Voronoi diagram of a set of data points and counts the number of finite edges and the number of rays of this diagram file examples Triangulation 2 Voronoi C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 2 h include fstream struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Delaunay triangulation 2 K Triangulation typedef Triangulation Edge iterator Edge iterator typedef Triangulation Point Point int main std ifstream in data voronoi cin std istream iterator Point begin in std istream iterator Point end Triangulation T T insert begin end int ns int nr Edge iterator eit T edges begin for eit T edges end eit CGAL Object o T dual eit K Segment 2 s K Ray 2 r if CGAL assign s o ns if CGAL assign r o nr std cout The voronoi diagram as ns finite edges and nr rays std endl return 31 6 Regular Triangulations 31 6 1 Description Let PW pi wi i 1 n be a set of weighted points where each pi is a point and each wi is a scalar called the weight of point pi Alternatively each weighted point pi wi can be regarded as a sphere or a circle depending on the dimensionality of pi with center pi and radius ri sqrt wi The power diagram of the set PW is a space partition in which each cell corresponds to a sphere pi wi of PW and is the locus of points p whose power with respect to pi wi is less than its power with respect to any other sphere in PW In the two dimensional space the dual of this diagram is a triangulation whose domain covers the convex hull of the set P pi i 1 n of center points and whose vertices form a subset of P Such a triangulation is called a regular triangulation Three points pi pj and pk of P form a triangle in the regular triangulation of PW iff there is a point p of the plane with equal powers with respect to pi wi pj wj and pk wk and such that this power is less than the power of p with respect to any other sphere in PW Let us defined the power product of two weighted points pi wi and pj wj as pi wi pj wj pipj 2 wi wj pi wi pj is simply the power of point pj with respect to the sphere pi wi and two weighted points are said to be orthogonal if their power product is null The power circle of three weighted points pi wi pj wj and pk wk is defined as the unique circle orthogonal to pi wi pj wj and pk wk The regular triangulation of the sets PW satisfies the following regular property which just reduces to the Delaunay property when all the weights are null a triangle pipjpk is a face of the regular triangulation of PW iff the power product of any weighted point pl wl of PW with the power circle of pi wi pj wj and pk wk is positive or null We call power test of pi wi pj wj pk wk and pl wl the predicates which amount to compute the sign of the power product of pl wl with respect to the power circle of pi wi pj wj and pk wk This predicate amounts to computing the sign of the following determinant 1 xi yi xi 2 yi 2 wi 1 xj yj xj 2 yj 2 wj 1 xk yk xk 2 yk 2 wk 1 xl yl xl 2 yl 2 wl A pair of neighboring faces pipjpk and pipjpl is said to be locally regular with respect to the weights in PW if the power test of pi wi pj wj pk wk and pl wl is positive A classical result of computational geometry establishes that a triangulation of the convex hull of P such that any pair of neighboring faces is regular with respect to PW is a regular triangulation of PW Alternatively the regular triangulation of the weighted points set PW can be obtained as the projection on the two dimensional plane of the convex hull of the set of three dimensional points P pi pi 2 wi i 1 n The class Regular triangulation 2 Traits Tds is designed to maintain the regular triangulation of a set of 2d weighted points It derives from the class Triangulation 2 Traits Tds The functions insert and remove are overwritten to handle weighted points and maintain the regular property The vertices of the regular triangulation of a set of weighted points PW correspond only to a subset of PW Some of the input weigthed points have no cell in the dual power diagrams and therefore do not correspond to a vertex of the regular triangulation Such a point is called a hidden point Because hidden points can reappear later on as vertices when some other point is removed they have to be stored somewhere The regular triangulation store those points in special vertices called hidden vertices A hidden point can reappear as vertex of the triangulation only when the two dimensional face that hides it is removed from the triangulation To deal with this feature each face of a regular triangulation stores a list of hidden vertices The points in those vertices are reinserted in the triangulation when the face is removed Regular triangulation have member functions to construct the vertices and edges of the dual power diagrams The geometric traits The geometric traits of a regular triangulation must provide a weighted point type and a power test on these weighted points The concept RegularTriangulationTraits 2 is a refinement of the concept TriangulationTraits 2 CGAL provides the class Regular triangulation euclidean traits 2 Rep Weight which is a model for the traits concept RegularTriangulationTraits 2 The class Regular triangulation euclidean traits 2 Rep Weight derives from the class Triangulation euclidean traits 2 Rep and uses a Weighted point type derived from the type Point 2 of Triangulation euclidean traits 2 Rep There is also a class Regular triangulation filtered traits 2 FK which provides filtered predicates efficient and exact The Vertex type and Face Type of a Regular Triangulation The base vertex type of a regular triangulation includes a boolean to mark the hidden state of the vertex Therefore CGAL defines the concept RegularTriangulationVertexBase 2 which refine the concept TriangulationVertexBase 2 and provides a default model for this concept The base face type of a regular triangulation is required to provide a list of hidden vertices designed to store the points hidden by the face It has to be a model of the concept RegularTriangulationFaceBase 2 CGAL provides the templated class Regular triangulation face base 2 Traits as a default base class for faces of regular triangulations 31 6 2 Example a Regular Triangulation The following code creates a regular triangulation of a set of weighted points and ouput the number of vertices and the number of hidden vertices file examples Triangulation 2 regular C include CGAL Exact predicates inexact constructions kernel h include CGAL Regular triangulation euclidean traits 2 h include CGAL Regular triangulation 2 h include fstream struct K CGAL Exact predicates inexact constructions kernel typedef double W typedef CGAL Regular triangulation euclidean traits 2 K W Gt typedef CGAL Regular triangulation 2 Gt Regular triangulation int main Regular triangulation rt std ifstream in data regular cin Regular triangulation Weighted point wp int count while in wp count rt insert wp rt is valid std cout number of inserted points count std endl std cout number of vertices std cout rt number of vertices std endl std cout number of hidden vertices std cout rt number of hidden vertices std endl return 31 7 Constrained Triangulations A constrained triangulation is a triangulation of a set of points that has to include among its edges a given set of segments joining the points The corresponding edges are called constrained edges The endpoints of constrained edges are of course vertices of the triangulation However the triangulation may include include other vertices as well There are three versions of constrained triangulations In the basic version the constrained triangulation does not handle intersecting constraints and the set of input constraints is required to be a set of segments that do not intersect except possibly at their endpoints Any number of constrained edges are allowed to share the same endpoint Vertical constrained edges or constrained edges with null length are allowed The two other versions support intersecting input constraints In those versions input constraints are allowed to be intersecting overlapping or partially overlapping segments The triangulation introduces additional vertices at each point that is the proper intersection points of two constraints A single constraint intersecting other constraints will then appear as several edges in the triangulation The two versions dealing with intersecting constraints differ in the way intersecting constraints are dealt with One of them is designed to be robust when predicates are evaluated exactly but constructions i e intersection computations are approximative The other one is designed to be used with exact arithmetic meaning exact evaluation of predicates and exact computation of intersections This last version finds its full efficiency when used in conjunction with a constraint hierarchy data structure which allows one to avoid the cascading of intersection computations as provided in the class Constrained triangulation plus 2 See section A constrained triangulation is represented in the CGAL library as an object of the class Constrained triangulation 2 Traits Tds Itag The third parameter Itag is the intersection tag which serves to choose how intersecting constraints are dealt with This parameter has to be instantiated by one of the following classes CGAL No intersection tag when input constraints do not intersect CGAL Exact predicates tag if the geometric traits provides exact predicates but approximative constructions CGAL Exact intersections tag when an exact predicates and exact constructions are provided The class Constrained triangulation 2 Traits Tds Itag inherits from Triangulation 2 Traits Tds It defines an additionnal type Constraint to represent the constraints A constraint is represented as a pair of points A constrained triangulation can be created from a list of constrained edges The class Constrained triangulation 2 Traits Tds Itag overrides the insertion and removal of a point to take care of the information about constrained edges The class also allows inline insertion of a new constraint given by its two endpoints or the removal of a constraint The Geometric Traits The geometric traits of a constraint triangulation has to be a model of the concept TriangulationTraits 2 When intersections of input constraints are supported the geometric traits class has to be a model of the concept ConstrainedTriangulationTraits 2 which refines the concept TriangulationTraits 2 providing additional function object types to compute the intersection of two segments The Base Face of a Constrained Triangulation The information about constrained edges is stored in the faces of the triangulation The base face of a Constrained Triangulation has to be a model for the concept ConstrainedTriangulationFaceBase 2 which refines the concept TriangulationFaceBase 2 The concept ConstrainedTriangulationFaceBase 2 requires member functions the get and set the constrained status of the edges CGAL provides a default base face class for constrained triangulations This class named Constrained triangulation face base 2 Traits derives from the class Triangulation face base 2 Traits and adds three booleans to store the status of its edges Figure Constrained and Constrained Delaunay triangulation the constraining edges are the green edges a constrained triangulation is shown on the left the constrained Delaunay triangulation with two examples of circumcircles is shown on the right 31 8 Constrained Delaunay Triangulations A constrained Delaunay triangulation is a triangulation with constrained edges which tries to be as much Delaunay as possible As constrained edges are not necessarily Delaunay edges the triangles of a constrained Delaunay triangulation do not necessarily fulfill the empty circle property but they fulfill a weaker constrained empty circle property To state this property it is convenient to think of constrained edges as blocking the view Then a triangulation is constrained Delaunay iff the circumscribing circle of any facet encloses no vertex visible from the interior of the facet As in the case of constrained triangulations three different versions of Delaunay constrained triangulations are provided The first version handle set of constraints which do not intersect except possibly at the endpoints The two other versions handle intersecting input constraints One of them is designed to be designed to be robust when used in conjunction with a geometric traits providing exact predicates and approximative constructions such as a CGAL Filtered Kernel or any kernel providing filtered exact predicates The third version is designed to be used with an exact arithmetic number type The CGAL class Constrained Delaunay triangulation 2 Traits Tds Itag is designed to represent constrained Delaunay triangulations As in the case of constraints triangulation the third parameter Itag is the intersection tag and serves to choose how intersecting constraints are dealt with It can be instantiated with one of the following class CGAL No intersection tag CGAL Exact predicates tag CGAL Exact intersections tag see Section A constrained Delaunay triangulation is not a Delaunay triangulation but it is a constrained triangulation Therefore the class Constrained Delaunay triangulation 2 Traits Tds Itag derives from the class Constrained triangulation 2 Traits Tds Itag The constrained Delaunay triangulation has member functions to override the insertion and removal of a point or of a constraint Each of those member function takes care to restore the constrained empty circle property The Geometric Traits The geometric traits of a constrained Delaunay triangulation is required to provide the side of oriented circle predicate as the geometric traits of a Delaunay triangulation and has to a model of the concept DelaunayTriangulationTraits 2 When intersecting input constraints are supported the geometric traits is further required to provide function objects to compute constraints intersections Then the geometric traits has to be at the same time a model of the concept ConstrainedTriangulationTraits 2 The face base class Information about the status constrained or not of the edges of the triangulation has to be stored in the face class and the base face class of a constrained Delaunay triangulation has to be a model of ConstrainedTriangulationFaceBase 2 31 8 1 Example a constrained Delaunay triangulation The following code inserts a set of intersecting constraint segments into a triangulation and counts the number of constrained edges of the resulting triangulation file examples Triangulation 2 constrained C include CGAL Exact predicates inexact constructions kernel h include CGAL Constrained Delaunay triangulation 2 h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vb typedef CGAL Constrained triangulation face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb TDS typedef CGAL Exact predicates tag Itag typedef CGAL Constrained Delaunay triangulation 2 K TDS Itag CDT typedef CDT Point Point int main CDT cdt std cout Inserting a grid of 5x5 constraints std endl for int i 1 i 6 i cdt insert constraint Point i Point 6 i for int j 1 j 6 j cdt insert constraint Point j Point j 6 assert cdt is valid int count for CDT Finite edges iterator eit cdt finite edges begin eit cdt finite edges end eit if cdt is constrained eit count std cout The number of resulting constrained edges is std cout count std endl return 31 9 Constrained Triangulations Plus The class Constrained triangulation plus 2 Tr provides a constrained triangulation with an additional data structure called the constraint hierarchy that keeps track of the input constraints and of their refinement in the triangulation The class Constrained triangulation plus 2 Tr inherits from its template parameter Tr which has to be instantiated by a constrained or constrained Delaunay triangulation According to its intersection tag the base class will support intersecting input constraints or not When intersections of input constraints are supported the base class constructs a triangulation of the arrangement of the constraints introducing new vertices at each proper intersection points and refining the input constraints into subconstraints which appear as edges more precisely as constrained edges of the triangulation The data structure maintains for each input constraint the sequence of intersection vertices added on this constraint The constraint hierarchy also allows the user to retrieve the set of constrained edges of the triangulation and for each constrained edge the set of input constraints that overlap it The class Constrained triangulation plus 2 Tr is especially useful when the base constrained triangulation class handles intersections of constraints and uses an exact number type i e when its intersection tag is CGAL Exact intersections tag Indeed in this case the Constrained triangulation plus 2 Tr is specially designed to avoid cascading in the computations of intersection points 31 9 1 Example Building a triangulated arrangement of segments The following code inserts a set of intersecting constraint segments into a triangulation and counts the number of constrained edges of the resulting triangulation file examples Triangulation 2 constrained plus C include CGAL Exact predicates exact constructions kernel h include CGAL intersections h include CGAL Constrained Delaunay triangulation 2 h include CGAL Constrained triangulation plus 2 h struct K CGAL Exact predicates exact constructions kernel typedef CGAL Triangulation vertex base 2 K Vb typedef CGAL Constrained triangulation face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb TDS typedef CGAL Exact intersections tag Itag typedef CGAL Constrained Delaunay triangulation 2 K TDS Itag CDT typedef CGAL Constrained triangulation plus 2 CDT CDTplus typedef CDTplus Point Point int main CDTplus cdt std cout Inserting a grid 5 x 5 of constraints std endl for int i 1 i 6 i cdt insert constraint Point i Point 6 i for int j 1 j 6 j cdt insert constraint Point j Point j 6 assert cdt is valid int count for CDTplus Subconstraint iterator scit cdt subconstraints begin scit cdt subconstraints end scit count std cout The number of resulting constrained edges is count std endl return 31 1 The Triangulation Hierarchy The class Triangulation hierarchy 2 Tr implements a triangulation augmented with a data structure to answer efficiently point location queries The data structure is a hierarchy of triangulations The triangulation at the lowest level is the original triangulation where operations and point location are to be performed Then at each succedding level the data structure stores a triangulation of a small random sample of the vertices of the triangulation at the preceeding level Point location is done through a top down nearest neighbor query The nearest neighbor query is first performed naively in the top level triangulation Then at each following level the nearest neighbor at that level is found through a linear walk performed from the nearest neighbor found at the preceeding level Because the number of vertices in each triangulation is only a small fraction of the number of vertices of the preceeding triangulation the data structure remains small and achieves fast point location queries on real data As proved in Dev98 this structure has an optimal behaviour when it is built for Delaunay triangulations However it can be used as well for other triangulations and the class Triangulation hierarchy 2 Tr is templated by a parameter which is to be instantiated by one of the CGAL triangulation classes The class Triangulation hierarchy 2 Tr inherits from the triangulation type passed as template parameter Tr The insert and remove member functions are overwritten to update the data structure at each operation The locate queries are also overwritten to take advantage of the data structure for a fast processing The Vertex of a Triangulation Hierarchy The base vertex class of a triangulation hierarchy has to be a model of the concept TriangulationHierarchyVertexBase 2 which extends the concept TriangulationVertexBase 2 This extension adds access and setting member functions for two pointers to the corresponding vertices in the triangulations of the next and preceeding levels CGAL provides the class Triangulation hierarchy vertex base 2 Vb which is a model for the concept TriangulationHierarchyVertexBase 2 This class is templated by a parameter Vb which is to be instantiated by a model of the concept TriangulationVertexBase 2 The class Triangulation hierarchy vertex base 2 Vb inherits from its template parameter Vb This design allows to use for Vb either the default vertex base class or a user customized vertex base with additionnal functionalities 31 1 1 Examples of the Use of a Triangulation Hierarchy The following program is example of the standard use of a triangulation hierarchy to enhance the efficiency of a Delaunay triangulation The program output the number of vertices at the different levels of the hierarchy file examples Triangulation 2 hierarchy C include CGAL Exact predicates inexact constructions kernel h include CGAL Delaunay triangulation 2 h include CGAL Triangulation hierarchy 2 h include CGAL point generators 2 h include CGAL algorithm h include cassert struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vbb typedef CGAL Triangulation hierarchy vertex base 2 Vbb Vb typedef CGAL Triangulation face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb Tds typedef CGAL Delaunay triangulation 2 K Tds Dt typedef CGAL Triangulation hierarchy 2 Dt Triangulation typedef Triangulation Point Point typedef CGAL Creator uniform 2 double Point Creator int main std cout insertion of 1 random points std endl Triangulation t CGAL Random points in square 2 Point Creator g 1 CGAL copy n g 1 std back inserter t verbose mode of is valid shows the number of vertices at each level std cout The number of vertices at successive levels std endl assert t is valid true return The following program shows how to use a triangulation hierachy in conjonction with a constrained triangulation plus file examples Triangulation 2 constrained hierarchy plus C include CGAL Exact predicates inexact constructions kernel h include CGAL Constrained Delaunay triangulation 2 h include CGAL Triangulation hierarchy 2 h include CGAL Constrained triangulation plus 2 h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vbb typedef CGAL Triangulation hierarchy vertex base 2 Vbb Vb typedef CGAL Constrained triangulation face base 2 K Fb typedef CGAL Triangulation data structure 2 Vb Fb TDS typedef CGAL Exact predicates tag Itag typedef CGAL Constrained Delaunay triangulation 2 K TDS Itag CDT typedef CGAL Triangulation hierarchy 2 CDT CDTH typedef CGAL Constrained triangulation plus 2 CDTH Triangulation typedef Triangulation Point Point int main Triangulation cdt std cout Inserting a grid 5 x 5 of constraints std endl for int i 1 i 6 i cdt insert constraint Point i Point 6 i for int j 1 j 6 j cdt insert constraint Point j Point j 6 int count for Triangulation Subconstraint iterator scit cdt subconstraints begin scit cdt subconstraints end scit count std cout The number of resulting constrained edges is std cout count std endl verbose mode of is valid shows the number of vertices at each level std cout The number of vertices at successive levels std endl assert cdt is valid true return 31 11 Flexibility Using Customized Vertices and Faces To be able to adapt to various needs a highly flexible design has been selected for 2D triangulations We have already seen that the triangulation classes have two parameters a geometric traits class and a triangulation data structure class which the user can instantiate with his own customized classes The most usefull flexibility however comes from the fact that the triangulation data structure itself has two template parameters to be instantiated by base classes for the vertices and faces of the triangulation The vertex and face classes of the triangulation are derived from those base classes Thus using his own customized classes to instantiate these parameters the user can easily build up a triangulation with additionnal informations or functionalities in the vertices and faces A cyclic dependancy To insure flexibility the triangulation data structure is templated by the vertex and face base classes Also since incidence and adjacency relations are stored in vertices and faces the base classes have to know the types of handles on vertices and faces provided by the triangulation data structure Thus the vertex and base classes have to be thenselves parameterized by the triangulation data structure and there is a cyclic dependancy on template parameter Figure The cyclic dependency in triangulations software design Previously this cyclic dependency was avoided by using only void pointers in the interface of base classes These void were converted to appropriate types at the triangulation data structure levels This solution had some drawbacks mainly the user could not add in the vertices or faces of the triangulation a functionality related to types defined by the triangulation data structure for instance a handle to a vertex and he was lead to use himself void pointers The new solution to resolve the template dependancy is based on a rebind mechanism similar to the mecanism used in the standard allocator class std allocator The rebind mecanism is described in Section of Chapter For now we will just notice that the design requires the existence in the vertex and face base classes of a nested template class Rebind TDS defining a type Other used by the rebinding mecanism The two following examples aim to show how the user can put in use the flexibility offered by the base classes parameters Adding colors The first example corresponds to a case where the user wishes to add in the vertices or faces of the triangulation an additional information that do not depend on types provided by the triangulation data structure In that case predefined classes Triangulation vertex base with info 2 Info Traits Vb or Triangulation face base with info 2 Info Traits Vb can be used Those classes have a template parameter Info devoted to handle additionnal information The following examples shows how to add a CGAL Color in the triangulation faces file examples Triangulation 2 colored face C include CGAL Exact predicates inexact constructions kernel h include CGAL IO Color h include CGAL Triangulation 2 h include CGAL Triangulation face base with info 2 h struct K CGAL Exact predicates inexact constructions kernel typedef CGAL Triangulation vertex base 2 K Vb typedef CGAL Triangulation face base with info 2 CGAL Color K Fb typedef CGAL Triangulation data structure 2 Vb Fb Tds typedef CGAL Triangulation 2 K Tds Triangulation typedef Triangulation Face handle Face handle typedef Triangulation Finite faces iterator Finite faces iterator typedef Triangulation Point Point int main Triangulation t t insert Point 1 t insert Point t insert Point 2 t insert Point 2 2 Finite faces iterator fc t finite faces begin for fc t finite faces end fc fc info CGAL BLUE Point p 5 5 Face handle fh t locate p fh info CGAL RED return Adding handles The second examples shows how the user can still derive and plug in his own vertex base or face base when he would like to have additionnal functionalities depending on types provided by the triangulation data structure file examples Triangulation 2 adding handles C include CGAL Exact predicates inexact constructions kernel h include CGAL Triangulation 2 h include cassert A facet with an additionnal handle template class Gt class Vb CGAL Triangulation vertex base 2 Gt class My vertex base public Vb typedef Vb Base public typedef typename Vb Vertex handle Vertex handle typedef typename Vb Face handle Face handle typedef typename Vb Point Point template typename TDS2 struct Rebind TDS typedef typename Vb template Rebind TDS TDS2 Other Vb2 typedef My vertex base Gt Vb2 Other private Vertex handle va public My vertex base Base My vertex base const Point p Base p My vertex base const Point p Face handle f Base f p My vertex base Face handle f Base f void set associated vertex Vertex handle va va va Vertex handle get associated vertex return va struct K CGAL Exact predicates inexact constructions kernel typedef My vertex base K Vb typedef CGAL Triangulation data structure 2 Vb Tds typedef CGAL Triangulation 2 K Tds Triangulation typedef Triangulation Vertex handle Vertex handle typedef Triangulation Finite faces iterator Finite faces iterator typedef Triangulation Point Point int main Triangulation t Vertex handle v t insert Point 1 Vertex handle v1 t insert Point Vertex handle v2 t insert Point 2 Vertex handle v3 t insert Point 2 2 associate vertices as you like v set associated vertex v1 v1 set associated vertex v2 v2 set associated vertex v3 v3 set associated vertex v assert v get associated vertex v1 return 31 12 Design and Implementation History The code of this package is the result of a long development process Here follows a tentative list of people who added their stone to this package Jean Daniel Boissonnat Herv Br nnimann Olivier Devillers Andreas Fabri Fr d ric Fichel Julia Fl totto Monique Teillaud and Mariette Yvinec Next chapter 2D Triangulations Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Triangulation_2/Chapter_main.html", "title": "2d triangulations", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Triangulation_2/main.tex' -->\n<html> <head>  \n<title>2D Triangulations</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_31\"></a>\n  \n<h1>Chapter 31<BR>2D Triangulations</h1>\n \n<A NAME=\"Chapter_2D_Triangulations\"></A>\n<A NAME=\"user_chapter_2D_Triangulations\"></A>\n<EM>Mariette Yvinec</EM><BR>\n\n\n<P>\n\n<CENTER>\n<img border=0 src=\"./tr1.gif\" width=300>\n<img border=0 src=\"./dt1.gif\" width=300>\n</CENTER>\n<P>\n\nThis chapter describes the two dimensional triangulations\nof C<SMALL>GAL</SMALL>. \nSection&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Definitions\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> recalls the\nmain definitions about triangulations.\nSections&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Representation\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> discusses\nthe way two-dimensional triangulations are represented in C<SMALL>GAL</SMALL> .\nSection&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Software_Design\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> presents\nthe overall software\ndesign of the 2D triangulations package. \nThe next sections present the different two dimensional triangulations classes\navailable in  C<SMALL>GAL</SMALL> : \nbasic triangulations (section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Basic\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>),\nDelaunay triangulations\n(Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Delaunay\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>),\nregular triangulations\n(Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Regular\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>),\nconstrained triangulations\n(Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>),\nand constrained Delaunay triangulations\n(Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained_Delaunay\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\nSection&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained_Plus\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\ndescribes a class which implements a constrained or\nconstrained Delaunay triangulation  with\nan additionnal data structure \nto describe how the constraints are refined \nby the edges of the triangulations.\nSection&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\ndescribes a hierarchical data structure for\nfast point location queries.\nAt last, Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Flexibility\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> \nexplains how the user can  benefit  from the flexibility \nof  C<SMALL>GAL</SMALL> triangulations using customized classes for faces\nand vertices.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>31.1&nbsp;&nbsp;&nbsp;Definitions</h2>\n\n<A NAME=\"Section_2D_Triangulations_Definitions\"></A>\n<P>\n\nA two dimensional triangulation can be roughly described as a set <MATH><I>T</I></MATH>\nof triangular facets such that&nbsp;:<BR>\n\n- two facets either are  disjoint or share a lower dimensional\nface (edge or vertex).<BR>\n\n- the set of facets in  <MATH><I>T</I></MATH> is connected for the adjacency relation.<BR>\n\n- the  domain <MATH><I>U<SUB>T</SUB></I></MATH>  which is the union\nof facets in <MATH><I>T</I></MATH> has no singularity.\n<P>\n\nMore precisely, a triangulation can be described \nas a simplicial complex.\nLet us first record a few definitions.\n<P>\n\nA simplicial complex is a set <MATH><I>T</I></MATH>  of simplices such that&nbsp;<BR>\n\n- any face of a simplex in <MATH><I>T</I></MATH> is a simplex in <MATH><I>T</I></MATH><BR>\n\n- two simplices in <MATH><I>T</I></MATH>  either are disjoint or  share\n  a common subface.\n<P>\n\nThe dimension <MATH><I>d</I></MATH> of a  simplicial complex is the \nmaximal dimension of its simplices.<BR>\n\nA simplicial complex <MATH><I>T</I></MATH> is pure if any simplex of <MATH><I>T</I></MATH>\nis included in a simplex of <MATH><I>T</I></MATH> with maximal dimension.<BR>\n\nTwo simplexes in <MATH><I>T</I></MATH> with maximal dimension <MATH><I>d</I></MATH> are said to be\nadjacent if they share a <MATH><I>(d-1)</I></MATH> dimensional subface.\nA simplicial complex is connected if the adjacency relation\ndefines a connected graph \nover  the set of simplices of <MATH><I>T</I></MATH> with maximal dimension.<BR>\n\nThe union <MATH><I>U<SUB>T</SUB></I></MATH> of all simplices in <MATH><I>T</I></MATH> is called the domain of <MATH><I>T</I></MATH>.\nA point <MATH><I>p</I></MATH> in the domain of <MATH><I>T</I></MATH> is said to singular \nif its surrounding in <MATH><I>U<SUB>T</SUB></I></MATH>\nis neither a topological ball nor a topological disc.\n<P>\n\nThen, a two dimensional triangulation can be described as a \ntwo dimensional simplicial complex  that is pure,\nconnected and without singularity.\n<P>\n\nEach facet of a triangulation can be given an <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>\nwhich in turn induces an <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>\non the edges incident to that facet. The <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of two adjacent\nfacets are said to be consistent if they induce\n<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations on their common incident edge.\nA triangulation is said to be orientable if \nthe <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of each facet can be chosen in such a way\nthat all pairs of incident facets have consistent orientations.\n<P>\n\nThe data stucture underlying C<SMALL>GAL</SMALL> triangulations\nallows to represent the combinatorics of \nany  orientable two dimensional  triangulations\nwithout boundaries. \nOn top of this data structure, the 2D triangulations classes\ntake care of the geometric embedding  of the triangulation\nand are designed to handle planar triangulations.\nThe plane of the tiangulation may be embedded in a higher\ndimensional space.\n<P>\n\nThe  triangulations of  C<SMALL>GAL</SMALL> are complete triangulations\nwhich means  that their domain is  the\nconvex hull of  their vertices.\nBecause any planar triangulation\ncan be completed, this is not a real restriction.\nFor instance, a triangulation of a  polygonal region can be\nconstructed  and represented as a subset  of a constrained triangulation \nin which  the region boundary edges have been input as \nconstrained edges (see\nSection&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>,\n<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained_Delaunay\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and \n<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained_Plus\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\nStrictly speaking, the term <I>face</I> should be used\nto design  a face of any dimension,\nand the two-dimensional faces of a triangulation \nshould be properly called <I>facets</I>.\nHowever, following a common usage, we hereafter often call <I>faces</I>, the facets\nof a two dimensional triangulation.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>31.2&nbsp;&nbsp;&nbsp;Representation</h2>\n\n<A NAME=\"Section_2D_Triangulations_Representation\"></A>\n<P>\n\n<h4>The set of faces</h4>\n<P>\n\nA 2D triangulation  of C<SMALL>GAL</SMALL> can be viewed as a planar partition \nwhose bounded faces are triangular and cover\nthe convex hull of the set of vertices. \nThe single unbounded face of this partition\nis the complementary of the convex hull. \nIn many applications, such as Kirkpatrick's hierarchy\nor incremental Delaunay construction, it is convenient to\ndeal with only triangular faces. Therefore, \na fictitious vertex, called the <I>infinite vertex</I>\nis added to the triangulation as well as\n<I>infinite edges</I> and <I>infinite faces</I> incident to it..\nEach infinite edge\nis incident to the infinite vertex and to a vertex of the convex hull.\nEach infinite face is incident to the infinite vertex\nand to a convex hull edge.\n<P>\n\nTherefore, each edge of the triangulation\nis incident to exactly two faces\nand the set of faces of a triangulation is topologically\nequivalent to a two-dimensional sphere.\nThis extends to  lower dimensional triangulations\narising in degenerate cases or when the triangulations\nas less than three vertices.\nIncluding the infinite faces, \na one dimensional triangulation\nis a ring of edges and vertices\ntopologically equivalent to a <MATH><I>1</I></MATH>-sphere.\nA zero dimensional triangulation, whose domain is reduced to a\nsingle point, is represented by  two vertices that is\ntopologically equivalent to a <MATH><I>0</I></MATH>-sphere.\n<P>\n\nNote that\nthe <I>infinite vertex</I> has no significant\ncoordinates and that no geometric predicate can be applied on it\nnor on an infinite face.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Infinite vertex and infinite faces\n<A NAME=\"2D_Triangulation_Fig_infinite_vertex\"></A>\n\n<CENTER>\n<img border=0 src=\"./infinite.gif\" align=center alt=\"Vertices at\ninfinity\">\n</CENTER>\n<P>\n\n<h4>A representation based on faces and vertices</h4>\n\nBecause a triangulation is  a set of\ntriangular faces with constant-size complexity,\ntriangulations are not implemented\nas a layer on top of a planar map.\nC<SMALL>GAL</SMALL> uses a proper internal\nrepresentation of triangulations based on faces and vertices\nrather than on edges. Such a  representation\nsaves storage space and results in faster\nalgorithms&nbsp; [<A HREF=\"../biblio.html#Biblio_bdty-tcgal-00\">BDTY00</A>].\n<P>\n\nThe basic elements of the representation are vertices and faces.\nEach triangular face gives access to its three incident vertices \nand to its three adjacent faces. \nEach vertex gives access to one of its incident faces\nand through that face to the circular list of its incident faces.\n<P>\n\nThe three vertices of a face are indexed with 0, 1 and 2\nin counterclockwise order. The neighbor of a face are also \nindexed with 0,1,2 in such a way that the neighbor indexed by <I>i</I>\nis <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex with the same index.\nSee Figure&nbsp;<A HREF=\"Chapter_main.html#2D_Triangulation_Fig_neighbors1\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, \n the functions <I>ccw(i)</I>\nand <I>cw(i)</I> shown  on this figure\ncompute respectively <MATH><I>i+1</I></MATH> and <MATH><I>i-1</I></MATH> modulo 3.\n<P>\n\nThe edges are not explicitly represented, they are only implicitely\nrepresented through the adjacency relations of two faces.\nEach edge has two implicit representations : the edge\nof a face <I>f</I>  which is opposed to the vertex indexed <I>i</I>,\ncan be represented as well as an edge of the <I>neighbor(i)</I> of \n<I>f</I>.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Vertices and neighbors. \n    <A NAME=\"2D_Triangulation_Fig_neighbors1\"></A> \n  \n<CENTER>\n<img border=0  src=\"./rep_bis.gif\" width=400 align=center alt=\"Neighbors\">\n</CENTER>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>31.3&nbsp;&nbsp;&nbsp;Software Design</h2>\n\n<A NAME=\"Section_2D_Triangulations_Software_Design\"></A>\n<P>\n\nThe triangulations  classes of C<SMALL>GAL</SMALL>  \nprovide high-level geometric functionalities\nsuch as location of a point in the triangulation, insertion\nor removal of a point.\nThey are build as a layer on top of a data structure\ncalled the triangulation data structure.\nThe triangulation data structure   can be thought \nof as a container for the faces and vertices of the triangulation.\nThis data structure  also takes care\nof all the combinatorial aspects of the triangulation.\n<P>\n\nThis separation between the\ngeometric aspect and the combinatorial part\nis reflected in the software design by the fact\nthat the triangulation classes have two template parameters :\n<P>\n\n<UL>\n<LI> the first parameter stands for a\n<B>geometric traits</B> class providing \nthe geometric primitives (points, segments and triangles) \nof  the triangulation and the elementary\noperations (predicate or constructions) on those objects.\n<P>\n\n<LI> the second parameter stands for a\n<B>triangulation data structure</B> class. The concept\nof triangulation data structure is described in\n Section&nbsp;<A HREF=\"../TDS_2/Chapter_main.html#2D_TDS_Concept\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> of\nChapter&nbsp;<A HREF=\"../TDS_2/Chapter_main.html#user_chapter_2D_Triangulation_Data_Structure\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nThe triangulation data structure defines the types\nused to represent the faces and vertices of the triangulation,\nas well as additionnal types (handles, iterators and circulators)\nto access and visit the faces and vertices.\n<P>\n\nC<SMALL>GAL</SMALL> provides the class <I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_966\">Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I>\nas a  default model of triangulation data structure.\nThe class <I><A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_966\">Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I>\nhas two template parameters standing for\na vertex base class and a face base class from which the vertex and\nface classes are respectively derived.\nC<SMALL>GAL</SMALL> defines concepts \nfor these template parameters\nand provide default models for these concepts.\nThe vertex and base classes are templated by the geometric\ntraits which allows them to have some knowledge of the geometric\nprimitives of the triangulation. \nThose default vertex and  face base classes\ncan be replaced by \nuser customized base classes in order, for example, to deal\nwith additionnal properties attached to the vertices or faces\nof a triangulation. See section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Flexibility\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\nfor more details on the way to make use of this flexibility.\n</UL>\n<P>\n\nThe Figure&nbsp;<A HREF=\"Chapter_main.html#2D_Triangulation_Fig_three_levels\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> summarizes the design of the\ntriangulation package, showing the  three layers\n(base classes, triangulation data structure and triangulation)\nforming this design.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The triangulations software design.\n<A NAME=\"2D_Triangulation_Fig_three_levels\"></A>\n\n<CENTER><BR>\n\n<img border=0 src=\"./threelevels.gif\"  align=center alt=\"Three_levels\">\n</CENTER>\n<P>\n\nThe top triangulation  level, responsible for the geometric \nembedding of the  triangulation comes in different flavors \naccording to the different kind of triangulations:\nbasic, Delaunay, regular, constrained or constrained Delaunay.\nEach kind of triangulations correspond to a different\nclass. \nFigure&nbsp;<A HREF=\"Chapter_main.html#2D_Triangulation_Fig_derivation_tree\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>  summarizes the derivation dependancies\nof C<SMALL>GAL</SMALL> 2D triangulations classes.\nAny 2D triangulation class is parametrized by\na geometric traits and a triangulation data structure.\nWhile a  unique concept <I><A HREF=\"../TDS_2_ref/Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I>\ndescribes the   triangulation data structure requirements\nfor any  triangulation classes, \nthe concept of geometric traits actually depends\non the  triangulation class.\nIn general, the requirements for the vertex and face base classes \nare described by the basic concepts <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationVertexBase_2.html#Cross_link_anchor_937\">TriangulationVertexBase_2</A></I>\nand  <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationFaceBase_2.html#Cross_link_anchor_934\">TriangulationFaceBase_2</A></I>. However, some  triangulation\nclasses requires base classes implementing\nrefinements \nof the basic concepts.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The derivation tree of 2D triangulations.\n<A NAME=\"2D_Triangulation_Fig_derivation_tree\"></A><BR>\n\n<CENTER>\n<img border=0 src=\"./derivation_tree.gif\" align=center>\n</CENTER>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>31.4&nbsp;&nbsp;&nbsp;Basic Triangulations</h2>\n\n<A NAME=\"Section_2D_Triangulations_Basic\"></A>\n<P>\n\n<h3>31.4.1&nbsp;&nbsp;&nbsp;Description</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Basic_Description\"></A>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I>\nserves as a base class for the other\n2D triangulations classes\nand \n implements the user\ninterface to a triangulation.\n<P>\n\nThe vertices and faces of the triangulations are accessed through \n<I>handles</I>,\n<I>iterators</I> and <I>circulators</I>.\nA handle is a model of the concept <I><A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A></I> which basically\noffers the two dereference operators  <I>*</I>  and <I>-&gt;</I> .\nA circulator is a type devoted to visit circular sequences.\nHandles are used whenever the accessed element \nis not part of a sequence.\nIterators  and circulators are used\nto visit  all or parts of the triangulation.\n<P>\n\nThe iterators and circulators\nare all bidirectional and non mutable.\nThe circulators and iterators are convertible to the \nhandles with the same value type, so that \nwhen calling a member function,\nany handle type argument can be replaced\nby an iterator or a circulator\nwith the same value type.\n<P>\n\nThe triangulation class allows to visit the vertices\nand  neighbors of a face in clockwise or counterclockwise order.\n<P>\n\nThere are circulators  \nto visit the edges or faces \nincident to a given vertex or the  vertices \nadjacent to it.\nAnother circulator type allows to visit all the faces\ntraversed by a given line.\nCirculators step through infinite features as well as \nthrough finite ones.\n<P>\n\nThe triangulation class offers \nsome iterators to visit all the \nfaces, edges or vertices and also iterators to visit \nselectively the finite\nfaces, edges  or vertices.\n<P>\n\nThe triangulation class provides methods to test\nthe infinite character of any feature,\nand also methods to test the presence in the triangulation\nof a particular feature (edge or face) given its vertices.\n<P>\n\nThe triangulation class  provides a method to locate\na given point with respect to a triangulation.\nIn particular, this method reports wether the point\ncoincides with a vertex of the triangulation, lies on an edge,\nin a face or outside of the convex hull. In case of a degenerate \nlower dimensional triangulation, the query point may also lie\noutside the triangulation affine hull.\n<P>\n\nThe triangulation class also provides\nmethods to locate a point with respect to\na given  finite face of the triangulation or with respect to its\ncircumcircle.\nThe faces of the triangulation and their circimcircles \nhave the  counterclockwise <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>.\n<P>\n\nThe triangulation can be modified by several functions&nbsp;:\ninsertion of a point, removal of a vertex,\nflipping  of an edge. The flipping of an edge\nis possible when the union of the two incident faces\nforms  a convex body (see Figure&nbsp;<A HREF=\"Chapter_main.html#2D_Triangulation_fig_flip_bis\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Flip. <A NAME=\"2D_Triangulation_fig_flip_bis\"></A>\n\n<CENTER>\n<img border=0 src=\"./Flip.gif\" align=center alt=\"Flip\">\n</CENTER>\n<P>\n\n<h4>Implementation</h4>\n<P>\n\nLocate is implemented by a line walk. The walk\nbegins  at  a vertex of the face which\nis given\nas an optional argument  or at an arbitrary vertex of the triangulation\n if no optional argument is given. It takes\ntime O(n) in the worst case, but only O(<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(n))\non average if the vertices are distributed uniformly at random.\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A>&lt;Traits,Tds&gt;</I>,\ndescribed in section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Hierarchy\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>, \nimplements a data structure  designed to\noffer an alternate  more efficient point location algorithm.\n<P>\n\nInsertion of a point is done by locating a face that contains the\npoint, and splitting this face into three new faces.\nIf the point falls outside the convex hull, the triangulation\n is restored by flips.  Apart from the location, insertion takes a\ntime O(1). This bound is only an amortized bound\nfor points located outside the convex hull.\n<P>\n\nRemoval of a vertex is done by removing all adjacent triangles, and\nretriangulating the hole. Removal takes a time  at most proportionnal to\nd^2, where\n d is the degree of the removed vertex,\nwhich is O(1) for a random vertex.\n<P>\n\nThe face, edge, and vertex iterators on finite features\nare derived from their counterparts visiting all (finite and infinite)\nfeatures which are themselves derived from the corresponding iterators\nof the triangulation data structure.\n<P>\n\n<h4>Geometric Traits</h4>\n\n<A NAME=\"Subsubsection_2D_Triangulation_Basic_Geometric_Traits\"></A>\n<P>\n\nThe geometric traits of a triangulation \n is required to provide\nthe geometric objects (points, segments and triangles)\nbuilding up the triangulation\ntogether with the geometric predicates on those objects.\nThe required predicates are:<BR>\n\n- comparison of the <I>x</I> or <I>y</I> coordinates of two points.<BR>\n\n- the <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> test which computes \n  the order type of three given point.\n<P>\n\nThe concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I>  describes the requirements for the \ngeometric traits class of a triangulation.\n The C<SMALL>GAL</SMALL>  kernel classes \nare models for  this  concept.\nThe C<SMALL>GAL</SMALL>  library also provides dedicated models\nof <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I> \nusing the kernel geometric objects and predicates.\nThese classes are themselves templated with a C<SMALL>GAL</SMALL>  kernel\nand extract the required types and predicates from the kernel.\nThe traits class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_2.html#Cross_link_anchor_943\">Triangulation_euclidean_traits_2</A>&lt;R&gt;</I>\nis designed to deal with ordinary  two dimensional points.\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_xy_3.html#Cross_link_anchor_945\">Triangulation_euclidean_traits_xy_3</A>&lt;R&gt;</I> \nis a geometric traits class to build the triangulation\nof a terrain. Such a triangulation is a two-dimensional\ntriangulation embedded  in  three dimensional space.\nThe data points are three-dimensional points.\nThe triangulation is \nbuild according to  the projections of those points\non the <MATH><I>xy</I></MATH> plane  and then lifted up to the original\nthree-dimensional data points.\nThis is especially usefull\nto deal with GIS terrains.\nInstead of really projecting the  three-dimensional points and\nmaintaining a mapping between each point and its projection\n (which costs space and is error prone),\nthe traits class  supplies geometric predicates that ignore the\n<I>z</I>-coordinates of the points.\nSee Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Delaunay\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for an example.\nC<SMALL>GAL</SMALL> provides also the geometric traits classes\n<I>Triangulation_euclidean_traits_yz_3&lt;R&gt;</I> and\n<I>Triangulation_euclidean_traits_zx_3&lt;R&gt;</I> to\ndeal with projections on the\n <I>xz</I> plane  and  <I>yz</I>-plane,\nrespectively.\n<P>\n\n<h3>31.4.2&nbsp;&nbsp;&nbsp;Example of a Basic Triangulation</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Basic_Example\"></A>\n<P>\n\nThe following program  creates a  triangulation of 2D points\nusing the  default kernel \n<I>Exact_predicate_inexact_constructions_kernel</I>\nas geometric traits and the default triangulation data structure.\n The input points are read from a file \nand inserted in the triangulation.\nFinally points on the convex hull are written to <TT>cout</TT>. \n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/triangulation_prog1.C\n\n#include &lt;fstream&gt;\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_938\">CGAL::Triangulation_2</A>&lt;K&gt;         Triangulation;\ntypedef Triangulation::Vertex_circulator Vertex_circulator;\ntypedef Triangulation::Point             Point;\n\nint main() {\n  std::ifstream in(&quot;data/triangulation_prog1.cin&quot;);\n  std::istream_iterator&lt;Point&gt; begin(in);\n  std::istream_iterator&lt;Point&gt; end;\n\n  Triangulation t;\n  t.insert(begin, end);\n    \n  Vertex_circulator vc = t.incident_vertices(t.infinite_vertex()),\n    done(vc);\n  if (vc != 0) {\n    do { std::cout &lt;&lt; vc-&gt;point() &lt;&lt; std::endl;\n    }while(++vc != done);\n  }\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>31.5&nbsp;&nbsp;&nbsp;Delaunay Triangulations</h2>\n\n<A NAME=\"Section_2D_Triangulations_Delaunay\"></A>\n<P>\n\n<h3>31.5.1&nbsp;&nbsp;&nbsp;Description</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Delaunay_Description\"></A>\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>&lt;Traits,Tds&gt;</I> is designed to represent\nthe Delaunay triangulation of a set of data points in the plane.\nA  Delaunay triangulation\nfulfills\nthe following <I>empty circle property</I> \n(also called <I>Delaunay property</I>): the circumscribing\ncircle of any facet of the triangulation \ncontains no data point in its interior.\nFor a point set with no subset of four cocircular points\nthe Delaunay triangulation is unique, it is  dual\nto the Voronoi diagram of the set of points.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>&lt;Traits,Tds&gt;</I> derives\nfrom the class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I>.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>&lt;Traits,Tds&gt;</I>\ninherits the types defined by the \nbasic class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I>.\nAdditionnal types, provided by the traits class,\nare defined to represent the dual Voronoi diagram.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>&lt;Traits,Tds&gt;</I>\noverwrites the member functions that insert a new point\nin the triangulation \nor remove a vertex  from it\nto maintain the Delaunay property.\nIt also has a member function (<I>Vertex_handle         nearest_vertex(const Point&amp; p)</I>)\nto answer nearest neighbor queries\nand member functions to construct the elements (vertices and edges)\nof the dual Voronoi diagram.\n<P>\n\n<H3>Geometric traits</H3>\nThe geometric traits has to be a model of the concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_DelaunayTriangulationTraits_2.html#Cross_link_anchor_918\">DelaunayTriangulationTraits_2</A></I>\nwhich refines the concept <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I>.\nIn particular this concept provides\nthe <I><A HREF=\"../Kernel_23_ref/Function_side_of_oriented_circle.html#Cross_link_anchor_261\">side_of_oriented_circle</A></I> predicate\nwhich, given four points <I>p,q,r,s</I>\n decides the position of  the point <MATH><I>s</I></MATH>  with respect to the circle\npassing through <MATH><I>p</I></MATH>, <MATH><I>q</I></MATH> and <MATH><I>r</I></MATH>. \nThe <I><A HREF=\"../Kernel_23_ref/Function_side_of_oriented_circle.html#Cross_link_anchor_261\">side_of_oriented_circle</A></I>\npredicate actually defines the Delaunay triangulation.\nChanging this predicate \nallows to build variant of Delaunay triangulations for different metrics\nsuch that <MATH><I>L<SUB>1</SUB></I></MATH> or <MATH><I>L<SUB> <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </SUB></I></MATH> metric or any metric defined by a\nconvex object. However, the user of an exotic metric\nmust be careful that the constructed triangulation \nhas to be a triangulation of the convex hull\nwhich means that convex hull edges have to be Delaunay edges.\nThis is granted for any smooth convex metric (like <MATH><I>L<SUB>2</SUB></I></MATH>)\nand can be ensured for other metrics (like  <MATH><I>L<SUB> <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </SUB></I></MATH>)\nby the addition to the point set of well chosen sentinel points.\n<P>\n\nThe C<SMALL>GAL</SMALL>  kernel classes \n and the class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_2.html#Cross_link_anchor_943\">Triangulation_euclidean_traits_2</A>&lt;R&gt;</I>\nare models of the concept <I><A HREF=\"../Triangulation_2_ref/Concept_DelaunayTriangulationTraits_2.html#Cross_link_anchor_918\">DelaunayTriangulationTraits_2</A></I>\nfor the euclidean metric.\nThe traits class for terrains,\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_xy_3.html#Cross_link_anchor_945\">Triangulation_euclidean_traits_xy_3</A>&lt;R&gt;</I>,<BR>\n\n<I>Triangulation_euclidean_traits_yz_3&lt;R&gt;</I>, and<BR>\n\n<I>Triangulation_euclidean_traits_zx_3&lt;R&gt;</I><BR>\n\nare also models of  <I><A HREF=\"../Triangulation_2_ref/Concept_DelaunayTriangulationTraits_2.html#Cross_link_anchor_918\">DelaunayTriangulationTraits_2</A></I>\nexcapt that they do not fulfills \nthe requirements for the duality functions and nearest vertex\nqueries.\n<P>\n\n<H3>Implementation</H3>\nThe insertion of a new point in the Delaunay triangulation\nis performed using first the insertion member function\nof the basic triangulation and second \nperforming a sequence of flips to restore the Delaunay property. \nThe number of flips that have to be performed is O(d)\nif the new vertex has degree d in the updated\nDelaunay triangulation. For\npoints distributed uniformly at random, \neach insertion takes time O(1) on\naverage, once the point has been located in the triangulation.\n<P>\n\nRemoval calls the removal in the triangulation and then retriangulates\nthe hole created in such a way that  the Delaunay criterion is\nsatisfied. Removal of a\nvertex of degree d takes time O(d^2).\nThe degree <MATH><I>d</I></MATH> is O(1) for a random\nvertex in the triangulation.\n<P>\n\nAfter having performed a  point location, the\nnearest neighbor of a point is found in time O(n) in the\nworst case, but in time O(1)\nfor vertices distributed uniformly at random  and any query point.\n<P>\n\n<h3>31.5.2&nbsp;&nbsp;&nbsp;Example : a Delaunay Terrain</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Delaunay_Terrain\"></A>\n<P>\n\nThe following code  creates a Delaunay triangulation with \nthe usual Euclidean metric for the vertical projection of a \nterrain model. The points have elevation, that is they are 3D points,\nbut the predicates used to build the  Delaunay triangulation\nare computed using only  the <MATH><I>x</I></MATH> and <MATH><I>y</I></MATH> coordinates  \nof these points. \n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/terrain.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_xy_3.html#Cross_link_anchor_945\">Triangulation_euclidean_traits_xy_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n\n#include &lt;fstream&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_xy_3.html#Cross_link_anchor_944\">CGAL::Triangulation_euclidean_traits_xy_3</A>&lt;K&gt;  Gt;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;Gt&gt; Delaunay;\n\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>   Point;\n\nint main()\n{\n  std::ifstream in(&quot;data/terrain.cin&quot;);\n  std::istream_iterator&lt;Point&gt; begin(in);\n  std::istream_iterator&lt;Point&gt; end;\n\n  Delaunay dt;\n  dt.insert(begin, end);\n  std::cout &lt;&lt; dt.number_of_vertices() &lt;&lt; std::endl;\n  return 0;\n}\n\n</pre>\n<P>\n\n<h3>31.5.3&nbsp;&nbsp;&nbsp;Example : Voronoi Diagram</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Voronoi\"></A>\n \n     \n<A NAME=\"Index_anchor_871\"></A> \n \n   \n\nThe following code computes the edges of Voronoi diagram\nof a set of data points\nand counts  the number of finite edges and the number of rays\nof this diagram\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/Voronoi.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n\n#include &lt;fstream&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;K&gt;  Triangulation;\ntypedef Triangulation::Edge_iterator  Edge_iterator;\ntypedef Triangulation::Point          Point;\n\nint main( )\n{\n  std::ifstream in(&quot;data/voronoi.cin&quot;);\n  std::istream_iterator&lt;Point&gt; begin(in);\n  std::istream_iterator&lt;Point&gt; end;\n  Triangulation T;\n  T.insert(begin, end);\n\n  int ns = 0;\n  int nr = 0;  \n  Edge_iterator eit =T.edges_begin();\n  for ( ; eit !=T.edges_end(); ++eit) {\n    <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_87\">CGAL::Object</A> o = T.dual(eit);\n    K::<A HREF=\"../Kernel_23_ref/Class_Segment_2.html#Cross_link_anchor_56\">Segment_2</A> s;\n    K::<A HREF=\"../Kernel_23_ref/Class_Ray_2.html#Cross_link_anchor_54\">Ray_2</A>     r;\n    if (<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(s,o)) {++ns;}\n    if (<A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_89\">CGAL::assign</A>(r,o)) {++nr;}\n  }\n  std::cout &lt;&lt; &quot;The voronoi diagram as &quot; &lt;&lt; ns &lt;&lt; &quot;finite edges &quot; \n\t    &lt;&lt; &quot; and &quot; &lt;&lt; nr &lt;&lt; &quot; rays&quot; &lt;&lt; std::endl;\n  return 0;\n}\n \n</pre>\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>31.6&nbsp;&nbsp;&nbsp;Regular Triangulations</h2>\n\n<A NAME=\"Section_2D_Triangulations_Regular\"></A>\n<P>\n\n<h3>31.6.1&nbsp;&nbsp;&nbsp;Description</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Regular_Description\"></A>\n \n     \n<A NAME=\"Index_anchor_872\"></A> \n \n   \n\nLet <MATH><I>  PW = {(p<SUB>i</SUB>, w<SUB>i</SUB>), i = 1, ..., n }</I></MATH> be a set of \nweighted points where each <MATH><I>p<SUB>i</SUB></I></MATH> is a point and each <MATH><I>w<SUB>i</SUB></I></MATH>\nis a scalar called the weight of point <MATH><I>p<SUB>i</SUB></I></MATH>.\nAlternatively, each weighted point <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH> can be regarded\nas a sphere (or a circle, depending on the dimensionality\nof <MATH><I>p<SUB>i</SUB></I></MATH>)  with center <MATH><I>p<SUB>i</SUB></I></MATH> and radius <MATH><I>r<SUB>i</SUB>=<A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(w<SUB>i</SUB>)</I></MATH>.\n<P>\n\nThe power diagram of the set <MATH><I>  PW</I></MATH> is a space partition in which\n each cell corresponds to a sphere <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH> of <MATH><I>  PW</I></MATH>\nand is the locus of points  <MATH><I>p</I></MATH> whose power with respect to <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>\nis less than its power with respect to any other sphere \nin <MATH><I>  PW</I></MATH>. In the two-dimensional space,\nthe dual of this diagram is a triangulation \nwhose domain covers the convex hull of the set \n<MATH><I>  P= { p<SUB>i</SUB>, i = 1, ..., n }</I></MATH> of center points\nand whose vertices form a subset of <MATH><I>  P</I></MATH>.\nSuch a triangulation is called a regular triangulation.\nThree points <MATH><I>p<SUB>i</SUB>, p<SUB>j</SUB></I></MATH> and <MATH><I>p<SUB>k</SUB></I></MATH> of <MATH><I>  P</I></MATH>\nform a triangle in the regular triangulation of <MATH><I>  PW</I></MATH>\niff there is a point <MATH><I>p</I></MATH> of the plane with equal \npowers with respect to <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nand <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH> and such that this power \nis  less than the power of <MATH><I>p</I></MATH>\nwith respect to any other sphere in  <MATH><I>  PW</I></MATH>.\n<P>\n\nLet us defined the power product of two weighted points\n<MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH> and <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH> as:\n<P ALIGN=CENTER>\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUB>i</SUB>, w<SUB>i</SUB>,p<SUB>j</SUB>, w<SUB>j</SUB>) = p<SUB>i</SUB>p<SUB>j</SUB> <SUP>2</SUP> - w<SUB>i</SUB>  - w<SUB>j</SUB>  .</I></MATH>\n<P>\n\n<MATH><I><IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Pi.gif\">(p<SUB>i</SUB>, w<SUB>i</SUB>,p<SUB>j</SUB>, 0)</I></MATH> is simply the power of point <MATH><I>p<SUB>j</SUB></I></MATH>\nwith respect to the sphere <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, and two weighted points \nare said to be orthogonal if their power product is null.\nThe power circle of three weighted points\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nand <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH> is defined as the unique circle\n<MATH><I>(<IMG BORDER=0 WIDTH=9 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_pi.gif\">, <IMG BORDER=0 WIDTH=10 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_omega.gif\">)</I></MATH>  orthogonal to\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>\nand <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH>.\n<P>\n\nThe regular triangulation of the sets <MATH><I>  PW</I></MATH>\nsatisfies the following <I>regular property</I> (which just reduces to the \nDelaunay property when all the weights are null):\na triangle <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB></I></MATH> is a face of the regular triangulation\nof <MATH><I>  PW</I></MATH> iff the power product of any weighted point\n <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH> of <MATH><I>  PW</I></MATH> with the power circle of\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH> and <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH> is positive or null.\nWe call  power test of  <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>, <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH>,\nand <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH>,  the predicates which amount to compute\nthe <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of \nthe power product of <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH> with respect to\nthe power circle of\n <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH> and <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH>.\nThis predicate amounts to computing the <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of\nthe following\ndeterminant\n<P ALIGN=CENTER>\n<MATH><I>| \n<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>i</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>i</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>i</SUB> <SUP>2</SUP> + y<SUB>i</SUB> <SUP>2</SUP> - w<SUB>i</SUB>  \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>j</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>j</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>j</SUB> <SUP>2</SUP> + y<SUB>j</SUB> <SUP>2</SUP> - w<SUB>j</SUB>  \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>k</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>k</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>k</SUB> <SUP>2</SUP> + y<SUB>k</SUB> <SUP>2</SUP> - w<SUB>k</SUB>  \n    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\n1  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>l</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\ny<SUB>l</SUB>  \n        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\nx<SUB>l</SUB> <SUP>2</SUP> + y<SUB>l</SUB> <SUP>2</SUP> - w<SUB>l</SUB>\n\n</TD></TR></TABLE>\n\n|\n</I></MATH>\n<P>\n\nA pair of neighboring faces <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB></I></MATH>\nand <MATH><I>p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>l</SUB></I></MATH> is said to be locally regular\n(with respect to  the weights in <MATH><I>  PW</I></MATH>)\nif the power test of <MATH><I>(p<SUB>i</SUB>, w<SUB>i</SUB>)</I></MATH>, <MATH><I>(p<SUB>j</SUB>, w<SUB>j</SUB>)</I></MATH>, <MATH><I>(p<SUB>k</SUB>, w<SUB>k</SUB>)</I></MATH>,\nand <MATH><I>(p<SUB>l</SUB>, w<SUB>l</SUB>)</I></MATH> is positive.\nA classical  result of computational geometry\nestablishes that a triangulation of the convex hull of <MATH><I>  P</I></MATH>\nsuch that any pair of neighboring faces is regular with respect\nto <MATH><I>  PW</I></MATH>, is a\n regular triangulation of <MATH><I>  PW</I></MATH>.\n<P>\n\nAlternatively, the regular triangulation\nof the weighted points set <MATH><I>  PW</I></MATH>\ncan be obtained as the projection\non the two dimensional plane of the convex hull of the set of three\ndimensional points \n<MATH><I>  P'= { (p<SUB>i</SUB>,p<SUB>i</SUB> <SUP>2</SUP> - w<SUB>i</SUB> ), i = 1, ..., n }</I></MATH>.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>&lt;Traits, Tds&gt;</I>\n is designed to maintain the\nregular triangulation of a set of <MATH><I>2d</I></MATH> weighted points.\nIt derives from the class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits, Tds&gt;</I>.\nThe functions <I>insert</I> and \n<I>remove</I> are overwritten to handle weighted points\nand maintain the regular\nproperty.\nThe vertices of the regular triangulation\nof a set of weighted points <MATH><I>PW</I></MATH> correspond  only to a subset\nof <MATH><I>PW</I></MATH>.\nSome of the input\nweigthed points have no cell in the dual power diagrams\nand therefore do not correspond to a vertex of the regular\ntriangulation.\nSuch a point is called a hidden point.\nBecause hidden points can reappear later on as vertices\nwhen  some other point is removed,\nthey  have to be stored somewhere. \nThe regular triangulation  store those points in special vertices, called\nhidden vertices. \nA hidden point can reappear as vertex of the triangulation\nonly when the two dimensional face that hides it\nis removed from the triangulation. To deal with this feature,\neach face of a regular triangulation stores a list of hidden vertices.\nThe points in those vertices \nare reinserted in the triangulation  when the face\nis removed.\n<P>\n\nRegular triangulation have member functions to construct\nthe vertices and edges of the dual power diagrams.\n<P>\n\n<h4>The geometric traits</h4>\n\nThe geometric traits of a regular triangulation\nmust provide a weighted point type\nand a power test on these weighted points.\nThe concept \n<I><A HREF=\"../Triangulation_2_ref/Concept_RegularTriangulationTraits_2.html#Cross_link_anchor_924\">RegularTriangulationTraits_2</A></I>,\nis a refinement of the concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I>. C<SMALL>GAL</SMALL> provides \nthe class\n<I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_euclidean_traits_2.html#Cross_link_anchor_929\">Regular_triangulation_euclidean_traits_2</A>&lt;Rep,Weight&gt;</I>\nwhich is a model for the traits concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_RegularTriangulationTraits_2.html#Cross_link_anchor_924\">RegularTriangulationTraits_2</A></I>.\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_euclidean_traits_2.html#Cross_link_anchor_929\">Regular_triangulation_euclidean_traits_2</A>&lt;Rep,Weight&gt;</I>\nderives  from the class\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_2.html#Cross_link_anchor_943\">Triangulation_euclidean_traits_2</A>&lt;Rep&gt;</I>\nand uses a <I><A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A></I> type\nderived from the type <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I> of\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_euclidean_traits_2.html#Cross_link_anchor_943\">Triangulation_euclidean_traits_2</A>&lt;Rep&gt;</I>.\nThere is also a class <I>Regular_triangulation_filtered_traits_2&lt;FK&gt;</I>\nwhich provides filtered predicates (efficient and exact).\n<P>\n\n<h4>The Vertex type and Face Type of a Regular Triangulation</h4>\n<P>\n\nThe base vertex type of a regular triangulation\nincludes a boolean to mark the hidden state of the vertex.\nTherefore  CGAL defines the concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_RegularTriangulationVertexBase_2.html#Cross_link_anchor_925\">RegularTriangulationVertexBase_2</A></I> which refine\nthe concept <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationVertexBase_2.html#Cross_link_anchor_937\">TriangulationVertexBase_2</A></I>\nand provides a default model \nfor this concept.\n<P>\n\nThe base face type of a regular triangulation\nis required to provide a list of hidden vertices,\ndesigned to store the points hidden by the face. It has to be a model\nof the concept <I><A HREF=\"../Triangulation_2_ref/Concept_RegularTriangulationFaceBase_2.html#Cross_link_anchor_923\">RegularTriangulationFaceBase_2</A></I>.\nC<SMALL>GAL</SMALL> provides the templated class \n<I><A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_face_base_2.html#Cross_link_anchor_931\">Regular_triangulation_face_base_2</A>&lt;Traits&gt;</I>\nas a default base class for faces of regular triangulations.\n<P>\n\n<h3>31.6.2&nbsp;&nbsp;&nbsp;Example : a Regular Triangulation</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Regular_Example\"></A>\n<P>\n\nThe following code  creates a regular triangulation \nof a set of weighted points and ouput the number\nof vertices and the number of hidden vertices.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/regular.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_euclidean_traits_2.html#Cross_link_anchor_929\">Regular_triangulation_euclidean_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_927\">Regular_triangulation_2</A>.h&gt;\n\n#include &lt;fstream&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef double W;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_euclidean_traits_2.html#Cross_link_anchor_928\">CGAL::Regular_triangulation_euclidean_traits_2</A>&lt;K,W&gt;  Gt;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Regular_triangulation_2.html#Cross_link_anchor_926\">CGAL::Regular_triangulation_2</A>&lt;Gt&gt; Regular_triangulation;\n\nint main()\n{\n   Regular_triangulation rt;\n   std::ifstream in(&quot;data/regular.cin&quot;);\n\n   Regular_triangulation::<A HREF=\"../Triangulation_2_ref/Class_Weighted_point.html#Cross_link_anchor_959\">Weighted_point</A> wp;\n   int count = 0;\n   while(in &gt;&gt; wp){\n       count++;\n     rt.insert(wp);\n   }\n   rt.is_valid();\n   std::cout &lt;&lt; &quot;number of inserted points : &quot; &lt;&lt; count &lt;&lt; std::endl;\n   std::cout &lt;&lt; &quot;number of vertices :  &quot; ;\n   std::cout &lt;&lt; rt.number_of_vertices() &lt;&lt; std::endl;\n   std::cout &lt;&lt; &quot;number of hidden vertices :  &quot; ;\n   std::cout &lt;&lt; rt.number_of_hidden_vertices() &lt;&lt; std::endl;\n   return 0;\t\n}\n</pre>\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>31.7&nbsp;&nbsp;&nbsp;Constrained Triangulations</h2>\n\n<A NAME=\"Section_2D_Triangulations_Constrained\"></A>\n<P>\n\n<A NAME=\"Subsection_2D_Triangulations_Constrained_Description\"></A>\nA constrained triangulation is a triangulation of a set of points\nthat has to include among its edges \na given set of segments joining the points. The corresponding \nedges are called <I>constrained edges</I>.\n<P>\n\nThe endpoints of constrained edges are of course vertices of the\ntriangulation. However the triangulation may include\ninclude other vertices as well.\nThere are three versions of  constrained triangulations.\n<UL>\n<LI>In the basic version, the constrained triangulation \ndoes not handle intersecting constraints, and the set of input \nconstraints is required to be a set of segments that do not intersect\nexcept possibly at their endpoints. Any number of constrained edges\nare allowed to share the same endpoint.  Vertical constrained edges or\nconstrained edges with null length are allowed.\n<LI>The two other versions support intersecting input constraints.\nIn those versions, input constraints are allowed to be\nintersecting, overlapping or partially\noverlapping segments.\nThe triangulation introduces  additional  vertices at each point that\nis the proper <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> points of  two \nconstraints. A single constraint intersecting other\nconstraints will then appear as several edges in the triangulation.\nThe two versions dealing with intersecting constraints differ\nin the way intersecting constraints are dealt with.\n<UL>\n<LI>One of them is\ndesigned to be robust when predicates are evaluated exactly but\nconstructions (i. e.  <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> computations) are\napproximative.\n<LI>The other one is designed to be used \nwith exact arithmetic (meaning exact\nevaluation of predicates and exact computation of intersections.)\nThis last version finds its full efficiency  when used in conjunction\nwith a constraint hierarchy data structure (which allows one to avoid the\ncascading of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> computations)\nas provided in the class\n<I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A></I>. See\nsection&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained_Plus\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n</UL>\n</UL>\n<P>\n\n<CENTER>\n<img border=0 src=\"./constraints.gif\" align=center alt=\"A set of\nconstraints and its constrained triangulation\">\n</CENTER>\n<P>\n\nA constrained triangulation is represented in the CGAL library as an\nobject of the class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_2.html#Cross_link_anchor_913\">Constrained_triangulation_2</A>&lt;Traits,Tds,Itag&gt;</I>.\nThe third parameter <I>Itag</I> is the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> tag\nwhich serves to choose how intersecting constraints\nare dealt with. This parameter has to be instantiated\nby one of the following classes&nbsp;:\n<I>CGAL::No_intersection_tag</I> when input constraints do not\nintersect<BR>\n\n<I>CGAL::Exact_predicates_tag</I> if the geometric traits provides\nexact predicates but approximative constructions<BR>\n\n<I>CGAL::Exact_intersections_tag</I> when an exact predicates\nand exact constructions are provided.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_2.html#Cross_link_anchor_913\">Constrained_triangulation_2</A>&lt;Traits,Tds, Itag&gt;</I>\ninherits from <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I>.\nIt defines an additionnal type <I>Constraint</I>\nto represent the constraints. A\nconstraint is represented as a pair of points.\n<P>\n\nA  constrained triangulation can be created\nfrom a\nlist of constrained edges.\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_2.html#Cross_link_anchor_913\">Constrained_triangulation_2</A>&lt;Traits,Tds,Itag&gt;</I>\noverrides the insertion and removal of a point to take care of the\ninformation about constrained edges. The class also allows inline\ninsertion of a new constraint, given by its two endpoints\nor the removal of a constraint.\n<P>\n\n<h4>The Geometric Traits</h4>\n\nThe geometric traits of a constraint triangulation\n has to be a model\nof the concept <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I>.\nWhen intersections of input constraints are supported, \nthe geometric traits class has to be a model \nof the concept <I><A HREF=\"../Triangulation_2_ref/Concept_ConstrainedTriangulationTraits_2.html#Cross_link_anchor_909\">ConstrainedTriangulationTraits_2</A></I>\nwhich refines the concept <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationTraits_2.html#Cross_link_anchor_936\">TriangulationTraits_2</A></I>\nproviding  additional function object types\nto compute the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> of two segments.\n<P>\n\n<h4>The Base Face of a Constrained Triangulation</h4>\n\n The information about constrained edges is stored in the \nfaces of the triangulation. The base face of a Constrained Triangulation\nhas to be a model for the concept <I><A HREF=\"../Triangulation_2_ref/Concept_ConstrainedTriangulationFaceBase_2.html#Cross_link_anchor_908\">ConstrainedTriangulationFaceBase_2</A></I>\nwhich refines the concept <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationFaceBase_2.html#Cross_link_anchor_934\">TriangulationFaceBase_2</A></I>.\nThe concept <I><A HREF=\"../Triangulation_2_ref/Concept_ConstrainedTriangulationFaceBase_2.html#Cross_link_anchor_908\">ConstrainedTriangulationFaceBase_2</A></I>\nrequires  member functions\n the get and set the constrained status of the edges.\n<P>\n\nC<SMALL>GAL</SMALL> provides a default base face class\nfor constrained triangulations. This class, named\n<I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_face_base_2.html#Cross_link_anchor_915\">Constrained_triangulation_face_base_2</A>&lt;Traits&gt;</I>,\nderives from the class\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_2.html#Cross_link_anchor_947\">Triangulation_face_base_2</A>&lt;Traits&gt;</I>\nand adds three booleans to store the status of its edges.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Constrained and Constrained Delaunay triangulation : \n the constraining edges are the green edges,  a constrained\ntriangulation is shown on the left, the constrained Delaunay\ntriangulation with two examples of circumcircles is shown on the right.\n<A NAME=\"2D_Triangulation_Fig_constrained\"></A>\n\n<CENTER>\n<img border=0 src=\"./poisson.gif\" width=300 alt=\" Constrained triangulation\">\n<img border=0 src=\"./del_poisson.gif\" width=300 alt=\"Constrained Delaunay triangulation\">\n</CENTER>\n<P>\n\n<a name=\"Section_8\"></a>\n        \n<h2>31.8&nbsp;&nbsp;&nbsp;Constrained Delaunay Triangulations</h2>\n\n<A NAME=\"Section_2D_Triangulations_Constrained_Delaunay\"></A>\n<P>\n\n<A NAME=\"Subsection_2D_Triangulations_Constrained_Delaunay_Description\"></A>\nA constrained Delaunay triangulation is a triangulation with\nconstrained edges which tries to be as much Delaunay as possible.\nAs constrained edges are not necessarily Delaunay edges,\nthe triangles of a constrained Delaunay triangulation do not\nnecessarily fulfill the empty circle property\nbut they fulfill a weaker <I>constrained empty circle property</I>.\n To state this property,\nit is convenient to think of  constrained\nedges as blocking the view. Then, a triangulation is \nconstrained Delaunay iff\n the circumscribing circle\nof any facet encloses \nno vertex  visible\nfrom the interior of the facet.\nAs in the case of constrained triangulations, three different versions\nof Delaunay constrained triangulations are provided. The first version\nhandle set of constraints which do not intersect except possibly\nat the endpoints. The two other versions \nhandle intersecting input constraints. One of them\n is designed to be designed to be robust\nwhen used in conjunction with a geometric traits\nproviding exact predicates and approximative constructions\n(such as a <I>CGAL::Filtered_Kernel</I> or any kernel providing\nfiltered exact predicates). The third version is designed to be used\nwith an exact arithmetic number type.\n<P>\n\nThe C<SMALL>GAL</SMALL> class\n<I><A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>&lt;Traits,Tds,Itag&gt;</I>\nis designed to represent\nconstrained Delaunay triangulations.\n<P>\n\nAs in the case of constraints triangulation, the third parameter \n<I>Itag</I> is the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> tag\nand serves to choose how intersecting constraints\nare dealt with. It can be instantiated with one of the following\nclass&nbsp;: <I>CGAL::No_intersection_tag</I>,\n<I>CGAL::Exact_predicates_tag</I>,\n<I>CGAL::Exact_intersections_tag</I> \n(see Section&nbsp;<A HREF=\"Chapter_main.html#Section_2D_Triangulations_Constrained\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nA constrained Delaunay triangulation is not a Delaunay\ntriangulation but it is a constrained triangulation.\nTherefore the class\n<I><A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>&lt;Traits,Tds,Itag&gt;</I>\nderives from\nthe class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_2.html#Cross_link_anchor_913\">Constrained_triangulation_2</A>&lt;Traits,Tds,Itag&gt;</I>.\n<P>\n\nThe constrained Delaunay triangulation\nhas member functions to override the \ninsertion and removal of a point or of a constraint.\nEach of those member function takes care\nto  restore\n the constrained empty circle\nproperty.\n<P>\n\n<h4>The Geometric Traits</h4>\n\n The geometric traits \nof a constrained Delaunay triangulation is required\nto provide the <I><A HREF=\"../Kernel_23_ref/Function_side_of_oriented_circle.html#Cross_link_anchor_261\">side_of_oriented_circle</A></I> predicate as the geometric traits\nof a Delaunay triangulation and has to a model of the concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_DelaunayTriangulationTraits_2.html#Cross_link_anchor_918\">DelaunayTriangulationTraits_2</A></I>. When intersecting input\nconstraints\nare supported the geometric traits is further required \nto provide function objects to compute constraints intersections.\nThen the geometric traits has to be at the same time a model\nof the concept <I><A HREF=\"../Triangulation_2_ref/Concept_ConstrainedTriangulationTraits_2.html#Cross_link_anchor_909\">ConstrainedTriangulationTraits_2</A></I>.\n<P>\n\n<h4>The face base class</h4>\n\nInformation about the status (constrained or not)\nof the edges of the triangulation has to be stored\nin the face class\n and the base face class\nof a constrained Delaunay triangulation has to be a model\nof <I><A HREF=\"../Triangulation_2_ref/Concept_ConstrainedTriangulationFaceBase_2.html#Cross_link_anchor_908\">ConstrainedTriangulationFaceBase_2</A></I>.\n<P>\n\n<h3>31.8.1&nbsp;&nbsp;&nbsp;Example : a  constrained Delaunay triangulation</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Constrained_Delaunay_Example\"></A>\nThe following code inserts a set of intersecting constraint segments\ninto a triangulation \nand counts the number of constrained edges of the\nresulting triangulation.\n<P>\n\n<pre class=\"ExampleCode\">// file : examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/constrained.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt;                     Vb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_face_base_2.html#Cross_link_anchor_914\">CGAL::Constrained_triangulation_face_base_2</A>&lt;K&gt;           Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;              TDS;\ntypedef CGAL::Exact_predicates_tag                               Itag;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K, TDS, Itag&gt; CDT;\ntypedef CDT::Point          Point;\n\nint\nmain( )\n{\n  CDT cdt;\n  std::cout &lt;&lt; &quot;Inserting a grid of 5x5 constraints &quot; &lt;&lt; std::endl;\n  for (int i = 1; i &lt; 6; ++i) \n    cdt.insert_constraint( Point(0,i), Point(6,i));\n  for (int j = 1; j &lt; 6; ++j) \n    cdt.insert_constraint( Point(j,0), Point(j,6));\n  \n  assert(cdt.is_valid());\n  int count = 0;\n  for (CDT::Finite_edges_iterator eit = cdt.finite_edges_begin();\n       eit != cdt.finite_edges_end();\n       ++eit)\n    if (cdt.is_constrained(*eit)) ++count;\n  std::cout &lt;&lt; &quot;The number of resulting constrained edges is  &quot;;\n  std::cout &lt;&lt;  count &lt;&lt; std::endl;\n  return 0;\n}\n  \n</pre>\n<P>\n\n<a name=\"Section_9\"></a>\n        \n<h2>31.9&nbsp;&nbsp;&nbsp;Constrained Triangulations Plus</h2>\n\n<A NAME=\"Section_2D_Triangulations_Constrained_Plus\"></A>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A>&lt;Tr&gt;</I>\nprovides a constrained triangulation with an additional data\nstructure called the  constraint hierarchy \nthat keeps track of  the input constraints and of their refinement\nin the triangulation.\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A>&lt;Tr&gt;</I>\ninherits from its template parameter Tr, which has to be instantiated\nby a constrained  or constrained Delaunay  triangulation.\nAccording to its <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> tag, the base class\nwill support intersecting input constraints or not.\nWhen intersections of input constraints are supported,\nthe base class constructs a triangulation  of the  arrangement\nof the constraints,\nintroducing new vertices at each proper <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\npoints and  refining the input constraints into subconstraints\nwhich appear as  edges (more precisely as constrained edges) of the\ntriangulation.  The  data structure maintains for each \ninput constraint\nthe sequence of <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> vertices added on this constraint.\nThe constraint hierarchy also allows the user to retrieve the set\nof constrained edges of the triangulation, and for each\nconstrained edge,  the set of input constraints that overlap it.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A>&lt;Tr&gt;</I>\nis especially useful when the base constrained triangulation class\nhandles intersections of constraints and uses an exact number type,\ni.e. when its <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A> tag is <I>CGAL::Exact_intersections_tag</I>.\nIndeed in this case, the <I><A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A>&lt;Tr&gt;</I>\nis specially designed to avoid cascading in the computations of\n<A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>  points.\n<P>\n\n<h3>31.9.1&nbsp;&nbsp;&nbsp;Example : Building a triangulated arrangement of segments</h3>\n<P>\n\nThe following code inserts a set of intersecting constraint segments\ninto a triangulation \nand counts the number of constrained edges of the\nresulting triangulation.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/constrained_plus.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel.html#Cross_link_anchor_34\">Exact_predicates_exact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/intersections.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel.html#Cross_link_anchor_33\">CGAL::Exact_predicates_exact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt;              Vb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_face_base_2.html#Cross_link_anchor_914\">CGAL::Constrained_triangulation_face_base_2</A>&lt;K&gt;    Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;       TDS;\ntypedef CGAL::Exact_intersections_tag                     Itag;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K,TDS,Itag&gt; CDT;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_916\">CGAL::Constrained_triangulation_plus_2</A>&lt;CDT&gt;       CDTplus;\ntypedef CDTplus::Point                                    Point;\n\nint\nmain( )\n{\n  CDTplus cdt;\n  std::cout  &lt;&lt; &quot;Inserting a grid 5 x 5 of constraints &quot; &lt;&lt; std::endl;\n  for (int i = 1; i &lt; 6; ++i) \n    cdt.insert_constraint( Point(0,i), Point(6,i));\n  for (int j = 1; j &lt; 6; ++j) \n    cdt.insert_constraint( Point(j,0), Point(j,6));\n  \n  assert(cdt.is_valid());\n  int count = 0;\n  for (CDTplus::Subconstraint_iterator scit = cdt.subconstraints_begin();\n       scit != cdt.subconstraints_end();\n       ++scit)  ++count;\n  std::cout &lt;&lt; &quot;The number of resulting constrained edges is  &quot;\n\t    &lt;&lt;  count &lt;&lt; std::endl;\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_10\"></a>\n        \n<h2>31.10&nbsp;&nbsp;&nbsp;The Triangulation Hierarchy</h2>\n\n<A NAME=\"Section_2D_Triangulations_Hierarchy\"></A>\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A>&lt;Tr&gt;</I>\nimplements a triangulation augmented with\na data structure to answer efficiently  point location queries.\nThe data structure is a hierarchy \nof triangulations. The triangulation at the lowest level is\nthe original triangulation where operations and point location are to \nbe performed.\nThen at each succedding level, the data structure\nstores a triangulation of a small random sample of the vertices\nof the triangulation at the preceeding level. Point location\nis done through a top down nearest neighbor query.\nThe nearest neighbor query is first\nperformed naively in the top level triangulation.\nThen, at each following level, the nearest neighbor at that level\nis found through a linear walk performed from\nthe nearest neighbor found at the preceeding level.\nBecause the number of vertices in each triangulation is only a small\nfraction of the number of vertices of the preceeding triangulation,\nthe data structure remains small and achieves fast point location \nqueries  on real\ndata. As proved in&nbsp;[<A HREF=\"../biblio.html#Biblio_d-iirdt-98\">Dev98</A>], this structure has an optimal behaviour\nwhen it is built for Delaunay triangulations.\nHowever it can be used as well for other triangulations\nand the class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A>&lt;Tr&gt;</I> is templated by a parameter\nwhich is to be instantiated by one of the C<SMALL>GAL</SMALL> triangulation\nclasses.\n<P>\n\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A>&lt;Tr&gt;</I> inherits from the\ntriangulation type passed as template parameter <I>Tr</I>. \nThe insert and remove member functions\nare  overwritten to update the data structure at each operation.\nThe locate queries are also overwritten to take advantage of the data\nstructure for a fast processing.\n<P>\n\n<h4>The Vertex of a Triangulation Hierarchy</h4>\n\nThe base vertex class  of a triangulation hierarchy \nhas to be a model of the\nconcept\n<I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationHierarchyVertexBase_2.html#Cross_link_anchor_935\">TriangulationHierarchyVertexBase_2</A></I> which extends\nthe concept <I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationVertexBase_2.html#Cross_link_anchor_937\">TriangulationVertexBase_2</A></I>.\nThis extension adds\naccess and setting member functions \nfor two pointers  to the corresponding vertices in the \ntriangulations of the next and preceeding levels.\n<P>\n\nC<SMALL>GAL</SMALL> provides the class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_vertex_base_2.html#Cross_link_anchor_953\">Triangulation_hierarchy_vertex_base_2</A>&lt;Vb&gt;</I>\nwhich is a model for the concept \n<I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationHierarchyVertexBase_2.html#Cross_link_anchor_935\">TriangulationHierarchyVertexBase_2</A></I>.\nThis class is templated by a parameter <I>Vb</I>\nwhich is to be instantiated by a model of  the concept\n<I><A HREF=\"../Triangulation_2_ref/Concept_TriangulationVertexBase_2.html#Cross_link_anchor_937\">TriangulationVertexBase_2</A></I>.\nThe class <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_vertex_base_2.html#Cross_link_anchor_953\">Triangulation_hierarchy_vertex_base_2</A>&lt;Vb&gt;</I> inherits\nfrom its template parameter <I>Vb</I>.\nThis design allows to use for  <I>Vb</I> \neither the default\nvertex base class or a user customized\nvertex base with additionnal functionalities.\n<P>\n\n<h3>31.10.1&nbsp;&nbsp;&nbsp;Examples of the Use of a  Triangulation Hierarchy</h3>\n\n<A NAME=\"Subsection_2D_Triangulations_Hierarchy_Examples\"></A>\n<P>\n\nThe following program is example\nof the  standard use of a  triangulation hierarchy\nto enhance the efficiency\nof a Delaunay triangulation. The program output the number of vertices\nat the different levels of the hierarchy.\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/hierarchy.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_920\">Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A>.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/algorithm.h&gt;\n#include &lt;cassert&gt;\n\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt;             Vbb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_vertex_base_2.html#Cross_link_anchor_952\">CGAL::Triangulation_hierarchy_vertex_base_2</A>&lt;Vbb&gt; Vb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_2.html#Cross_link_anchor_946\">CGAL::Triangulation_face_base_2</A>&lt;K&gt;               Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;      Tds;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Delaunay_triangulation_2.html#Cross_link_anchor_919\">CGAL::Delaunay_triangulation_2</A>&lt;K,Tds&gt;            Dt;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_950\">CGAL::Triangulation_hierarchy_2</A>&lt;Dt&gt;              Triangulation;\ntypedef Triangulation::Point                             Point;\ntypedef <A HREF=\"../STL_Extension_ref/FunctionObjectClass_Creator_uniform_2.html#Cross_link_anchor_1565\">CGAL::Creator_uniform_2</A>&lt;double,Point&gt;            Creator;\n \nint main( )\n{\n  std::cout &lt;&lt; &quot;insertion of 1000 random points&quot; &lt;&lt; std::endl;\n  Triangulation t;\n  <A HREF=\"../Generator_ref/Class_Random_points_in_square_2.html#Cross_link_anchor_1699\">CGAL::Random_points_in_square_2</A>&lt;Point,Creator&gt; g(1.);\n  <A HREF=\"../STL_Extension_ref/Function_copy_n.html#Cross_link_anchor_1445\">CGAL::copy_n</A>( g, 1000, std::back_inserter(t));\n  \n  //verbose mode of is_valid ; shows the number of vertices at each  level\n  std::cout &lt;&lt; &quot;The number of vertices at successive levels&quot; &lt;&lt; std::endl; \n  assert(t.is_valid(true));\n\n  return 0;\n}\n</pre>\n<P>\n\nThe following program shows how to use\na triangulation hierachy in conjonction with a constrained \ntriangulation plus.\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/constrained_hierarchy_plus.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_911\">Constrained_Delaunay_triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_951\">Triangulation_hierarchy_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_917\">Constrained_triangulation_plus_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt;             Vbb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_vertex_base_2.html#Cross_link_anchor_952\">CGAL::Triangulation_hierarchy_vertex_base_2</A>&lt;Vbb&gt; Vb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_face_base_2.html#Cross_link_anchor_914\">CGAL::Constrained_triangulation_face_base_2</A>&lt;K&gt;   Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;      TDS;\ntypedef CGAL::Exact_predicates_tag                       Itag;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_Delaunay_triangulation_2.html#Cross_link_anchor_910\">CGAL::Constrained_Delaunay_triangulation_2</A>&lt;K,TDS,Itag&gt; CDT;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_hierarchy_2.html#Cross_link_anchor_950\">CGAL::Triangulation_hierarchy_2</A>&lt;CDT&gt;             CDTH;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Constrained_triangulation_plus_2.html#Cross_link_anchor_916\">CGAL::Constrained_triangulation_plus_2</A>&lt;CDTH&gt;     Triangulation;\n\ntypedef Triangulation::Point                             Point;\n\nint \nmain( )\n{\n  Triangulation cdt;\n  std::cout &lt;&lt; &quot;Inserting a grid 5 x 5 of  constraints &quot; &lt;&lt; std::endl;\n    for (int i = 1; i &lt; 6; ++i) \n    cdt.insert_constraint( Point(0,i), Point(6,i));\n    for (int j = 1; j &lt; 6; ++j) \n    cdt.insert_constraint( Point(j,0), Point(j,6));\n  \n  int count = 0;\n  for (Triangulation::Subconstraint_iterator scit = cdt.subconstraints_begin();\n       scit != cdt.subconstraints_end();\n       ++scit)  ++count;\n  std::cout &lt;&lt; &quot;The number of resulting constrained edges is  &quot;;\n  std::cout &lt;&lt;  count &lt;&lt; std::endl;\n\n  //verbose mode of is_valid ; shows the number of vertices at each  level\n  std::cout &lt;&lt; &quot;The number of vertices at successive levels&quot; &lt;&lt; std::endl; \n  assert(cdt.is_valid(true));\n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_11\"></a>\n        \n<h2>31.11&nbsp;&nbsp;&nbsp;Flexibility: Using  Customized Vertices and Faces</h2>\n\n<A NAME=\"Section_2D_Triangulations_Flexibility\"></A>\n<P>\n\nTo be able to adapt to  various needs, a highly\nflexible design has been  selected for 2D triangulations.\nWe have already seen that\nthe triangulation classes have two\nparameters : a geometric traits class\nand a triangulation data structure  class\nwhich the user can instantiate with his own customized classes.\n<P>\n\nThe most usefull flexibility however comes from the fact\nthat the triangulation data structure itself has two template\nparameters to be instantiated by \nbase classes for the vertices and faces of the triangulation.\nThe vertex and face classes of the triangulation are derived\nfrom those base classes. \nThus, using his own customized classes to instantiate these\nparameters, the user can easily build up  a triangulation with additionnal\ninformations or functionalities in the vertices and faces.\n<P>\n\n<B>A cyclic dependancy</B>\nTo insure flexibility, the triangulation data structure is templated by the\nvertex and face base classes. Also since incidence and adjacency\nrelations are stored in vertices and faces, the base classes have to\nknow the types of handles on vertices and faces provided\nby the triangulation data structure. Thus the vertex and base\nclasses have to be thenselves parameterized by the triangulation data\nstructure, and there is a cyclic dependancy on template parameter.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>The cyclic dependency in triangulations software design.\n<A NAME=\"2D_Triangulation_Fig_three_levels_2\"></A>\n\n<CENTER><BR>\n\n<img border=0 src=\"./threelevels2.gif\" align=center alt=\"Three_levels\">\n</CENTER>\n<P>\n\nPreviously, this cyclic dependency was avoided by \nusing only <I>void*</I> pointers in the interface of base classes.\nThese <I>void*</I> were converted to appropriate types at the\ntriangulation data structure levels. This solution had some drawbacks\n&nbsp;: mainly the user could not add in the vertices or faces of the \ntriangulation a functionality related to types defined by \nthe triangulation data structure, for instance a handle to a vertex,\nand he was lead to use himself \n<I>void*</I>  pointers).\nThe new solution to resolve the template dependancy\nis based on a rebind mechanism similar to the mecanism used in the \nstandard allocator class std::allocator. The rebind mecanism\nis described in Section&nbsp;<A HREF=\"../TDS_2/Chapter_main.html#2D_TDS_default\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> \nof Chapter&nbsp;<A HREF=\"../TDS_2/Chapter_main.html#Chapter_2D_Triangulation_Data_Structure\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\nFor now, we will just notice that the design\nrequires\nthe existence in the vertex and face base classes \nof a nested template class\n<I>Rebind_TDS</I> defining a type <I>Other</I> used by\nthe rebinding mecanism.\n<P>\n\nThe two following examples  aim to show how the user\ncan  put in use the flexibility offered by the\nbase classes parameters.\n<P>\n\n<B>Adding colors</B> \nThe first example corresponds to a case where the user wishes to add in \nthe vertices or faces of the triangulation  an additional information\nthat do not depend on types provided\nby the triangulation data structure. \nIn that case, predefined classes\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_with_info_2.html#Cross_link_anchor_957\">Triangulation_vertex_base_with_info_2</A>&lt;Info,Traits,Vb&gt;</I>\nor <I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_with_info_2.html#Cross_link_anchor_949\">Triangulation_face_base_with_info_2</A>&lt;Info,Traits,Vb&gt;</I>\ncan be used. Those classes have\na template parameter <I>Info</I> devoted to\nhandle additionnal information.\nThe following examples shows how to add a \n<I><A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A></I> in the triangulation faces.\n<P>\n\n<pre class=\"ExampleCode\">// file : examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/colored_face.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1754\">Color</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_with_info_2.html#Cross_link_anchor_949\">Triangulation_face_base_with_info_2</A>.h&gt;\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;K&gt; Vb;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_face_base_with_info_2.html#Cross_link_anchor_948\">CGAL::Triangulation_face_base_with_info_2</A>&lt;<A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A>,K&gt; Fb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_938\">CGAL::Triangulation_2</A>&lt;K,Tds&gt; Triangulation;\n\ntypedef Triangulation::Face_handle Face_handle;\ntypedef Triangulation::Finite_faces_iterator Finite_faces_iterator;\ntypedef Triangulation::Point  Point;\n\nint main() {\n  Triangulation t;\n  t.insert(Point(0,1));\n  t.insert(Point(0,0));\n  t.insert(Point(2,0));\n  t.insert(Point(2,2));\n \n  Finite_faces_iterator fc = t.finite_faces_begin();\n  for( ; fc != t.finite_faces_end(); ++fc)  fc-&gt;info() = CGAL::BLUE;\n\n  Point p(0.5,0.5);\n  Face_handle fh = t.locate(p);\n  fh-&gt;info() = CGAL::RED;\n\n  return 0;\n}\n</pre>\n<P>\n\n<B>Adding handles</B>\nThe second examples  shows how the user can  still\nderive and plug in his own vertex base \nor face base when he would like to have  \nadditionnal functionalities depending on types provided by the triangulation\ndata structure.\n<P>\n\n<pre class=\"ExampleCode\">// file : examples/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>/adding_handles.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>.h&gt;\n#include &lt;cassert&gt;\n\n/* A facet with an additionnal handle */\ntemplate &lt; class Gt, class Vb = <A HREF=\"../Triangulation_2_ref/Class_Triangulation_vertex_base_2.html#Cross_link_anchor_954\">CGAL::Triangulation_vertex_base_2</A>&lt;Gt&gt; &gt;\nclass My_vertex_base \n  : public  Vb\n{\n  typedef Vb                              Base;\npublic:\n  typedef typename Vb::Vertex_handle      Vertex_handle;\n  typedef typename Vb::Face_handle        Face_handle;\n  typedef typename Vb::Point              Point;\n\n  template &lt; typename TDS2 &gt;\n  struct Rebind_TDS {\n    typedef typename Vb::template Rebind_TDS&lt;TDS2&gt;::Other    Vb2;\n    typedef My_vertex_base&lt;Gt,Vb2&gt;                           Other;\n  };\n\nprivate:\n  Vertex_handle  va_;\n\npublic:\n  My_vertex_base() : Base() {}\n  My_vertex_base(const Point &amp; p) : Base(p) {}\n  My_vertex_base(const Point &amp; p, Face_handle f) : Base(f,p) {}\n  My_vertex_base(Face_handle f) : Base(f) {}\n\n  void set_associated_vertex(Vertex_handle va) { va_ = va;}\n  Vertex_handle get_associated_vertex() {return va_ ; }\n};\n\nstruct K : <A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_37\">CGAL::Exact_predicates_inexact_constructions_kernel</A> {};\n\ntypedef My_vertex_base&lt;K&gt; Vb;\ntypedef <A HREF=\"../TDS_2_ref/Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb&gt; Tds;\ntypedef <A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_938\">CGAL::Triangulation_2</A>&lt;K,Tds&gt; Triangulation;\n\ntypedef Triangulation::Vertex_handle Vertex_handle;\ntypedef Triangulation::Finite_faces_iterator Finite_faces_iterator;\ntypedef Triangulation::Point   Point;\n\nint main() {\n  Triangulation t;\n  Vertex_handle v0 = t.insert(Point(0,1));\n  Vertex_handle v1 = t.insert(Point(0,0));\n  Vertex_handle v2 = t.insert(Point(2,0));\n  Vertex_handle v3 = t.insert(Point(2,2));\n \n  // associate vertices as you like\n  v0-&gt;set_associated_vertex(v1);\n  v1-&gt;set_associated_vertex(v2);\n  v2-&gt;set_associated_vertex(v3);\n  v3-&gt;set_associated_vertex(v0); \n  assert( v0-&gt;get_associated_vertex() == v1); \n\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_12\"></a>\n        \n<h2>31.12&nbsp;&nbsp;&nbsp;Design and Implementation History</h2>\n<P>\n\nThe code of this package is the result of a long development\nprocess. Here follows a tentative list of people\nwho added their stone to this package&nbsp;:\nJean-Daniel Boissonnat, Herv&eacute; Br&ouml;nnimann, \nOlivier Devillers, Andreas Fabri, Fr&eacute;d&eacute;ric Fichel,\nJulia Fl&ouml;totto, Monique Teillaud and Mariette Yvinec.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Triangulation_2_ref/Chapter_intro.html\">2D Triangulations</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_31!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38219.0}