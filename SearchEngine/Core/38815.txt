{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Min circle 2 Traits Definition An object of the class Min circle 2 Traits is the unique circle of smallest area enclosing a finite multi set of points in two dimensional Euclidean space 2 For a point set P we denote by mc P the smallest circle that contains all points of P Note that mc P can be degenerate i e mc P if P and mc P p if P p An inclusion minimal subset S of P with mc S mc P is called a support set the points in S are the support points A support set has size at most three and all its points lie on the boundary of mc P In general neither the support set nor its size are necessarily unique The underlying algorithm can cope with all kinds of input e g P may be empty or points may occur more than once The algorithm computes a support set S which remains fixed until the next insert or clear operation Please note This class is almost obsolete The class CGAL Min sphere of spheres d Traits solves a more general problem and is faster then Min circle 2 Traits even if used only for points in two dimensions as input Most importantly CGAL Min sphere of spheres d Traits has a specialized implementation for floating point arithmetic which ensures correct results in a large number of cases including highly degenerate ones In contrast Min circle 2 Traits is not tuned for floating point computations The only advantage of Min circle 2 Traits over CGAL Min sphere of spheres d Traits is that the former can deal with points in homogeneous coordinates in which case the algorithm is division free Thus Min circle 2 Traits might still be an option in case your input number type cannot efficiently divide include CGAL Min circle 2 h Requirements The template parameter Traits is a model for MinCircle2Traits We provide the model CGAL Min circle 2 traits 2 using the two dimensional CGAL kernel Types Min circle 2 Traits Point typedef to Traits Point Min circle 2 Traits Circle typedef to Traits Circle Min circle 2 Traits Point iterator non mutable model of the STL concept BidirectionalIterator with value type Point Used to access the points of the smallest enclosing circle Min circle 2 Traits Support point iterator non mutable model of the STL concept RandomAccessIterator with value type Point Used to access the support points of the smallest enclosing circle Creation A Min circle 2 Traits object can be created from an arbitrary point set P and by specialized construction methods expecting no one two or three points as arguments The latter methods can be useful for reconstructing mc P from a given support set S of P template class InputIterator Min circle 2 Traits min circle InputIterator first InputIterator last bool randomize Random random CGAL default random Traits traits Traits initializes min circle to mc P with P being the set of points in the range first last If randomize is true a random permutation of P is computed in advance using the random numbers generator random Usually this will not be necessary however the algorithm s efficiency depends on the order in which the points are processed and a bad order might lead to extremely poor performance see example below Requirement The value type of first and last is Point Min circle 2 Traits min circle Traits traits Traits initializes min circle to mc the empty set Postcondition min circle is empty true Min circle 2 Traits min circle Point p Traits traits Traits initializes min circle to mc p the set p Postcondition min circle is degenerate true Min circle 2 Traits min circle Point p1 Point p2 Traits traits Traits initializes min circle to mc p1 p2 the circle with diameter equal to the segment connecting p1 and p2 Min circle 2 Traits min circle Point p1 Point p2 Point p3 Traits traits Traits initializes min circle to mc p1 p2 p3 Access Functions int min circle number of points returns the number of points of min circle i e P int min circle number of support points returns the number of support points of min circle i e S Point iterator min circle points begin returns an iterator referring to the first point of min circle Point iterator min circle points end returns the corresponding past the end iterator Support point iterator min circle support points begin returns an iterator referring to the first support point of min circle Support point iterator min circle support points end returns the corresponding past the end iterator Point min circle support point int i returns the i th support point of min circle Between two modifying operations see below any call to min circle support point i with the same i returns the same point Precondition i min circle number of support points Circle min circle circle returns the current circle of min circle Predicates By definition an empty Min circle 2 Traits has no boundary and no bounded side i e its unbounded side equals the whole space 2 CGAL Bounded side min circle bounded side Point p returns CGAL ON BOUNDED SIDE CGAL ON BOUNDARY or CGAL ON UNBOUNDED SIDE iff p lies properly inside on the boundary of or properly outside of min circle resp bool min circle has on bounded side Point p returns true iff p lies properly inside min circle bool min circle has on boundary Point p returns true iff p lies on the boundary of min circle bool min circle has on unbounded side Point p returns true iff p lies properly outside of min circle bool min circle is empty returns true iff min circle is empty this implies degeneracy bool min circle is degenerate returns true iff min circle is degenerate i e if min circle is empty or equal to a single point equivalently if the number of support points is less than 2 Modifiers New points can be added to an existing min circle allowing to build mc P incrementally e g if P is not known in advance Compared to the direct creation of mc P this is not much slower because the construction method is incremental itself void min circle insert Point p inserts p into min circle and recomputes the smallest enclosing circle template class InputIterator void min circle insert InputIterator first InputIterator last inserts the points in the range first last into min circle and recomputes the smallest enclosing circle by calling insert p for each point p in first last Requirement The value type of first and last is Point void min circle clear deletes all points in min circle and sets min circle to the empty set Postcondition min circle is empty true Validity Check An object min circle is valid iff min circle contains all points of its defining set P min circle is the smallest circle spanned by its support set S and S is minimal i e no support point is redundant bool min circle is valid bool verbose false int level returns true iff min circle is valid If verbose is true some messages concerning the performed checks are written to standard error stream The second parameter level is not used we provide it only for consistency with interfaces of other classes Miscellaneous const Traits min circle traits returns a const reference to the traits class object I O std ostream std ostream os min circle writes min circle to output stream os Requirement The output operator is defined for Point and for Circle if pretty printing is used std istream std istream is min circle reads min circle from input stream is Requirement The input operator is defined for Point include CGAL IO Window stream h CGAL Window stream CGAL Window stream ws min circle writes min circle to window stream ws Requirement The window stream output operator is defined for Point and Circle See Also CGAL Min ellipse 2 Traits CGAL Min sphere d Traits CGAL Min sphere of spheres d Traits CGAL Min circle 2 traits 2 K MinCircle2Traits Implementation We implement the incremental algorithm of Welzl with move to front heuristic Wel91 The whole implementation is described in GS98a If randomization is chosen the creation time is almost always linear in the number of points Access functions and predicates take constant time inserting a point might take up to linear time but substantially less than computing the new smallest enclosing circle from scratch The clear operation and the check for validity each takes linear time Example To illustrate the creation of Min circle 2 Traits and to show that randomization can be useful in certain cases we give an example file examples Min circle 2 example Min circle 2 C includes include CGAL Homogeneous h include CGAL Min circle 2 h include CGAL Min circle 2 traits 2 h include CGAL Gmpz h include iostream typedefs typedef CGAL Gmpz NT typedef CGAL Homogeneous NT K typedef CGAL Min circle 2 traits 2 K Traits typedef CGAL Min circle 2 Traits Min circle typedef K Point 2 Point main int main int char int n 1 Point P new Point n for int i i n i P i Point i 2 i i 1 2 3 Min circle mc1 P P n false very slow Min circle mc2 P P n true fast CGAL set pretty mode std cout std cout mc2 delete P return Next Min circle 2 traits 2 K Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Optimisation_ref/Class_Min_circle_2.html", "title": "min_circle_2&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Optimisation_ref/Min_circle_2.tex' -->\n<html> <head>  \n<title>Min_circle_2&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1138\"></A>\n\n<A NAME=\"Cross_link_anchor_1139\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1038\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Min_circle_2<Traits>\"></A>\n<h2><I>CGAL::Min_circle_2&lt;Traits&gt;</I></h2>\n<P>\n\n<A NAME=\"Index_anchor_1039\"></A> \n\n   \n\n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1040\"></A> \n\n   \n\n   \n\n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1041\"></A> \n\n   \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1042\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1043\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nAn object of the class <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> is the unique circle of smallest <A HREF=\"../Kernel_23_ref/Function_area.html#Cross_link_anchor_159\">area</A>\nenclosing a finite (multi)set of points in two-dimensional Euclidean\nspace&nbsp;<MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>2</SUB></I></MATH>.  For a point set <MATH><I>P</I></MATH> we denote by <MATH><I>mc(P)</I></MATH> the smallest circle\nthat contains all points of <MATH><I>P</I></MATH>. Note that <MATH><I>mc(P)</I></MATH> can be\ndegenerate,\ni.e.&nbsp;<MATH><I>mc(P)=</I></MATH>&Oslash;<MATH><I></I></MATH> if\n<MATH><I>P=</I></MATH>&Oslash;<MATH><I></I></MATH> and <MATH><I>mc(P)={p}</I></MATH> if\n<MATH><I>P={p}</I></MATH>.\n<P>\n\nAn inclusion-minimal subset <MATH><I>S</I></MATH> of <MATH><I>P</I></MATH> with <MATH><I>mc(S)=mc(P)</I></MATH> is called a\n<I>support set</I>,\nthe points in <MATH><I>S</I></MATH> are the <I>support points</I>.  A support set has size at\nmost three, and all its points lie on the boundary of <MATH><I>mc(P)</I></MATH>. In general,\nneither the support set nor its size are necessarily unique.\n<P>\n\nThe underlying algorithm can cope with all kinds of input, e.g.&nbsp;<MATH><I>P</I></MATH> may be\nempty or points may occur more than once. The algorithm computes a support\nset <MATH><I>S</I></MATH> which remains fixed until the next insert or clear operation.\n<P>\n\n<B>Please note:</B> This class is (almost) obsolete. The class\n<I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> solves a more general problem\nand is faster then <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> even if used only for points in two\ndimensions as input. Most importantly, \n<I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> has\na specialized implementation for floating-point arithmetic which\nensures correct results in a large number of cases (including\nhighly degenerate ones). In contrast, <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> is not tuned for\nfloating-point computations. The only advantage of \n<I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> over <I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I> is that the\nformer can deal with points in homogeneous coordinates, in which \ncase the algorithm is division-free. Thus, <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> might still\nbe an option in case your input number type cannot (efficiently) \ndivide.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Min_circle_2.h\">CGAL/Min_circle_2.h</A>&gt;</I>\n<P>\n\n<H3>Requirements</H3>   \n     \n     \n<A NAME=\"Index_anchor_1044\"></A>\n<P>\n\nThe template parameter <I>Traits</I> is a model for <I><A HREF=\"Concept_MinCircle2Traits.html#Cross_link_anchor_1142\">MinCircle2Traits</A></I>.\n<P>\n\nWe provide the model <I><A HREF=\"Class_Min_circle_2_traits_2.html#Cross_link_anchor_1140\">CGAL::Min_circle_2_traits_2</A></I> using the \ntwo-dimensional C<SMALL>GAL</SMALL>&nbsp;kernel.\n<P>\n\n<H3>Types</H3>   \n     \n     \n<A NAME=\"Index_anchor_1045\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;::Point\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::Point </I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;::Circle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    typedef to <I>Traits::Circle</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;::Point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL concept <I>BidirectionalIterator</I>\n        with value type <I>Point</I>. Used to access the points\n        of the smallest enclosing circle.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;::Support_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    non-mutable model of the STL concept <I>RandomAccessIterator</I>\n        with value type <I>Point</I>. Used to access the support points\n        of the smallest enclosing circle.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1046\"></A>\n<P>\n\nA <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> object can be created from an arbitrary point set <MATH><I>P</I></MATH> and by\nspecialized construction methods expecting no, one, two or three points as\narguments. The latter methods can be useful for reconstructing <MATH><I>mc(P)</I></MATH> from\na given support&nbsp;set\n<MATH><I>S</I></MATH> of <MATH><I>P</I></MATH>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt; min_circle ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\nbool randomize,<BR>\n\nRandom&amp; random = CGAL::default_random,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_circle</I> to <MATH><I>mc(P)</I></MATH> with <MATH><I>P</I></MATH> being the set of points\n        in the range [<I>first</I>,<I>last</I>). If <I>randomize</I> is\n        <I>true</I>, a random permutation of <MATH><I>P</I></MATH> is computed in\n        advance, using the random numbers generator <I>random</I>.\n        Usually, this will not be necessary, however, the algorithm's\n        efficiency depends on the order in which the points are\n        processed, and a bad order might lead to extremely poor\n        performance (see example below).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I>\n        is <I>Point</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt; min_circle (  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_circle</I> to\n        <MATH><I>mc(</I></MATH>&Oslash;<MATH><I>)</I></MATH>, the empty set.<BR>\n\n<EM>Postcondition: </EM><I>min_circle</I><I>.is_empty()</I> = <I>true</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt; min_circle (  Point p,  Traits traits = Traits());\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_circle</I> to <MATH><I>mc({p})</I></MATH>, the set <MATH><I>{p}</I></MATH>.<BR>\n\n<EM>Postcondition: </EM><I>min_circle</I><I>.is_degenerate()</I> = <I>true</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt; min_circle ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p1,<BR>\n\nPoint p2,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_circle</I> to <MATH><I>mc({p1,p2})</I></MATH>, the circle with diameter\n        equal to the segment connecting <MATH><I>p1</I></MATH> and <MATH><I>p2</I></MATH>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt; min_circle ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p1,<BR>\n\nPoint p2,<BR>\n\nPoint p3,<BR>\n\nTraits traits = Traits());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    initializes <I>min_circle</I> to <MATH><I>mc({p1,p2,p3})</I></MATH>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>   \n     \n     \n<A NAME=\"Index_anchor_1047\"></A> \n\n   \n\n\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1048\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1049\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.number_of_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of points of <I>min_circle</I>, i.e. <MATH><I>|P|</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_number_of_support_points6_9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.number_of_support_points ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of support points of <I>min_circle</I>, i.e. <MATH><I>|S|</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_begin69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.points_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first point of <I>min_circle</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_iterator_points_end69_const;\"></A>\nPoint_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.points_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_begin69_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.support_points_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns an iterator referring to the first support point of <I>min_circle</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Support_point_iterator_support_points_end69_const;\"></A>\nSupport_point_iterator\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.support_points_end ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the corresponding past-the-end iterator.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Point__support_point6_int_i9_const;\"></A>\n Point\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.support_point ( int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the <I>i</I>-th support point of <I>min_circle</I>. Between two\n        modifying operations (see below) any call to\n        <I>min_circle</I><I>.support_point(i)</I> with the same <I>i</I> returns\n        the same point.<BR>\n\n<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i&lt; </I></MATH><I>min_circle</I><I>.number_of_support_points()</I><MATH><I></I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Circle__circle6_9_const;\"></A>\n Circle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.circle ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the current circle of <I>min_circle</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Predicates</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1050\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1051\"></A>\n<P>\n\nBy definition, an empty <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> has no boundary and no\nbounded side, i.e. its unbounded side equals the whole space <MATH><I> <IMG BORDER=0 WIDTH=12 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_E.gif\"> <SUB>2</SUB></I></MATH>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_CGAL::Bounded_side_bounded_side6_const_Point__p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_98\">CGAL::Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.bounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>CGAL::</I><I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I>,\n        <I>CGAL::</I><I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I>, or\n        <I>CGAL::</I><I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> iff <I>p</I> lies properly\n        inside, on the boundary of, or properly outside of <I>min_circle</I>, resp.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_bounded_side6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.has_on_bounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies properly inside <I>min_circle</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_boundary6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.has_on_boundary (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies on the boundary\n        of <I>min_circle</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_on_unbounded_side6_const_Point__p9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.has_on_unbounded_side (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>p</I> lies properly outside of <I>min_circle</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_empty6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.is_empty ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_circle</I> is empty (this implies\n        degeneracy).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_degenerate6_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.is_degenerate ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_circle</I> is degenerate,\n        i.e.&nbsp;if <I>min_circle</I> is empty or equal to a single point, equivalently\n        if the number of support points is less than 2.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>   \n     \n     \n     \n<A NAME=\"Index_anchor_1052\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1053\"></A>\n<P>\n\nNew points can be added to an existing <I>min_circle</I>, allowing to build <MATH><I>mc(P)</I></MATH>\nincrementally, e.g.&nbsp;if <MATH><I>P</I></MATH> is not known in advance. Compared to the direct\ncreation of <MATH><I>mc(P)</I></MATH>, this is not much slower, because the construction\nmethod is incremental itself.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_const_Point__p9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.insert (  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts <I>p</I> into <I>min_circle</I> and recomputes the smallest\n        enclosing circle.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_insert6_InputIterator_first+_InputIterator_last_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_circle.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inserts the points in the range [<I>first</I>,<I>last</I>)\n        into <I>min_circle</I> and recomputes the smallest enclosing circle by\n        calling <I>insert(p)</I> for each point <I>p</I> in\n        [<I>first</I>,<I>last</I>).<BR>\n\n<EM>Requirement: </EM>The value type of <I>first</I> and <I>last</I> is\n        <I>Point</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear6_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.clear ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    deletes all points in <I>min_circle</I> and sets <I>min_circle</I> to the empty set.<BR>\n\n<EM>Postcondition: </EM><I>min_circle</I><I>.is_empty()</I> = <I>true</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Validity Check</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1054\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1055\"></A>\n<P>\n\nAn object <I>min_circle</I> is valid, iff\n<UL>\n  <LI><I>min_circle</I> contains all points of its defining set <MATH><I>P</I></MATH>,\n  <LI><I>min_circle</I> is the smallest circle spanned by its support set <MATH><I>S</I></MATH>, and\n  <LI><MATH><I>S</I></MATH> is minimal, i.e. no support point is redundant.\n</UL>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6_bool_verbose_=_false+_int_level_=_0_9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    min_circle.is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    bool verbose = false,<BR>\n\nint level = 0)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <I>true</I>, iff <I>min_circle</I> is valid. If <I>verbose</I>\n      is <I>true</I>, some messages concerning the performed checks\n      are written to standard error stream. The second parameter\n      <I>level</I> is not used, we provide it only for consistency\n      with interfaces of other classes.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Miscellaneous</H3>\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1056\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1057\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_const_Traits__traits6_9_const;\"></A>\nconst Traits&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    min_circle.traits ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a const reference to the traits class object.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>I/O</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1058\"></A>\n<P>\n\n<A NAME=\"Index_anchor_1059\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1060\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::ostream&amp; os &lt;&lt;  min_circle<A NAME=\"Function_std::ostream__operator_66_6_std::ostream__os+_const_Min_circle_26Traits9__min_circle9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>min_circle</I> to output stream <I>os</I>.<BR>\n\n<EM>Requirement: </EM>The output operator is defined for <I>Point</I>\n        (and for <I>Circle</I>, if pretty printing is used).\n        </TD></TR>\n        </TABLE>\n<P>\n\n<A NAME=\"Index_anchor_1061\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1062\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    std::istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     std::istream&amp; is &gt;&gt;  min_circle&amp;<A NAME=\"Function_std::istream__operator_99_6_std::istream__is+_Min_circle_26Traits9_min_circle_9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads <I>min_circle</I> from input stream <I>is</I>.<BR>\n\n<EM>Requirement: </EM>The input operator is defined for <I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Window_stream.h\">CGAL/IO/Window_stream.h</A>&gt;</I>\n<P>\n\n<A NAME=\"Index_anchor_1063\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1064\"></A> \n\n   \n  \n      \n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1757\">CGAL::Window_stream</A>&amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     <A HREF=\"../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1757\">CGAL::Window_stream</A>&amp; ws &lt;&lt;  min_circle<A NAME=\"Function_CGAL::Window_stream__operator_66_6_CGAL::Window_stream__ws+_const_Min_circle_26Traits9__min_circle9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>min_circle</I> to window stream <I>ws</I>.<BR>\n\n<EM>Requirement: </EM>The window stream output operator is defined for\n        <I>Point</I> and <I>Circle</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Min_ellipse_2.html#Cross_link_anchor_1143\">CGAL::Min_ellipse_2</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_sphere_d.html#Cross_link_anchor_1162\">CGAL::Min_sphere_d</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_sphere_of_spheres_d.html#Cross_link_anchor_1166\">CGAL::Min_sphere_of_spheres_d</A>&lt;Traits&gt;</I><BR>\n\n<I><A HREF=\"Class_Min_circle_2_traits_2.html#Cross_link_anchor_1140\">CGAL::Min_circle_2_traits_2</A>&lt;K&gt;</I><BR>\n\n<I><A HREF=\"Concept_MinCircle2Traits.html#Cross_link_anchor_1142\">MinCircle2Traits</A></I>\n<P>\n\n<H3>Implementation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1065\"></A>\n<P>\n\nWe implement the incremental algorithm of Welzl, with move-to-front\nheuristic&nbsp;[<A HREF=\"../biblio.html#Biblio_w-sedbe-91a\">Wel91</A>]. The whole implementation is described\nin&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:gs-seceg-98\">GS98a</A>].\n<P>\n\nIf randomization is\nchosen, the creation time is almost always linear in the number of points.\nAccess functions and predicates take constant time, inserting a point might\ntake up to linear time, but substantially less than computing the new\nsmallest enclosing circle from scratch. The clear operation and the check\nfor validity each takes linear time.\n<P>\n\n<H3>Example</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1066\"></A>\n<P>\n\nTo illustrate the creation of <I><A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>&lt;Traits&gt;</I> and to show that\nrandomization can be useful in certain cases, we give an example.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>/example_Min_circle_2.C\n\n// includes\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1139\">Min_circle_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Min_circle_2_traits_2.html#Cross_link_anchor_1141\">Min_circle_2_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A>.h&gt;\n#include &lt;iostream&gt;\n\n// typedefs\ntypedef  <A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363\">CGAL::Gmpz</A>                      NT;\ntypedef  <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;NT&gt;           K;\ntypedef  <A HREF=\"Class_Min_circle_2_traits_2.html#Cross_link_anchor_1140\">CGAL::Min_circle_2_traits_2</A>&lt;K&gt;  Traits;\ntypedef  <A HREF=\"Class_Min_circle_2.html#Cross_link_anchor_1138\">CGAL::Min_circle_2</A>&lt;Traits&gt;      Min_circle;\n\ntypedef  K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>                      Point;\n\n// main\nint\nmain( int, char**)\n{\n    int     n = 100;\n    Point*  P = new Point[ n];\n\n    for ( int i = 0; i &lt; n; ++i)\n        P[ i] = Point( (i%2 == 0 ? i : -i), 0);\n    // (0,0), (-1,0), (2,0), (-3,0), ...\n\n    Min_circle  mc1( P, P+n, false);    // very slow\n    Min_circle  mc2( P, P+n, true);     // fast\n\n    <A HREF=\"../IOstream_ref/Function_set_pretty_mode.html#Cross_link_anchor_1749\">CGAL::set_pretty_mode</A>( std::cout);\n    std::cout &lt;&lt; mc2;\n\n    delete[] P;\n\n    return( 0);\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Min_circle_2_traits_2.html\"><I>Min_circle_2_traits_2&lt;K&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_52!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38815.0}