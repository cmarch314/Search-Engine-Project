{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 61Spatial Searching Hans Tangelder and Andreas Fabri 61 1 Introduction The spatial searching package implements exact and approximate distance browsing by providing implementations of algorithms supporting both nearest and furthest neighbor searching both exact and approximate searching approximate range searching approximate k nearest and k furthest neighbor searching approximate incremental nearest and incremental furthest neighbor searching query items representing points and spatial objects In these searching problems a set P of data points in d dimensional space is given The points can be represented by Cartesian coordinates or homogeneous coordinates These points are preprocessed into a tree data structure so that given any query item q the points of P can be browsed efficiently The approximate spatial searching package is designed for data sets that are small enough to store the search structure in main memory in contrast to approaches from databases that assume that the data reside in secondary storage 61 1 1 Neighbor Searching Spatial searching supports browsing through a collection of d dimensional spatial objects stored in a spatial data structure on the basis of their distances to a query object The query object may be a point or an arbitrary spatial object e g a d dimensional sphere The objects in the spatial data structure are d dimensional points Often the number of the neighbors to be computed is not know beforehand e g because the number may depend on some properties of the neighbors for example when querying for the nearest city to Paris with population greater than a million or the distance to the query point The convential approach is k nearest neighbor searching that makes use of a k nearest neighbor algorithm where k is known prior to the invocation of the algorithm Hence the number of nearest neighbors has to be guessed If the guess is too large redundant computations are performed If the number is too small the computation has to be reinvoked for a larger number of neighbors thereby performing redundant computations Therefore Hjaltason and Samet HS95 introduced incremental nearest neighbor searching in the sense that having obtained the k nearest neighbors the k 1st neighbor can be obtained without having to calculate the k 1 nearest neighbor from scratch Spatial searching typically consists of a preprocessing phase and a searching phase In the preprocessing phase one builds a search structure and in the searching phase one makes the queries In the preprocessing phase the user builds a tree data structure storing the spatial data In the searching phase the user invokes a searching method to browse the spatial data With relatively minor modifications nearest neighbor searching algorithms can be used to find the furthest object from the query object Therefore furthest neighbor searching is also supported by the spatial searching package The execution time for exact neighbor searching can be reduced by relaxing the requirement that the neighbors should be computed exactly If the distances of two objects to the query object are approximately the same instead of computing the nearest furthest neighbor exactly one of these objects may be returned as the approximate nearest furthest neighbor I e given some non negative constant the distance of an object returned as an approximate k nearest neighbor must not be larger than 1 r where r denotes the distance to the real kth nearest neighbor Similar the distance of an approximate k furthest neighbor must not be smaller than r 1 Obviously for we get the exact result and the larger is the less exact the result Neighbor searching is implemented by the following four classes The class CGAL Orthogonal k neighbor search Traits OrthogonalDistance Splitter SpatialTree implements the standard search strategy for orthogonal distances like the weighted Minkowski distance It requires the use of extended nodes in the spatial tree and supports only k neighbor searching for point queries The class CGAL K neighbor search Traits GeneralDistance Splitter SpatialTree implements the standard search strategy for general distances like the Manhattan distance for iso rectangles It does not require the use of extended nodes in the spatia tree and supports only k neighbor searching for queries defined by points or spatial objects The class Orthogonal incremental neighbor search Traits GeneralDistance Splitter SpatialTree implements the incrementral search strategy for general distances like the weighted Minkowski distance It requires the use of extended nodes in the spatial tree and supports incremental neighbor searching and distance browsing for point queries The class CGAL Incremental neighbor search Traits GeneralDistance Splitter SpatialTree implements the incremental search strategy for general distances like the Manhattan distance for iso rectangles It does not requires the use of extended nodes in the spatial tree and supports incremental neighbor searching and distance browsing for queries defined by points or spatial objects 61 1 2 Range Searching Exact range searching and approximate range searching is supported using exact or fuzzy d dimensional objects enclosing a region The fuzziness of the query object is specified by a parameter denoting a maximal allowed distance to the boundary of a query object If the distance to the the boundary is at least points inside the object are always reported and points outside the object are never reported Points within distance to the boundary may be or may be not reported For exact range searching the fuzziness parameter is set to zero The class Kd tree implements range searching in the method search which is a template method with an output iterator and a model of the concept FuzzyQueryItem as CGAL Fuzzy iso box d or CGAL Fuzzy sphere d For range searching of large data sets the user may set the parameter bucket size used in building the k d tree to a large value e g 1 because in general the query time will be less then using the default value 61 2 Splitting Rules Instead of using the default splitting rule Sliding midpoint described below a user may depending upon the data select one from the following splitting rules which determine how a separating hyperplane is computed Midpoint of rectangle This splitting rule cuts a rectangle through its midpoint orthogonal to the longest side Midpoint of max spread This splitting rule cuts a rectangle through Mind Maxd 2 orthogonal to the dimension with the maximum point spread Mind Maxd Sliding midpoint This is a modification of the midpoint of rectangle splitting rule It first attempts to perform a midpoint of rectangle split as described above If data points lie on both sides of the separating plane the sliding midpoint rule computes the same separator as the midpoint of rectangle rule If the data points lie only on one side it avoids this by sliding the separator computed by the midpoint of rectangle rule to the nearest datapoint Median of rectangle The splitting dimension is the dimension of the longest side of the rectangle The splitting value is defined by the median of the coordinates of the data points along this dimension Median of max spread The splitting dimension is the dimension of the longest side of the rectangle The splitting value is defined by the median of the coordinates of the data points along this dimension Fair This splitting rule is a compromise between the median of rectangle splitting rule and the midpoint of rectangle splitting rule This splitting rule maintains an upper bound on the maximal allowed ratio of the longest and shortest side of a rectangle the value of this upper bound is set in the constructor of the fair splitting rule Among the splits that satisfy this bound it selects the one in which the points have the largest spread It then splits the points in the most even manner possible subject to maintaining the bound on the ratio of the resulting rectangles Sliding fair This splitting rule is a compromise between the fair splitting rule and the sliding midpoint rule Sliding fair split is based on the theory that there are two types of splits that are good balanced splits that produce fat rectangles and unbalanced splits provided the rectangle with fewer points is fat Also this splitting rule maintains an upper bound on the maximal allowed ratio of the longest and shortest side of a rectangle the value of this upper bound is set in the constructor of the fair splitting rule Among the splits that satisfy this bound it selects the one one in which the points have the largest spread It then considers the most extreme cuts that would be allowed by the aspect ratio bound This is done by dividing the longest side of the rectangle by the aspect ratio bound If the median cut lies between these extreme cuts then we use the median cut If not then consider the extreme cut that is closer to the median If all the points lie to one side of this cut then we slide the cut until it hits the first point This may violate the aspect ratio bound but will never generate empty cells 61 3 Example Programs We give six examples The first example illustrates k nearest neighbor searching and the second example incremental neighbor searching The third is an example of approximate furthest neighbor searching using a d dimensional iso rectangle as an query object Approximate range searching is illustrated by the fourth example The fifth example illustrates k neighbour searching for a user defined point class The last example shows how to choose another splitting rule in the k d tree that is used as search tree 61 3 1 Example of K Neighbor Searching The first example illustrates k neighbor searching with an Euclidean distance and 2 dimensional points The generated random data points are inserted in a search tree We then initialize the k neighbor search object with the origin as query Finally we obtain the result of the computation in the form of an iterator range The value of the iterator is a pair of a point and its square distance to the query point We use square distances or transformed distances for other distance classes as they are computationally cheaper file examples Spatial searching Nearest neighbor searching C include CGAL Simple cartesian h include CGAL point generators 2 h include CGAL Orthogonal k neighbor search h include CGAL Search traits 2 h include list typedef CGAL Simple cartesian double K typedef K Point 2 Point d typedef CGAL Search traits 2 K TreeTraits typedef CGAL Orthogonal k neighbor search TreeTraits Neighbor search typedef Neighbor search Tree Tree int main const int N 1 std list Point d points points push back Point d Tree tree points begin points end Point d query Initialize the search structure and search all N points Neighbor search search tree query N report the N nearest neighbors and their distance This should sort all N points by increasing distance from origin for Neighbor search iterator it search begin it search end it std cout it first sqrt it second std endl return 61 3 2 Example of Incremental Searching This example program illustrates incremental searching for the closest point with a positive first coordinate We can use the orthogonal incremental neighbor search class as the query is also a point and as the distance is the Euclidean distance As for the k neighbor search we first initialize the search tree with the data We then create the search object and finally obtain the iterator with the begin method Note that the iterator is of the input iterator category that is one can make only one pass over the data file examples Spatial searching Distance browsing C include CGAL Simple cartesian h include CGAL Orthogonal incremental neighbor search h include CGAL Search traits 2 h typedef CGAL Simple cartesian double K typedef K Point 2 Point d typedef CGAL Search traits 2 K TreeTraits typedef CGAL Orthogonal incremental neighbor search TreeTraits NN incremental search typedef NN incremental search iterator NN iterator typedef NN incremental search Tree Tree A functor that returns true iff the x coordinate of a dD point is not positive struct X not positive bool operator const NN iterator it return it first An iterator that only enumerates dD points with positive x coordinate typedef CGAL Filter iterator NN iterator X not positive NN positive x iterator int main Tree tree tree insert Point d tree insert Point d 1 1 tree insert Point d 1 tree insert Point d 1 11 tree insert Point d 45 tree insert Point d 234 tree insert Point d 3 Point d query NN incremental search NN tree query NN positive x iterator it NN end X not positive NN begin end NN end X not positive std cout The first 5 nearest neighbours with positive x coord are std endl for int j j 5 it end j it std cout it first at squared distance it second std endl return 61 3 3 Example of General Neighbor Searching This example program illustrates approximate nearest and furthest neighbor searching using 4 dimensional Cartesian coordinates Five approximate nearest neighbors of the query rectangle 1 2 4 are computed Because the query object is a rectangle we cannot use the Orthogonal neighbor search As in the previous examples we first initialize a search tree create the search object with the query and obtain the result of the search as iterator range file examples Spatial searching General neighbor searching C include CGAL Cartesian d h include CGAL point generators 2 h include CGAL Manhattan distance iso box point h include CGAL K neighbor search h include CGAL Search traits 2 h typedef CGAL Cartesian d double K typedef K Point d Point d typedef CGAL Random points in square 2 Point d Random points iterator typedef K Iso box d Iso box d typedef K TreeTraits typedef CGAL Manhattan distance iso box point TreeTraits Distance typedef CGAL K neighbor search TreeTraits Distance Neighbor search typedef Neighbor search Tree Tree int main const int N 1 const int K 1 Tree tree Random points iterator rpg for int i i N i tree insert rpg Point d pp 1 1 Point d qq 2 2 Iso box d query pp qq Distance tr dist Neighbor search N1 tree query K false eps 1 nearest false std cout For query rectange 1 2 2 std endl The K approximate furthest neighbors are std endl for Neighbor search iterator it N1 begin it N1 end it std cout Point it first at distance tr dist inverse of transformed distance it second std endl return 61 3 4 Example of a Range Query This example program illustrates approximate range querying for 4 dimensional fuzzy iso rectangles and spheres using homogeneous coordinates The range queries are member functions of the k d tree class file examples Spatial searching Fuzzy range query C include CGAL Cartesian d h include CGAL point generators d h include CGAL Kd tree h include CGAL Fuzzy sphere h include CGAL Fuzzy iso box h include CGAL Search traits d h typedef CGAL Cartesian d double K typedef K Point d Point d typedef CGAL Search traits d K Traits typedef CGAL Random points in iso box d Point d Random points iterator typedef CGAL Counting iterator Random points iterator N Random points iterator typedef CGAL Kd tree Traits Tree typedef CGAL Fuzzy sphere Traits Fuzzy sphere typedef CGAL Fuzzy iso box Traits Fuzzy iso box int main const int D 4 const int N 1 generator for random data points in the square 1 1 1 1 Random points iterator rpit 4 1 Insert N points in the tree Tree tree N Random points iterator rpit N Random points iterator N define range query objects double pcoord D 3 3 3 3 double qcoord D 9 9 9 9 Point d p D pcoord pcoord D Point d q D qcoord qcoord D Fuzzy sphere fs p 7 1 Fuzzy iso box fib p q 1 std cout points approximately in fuzzy range query std endl std cout with center 3 3 3 3 std endl std cout and fuzzy radius 2 4 are std endl tree search std ostream iterator Point d std cout n fs std cout points approximately in fuzzy range query std cout 2 4 8 1 4 are std endl tree search std ostream iterator Point d std cout n fib return 61 3 5 Example Illustrating Use of User Defined Point and Distance Class The neighbor searching works with all CGAL kernels as well as with user defined points and distance classes In this example we assume that the user provides the following 3 dimensional points class struct Point double vec 3 Point vec vec 1 vec 2 Point double x double y double z vec x vec 1 y vec 2 z double x const return vec double y const return vec 1 double z const return vec 2 double x return vec double y return vec 1 double z return vec 2 bool operator const Point p const return x p x y p y z p z bool operator const Point p const return this p end of class namespace CGAL template struct Kernel traits Point struct Kernel typedef double FT typedef double RT struct Construct coord iterator const double operator const Point p const return static cast const double p vec const double operator const Point p int const return static cast const double p vec 3 We have put the glue layer in this file as well that is a class that allows to iterate over the Cartesian coordinates of the point and a class to construct such an iterator for a point We next need a distance class struct Distance typedef Point Query item double transformed distance const Point p1 const Point p2 const double distx p1 x p2 x double disty p1 y p2 y double distz p1 z p2 z return distx distx disty disty distz distz template class TreeTraits double min distance to rectangle const Point p const CGAL Kd tree rectangle TreeTraits b const double distance h p x if h b min coord distance b min coord h b min coord h if h b max coord distance h b max coord h b max coord h p y if h b min coord 1 distance b min coord 1 h b min coord 1 h if h b max coord 1 distance h b max coord 1 h b min coord 1 h p z if h b min coord 2 distance b min coord 2 h b min coord 2 h if h b max coord 2 distance h b max coord 2 h b max coord 2 return distance template class TreeTraits double max distance to rectangle const Point p const CGAL Kd tree rectangle TreeTraits b const double h p x double d h b min coord b max coord 2 h b min coord h b min coord b max coord h b max coord h h p y double d1 h b min coord 1 b max coord 1 2 h b min coord 1 h b min coord 1 b max coord 1 h b max coord 1 h h p z double d2 h b min coord 2 b max coord 2 2 h b min coord 2 h b min coord 2 b max coord 2 h b max coord 2 h return d d1 d2 double new distance double dist double old off double new off int cutting dimension const return dist new off new off old off old off double transformed distance double d const return d d double inverse of transformed distance double d return sqrt d end of struct Distance We are ready to put the pices together The class Search traits which you see in the next file is then a mere wrapper for all these types The searching itself works exactly as for CGAL kernels file examples Spatial searching User defined point and distance C include CGAL basic h include CGAL Search traits h include CGAL point generators 3 h include CGAL Orthogonal k neighbor search h include Point h defines types Point Construct coord iterator include Distance h typedef CGAL Random points in cube 3 Point Random points iterator typedef CGAL Counting iterator Random points iterator N Random points iterator typedef CGAL Search traits double Point const double Construct coord iterator Traits typedef CGAL Orthogonal k neighbor search Traits Distance K neighbor search typedef K neighbor search Tree Tree int main const int N 1 const int K 5 generator for random data points in the cube 1 1 1 1 1 1 Random points iterator rpit 1 Insert number of data points in the tree Tree tree N Random points iterator rpit N Random points iterator N Point query Distance tr dist search K nearest neighbours K neighbor search search tree query K for K neighbor search iterator it search begin it search end it std cout d q nearest neighbor tr dist inverse of transformed distance it second std endl search K furthest neighbour searching with eps search nearest false K neighbor search search2 tree query K false for K neighbor search iterator it search2 begin it search2 end it std cout d q furthest neighbor tr dist inverse of transformed distance it second std endl return 61 3 6 Example of Selecting a Splitting Rule and Setting the Bucket Size This example program illustrates selecting a splitting rule and setting the maximal allowed bucket size The only differences with the first example are the declaration of the Fair splitting rule needed to set the maximal allowed bucket size file examples Spatial searching Using fair splitting rule C include CGAL Simple cartesian h include CGAL point generators 2 h include CGAL Search traits 2 h include CGAL Orthogonal k neighbor search h typedef CGAL Simple cartesian double R typedef R Point 2 Point d typedef CGAL Random points in square 2 Point d Random points iterator typedef CGAL Counting iterator Random points iterator N Random points iterator typedef CGAL Search traits 2 R Traits typedef CGAL Euclidean distance Traits Distance typedef CGAL Fair Traits Fair typedef CGAL Orthogonal k neighbor search Traits Distance Fair Neighbor search typedef Neighbor search Tree Tree int main const int N 1 generator for random data points in the square 1 1 1 1 Random points iterator rpit 1 Fair fair 5 bucket size 5 Insert number of data points in the tree Tree tree N Random points iterator rpit N Random points iterator N fair Point d query Initialize the search structure and search all N points Neighbor search search tree query N report the N nearest neighbors and their distance This should sort all N points by increasing distance from origin for Neighbor search iterator it search begin it search end it std cout it first sqrt it second std endl return 61 4 Software Design 61 4 1 The k d tree Bentley Ben75 introduced the k d tree as a generalization of the binary search tree in higher dimensions k d trees hierarchically decompose space into a relatively small number of rectangles such that no rectangle contains too many input objects For our purposes a rectangle in real d dimensional space d is the product of d closed intervals on the coordinate axes k d trees are obtained by partitioning point sets in d using d 1 dimensional hyperplanes Each node in the tree is split into two children by one such separating hyperplane Several splitting rules see Section can be used to compute a seperating d 1 dimensional hyperplane Each internal node of the k d tree is associated with a rectangle and a hyperplane orthogonal to one of the coordinate axis which splits the rectangle into two parts Therefore such a hyperplane defined by a splitting dimension and a splitting value is called a separator These two parts are then associated with the two child nodes in the tree The process of partitioning space continues until the number of data points in the rectangle falls below some given threshold The rectangles associated with the leaf nodes are called buckets and they define a subdivision of the space into rectangles Data points are only stored in the leaf nodes of the tree not in the internal nodes Friedmann Bentley and Finkel FBF77 described the standard search algorithm to find the kth nearest neighbor by searching a k d tree recursively When encountering a node of the tree the algorithm first visits the child that is closest to the query point On return if the rectangle containing the other child lies within 1 1 times the distance to the kth nearest neighbors so far then the other child is visited recursively Priority search AM93b visits the nodes in increasing order of distance from the queue with help of a priority queue The search stops when the distance of the query point to the nearest nodes exceeds the distance to the nearest point found with a factor 1 1 Priority search supports next neighbor search standard search does not In order to speed up the internal distance computations in nearest neighbor searching in high dimensional space the approximate searching package supports orthogonal distance computation Orthogonal distance computation implements the efficient incremental distance computation technique introduced by Arya and Mount AM93a This technique works only for neighbor queries with query items represented as points and with a quadratic form distance defined by dA x y x y A x y T where the matrix A is positive definite i e dA x y An important class of quadratic form distances are weighted Minkowski distances Given a parameter p and parameters wi i d the weighted Minkowski distance is defined by lp w r q i 1i d wi ri qi p 1 p for p and defined by l w r q max wi ri qi 1 i d The Manhattan distance p 1 wi 1 and the Euclidean distance p 2 wi 1 are examples of a weighted Minkowski metric To speed up distance computations also transformed distances are used instead of the distance itself For instance for the Euclidean distance to avoid the expensive computation of square roots squared distances are used instead of the Euclidean distance itself Next chapter Spatial Searching Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Spatial_searching/Chapter_main.html", "title": "spatial searching", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Spatial_searching/main.tex' -->\n<html> <head>  \n<title>Spatial Searching</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_61\"></a>\n  \n<h1>Chapter 61<BR>Spatial Searching</h1>\n\n<A NAME=\"ChapterUserSpatialSearching\"></A>\n\r\n<EM>Hans Tangelder  and Andreas Fabri</EM><BR>\n\n<a name=\"Section_1\"></a>\n        \n<h2>61.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n\r\n\r\nThe spatial searching package implements exact and approximate\r\ndistance browsing by providing implementations of algorithms\r\nsupporting\r\n\r\n<UL> \r\n\r\n<LI>both nearest and furthest neighbor searching\r\n\r\n<LI>both exact and approximate searching\r\n\r\n<LI>(approximate) range searching\r\n\r\n<LI>(approximate) <MATH><I>k</I></MATH>-nearest and <MATH><I>k</I></MATH>-furthest neighbor searching\r\n\r\n<LI>(approximate) incremental nearest and incremental furthest neighbor searching\r\n\r\n<LI>query items representing points and spatial objects.\r\n\r\n</UL>\r\n\r\nIn these searching problems a set <MATH><I>P</I></MATH> of data points in\r\n<MATH><I>d</I></MATH>-dimensional space is given.  The points can be represented by\r\n<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> coordinates or homogeneous coordinates.  These points are\r\npreprocessed into a tree data structure, so that given any\r\nquery item <MATH><I>q</I></MATH> the points of <MATH><I>P</I></MATH> can be browsed efficiently.  The\r\napproximate spatial searching package is designed for data sets that\r\nare small enough to store the search structure in main memory (in\r\ncontrast to approaches from databases that assume that the data reside\r\nin secondary storage).\r\n\r\n\n<h3>61.1.1&nbsp;&nbsp;&nbsp;Neighbor Searching</h3>\n\r\n\r\nSpatial searching supports browsing through a collection of\r\n<MATH><I>d</I></MATH>-dimensional spatial objects stored in a spatial data structure on\r\nthe basis of their distances to a query object. The query object may\r\nbe a point or an arbitrary spatial object, e.g, a <MATH><I>d</I></MATH>-dimensional\r\nsphere. The objects in the spatial data structure are <MATH><I>d</I></MATH>-dimensional\r\npoints.\r\n\r\nOften the number of the neighbors to be computed is not know\r\nbeforehand, e.g., because the number may depend on some properties of\r\nthe neighbors (for example when querying for the nearest city to Paris with\r\npopulation greater than a million) or the distance to the query point.\r\nThe convential approach is <MATH><I>k</I></MATH>-<I>nearest neighbor searching</I> that\r\nmakes use of a <MATH><I>k</I></MATH>-nearest neighbor algorithm, where <MATH><I>k</I></MATH> is known\r\nprior to the invocation of the algorithm.  Hence, the number of\r\nnearest neighbors has to be guessed. If the guess is too large\r\nredundant computations are performed.  If the number is too small the\r\ncomputation has to be reinvoked for a larger number of neighbors,\r\nthereby performing redundant computations.  Therefore, Hjaltason and\r\nSamet [<A HREF=\"../biblio.html#Biblio_hs-rsd-95\">HS95</A>] introduced <I>incremental nearest neighbor\r\nsearching</I> in the sense that having obtained the <MATH><I>k</I></MATH> nearest\r\nneighbors, the <MATH><I>k</I></MATH> + 1<MATH><I><SUP>st</SUP></I></MATH> neighbor can be obtained without having\r\nto calculate the <MATH><I>k</I></MATH> + 1 nearest neighbor from scratch.\r\n \r\n\r\nSpatial searching typically consists of a preprocessing phase and a\r\nsearching phase.  In the preprocessing phase one builds a search\r\nstructure and in the searching phase one makes the queries.  In the\r\npreprocessing phase the user builds a tree data structure\r\nstoring the spatial data.  In the searching phase the user invokes a\r\nsearching method to browse the spatial data.\r\n\r\nWith relatively minor modifications, nearest neighbor searching\r\nalgorithms can be used to find the furthest object from the query\r\nobject.  Therefore, <I>furthest neighbor searching</I> is also\r\nsupported by the spatial searching package.\r\n\r\nThe execution time for exact neighbor searching can be reduced by\r\nrelaxing the requirement that the neighbors should be computed\r\nexactly.  If the distances of two objects to the query object are\r\napproximately the same, instead of computing the nearest/furthest\r\nneighbor exactly, one of these objects may be returned as the\r\napproximate nearest/furthest neighbor. I.e., given some non-negative\r\nconstant <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH> the distance of an object returned as an\r\napproximate <MATH><I>k</I></MATH>-nearest neighbor must not be larger than\r\n<MATH><I>(1+<IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\">)r</I></MATH>, where <MATH><I>r</I></MATH> denotes the distance to the real <MATH><I>k<SUP>th</SUP></I></MATH>\r\nnearest neighbor.  Similar the distance of an approximate <MATH><I>k</I></MATH>-furthest\r\nneighbor must not be smaller than <MATH><I>r/(1+<IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\">)</I></MATH>.  Obviously, for\r\n<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\">=0</I></MATH> we get the exact result, and the larger <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH> is,\r\nthe less exact the result.\r\n\r\nNeighbor searching is implemented by the following four classes.\r\n\r\nThe class <I><A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1312\">CGAL::Orthogonal_k_neighbor_search</A>&lt;Traits,\r <A HREF=\"../Spatial_searching_ref/Concept_OrthogonalDistance.html#Cross_link_anchor_1309\">OrthogonalDistance</A>, <A HREF=\"../Spatial_searching_ref/Concept_Splitter.html#Cross_link_anchor_1331\">Splitter</A>, <A HREF=\"../Spatial_searching_ref/Concept_SpatialTree.html#Cross_link_anchor_1330\">SpatialTree</A>&gt;</I> implements the standard\r\nsearch strategy for orthogonal distances like the weighted Minkowski\r\ndistance. It requires the use of extended nodes in the spatial tree\r\nand supports only <MATH><I>k</I></MATH> neighbor searching for point queries.\r\n\r\nThe class <I><A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1291\">CGAL::K_neighbor_search</A>&lt;Traits, <A HREF=\"../Spatial_searching_ref/Concept_GeneralDistance.html#Cross_link_anchor_1288\">GeneralDistance</A>,\r <A HREF=\"../Spatial_searching_ref/Concept_Splitter.html#Cross_link_anchor_1331\">Splitter</A>, <A HREF=\"../Spatial_searching_ref/Concept_SpatialTree.html#Cross_link_anchor_1330\">SpatialTree</A>&gt;</I> implements the standard search strategy for\r\ngeneral distances like the Manhattan distance for iso-rectangles.\r\nIt does not require the use of extended nodes in the spatia tree and supports\r\nonly <MATH><I>k</I></MATH> neighbor searching for queries defined by points or spatial\r\nobjects.\r\n\r\nThe class <I><A HREF=\"../Spatial_searching_ref/Class_Orthogonal_incremental_neighbor_search.html#Cross_link_anchor_1311\">Orthogonal_incremental_neighbor_search</A>&lt;Traits,\r <A HREF=\"../Spatial_searching_ref/Concept_GeneralDistance.html#Cross_link_anchor_1288\">GeneralDistance</A>, <A HREF=\"../Spatial_searching_ref/Concept_Splitter.html#Cross_link_anchor_1331\">Splitter</A>, <A HREF=\"../Spatial_searching_ref/Concept_SpatialTree.html#Cross_link_anchor_1330\">SpatialTree</A>&gt;</I> implements the incrementral\r\nsearch strategy for general distances like the weighted Minkowski\r\ndistance. It requires the use of extended nodes in the spatial tree\r\nand supports incremental neighbor searching and distance browsing for\r\npoint queries.\r\n\r\nThe class <I><A HREF=\"../Spatial_searching_ref/Class_Incremental_neighbor_search.html#Cross_link_anchor_1289\">CGAL::Incremental_neighbor_search</A>&lt;Traits,\r <A HREF=\"../Spatial_searching_ref/Concept_GeneralDistance.html#Cross_link_anchor_1288\">GeneralDistance</A>, <A HREF=\"../Spatial_searching_ref/Concept_Splitter.html#Cross_link_anchor_1331\">Splitter</A>, <A HREF=\"../Spatial_searching_ref/Concept_SpatialTree.html#Cross_link_anchor_1330\">SpatialTree</A>&gt;</I> implements the incremental\r\nsearch strategy for general distances like the Manhattan distance for\r\niso-rectangles.  It does not requires the use of extended nodes in the\r\nspatial tree and supports incremental neighbor searching and distance\r\nbrowsing for queries defined by points or spatial objects.\r\n\r\n\r\n\r\n\r\n\n<h3>61.1.2&nbsp;&nbsp;&nbsp;Range Searching</h3>\n\r\n\r\n<I>Exact range searching</I> and <I>approximate range searching</I> is\r\nsupported using exact or fuzzy <MATH><I>d</I></MATH>-dimensional objects enclosing a\r\nregion.  The fuzziness of the query object is specified by a parameter\r\n<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH> denoting a maximal allowed distance to the boundary of a\r\nquery object.  If the distance to the the boundary is at least\r\n<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>, points inside the object are always reported and points\r\noutside the object are never reported. Points within distance\r\n<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH> to the boundary may be or may be not reported.  For exact\r\nrange searching the fuzziness parameter <MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH> is set to zero.\r\n\r\nThe class <I><A HREF=\"../Spatial_searching_ref/Class_Kd_tree.html#Cross_link_anchor_1294\">Kd_tree</A></I> implements range searching in the method <I>search</I>,\r\nwhich is a template method with an output iterator and a model of the\r\nconcept <I><A HREF=\"../Spatial_searching_ref/Concept_FuzzyQueryItem.html#Cross_link_anchor_1283\">FuzzyQueryItem</A></I> as <I>CGAL::Fuzzy_iso_box_d</I>  \r\nor <I>CGAL::Fuzzy_sphere_d</I>. \r\nFor range searching of large data sets the user may set the parameter <I>bucket_size</I> \r\nused in building the <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> tree to a large value (e.g. 100), \r\nbecause in general the query time will be less then using the default value.\r\n\r\n<a name=\"Section_2\"></a>\n        \n<h2>61.2&nbsp;&nbsp;&nbsp;Splitting Rules</h2>\n\r\n<A NAME=\"Spatial_Searching:Splitting_rule_section\"></A>\r\n\r\nInstead of using the default splitting rule <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Sliding_midpoint.html#Cross_link_anchor_1328\">Sliding_midpoint</A></I> described below,\r\na user may, depending upon the data, select \r\none from the following splitting rules,\r\nwhich determine how a separating hyperplane is computed:\r\n\r\n<DL>\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Midpoint_of_rectangle.html#Cross_link_anchor_1308\">Midpoint_of_rectangle</A></I></B><DD>\r\n\r\nThis splitting rule cuts a rectangle through its <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> orthogonal\r\nto the longest side.\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Midpoint_of_max_spread.html#Cross_link_anchor_1306\">Midpoint_of_max_spread</A></I></B><DD>\r\n\r\nThis splitting rule cuts a rectangle through <MATH><I>(Mind+Maxd)/2</I></MATH> orthogonal\r\nto the dimension with the maximum point spread <MATH><I>[Mind,Maxd]</I></MATH>.\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Sliding_midpoint.html#Cross_link_anchor_1328\">Sliding_midpoint</A></I></B><DD>\r\n\r\nThis is a modification of the <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> of rectangle splitting rule.\r\nIt first attempts to perform a <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> of rectangle split as\r\ndescribed above. If data points lie on both sides of the separating\r\nplane the sliding <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> rule computes the same separator as\r\nthe <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> of rectangle rule. If the data points lie only on one\r\nside it avoids this by sliding the separator, computed by\r\nthe <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> of rectangle rule, to the nearest datapoint.\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Median_of_rectangle.html#Cross_link_anchor_1304\">Median_of_rectangle</A></I></B><DD>\r\n\r\nThe splitting dimension is the dimension of the longest side of the rectangle.\r\nThe splitting value is defined by the median of the coordinates of the data points\r\nalong this dimension.\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Median_of_max_spread.html#Cross_link_anchor_1302\">Median_of_max_spread</A></I></B><DD>\r\n\r\nThe splitting dimension is the dimension of the longest side of the rectangle.\r\nThe splitting value is defined by the median of the coordinates of the data points\r\nalong this dimension.\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Fair.html#Cross_link_anchor_1282\">Fair</A></I></B><DD>\r\n\r\nThis splitting rule is a compromise between the median of rectangle\r\nsplitting rule and the <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> of rectangle splitting rule. This\r\nsplitting rule maintains an upper bound on the maximal allowed ratio\r\nof the longest and shortest side of a rectangle (the value of this\r\nupper bound is set in the constructor of the fair splitting\r\nrule). Among the splits that satisfy this bound, it selects the one in\r\nwhich the points have the largest spread.  It then splits the points\r\nin the most even manner possible, subject to maintaining the bound on\r\nthe ratio of the resulting rectangles.\r\n\r\n<DT><B> <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Sliding_fair.html#Cross_link_anchor_1326\">Sliding_fair</A></I></B><DD>\r\n\r\nThis splitting rule is a compromise between the fair splitting rule\r\nand the sliding <A HREF=\"../Kernel_23_ref/Function_midpoint.html#Cross_link_anchor_239\">midpoint</A> rule.  Sliding fair-split is based on the\r\ntheory that there are two types of splits that are good: balanced\r\nsplits that produce fat rectangles, and unbalanced splits provided the\r\nrectangle with fewer points is fat.\r\n\r\nAlso, this splitting rule maintains an upper bound on the maximal\r\nallowed ratio of the longest and shortest side of a rectangle (the\r\nvalue of this upper bound is set in the constructor of the fair\r\nsplitting rule). Among the splits that satisfy this bound, it selects\r\nthe one one in which the points have the largest spread.  It then\r\nconsiders the most extreme cuts that would be allowed by the aspect\r\nratio bound. This is done by dividing the longest side of the\r\nrectangle by the aspect ratio bound. If the median cut lies between\r\nthese extreme cuts, then we use the median cut. If not, then consider\r\nthe extreme cut that is closer to the median.  If all the points lie\r\nto one side of this cut, then we slide the cut until it hits the first\r\npoint.  This may violate the aspect ratio bound, but will never\r\ngenerate empty cells.\r\n\r\n</DL>\r\n\r\n\r\n\r\n\r\n<a name=\"Section_3\"></a>\n        \n<h2>61.3&nbsp;&nbsp;&nbsp;Example Programs</h2>\n\r\n\r\nWe give six examples.  The first example illustrates k nearest neighbor\r\nsearching, and the second example incremental neighbor searching. \r\nThe third is an example of approximate furthest neighbor searching\r\nusing a <MATH><I>d</I></MATH>-dimensional iso-rectangle as an query object.  Approximate\r\nrange searching is illustrated by the fourth example.  The fifth\r\nexample illustrates k neighbour searching for a user defined point\r\nclass. The last example shows how to choose another splitting rule in the\r\n<MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> tree that is used as search tree.\n<P>\n\n<h3>61.3.1&nbsp;&nbsp;&nbsp;Example of K Neighbor Searching</h3>\n\r\n\r\nThe first example illustrates k neighbor searching with an Euclidean\r\ndistance and 2-dimensional points. The generated random\r\ndata points are inserted in a search tree. We then initialize\r\nthe k neighbor search object with the origin as query. Finally, we \r\nobtain the result of the computation in the form of an iterator\r\nrange. The value of the iterator is a pair of a point and its <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A>\r\ndistance to the query point. We use <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> distances, or <I>transformed distances</I> for other distance classes, as they are \r\ncomputationally cheaper.\r\n\r\n<pre class=\"ExampleCode\">// file: examples/Spatial_searching/Nearest_neighbor_searching.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1313\">Orthogonal_k_neighbor_search</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1318\">Search_traits_2</A>.h&gt;\n#include &lt;list&gt;\n\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; K;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1317\">CGAL::Search_traits_2</A>&lt;K&gt; TreeTraits;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1312\">CGAL::Orthogonal_k_neighbor_search</A>&lt;TreeTraits&gt; Neighbor_search;\ntypedef Neighbor_search::Tree Tree;\n\nint main() {\n  const int N = 1;\n\n  std::list&lt;<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>&gt; points;\n  points.push_back(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(0,0));\n  \n  Tree tree(points.begin(), points.end());\n\n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> query(0,0);\n  \n  // Initialize the search structure, and search all N points\n  \n  Neighbor_search search(tree, query, N);\n  \n   // report the N nearest neighbors and their distance\n  // This should sort all N points by increasing distance from origin\n  for(Neighbor_search::iterator it = search.begin(); it != search.end(); ++it){\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot;&lt;&lt; <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(it-&gt;second) &lt;&lt; std::endl;\n  }\n  \n  \n  return 0;\n}\n</pre>\n<P>\n\n<h3>61.3.2&nbsp;&nbsp;&nbsp;Example of Incremental Searching</h3>\n\r\n\r\nThis example program illustrates incremental searching for the closest\r\npoint with a positive first coordinate. We can use the orthogonal\r\nincremental neighbor search class, as the query is also a point and as\r\nthe distance is the Euclidean distance. \r\n\r\nAs for the <MATH><I>k</I></MATH> neighbor search, we first initialize the search tree with\r\nthe data. We then create the search object, and finally obtain the iterator\r\nwith the <I>begin()</I> method. Note that the iterator is of the input\r\niterator category, that is one can make only one pass over the data. \r\n\r\n \r\n<pre class=\"ExampleCode\">// file: examples/Spatial_searching/Distance_browsing.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Orthogonal_incremental_neighbor_search.html#Cross_link_anchor_1311\">Orthogonal_incremental_neighbor_search</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1318\">Search_traits_2</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; K;\ntypedef K::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1317\">CGAL::Search_traits_2</A>&lt;K&gt; TreeTraits;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Orthogonal_incremental_neighbor_search.html#Cross_link_anchor_1310\">CGAL::Orthogonal_incremental_neighbor_search</A>&lt;TreeTraits&gt; NN_incremental_search;\ntypedef NN_incremental_search::iterator NN_iterator;\ntypedef NN_incremental_search::Tree Tree;\n\n// A functor that returns true, iff the x-coordinate of a dD point is not positive\nstruct X_not_positive {\n  bool operator()(const NN_iterator&amp; it) { return ((*it).first)[0]&lt;0;  }\n};\n\n// An iterator that only enumerates dD points with positive x-coordinate\ntypedef <A HREF=\"../STL_Extension_ref/Class_Filter_iterator.html#Cross_link_anchor_1463\">CGAL::Filter_iterator</A>&lt;NN_iterator, X_not_positive&gt; NN_positive_x_iterator;\n\nint main() {\n\n  Tree tree;\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(0,0));\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(1,1));\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(0,1));\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(10,110));\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(45,0));\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(0,2340));\n  tree.insert(<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>(0,30));\n  \n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> query(0,0);\n\n  NN_incremental_search NN(tree, query);\n  NN_positive_x_iterator it(NN.end(), X_not_positive(), NN.begin()), end(NN.end(), X_not_positive());\n\n  std::cout &lt;&lt;  &quot;The first 5 nearest neighbours with positive x-coord are: &quot; &lt;&lt; std::endl;\n  for (int j=0; (j &lt; 5)&amp;&amp;(it!=end); ++j,++it) \n    std::cout &lt;&lt;   (*it).first &lt;&lt; &quot;  at squared distance = &quot; &lt;&lt; (*it).second &lt;&lt; std::endl;\n\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</pre>\n<P>\n\n<h3>61.3.3&nbsp;&nbsp;&nbsp;Example of General Neighbor Searching</h3>\n\r\n\r\nThis example program illustrates approximate nearest and furthest\r\nneighbor searching using 4-dimensional <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> coordinates.  Five\r\napproximate nearest neighbors of the query rectangle\r\n<MATH><I>[0.1,0.2]<SUP>4</SUP></I></MATH> are computed. Because the query object is a rectangle\r\nwe cannot use the Orthogonal neighbor search. As in the previous \r\nexamples we first initialize a search tree, create the search object\r\nwith the query, and obtain the result of the search as iterator range.\r\n \r\n<pre class=\"ExampleCode\">// file: examples/Spatial_searching/General_neighbor_searching.C\n\n#include &lt;CGAL/Cartesian_d.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Manhattan_distance_iso_box_point.html#Cross_link_anchor_1300\">Manhattan_distance_iso_box_point</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1318\">Search_traits_2</A>.h&gt;\n\ntypedef CGAL::Cartesian_d&lt;double&gt; K;\ntypedef K::<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>;\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_in_square_2.html#Cross_link_anchor_1699\">CGAL::Random_points_in_square_2</A>&lt;<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>&gt; Random_points_iterator;\ntypedef K::<A HREF=\"../Kernel_d_ref/Class_Iso_box_d.html#Cross_link_anchor_503\">Iso_box_d</A> <A HREF=\"../Kernel_d_ref/Class_Iso_box_d.html#Cross_link_anchor_503\">Iso_box_d</A>;\ntypedef K TreeTraits;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Manhattan_distance_iso_box_point.html#Cross_link_anchor_1299\">CGAL::Manhattan_distance_iso_box_point</A>&lt;TreeTraits&gt; Distance;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1291\">CGAL::K_neighbor_search</A>&lt;TreeTraits, Distance&gt; Neighbor_search;\ntypedef Neighbor_search::Tree Tree;\n\nint  main() {\n  const int N = 1000;\n  const int K = 10;\n\n  Tree tree;\n  Random_points_iterator rpg;\n  for(int i = 0; i &lt; N; i++){\n    tree.insert(*rpg++);\n  }\n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> pp(0.1,0.1);\n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> qq(0.2,0.2);\n  <A HREF=\"../Kernel_d_ref/Class_Iso_box_d.html#Cross_link_anchor_503\">Iso_box_d</A> query(pp,qq);\n\n  Distance tr_dist;\n  Neighbor_search N1(tree, query, K, 0.0, false); // eps=10.0, nearest=false\n  \n  std::cout &lt;&lt; &quot;For query rectange = [0.1,0.2]^2 &quot; &lt;&lt; std::endl \n\t    &lt;&lt;  &quot;The &quot; &lt;&lt; K &lt;&lt; &quot; approximate furthest neighbors are: &quot; &lt;&lt; std::endl; \n  for (Neighbor_search::iterator it = N1.begin();it != N1.end();it++) { \n    std::cout &lt;&lt; &quot; Point &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; at distance = &quot; &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl; \n  } \n  return 0;\n}\n</pre>\n<P>\n\n<h3>61.3.4&nbsp;&nbsp;&nbsp;Example of a Range Query</h3>\n\r\n\r\nThis example program illustrates approximate range querying for\r\n4-dimensional fuzzy iso-rectangles and spheres using homogeneous\r\ncoordinates. The range queries are member functions of the <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> \r\ntree class.\r\n\r\n<pre class=\"ExampleCode\">// file: examples/Spatial_searching/Fuzzy_range_query.C\n#include &lt;CGAL/Cartesian_d.h&gt;\n#include &lt;CGAL/point_generators_d.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Kd_tree.html#Cross_link_anchor_1294\">Kd_tree</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Fuzzy_sphere.html#Cross_link_anchor_1287\">Fuzzy_sphere</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Fuzzy_iso_box.html#Cross_link_anchor_1285\">Fuzzy_iso_box</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Search_traits_d.html#Cross_link_anchor_1322\">Search_traits_d</A>.h&gt;\n\ntypedef CGAL::Cartesian_d&lt;double&gt; K;\ntypedef K::<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Search_traits_d.html#Cross_link_anchor_1321\">CGAL::Search_traits_d</A>&lt;K&gt; Traits;\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_in_iso_box_d.html#Cross_link_anchor_1709\">CGAL::Random_points_in_iso_box_d</A>&lt;<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>&gt;       Random_points_iterator;\ntypedef <A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1457\">CGAL::Counting_iterator</A>&lt;Random_points_iterator&gt; N_Random_points_iterator;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Kd_tree.html#Cross_link_anchor_1293\">CGAL::Kd_tree</A>&lt;Traits&gt; Tree;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Fuzzy_sphere.html#Cross_link_anchor_1286\">CGAL::Fuzzy_sphere</A>&lt;Traits&gt; <A HREF=\"../Spatial_searching_ref/Class_Fuzzy_sphere.html#Cross_link_anchor_1287\">Fuzzy_sphere</A>;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Fuzzy_iso_box.html#Cross_link_anchor_1284\">CGAL::Fuzzy_iso_box</A>&lt;Traits&gt; <A HREF=\"../Spatial_searching_ref/Class_Fuzzy_iso_box.html#Cross_link_anchor_1285\">Fuzzy_iso_box</A>;\n\nint main() {\n  const int D = 4;\n  const int N = 1000;\n  // generator for random data points in the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> ( (-1000,-1000), (1000,1000) ) \n  Random_points_iterator rpit(4, 1000.0);\n  \n  // Insert N points in the tree\n  Tree tree(N_Random_points_iterator(rpit,0),\n\t    N_Random_points_iterator(N));\n\n  // define range query objects\n  double  pcoord[D] = { 300, 300, 300, 300 };\n  double  qcoord[D] = { 900.0, 900.0, 900.0, 900.0 };\n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> p(D, pcoord, pcoord+D);\n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> q(D, qcoord, qcoord+D);\n  <A HREF=\"../Spatial_searching_ref/Class_Fuzzy_sphere.html#Cross_link_anchor_1287\">Fuzzy_sphere</A> fs(p, 700.0, 100.0);\n  <A HREF=\"../Spatial_searching_ref/Class_Fuzzy_iso_box.html#Cross_link_anchor_1285\">Fuzzy_iso_box</A> fib(p, q, 100.0);\n\n  std::cout &lt;&lt; &quot;points approximately in fuzzy range query&quot; &lt;&lt; std::endl; \n  std::cout &lt;&lt; &quot;with center (300.0, 300.0, 300.0, 300.0)&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;and fuzzy radius &lt;200.0,400.0&gt; are:&quot; &lt;&lt; std::endl;\n  tree.search(std::ostream_iterator&lt;<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>&gt;(std::cout, &quot;\\n&quot;), fs);\n\n  std::cout &lt;&lt; &quot;points approximately in fuzzy range query &quot;;\n  std::cout &lt;&lt; &quot;[&lt;200,4000&gt;,&lt;800,1000&gt;]]^4 are:&quot; &lt;&lt; std::endl;\n\n  tree.search(std::ostream_iterator&lt;<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>&gt;(std::cout, &quot;\\n&quot;), fib);\n  return 0;\n}\n</pre>\n<P>\n\n<h3>61.3.5&nbsp;&nbsp;&nbsp;Example Illustrating Use of User Defined Point and Distance Class</h3>\n\r\n\r\nThe neighbor searching works with all C<SMALL>GAL</SMALL> kernels, as well as with\r\nuser defined points and distance classes.\r\nIn this example we assume that the user provides the following 3-dimensional \r\npoints class.\r\n\r\n<pre class=\"ExampleCode\">struct Point {\n  double vec[3];\n\n  Point() { vec[0]= vec[1] = vec[2] = 0; }\n  Point (double x, double y, double z) { vec[0]=x; vec[1]=y; vec[2]=z;  }\n \n  double x() const { return vec[ 0 ]; }\n  double y() const { return vec[ 1 ]; }\n  double z() const { return vec[ 2 ]; }\n\n  double&amp; x() { return vec[ 0 ]; }\n  double&amp; y() { return vec[ 1 ]; }\n  double&amp; z() { return vec[ 2 ]; }\n  \n  bool operator==(const Point&amp; p) const \n  {\n    return (x() == p.x()) &amp;&amp; (y() == p.y()) &amp;&amp; (z() == p.z())  ;\n  }\n\n  bool  operator!=(const Point&amp; p) const { return ! (*this == p); }\n}; //end of class\n\n\n\nnamespace CGAL {\n\n  template &lt;&gt;\n  struct <A HREF=\"../Kernel_23_ref/Class_Kernel_traits.html#Cross_link_anchor_28\">Kernel_traits</A>&lt;Point&gt; {\n    struct <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A> {\n      typedef double FT;\n      typedef double RT;\n    };\n  };\n}\n\n\nstruct Construct_coord_iterator {\n  const double* operator()(const Point&amp; p) const \n  { return static_cast&lt;const double*&gt;(p.vec); }\n\n  const double* operator()(const Point&amp; p, int)  const\n  { return static_cast&lt;const double*&gt;(p.vec+3); }\n};\n</pre>\r\n\r\nWe have put the glue layer in this file as well, that is a class that allows to \r\niterate over the <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> coordinates of the point, and a class to construct\r\nsuch an iterator for a point. We next need a distance class\n<P>\n\n<pre class=\"ExampleCode\">struct Distance {\n  typedef Point Query_item;\n\n  double transformed_distance(const Point&amp; p1, const Point&amp; p2) const {\n    double distx= p1.x()-p2.x();\n    double disty= p1.y()-p2.y();\n    double distz= p1.z()-p2.z();\n    return distx*distx+disty*disty+distz*distz;\n  }\n\n  template &lt;class TreeTraits&gt;\n  double min_distance_to_rectangle(const Point&amp; p,\n\t\t\t\t   const <A HREF=\"../Spatial_searching_ref/Class_Kd_tree_rectangle.html#Cross_link_anchor_1297\">CGAL::Kd_tree_rectangle</A>&lt;TreeTraits&gt;&amp; b) const {   \n    double distance(0.0), h = p.x();\n    if (h &lt; b.min_coord(0)) distance += (b.min_coord(0)-h)*(b.min_coord(0)-h);\n    if (h &gt; b.max_coord(0)) distance += (h-b.max_coord(0))*(h-b.max_coord(0));\n    h=p.y();\n    if (h &lt; b.min_coord(1)) distance += (b.min_coord(1)-h)*(b.min_coord(1)-h);\n    if (h &gt; b.max_coord(1)) distance += (h-b.max_coord(1))*(h-b.min_coord(1));\n    h=p.z();\n    if (h &lt; b.min_coord(2)) distance += (b.min_coord(2)-h)*(b.min_coord(2)-h);\n    if (h &gt; b.max_coord(2)) distance += (h-b.max_coord(2))*(h-b.max_coord(2));\n    return distance;\n  }\n  \n  template &lt;class TreeTraits&gt;\n  double max_distance_to_rectangle(const Point&amp; p,\n\t\t\t\t   const <A HREF=\"../Spatial_searching_ref/Class_Kd_tree_rectangle.html#Cross_link_anchor_1297\">CGAL::Kd_tree_rectangle</A>&lt;TreeTraits&gt;&amp; b) const {   \n    double h = p.x();\n\n    double d0 = (h &gt;= (b.min_coord(0)+b.max_coord(0))/2.0) ?\n                (h-b.min_coord(0))*(h-b.min_coord(0)) : (b.max_coord(0)-h)*(b.max_coord(0)-h);\n    \n    h=p.y();\n    double d1 = (h &gt;= (b.min_coord(1)+b.max_coord(1))/2.0) ?\n                (h-b.min_coord(1))*(h-b.min_coord(1)) : (b.max_coord(1)-h)*(b.max_coord(1)-h);\n    h=p.z();\n    double d2 = (h &gt;= (b.min_coord(2)+b.max_coord(2))/2.0) ?\n                (h-b.min_coord(2))*(h-b.min_coord(2)) : (b.max_coord(2)-h)*(b.max_coord(2)-h);\n    return d0 + d1 + d2;\n  }\n  \n  double new_distance(double&amp; dist, double old_off, double new_off,\n\t\t      int cutting_dimension)  const {\n    return dist + new_off*new_off - old_off*old_off;\n  }\n  \n  double transformed_distance(double d) const { return d*d; }\n  \n  double inverse_of_transformed_distance(double d) { return <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(d); }\n  \n}; // end of struct Distance\n</pre>\n<P>\n\nWe are ready to put the pices together.\r\nThe class <I><A HREF=\"../Spatial_searching_ref/Class_Search_traits.html#Cross_link_anchor_1324\">Search_traits</A>&lt;..&gt;</I> which you see in the next file is then a mere \r\nwrapper for all these types.  The searching itself works exactly as for C<SMALL>GAL</SMALL> kernels.\r\n\r\n<pre class=\"ExampleCode\">//file: examples/Spatial_searching/User_defined_point_and_distance.C\n\n#include &lt;CGAL/basic.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Search_traits.html#Cross_link_anchor_1324\">Search_traits</A>.h&gt;\n#include &lt;CGAL/point_generators_3.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1313\">Orthogonal_k_neighbor_search</A>.h&gt;\n#include &quot;Point.h&quot;  // defines types Point, Construct_coord_iterator\n#include &quot;Distance.h&quot;\n\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_in_cube_3.html#Cross_link_anchor_1693\">CGAL::Random_points_in_cube_3</A>&lt;Point&gt; Random_points_iterator;\ntypedef <A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1457\">CGAL::Counting_iterator</A>&lt;Random_points_iterator&gt; N_Random_points_iterator;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Search_traits.html#Cross_link_anchor_1323\">CGAL::Search_traits</A>&lt;double, Point, const double*, Construct_coord_iterator&gt; Traits;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1312\">CGAL::Orthogonal_k_neighbor_search</A>&lt;Traits, Distance&gt; <A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A>;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A>::Tree Tree;\n\nint main() {\n  const int N = 1000;\n  const int K = 5;\n  // generator for random data points in the cube ( (-1,-1,-1), (1,1,1) ) \n  Random_points_iterator rpit( 1.0);\n  \n  // Insert number_of_data_points in the tree\n  Tree tree(N_Random_points_iterator(rpit,0),\n\t    N_Random_points_iterator(N));\n\n  Point query(0.0, 0.0, 0.0);\n  Distance tr_dist;\n\n  // search K nearest neighbours\n  <A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A> search(tree, query, K);\n  for(<A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A>::iterator it = search.begin(); it != search.end(); it++){\n    std::cout &lt;&lt; &quot; d(q, nearest neighbor)=  &quot; \n\t      &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl; \n  }\n  // search K furthest neighbour searching, with eps=0, search_nearest=false \n  <A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A> search2(tree, query, K, 0.0, false);\n  \n  for(<A HREF=\"../Spatial_searching_ref/Class_K_neighbor_search.html#Cross_link_anchor_1292\">K_neighbor_search</A>::iterator it = search2.begin(); it != search2.end(); it++){\n    std::cout &lt;&lt; &quot; d(q, furthest neighbor)=  &quot; \n\t      &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl; \n  }\n  return 0;\n}\n</pre>\n<P>\n\n<h3>61.3.6&nbsp;&nbsp;&nbsp;Example of Selecting a Splitting Rule and Setting the Bucket Size</h3>\n\r\n\r\nThis example program illustrates selecting a splitting rule and\r\nsetting the maximal allowed bucket size.  The only differences with\r\nthe first example are the declaration of the <I><A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Fair.html#Cross_link_anchor_1282\">Fair</A></I> \r\nsplitting rule, needed to set the maximal allowed bucket size.\r\n\r\n<pre class=\"ExampleCode\">// file: examples/Spatial_searching/Using_fair_splitting_rule.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/point_generators_2.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1318\">Search_traits_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1313\">Orthogonal_k_neighbor_search</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; R;\ntypedef R::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>;\ntypedef <A HREF=\"../Generator_ref/Class_Random_points_in_square_2.html#Cross_link_anchor_1699\">CGAL::Random_points_in_square_2</A>&lt;<A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A>&gt; Random_points_iterator;\ntypedef <A HREF=\"../STL_Extension_ref/Class_Counting_iterator.html#Cross_link_anchor_1457\">CGAL::Counting_iterator</A>&lt;Random_points_iterator&gt; N_Random_points_iterator;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Search_traits_2.html#Cross_link_anchor_1317\">CGAL::Search_traits_2</A>&lt;R&gt; Traits;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Euclidean_distance.html#Cross_link_anchor_1277\">CGAL::Euclidean_distance</A>&lt;Traits&gt; Distance;\ntypedef <A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Fair.html#Cross_link_anchor_1281\">CGAL::Fair</A>&lt;Traits&gt; <A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Fair.html#Cross_link_anchor_1282\">Fair</A>;\ntypedef <A HREF=\"../Spatial_searching_ref/Class_Orthogonal_k_neighbor_search.html#Cross_link_anchor_1312\">CGAL::Orthogonal_k_neighbor_search</A>&lt;Traits,Distance,<A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Fair.html#Cross_link_anchor_1282\">Fair</A>&gt; Neighbor_search;\ntypedef Neighbor_search::Tree Tree;\n\nint main() {\n  const int N = 1000;\n  // generator for random data points in the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> ( (-1,-1), (1,1) ) \n  Random_points_iterator rpit( 1.0);\n\n  <A HREF=\"../Spatial_searching_ref/FunctionObjectClass_Fair.html#Cross_link_anchor_1282\">Fair</A> fair(5); // bucket size=5\n  // Insert number_of_data_points in the tree\n  Tree tree(N_Random_points_iterator(rpit,0),\n\t    N_Random_points_iterator(N),\n\t    fair);\n\n  <A HREF=\"../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487\">Point_d</A> query(0,0);\n\n  // Initialize the search structure, and search all N points\n  Neighbor_search search(tree, query, N);\n\n  // report the N nearest neighbors and their distance\n  // This should sort all N points by increasing distance from origin\n  for(Neighbor_search::iterator it = search.begin(); it != search.end(); ++it){\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot;&lt;&lt; <A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(it-&gt;second) &lt;&lt; std::endl;\n  }\n  return 0;\n}\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>61.4&nbsp;&nbsp;&nbsp;Software Design</h2>\n\r\n\r\n\n<h3>61.4.1&nbsp;&nbsp;&nbsp;The <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> tree</h3>\n\r\n<A NAME=\"Kd_tree_subsection\"></A>\r\n\r\nBentley [<A HREF=\"../biblio.html#Biblio_b-mbstu-75\">Ben75</A>] introduced the <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> tree as a\r\ngeneralization of the binary search tree in higher dimensions. <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH>\r\ntrees hierarchically decompose space into a relatively small number of\r\nrectangles such that no rectangle contains too many input objects.\r\nFor our purposes, a <I>rectangle</I> in real <MATH><I>d</I></MATH> dimensional space,\r\n<MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH>, is the product of <MATH><I>d</I></MATH> closed intervals on the coordinate axes.\r\n<MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> trees are obtained by partitioning point sets in <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> using\r\n(<MATH><I>d</I></MATH>-1)-dimensional hyperplanes.  Each node in the tree is split into\r\ntwo children by one such separating hyperplane.  Several splitting\r\nrules (see Section <A HREF=\"Chapter_main.html#Spatial_Searching:Splitting_rule_section\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> can\r\nbe used to compute a seperating (<MATH><I>d</I></MATH>-1)-dimensional hyperplane.\r\n\r\nEach internal node of the <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> tree is associated with a rectangle\r\nand a hyperplane orthogonal to one of the coordinate axis, which\r\nsplits the rectangle into two parts.  Therefore, such a hyperplane,\r\ndefined by a splitting dimension and a splitting value, is called a\r\nseparator.  These two parts are then associated with the two child\r\nnodes in the tree. The process of partitioning space continues until\r\nthe number of data points in the rectangle falls below some given\r\nthreshold. The rectangles associated with the leaf nodes are called\r\n<I>buckets</I>, and they define a subdivision of the space into\r\nrectangles.  Data points are only stored in the leaf nodes of the\r\ntree, not in the internal nodes.\r\n\r\nFriedmann, Bentley and Finkel [<A HREF=\"../biblio.html#Biblio_fbf-afbml-77\">FBF77</A>] described the\r\nstandard search algorithm to find the <MATH><I>k</I></MATH>th nearest neighbor by\r\nsearching a <MATH><I>k</I></MATH>-<MATH><I>d</I></MATH> tree recursively.\r\n\r\nWhen encountering a node of the tree, the algorithm first visits the\r\nchild that is closest to the query point. On return, if the rectangle\r\ncontaining the other child lies within 1/ (1+<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>) times the\r\ndistance to the <MATH><I>k</I></MATH>th nearest neighbors so far, then the other child\r\nis visited recursively.  Priority search [<A HREF=\"../biblio.html#Biblio_am-annqf-93\">AM93b</A>] visits the\r\nnodes in increasing order of distance from the queue with help of a\r\npriority queue.  The search stops when the distance of the query point\r\nto the nearest nodes exceeds the distance to the nearest point found\r\nwith a factor 1/ (1+<MATH><I><IMG BORDER=0 WIDTH=5 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_epsilon.gif\"></I></MATH>).  Priority search supports next\r\nneighbor search, standard search does not.\r\n\r\nIn order to speed-up the internal distance computations in nearest\r\nneighbor searching in high dimensional space, the approximate\r\nsearching package supports orthogonal distance computation. Orthogonal distance\r\ncomputation\r\nimplements the efficient incremental distance computation technique\r\nintroduced by Arya and Mount [<A HREF=\"../biblio.html#Biblio_am-afvq-93\">AM93a</A>].  This technique\r\nworks only for neighbor queries with query items represented as points\r\nand with a quadratic form distance, defined by <MATH><I>d<SUB>A</SUB>(x,y)=\r\n(x-y)A(x-y)<SUP>T</SUP></I></MATH>, where the matrix <MATH><I>A</I></MATH> is positive definite,\r\ni.e. <MATH><I>d<SUB>A</SUB>(x,y)  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 0</I></MATH>.  An important class of quadratic form\r\ndistances are weighted Minkowski distances.  Given a parameter <MATH><I>p&gt;0</I></MATH>\r\nand parameters <MATH><I>w<SUB>i</SUB>  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 0, 0 &lt; i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> d</I></MATH>, the weighted Minkowski\r\ndistance is defined by <MATH><I>l<SUB>p</SUB>(w)(r,q)= (<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_Sigma.gif\"><SUB>i=1</SUB><SUP>i=d</SUP> \r\nw<SUB>i</SUB>(r<SUB>i</SUB>-q<SUB>i</SUB>)<SUP>p</SUP>)<SUP>1/p</SUP></I></MATH> for <MATH><I>0 &lt; p &lt; <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </I></MATH> and defined by\r\n<MATH><I>l<SUB> <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC=\"cc_infty.gif\"> </SUB>(w)(r,q)=<A HREF=\"../NumberTypeSupport_ref/Function_max.html#Cross_link_anchor_1392\">max</A> {w<SUB>i</SUB> |r<SUB>i</SUB>-q<SUB>i</SUB>|  <IMG BORDER=0 WIDTH=2 HEIGHT=29 ALIGN=MIDDLE SRC=\"cc_mid.gif\"> 1  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> d}</I></MATH>.  The\r\nManhattan distance (<MATH><I>p=1</I></MATH>, <MATH><I>w<SUB>i</SUB>=1</I></MATH>) and the Euclidean distance (<MATH><I>p=2</I></MATH>,\r\n<MATH><I>w<SUB>i</SUB>=1</I></MATH>) are examples of a weighted Minkowski metric.\r\n\r\nTo speed up distance computations also transformed distances are used\r\ninstead of the distance itself.  For instance for the Euclidean\r\ndistance, to avoid the expensive computation of <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> roots, squared\r\ndistances are used instead of the Euclidean distance itself.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Spatial_searching_ref/Chapter_intro.html\">Spatial Searching</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_61!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38945.0}