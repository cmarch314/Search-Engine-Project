{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 5Extensible Kernel This manual section describe how users can plug user defined geometric classes in existing CGAL kernels This is best illustrated by an example 5 1 Introduction CGAL defines the concept of a geometry kernel Such a kernel provides types construction objects and generalized predicates Most implementations of Computational Geometry algorithms and data structures in the basic library of CGAL were done in a way that classes or functions can be parametrized with a geometric traits class In most cases this geometric traits class must be a model of the CGAL geometry kernel concept but there are some exceptions 5 2 An Extensive Example Assume you have the following point class where the coordinates are stored in an array of doubles where we have another data member color which shows up in the constructor class MyPointC2 private double vec 2 int col public MyPointC2 col vec vec 1 MyPointC2 const double x const double y int c col c vec x vec 1 y const double x const return vec const double y const return vec 1 double x return vec double y return vec 1 int color const return col int color return col bool operator const MyPointC2 p const return vec p vec vec 1 p vec 1 col p col bool operator const MyPointC2 p const return this p As said earlier the class is pretty minimalistic for example it has no bbox method One might assume that a basic library algorithm which computes a bounding box e g to compute the bounding box of a polygon will not compile Luckily it will because it does not use of member functions of geometric objects but it makes use of the functor Kernel Construct bbox 2 To make the right thing happen with MyPointC2 we have to provide the following functor template class ConstructBbox 2 class MyConstruct bbox 2 public ConstructBbox 2 public CGAL Bbox 2 operator const typename MyPointC2 p const return CGAL Bbox 2 p x p y p x p y Things are similar for random access to the Cartesian coordinates of a point As the coordinates are stored in an array of doubles we can use double as random access iterator class MyConstruct coord iterator public const double operator const MyPointC2 p return p x const double operator const MyPointC2 p int const double pyptr p y pyptr return pyptr The last functor we have to provide is the one which constructs points That is you are not forced to add the constructor with the Origin as parameter to your class nor the constructor with homogeneous coordinates and at the same time you can pass the additional color argument to your point constructor The functor is a kind of glue layer between the CGAL algorithms and your class template typename K class MyConstruct point 2 typedef typename K RT RT typedef typename K Point 2 Point 2 public typedef Point 2 result type typedef CGAL Arity tag 1 Arity Point 2 operator const return Point 2 Point 2 operator CGAL Origin o const return Point 2 Point 2 operator const RT x const RT y const return Point 2 x y We need this one as such a functor is in the Filtered kernel Point 2 operator const RT x const RT y const RT w const if w 1 return Point 2 x w y w else return Point 2 x y Now we are ready to put the puzzle together We won t explain it in detail but you see that there are typedefs to the new point class and the functors All the other types are inherited ifndef MYKERNEL H define MYKERNEL H include CGAL Cartesian h include MyPointC2 h include MySegmentC2 h K is the new kernel and K Base is the old kernel template typename K typename K Base class MyCartesian base public K Base template Base K Type typedef typename K Base template Base K Type OldK public typedef K Kernel typedef MyPointC2 Point 2 typedef MySegmentC2 Kernel Segment 2 typedef MyConstruct point 2 Kernel Construct point 2 typedef const double Cartesian const iterator 2 typedef MyConstruct coord iterator Construct cartesian const iterator 2 typedef MyConstruct bbox 2 typename OldK Construct bbox 2 Construct bbox 2 template typename Kernel2 struct Base typedef MyCartesian base Kernel2 K Base Type template typename FT struct MyKernel public MyCartesian base MyKernel FT CGAL Cartesian FT endif MYKERNEL H Finally we give an example how this new kernel can be used Predicates and constructions work with the new point they can be a used to construct segments and triangles with and data structures from the Basic Library as the Delaunay triangulation work with them The kernel itself can be made robust by plugging it in the Filtered kernel adaptor This class has the same functionality as the class Filtered kernel with the only difference that it does not enforce type equality between Kernel Point 2 and Point 2 Kernel which does not make sense in our case as our point does not offer the functionality of the latter file examples Kernel 23 MyKernel C include CGAL basic h include CGAL Filtered kernel h include CGAL Delaunay triangulation 2 h include CGAL squared distance 2 h include cassert include MyKernel h typedef MyKernel double MK typedef CGAL Filtered kernel adaptor MK K typedef CGAL Delaunay triangulation 2 K Delaunay triangulation 2 typedef K Point 2 Point typedef K Segment 2 Segment typedef K Ray 2 Ray typedef K Line 2 Line typedef K Triangle 2 Triangle typedef K Iso rectangle 2 Iso rectangle const int RED 1 const int BLACK 2 int main Point a RED b 1 BLACK c 1 1 BLACK d 1 RED Delaunay triangulation 2 dt dt insert a K Orientation 2 orientation orientation a b c Point p 1 2 BLACK q p color RED q color BLACK std cout p std endl K Compute squared distance 2 squared distance std cout squared distance a b squared distance a b std endl Segment s1 p q s2 a c K Construct midpoint 2 construct midpoint 2 construct midpoint 2 p q assert s1 source color RED s1 source color BLACK assert s1 source color BLACK K Intersect 2 intersection CGAL Object o intersection s1 s2 K Construct cartesian const iterator 2 construct it K Cartesian const iterator 2 cit construct it a assert cit a x cit construct it a cit assert cit a y Line l1 a b l2 p q intersection l1 l2 intersection s1 l1 Ray r1 d b r2 d c intersection r1 r2 intersection r1 l1 squared distance r1 r2 squared distance r1 l2 squared distance r1 s2 Triangle t1 a b c t2 a c d intersection t1 t2 intersection t1 l1 intersection t1 s1 intersection t1 r1 Iso rectangle i1 a c i2 d p intersection i1 i2 intersection i1 s1 intersection i1 r1 intersection i1 l1 t1 orientation std cout s1 source std endl std cout t1 bbox std endl return 5 3 Limitations The point class must have member functions x and y and z for the 3d point We will probably introduce function objects that take care of coordinate access Global functions operating on for example CGAL orientation CGAL MyKernel double Point 2 CGAL MyKernel double Point 2 CGAL MyKernel double Point 2 will not work Instead you have to use the functor MyKernel double Orientation 2 Rewriting the code is however straightforward you can give the function object the same name as the global function K Orientation 2 orientation 2 K Point 2 p RED q 1 1 BLACK r 2 1 RED orientation p q r We did not go through the entire kernel to also make it possible to plug in user defined lines rays or triangles Next chapter Kernel Related Tools Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Kernel_23/Chapter_extensible_kernel.html", "title": "extensible kernel", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Kernel_23/extensible_kernel.tex' -->\n<html> <head>  \n<title>Extensible Kernel</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_extensible_kernel.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_5\"></a>\n  \n<h1>Chapter 5<BR>Extensible Kernel</h1>\n<P>\n\nThis manual section describe how users can plug user defined\ngeometric classes in existing C<SMALL>GAL</SMALL> kernels.  This is best\nillustrated by an example.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>5.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nC<SMALL>GAL</SMALL> defines the concept of a geometry kernel. Such a kernel provides types,\nconstruction objects and generalized predicates. Most implementations\nof Computational Geometry algorithms and data structures in the basic\nlibrary of C<SMALL>GAL</SMALL> were done in a way that classes or functions can be\nparametrized with a geometric traits class.\n<P>\n\nIn most cases this geometric traits class must be a model of the C<SMALL>GAL</SMALL> geometry\nkernel concept (but there are some exceptions).\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>5.2&nbsp;&nbsp;&nbsp;An Extensive Example</h2>\n<P>\n\nAssume you have the following point class, where the coordinates are\nstored in an array of <I>doubles</I>, where we have another data member\n<I>color</I>, which shows up in the constructor.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<pre class=\"ExampleCode\">\nclass MyPointC2 {\n\nprivate:\n  double vec[2];\n  int col;\n\npublic:\n\n  MyPointC2()\n    : col(0)\n  {\n    *vec = 0;\n    *(vec+1) = 0;\n  }\n\n  \n  MyPointC2(const double x, const double y, int c)\n    : col(c)\n  {\n    *vec = x;\n    *(vec+1) = y;\n  }\n\n  const double&amp; x() const  { return *vec; }\n\n  const double&amp; y() const { return *(vec+1); }\n\n  double &amp; x() { return *vec; }\n\n  double&amp; y() { return *(vec+1); }\n\n  int color() const { return col; }\n\n  int&amp; color() { return col; }\n  \n  \n  bool operator==(const MyPointC2 &amp;p) const\n  {\n    return ( *vec == *(p.vec) )  &amp;&amp; ( *(vec+1) == *(p.vec + 1) &amp;&amp; ( col == p.col) );\n  }\n\n  bool operator!=(const MyPointC2 &amp;p) const\n  {\n      return !(*this == p);\n  }\n\n};\n</pre>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\nAs said earlier the class is pretty minimalistic, for\nexample it has no <I>bbox()</I> method.  One\nmight assume that a basic library algorithm which computes \na bounding box (e.g, to compute the bounding box of a polygon),\nwill not compile. Luckily it will, because it does not\nuse of member functions of geometric objects, but it makes\nuse of the functor <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::Construct_bbox_2</I>.\n<P>\n\nTo make the right thing happen with <I>MyPointC2</I> we\nhave to provide the following functor.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<pre class=\"ExampleCode\">\ntemplate &lt;class ConstructBbox_2&gt;\nclass MyConstruct_bbox_2 : public ConstructBbox_2 {\npublic:\n  CGAL::Bbox_2 operator()(const typename MyPointC2&amp; p) const {\n    return CGAL::Bbox_2(p.x(), p.y(), p.x(), p.y());\n  }\n};\n</pre>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\nThings are similar for random access to the \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n\ncoordinates of a point. As the coordinates are stored\nin an array of <I>doubles</I> we can use <I>double*</I> as\nrandom access iterator.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<pre class=\"ExampleCode\">\nclass MyConstruct_coord_iterator {\npublic:\n  const double* operator()(const MyPointC2&amp; p)\n  {\n    return &amp;p.x();\n  }\n\n  const double* operator()(const MyPointC2&amp; p, int)\n  {\n    const double* pyptr = &amp;p.y();\n    pyptr++;\n    return pyptr;\n  }\n};\n</pre>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\nThe last functor we have to provide is the one which constructs\npoints. That is you are not forced to add the constructor \nwith the <I><A HREF=\"../Kernel_23_ref/Class_Origin.html#Cross_link_anchor_139\">Origin</A></I> as parameter to your class, nor the constructor with \nhomogeneous coordinates, and at the same time you can \npass the additional color argument to your point constructor.\nThe functor is a kind of glue layer between the C<SMALL>GAL</SMALL> algorithms\nand your class.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<pre class=\"ExampleCode\">\n template &lt;typename K&gt;\n  class MyConstruct_point_2\n  {\n    typedef typename K::RT         RT;\n    typedef typename K::Point_2    Point_2;\n  public:\n    typedef Point_2          result_type;\n    typedef CGAL::Arity_tag&lt; 1 &gt;   Arity;\n\n    Point_2\n    operator()() const\n    { return Point_2(); }\n\n    Point_2\n    operator()(CGAL::Origin o) const\n    { return Point_2(0,0, 0); }\n\n    Point_2\n    operator()(const RT&amp; x, const RT&amp; y) const\n    { return Point_2(x, y, 0); }\n\n    \n    // We need this one, as such a functor is in the Filtered_kernel\n    Point_2\n    operator()(const RT&amp; x, const RT&amp; y, const RT&amp; w) const\n    { \n      if(w != 1){\n\treturn Point_2(x/w, y/w, 0); \n      } else {\n\treturn Point_2(x,y, 0);\n      }\n    }\n  };\n\n</pre>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\nNow we are ready to put the puzzle together. We won't explain it in\ndetail, but you see that there are <I>typedefs</I> to the new point\nclass and the functors. All the other types are inherited.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<P>\n\n<pre class=\"ExampleCode\">#ifndef MYKERNEL_H\n#define MYKERNEL_H\n\n#include &lt;CGAL/Cartesian.h&gt;\n#include &quot;MyPointC2.h&quot;\n#include &quot;MySegmentC2.h&quot;\n\n// K_ is the new kernel, and K_Base is the old kernel\ntemplate &lt; typename K_, typename K_Base &gt;\nclass MyCartesian_base\n  : public K_Base::template Base&lt;K_&gt;::Type\n{\n  typedef typename K_Base::template Base&lt;K_&gt;::Type   OldK;\npublic:\n  typedef K_                                Kernel;\n  typedef MyPointC2                         Point_2;\n  typedef MySegmentC2&lt;Kernel&gt;               Segment_2;\n  typedef MyConstruct_point_2&lt;Kernel&gt;       Construct_point_2;\n  typedef const double*                     Cartesian_const_iterator_2;\n  typedef MyConstruct_coord_iterator        Construct_cartesian_const_iterator_2;\n  typedef MyConstruct_bbox_2&lt;typename OldK::Construct_bbox_2&gt; \n                                            Construct_bbox_2;\n\n  template &lt; typename Kernel2 &gt;\n  struct Base { typedef MyCartesian_base&lt;Kernel2, K_Base&gt;  Type; };\n};\n\n\ntemplate &lt; typename FT_ &gt;\nstruct MyKernel\n  : public MyCartesian_base&lt;MyKernel&lt;FT_&gt;, CGAL::Cartesian&lt;FT_&gt; &gt;\n{};\n\n#endif // MYKERNEL_H\n</pre>\n<P>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\nFinally, we give an example how this new kernel can be used.\nPredicates and constructions work with the new point, they\ncan be a used to construct segments and triangles with, and\ndata structures from the Basic Library, as the Delaunay\ntriangulation work with them.\n<P>\n\nThe kernel itself can be\nmade robust by plugging it in the <I><A HREF=\"../Kernel_23_ref/Class_Filtered_kernel_adaptor.html#Cross_link_anchor_14\">Filtered_kernel_adaptor</A></I>.\nThis class has the same functionality as the class <I><A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_12\">Filtered_kernel</A></I>\nwith the only difference that it does not enforce type equality\nbetween <I><A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_2.html#Cross_link_anchor_459\">Kernel::Point_2</A></I> and <I><A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I>, which\ndoes not make sense in our case as our point does not offer\nthe functionality of the latter.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<pre class=\"ExampleCode\">// file: examples/Kernel_23/MyKernel.C\n\n#include &lt;CGAL/basic.h&gt;\n#include &lt;CGAL/Filtered_kernel.h&gt;\n#include &lt;CGAL/Delaunay_triangulation_2.h&gt;\n#include &lt;CGAL/squared_distance_2.h&gt;\n#include &lt;cassert&gt;\n#include &quot;MyKernel.h&quot;\n\n\ntypedef MyKernel&lt;double&gt;                   MK;\ntypedef CGAL::Filtered_kernel_adaptor&lt;MK&gt;  K;\ntypedef CGAL::Delaunay_triangulation_2&lt;K&gt;  Delaunay_triangulation_2;\n\n\ntypedef K::Point_2         Point;\ntypedef K::Segment_2       Segment;\ntypedef K::Ray_2           Ray;\ntypedef K::Line_2          Line;\ntypedef K::Triangle_2      Triangle;\ntypedef K::Iso_rectangle_2 Iso_rectangle;\n\nconst int RED= 1;\nconst int BLACK=2;\n\nint main()\n{\n  Point a(0,0, RED), b(1,0, BLACK), c(1,1, BLACK), d(0,1, RED);\n\n  Delaunay_triangulation_2 dt;\n  dt.insert(a);\n\n  K::Orientation_2 orientation;\n  orientation(a,b,c);\n  Point p(1,2, BLACK), q;\n  p.color() = RED;\n  q.color() = BLACK;\n  std::cout &lt;&lt; p &lt;&lt; std::endl;\n\n  K::Compute_squared_distance_2 squared_distance;\n\n  std::cout &lt;&lt; &quot;squared_distance(a, b) == &quot;\n            &lt;&lt; squared_distance(a, b) &lt;&lt; std::endl;\n\n  Segment s1(p,q), s2(a, c);\n\n  K::Construct_midpoint_2 construct_midpoint_2;\n\n  construct_midpoint_2(p,q);\n\n  assert(s1.source().color() == RED);\n\n  s1.source().color() = BLACK;\n\n  assert(s1.source().color() == BLACK);\n\n  K::Intersect_2 intersection;\n\n  CGAL::Object o = intersection(s1, s2);\n\n  K::Construct_cartesian_const_iterator_2 construct_it;\n  K::Cartesian_const_iterator_2  cit = construct_it(a);\n  assert(*cit == a.x());\n\n  cit = construct_it(a,0);\n\n  cit--;\n  assert(*cit == a.y());\n\n  Line l1(a,b), l2(p, q);\n\n  intersection(l1, l2);\n\n\n  intersection(s1, l1);\n\n  Ray r1(d,b), r2(d,c);\n  intersection(r1, r2);\n\n  intersection(r1, l1);\n\n  squared_distance(r1, r2);\n  squared_distance(r1, l2);\n  squared_distance(r1, s2);\n\n  Triangle t1(a,b,c), t2(a,c,d);\n  intersection(t1, t2);\n  intersection(t1, l1);\n\n  intersection(t1, s1);\n\n  intersection(t1, r1);\n\n  Iso_rectangle i1(a,c), i2(d,p);\n  intersection(i1, i2);\n  intersection(i1, s1);\n\n  intersection(i1, r1);\n  intersection(i1, l1);\n\n  t1.orientation();\n\n  std::cout &lt;&lt; s1.source() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; t1.bbox() &lt;&lt; std::endl;\n  return 0;\n}\n</pre>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>5.3&nbsp;&nbsp;&nbsp;Limitations</h2>\n<P>\n\nThe point class must have member functions <I>x()</I> and <I>y()</I>\n(and <I>z()</I> for the 3d point). We will probably\nintroduce function objects that take care of coordinate\naccess.\n<P>\n\nGlobal functions operating on, for example\n<I><A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_246\">CGAL::orientation</A>(CGAL::MyKernel&lt;double&gt;::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>,CGAL::MyKernel&lt;double&gt;::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>,CGAL::MyKernel&lt;double&gt;::<A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A></I> will not work. \nInstead you have to use the functor <I>MyKernel&lt;double&gt;::Orientation_2</I>.\n<P>\n\nRewriting the code is however straightforward: you can give\nthe function object the same name as the global function.\n<P>\n\n<!-- REMOVE_LINKS_BEGIN -->\n<pre class=\"ExampleCode\">\n\nK::Orientation_2 orientation_2;\nK::Point_2 p(0,0,RED), q(1,1,BLACK), r(2,1, RED);\n\norientation(p, q, r);\n\n</pre>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\nWe did not go through the entire kernel, to also make\nit possible to plug in user defined lines, rays or triangles.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"Chapter_kernel_tools.html\">Kernel Related Tools</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_5!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38739.0}