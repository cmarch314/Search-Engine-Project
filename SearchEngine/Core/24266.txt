{"text": "Domains of Concern in Software Architectures and Architecture Description Languages Nenad Medvidovic and David S Rosenblum Department of Information and Computer Science University of California Irvine Irvine California 92697 3425 U S A neno dsr ics uci edu Abstract Software architectures shift the focus of developers from lines of code to coarser grained elements and their interconnection structure Architecture description languages ADLs have been proposed as domain specific languages for the domain of software architecture There is still little consensus in the research community on what problems are most important to address in a study of software architecture what aspects of an architecture should be modeled in an ADL or even what an ADL is To shed light on these issues we provide a framework of architectural domains or areas of concern in the study of software architectures We evaluate existing ADLs with respect to the framework and study the relationship between architectural and application domains One conclusion is that while the architectural domains perspective enables one to approach architectures and ADLs in a new more structured manner further understanding of architectural domains their tie to application domains and their specific influence on ADLs is needed Keywords software architecture architecture description language domain domain specific language architectural domain Contents 1 Introduction 2 Overview of ADLs 2 1 Definitions of Architecture and Style 2 2 Definition of ADLs 2 3 Categorizing ADLs 2 4 Applications of ADLs 2 5 Architecture vs Design 3 Architectural Domains 3 1 Representation 3 2 Design Process Support 3 3 Analysis 3 3 1 Static Analysis 3 3 2 Dynamic Analysis 3 4 Evolution 3 4 1 Specification Time Evolution 3 4 2 Execution Time Evolution 3 5 Refinement 3 6 Traceability 3 7 Simulation Executability 4 ADL Support for Architectural Domains 4 1 Representation 4 2 Design Process Support 4 3 Analysis 4 3 1 Static Analysis 4 3 2 Dynamic Analysis 4 4 Evolution 4 4 1 Specification Time Evolution 4 4 2 Execution Time Evolution 4 5 Refinement 4 6 Traceability 4 7 Simulation Executability 4 8 Summary 5 Architectural vs Application Domains 6 Conclusions 7 Acknowledgements 8 References Footnotes 1 Introduction Software architecture is an aspect of software engineering directed at reducing costs of developing applications and increasing the potential for commonality among different members of a closely related product family PW92 GS93 Software development based on common architectural idioms has its focus shifted from lines of code to coarser grained architectural elements and their overall interconnection structure This enables developers to abstract away the unnecessary details and focus on the big picture system structure high level communication protocols assignment of software components and connectors to hardware components development process and so on Many researchers have realized that to obtain the benefits of an architectural focus software architecture must be provided with its own body of specification languages and analysis techniques Gar95 GPT95 Wolf96 Such languages are needed to demonstrate properties of a system upstream thus minimizing the costs of errors They are also needed to provide abstractions adequate for modeling a large system while ensuring sufficient detail for establishing properties of interest A large number of architecture description languages ADLs has been proposed each of which embodies a particular approach to the specification and evolution of an architecture Examples are Rapide LKA 95 LV95 Aesop GAO94 MetaH Ves96 UniCon SDK 95 Darwin MDEK95 MK96 Wright AG94a AG94b C2 MTW96 MORT96 Med96 and SADL MQR95 Recently initial work has been done on an architecture interchange language ACME GMW95 GMW97 which is intended to support mapping of architectural specifications from one ADL to another and hence provide a bridge for their different foci and resulting support tools There is still very much a lack of consensus in the research community on what an ADL is what aspects of an architecture should be modeled by an ADL and what should be interchanged in an interchange language This divergence has resulted in a wide variation of approaches found in this first generation of ADLs Perhaps even more significantly there is a wide difference of opinions as to what problems are most important to address in a study of software architecture In our previous research we have provided a foundation for understanding defining classifying and comparing ADLs Med97 MT97 In this paper we build upon those results by identifying and characterizing architectural domains the problems or areas of concern that need to be addressed by ADLs Understanding these domains and their properties is a key to better understanding the needs of software architectures architecture based development and architectural description and interchange A study of architectural domains is also needed to guide the development of next generation ADLs This paper presents a framework of architectural domains We demonstrate that each existing ADL currently supports only a small subset of these domains and we discuss possible reasons for that Finally we consider the relationship between architectural domains and application domains While we draw from previous ADL work and reference a number of ADLs the most significant contribution of this paper is the framework of architectural domains It provides structure to a field that has been approached largely in an ad hoc fashion thus far The framework gives the architect a sound foundation for selecting an ADL and orients discourse away from arguments about notation and more towards solving important engineering problems The remainder of the paper is organized as follows Section 2 provides a short discussion of ADLs Section 3 presents and motivates each architectural domain while Section 4 discusses the support for architectural domains in existing ADLs Section 5 expounds on the relationship between application domains and architectural domains Discussion and conclusions round out the paper 2 Overview of ADLs To properly enable further discussion several definitions are needed In this section we define software architectures architectural styles and ADLs Footnote 1 We categorize ADLs differentiate them from other similar notations and discuss examples of use of ADLs in actual projects Finally we provide a short discussion on our use of the terms architecture and design 2 1 Definitions of Architecture and Style There is no standard definition of architecture but we will use as our working definition the one provided by Garlan and Shaw GS93 Software architecture is a level of design that goes beyond the algorithms and data structures of the computation designing and specifying the overall system structure emerges as a new kind of problem Structural issues include gross organization and global control structure protocols for communication synchronization and data access assignment of functionality to design elements physical distribution composition of design elements scaling and performance and selection among design alternatives Architectural style is a set of design rules that identify the kinds of components and connectors that may be used to compose a system or subsystem together with local or global constraints on the way the composition is done SC96 2 2 Definition of ADLs Loosely defined an ADL for software applications focuses on the high level structure of the overall application rather than the implementation details of any specific source module Ves93 ADLs provide both a concrete syntax and a conceptual framework for modeling a software system s conceptual architecture The building blocks of an architectural description are components units of computation or data stores connectors architectural building blocks used to model interactions among components and rules that govern those interactions and architectural configurations connected graphs of components and connectors that describe architectural structure An ADL must provide the means for their explicit specification this criterion enables one to determine whether or not a particular notation is an ADL In order to infer any kind of information about an architecture at a minimum interfaces of constituent components must also be modeled formally Without this information an architectural description becomes but a collection of interconnected identifiers An ADL s conceptual framework typically subsumes a formal semantic theory That theory is part of the ADL s underlying framework for characterizing architectures it influences the ADL s suitability for modeling particular kinds of systems e g highly concurrent systems or particular aspects of a given system e g its static properties Examples of formal specification theories are Petri nets Pet62 Statecharts Har87 partially ordered event sets LVB 93 communicating sequential processes CSP Hoa85 model based formalisms e g CHemical Abstract Machine IW95 Z Spi89 algebraic formalisms e g Obj GW88 and axiomatic formalisms e g Anna Luc87 Finally even though the suitability of a given language for modeling architectures is independent of whether and what kinds of tool support it provides an accompanying toolset will render an ADL both more usable and useful Furthermore capabilities provided by such a toolset are often a direct reflection of the ADL s intended use 2 3 Categorizing ADLs Existing languages that are commonly referred to as ADLs can be grouped into three categories based on how they model configurations implicit configuration languages model configurations implicitly through interconnection information that is distributed across definitions of individual components and connectors in line configuration languages model configurations explicitly but specify connector information only as part of the configuration in line explicit configuration languages model both components and connectors separately from configurations The first category implicit configuration languages are by definition given in this paper not ADLs although they may serve as useful tools in modeling certain aspects of architectures An example of an implicit configuration language is ArTek TLPD95 In ArTek there is no configuration specification instead each connector specifies component ports to which it is attached The focus on conceptual architecture and explicit treatment of connectors as first class entities differentiate ADLs from module interconnection languages MILs DK76 PN86 programming languages and object oriented notations and languages e g Unified Method BR95 MILs typically describe the uses relationships among modules in an implemented system and support only one type of connection AG94a SG94 Programming languages describe a system s implementation whose architecture is typically implicit in subprogram definitions and calls Explicit treatment of connectors also distinguishes ADLs from OO languages as demonstrated in LVM95 It is important to note however that there is less than a firm boundary between ADLs and MILs Certain ADLs e g Wright and Rapide model components and connectors at a high level of abstraction and do not assume or prescribe a particular relationship between an architectural description and an implementation We refer to these languages as being implementation independent On the other hand several ADLs e g UniCon and MetaH enforce a high degree of fidelity of an implementation to its architecture Components modeled in these languages are directly related to their implementations so that a module interconnection specification may be indistinguishable from an architectural description in such a language These are implementation constraining languages 2 4 Applications of ADLs ADLs are special purpose notations whose very specific foci render them suitable for powerful analyses simulation and automated code generation However they have yet to find their place in mainstream software development Although current research is under way to bridge the gap that separates ADLs from more widely used design notations RMRR97 only a small number of existing ADLs have been applied to large scale real world examples to date What these examples do demonstrate is the potential for effective use of ADLs in software projects Wright was used to model and analyze the Runtime Infrastructure RTI of the Department of Defense DoD High Level Architecture for Simulations HLA All96 The original specification for RTI was over 1 pages long Wright was able to substantially condense the specification and reveal several inconsistencies and weaknesses in it SADL was applied to an operational power control system used by the Tokyo Electric Power Company The system was implemented in 2 lines of Fortran 77 code SADL was used to formalize the system s reference architecture and ensure its consistency with the implementation architecture Finally Rapide has been used in several large scale projects thus far A representative example is the X Open Distributed Transaction Processing DTP Industry Standard The documentation for the standard is over 4 pages long Its reference architecture and subsequent extensions have been successfully specified and simulated in Rapide LKA 95 2 5 Architecture vs Design Given the above definition of software architectures and ADLs an issue worth addressing is the relationship between architecture and design Current literature leaves this question largely unanswered allowing for several interpretations architecture and design are the same architecture is at a level of abstraction above design so it is simply another step artifact in a software development process and architecture is something new and is somehow different from design but just how remains unspecified All three interpretations are partially correct To a large extent architectures serve the same purpose as design However their explicit focus on connectors and configurations distinguishes them from traditional software design At the same time as a high level architecture is refined connectors lose prominence by becoming distributed across the lower level architecture s elements Such a lower level architecture may indeed be considered to be a design Keeping this relationship in mind for reasons of simplicity we will simply refer to architectures as high level low level and so forth in the remainder of the paper while design will only refer to the process that results in an architecture 3 Architectural Domains ADLs typically share syntactic constructs that enable them to model components and component interfaces connectors and configurations Footnote 2 A much greater source of divergence are the different ADLs conceptual frameworks and consequently their support for modeling architectural semantics ADL developers typically have decided to focus on a specific aspect of architectures or an architectural domain which guides their selection of an underlying semantic model and a set of related formal specification notations These formal notations in turn restrict the types of problems for which the ADL is suitable This relationship between an architectural domain and candidate formal notations is rarely straightforward or fully understood In the absence of objective criteria ADL researchers are forced to base their decisions on intuition experience and biases arising from past research accomplishments Unfortunately intuition can often be misleading and experience insufficient in a young discipline such as software architectures In this paper we attempt to fill this void The remainder of this section motivates and formulates a framework for classifying the problems on which architectural models focus architectural domains shown in Figure 1 Architectural domains represent broad classes of problems and are likely to be reflected in many ADLs and their associated formal specification language constructs Their proper understanding is thus necessary Furthermore heuristics may be developed over time that will enable easier interchange of architectures modeled in ADLs that focus on particular architectural domains Finally such a framework can be used as a guide in developing future ADLs Figure 1 Architectural domains 3 1 Representation A key role of an explicit representation of an architecture is to aid understanding and communication about a software system among different stakeholders For this reason it is important that architectural descriptions be simple understandable and possibly graphical with well understood but not necessarily formally defined semantics Architectural models typically comprise multiple views e g high level graphical view lower level view with formal specifications of components and connectors conceptual architecture one or more implementation architectures corresponding development process data or control flow view and so on Different stakeholders e g architects developers managers customers may require different views of the architecture The customers may be satisfied with a high level boxes and arrows description the developers may want detailed component and connector models while the managers may require a view of the development process 3 2 Design Process Support Software architects decompose large distributed heterogeneous systems into smaller building blocks In doing so they have to consider many issues make many decisions and utilize many design techniques methodologies and tools Modeling architectures from multiple perspectives discussed in the previous subsection is only one way of supporting software architects cognitive processes Others include delivering design guidance in a timely and understandable fashion capturing design rationale and revisiting past design steps 3 3 Analysis Architectures are often intended to model large distributed concurrent systems The ability to evaluate the properties of such systems upstream at the architectural level can substantially lessen the number of errors passed downstream Given that unnecessary details are abstracted away in architectures the analysis task may also be easier to perform than at source code level Analysis of architectures may be performed statically before execution or dynamically at runtime Certain types of analysis can be performed both statically and dynamically 3 3 1 Static Analysis Examples of static analysis are internal consistency checks such as whether appropriate components are connected and their interfaces match whether connectors enable desired communication whether constraints are satisfied and whether the combined semantics of components and connectors result in desired system behavior Certain concurrent and distributed aspects of an architecture can also be assessed statically such as the potential for deadlocks and starvation performance reliability security and so on Finally architectures can be statically analyzed for adherence to design heuristics and style rules 3 3 2 Dynamic Analysis Examples of dynamic analysis are testing debugging assertion checking and assessment of the performance reliability and schedulability of an executing architecture Saying that an architecture is executing can mean two different things the system built based on the architecture is executing or the runtime behavior of the architecture itself is being simulated Clearly certain analyses such as performance or reliability are more meaningful or even only possible in the former case However an implementation of the system may not yet exist Furthermore it may be substantially less expensive to perform dynamic analyses in the latter case particularly when the relationship between the architecture and the implemented system is well understood 3 4 Evolution Support for software evolution is a key aspect of architecture based development Architectures evolve to reflect evolution of a single software system they also evolve into families of related systems As design elements individual components and connectors within an architecture may also evolve Evolution of components connectors and architectures can occur at specification time or execution time 3 4 1 Specification Time Evolution If we consider components and connectors to be types which are instantiated every time they are used in an architecture their evolution can be viewed simply in terms of subtyping Since components and connectors are modeled at a high level of abstraction flexible subtyping methods may be employed For example it may be useful to evolve a single component in multiple ways by using different subtyping mechanisms e g interface behavior or a combination of the two MORT96 At the level of architectures evolution is focused on incremental development and support for system families Incrementality of an architecture can further be viewed from two different perspectives One is its ability to accommodate addition of new components and the resulting issues of scale the other is specification of incomplete architectures 3 4 2 Execution Time Evolution Explicit modeling of architectures is intended to support development and evolution of large and potentially long running systems Being able to evolve such systems during execution may thus be desirable and in some cases necessary Architectures exhibit dynamism by allowing replication insertion removal and reconnection of architectural elements or subarchitectures during execution Dynamic changes of an architecture may be either planned at architecture specification time or unplanned Both types of dynamic change must be constrained to ensure that no desired architectural properties are violated 3 5 Refinement The most common argument for creating and using formal architectural models is that they are necessary to bridge the gap between informal boxes and arrows diagrams and programming languages which are deemed too low level for designing a system Architectural models may need to be specified at several levels of abstraction for different purposes For example a high level specification of the architecture can be used as an understanding and communication tool a subsequent lower level may be analyzed for consistency of interconnections an even lower level may be used in a simulation Therefore correct and consistent refinement of architectures to subsequently lower levels of abstraction is imperative Note that in this sense code generation is simply a special case of architectural refinement 3 6 Traceability As discussed above a software architecture often consists of multiple views and may be modeled at multiple levels of abstraction Figure 2 We call a particular view of the architecture at a given level of abstraction i e a single point in the two dimensional space of Figure 2 an architectural cross section It is critical for changes in one cross section to be correctly reflected in others A particular architectural cross section can be considered dominant so that all changes to the architecture are made to it and then reflected in others However changes will more frequently be made to the most appropriate or convenient cross section Traceability support will hence need to exist across all pertinent cross sections One final issue is the consistency of an architecture with system requirements Changes to the requirements must be appropriately reflected in the architecture changes to the architecture must be validated against the requirements Therefore even though system requirements are in the problem domain while architecture is in the solution domain traceability between the two is crucial For purposes of traceability requirements can be considered to be at a very high level of architectural abstraction as shown in Figure 2 Figure 2 Two dimensional space of architectural views and levels of abstraction The vertical axis is a set of discrete values with a nominal ordering The horizontal axis is a continuum with an ordinal ordering of values where system requirements are considered to be the highest level of abstraction and source code the lowest One possible dominant cross section graphical view of the high level architecture is shown 3 7 Simulation Executability Static architectural models are useful for establishing static properties of the modeled system Certain dynamic properties may also be predicted with static models but only if specific assumptions hold For example if the architect can correctly predict execution time and criticality of each component then schedulability of the encompassing architecture can be evaluated On the other hand other dynamic properties such as reliability may by definition require a running system Also developers may want to produce an early prototype to e g attempt allocation of architectural elements to components of the physical system Other stakeholders e g customers or managers may want to verify early on that the architecture conforms to their wishes Simulating the dynamic behavior of a high level architecture may thus be preferred to implementing the system it is a quicker cheaper and more flexible way of arriving at the desired information A special case of architectural simulation is the execution of the complete implemented system The ultimate goal of any software design and modeling endeavor is to produce such a system An elegant and effective architectural model is of limited value unless it can be converted into a running application A simulation can only partially depict the final system s dynamic behavior Manually transforming an architecture into a running system may result in many already discussed problems of consistency and traceability between the architecture and its implementation Techniques such as refinement and traceability discussed above must be employed to properly accomplish this task 4 ADL Support for Architectural Domains In the previous section we motivated and described different architectural domains in terms of their characteristics and needs of software architectures Another way of viewing architectural domains is in terms of modeling languages and specific language features needed to support different domains At the same time a useful way of understanding and classifying architecture modeling languages is in terms of architectural domains they are intended to support For these reasons this section studies the kinds of language facilities that are needed to support each architectural domain as well as the specific features existing ADLs employ to that end Our hope is that this discussion will shed light on the relationships among different architectural domains and their resulting ADL features and point out both where they can be effectively combined and where we can expect difficulties 4 1 Representation Ideally an ADL should make the structure of a system clear from a configuration specification alone i e without having to study component and connector specifications Architecture descriptions in in line configuration ADLs such as Darwin MetaH and Rapide tend to be encumbered with connector details while explicit configuration ADLs such as ACME Aesop C2 SADL UniCon and Wright have the best potential to facilitate understandability of architectural structure One common way of facilitating understandability and communication is by providing a graphical notation in addition to the textual notation However this is only the case if there is a precise relationship between a graphical description and the underlying semantic model For example Aesop C2 Darwin MetaH Rapide and UniCon support such semantically sound graphical notations while ACME SADL and Wright do not ADLs must also be able to model the architecture from multiple perspectives As discussed above several ADLs support at least two views of an architecture textual and graphical Each of these ADLs also allows both top level and detailed views of composite elements Aesop MetaH and UniCon further distinguish different types of components and connectors iconically Support for other views is sparse C2 provides a view of the development process that corresponds to the architecture RR96 Darwin s Software Architect s Assistant NKM96 provides a hierarchical view of the architecture which shows all the component types and the include relationships among them in a tree structure Rapide allows visualization of an architecture s execution behavior by building its simulation and animating its execution Rapide also provides a tool for viewing and filtering events generated by the simulation 4 2 Design Process Support As the above examples of C2 s Darwin s and Rapide s support tools indicate language features can only go so far in supporting software architects Adequate tools are also needed A category of tools that is critical for adequately supporting the design process are active specification tools they can significantly reduce the cognitive load on architects Only a handful of existing ADLs provide tools that actively support specification of architectures In general such tools can be proactive or reactive UniCon s graphical editor is proactive It invokes UniCon s language processing facilities to prevent errors during design Reactive specification tools detect existing errors They may either only inform the architect of the error non intrusive or also force the architect to correct it before moving on intrusive An example of the former is C2 s design environment Argo while MetaH s graphical editor is an example of the latter 4 3 Analysis The types of analyses for which an ADL is well suited depend on its underlying semantic model and to a lesser extent its specification features The semantic model will largely influence whether the ADL can be analyzed statically or dynamically or both For example Wright which is based on communicating sequential processes CSP Hoa85 allows static deadlock analysis of individual connectors and components attached to them On the other hand Rapide architectures which are modeled with partially ordered event sets posets LVB 93 can be analyzed dynamically 4 3 1 Static Analysis The most common type of static analysis tools are language parsers and compilers Parsers analyze architectures for syntactic correctness while compilers establish semantic correctness All existing ADLs have parsers Darwin MetaH Rapide and UniCon also have compilers which enable these languages to generate executable systems from architectural descriptions Wright does not have a compiler but it uses FDR For92 a model checker to establish type conformance There are numerous other possible types of static analysis of architectures Several examples are provided by current ADLs Aesop provides facilities for checking for type consistency cycles resource conflicts and scheduling feasibility in its architectures C2 uses critics to establish adherence to style rules and design guidelines MetaH and UniCon both currently support schedulability analysis by specifying non functional properties such as criticality and priority Finally given two architectures SADL can establish their relative correctness with respect to a refinement map 4 3 2 Dynamic Analysis The ability to analyze an architecture dynamically directly depends on the ADL s ability to model its dynamic behavior To this end ADLs can employ specification mechanisms such as event posets CHAM or temporal logic which can express dynamic properties of a system Another aspect of dynamic analysis is enforcement of constraints at runtime Most existing ADLs tend to view architectures statically so that current support for dynamic modeling and analysis is scarce Darwin enables dynamic analysis of architectures by instantiating parameters and components to enact what if scenarios Similarly Rapide Poset Browser s event filtering features and Animation Tools facilitate analysis of architectures through simulation Rapide s Constraint Checker also analyzes the conformance of a Rapide simulation to the formal constraints defined in the architecture Finally runtime systems of those ADLs that provide architecture compilation support can be viewed as dynamic analysis facilities 4 4 Evolution An architecture can evolve in two different dimensions evolution of individual components and connectors where the structure of the architecture is not affected although its behavior may be and evolution of the entire architecture which affects both the structure and behavior of an architecture Evolution in these two dimensions can occur both at architecture specification time and while the architecture is executing Footnote 3 4 4 1 Specification Time Evolution ADLs can support specification time evolution of individual components and connectors with subtyping Only a subset of existing ADLs provide such facilities and even their evolution support is limited and often relies on the chosen implementation programming language The remainder of the ADLs view and model components and connectors as inherently static Aesop supports behavior preserving subtyping of components and connectors to create substyles of a given architectural style Rapide allows its interface types to inherit from other types by using OO methods resulting in structural subtyping ACME also supports structural subtyping via its extends feature C2 provides a more sophisticated subtyping and type checking mechanism Multiple subtyping relationships among components are allowed name interface behavior and implementation subtyping as well as their combinations MORT96 Specification time evolution of complete architectures has two facets support for incremental development and support for system families Incrementality of an architecture can be viewed from two different perspectives One is its ability to accommodate addition of new components to the architecture In general explicit configuration ADLs can support incremental development more easily and effectively than in line configuration ADLs ADLs that allow variable numbers of components to communicate through a connector are well suited for incremental development particularly when faced with unplanned architectural changes Med97 Another view of incrementality is an ADL s support for incomplete architectural descriptions Incomplete architectures are common during design as some decisions are deferred and others have not yet become relevant However most existing ADLs and their supporting toolsets have been built to prevent precisely these kinds of situations For example Darwin MetaH Rapide and UniCon compilers constraint checkers and runtime systems have been constructed to raise exceptions if such situations arise In this case an ADL such as Wright which focuses its analyses on information local to a single connector is better suited to accommodate expansion of the architecture than e g SADL which is very rigorous in its refinement of entire architectures Still another aspect of static evolution is support for application families In MT96 we showed that the number of possible architectures in a component based style grows exponentially as a result of a linear expansion of a collection of components All such architectures may not belong to the same logical family Therefore relying on component and connector inheritance subtyping or other evolution mechanisms is insufficient An obvious solution currently adopted only by ACME is to provide a language construct that allows the architect to specify the family to which the given architecture belongs 4 4 2 Execution Time Evolution There are presently two approaches to supporting evolution of architectures at execution time The first is what Oreizy calls constrained dynamism all runtime changes to the architecture must be known a priori and are specified as part of the architectural model Ore96 Two existing ADLs support constrained dynamism Rapide supports conditional configuration its where clause enables a form of architectural rewiring at runtime using the link and unlink operators Darwin allows runtime replication of components using the dyn operator The second approach to execution time evolution places no restrictions at architecture specification time on the kinds of allowed changes Instead the ADL has an architecture modification feature which allows the architect to specify changes while the architecture is running Darwin and C2 are the only ADLs that support such pure dynamism Ore96 Darwin allows deletion and rebinding of components by interpreting Darwin scripts C2 specifies a set of operations for insertion removal and rewiring of elements in an architecture at runtime Med96 C2 s ArchShell tool enables arbitrary interactive construction execution and runtime modification of C2 style architectures by dynamically loading and linking new architectural elements Ore96 MOT97 An issue that needs further exploration is constraining pure dynamic evolution to ensure that the desired properties of architectures are maintained 4 5 Refinement ADLs provide architects with expressive and semantically elaborate facilities for specification of architectures However an ADL must also enable correct and consistent refinement of architectures to subsequently lower levels of abstraction and eventually to executable systems An obvious way in which ADLs can support refinement is by providing patterns or maps that when applied to an architecture result in a related architecture at a lower level of abstraction SADL and Rapide are the only two ADLs that provide such support SADL uses maps to enable correct architecture refinements across styles while Rapide generates comparative simulations of architectures at different abstraction levels Both approaches have certain drawbacks indicating that a hybrid approach may be useful Garlan has recently argued that refinement should not be consistent with respect to a single immutable law but rather with respect to particular properties of interest be they conservative extension SADL computational behavior Rapide or something entirely different such as performance Gar96 This may be a good starting point towards a successful marriage of the two approaches Several ADLs take a different approach to refinement they enable generation of executable systems directly from architectural specifications These are typically the implementation constraining languages such as MetaH and UniCon These ADLs assume the existence of a source file that corresponds to a given architectural element This approach makes the assumption that the relationship between elements of an architectural description and those of the resulting system will be 1 to 1 Given that architectures are intended to describe systems at a higher level of abstraction than source code modules this can be considered only a limited form of refinement 4 6 Traceability While the problem of refinement essentially focuses only on one axis of Figure 2 the horizontal axis and one direction left to right traceability may need to cover a large portion of the two dimensional space and is applicable in both directions This presents a much more difficult task indicating why this is the architectural domain in which existing ADLs are most lacking The relationships among architectural views vertical axis are not always well understood For example ADLs commonly provide support for tracing changes between textual and graphical views such that changes in one view are automatically reflected in the other however it may be less clear how the data flow view should affect the process view In other cases changes in one view e g process should never affect another e g control flow An even bigger hurdle is providing traceability support across both architectural views and levels of abstraction simultaneously Finally although much research has been directed at methodologies for making the transition from requirements to design e g OO this process is still an art form Further research is especially needed to understand the effects of changing requirements on architectures and vice versa Traceability is particularly a problem in the way implementation constraining languages approach code generation discussed in the previous subsection These ADLs provide no means of guaranteeing that the source modules which are supposed to implement architectural components will do so correctly Furthermore even if the specified modules currently implement the needed behavior correctly there is no guarantee that any future changes to those modules will be traced back to the architecture and vice versa 4 7 Simulation Executability As with dynamic analysis Section 4 3 2 simulating an architecture will directly depend upon the ADL s ability to model its dynamic behavior Currently Rapide is the only ADL that can simulate the architecture itself by generating event posets Other ADLs enable generation of running systems corresponding to the architecture MetaH and UniCon require preexisting component implementations in Ada and C respectively in order to generate applications Darwin can also construct executable systems in the same manner in C and Rapide in C C Ada VHDL or its executable sublanguage C2 and Aesop provide class hierarchies for their concepts and operations such as components connectors and interconnection and message passing protocols These hierarchies form a basis from which an implementation of an architecture may be produced Aesop s hierarchy has been implemented in C and C2 s in C Java and Ada 4 8 Summary Existing ADLs span a broad spectrum in terms of the architectural domains they support On the one hand languages like SADL and Wright have very specific narrow foci On the other C2 Rapide and Darwin support a number of architectural domains Certain domains e g evolution refinement and traceability are only sparsely supported indicating areas around which future work should be centered A more complete summary of this section is given in Table 1 below Table 1 ADL Support for Architectural Domains ARCH DOMAIN ADL Represent Design Process Support Static Analysis Dynamic Analysis Spec Time Evolution Exec Time Evolution Refinement Trace Simulation Executability ACME explicit config weblets noneparsernoneapplication familiesnonerep maps across levels textual graphical none Aesop explicit config graphical notation types distinguished iconicallysyntax directed editor specialized editors for visualization classesparser style specific compiler type cycle resource conflict and scheduling feasibility checkernonebehavior preserving subtyping of components and connectorsnonenone textual graphical build tool constructs system glue code in C for pipe and filter style C2 explicit config graphical notation process view simulation event filteringnon intrusive reactive design critics and to do lists in Argoparser critics to establish adherence to style rules and design heuristicsevent filteringmultiple subtyping mechanisms allows partial architecturespure dynamism element insertion removal and rewiringnone textual graphical class framework enables generation of C C Ada and Java code Darwin implicit config graphical notation hierarchical system viewautomated addition of ports propagation of changes across bound ports property dialogsparser compiler what if scenarios by instantiating parameters and dynamic componentsnoneconstrained dynamism runtime replication of components and conditional configurationnone textual graphical compiler generates C code MetaH implicit config graphical notation types distinguished iconicallyintrusive reactive graphical editorparser compiler schedulability reliability and security analysisnonenonenonenone textual graphical compiler generates Ada code C code generation planned Rapide implicit config graphical notation animated simulation event filteringnoneparser compiler constraint checker to ensure valid mappingsevent filtering and animationinheritance structural subtyping constrained dynamism conditional configuration and dynamic event generationrefinement maps enable comparative simulations of architectures at different levels textual graphical constraint checking across refinement levelssimulation by generating event posets system construction in C C Ada VHDL and Rapide SADL explicit config noneparser relative correctness of architectures w r t a refinement mapnonecomponent and connector refinement via pattern mapsnonemaps enable correct refinements across levelsrefinement across levelsnone UniCon explicit config graphical notationproactive GUI editor invokes language checkerparser compiler schedulability analysisnonenonenonenone textual graphical compiler generates C code Wright explicit config noneparser model checker for type conformance deadlock analysis of connectorsnonetype conformance for behaviorally related protocolsnonenonenonenone 5 Architectural vs Application Domains Over the past decade there has been interest in relating architectures which are in the solution domain to the problem or application domain leading to the notion of domain specific software architectures DSSAs Tra95 A DSSA provides a single generic reference architecture which reflects the characteristics of a particular problem domain and which is instantiated for each specific application in that domain Architectural styles discussed in Section 2 provide another way of relating the problem and solution spaces Styles are largely orthogonal to DSSAs a single style may be applicable to multiple application domains on the other hand a single DSSA may use multiple styles Any attempt to further explore and perhaps generalize the relationship between architectural and application domains would be greatly aided by a classification of application domains We are unaware of any such classification although Jackson identified a number of domain characteristics that could serve as a starting point for one Jac95 static vs dynamic domains with the latter being application domains having an element of time events and or state one dimensional vs multi dimensional domains tangible vs intangible domains with the latter typically involving machine representations of abstractions such as user interfaces inert vs reactive vs active dynamic domains and autonomous vs programmable vs biddable active dynamic domains Given these application domain characteristics one can easily identify a number of useful relationships with architectural domains For instance support for evolution executability and dynamic analysis are more important for dynamic domains than for static domains As another example reactive domains are naturally supported by a style of representation e g Statecharts Har87 that is different from that in active domains e g CHAM IW95 As we deepen our understanding of architectural domains we will be able to solidify our understanding of their relationship with application domains 6 Conclusions Software architecture research has been moving forward rapidly A number of ADLs and their supporting toolsets have been developed many existing styles have been adopted and new ones invented Theoretical underpinnings for the study of software architectures have also begun to emerge in the form of definitions PW92 GS93 and formal classifications of styles SC96 and ADLs Med97 MT97 This body of work reflects a wide spectrum of views on what architecture is what aspects of it should be modeled and how and what its relationship is to other software development concepts and artifacts This divergence of views has also resulted in a divergence of ADLs conceptual frameworks as defined in Section 2 Such fragmentation has made it difficult to establish whether there exists in ADLs a notion similar to computational equivalence in programming languages Furthermore sharing support tools has been difficult ACME has attempted to provide a basis for interchanging architectural descriptions across ADLs However ACME has thus far been much more successful at achieving architectural interchange at the syntactic i e structural level than at the semantic level Although some of the ACME team s recent work looks encouraging this still remains an open problem One of the reasons ACME has encountered difficulties is precisely the fact that there is only limited agreement in the architecture community on some fundamental issues the most critical of which is what problems architectures should attempt to solve This paper presents an important first step towards a solution to this problem We have recognized that the field of software architecture is concerned with several domains and that every ADL reflects the properties of one or more domains from this set Architectural domains thus provide a unifying view to what had seemed like a disparate collection of approaches notations techniques and tools The task of architectural interchange can be greatly aided by studying the interrelationships among architectural domains Existing ADLs can be better understood in this new light and new ADLs more easily developed to solve a specific set of problems Much further work is still needed however Our current understanding of the relationship between architectural domains and formal semantic theories Section 2 is limited Also we need to examine whether there exist techniques that can more effectively support the needs of particular architectural domains than those provided by existing ADLs Finally a more thorough understanding of the relationship between architectural and application domains is crucial if architecture based development is to fulfill its potential 7 Acknowledgements We would like to thank Richard Taylor Peyman Oreizy Jason Robbins David Redmiles and David Hilbert for their participation in numerous discussions of issues concerning ADLs We also thank the DSL reviewers for their helpful reviews Effort partially sponsored by the Defense Advanced Research Projects Agency and Rome Laboratory Air Force Materiel Command USAF under agreement numbers F3 6 2 94 C 218 and F3 6 2 97 2 21 The U S Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon Approved for Public Release Distribution Unlimited The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements either expressed or implied of the Defense Advanced Research Projects Agency Rome Laboratory or the U S Government This material is also partially based on work supported by the National Science Foundation under Grant No CCR 97 1973 8 References AG94a R Allen and D Garlan Formal Connectors Technical Report CMU CS 94 115 Carnegie Mellon University March 1994 AG94b R Allen and D Garlan Formalizing Architectural Connection In Proceedings of the Sixteenth International Conference on Software Engineering pages 71 8 Sorrento Italy May 1994 All96 R Allen HLA A Standards Effort as Architectural Style In A L Wolf ed Proceedings of the Second International Software Architecture Workshop ISAW 2 pages 13 133 San Francisco CA October 1996 BR95 G Booch and J Rumbaugh Unified Method for Object Oriented Development Rational Software Corporation 1995 DK76 F DeRemer and H H Kron Programming in the large versus Programming in the small IEEE Transactions on Software Engineering pages 8 86 June 1976 For92 Failures Divergence Refinement User Manual and Tutorial Formal Systems Europe Ltd Oxford England October 1992 GAO94 D Garlan R Allen and J Ockerbloom Exploiting Style in Architectural Design Environments In Proceedings of SIGSOFT 94 Foundations of Software Engineering pages 175 188 New Orleans Louisiana USA December 1994 Gar95 D Garlan editor Proceedings of the First International Workshop on Architectures for Software Systems Seattle WA April 1995 Gar96 D Garlan Style Based Refinement for Software Architecture In A L Wolf ed Proceedings of the Second International Software Architecture Workshop ISAW 2 pages 72 75 San Francisco CA October 1996 GMW95 D Garlan R Monroe and D Wile ACME An Architectural Interconnection Language Technical Report CMU CS 95 219 Carnegie Mellon University November 1995 GMW97 D Garlan R Monroe and D Wile ACME An Architecture Interchange Language Submitted for publication January 1997 GPT95 D Garlan F N Paulisch and W F Tichy editors Summary of the Dagstuhl Workshop on Software Architecture February 1995 Reprinted in ACM Software Engineering Notes pages 63 83 July 1995 GS93 D Garlan and M Shaw An Introduction to Software Architecture Advances in Software Engineering and Knowledge Engineering volume I World Scientific Publishing 1993 GW88 J A Goguen and T Winkler Introducing OBJ3 Technical Report SRI CSL 88 99 SRI International 1988 Har87 D Harel Statecharts A Visual Formalism for Complex Systems Science of Computer Programming 1987 Hoa85 C A R Hoare Communicating Sequential Processes Prentice Hall 1985 IW95 P Inverardi and A L Wolf Formal Specification and Analysis of Software Architectures Using the Chemical Abstract Machine Model IEEE Transactions on Software Engineering pages 373 386 April 1995 Jac95 M Jackson Software Requirements and Specifications A Lexicon of Practice Principles and Prejudices Addison Wesley 1995 LKA 95 D C Luckham J J Kenney L M Augustin J Vera D Bryan and W Mann Specification and Analysis of System Architecture Using Rapide IEEE Transactions on Software Engineering pages 336 355 April 1995 Luc87 D Luckham ANNA a language for annotating Ada programs reference manual volume 26 of Lecture Notes in Computer Science Springer Verlag Berlin 1987 LV95 D C Luckham and J Vera An Event Based Architecture Definition Language IEEE Transactions on Software Engineering pages 717 734 September 1995 LVB 93 D C Luckham J Vera D Bryan L Augustin and F Belz Partial Orderings of Event Sets and Their Application to Prototyping Concurrent Timed Systems Journal of Systems and Software pages 253 265 June 1993 LVM95 D C Luckham J Vera and S Meldal Three Concepts of System Architecture Unpublished Manuscript July 1995 Med96 N Medvidovic ADLs and Dynamic Architecture Changes In A L Wolf ed Proceedings of the Second International Software Architecture Workshop ISAW 2 pages 24 27 San Francisco CA October 1996 Med97 N Medvidovic A Classification and Comparison Framework for Software Architecture Description Languages Technical Report UCI ICS 97 2 University of California Irvine January 1997 MDEK95 J Magee N Dulay S Eisenbach and J Kramer Specifying Distributed Software Architectures In Proceedings of the Fifth European Software Engineering Conference ESEC 95 Barcelona September 1995 MK96 J Magee and J Kramer Dynamic Structure in Software Architectures In Proceedings of ACM SIGSOFT 96 Fourth Symposium on the Foundations of Software Engineering FSE4 pages 3 14 San Francisco CA October 1996 MOT97 N Medvidovic P Oreizy and R N Taylor Reuse of Off the Shelf Components in C2 Style Architectures In Proceedings of the 1997 Symposium on Software Reusability SSR 97 pages 19 198 Boston MA May 17 19 1997 Also in Proceedings of the 1997 International Conference on Software Engineering ICSE 97 pages 692 7 Boston MA May 17 23 1997 MORT96 N Medvidovic P Oreizy J E Robbins and R N Taylor Using object oriented typing to support architectural design in the C2 style In Proceedings of ACM SIGSOFT 96 Fourth Symposium on the Foundations of Software Engineering FSE4 pages 24 32 San Francisco CA October 1996 MQR95 M Moriconi X Qian and R A Riemenschneider Correct Architecture Refinement IEEE Transactions on Software Engineering pages 356 372 April 1995 MT96 N Medvidovic and R N Taylor Reusing Off the Shelf Components to Develop a Family of Applications in the C2 Architectural Style In Proceedings of the International Workshop on Development and Evolution of Software Architectures for Product Families Las Navas del Marqu s vila Spain November 1996 MT97 N Medvidovic and R N Taylor A Framework for Classifying and Comparing Architecture Description Languages To appear in Proceedings of the Sixth European Software Engineering Conference together with Fifth ACM SIGSOFT Symposium on the Foundations of Software Engineering Zurich Switzerland September 22 25 1997 MTW96 N Medvidovic R N Taylor and E J Whitehead Jr Formal Modeling of Software Architectures at Multiple Levels of Abstraction In Proceedings of the California Software Symposium 1996 pages 28 4 Los Angeles CA April 1996 NKM96 K Ng J Kramer and J Magee A CASE Tool for Software Architecture Design Journal of Automated Software Engineering JASE Special Issue on CASE 95 1996 Ore96 P Oreizy Issues in the Runtime Modification of Software Architectures Technical Report UCI ICS 96 35 University of California Irvine August 1996 Pet62 C A Petri Kommunikationen Mit Automaten PhD Thesis University of Bonn 1962 English translation Technical Report RADC TR 65 377 Vol 1 Suppl 1 Applied Data Research Princeton N J PN86 R Prieto Diaz and J M Neighbors Module Interconnection Languages Journal of Systems and Software pages 3 7 334 October 1989 PW92 D E Perry and A L Wolf Foundations for the Study of Software Architectures ACM SIGSOFT Software Engineering Notes pages 4 52 October 1992 RMRR97 J E Robbins N Medvidovic D F Redmiles and D S Rosenblum Integrating Architecture Description Languages with a Standard Design Method Technical Report UCI ICS 97 35 University of California Irvine August 1997 RR96 J E Robbins and D Redmiles Software architecture design from the perspective of human cognitive needs In Proceedings of the California Software Symposium CSS 96 Los Angeles CA USA April 1996 SC96 M Shaw and P Clements Toward Boxology Preliminary Classification of Architectural Styles In A L Wolf ed Proceedings of the Second International Software Architecture Workshop ISAW 2 pages 5 54 San Francisco CA October 1996 SDK 95 M Shaw R DeLine D V Klein T L Ross D M Young and G Zelesnik Abstractions for Software Architecture and Tools to Support Them IEEE Transactions on Software Engineering pages 314 335 April 1995 SG94 M Shaw and D Garlan Characteristics of Higher Level Languages for Software Architecture Technical Report CMU CS 94 21 Carnegie Mellon University December 1994 Spi89 J M Spivey The Z notation a reference manual Prentice Hall New York 1989 TLPD95 A Terry R London G Papanagopoulos and M Devito The ARDEC Teknowledge Architecture Description Language ArTek Version 4 Technical Report Teknowledge Federal Systems Inc and U S Army Armament Research Development and Engineering Center July 1995 Tra95 W Tracz DSSA Domain Specific Software Architecture Pedagogical Example ACM SIGSOFT Software Engineering Notes July 1995 Ves93 S Vestal A Cursory Overview and Comparison of Four Architecture Description Languages Technical Report Honeywell Technology Center February 1993 Ves96 S Vestal MetaH Programmer s Manual Version 1 9 Technical Report Honeywell Technology Center April 1996 Wolf96 A L Wolf editor Proceedings of the Second International Software Architecture Workshop ISAW 2 San Francisco CA October 1996 Footnotes Footnote 1 This section is condensed from a detailed exposition on ADLs given in Med97 and MT97 where we provided a definition of ADLs and devised a classification and comparison framework for them Footnote 2 One can think of these syntactic features as equivalent to a boxes and arrows graphical notation with little or no underlying semantics Footnote 3 Saying that an architecture is executing can mean either that the architecture is being simulated or that the executable system built based on that architecture is running ", "_id": "http://www.ics.uci.edu/~neno/dsl/dsl97.html", "title": "domains of concern in software architectures", "html": "<HTML>\n<HEAD>\n   <META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n   <META NAME=\"Generator\" CONTENT=\"Microsoft Word 97\">\n   <META NAME=\"GENERATOR\" CONTENT=\"Mozilla/4.01 [en] (Win95; U) [Netscape]\">\n   <TITLE>Domains of Concern in Software Architectures</TITLE>\n</HEAD>\n<BODY>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=+1>Domains of Concern in Software\nArchitectures</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=+1>and Architecture Description\nLanguages</FONT></FONT></B></CENTER>\n<P>\n<CENTER><FONT FACE=\"Variable Width\">\n<a href=\"http://www.ics.uci.edu/~neno/\">Nenad Medvidovic</a> and \n<a href=\"http://www.ics.uci.edu/~dsr/\">David S. Rosenblum</a></FONT></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">\n<a href=\"http://www.ics.uci.edu/index.html\">Department of Information and Computer Science</a></FONT></I></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">\n<a href=\"http://www.uci.edu/\">University of California, Irvine</a></FONT></I></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">Irvine, California 92697-3425, U.S.A.</FONT></I></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">{neno,dsr}@ics.uci.edu</FONT></I></CENTER>\n\n\n<P><B><FONT FACE=\"Variable Width\">Abstract</FONT></B>\n\n<P><I><FONT FACE=\"Variable Width\">Software architectures shift the focus of developers\nfrom lines-of-code to coarser-grained elements and their interconnection\nstructure. Architecture description languages (ADLs) have been proposed\nas domain-specific languages for the domain of software architecture. There\nis still little consensus in the research community on what problems are\nmost important to address in a study of software architecture, what aspects\nof an architecture should be modeled in an ADL, or even what an ADL is.\nTo shed light on these issues, we provide a framework of </FONT>architectural\ndomains, or areas of concern in the study of software architectures. We\nevaluate existing ADLs with respect to the framework and study the relationship\nbetween architectural and application domains. One conclusion is that,\nwhile the architectural domains perspective enables one to approach architectures\nand ADLs in a new, more structured manner, further understanding of architectural\ndomains, their tie to application domains, and their specific influence\non ADLs is needed.</I>\n\n<P><B>Keywords -</B><I> software architecture, architecture description\nlanguage, domain, domain-specific language, architectural domain</I>\n\n<P>\n<HR>\n<P>\n<B>Contents<BR>\n<UL>\n<LI><a href=\"#1\">1. Introduction</a>\n<LI><a href=\"#2\">2. Overview of ADLs</a>\n  <UL> \n  <LI><a href=\"#2.1\">2.1. Definitions of Architecture and Style</a>\n  <LI><a href=\"#2.2\">2.2. Definition of ADLs</a>\n  <LI><a href=\"#2.3\">2.3. Categorizing ADLs</a>\n  <LI><a href=\"#2.4\">2.4. Applications of ADLs</a>\n  <LI><a href=\"#2.5\">2.5. Architecture vs. Design</a>\n  </UL>\n<LI><a href=\"#3\">3. Architectural Domains</a>\n  <UL>\n  <LI><a href=\"#3.1\">3.1. Representation</a>\n  <LI><a href=\"#3.2\">3.2. Design Process Support</a>\n  <LI><a href=\"#3.3\">3.3. Analysis</a>\n    <UL>\n    <LI><a href=\"#3.3.1\">3.3.1. Static Analysis</a>\n    <LI><a href=\"#3.3.2\">3.3.2. Dynamic Analysis</a>\n    </UL> \n  <LI><a href=\"#3.4\">3.4. Evolution</a>\n    <UL>\n    <LI><a href=\"#3.4.1\">3.4.1. Specification-Time Evolution</a>\n    <LI><a href=\"#3.4.2\">3.4.2. Execution-Time Evolution</a>\n    </UL> \n  <LI><a href=\"#3.5\">3.5. Refinement</a>\n  <LI><a href=\"#3.6\">3.6. Traceability</a>\n  <LI><a href=\"#3.7\">3.7. Simulation/Executability</a>\n  </UL>\n<LI><a href=\"#4\">4. ADL Support for Architectural Domains</a>\n  <UL>\n  <LI><a href=\"#4.1\">4.1. Representation</a>\n  <LI><a href=\"#4.2\">4.2. Design Process Support</a>\n  <LI><a href=\"#4.3\">4.3. Analysis</a>\n    <UL>\n    <LI><a href=\"#4.3.1\">4.3.1. Static Analysis</a>\n    <LI><a href=\"#4.3.2\">4.3.2. Dynamic Analysis</a>\n    </UL> \n  <LI><a href=\"#4.4\">4.4. Evolution</a>\n    <UL>\n    <LI><a href=\"#4.4.1\">4.4.1. Specification-Time Evolution</a>\n    <LI><a href=\"#4.4.2\">4.4.2. Execution-Time Evolution</a>\n    </UL> \n  <LI><a href=\"#4.5\">4.5. Refinement</a>\n  <LI><a href=\"#4.6\">4.6. Traceability</a>\n  <LI><a href=\"#4.7\">4.7. Simulation/Executability</a>\n  <LI><a href=\"#4.8\">4.8. Summary</a>\n  </UL>\n<LI><a href=\"#5\">5. Architectural vs. Application Domains</a>\n<LI><a href=\"#6\">6. Conclusions</a>\n<LI><a href=\"#7\">7. Acknowledgements</a>\n<LI><a href=\"#8\">8. References</a>\n<LI><a href=\"#Footnotes\">Footnotes</a>\n</UL>\n</B><P>\n<HR>\n\n<P><a name=\"1\"><B><FONT FACE=\"Variable Width\">1. Introduction</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Software architecture is an aspect\nof software engineering directed at reducing costs of developing applications\nand increasing the potential for commonality among different members of\na closely related product family [<a href=\"#PW92\">PW92</a>, \n<a href=\"#GS93\">GS93</a>]. Software development based\non common architectural idioms has its focus shifted from lines-of-code\nto coarser-grained architectural elements and their overall interconnection\nstructure. This enables developers to abstract away the unnecessary details\nand focus on the \"big picture:\" system structure, high level communication\nprotocols, assignment of software components and connectors to hardware\ncomponents, development process, and so on.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Many researchers have realized that,\nto obtain the benefits of an architectural focus, software architecture\nmust be provided with its own body of specification languages and analysis\ntechniques [<a href=\"#Gar95\">Gar95</a>, <a href=\"#GPT95\">GPT95</a>, \n<a href=\"#Wolf96\">Wolf96</a>]. Such languages are needed to demonstrate\nproperties of a system upstream, thus minimizing the costs of errors. They\nare also needed to provide abstractions adequate for modeling a large system,\nwhile ensuring sufficient detail for establishing properties of interest.\nA large number of <I>architecture description languages</I> (ADLs) has\nbeen proposed, each of which embodies a particular approach to the specification\nand evolution of an architecture. Examples are \nRapide [<a href=\"#LKA+95\">LKA+95</a>, <a href=\"#LV95\">LV95</a>], \nAesop [<a href=\"#GAO94\">GAO94</a>], \nMetaH [<a href=\"#Ves96\">Ves96</a>], \nUniCon [<a href=\"#SDK+95\">SDK+95</a>], \nDarwin [<a href=\"#MDEK95\">MDEK95</a>, <a href=\"#MK96\">MK96</a>], \nWright [<a href=\"#AG94a\">AG94a</a>, <a href=\"#AG94b\">AG94b</a>], \nC2 [<a href=\"#MTW96\">MTW96</a>, <a href=\"#MORT96\">MORT96</a>,  \n<a href=\"#Med96\">Med96</a>], and \nSADL [<a href=\"#MQR95\">MQR95</a>]. \nRecently, initial work has been done on an architecture interchange language, \nACME [<a href=\"#GMW95\">GMW95</a>, <a href=\"#GMW97\">GMW97</a>], which is \nintended to support mapping of architectural specifications\nfrom one ADL to another, and hence provide a bridge for their different\nfoci and resulting support tools.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There is still very much a lack of\nconsensus in the research community on what an ADL is, what aspects of\nan architecture should be modeled by an ADL, and what should be interchanged\nin an interchange language. This divergence has resulted in a wide variation\nof approaches found in this first generation of ADLs. Perhaps even more\nsignificantly, there is a wide difference of opinions as to what problems\nare most important to address in a study of software architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>In our previous research, we have provided\na foundation for understanding, defining, classifying, and comparing ADLs\n[<a href=\"#Med97\">Med97</a>, <a href=\"#MT97\">MT97</a>]. In this paper, we build upon those results by identifying\nand characterizing <I>architectural domains</I>, the problems or areas\nof concern that need to be addressed by ADLs. Understanding these domains\nand their properties is a key to better understanding the needs of software\narchitectures, architecture-based development, and architectural description\nand interchange. A study of architectural domains is also needed to guide\nthe development of next-generation ADLs.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This paper presents a framework of\narchitectural domains. We demonstrate that each existing ADL currently\nsupports only a small subset of these domains, and we discuss possible\nreasons for that. Finally, we consider the relationship between architectural\ndomains and application domains.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>While we draw from previous ADL work\nand reference a number of ADLs, the most significant contribution of this\npaper is the framework of architectural domains. It provides structure\nto a field that has been approached largely in an ad-hoc fashion thus far.\nThe framework gives the architect a sound foundation for selecting an ADL\nand orients discourse away from arguments about notation and more towards\nsolving important engineering problems.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The remainder of the paper is organized\nas follows. <a href=\"#2\">Section 2</a> provides a short discussion of ADLs. \n<a href=\"#3\">Section 3</a> presents\nand motivates each architectural domain, while <a href=\"#4\">Section 4</a> discusses the\nsupport for architectural domains in existing ADLs. <a href=\"#5\">Section 5</a> expounds\non the relationship between application domains and architectural domains.\nDiscussion and conclusions round out the paper.</FONT></FONT>\n\n<P><a name=\"2\"><B><FONT FACE=\"Variable Width\">2. Overview of ADLs</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>To properly enable further discussion,\nseveral definitions are needed. In this section, we define software architectures,\narchitectural styles, and ADLs.<a name = \"foot1-txt\"><a href=\"#foot1\"><FONT SIZE=-1>[Footnote 1]</FONT></a> We categorize ADLs, differentiate them\n\nfrom other, similar notations, and discuss examples of use of ADLs in actual\nprojects. Finally, we provide a short discussion on our use of the terms\n\"architecture\" and \"design.\"</FONT></FONT>\n\n<P><a name=\"2.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.1. Definitions of Architecture and Style</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There is no standard definition of architecture,\nbut we will use as our working definition the one provided by Garlan and\nShaw [<a href=\"#GS93\">GS93</a>]:</FONT></FONT>\n<DIR><FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>[</I>Software architecture <I>is\na level of design that] goes beyond the algorithms and data structures\nof the computation: designing and specifying the overall system structure\nemerges as a new kind of problem. Structural issues include gross organization\nand global control structure; protocols for communication, synchronization,\nand data access; assignment of functionality to design elements; physical\ndistribution; composition of design elements; scaling and performance;\nand selection among design alternatives.</I></FONT></FONT></DIR>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>Architectural style </I>is \"a set of\ndesign rules that identify the kinds of components and connectors that\nmay be used to compose a system or subsystem, together with local or global\nconstraints on the way the composition is done\" [<a href=\"#SC96\">SC96</a>].</FONT></FONT>\n\n<P><a name=\"2.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.2. Definition of ADLs</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Loosely defined, \"an <I>ADL </I>for software\napplications focuses on the high-level structure of the overall application\nrather than the implementation details of any specific source module\" \n[<a href=\"#Ves93\">Ves93</a>].\nADLs provide both a concrete syntax and a conceptual framework for modeling\na software system's <I>conceptual </I>architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The building blocks of an architectural\ndescription are</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>components </I>- units of computation\nor data stores;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>connectors </I>- architectural building\nblocks used to model interactions among components and rules that govern\nthose interactions; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>architectural configurations </I>-\nconnected graphs of components and connectors that describe architectural\nstructure.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>An ADL must provide the means for their\n<I>explicit </I>specification; this criterion enables one to determine\nwhether or not a particular notation is an ADL. In order to infer any kind\nof information about an architecture, at a minimum, <I>interfaces </I>of\nconstituent components must also be modeled formally. Without this information,\nan architectural description becomes but a collection of (interconnected)\nidentifiers.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>An ADL's conceptual framework typically\nsubsumes a formal semantic theory. That theory is part of the ADL's underlying\nframework for characterizing architectures; it influences the ADL's suitability\nfor modeling particular kinds of systems (e.g., highly concurrent systems)\nor particular aspects of a given system (e.g., its static properties).\nExamples of formal specification theories are \nPetri nets [<a href=\"#Pet62\">Pet62</a>], \nStatecharts [<a href=\"#Har87\">Har87</a>], \npartially-ordered event sets [<a href=\"#LVB+93\">LVB+93</a>], \ncommunicating sequential processes (CSP) [<a href=\"#Hoa85\">Hoa85</a>], \nmodel-based formalisms (e.g., \nCHemical Abstract Machine [<a href=\"#IW95\">IW95</a>], \nZ [<a href=\"#Spi89\">Spi89</a>]), \nalgebraic formalisms (e.g., Obj [<a href=\"#GW88\">GW88</a>]), and\naxiomatic formalisms (e.g., Anna [<a href=\"#Luc87\">Luc87</a>]).</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Finally, even though the suitability\nof a given language for modeling architectures is independent of whether\nand what kinds of <I>tool support </I>it provides, an accompanying toolset\nwill render an ADL both more usable and useful. Furthermore, capabilities\nprovided by such a toolset are often a direct reflection of the ADL's intended\nuse.</FONT></FONT>\n\n<P><a name=\"2.3\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.3. Categorizing ADLs</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Existing languages that are commonly referred\nto as ADLs can be grouped into three categories, based on how they model\nconfigurations:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>implicit configuration languages </I>model\nconfigurations implicitly through interconnection information that is distributed\nacross definitions of individual components and connectors;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>in-line configuration languages </I>model\nconfigurations explicitly, but specify connector information only as part\nof the configuration, \"in line\";</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>explicit configuration languages </I>model\nboth components and connectors separately from configurations.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>The first category, implicit configuration\nlanguages, are, by definition given in this paper, not ADLs, although they\nmay serve as useful tools in modeling certain aspects of architectures.\nAn example of an implicit configuration language is \nArTek [<a href=\"#TLPD95\">TLPD95</a>]. In\nArTek, there is no configuration specification; instead, each connector\nspecifies component ports to which it is attached.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The focus on conceptual architecture\nand explicit treatment of connectors as first-class entities differentiate\nADLs from module interconnection languages (MILs) \n[<a href=\"#DK76\">DK76</a>, <a href=\"#PN86\">PN86</a>], programming\nlanguages, and object-oriented notations and languages (e.g., Unified Method\n[<a href=\"#BR95\">BR95</a>]). MILs typically describe the uses relationships among modules in\nan <I>implemented </I>system and support only one type of connection \n[<a href=\"#AG94a\">AG94a</a>, <a href=\"#SG94\">SG94</a>]. \nProgramming languages describe a system's implementation, whose\narchitecture is typically implicit in subprogram definitions and calls.\nExplicit treatment of connectors also distinguishes ADLs from OO languages,\nas demonstrated in [<a href=\"#LVM95\">LVM95</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>It is important to note, however, that\nthere is less than a firm boundary between ADLs and MILs. Certain ADLs,\ne.g., Wright and Rapide, model components and connectors at a high level\nof abstraction and do not assume or prescribe a particular relationship\nbetween an architectural description and an implementation. We refer to\nthese languages as being <I>implementation independent</I>. On the other\nhand, several ADLs, e.g., UniCon and MetaH, enforce a high degree of fidelity\nof an implementation to its architecture. Components modeled in these languages\nare directly related to their implementations, so that a module interconnection\nspecification may be indistinguishable from an architectural description\nin such a language. These are <I>implementation constraining </I>languages.</FONT></FONT>\n\n<P><a name=\"2.4\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.4. Applications of ADLs</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs are special purpose notations whose\nvery specific foci render them suitable for powerful analyses, simulation,\nand automated code generation. However, they have yet to find their place\nin mainstream software development. Although current research is under\nway to bridge the gap that separates ADLs from more widely used design\nnotations [<a href=\"#RMRR97\">RMRR97</a>], only a small number of existing ADLs have been applied\nto large-scale, \"real-world\" examples to date. What these examples do demonstrate\nis the potential for effective use of ADLs in software projects.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Wright was used to model and analyze\nthe <I>Runtime Infrastructure </I>(RTI) of the Department of Defense (DoD)\n<I>High-Level Architecture for Simulations </I>(HLA) \n[<a href=\"#All96\">All96</a>]. The original\nspecification for RTI was over 100 pages long. Wright was able to substantially\ncondense the specification and reveal several inconsistencies and weaknesses\nin it.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>SADL was applied to an operational\npower-control system, used by the Tokyo Electric Power Company. The system\nwas implemented in 200,000 lines of Fortran 77 code. SADL was used to formalize\nthe system's reference architecture and ensure its consistency with the\nimplementation architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Finally, Rapide has been used in several\nlarge-scale projects thus far. A representative example is the X/Open Distributed\nTransaction Processing (DTP) Industry Standard. The documentation for the\nstandard is over 400 pages long. Its reference architecture and subsequent\nextensions have been successfully specified and simulated in \nRapide [<a href=\"#LKA+95\">LKA+95</a>].</FONT></FONT>\n\n<P><a name=\"2.5\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.5. Architecture vs. Design</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Given the above definition of software\narchitectures and ADLs, an issue worth addressing is the relationship between\narchitecture and design. Current literature leaves this question largely\nunanswered, allowing for several interpretations:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>architecture and design are the same;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>architecture is at a level of abstraction\nabove design, so it is simply another step (artifact) in a software development\nprocess; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>architecture is something new and is somehow\ndifferent from design (but just how remains unspecified).</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>All three interpretations are partially\ncorrect. To a large extent, architectures serve the same purpose as design.\nHowever, their explicit focus on connectors and configurations distinguishes\nthem from traditional software design. At the same time, as a (high level)\narchitecture is refined, connectors lose prominence by becoming distributed\nacross the (lower level) architecture's elements. Such a lower level architecture\nmay indeed be considered to be a design. Keeping this relationship in mind,\nfor reasons of simplicity we will simply refer to architectures as \"high\nlevel,\" \"low level,\" and so forth, in the remainder of the paper, while\n\"design\" will only refer to the process that results in an architecture.</FONT></FONT>\n\n<P><a name=\"3\"><B><FONT FACE=\"Variable Width\">3. Architectural Domains</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs typically share syntactic constructs\nthat enable them to model components and component interfaces, connectors,\nand configurations.<a name = \"foot2-txt\"><a href=\"#foot2\"><FONT SIZE=-1>[Footnote 2]</FONT></a> A much greater source of divergence are the different\nADLs' conceptual frameworks, and, consequently, their support for modeling\narchitectural semantics. ADL developers typically have decided to focus\non a specific aspect of architectures, or an <I>architectural domain</I>,\nwhich guides their selection of an underlying semantic model and a set\nof related formal specification notations. These formal notations, in turn,\nrestrict the types of problems for which the ADL is suitable.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This relationship between an architectural\ndomain and candidate formal notations is rarely straightforward or fully\nunderstood. In the absence of objective criteria, ADL researchers are forced\nto base their decisions on intuition, experience, and biases arising from\npast research accomplishments. Unfortunately, intuition can often be misleading\nand experience insufficient in a young discipline such as software architectures.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>In this paper, we attempt to fill this\nvoid. The remainder of this section motivates and formulates a framework\nfor classifying the problems on which architectural models focus (architectural\ndomains), shown in <a href=\"#Fig.1\">Figure 1</a>. Architectural domains represent broad classes\nof problems and are likely to be reflected in many ADLs and their associated\nformal specification language constructs. Their proper understanding is\nthus necessary. Furthermore, heuristics may be developed over time that\nwill enable easier interchange of architectures modeled in ADLs that focus\non particular architectural domains. Finally, such a framework can be used\nas a guide in developing future ADLs.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&nbsp;</FONT></FONT>\n\n<P>\n<a name=\"Fig.1\"><img src=fig1.jpg border=2>\n<P><FONT SIZE=+0><FONT FACE=\"Variable Width\"><B>Figure 1: </B></FONT>Architectural domains.</FONT><FONT SIZE=+0></FONT>\n\n<P><a name=\"3.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.1. Representation</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>A key role of an explicit representation\nof an architecture is to aid understanding and communication about a software\nsystem among different stakeholders. For this reason, it is important that\narchitectural descriptions be simple, understandable, and possibly graphical,\nwith well understood, but not necessarily formally defined, semantics.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Architectural models typically comprise\nmultiple views, e.g., high level graphical view, lower level view with\nformal specifications of components and connectors, conceptual architecture,\none or more implementation architectures, corresponding development process,\ndata or control flow view, and so on. Different stakeholders (e.g., architects,\ndevelopers, managers, customers) may require different views of the architecture.\nThe customers may be satisfied with a high-level, \"boxes and arrows\" description,\nthe developers may want detailed component and connector models, while\nthe managers may require a view of the development process.</FONT></FONT>\n\n<P><a name=\"3.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.2. Design Process Support</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Software architects decompose large, distributed,\nheterogeneous systems into smaller building blocks. In doing so, they have\nto consider many issues, make many decisions, and utilize many design techniques,\nmethodologies, and tools.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Modeling architectures from multiple\nperspectives, discussed in the previous subsection, is only one way of\nsupporting software architects' cognitive processes. Others include delivering\ndesign guidance in a timely and understandable fashion, capturing design\nrationale, and revisiting past design steps.</FONT></FONT>\n\n<P><a name=\"3.3\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.3. Analysis</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Architectures are often intended to model\nlarge, distributed, concurrent systems. The ability to evaluate the properties\nof such systems upstream, at the architectural level, can substantially\nlessen the number of errors passed downstream. Given that unnecessary details\nare abstracted away in architectures, the analysis task may also be easier\nto perform than at source code level.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Analysis of architectures may be performed\nstatically, before execution, or dynamically, at runtime. Certain types\nof analysis can be performed both statically and dynamically.</FONT></FONT>\n\n<P><a name=\"3.3.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.3.1. Static Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Examples of static analysis are internal\nconsistency checks, such as whether appropriate components are connected\nand their interfaces match, whether connectors enable desired communication,\nwhether constraints are satisfied, and whether the combined semantics of\ncomponents and connectors result in desired system behavior. Certain concurrent\nand distributed aspects of an architecture can also be assessed statically,\nsuch as the potential for deadlocks and starvation, performance, reliability,\nsecurity, and so on. Finally, architectures can be statically analyzed\nfor adherence to design heuristics and style rules.</FONT></FONT>\n\n<P><a name=\"3.3.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.3.2. Dynamic Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Examples of dynamic analysis are testing,\ndebugging, assertion checking, and assessment of the performance, reliability,\nand schedulability of an executing architecture. Saying that an architecture\nis executing can mean two different things:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>the system built based on the architecture\nis executing, or</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>the runtime behavior of the architecture\nitself is being simulated.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Clearly, certain analyses, such as performance\nor reliability, are more meaningful or even only possible in the former\ncase. However, an implementation of the system may not yet exist. Furthermore,\nit may be substantially less expensive to perform dynamic analyses in the\nlatter case, particularly when the relationship between the architecture\nand the implemented system is well understood.</FONT></FONT>\n\n<P><a name=\"3.4\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.4. Evolution</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Support for software evolution is a key\naspect of architecture-based development. Architectures evolve to reflect\nevolution of a single software system; they also evolve into families of\nrelated systems. As design elements, individual components and connectors\nwithin an architecture may also evolve.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Evolution of components, connectors,\nand architectures can occur at specification time or execution time.</FONT></FONT>\n\n<P><a name=\"3.4.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.4.1. Specification-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>If we consider components and connectors\nto be types which are instantiated every time they are used in an architecture,\ntheir evolution can be viewed simply in terms of subtyping. Since components\nand connectors are modeled at a high level of abstraction, flexible subtyping\nmethods may be employed. For example, it may be useful to evolve a single\ncomponent in multiple ways, by using different subtyping mechanisms (e.g.,\ninterface, behavior, or a combination of the two) \n[<a href=\"#MORT96\">MORT96</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>At the level of architectures, evolution\nis focused on incremental development and support for system families.\nIncrementality of an architecture can further be viewed from two different\nperspectives. One is its ability to accommodate addition of new components\nand the resulting issues of scale; the other is specification of incomplete\narchitectures.</FONT></FONT>\n\n<P><a name=\"3.4.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.4.2. Execution-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Explicit modeling of architectures\nis intended to support development and evolution of large and potentially\nlong-running systems. Being able to evolve such systems during execution\nmay thus be desirable and, in some cases, necessary. Architectures exhibit\ndynamism by allowing replication, insertion, removal, and reconnection\nof architectural elements or subarchitectures during execution.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Dynamic changes of an architecture\nmay be either planned at architecture specification time or unplanned.\nBoth types of dynamic change must be constrained to ensure that no desired\narchitectural properties are violated.</FONT></FONT>\n\n<P><a name=\"3.5\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.5. Refinement</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>The most common argument for creating\nand using formal architectural models is that they are necessary to bridge\nthe gap between informal, \"boxes and arrows\" diagrams and programming languages,\nwhich are deemed too low-level for designing a system. Architectural models\nmay need to be specified at several levels of abstraction for different\npurposes. For example, a high level specification of the architecture can\nbe used as an understanding and communication tool; a subsequent lower\nlevel may be analyzed for consistency of interconnections; an even lower\nlevel may be used in a simulation. Therefore, correct and consistent refinement\nof architectures to subsequently lower levels of abstraction is imperative.\nNote that, in this sense, code generation is simply a special case of architectural\nrefinement.</FONT></FONT>\n\n<P><a name=\"3.6\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.6. Traceability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>As discussed above, a software architecture\noften consists of multiple views and may be modeled at multiple levels\nof abstraction (<a href=\"#Fig.2\">Figure 2</a>). We call a particular view of the architecture\nat a given level of abstraction (i.e., a single point in the two-dimensional\nspace of <a href=\"#Fig.2\">Figure 2</a>) an \"architectural cross-section.\" It is critical for\nchanges in one cross-section to be correctly reflected in others. A particular\narchitectural cross-section can be considered \"dominant,\" so that <I>all\n</I>changes to the architecture are made to it and then reflected in others.\nHowever, changes will more frequently be made to the most appropriate or\nconvenient cross-section. Traceability support will hence need to exist\nacross all pertinent cross-sections.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>One final issue is the consistency\nof an architecture with system requirements. Changes to the requirements\nmust be appropriately reflected in the architecture; changes to the architecture\nmust be validated against the requirements. Therefore, even though system\nrequirements are in the problem domain, while architecture is in the solution\ndomain, traceability between the two is crucial. For purposes of traceability,\nrequirements can be considered to be at a very high level of architectural\nabstraction, as shown in <a href=\"#Fig.2\">Figure 2</a>.</FONT></FONT>\n\n<P><FONT FACE=\"Courier\"><FONT SIZE=-1>&nbsp;</FONT></FONT>\n\n<P>\n<a name=\"Fig.2\"><img src=fig2.jpg border=2>\n<P><FONT SIZE=+0><FONT FACE=\"Variable Width\"><B>Figure 2: </B></FONT>Two-dimensional\nspace of architectural views and levels of abstraction. The vertical axis\nis a set of discrete values with a nominal ordering. The horizontal axis\nis a continuum with an ordinal ordering of values, where system requirements\nare considered to be the highest level of abstraction and source code the\nlowest. One possible dominant cross-section (graphical view of the high\nlevel architecture) is shown.</FONT><FONT SIZE=+0></FONT>\n\n<P><a name=\"3.7\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.7. Simulation/Executability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Static architectural models are useful\nfor establishing static properties of the modeled system. Certain dynamic\nproperties may also be predicted with static models, but only if specific\nassumptions hold. For example, if the architect can correctly predict execution\ntime and criticality of each component, then schedulability of the encompassing\narchitecture can be evaluated.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>On the other hand, other dynamic properties,\nsuch as reliability, may by definition require a running system. Also,\ndevelopers may want to produce an early prototype to, e.g., attempt allocation\nof architectural elements to components of the physical system. Other stakeholders\n(e.g., customers or managers) may want to verify early on that the architecture\nconforms to their wishes. Simulating the dynamic behavior of a high level\narchitecture may thus be preferred to implementing the system: it is a\nquicker, cheaper, and more flexible way of arriving at the desired information.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>A special case of architectural simulation\nis the execution of the complete implemented system. The ultimate goal\nof any software design and modeling endeavor is to produce such a system.\nAn elegant and effective architectural model is of limited value, unless\nit can be converted into a running application. A simulation can only partially\ndepict the final system's dynamic behavior. Manually transforming an architecture\ninto a running system may result in many, already discussed problems of\nconsistency and traceability between the architecture and its implementation.\nTechniques, such as refinement and traceability discussed above, must be\nemployed to properly accomplish this task.</FONT></FONT>\n\n<P><a name=\"4\"><B><FONT FACE=\"Variable Width\">4. ADL Support for Architectural Domains</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>In the previous section, we motivated\nand described different architectural domains in terms of their characteristics\nand needs of software architectures. Another way of viewing architectural\ndomains is in terms of modeling languages and specific language features\nneeded to support different domains. At the same time, a useful way of\nunderstanding and classifying architecture modeling languages is in terms\nof architectural domains they are intended to support. For these reasons,\nthis section studies the kinds of language facilities that are needed to\nsupport each architectural domain, as well as the specific features existing\nADLs employ to that end. Our hope is that this discussion will shed light\non the relationships among different architectural domains (and their resulting\nADL features) and point out both where they can be effectively combined\nand where we can expect difficulties.</FONT></FONT>\n\n<P><a name=\"4.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.1. Representation</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Ideally, an ADL should make the structure\nof a system clear from a configuration specification alone, i.e., without\nhaving to study component and connector specifications. Architecture descriptions\nin <I>in-line configuration ADLs</I>, such as Darwin, MetaH, and Rapide\ntend to be encumbered with connector details, while <I>explicit configuration\nADLs</I>, such as ACME, Aesop, C2, SADL, UniCon, and Wright have the best\npotential to facilitate understandability of architectural structure.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>One common way of facilitating understandability\nand communication is by providing a graphical notation, in addition to\nthe textual notation. However, this is only the case if there is a precise\nrelationship between a graphical description and the underlying semantic\nmodel. For example, Aesop, C2, Darwin, MetaH, Rapide, and UniCon support\nsuch \"semantically sound\" graphical notations, while ACME, SADL, and Wright\ndo not.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs must also be able to model the\narchitecture from multiple perspectives. As discussed above, several ADLs\nsupport at least two views of an architecture: textual and graphical. Each\nof these ADLs also allows both top-level and detailed views of composite\nelements. Aesop, MetaH, and UniCon further distinguish different types\nof components and connectors iconically.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Support for other views is sparse.\nC2 provides a view of the development process that corresponds to the architecture\n[<a href=\"#RR96\">RR96</a>]. Darwin's <I>Software Architect's Assistant</I>\n[<a href=\"#NKM96\">NKM96</a>] provides\na hierarchical view of the architecture which shows all the component types\nand the \"include\" relationships among them in a tree structure. Rapide\nallows visualization of an architecture's execution behavior by building\nits simulation and animating its execution. Rapide also provides a tool\nfor viewing and filtering events generated by the simulation.</FONT></FONT>\n\n<P><a name=\"4.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.2. Design Process Support</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>As the above examples of C2's, Darwin's,\nand Rapide's support tools indicate, language features can only go so far\nin supporting software architects. Adequate tools are also needed. A category\nof tools that is critical for adequately supporting the design process\nare <I>active specification tools</I>; they can significantly reduce the\ncognitive load on architects.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Only a handful of existing ADLs provide\ntools that actively support specification of architectures. In general,\nsuch tools can be proactive or reactive. UniCon's graphical editor is proactive.\nIt invokes UniCon's language processing facilities to <I>prevent </I>errors\nduring design. Reactive specification tools detect <I>existing </I>errors.\nThey may either only inform the architect of the error (<I>non-intrusive</I>)\nor also force the architect to correct it before moving on (<I>intrusive</I>).\nAn example of the former is C2's design environment, <I>Argo</I>, while\nMetaH's graphical editor is an example of the latter.</FONT></FONT>\n\n<P><a name=\"4.3\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.3. Analysis</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>The types of analyses for which an ADL\nis well suited depend on its underlying semantic model, and to a lesser\nextent, its specification features. The semantic model will largely influence\nwhether the ADL can be analyzed statically or dynamically, or both. For\nexample, Wright, which is based on communicating sequential processes (CSP)\n[<a href=\"#Hoa85\">Hoa85</a>], allows static deadlock analysis of individual connectors and components\nattached to them. On the other hand, Rapide architectures, which are modeled\nwith partially ordered event sets (posets) \n[<a href=\"#LVB+93\">LVB+93</a>], can be analyzed dynamically.</FONT></FONT>\n\n<P><a name=\"4.3.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.3.1. Static Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The most common type of static analysis\ntools are language parsers and compilers. Parsers analyze architectures\nfor syntactic correctness, while compilers establish semantic correctness.\nAll existing ADLs have parsers. Darwin, MetaH, Rapide, and UniCon also\nhave compilers, which enable these languages to generate executable systems\nfrom architectural descriptions. Wright does not have a compiler, but it\nuses FDR [<a href=\"#For92\">For92</a>], a model checker, to establish type conformance.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There are numerous other possible types\nof static analysis of architectures. Several examples are provided by current\nADLs. Aesop provides facilities for checking for type consistency, cycles,\nresource conflicts, and scheduling feasibility in its architectures. C2\nuses critics to establish adherence to style rules and design guidelines.\nMetaH and UniCon both currently support schedulability analysis by specifying\nnon-functional properties, such as criticality and priority. Finally, given\ntwo architectures, SADL can establish their relative correctness with respect\nto a refinement map.</FONT></FONT>\n\n<P><a name=\"4.3.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.3.2. Dynamic Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The ability to analyze an architecture\ndynamically directly depends on the ADL's ability to model its dynamic\nbehavior. To this end, ADLs can employ specification mechanisms, such as\nevent posets, CHAM, or temporal logic, which can express dynamic properties\nof a system. Another aspect of dynamic analysis is enforcement of constraints\nat runtime.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Most existing ADLs tend to view architectures\nstatically, so that current support for dynamic modeling and analysis is\nscarce. Darwin enables dynamic analysis of architectures by instantiating\nparameters and components to enact \"what if\" scenarios. Similarly, Rapide\n<I>Poset Browser</I>'s event filtering features and <I>Animation Tools\n</I>facilitate analysis of architectures through simulation. Rapide's <I>Constraint\nChecker </I>also analyzes the conformance of a Rapide simulation to the\nformal constraints defined in the architecture. Finally, runtime systems\nof those ADLs that provide architecture compilation support can be viewed\nas dynamic analysis facilities.</FONT></FONT>\n\n<P><a name=\"4.4\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.4. Evolution</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>An architecture can evolve in two different\ndimensions:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>evolution of individual components and\nconnectors, where the structure of the architecture is not affected, although\nits behavior may be; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>evolution of the entire architecture,\nwhich affects both the structure and behavior of an architecture.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Evolution in these two dimensions can\noccur both at architecture specification time and while the architecture\nis executing.<a name=\"foot3-txt\"><a href=\"#foot3\"><FONT SIZE=-1>[Footnote 3]</FONT></a></FONT></FONT>\n\n<P><a name=\"4.4.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.4.1. Specification-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs can support specification-time\nevolution of individual components and connectors with subtyping. Only\na subset of existing ADLs provide such facilities, and even their evolution\nsupport is limited and often relies on the chosen implementation (programming)\nlanguage. The remainder of the ADLs view and model components and connectors\nas inherently static.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Aesop supports behavior-preserving\nsubtyping of components and connectors to create substyles of a given architectural\nstyle. Rapide allows its interface types to inherit from other types by\nusing OO methods, resulting in structural subtyping. ACME also supports\nstructural subtyping via its <I>extends </I>feature. C2 provides a more\nsophisticated subtyping and type checking mechanism. Multiple subtyping\nrelationships among components are allowed: name, interface, behavior,\nand implementation subtyping, as well as their combinations \n[<a href=\"#MORT96\">MORT96</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Specification-time evolution of complete\narchitectures has two facets: support for incremental development and support\nfor system families. Incrementality of an architecture can be viewed from\ntwo different perspectives. One is its ability to accommodate addition\nof new components to the architecture. In general, <I>explicit configuration\nADLs </I>can support incremental development more easily and effectively\nthan <I>in-line configuration ADLs</I>; ADLs that allow variable numbers\nof components to communicate through a connector are well suited for incremental\ndevelopment, particularly when faced with unplanned architectural changes\n[<a href=\"#Med97\">Med97</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Another view of incrementality is an\nADL's support for incomplete architectural descriptions. Incomplete architectures\nare common during design, as some decisions are deferred and others have\nnot yet become relevant. However, most existing ADLs and their supporting\ntoolsets have been built to prevent precisely these kinds of situations.\nFor example, Darwin, MetaH, Rapide, and UniCon compilers, constraint checkers,\nand runtime systems have been constructed to raise exceptions if such situations\narise. In this case, an ADL, such as Wright, which focuses its analyses\non information local to a single connector is better suited to accommodate\nexpansion of the architecture than, e.g., SADL, which is very rigorous\nin its refinement of <I>entire </I>architectures.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Still another aspect of static evolution\nis support for application families. In [<a href=\"#MT96\">MT96</a>], we showed that the number\nof possible architectures in a component-based style grows exponentially\nas a result of a linear expansion of a collection of components. All such\narchitectures may not belong to the same logical family. Therefore, relying\non component and connector inheritance, subtyping, or other evolution mechanisms\nis insufficient. An obvious solution, currently adopted only by ACME, is\nto provide a language construct that allows the architect to specify the\nfamily to which the given architecture belongs.</FONT></FONT>\n\n<P><a name=\"4.4.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.4.2. Execution-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There are presently two approaches\nto supporting evolution of architectures at execution time. The first is\nwhat Oreizy calls \"constrained dynamism\": all runtime changes to the architecture\nmust be known a priori and are specified as part of the architectural model\n[<a href=\"#Ore96\">Ore96</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Two existing ADLs support constrained\ndynamism. Rapide supports conditional configuration; its <I>where </I>clause\nenables a form of architectural rewiring at runtime, using the <I>link\n</I>and <I>unlink </I>operators. Darwin allows runtime replication of components\nusing the <I>dyn </I>operator.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The second approach to execution time\nevolution places no restrictions at architecture specification time on\nthe kinds of allowed changes. Instead, the ADL has an architecture modification\nfeature, which allows the architect to specify changes while the architecture\nis running.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Darwin and C2 are the only ADLs that\nsupport such \"pure dynamism\" [<a href=\"#Ore96\">Ore96</a>]. Darwin allows deletion and rebinding\nof components by interpreting Darwin scripts. C2 specifies a set of operations\nfor insertion, removal, and rewiring of elements in an architecture at\nruntime [<a href=\"#Med96\">Med96</a>]. C2's <I>ArchShell </I>tool enables arbitrary interactive\nconstruction, execution, and runtime-modification of C2-style architectures\nby dynamically loading and linking new architectural elements \n[<a href=\"#Ore96\">Ore96</a>, <a href=\"#MOT97\">MOT97</a>].\nAn issue that needs further exploration is constraining pure dynamic evolution\nto ensure that the desired properties of architectures are maintained.</FONT></FONT>\n\n<P><a name=\"4.5\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.5. Refinement</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs provide architects with expressive\nand semantically elaborate facilities for specification of architectures.\nHowever, an ADL must also enable correct and consistent refinement of architectures\nto subsequently lower levels of abstraction, and, eventually, to executable\nsystems.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>An obvious way in which ADLs can support\nrefinement is by providing patterns, or maps, that, when applied to an\narchitecture, result in a related architecture at a lower level of abstraction.\nSADL and Rapide are the only two ADLs that provide such support. SADL uses\nmaps to enable correct architecture refinements across styles, while Rapide\ngenerates comparative simulations of architectures at different abstraction\nlevels. Both approaches have certain drawbacks, indicating that a hybrid\napproach may be useful.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Garlan has recently argued that refinement\nshould not be consistent with respect to a single (immutable) law, but\nrather with respect to particular properties of interest, be they conservative\nextension (SADL), computational behavior (Rapide), or something entirely\ndifferent, such as performance [<a href=\"#Gar96\">Gar96</a>]. This may be a good starting point\ntowards a successful marriage of the two approaches.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Several ADLs take a different approach\nto refinement: they enable generation of executable systems directly from\narchitectural specifications. These are typically the i<I>mplementation\nconstraining languages</I>, such as MetaH and UniCon. These ADLs assume\nthe existence of a source file that corresponds to a given architectural\nelement. This approach makes the assumption that the relationship between\nelements of an architectural description and those of the resulting system\nwill be 1-to-1. Given that architectures are intended to describe systems\nat a higher level of abstraction than source code modules, this can be\nconsidered only a limited form of refinement.</FONT></FONT>\n\n<P><a name=\"4.6\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.6. Traceability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>While the problem of refinement essentially\nfocuses only on one axis of <a href=\"#Fig.2\">Figure 2</a> (the horizontal axis) and one direction\n(left to right), traceability may need to cover a large portion of the\ntwo-dimensional space and is applicable in both directions. This presents\na much more difficult task, indicating why this is the architectural domain\nin which existing ADLs are most lacking.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The relationships among architectural\nviews (vertical axis) are not always well understood. For example, ADLs\ncommonly provide support for tracing changes between textual and graphical\nviews, such that changes in one view are automatically reflected in the\nother; however, it may be less clear how the data flow view should affect\nthe process view. In other cases, changes in one view (e.g., process) should\nnever affect another (e.g., control flow). An even bigger hurdle is providing\ntraceability support across <I>both </I>architectural views and levels\nof abstraction simultaneously. Finally, although much research has been\ndirected at methodologies for making the transition from requirements to\ndesign (e.g., OO), this process is still an art form. Further research\nis especially needed to understand the effects of changing requirements\non architectures and vice versa.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Traceability is particularly a problem\nin the way implementation constraining languages approach code generation,\ndiscussed in the previous subsection. These ADLs provide no means of guaranteeing\nthat the source modules which are supposed to implement architectural components\nwill do so correctly. Furthermore, even if the specified modules currently\nimplement the needed behavior correctly, there is no guarantee that any\nfuture changes to those modules will be traced back to the architecture\nand vice versa.</FONT></FONT>\n\n<P><a name=\"4.7\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.7. Simulation/Executability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>As with dynamic analysis \n(<a href=\"#4.3.2\">Section 4.3.2</a>),\nsimulating an architecture will directly depend upon the ADL's ability\nto model its dynamic behavior. Currently, Rapide is the only ADL that can\nsimulate the architecture itself, by generating event posets. Other ADLs\nenable generation of running systems corresponding to the architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>MetaH and UniCon require preexisting\ncomponent implementations in Ada and C, respectively, in order to generate\napplications. Darwin can also construct executable systems in the same\nmanner in C++, and Rapide in C, C++, Ada, VHDL, or its executable sublanguage.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>C2 and Aesop provide class hierarchies\nfor their concepts and operations, such as components, connectors, and\ninterconnection and message passing protocols. These hierarchies form a\nbasis from which an implementation of an architecture may be produced.\nAesop's hierarchy has been implemented in C++, and C2's in C++, Java, and\nAda.</FONT></FONT>\n\n<P><a name=\"4.8\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.8. Summary</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Existing ADLs span a broad spectrum in\nterms of the architectural domains they support. On the one hand, languages\nlike SADL and Wright have very specific, narrow foci. On the other, C2,\nRapide, and Darwin support a number of architectural domains. Certain domains,\ne.g., evolution, refinement, and traceability are only sparsely supported,\nindicating areas around which future work should be centered. A more complete\nsummary of this section is given in <a href=\"#Table1\">Table 1</a> below.</FONT></FONT>\n<P>\n<CENTER><TABLE BORDER CELLPADDING=2 WIDTH=\"625\" >\n<TR>\n<TD VALIGN=TOP COLSPAN=\"10\"> <a name=\"Table1\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Table 1: ADL Support for Architectural\nDomains</FONT></FONT></B></CENTER>\n</TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER>&nbsp;<B><FONT SIZE=-1>ARCH.</FONT></B></CENTER>\n\n<CENTER><B><U><FONT SIZE=-1>DOMAIN</FONT></U></B></CENTER>\n\n<CENTER><B><FONT SIZE=-1>ADL</FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Represent.</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Design</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Process</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Support</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Static</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Analysis</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Dynamic</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Analysis</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Spec-Time</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Evolution</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Exec-Time</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Evolution</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Refinement</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Trace.</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Simulation/</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Executability</FONT></FONT></B></CENTER>\n</TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>ACME</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\n\"weblets\"</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>application\nfamilies</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>rep-maps across\nlevels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Aesop</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\ngraphical notation; types distinguished iconically</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>syntax directed\neditor; specialized editors for visualization classes</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; style-specific\ncompiler; type, cycle, resource conflict, and scheduling feasibility checker</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>behavior-preserving\nsubtyping of components and connectors</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1><I>build </I>tool\nconstructs system glue code in C for pipe-and-filter style</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>C2</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\ngraphical notation; process view; simulation; event filtering</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>non-intrusive,\nreactive design critics and to-do lists in Argo</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; critics\nto establish adherence to style rules and design heuristics</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>event filtering</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>multiple subtyping\nmechanisms; allows partial architectures</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>pure dynamism:\nelement insertion, removal, and rewiring</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>class framework\nenables generation of C/C++, Ada, and Java code</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Darwin</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>implicit config.;\ngraphical notation; hierarchical system view</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>automated addition\nof ports; propagation of changes across bound ports; property dialogs</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>\"what if\" scenarios\nby instantiating parameters and dynamic components</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>constrained\ndynamism: runtime replication of components and conditional configuration</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>compiler generates\nC++ code</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>MetaH</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>implicit config.;\ngraphical notation; types distinguished iconically</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>intrusive,\nreactive graphical editor</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler;\nschedulability, reliability, and security analysis</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>compiler generates\nAda code (C code generation planned)</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Rapide</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>implicit config.;\ngraphical notation; animated simulation; event filtering</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler;\nconstraint checker to ensure valid mappings</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>event filtering\nand animation</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>inheritance\n(structural subtyping)</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>constrained\ndynamism: conditional configuration and dynamic event generation</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>refinement\nmaps enable comparative simulations of architectures at different levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical;</FONT></FONT></CENTER>\n\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=-1>constraint checking across refinement</FONT></FONT>&nbsp;\n<BR><FONT FACE=\"Variable Width\"><FONT SIZE=-1>levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>simulation\nby generating event posets; system construction in C/C++, Ada, VHDL, and\nRapide</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>SADL</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; relative\ncorrectness of architectures w.r.t. a refinement map</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>component and\nconnector refinement via pattern maps</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>maps enable\ncorrect refinements across levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>refinement</FONT></FONT>&nbsp;\n<BR><FONT FACE=\"Variable Width\"><FONT SIZE=-1>across levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>UniCon</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\ngraphical notation</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>proactive GUI\neditor invokes language checker</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler;\nschedulability analysis</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>compiler generates\nC code</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Wright</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; model\nchecker for type conformance; deadlock analysis of connectors</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>type conformance\nfor behaviorally related protocols</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n</TR>\n</TABLE></CENTER>\n\n<P><a name=\"5\"><B><FONT FACE=\"Variable Width\">5. Architectural vs. Application Domains</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Over the past decade there has been\ninterest in relating architectures, which are in the solution domain, to\nthe problem (or application) domain, leading to the notion of <I>domain-specific\nsoftware architectures (DSSAs) </I>[<a href=\"#Tra95\">Tra95</a>]. A DSSA provides a single (generic)\n<I>reference architecture</I>, which reflects the characteristics of a\nparticular problem domain, and which is instantiated for each specific\napplication in that domain. <I>Architectural styles</I>, discussed in \n<a href=\"#2\">Section 2</a>,\nprovide another way of relating the problem and solution spaces. Styles\nare largely orthogonal to DSSAs: a single style may be applicable to multiple\napplication domains; on the other hand, a single DSSA may use multiple\nstyles.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Any attempt to further explore and\nperhaps generalize the relationship between architectural and application\ndomains would be greatly aided by a classification of application domains.\nWe are unaware of any such classification, although Jackson identified\na number of <I>domain characteristics </I>that could serve as a starting\npoint for one [<a href=\"#Jac95\">Jac95</a>]:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>static </I>vs. <I>dynamic </I>domains,\nwith the latter being application domains having an element of time, events,\nand/or state;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>one-dimensional </I>vs. <I>multi-dimensional\n</I>domains;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>tangible </I>vs. <I>intangible </I>domains,\nwith the latter typically involving machine representations of abstractions\n(such as user interfaces);</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>inert </I>vs. <I>reactive </I>vs. <I>active\n</I>dynamic domains; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>autonomous </I>vs. <I>programmable\n</I>vs. <I>biddable </I>active dynamic domains.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Given these application domain characteristics,\none can easily identify a number of useful relationships with architectural\ndomains. For instance, support for evolution, executability and dynamic\nanalysis are more important for dynamic domains than for static domains.\nAs another example, reactive domains are naturally supported by a style\nof representation (e.g., Statecharts [<a href=\"#Har87\">Har87</a>]) that is different from that\nin active domains (e.g., CHAM [<a href=\"#IW95\">IW95</a>]). As we deepen our understanding of\narchitectural domains, we will be able to solidify our understanding of\ntheir relationship with application domains.</FONT></FONT>\n\n<P><a name=\"6\"><B><FONT FACE=\"Variable Width\">6. Conclusions</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Software architecture research has\nbeen moving forward rapidly. A number of ADLs and their supporting toolsets\nhave been developed; many existing styles have been adopted and new ones\ninvented. Theoretical underpinnings for the study of software architectures\nhave also begun to emerge in the form of definitions \n[<a href=\"#PW92\">PW92</a>, <a href=\"#GS93\">GS93</a>] and formal\nclassifications of styles [<a href=\"#SC96\">SC96</a>] and \nADLs [<a href=\"#Med97\">Med97</a>, <a href=\"#MT97\">MT97</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This body of work reflects a wide spectrum\nof views on what architecture is, what aspects of it should be modeled\nand how, and what its relationship is to other software development concepts\nand artifacts. This divergence of views has also resulted in a divergence\nof ADLs' conceptual frameworks (as defined in <a href=\"#2\">Section 2</a>). Such fragmentation\nhas made it difficult to establish whether there exists in ADLs a notion\nsimilar to computational equivalence in programming languages. Furthermore,\nsharing support tools has been difficult.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ACME has attempted to provide a basis\nfor interchanging architectural descriptions across ADLs. However, ACME\nhas thus far been much more successful at achieving architectural interchange\nat the syntactic (i.e., structural) level, than at the semantic level.\nAlthough some of the ACME team's recent work looks encouraging, this still\nremains an open problem. One of the reasons ACME has encountered difficulties\nis precisely the fact that there is only limited agreement in the architecture\ncommunity on some fundamental issues, the most critical of which is what\nproblems architectures should attempt to solve.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This paper presents an important first\nstep towards a solution to this problem. We have recognized that the field\nof software architecture is concerned with several domains and that every\nADL reflects the properties of one or more domains from this set. Architectural\ndomains thus provide a unifying view to what had seemed like a disparate\ncollection of approaches, notations, techniques, and tools. The task of\narchitectural interchange can be greatly aided by studying the interrelationships\namong architectural domains. Existing ADLs can be better understood in\nthis new light and new ADLs more easily developed to solve a specific set\nof problems.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Much further work is still needed,\nhowever. Our current understanding of the relationship between architectural\ndomains and formal semantic theories (<a href=\"#2\">Section 2</a>) is limited. Also, we need\nto examine whether there exist techniques that can more effectively support\nthe needs of particular architectural domains than those provided by existing\nADLs. Finally, a more thorough understanding of the relationship between\narchitectural and application domains is crucial if architecture-based\ndevelopment is to fulfill its potential.</FONT></FONT>\n\n<P><a name=\"7\"><B><FONT FACE=\"Variable Width\">7. Acknowledgements</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>We would like to thank Richard Taylor,\nPeyman Oreizy, Jason Robbins, David Redmiles, and David Hilbert for their\nparticipation in numerous discussions of issues concerning ADLs. We also\nthank the DSL reviewers for their helpful reviews.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Effort partially sponsored by the Defense\nAdvanced Research Projects Agency, and Rome Laboratory, Air Force Materiel\nCommand, USAF, under agreement numbers F30602-94-C-0218 and F30602-97-2-0021.\nThe U.S. Government is authorized to reproduce and distribute reprints\nfor Governmental purposes notwithstanding any copyright annotation thereon.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Approved for Public Release - Distribution\nUnlimited.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The views and conclusions contained\nherein are those of the authors and should not be interpreted as necessarily\nrepresenting the official policies or endorsements, either expressed or\nimplied, of the Defense Advanced Research Projects Agency, Rome Laboratory\nor the U.S. Government.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This material is also partially based\non work supported by the National Science Foundation under Grant No. CCR-9701973.</FONT></FONT>\n\n<P><a name=\"8\"><B><FONT FACE=\"Variable Width\">8. References</FONT></B>\n<P>\n<DL COMPACT>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>\n\n<DT><a name=\"AG94a\">[AG94a] \n<DD>R. Allen and D. Garlan. Formal\nConnectors. Technical Report, CMU-CS-94-115, Carnegie Mellon University,\nMarch 1994.\n\n<DT><a name=\"AG94b\">[AG94b] \n<DD>R. Allen and D. Garlan. Formalizing\nArchitectural Connection. In <I>Proceedings of the Sixteenth International\nConference on Software Engineering</I>, pages 71-80, Sorrento, Italy, May\n1994.</FONT></FONT>\n\n<DT><a name=\"All96\">[All96] \n<DD>R. Allen. HLA: A Standards\nEffort as Architectural Style. In A. L. Wolf, ed., <I>Proceedings of the\nSecond International Software Architecture Workshop (ISAW-2)</I>, pages\n130-133, San Francisco, CA, October 1996.\n\n<DT><a name=\"BR95\">[BR95] \n<DD>G. Booch and J. Rumbaugh. <I>Unified\nMethod for Object-Oriented Development</I>. Rational Software Corporation,\n1995.\n\n<DT><a name=\"DK76\">[DK76] \n<DD>F. DeRemer and H. H. Kron. Programming-in-the-large\nversus Programming-in-the-small. <I>IEEE Transactions on Software Engineering</I>,\npages 80-86, June 1976.\n\n<DT><a name=\"For92\">[For92] \n<DD><I>Failures Divergence Refinement:\nUser Manual and Tutorial</I>. Formal Systems (Europe) Ltd., Oxford, England,\nOctober 1992.\n\n<DT><a name=\"GAO94\">[GAO94] \n<DD>D. Garlan, R. Allen, and J.\nOckerbloom. Exploiting Style in Architectural Design Environments. In <I>Proceedings\nof SIGSOFT'94: Foundations of Software Engineering</I>, pages 175-188,\nNew Orleans, Louisiana, USA, December 1994.\n\n<DT><a name=\"Gar95\">[Gar95] \n<DD>D. Garlan, editor. <I>Proceedings\nof the First International Workshop on Architectures for Software Systems</I>,\nSeattle, WA, April 1995.\n\n<DT><a name=\"Gar96\">[Gar96] \n<DD>D. Garlan. Style-Based Refinement\nfor Software Architecture. In A. L. Wolf, ed., <I>Proceedings of the Second\nInternational Software Architecture Workshop (ISAW-2)</I>, pages 72-75,\nSan Francisco, CA, October 1996.\n\n<DT><a name=\"GMW95\">[GMW95] \n<DD>D. Garlan, R. Monroe, and D.\nWile. ACME: An Architectural Interconnection Language. Technical Report,\nCMU-CS-95-219, Carnegie Mellon University, November 1995.\n\n<DT><a name=\"GMW97\">[GMW97] \n<DD>D. Garlan, R. Monroe, and D.\nWile. ACME: An Architecture Interchange Language. Submitted for publication,\nJanuary 1997.\n\n<DT><a name=\"GPT95\">[GPT95] \n<DD>D. Garlan, F. N. Paulisch,\nand W. F. Tichy, editors. <I>Summary of the Dagstuhl Workshop on Software\nArchitecture</I>, February 1995. Reprinted in ACM Software Engineering\nNotes, pages 63-83, July 1995.\n\n<DT><a name=\"GS93\">[GS93] \n<DD>D. Garlan and M. Shaw. <I>An\nIntroduction to Software Architecture: Advances in Software Engineering\nand Knowledge Engineering</I>, volume I. World Scientific Publishing, 1993.\n\n<DT><a name=\"GW88\">[GW88] \n<DD>J. A. Goguen and T. Winkler.\nIntroducing OBJ3. Technical Report SRI-CSL-88-99. SRI International, 1988.\n\n<DT><a name=\"Har87\">[Har87] \n<DD>D. Harel. Statecharts: A Visual\nFormalism for Complex Systems. <I>Science of Computer Programming</I>,\n1987.\n\n<DT><a name=\"Hoa85\">[Hoa85] \n<DD>C. A. R. Hoare. <I>Communicating\nSequential Processes</I>. Prentice Hall, 1985.\n\n<DT><a name=\"IW95\">[IW95] \n<DD>P. Inverardi and A. L. Wolf.\nFormal Specification and Analysis of Software Architectures Using the Chemical\nAbstract Machine Model. <I>IEEE Transactions on Software Engineering</I>,\npages 373-386, April 1995.\n\n<DT><a name=\"Jac95\">[Jac95]\n<DD>M. Jackson. <I>Software Requirements\nand Specifications: A Lexicon of Practice, Principles and Prejudices</I>.\nAddison-Wesley, 1995.\n\n<DT><a name=\"LKA+95\">[LKA+95] \n<DD>D. C. Luckham, J. J. Kenney,\nL. M. Augustin, J. Vera, D. Bryan, and W. Mann. Specification and Analysis\nof System Architecture Using Rapide. <I>IEEE Transactions on Software Engineering</I>,\npages 336-355, April 1995.\n\n<DT><a name=\"Luc87\">[Luc87] \n<DD>D. Luckham. <I>ANNA, a language\nfor annotating Ada programs: reference manual</I>, volume 260 of <I>Lecture\nNotes in Computer Science</I>. Springer-Verlag, Berlin, 1987.\n\n<DT><a name=\"LV95\">[LV95] \n<DD>D. C. Luckham and J. Vera. An Event-Based Architecture Definition Language. <I>IEEE Transactions on Software\nEngineering</I>, pages 717-734, September 1995.\n\n<DT><a name=\"LVB+93\">[LVB+93] \n<DD>D. C. Luckham, J. Vera, D.\nBryan, L. Augustin, and F. Belz. Partial Orderings of Event Sets and Their\nApplication to Prototyping Concurrent, Timed Systems. <I>Journal of Systems\nand Software</I>, pages 253-265, June 1993.\n\n<DT><a name=\"LVM95\">[LVM95] \n<DD>D. C. Luckham, J. Vera, and\nS. Meldal. Three Concepts of System Architecture. Unpublished Manuscript,\nJuly 1995.\n\n<DT><a name=\"Med96\">[Med96] \n<DD>N. Medvidovic. ADLs and Dynamic\nArchitecture Changes. In A. L. Wolf, ed., <I>Proceedings of the Second\nInternational Software Architecture Workshop (ISAW-2)</I>, pages 24-27,\nSan Francisco, CA, October 1996.\n\n<DT><a name=\"Med97\">[Med97] \n<DD>N. Medvidovic. A Classification\nand Comparison Framework for Software Architecture Description Languages.\nTechnical Report, UCI-ICS-97-02, University of California, Irvine, January\n1997.\n\n<DT><a name=\"MDEK95\">[MDEK95] \n<DD>J. Magee, N. Dulay, S. Eisenbach,\nand J. Kramer. Specifying Distributed Software Architectures. In <I>Proceedings\nof the Fifth European Software Engineering Conference (ESEC'95)</I>, Barcelona,\nSeptember 1995.\n\n<DT><a name=\"MK96\">[MK96] \n<DD>J. Magee and J. Kramer. Dynamic\nStructure in Software Architectures. In <I>Proceedings of ACM SIGSOFT'96:\nFourth Symposium on the Foundations of Software Engineering (FSE4)</I>,\npages 3-14, San Francisco, CA, October 1996.\n\n<DT><a name=\"MOT97\">[MOT97] \n<DD>N. Medvidovic, P. Oreizy, and\nR. N. Taylor. Reuse of Off-the-Shelf Components in C2-Style Architectures.\nIn <I>Proceedings of the 1997 Symposium on Software Reusability (SSR'97)</I>,\npages 190-198, Boston, MA, May 17-19, 1997. Also in <I>Proceedings of the\n1997 International Conference on Software Engineering (ICSE'97)</I>, pages\n692-700, Boston, MA, May 17-23, 1997.\n\n<DT><a name=\"MORT96\">[MORT96] \n<DD>N. Medvidovic, P. Oreizy,\nJ. E. Robbins, and R. N. Taylor. Using object-oriented typing to support\narchitectural design in the C2 style. In <I>Proceedings of ACM SIGSOFT'96:\nFourth Symposium on the Foundations of Software Engineering (FSE4)</I>,\npages 24-32, San Francisco, CA, October 1996.\n\n<DT><a name=\"MQR95\">[MQR95] \n<DD>M. Moriconi, X. Qian, and R.\nA. Riemenschneider. Correct Architecture Refinement. <I>IEEE Transactions\non Software Engineering</I>, pages 356-372, April 1995.\n\n<DT><a name=\"MT96\">[MT96] \n<DD>N. Medvidovic and R. N. Taylor.\nReusing Off-the-Shelf Components to Develop a Family of Applications in\nthe C2 Architectural Style. In <I>Proceedings of the International Workshop\non Development and Evolution of Software Architectures for Product Families</I>,\nLas Navas del Marqu&eacute;s, &Aacute;vila, Spain, November 1996.\n\n<DT><a name=\"MT97\">[MT97] \n<DD>N. Medvidovic and R. N. Taylor.\nA Framework for Classifying and Comparing Architecture Description Languages.\nTo appear in <I>Proceedings of the Sixth European Software Engineering\nConference together with Fifth ACM SIGSOFT Symposium on the Foundations\nof Software Engineering</I>, Zurich, Switzerland, September 22-25, 1997.\n\n<DT><a name=\"MTW96\">[MTW96] \n<DD>N. Medvidovic, R. N. Taylor,\nand E. J. Whitehead, Jr. Formal Modeling of Software Architectures at Multiple\nLevels of Abstraction. In <I>Proceedings of the California Software Symposium\n1996</I>, pages 28-40, Los Angeles, CA, April 1996.\n\n<DT><a name=\"NKM96\">[NKM96] \n<DD>K. Ng, J. Kramer, and J. Magee.\nA CASE Tool for Software Architecture Design. <I>Journal of Automated Software\nEngineering (JASE), Special Issue on CASE-95</I>, 1996.\n\n<DT><a name=\"Ore96\">[Ore96] \n<DD>P. Oreizy. Issues in the\nRuntime Modification of Software Architectures. Technical Report, UCI-ICS-96-35,\nUniversity of California, Irvine, August 1996.\n\n<DT><a name=\"Pet62\">[Pet62] \n<DD>C. A. Petri. Kommunikationen\nMit Automaten. PhD Thesis, University of Bonn, 1962. English translation:\nTechnical Report RADC-TR-65-377, Vol.1, Suppl 1, Applied Data Research,\nPrinceton, N.J.\n\n<DT><a name=\"PN86\">[PN86] \n<DD>R. Prieto-Diaz and J. M. Neighbors.\nModule Interconnection Languages. <I>Journal of Systems and Software</I>,\npages 307-334, October 1989.\n\n<DT><a name=\"PW92\">[PW92] \n<DD>D. E. Perry and A. L. Wolf.\nFoundations for the Study of Software Architectures. <I>ACM SIGSOFT Software\nEngineering Notes</I>, pages 40-52, October 1992.\n\n<DT><a name=\"RMRR97\">[RMRR97] \n<DD>J. E. Robbins, N. Medvidovic,\nD. F. Redmiles, and D. S. Rosenblum. Integrating Architecture Description\nLanguages with a Standard Design Method. Technical Report, UCI-ICS-97-35,\nUniversity of California, Irvine, August 1997.\n\n<DT><a name=\"RR96\">[RR96] \n<DD>J. E. Robbins and D. Redmiles.\nSoftware architecture design from the perspective of human cognitive needs.\nIn <I>Proceedings of the California Software Symposium (CSS'96)</I>, Los\nAngeles, CA, USA, April 1996.\n\n<DT><a name=\"SC96\">[SC96] \n<DD>M. Shaw and P. Clements. Toward\nBoxology: Preliminary Classification of Architectural Styles. In A. L.\nWolf, ed., <I>Proceedings of the Second International Software Architecture\nWorkshop (ISAW-2)</I>, pages 50-54, San Francisco, CA, October 1996.\n\n<DT><a name=\"SDK+95\">[SDK+95] \n<DD>M. Shaw, R. DeLine, D. V.\nKlein, T. L. Ross, D. M. Young, and G. Zelesnik. Abstractions for Software\nArchitecture and Tools to Support Them. <I>IEEE Transactions on Software\nEngineering</I>, pages 314-335, April 1995.\n\n<DT><a name=\"SG94\">[SG94] \n<DD>M. Shaw and D. Garlan. Characteristics\nof Higher-Level Languages for Software Architecture. Technical Report,\nCMU-CS-94-210, Carnegie Mellon University, December 1994.\n\n<DT><a name=\"Spi89\">[Spi89] \n<DD>J. M. Spivey. <I>The Z notation:\na reference manual</I>. Prentice Hall, New York, 1989.\n\n<DT><a name=\"TLPD95\">[TLPD95] \n<DD>A. Terry, R. London, G. Papanagopoulos,\nand M. Devito. The ARDEC/Teknowledge Architecture Description Language\n(ArTek), Version 4.0. Technical Report, Teknowledge Federal Systems, Inc.\nand U.S. Army Armament Research, Development, and Engineering Center, July\n1995.\n\n<DT><a name=\"Tra95\">[Tra95] \n<DD>W. Tracz. DSSA (Domain-Specific\nSoftware Architecture) Pedagogical Example. <I>ACM SIGSOFT Software Engineering\nNotes</I>, July 1995.\n\n<DT><a name=\"Ves93\">[Ves93] \n<DD>S. Vestal. A Cursory Overview\nand Comparison of Four Architecture Description Languages. Technical Report,\nHoneywell Technology Center, February 1993.\n\n<DT><a name=\"Ves96\">[Ves96] \n<DD>S. Vestal. MetaH Programmer's\nManual, Version 1.09. Technical Report, Honeywell Technology Center, April\n1996.\n\n<DT><a name=\"Wolf96\">[Wolf96] \n<DD>A. L. Wolf, editor. <I>Proceedings\nof the Second International Software Architecture Workshop (ISAW-2)</I>,\nSan Francisco, CA, October 1996.\n\n</FONT></FONT>\n</DL>\n\n<P>\n<HR>\n<P><a name=\"Footnotes\"><B><FONT FACE=\"Variable Width\">Footnotes</FONT></B>\n<P>\n<DL>\n<DT><a name=\"foot1\"><a href=\"#foot1-txt\">[Footnote 1]</a>\n<DD>This section is condensed from a detailed exposition on\nADLs given in [<a href=\"#Med97\">Med97</a>] and [<a href=\"#MT97\">MT97</a>], where we provided a \ndefinition of ADLs and devised a classification and comparison \nframework for them.\n\n<P>\n<DT><a name=\"foot2\"><a href=\"#foot2-txt\">[Footnote 2]</a>\n<DD>One can think of these syntactic features as equivalent to a \n\"boxes and arrows\" graphical notation with little or no underlying \nsemantics.\n\n<P>\n<DT><a name=\"foot3\"><a href=\"#foot3-txt\">[Footnote 3]</a>\n<DD>Saying that an architecture is \"executing\" can mean either \nthat the architecture is being simulated or that the executable \nsystem built based on that architecture is running.\n</DL>\n\n</BODY>\n</HTML>\n", "id": 24266.0}