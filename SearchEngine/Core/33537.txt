{"text": "Program 5 Graph Implemented via CollectionsandAn Important Graph Algorithm Fundamental Data Structures ICS 23 Introduction This programming assignment is designed to improve your knowledge of using collection classes especially Map and Set while teaching you important concepts of representing graphs and writing graph processing algorithms There are two problems in this assignment The first problem is to write a class named HashGraph that implements the Graph interface which includes a wide variety of simple and efficient bookkeeping operations on the nodes and edges in a directed graph The second problem involves implementing an important graph algorithm using HashGraph The algorithms is Dijkstra s all shortest paths algorithm When writing HashGraph you will run it against my JUnit tests to verify a bit too strong of a word here that it is correct You may also find it useful to test your class with the DriverForGraph With this driver you can individually test any methods in your classes interactively and see their results returned values and state changes mostly using toString Both the JUnit test and driver are included in the start project folder for this project I have also included the Javadoc for the HashGraph class built from the comments in the java file You are already familiar with classes implementing the Map and Set interfaces use the standard HashMap and HashSet implementations actually I will write the HashSet implementation over the weekend for now use ArraySet to work on your program and just substitute HashSet for ArraySet when I send email telling you where to get HashSet the only difference will be the speed of the operations on these two different set representations You will implement the HashGraph class using these interfaces classes along with two simple inner classes that I have implemented specially for this assignment SimpleEdge which is a lot like SimpleEntry for HashMap a class implementing Graph Edge and LocalInformation I have provided a HashGraph class with Javadoc comments for all its methods along with full implementations of the SimpleEdge and LocalInformation classes change only the former not the final two but definitely read and understand their code I have also provided an interface named EdgeValueIO in the file EdgeValueIO java and various simple classes implementing this interface for standard edge values examine these files briefly mostly their information is used in the load and write methods which need to translate to from String information in files Download and unzip the following Eclipse project Start and use it to start working on this program For each part of this assignmnment you will update and turn in a single java file in the project see the Checkmate submission for this assignment for more details Only one student should submit the assignment but both student s names should appear in the comments at the top of each submitted program Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review while you work on this assignment and before you turn in the files The HashGraph Class The start folder contains one main file to examine update HashGraph java but there are lots of others most importantly Graph java to read and understand You can download and run a special Executable version of my DriverForGraph to help you understand the specification of the problem and observe the programmer user interaction that you are to implement I suggest your create a few small graphs with int edges enter them using this driver and then call various methods on the graph to see their behavior The HashGraph class acts as a repository for all the nodes and edges that comprise a graph organized in such a way that allows us quickly to access information that is useful in graph algorithms Part of the complexity comes from keeping and updating redundant information We will represent each graph primarily using two maps one with nodes as keys and one with edges as keys With this representation it is easy to get all the nodes and edges directly connected to some node and get the value associated with any edge nodeMap maps its key a node name represented by a String to its value a LocalInformation object that stores four sets nodes with edges that lead to them from this node destination nodes with this node is their origin node nodes whose edges lead to this node origin nodes with this node as their destination node edges leading to other nodes from this node all edges with this node is their origin node edges from other nodes leading to this node all edges with this node is their destination node edgeMap maps its key an Edge to its value an object of generic type E often using a String or wrapper class for the edge s value but we can use any class for this value Clarification Although there is an accessor named getValue in the SimpleEdge class along with getOrigin and getDestination edge values ARE NOT stored in SimpleEdge objects examine that class Instead they are retrieved from the edgeMap in getValue by using the SimpleEdge object as a key which stores only the origin and destination node We partition the connected nodes into two sets outgoing and incoming by using the outNodes and inNodes instance variables in the LocalInformation class Likewise we partition the edges into two sets outgoing and incoming by using the outEdges and inEdges instance variables in the LocalInformation class All these sets could be computed when necessary from the main maps but it is more efficient to cache their values and then be able to use these values directly without re computing them The downside of caching is that it takes more space and whenever we udpate the main maps we must also update the related LocalInformation sets too which is where most of the complexity of this programming assignment comes from A variety of methods return Iterable objects typically this means that they return sets of nodes or edges because we keep track of most LocalInformation in sets and the Set interface extends Iterable The code using such an Iterable object can easily turn it into a concrete Set or List by supplying the Iterable object to a constructor from a class These iterators should NOT allow their remove method to work we don t want code with access to an iterator for nodes or edges to remove those nodes or edges directly which would cause all sorts of inconsistencies with the other cached values a programmer could wreck our carefully controlled data structures Removal should be done only by the HashGraph methods To aid you in this task I have supplied a decorator for Iterable named Unremovable which delegates hasNext and next to the original Iterable object supplied to its constructor but throws UnsupportedOperationException whenever remove is called Here is a brief list of all the methods in the Graph interface All of these methods are documented more fully in the class you are writing I have already written some of the bodies of these methods others you must write There are two constructors one constructs an empty graph another constructs a graph that is a copy of its graph parameter addNode adds a node with no outgoing or incoming nodes edges to the graph addEdge adds an edge to the graph updating the LocalInformation for its origin and destination nodes and adding these nodes automatically first if they do not already exist in the graph removeNode removes a node from the graph as well as all the edges that refer to that node and updates the LocalInformation for the affected nodes affected nodes are origin and destination nodes for the removed edges removeEdge removes an edge from the graph updating the LocalInformation for its origin and destination nodes clear removes all nodes and edges from the graph load reads a graph from a file see the comment for details write writes a graph to a file see the comment for details The details ensure that graphs that are written to a file can then be read back in getNodeCount returns the number of nodes in the graph getEdgeCount returns the number of edges in the graph hasNode determines whether or not a node is in the graph hasEdge determines whether or not an edge is in the graph getEdgeValue returns the value associated with the edge that is its parameter or null if that edge is not in the graph inDegree returns the number of incoming edges to a node outDegree returns the number of outgoing edges from a node degree returns the number of edges outgoing or incoming to a node getAllNodes returns an Iterable object for all the nodes in the graph whose remove method is disabled getAllEdges returns an Iterable object for all the edges in the graph whose remove method is disabled getOutNodes returns an Iterable object for all the nodes in the graph that are desinations of the given node via some edge whose remove method is disabled getInNodes returns an Iterable object for all the nodes in the graph that are origins of the given node via some edge whose remove method is disabled getOutEdges returns an Iterable object for all the edges in the graph that have the given nodes as their origin whose remove method is disabled getInEdges returns an Iterable object for all the edges in the graph that have the given nodes as their destination whose remove method is disabled toString returns the textual representation of a graph by including all the nodes and edges that it contains the nodes are sorted in alphabetic order the out edges are sorted by destination nodes the in edges are sorted by origin nodes Although this interface contains many methods many are similar in functionality and code Each is implemented relatively easily via the powerful collection classes used to represent the graph Some methods which would normally be void say addNode return the entire HashGraph object see return this at their end Using this approach we can cascade method calls e g g addNode a addNode b instead of writing two sequential statements g addNode a g addNode b This isn t a huge win but it is a convenience and you should see this style any void method can instead be made to return such an object Often writing testing and debugging one method in a class will immediately lead to the correct code for one or more other methods some simpler methods are called inside other more complicated methods As with many programming problems understanding the concepts involved will take lots of time writing code must come afterward and it should be more straightforward although your bugs will lead you to discover yet more information There generally is no exception throwing in these methods With non existant nodes edges as parameters most of these methods return empty sets or other special values like null In other cases such a removing non existent nodes edges the methods make no state changes and they do NOT throw exceptions Writing Testing The HashGraph Class Try to write test and debug one method at a time using the driver in the DriverForGraph class Basically call toString after every mutator to see if the state of the class has been changed correctly I d start by writing the first constructor and the simplest methods that manipulate nodeMap addNode and getAllNodes which is necessary in toString method in HashGraph Next I d write addEdge you can try to have it update the LocalInformation for the origin and destination nodes or I d suggest leaving that functionality until it is needed later We use these two methods to build any graph I would next write the getAllEdges method Then I would write the getNodeCount and getEdgeCount methods which can be easily computed from their respective maps When these work successfully I d write the hasNode hasEdge and getEdgeValue methods Once you write the getEdgeValue method the toString method should show values with the edges Remember to test adding an edge with some value and then adding the same edge but with a different value the new edge should replace the old one I d next write the clear load and write methods Next I d make sure that addEdge updates its LocalInformation and I d write the inDegree outDegree and degree methods I d follow this by writing the getOutNodes getInNodes getOutEdges and getInNodes to test that adding edges works corectly Finally I d write the second constructor and then the removeEdge method and then the removeNode method which will automatically call removeEdge for every edge related to the node being removed both must make LocalInformation updates Again call toString after every mutator to see if the state of the class has been changed correctly Of course you can run JUnit test during this process and that is what we will grade this part of the assinment on Extended Dijkstra s Algorithm Implementing a Graph Algorithm with the HashGraph class In this part of the programming assignment you will implement an extended version of Dijkstra s Algorithm using the HashGraph class as well as various other collection classes This algorithm reads a graph whose edges store integers representing costs and computes the minimum cost shortest paths to all nodes from a given node the user is prompted for this node For any other given node we can compute up the minimum cost to reach it and list the nodes on this path FYI my solution added about 5 lines of code to main The start folder contains the file Dijkstra java which contains some code and many comments to guide you through the implementation I will also summarize the extended Dijkstra Algorithm here Most data is stored as objects from a class named Info which contains the name of a node the cost of the minimum path to reach that node initialzed to infinity and updated in the algorithm and the name of the node before it on the shortest path initialized to and updated in the algorithm Objects of this class are ultimately stored in three collections as the values of keys in a map as the values in a priority queue with the lowest cost having the highest priority this class contains Comparator for this prioritization and temporarily as the values in a set Declare a map and put each node in the graph as a key in the map with its value a new object of Info which is not filled in yet Prompt the user for the name of a starting node in the graph keep prompting if the user enters a node name that is not in the graph Find the Info for this node in the graph and set its cost to since it is the start node the cost to reach it is Put all the Info values not keys from the map into the priority queue So long as the priority queue is not yet empty process another node Remove the highest priority value in the priority queue the one whose cost is lowest initially the start node Call this the min node We now know the least costly path from the start node to min For every node d that is a destination from the min node get d s Info and see if the cost is infinite or greater than the cost of the path from the start node to min plus the cost of the edge from min to d If it is 1 update the cost in Info to this smaller number 2 set the predecessor of d to be min and 3 put this Info into a set of changed Info objects Use an iterator to remove all the changed Info objects from the priority queue and then re add these objects their cost e g priority is different to the priority queue Continue around the loop Print the map note the Info values are filled in with the minimum cost to reach each node and the node preceding it on the minimum path Repeatedly prompt the user for the name of a stopping node in the graph ignore any node name that is not in the graph Find the cost from the start node to that node and list the nodes on the path by repeatedly getting predecessors in the map a Stack will be useful here because we visit nodes backwards from the stopping node to the starting node but want to print the paths forward from the starting node to the stopping node Overall this algorithm uses a stack priority queue set and map most of the collections that we have studied and implemented except queue You can download and run a special Executable version of my Dijkstra program to help you understand the specification of the problem and observe the programmer user interaction that you are to implement Test it on the flightcost txt file typing in later the names of two cities ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/assignments/program5/program.html", "title": "program 5", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n<html>\n\n<head>\n  <title>Program 5</title>\n</head>\n\n<body BGCOLOR=\"white\">\n\n<center>\n<h1>Program 5</h1>\n<h1>\n  Graph Implemented via Collections<br>and<br>An Important Graph Algorithm\n</h1>\n<p>\n<h2>Fundamental Data Structures<br>\nICS-23<br>\n</h2>\n<p>\n</center>\n\n\n<!-- Introduction -->\n\n<a name=\"Introduction\">\n<hr align=\"left\" width=\"33%\">\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\n<tbody>\n<tr valign=\"top\">\n<td width =\"20%\"><b>Introduction</b></td>\n<td width =\"80%\">\nThis programming assignment is designed to improve your knowledge of using\n  collection classes (especially <b>Map</b> and <b>Set</b>), while teaching\n  you important concepts of representing graphs and writing graph-processing\n  algorithms.\nThere are two problems in this assignment.\n<ul>\n<li>The first problem is to write a class named <b>HashGraph</b> that\n   implements the <b>Graph</b> interface, which includes a wide variety of\n   simple and efficient bookkeeping operations on the nodes and edges in a\n   directed graph.\n<p>\n<li>The second problem involves implementing an important graph algorithm using\n      <b>HashGraph</b>.\n    The algorithms is Dijkstra's all-shortest-paths algorithm\n</ul>\n<p>\nWhen writing <b>HashGraph</b>, you will run it against my JUnit tests to verify\n  (a bit too strong of a word here) that it is correct.\nYou may also find it useful to test your class with the <b>DriverForGraph</b>.\nWith this driver, you can individually test any methods in your classes\n  interactively, and see their results (returned values and state changes,\n  mostly using <b>toString</b>).\nBoth the JUnit test and driver are included in the start project folder for\n  this project.\nI have also included the Javadoc for the <b>HashGraph</b> class (built from\n  the comments in the <b>.java</b> file.\n<p>\nYou are already familiar with classes implementing the <b>Map</b> and\n  <b>Set</b> interfaces; use the standard <b>HashMap</b> and <b>HashSet</b>\n  implementations (actually, I will write the <b>HashSet</b> implementation\n  over the weekend: for now use <b>ArraySet</b> to work on your program, and\n  just substitute <b>HashSet</b> for <b>ArraySet</b> when I send email\n  telling you where to get <b>HashSet</b>; the only difference will be\n  the speed of the operations on these two different set representations).\n<p>\nYou will implement the <b>HashGraph</b> class using these interfaces/classes,\n  along with two simple inner classes that I have implemented specially for\n  this assignment: <b>SimpleEdge</b> (which is a lot like <b>SimpleEntry</b>\n  for <b>HashMap</b>: a class implementing <b>Graph.Edge</b>) and\n  <b>LocalInformation</b>.\nI have provided a <b>HashGraph</b> class with Javadoc comments for all\n  its methods, along with full implementations of the <b>SimpleEdge</b> and\n  <b>LocalInformation</b> classes; change only the former, not the final two\n  (but definitely read and understand their code).\n<p>\nI have also provided an interface named <b>EdgeValueIO</b> (in the file\n  <b>EdgeValueIO.java</b>) and various simple classes implementing this\n  interface for standard edge values; examine these files briefly (mostly\n  their information is used in the <b>load</b> and <b>write</b> methods,\n  which need to translate to/from <b>String</b> information (in files).\n<p>\nDownload and unzip the following <a href=\"program5start.zip\">Eclipse project\n  Start</a> and use it to start working on this program.\nFor each part of this assignmnment you will update and turn in a single\n  <b>.java</b> file in the project (see the <b>Checkmate</b> submission for\n  this assignment for more details).\n<p>\n<b>Only one student should submit the assignment</b>, but both student's names\nshould appear in the comments at the top of <b>each submitted program</b>.\nPlease turn in each program as you finish it, so that I can accurately assess\n  the progress of the class as a whole during this assignment.\n<p>\nPrint this document and carefully read it, marking any parts that contain\n  important detailed information that you find (for review while you work on\n  this assignment and before you turn in the files).\n</td>\n</tbody>\n</table>\n\n\n<!-- Graph -->\n\n<a name=\"Graph\">\n<hr align=\"left\" width=\"33%\">\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\n<tbody>\n<tr valign=\"top\">\n<td width =\"20%\"><b>The HashGraph Class</b></td>\n<td width =\"80%\">\nThe start folder contains one main file to examine/update:\n  <b>HashGraph.java</b>; but there are lots of others (most importantly\n  <b>Graph.java</b>) to read and understand.\nYou can download and run a special\n  <a href=\"ExecutableDriver.zip\">Executable</a>\n  version of my <b>DriverForGraph</b> to help you understand the specification\n  of the problem and observe the programmer/user interaction that you are to\n  implement.\nI suggest your create a few small graphs (with int edges), enter them using\n  this driver, and then call various methods on the graph to see their\n  behavior.\n<p>\nThe <b>HashGraph</b> class acts as a repository for all the nodes and edges\n  that comprise a graph, organized in such a way that allows us quickly to\n  access information that is useful in graph algorithms.\nPart of the complexity comes from keeping (and updating) redundant information.\n<p>\nWe will represent each graph primarily using two maps: one with nodes as keys\n  and one with edges as keys.\nWith this representation, it is easy to <b>get...</b> all the nodes and edges\n  directly connected to some node, and <b>get...</b> the value associated with\n  any edge.\n<ul>\n<li><b>nodeMap</b> maps its key (a node name represented by a <b>String</b>)\n      to its value: a <b>LocalInformation</b> object that stores four sets:\n     <ol>\n       <li>nodes with edges that lead to them from this node\n            (destination nodes with this node is their <b>origin</b> node)\n       <li>nodes whose edges lead to this node\n             (origin nodes with this node as their <b>destination</b> node),\n       <li>edges leading to other nodes from this node,\n            (all edges with this node is their <b>origin</b> node)\n       <li>edges from other nodes leading to this node\n            (all edges with this node is their <b>destination</b> node)\n    </ol>\n<p>\n<li><b>edgeMap</b> maps its key (an <b>Edge</b>) to its value (an object of\n        generic type <b>E</b>, often using a <b>String</b> or wrapper class\n        for the edge's value; but we can use any class for this value).\n</ul>\nClarification: Although there is an accessor named <b>getValue</b> in the\n  <b>SimpleEdge</b> class (along with <b>getOrigin</b> and\n  <b>getDestination</b> edge values ARE NOT stored in <b>SimpleEdge</b> objects\n  (examine that class).\nInstead they are retrieved from the <b>edgeMap</b> in <b>getValue</b> by using \n  the <b>SimpleEdge</b> object as a key (which stores only the origin and\n  destination node).\n<p>\nWe partition the connected nodes into two sets: outgoing and incoming, by\n  using the <b>outNodes</b> and <b>inNodes</b> instance variables in the\n   <b>LocalInformation</b> class.\nLikewise, we partition the edges into two sets: outgoing and incoming, by\n  using the <b>outEdges</b> and <b>inEdges</b> instance variables in the\n   <b>LocalInformation</b> class.\n<p>\nAll these sets could be computed when necessary from the main maps, but it \n  is more efficient to cache their values and then be able to use these values\n  directly, without (re)computing them.\nThe downside of caching is that it takes more space and whenever we udpate the\n  main maps, we must also update the related <b>LocalInformation</b> sets too,\n  which is where most of the complexity of this programming assignment comes\n  from.\n<p>\nA variety of methods return <b>Iterable</b> objects: typically this means that\n  they return sets of nodes or edges, because we keep track of most\n  <b>LocalInformation</b> in sets and the <b>Set</b> interface extends\n  <b>Iterable</b>.\nThe code using such an <b>Iterable</b> object can easily turn it into a\n  concrete <b>Set</b> or <b>List</b> by supplying the <b>Iterable</b> object\n  to a constructor from a class.\n<p>\nThese iterators should NOT allow their <b>remove</b> method to work; we\n  don't want code with access to an iterator for nodes or edges to remove\n  those nodes or edges directly (which would cause all sorts of\n  inconsistencies with the other cached values; a programmer could wreck our\n  carefully controlled data structures).\nRemoval should be done only by the <b>HashGraph</b> methods.\nTo aid you in this task, I have supplied a decorator for <b>Iterable</b>\n  named <b>Unremovable</b>, which delegates <b>hasNext</b> and <b>next</b>\n  to the original <b>Iterable</b> object supplied to its constructor, but\n  throws <b>UnsupportedOperationException</b> whenever <b>remove</b> is\n  called.\n<p>\nHere is a brief list of all the methods in the <b>Graph</b> interface.\nAll of these methods are documented more fully in the class you are writing.\nI have already written some of the bodies of these methods; others you must\n  write.\n<ul>\n  <li>There are two constructors: one constructs an empty graph, another\n        constructs a graph that is a copy of its graph parameter.\n  <p>      \n  <li><b>addNode</b> adds a node (with no outgoing or incoming nodes/edges) to\n        the graph.\n  <li><b>addEdge</b> adds an edge to the graph, updating the\n        <b>LocalInformation</b> for its <b>origin</b> and <b>destination</b>\n        nodes -and adding these nodes automatically, first, if they do not\n        already exist in the graph.\n  <li><b>removeNode</b> removes a node from the graph, as well as all the\n        edges that refer to that node, and updates the <b>LocalInformation</b>\n        for the affected nodes (affected nodes are origin and destination\n        nodes for the removed edges).\n  <li><b>removeEdge</b> removes an edge from the graph,\n        updating the <b>LocalInformation</b> for its <b>origin</b> and\n        <b>destination</b> nodes.\n  <li><b>clear</b> removes all nodes and edges from the graph.\n  <p>\n  <li><b>load</b> reads a graph from a file (see the comment for details)\n  <li><b>write</b> writes a graph to a file (see the comment for details)\n      The details ensure that graphs that are written to a file can then \n        be read back in.\n  <p>\n  <li><b>getNodeCount</b> returns the number of nodes in the graph.\n  <li><b>getEdgeCount</b> returns the number of edges in the graph.\n  <li><b>hasNode</b> determines whether or not a node is in the graph.\n  <li><b>hasEdge</b> determines whether or not an edge is in the graph.\n  <li><b>getEdgeValue</b> returns the value associated with the edge that is\n         its parameter (or <b>null</b> if that edge is not in the graph).\n  <p>\n  <li><b>inDegree</b> returns the number of incoming edges to a node.\n  <li><b>outDegree</b> returns the number of outgoing edges from\n        a node.\n  <li><b>degree</b> returns the number of edges outgoing or incoming to a\n         node.\n  <li><b>getAllNodes</b> returns an <b>Iterable</b> object for all the nodes\n         in the graph (whose <b>remove</b> method is disabled).\n  <li><b>getAllEdges</b> returns an <b>Iterable</b> object for all the\n         edges in the graph (whose <b>remove</b> method is disabled).\n  <li><b>getOutNodes</b> returns an <b>Iterable</b> object for all the\n         nodes in the graph that are desinations of the given node via some\n         edge (whose <b>remove</b> method is disabled).\n  <li><b>getInNodes</b> returns an <b>Iterable</b> object for all the\n         nodes in the graph that are origins of the given node via some\n         edge (whose <b>remove</b> method is disabled).\n  <li><b>getOutEdges</b> returns an <b>Iterable</b> object for all the\n         edges in the graph that have the given nodes as their origin\n         (whose <b>remove</b> method is disabled).\n  <li><b>getInEdges</b> returns an <b>Iterable</b> object for all the\n         edges in the graph that have the given nodes as their destination\n         (whose <b>remove</b> method is disabled).\n  <li><b>toString</b> returns the textual representation of a graph by\n       including all the nodes and edges that it contains; the nodes\n       are sorted in alphabetic order; the out edges are sorted by destination\n       nodes; the in edges are sorted by origin nodes.\n  </ul>\nAlthough this interface contains many methods, many are similar in\n  functionality (and code).\nEach is implemented relatively easily via the powerful collection classes\n  used to represent the graph.\nSome methods, which would normally be <b>void</b> (say <b>addNode</b>) return\n  the entire <b>HashGraph</b> object (see <b>return this;</b> at their end).\nUsing this approach, we can cascade method calls: e.g.,\n<b>g.addNode(\"a\").addNode(\"b\");</b> instead of writing two sequential \n  statements. <b>g.addNode(\"a\"); g.addNode(\"b\");</b>\nThis isn't a huge win, but it is a convenience and you should see this style\n  (any <b>void</b> method can instead be made to return such an object).\n<p>\nOften writing, testing, and debugging one method in a class will immediately\n  lead to the correct code for one (or more) other methods; some simpler\n  methods are called inside other more complicated methods.\nAs with many programming problems, understanding the concepts involved will\n  take lots of time; writing code must come afterward, and it should be more\n  straightforward, although your bugs will lead you to discover yet more \n  information.\n<p>\nThere generally is no exception throwing in these methods.\nWith non-existant nodes/edges as parameters, most of these methods return\n  empty sets (or other special values like <b>null</b>).\nIn other cases, such a removing non-existent nodes/edges, the methods make no\n  state changes and they do NOT throw exceptions.\n<p>\n\n</td>\n</tbody>\n</table>\n\n\n\n<!-- Approach -->\n\n<a name=\"Approach\">\n<hr align=\"left\" width=\"33%\">\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\n<tbody>\n<tr valign=\"top\">\n<td width =\"20%\"><b>Writing/Testing The HashGraph Class</b></td>\n<td width =\"80%\">\nTry to write, test, and debug one method at a time, using the driver in the\n  <b>DriverForGraph</b> class.\nBasically, call <b>toString</b> after every mutator to see if the state of the\n  class has been changed correctly.\n<p>\nI'd start by writing the first constructor and the simplest methods that\n  manipulate <b>nodeMap</b>: <b>addNode</b> and <b>getAllNodes</b> (which is\n  necessary in <b>toString</b> method in <b>HashGraph</b>).\nNext I'd write <b>addEdge</b>: you can try to have it update the\n  <b>LocalInformation</b> for the <b>origin</b> and <b>destination</b> nodes,\n  or I'd suggest leaving that functionality until it is needed later.\nWe use these two methods to build any graph.\n<p>\nI would next write the <b>getAllEdges</b> method.\nThen I would write the <b>getNodeCount</b> and <b>getEdgeCount</b> methods,\n  which can be easily computed from their respective maps.\n<p>\nWhen these work successfully, I'd write the <b>hasNode</b>, <b>hasEdge</b>,\n  and <b>getEdgeValue</b> methods.\nOnce you write the <b>getEdgeValue</b> method, the <b>toString</b> method\n  should show values with the edges.\nRemember to test adding an edge with some value, and then adding the same edge\n  (but with a different value; the new edge should replace the old one).\n<p>\nI'd next write the <b>clear</b>, <b>load</b> and <b>write</b> methods.\n<p>\nNext, I'd make sure that <b>addEdge</b> updates its <b>LocalInformation</b>\n  and I'd write the <b>inDegree</b>, <b>outDegree</b>, and <b>degree</b>\n  methods.\nI'd follow this by writing the <b>getOutNodes</b>, <b>getInNodes</b>, \n  <b>getOutEdges</b>, and <b>getInNodes</b> to test that adding edges\n  works corectly.\n<p>\nFinally, I'd write the second constructor, and then the <b>removeEdge</b>\n  method, and then the <b>removeNode</b> method (which will automatically call\n  <b>removeEdge</b> for every edge related to the node being removed):\n  both must make <b>LocalInformation</b> updates.\nAgain, call <b>toString</b> after every mutator to see if the state of the\n  class has been changed correctly.\n<p>\nOf course, you can run JUnit test during this process, and that is what we\n  will grade this part of the assinment on.\n</td>\n</tbody>\n</table>\n\n\n<!-- Dijkstra's Algorithm -->\n\n<a name=\"Approach\">\n<hr align=\"left\" width=\"33%\">\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\n<tbody>\n<tr valign=\"top\">\n<td width =\"20%\"><b>Extended Dijkstra's Algorithm<br>\n  Implementing a Graph Algorithm with the <b>HashGraph</b> class</b></td>\n<td width =\"80%\">\nIn this part of the programming assignment, you will implement an extended\n  version of Dijkstra's Algorithm, using the <b>HashGraph</b> class -as well\n  as various other collection classes.\nThis algorithm reads a graph whose edges store integers (representing costs)\n  and computes the minimum cost (shortest) paths to all nodes from a given\n  node (the user is prompted for this node).\nFor any other given node, we can compute up the minimum cost to reach it and \n  list the nodes on this path.\nFYI, my solution added about 50 lines of code to <b>main</b>.\n<p>\nThe start folder contains the file <b>Dijkstra.java</b>, which contains some\n  code and many comments to guide you through the implementation.\nI will also summarize the extended Dijkstra Algorithm here.\nMost data is stored as objects from a class named <b>Info</b>, which contains\n  the name of a node, the cost of the minimum path to reach that node\n  (initialzed to +infinity and updated in the algorithm), and the name of the\n  node before it on the shortest path (initialized to <b>\"\"</b> and updated in\n  the algorithm).\nObjects of this class are ultimately stored in three collections: as the values\n  of keys in a map, as the values in a priority queue (with the lowest cost\n  having the highest priority: this class contains <b>Comparator</b> for this\n  prioritization), and temporarily as the values in a set.\n<p>\n<ol>\n<li>Declare a map and put each node in the graph as a key in the map, with\n      its value a new object of <b>Info</b> (which is not filled in yet).\n<p>\n<li>Prompt the user for the name of a starting node in the graph; keep\n      prompting if the user enters a node name that is not in the graph.\n    Find the <b>Info</b> for this node in the graph and set its\n      cost to <b>0</b>: since it is the start node, the cost to reach it is\n      0.\n<p>\n<li>Put all the <b>Info</b> values (not keys) from the map into the priority\n      queue.\n<p>\n<li>So long as the priority queue is not yet empty, process another node.\n<ol>\n  <li>Remove the highest priority  value in the priority queue (the\n        one whose cost is lowest: initially, the start node).\n      Call this the <b>min</b> node.\n      We now know the least costly path from the start node to <b>min</b>.\n  <p>\n  <li>For every node <b>d</b> that is a destination from the <b>min</b> node,\n        get <b>d</b>'s <b>Info</b> and see if the cost is infinite or greater\n        than the cost of the path from the start node to <b>min</b>, plus\n        the cost of the edge from <b>min</b> to <b>d</b>.\n      If it is, (1) update the cost in <b>Info</b> to this smaller number,\n      (2) set the predecessor of <b>d</b> to be <b>min</b>, and\n      (3) put this <b>Info</b> into a set of \"changed\" <b>Info</b> objects.\n  <p>\n  <li>Use an iterator to remove all the changed <b>Info</b> objects from\n        the priority queue, and then re-add these objects (their\n         cost -e.g., priority- is different) to the priority queue.\n  <p>\n  <li>Continue around the loop\n  <p>\n  </ol>\n<li>Print the map: note the <b>Info</b> values are filled in with the\n      minimum cost to reach each node and the node preceding it on\n      the minimum path.\n<p>\n<li>Repeatedly prompt the user for the name of a stopping node in the graph;\n      ignore any node name that is not in the graph.\n    Find the cost from the start node to that node and list the nodes on\n      the path by repeatedly \"getting\" predecessors in the map (a <b>Stack</b>\n      will be useful here, because we visit nodes backwards from the stopping\n      node to the starting node, but want to print the paths forward, from the\n      starting node to the stopping node).\n</ol>\nOverall, this algorithm uses a stack, priority queue, set, and map -most of\n  the collections that we have studied and implemented (except queue).\n<p>\nYou can download and run a special\n  <a href=\"ExecutableDijkstra.zip\">Executable</a>\n  version of my <b>Dijkstra</b> program to help you understand the\n  specification of the problem and observe the programmer/user interaction\n  that you are to implement.\nTest it on the <b>flightcost.txt</b> file, typing in later the names of\n  two cities.\n</td>\n</tbody>\n</table>\n\n\n</table>\n</body>\n</html>\n\n\n", "id": 33537.0}