{"text": "Program 3 Implementing Priority Queues and Maps and their iterators with Binary Trees ICS 46 Data Strcuture Implementation and Analysis Introduction This programming assignment is designed to ensure that you know how to implement two templated classes Priority Queue and Map with binary trees max heap and BST respectively Your implementations will also include fully functional iterators for these classes For the priority queue you will be writing code that processes the underlying array storing the values as a max heap For the map you will be writing iterative and recursive code that processes the BST You can test these implementations by using the standard drivers provided with the download and GoogleTests that we will use when grading your code for correctness recall that you can augment the GoogleTest with whatever code you want to aid your debugging a GoogleTest is just a C program You can also test the code you wrote for Programming Assignment 1 using array implementations of these classes by substituting these binary tree implementations typically by changing a few typedef statements Write and use the standard insertion operator and str method in each class for debugging For str in HeapPriorityQueue return in a std string the entire contents array for all indexes ascending along with the other instance variables from this information you can easily reconstruct the max heap as binary tree For str in BSTMap return a std string that shows the BST rotated left by 9 degrees along with the other instance variables so you can easily examine the structure of the BST Note that there is no tested requirement for what these methods return but the versions above will make debugging easier You should download the program3 project folder and use it to create an Eclipse project ultimately needing to connect it to both the courselib and googletest libraries You will write the required methods in the heap priority queue hpp and bst map hpp files in this project and submit each separately in Checkmate The project folder also contains two pairs of hpp and cpp files a driver GoogleTest pair for each class that you will write and the driver cpp file which has a main function that can be made to run any of the two drivers Instead you can also use a existing working project folder that already is connected to both the courselib and googletest libraries remove but save all the files in its src folder and then put all the hpp and cpp files from the downloaded project s src folder into the existing working project s src folder Important Only one of the cpp files with a main method can be active compiling at any time In the download only the driver cpp file is active the GoogleTests are inactive To make a progam inactive select it in the editor tab use the Ctrl a command to select all its lines and then click Source at the top left of the menu and choose Toggle Comment ever line will now appear in a comment so the main function is commented out by using these same instructions you can toggle back those lines to not have comments I recommend that you work on this assignment in pairs Try to find someone who lives near you with similar programming skills and work habits schedule e g talk about whether you prefer to work mornings nights or weekends what kind of commitment you will make to submit program early Only one student should submit all parts of the the assignment but both student s names along with their UniqueID should appear in the comments at the top of each submitted cpp file It should look something like Romeo Montague UniqueID from grades spreadsheet Juliet Capulet UniqueID from grades spreadsheet We certify that we worked cooperatively on this programming assignment according to the rules for pair programming If you do not know what the terms cooperatively and or rules for pair programming mean please read about Pair Programming before starting this assignment Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files This assignment has 2 parts pairs should work on each part together not split them up and do them separately Part 1 is worth 3 points part 2 is worth 5 points Remember I m going to be running MOSS on the parts of this assignment IMPORTANT The courselib contains array implementations for all these data types and you have written linked list versions of them although this assignment requires you to use binary trees there are still many strong similarities at a high level in all these implementations So I encourage you to examine these implementations closely and understand them possibly experiment with them using their drivers or GoogleTests while you are writing your binary tree implementations this advice is especially true as you begin to study understand and implement iterators Please feel free about asking questions about these methods both their syntax and semantics Priority Queues Priority Queues can be implemented by a variety of data structures where the highest priority value is always removed first How does a specific priority queue determine which value has the highest priority When constructed we supply the priority queue with a gt greater than function that computes whether its first argument has a greater priority than its second argument So we cannot ask What is the priority of a value But we can ask Which of two values has the higher priority using the a gt function For example we cannot ask for the priority of a std string value but we can ask which of two std string values has the higher priority We can implement priority queues efficiently using a max heap stored in an array whose enqueue and dequeue operations are each O Log N When writing the copy constructor and operator use the fact that array being copied are already a max heap to make these operations O N not O N Log N When writing the iterator constructor load the array sequentially with the values produced by the iterator then construct the max heap in O N using the offline algorithm discussed in the notes The file heap priority queue hpp declares the appropriate constructors methods and instance variables Note the simple helper methods left child right child parent is root and in heap which abstract the mapping functions and two useful bool functions Use these methods to simplify writing the helper methods percolate up and percolate down int i which do most of the work in the enqueue and dequeue methods respectively and may be called in other places the iterator s erase method Think carefully about how to write these percolate methods simply or you will never get them properly debugged my method bodies used for loops and were 3 lines and 8 lines long each each using std swap included from utility I suggest copying pasting the methods from the array priority queue hpp file and then translating these methods from using an array to using a max heap since both fundamentally process arrays e g see call the ensure length helper method Pay close attention to ensure all instance variables receive values in the constructors and are used set correctly in queries and commands Iterators There is no simple efficient way to write an iterator for this max heap implementation of priority queues because the iterator is supposed to produce its values from highest to lowest priority but the array is a max heap so we cannot just traverse its values being able to erase values with an iterator makes this task even harder Here is how to implement the iterator for this class Notice the ics HeapPriorityQueue it instance variable in the Iterator class in the HeapPriorityQueue class In the constructor for Iterator the second argument should be true when called from begin and ibegin but false when called from end and iend When it is true the Iterator should copy the ref pq HeapPriorityQueue into the instance variabler it and use this copy for iteration purposes when false it should leave it empty its gt can be nullptr because it won t be used examining the the current iterator value calls peek on it advancing the iterator calls dequeue Overall the cursor is the highest priority value in the it priority queue the one that can be peeked and dequeued To erase a the iterator s cursor use the following algorithm Scan the max heap in the real ref pq priority queue to find the index of the value to erase Use that index like the root in the dequeue algorithm with one difference the value put there from the end of the max heap might have to be percolated up instead of down Look at the iterator erase heap special case GoogleTest to see an example of a max heap construct its array where removing a value f causes the value to percolate up This approach makes the iterators easy to write but expensive in time and space to use especially erase e g storing the second heap requires O N extra space creating the iterator requires O N is O Log N not O 1 erase can be O N since it scans the array representing the heap Feel free to question discuss iterators for HeapPriorityQueue on the message boards so long as no code is posted or described in too much detail Maps Map can be implemented by a variety of data structures they all associate unique keys with values by storing an ics pair holding both the key and its value The data structure should allow us quickly to find the value associated with a key and possibly change update such a value We can implement maps efficiently by using a binary search tree BST whose order property is determined by comparing only the key first part of the pair Most operations updating BSTs are O height of BST which for non pathological BSTs is O Log N When writing the copy constructor and operator use the fact that the BST being copied is already a tree with the correct order property to make these operations O N not O N Log N The file bst map hpp declares the appropriate constructors methods and instance variables Note the many helper methods that operate on BSTs some can be implemented more simply iteratively some more simply recursively Many of the standard map methods call one or more of these helper methods to retrieve information from a BST or change it e g add remove key value assocations These include find key find value insert remove closest remove copy copy to queue delete BST for destructors equals a helper for operator and string rotated a helper for str These methods typically are passed the root of a BST using some parameter mode and if they call themselves recursively recur on a left and or right subtree passing their left right child as the root of a smaller tree I have written boilerplate for all these methods I suggest examining code in the array map hpp file to help you understand some of the bookkeeping requirements of these methods Many of the recursive helper functions you need to write have similar functions in the notes on processing binary trees including BSTs recursively Pay close attention to ensure all instance variables receive values in the constructors and are used set correctly in queries and commands Iterators There is no simple efficient way to write an iterator for this BST implementation of maps even though there is no requirement for the order in which the iterator produces values being able to erase values with an iterator makes this task even harder Note that map iterators produce Entry which is defined by typedef ics pair KEY T Entry Here is how to implement the iterator for this class it has similarities to implementing iterators for the heap priority queue Notice the ics ArrayQueue it instance variable in the Iterator class in the BSTMap class In the constructor for Iterator the second argument should be true when called from begin and ibegin but false when called from end and iend When it is true the Iterator fills the it queue with every key value pair in the BST storing the map and use this queue for iteration purposes when false it should leave it empty examining the current iterator value calls peek on it advancing the iterator calls dequeue Overall the cursor is the front key value pair in the it queue the one that can be peeked and dequeued To erase a the iterator s cursor remove its key value pair from the BST storing the map This approach makes the iterators easy to write but expensive in time to create copying all the key value pairs from the BST to the queue is O N and space storing each key pair value in the BST and in the queue requires O N extra space Feel free to question discuss iterators for BSTMap on the message boards so long as no code is posted or described in too much detail Testing There are various ways to test each of the classes you are writing in this programming assignment First though you should write all the methods paying careful attention to the array implementations and previously written linked list implementations For some you might just boiler plate simple code that is not correct but allows the methods to compile allowing other methods in the classes to be tested The easiest way to start testing debugging is by using the driver program It allows you to perform any method call supported by the templated classes and see the state of the class or view the debugger Of course you must get the insertion operator and str method to work before using it to debug the other methods After you debug your code with the driver try running the appropriate GoogleTest code Again this form of testing is useful only as you approach a finished solution We will use the GoogleTest and visual inspection to grade this assignment Important Note You can put std cout statements in the GoogleTest code but don t accidentally remove any of the assertions otherwise you won t be fully checking your code the way we will while you are debugging your classes All debugging std cout should end in std endl to flush the output stream ensure the output it displayed before executing the next statement When you run the GoogleTest choose small values for the first and third prompts just press return to the second prompt or comment out these prompts and assign small values to these variables instead Besides an indication of which tests pass and fail the console window will show a speed for the speed test which will vary depending on how fast a machine you run your code on don t worry about it When your code is passing all the tests put in values like 1 for these prompts ", "_id": "http://www.ics.uci.edu/~pattis/ICS-46/assignments/program3/program.html", "title": "program 3", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 3</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 3</h1>\r\n<h1>Implementing Priority Queues and Maps<br>\r\n    (and their iterators) with Binary Trees\r\n</h1>\r\n<p>\r\n<h2>ICS-46: Data Strcuture Implementation and Analysis\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to\r\n  implement two templated classes (<b>Priority Queue</b> and <b>Map</b>)\r\n  with binary trees (max-heap and BST respectively).\r\nYour implementations will also include fully-functional iterators for\r\n  these classes.\r\nFor the priority queue you will be writing code that processes the underlying\r\n   array storing the values as a max-heap.\r\nFor the map you will be writing iterative and recursive code that processes the\r\n  BST.\r\n<p>\r\nYou can test these implementations by using the standard drivers (provided\r\n  with the download) and GoogleTests that we will use when grading your\r\n  code for correctness; recall that you can augment the GoogleTest with whatever\r\n  code you want, to aid your debugging: a GoogleTest is just a C++ program.\r\nYou can also test the code you wrote for Programming Assignment #1 (using\r\n  array implementations of these classes) by substituting these binary tree\r\n  implementations -typically by changing a few <b>typedef</b> statements.\r\n<p>\r\nWrite and use the standard <b>insertion</b> (<b>&lt;&lt;</b>) operator and\r\n  <b>str()</b> method in each class for debugging.\r\nFor <b>str</b> in <b>HeapPriorityQueue</b> return in a <b>std::string</b> the\r\n  entire contents array for all indexes (ascending) along with the other\r\n  instance variables: from this information you can easily reconstruct the\r\n  max-heap-as-binary_tree.\r\nFor <b>str</b> in <b>BSTMap</b> return a <b>std::string</b> that shows the BST\r\n  rotated left by 90 degrees  along with the other instance variables, so you\r\n  can easily examine the structure of the BST.\r\nNote that there is no tested requirement for what these methods return, but\r\n  the versions above will make debugging easier.\r\n<p>\r\nYou should download the \r\n  <a href=\"program3.zip\">program3</a> project folder and use it to create an\r\n  Eclipse project (ultimately needing to connect it to both the\r\n  <b>courselib</b> and <b>googletest</b> libraries).\r\nYou will write the required methods in the <b>heap_priority_queue.hpp</b> and\r\n  <b>bst_map.hpp</b> files in this project, and submit each separately in\r\n  Checkmate.\r\nThe project folder also contains two pairs of <b>.hpp</b> and <b>.cpp</b>\r\n  files: a driver/GoogleTest pair for each class that you will write, and the\r\n  <b>driver.cpp</b> file which has a <b>main</b> function that can be made to\r\n  run any of the two drivers.\r\n<p>\r\nInstead, you can also use a existing/working project folder that already is\r\n connected to both the <b>courselib</b> and <b>googletest</b> libraries: remove\r\n  (but save) all the files in its <b>src</b> folder and then put all the\r\n  <b>.hpp</b> and <b>.cpp</b> files from the downloaded project's <b>src</b>\r\n  folder into the existing/working project's <b>src</b> folder.\r\n<p>\r\n<b>Important: Only one of the <b>.cpp</b> files with a <b>main</b> method can\r\n  be active/compiling at any time.</b>\r\nIn the download, only the <b>driver.cpp</b> file is active; the GoogleTests are\r\n  inactive.\r\nTo make a progam inactive, select it (in the editor tab), use the <b>Ctrl/a</b>\r\n  command to select all its lines, and then click <b>Source</b> at the top\r\n  left of the menu and choose <b>Toggle Comment</b>: ever line will now appear\r\n  in a comment (so the <b>main</b> function is commented-out; by using these\r\n  same instructions, you can toggle back those lines to not have comments.\r\n<p>\r\nI recommend that you work on this assignment in pairs\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  student's names (along with their UniqueID) should appear in the comments at\r\n  the top of <b>each submitted .cpp</b> file.\r\nIt should look something like\r\n<pre><b>\r\n//Romeo Montague(UniqueID from grades spreadsheet)\r\n//Juliet Capulet(UniqueID from grades spreadsheet)\r\n//We certify that we worked cooperatively on this programming\r\n//  assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  before starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can accurately\r\n  assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\n<p>\r\n<p>\r\nThis assignment has 2 parts: pairs should work on each part together, not split\r\n  them up and do them separately.\r\nPart 1 is worth 30 points; part 2 is worth 50 points.\r\nRemember I'm going to be running MOSS on the parts of this assignment.\r\n<p>\r\nIMPORTANT: The courselib contains array implementations for all these data\r\n  types (and you have written linked-list versions of them); although this\r\n  assignment requires you to use binary trees, there are still\r\n  <b>many strong similarities</b> at a high level in all these implementations.\r\nSo, I encourage you to examine these implementations closely, and understand\r\n  them; possibly, experiment with them (using their drivers or GoogleTests),\r\n  while you are writing your binary tree implementations: this advice is\r\n  especially true as you begin to study, understand, and implement iterators.\r\nPlease feel free about asking questions about these methods: both their syntax\r\n  and semantics.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- priorityqueue -->\r\n\r\n<a name=\"priorityqueue\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Priority Queues</b></td>\r\n<td width =\"80%\">\r\nPriority Queues can be implemented by a variety of data structures (where the\r\n  highest priority value is always removed first).\r\nHow does a specific priority queue determine which value has the highest\r\n  priority?\r\nWhen constructed, we supply the priority queue with a <b>gt</b> (greater-than)\r\n  function that computes whether its first argument has a greater priority\r\n  than its second argument.\r\nSo, we cannot ask, \"What is the priority of a value.\" But, we can ask \"Which\r\n  of two values has the higher priority\", using the a <b>gt</b> function.\r\nFor example, we cannot ask for the priority of a <b>std::string</b> value, but\r\n  we can ask which of two <b>std::string</b> values has the higher priority.\r\n<p>\r\nWe can implement priority queues efficiently using a max-heap (stored in an\r\n  array), whose <b>enqueue</b> and <b>dequeue</b> operations are each O(Log N).\r\nWhen writing the copy constructor and operator=, use the fact that \"array\r\n  being copied are already a max-heap\" to make these operations O(N) not\r\n  O(N Log N).\r\nWhen writing the iterator constructor, load the array sequentially with the\r\n  values produced by the iterator, then construct the max-heap in O(N) using the\r\n  offline algorithm discussed in the notes.\r\n<p>\r\nThe file <b>heap_priority_queue.hpp</b> declares the appropriate constructors,\r\n  methods, and instance variables.\r\nNote the simple helper methods <b>left_child</b>, <b>right_child</b>, \r\n  <b>parent</b>, <b>is_root</b>, and <b>in_heap</b>, which abstract the\r\n  mapping functions and two useful <b>bool</b> functions:.\r\nUse these methods to simplify writing the helper methods <b>percolate_up</b> and\r\n  <b>percolate_down (int i)</b>, which do most of the work in the <b>enqueue</b>\r\n  and <b>dequeue</b> methods (respectively) and may be called in other places\r\n  (the iterator's <b>erase</b> method).\r\nThink <b>carefully</b> about how to write these percolate methods simply (or you\r\n  will never get them properly debugged): my method bodies used <b>for</b> loops\r\n  and were 3 lines and 8 lines long each (each using <b>std::swap</b>\r\n  included from <b>&lt;utility&gt;</b>.\r\n<p>\r\nI suggest copying/pasting the methods from the <b>array_priority_queue.hpp</b>\r\n  file, and then translating these methods from using an array to using a\r\n  max-heap, since both fundamentally process arrays (e.g., see/call the\r\n  <b>ensure_length</b> helper method).\r\nPay close attention to ensure <b>all instance variables</b> receive values in\r\n  the constructors and are used/set correctly in queries and commands.\r\n<p>\r\n<b>Iterators:</b>\r\nThere is no simple/efficient way to write an iterator for this max-heap\r\n  implementation of priority queues, because the iterator is supposed to\r\n  produce its values from highest to lowest priority, but the array is a\r\n  max-heap (so we cannot just traverse its values); being able to <b>erase</b>\r\n  values with an iterator makes this task even harder.\r\nHere is how to implement the iterator for this class.\r\n<ul>\r\n<li>Notice the <b>ics::HeapPriorityQueue<T> it;</b> instance variable in the\r\n      <b>Iterator</b> class in the <b>HeapPriorityQueue</b> class.\r\n<p>\r\n<li>In the constructor for <b>Iterator</b>, the second argument should be\r\n      <b>true</b> when called from <b>begin</b> and <b>ibegin</b> but\r\n      <b>false</b> when called from <b>end</b> and <b>iend</b>.\r\n<p>\r\n<li>When it is <b>true</b> the <b>Iterator</b> should copy the\r\n      <b>ref_pq HeapPriorityQueue</b> into the instance variabler <b>it</b>\r\n      and use this copy for iteration purposes (when <b>false</b> it should \r\n      leave <b>it</b> empty: its <b>gt</b> can be <b>nullptr</b> because it\r\n      won't be used): examining the the current iterator value calls\r\n      <b>peek()</b> on </b>it</b>; advancing the iterator calls <b>dequeue</b>.\r\n    Overall, the \"cursor\" is the highest priority value in the <b>it</b>\r\n      priority queue (the one that can be peeked and dequeued).\r\n<p>\r\n<li>To <b>erase</b> a the iterator's \"cursor\" use the following algorithm:\r\n    <ol>\r\n       <li>Scan the max-heap in the real (<b>ref_pq</b>) priority queue to find\r\n             the index of the value to erase.\r\n       <li>Use that index like the root in the <b>dequeue</b> algorithm with one\r\n             difference: the value put there from the end of the max-heap might\r\n             have to be percolated up instead of down.\r\n           Look at the <b>iterator_erase_heap_special_case</b> GoogleTest to\r\n             see an example of a max-heap (construct its array), where removing\r\n             a value (<b>\"f\"</b>) causes the value to percolate up.\r\n    </ol>\r\n</ul>\r\nThis approach makes the iterators easy to write but expensive in time and space\r\n  to use (especially erase): e.g., storing the second heap requires O(N) extra\r\n   space; creating the iterator requires O(N); <b>++</b> is O(Log N) not O(1):\r\n   erase can be O(N) since it scans the array representing the heap.\r\n<p>\r\nFeel free to question/discuss iterators for <b>HeapPriorityQueue</b> on the\r\n  message boards, so long as no code is posted or described in too much detail.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- map -->\r\n\r\n<a name=\"priorityqueue\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Maps</b></td>\r\n<td width =\"80%\">\r\nMap can be implemented by a variety of data structures: they all associate\r\n  unique keys with values, by storing an <b>ics::pair</b> holding both the\r\n  key and its value.\r\nThe data structure should allow us quickly to find the value associated with\r\n  a key, and possibly change/update such a value.\r\n<p>\r\nWe can implement maps efficiently by using a binary search tree (BST) whose\r\n  order property is determined by comparing only the key (<b>first</b>) part\r\n  of the <b>pair</b>.\r\nMost operations updating BSTs are O(height of BST) which for non-pathological\r\n  BSTs is O(Log N).\r\nWhen writing the copy constructor and operator=, use the fact that \"the BST\r\n  being copied is already a tree with the correct order property\" to make these\r\n  operations O(N) not O(N Log N).\r\n<p>\r\nThe file <b>bst_map.hpp</b> declares the appropriate constructors, methods, and\r\n  instance variables.\r\nNote the many helper methods that operate on BSTs: some can be implemented\r\n  more simply iteratively, some more simply recursively.\r\nMany of the standard <b>map</b> methods call one or more of these helper\r\n  methods to retrieve information from a BST or change it (e.g., add/remove\r\n  key->value assocations).\r\nThese include: <b>find_key</b>, <b>find_value</b>, <b>insert</b>,\r\n  <b>remove_closest</b>, <b>remove</b>, <b>copy</b>, <b>copy_to_queue</b>,\r\n  <b>delete_BST</b> (for destructors),\r\n  <b>equals</b> (a helper for <b>operator == </b>), and \r\n  <b>string_rotated</b> (a helper for <b>str()</b>).\r\nThese methods typically are passed the root of a BST (using some parameter\r\n  mode), and if they call themselves recursively recur on a left and/or right\r\n  subtree (passing their left/right child as the root of a smaller tree).\r\n<p>\r\nI have written boilerplate for all these methods.\r\nI suggest examining code in the <b>array_map.hpp</b> file to help you understand\r\n  some of the bookkeeping requirements of these methods.\r\nMany of the recursive helper functions you need to write have similar functions\r\n  in the notes on processing binary trees (including BSTs) recursively.\r\nPay close attention to ensure <b>all instance variables</b> receive values in\r\n  the constructors and are used/set correctly in queries and commands.\r\n<p>\r\n<b>Iterators:</b>\r\nThere is no simple/efficient way to write an iterator for this BST\r\n  implementation of maps, even though there is no requirement for the order\r\n  in which the iterator produces values; being able to <b>erase</b> values with\r\n  an iterator makes this task even harder.\r\nNote that map iterators produce <b>Entry</b> which is defined by \r\n  <b>typedef ics::pair&lt;KEY,T&gt; Entry;</b>\r\nHere is how to implement the iterator for this class: it has similarities to\r\n  implementing iterators for the heap priority queue.\r\n<ul>\r\n<li>Notice the <b>ics::ArrayQueue<T> it;</b> instance variable in the\r\n      <b>Iterator</b> class in the <b>BSTMap</b> class.\r\n<p>\r\n<li>In the constructor for <b>Iterator</b>, the second argument should be\r\n      <b>true</b> when called from <b>begin</b> and <b>ibegin</b> but\r\n      <b>false</b> when called from <b>end</b> and <b>iend</b>.\r\n<p>\r\n<li>When it is <b>true</b> the <b>Iterator</b> fills the <b>it</b> queue with\r\n      every key->value pair in the BST storing the map and use this queue for\r\n      iteration purposes (when <b>false</b> it should leave <b>it</b> empty):\r\n      examining the current iterator value calls <b>peek()</b> on\r\n      </b>it</b>; advancing the iterator calls <b>dequeue</b>.\r\n    Overall, the \"cursor\" is the front key->value pair in the <b>it</b>\r\n      queue (the one that can be peeked and dequeued).\r\n<p>\r\n<li>To <b>erase</b> a the iterator's \"cursor\" remove its key->value pair from\r\n      the BST storing the map.\r\n</ul>\r\nThis approach makes the iterators easy to write but expensive in time to\r\n  create (copying all the key->value pairs from the BST to the queue is O(N))\r\n  and space (storing each key->pair value in the BST and in the queue requires\r\n  O(N) extra space).\r\n<p>\r\nFeel free to question/discuss iterators for <b>BSTMap</b> on the\r\n  message boards, so long as no code is posted or described in too much detail.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- testing -->\r\n\r\n<a name=\"testing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Testing</b></td>\r\n<td width =\"80%\">\r\nThere are various ways to test each of the classes you are writing in this\r\n  programming assignment.\r\nFirst, though, you should write all the methods, paying careful attention to\r\n  the array implementations and previously written linked list implementations.\r\nFor some, you might just boiler-plate simple code that is not correct, but\r\n  allows the methods to compile, allowing other methods in the classes to be\r\n  tested.\r\n<p>\r\nThe easiest way to start testing//debugging is by using the driver program.\r\nIt allows you to perform any method call supported by the templated classes,\r\n  and see the state of the class (or view the debugger).\r\nOf course, \r\n<b>you must get the <b>insertion</b> (&lt;&lt;) operator and str() method to\r\n  work before using it to debug the other methods.</b>\r\n<p>\r\nAfter you debug your code with the driver, try running the appropriate\r\n  GoogleTest code.\r\nAgain, this form of testing is useful only as you approach a finished solution.\r\nWe will use the GoogleTest, and visual inspection, to grade this\r\n  assignment.\r\n<b>Important Note</b>: You can put <b>std::cout</b> statements in the GoogleTest\r\n  code (but don't accidentally remove any of the assertions, otherwise\r\n  you won't be fully checking your code the way we will) while you are\r\n  debugging your classes.\r\nAll debugging <b>std::cout</b> should end in <b>std::endl</b> to flush the\r\n  output stream: ensure the output it displayed before executing the next\r\n  statement\r\n<p>\r\nWhen you run the GoogleTest, choose small values for the first and\r\n  third prompts (just press return to the second prompt) or comment-out these\r\n  prompts and assign small values to these variables instead.\r\nBesides an indication of which tests pass and fail, the console window\r\n  will show a speed for the speed test (which will vary depending on how\r\n  fast a machine you run your code on): don't worry about it.\r\nWhen your code is passing all the tests, put in values like 10,000 for these\r\n  prompts.\r\n<p>\r\n\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 11021.0}