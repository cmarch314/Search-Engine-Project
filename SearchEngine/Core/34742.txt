{"text": "Introducing Trees Introduction to Computer Science II ICS 22 Introduction In this lecture we will continue our study of self referential classes by examining trees Like linked lists trees contain nodes these nodes are objects instantiated from a class that contains instance variables that refer to other nodes from this same class Whereas references in the linked list class indicate a follows relationship and in the case of doubly linked lists also a precedes relationship references in tree classes indicate an inclusion relationship where a parent node includes all its children nodes these relationships are much more interesting in terms of the kinds of information that they can represent Although we will first examine general tree structures we will focus most of our attention in this lecture and the next on defining and processing binary trees Within this category we will soon see examples of ordered search trees and structure expression trees We will use ordered search trees primarily to store collections of values that can be searched quickly bringing O Log2N searching to self referential classess just as we did for arrays In a later tree lecture we will examine another kind of ordered tree a heap and it relation to implementing a priority queue with fast enqueue dequeue operations as well as other special kinds of trees N ary trees structure expression trees and digital trees Again in ICS 22 we are just scratching the surface of the topic of trees which are very important in Computer Science Terminology All kinds of trees illustate one important relationship inclusion between parts and a whole another way to describe this relationship is that between a parent node that includes child nodes Every child node has a unique parent every parent node can have any number of children including none As in trees used in geneology we will write each parent node directly above its child ren node s In fact we will use other geneological terms like ancestor and descendant when describing nodes in a tree We draw lines between parent child nodes to illustrate their direct relationship There is one unique node in every tree this node has no parent and is called the root of the tree because all other nodes in the tree are its descendants we write the root node at the top of the tree A mutually exclusive way to classify tree nodes is as internal or leaf An intenal node has one or more children a leaf node has no children So any node that is a parent is an internal node a node that is only a child not a parent to another child is a leaf node Finally we define the size of a tree as the number of nodes that it contains similarly to the length of a linear linked list we define the height of a tree as the length of the longest path each line counts as one step from a root to one of its descendants Alternatively we can define the depth of a node as the number of ancestors it has and then define the height of a tree as the largest depth of any of its nodes Note that the root is at depth because it has no ancestors a tree consisting solely of a root also has a height of The concepts of size and height for trees generalize the length of linear linked list We have already used trees to represent inheritance hierarchies the relationship between classes parents and subclasses children In the bouncing ball program we used the following tree to illustrate the inheritance hierarchy of most of its model classes Let s state some facts about this tree using some of the terminology defined above The root of the tree is labelled Object it is also an internal node The node labelled Simulton is an internal node that has two children the nodes labelled BlackHole MoveableSimulton of course the parent of each of these nodes is Simulton The nodes labelled PulsatingBlackHole Ball Floater and HuntingBlackHole are leaf nodes The ancestors of the node labelled Ball are the nodes labelled Pre its parent MoveableSimulaton its grandparent Simulton its great grandparent and Object its great great grandparent The size of this tree is 9 nodes the height is 4 both Ball and Floater are at depth 4 in the tree Another common example of relationships that can be represented by a tree is the structure of a file directory The root node in a file directory is a folder that is the root of the directory Each of its children is either a file which must be a leaf node or a folder which can itself act as a parent to other children that are files or folders When we study N ary trees which file directories are examples of we will examine recursive methods to compute information like the amount of storage occupied by all the files in a directory A Class for Defining Binary Trees In this section we will begin our detailed study of trees by examining binary trees A binary tree has at most two children each node has children a leaf node or has 1 or 2 children an internal node We can define a class to construct objects nodes for such trees as public class TN public int value public TN left right public TN int i TN l TN r value i left l right r In the standard definition of a binary tree a parent node refers to each of its two left and right subtrees which can be null or refer to child nodes that themselves are trees Of course the null reference denotes an empty tree one with no nodes just as it denotes and empty list As in doubly linked lists we can extend such a class to also include a parent reference instance variable But such references are often not worth the trouble to implement and maintain and we will do without them just as we did without previous references in our study of linked lists In classes that implement collections via trees we typically declare an instance variable named root that stores null or a reference to the root of a tree and use it just as we used front when storing collections in a linked list Recursive Methods for Computing Size and Height In this section we start relating some terminological concepts that we learned to recursive methods that operate on the binary trees defined in the previous section We can write a very simple recursive method for computing the size of a binary tree it is simlar to and generalizes the recursive method that we studied to compute the length of linked list public int size TN t if t null return else return 1 size t left size t right Note that here and in many other recursive methods operating on binary trees we write two recursive calls one to compute the size of the left subtree and one to compute the size of the right subtree We can prove that this method is correct as follows For the base case an empty tree this method returns the correct size nodes The recursive calls are applied to a strictly smaller trees at least one fewer nodes and of at least one smaller height both integers that characterize the size of a tree problem If size t left and size t right correctly compute the number of nodes in the left and right subtrees of t then returning a value one bigger for the root of this subtree than the sum of these values correctly computes the size of the entire list Note that without some kind of array or collection class we CANNOT write this code iteratively If we try to use one cursor as opposed to an array or stack of cursors once we move to one subtree say the left one we have lost our reference to the other right one As always it would be useful to hand simulate this recursive method on a small tree to understand its workings better In a hand simulation calls would go up and down the call frames unlike linear linked list recursion which tends to go down once and then back to the top Here is a iterative method that uses a stack to compute the size of a tree public int size TN t Stack TN s new ArrayStack TN int size s add t while s isEmpty TN next s remove if next null size s add next left s add next right return size We can also write a recursive method to compute the height of tree First we will do so in an intuitive manner then we will write a smaller and simpler to understand method using a bit more sophistication Note that height of a sub tree that is a leaf node is just Also note that the height of an internal node is 1 more than the biggest height of its subtrees Using these facts we can write the following recursive method to compute the height of any non empty tree public int height TN t if t left null t right null leaf check return else if t left null return 1 height t right else if t right null return 1 height t left else return 1 Math max height t left height t right This method deals with all the necessary cases a leaf node an internal node with only a left or only a right subtree and an internal node with both left and right subtrees This method does not work on empty trees which have no directly defined height from the previous definition Now let us simplify this code by defining the height of an empty tree to be 1 In one case this seems very strange but in another it seems obvious an empty tree should have a height that is one less than a leaf node whose height is By using this definition and no others we can simplify the height method as well as defininig it for all possible trees even empty ones into the elegant method below public int height TN t if t null return 1 else return 1 Math max height t left height t right Again if t is a leaf node then its left and right subtrees are empty so this method would preform the recursion and return 1 Math max 1 1 which returns the correct answer for a leaf node So using this generalization of height our code is simpler and always works no matter whether an empty or non empty tree is passed as a parameter in the earlier method passing an empty tree has a parameter would cause Java to throw a NullPointerException when it tried to determine if the node was a leaf Mathematicians generalize definitions such as this one all the time You may or may not know that for a non zero a a is defined as 1 There are many ways to justify this definition some quite complicated the simplest way is to note the algebraic law axay ax y By this law a quite useful one to have a ax a x ax which means that a must be equal to 1 for this identity to hold Mathematics Size Height Relationships We can use the structure of binary trees to derive some mathematical relationships between their sizes and heights First we should reiterate that the inclusion relationships modeled by trees is much more interesting than the follows relationship that is modeled by linear linked lists One way to illustrate the difference in interestingness is by examining all structurally different different looking linked lists containing 4 nodes independent of the values they store there is only one In contrast here is a listing of all the structural different binary trees containing 4 nodes i e of size 4 In a more mathematically advanced class we could deduce a formula that computes the number of structurally different trees containing N nodes this is similar to computing the number of isomers of a chemical molecule We define a pathological tree as one with only one node at each depth all the ones on the bottom In all pathological trees we have height size 1 At the other end of the spectrum is a perfect tree in which every depth is filled with as many nodes as possible none of the trees above satisfy this criteria The picture below shows perfect trees of height 1 2 and 3 If we tabulate this data we have the following information characterizing the height and size of perfect trees heightsize 11327315 If we study and extend this table we can guess a simple but interesting relationship between the height of a perfect tree and its size size 2height 1 1 First verify that this formula is correct for the heights sizes shown Now let s prove it by induction For a perfect tree of height the formula is true by evaluation Lets s assume that this formula is true for all perfect trees of height less than or equal to h and prove that it is true for a tree of height h 1 To construct a perfect tree of height h 1 examine the following picture Then the number of nodes in the entire perfect tree is 1 2h 1 1 2h 1 1 2 h 1 1 1 Which completes the proof for perfect tree of height h 1 Rewriting this equality to express height as a function of size we have height Log2 size 1 1 Now we can also write the original formula as size 2 2height 1 removing the multiplicative and additive constants we have size is O 2height Or solving for height we have height is Log2size Notice the use of because we have lower bound In the next lecture we will learn that the complexity class for searching an ordered binary tree is related to its height for perfect trees the complexity class is O Log2size but in the worst case it is O N If we can keep our binary trees reasonably full we will be able to search them in the same complexity class as searching sorted arrays same for adding and removing elements which was not true for ordered lists while keeping the ordered property Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a TA or any other student Hand simulate the size and height methods discussed in this lecture on empty tress and various small non empty trees Write the method print that prints all values in a binary tree Write the method max that computes the maximum values stored in a binary tree assume the tree is a non empty tree ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/lectures/trees/lecture.html", "title": "introducing trees", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Introducing Trees</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Introducing Trees</h1>\r\n<p>\r\n<h2>Introduction to Computer Science II<br>\r\nICS-22<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture we will continue our study of self-referential classes\r\n  by examining trees.\r\nLike linked lists, trees contain nodes: these nodes are objects instantiated\r\n  from a class that contains instance variables that refer to other nodes from\r\n  this same class.\r\nWhereas references in the linked list class indicate a \"follows\" relationship\r\n  (and in the case of doubly-linked lists also a \"precedes\" relationship),\r\n  references in tree classes indicate an inclusion relationship (where a\r\n  parent node includes all its children nodes): these relationships are much\r\n  more interesting in terms of the kinds of information that they can\r\n  represent.\r\n <p>\r\n Although we will first examine general tree structures, we will focus most of\r\n   our attention in this lecture and the next on defining and processing\r\n   binary trees.\r\nWithin this category we will soon see examples of ordered (search) trees and\r\n  structure (expression) trees.\r\nWe will use ordered search trees primarily to store collections of values that\r\n  can be searched quickly (bringing <b>O(Log<sub>2</sub>N)</b> searching to\r\n  self-referential classess, just as we did for arrays).\r\n<p>\r\nIn a later tree lecture we will examine another kind of ordered tree (a\r\n  heap) and it relation to implementing a priority queue with \"fast\"\r\n  enqueue/dequeue operations, as well as other special kinds of trees\r\n  (N-ary trees, structure/expression trees, and digital trees).\r\nAgain, in ICS-22 we are just scratching the surface of the topic of trees,\r\n  which are very important in Computer Science.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Terminology -->\r\n\r\n<a name=\"Terminology\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Terminology</b></td>\r\n<td width =\"80%\">\r\nAll kinds of trees illustate one important relationship: inclusion between\r\n  parts and a whole; another way to describe this relationship is that between\r\n  a <b>parent</b> node that includes <b>child</b> nodes.\r\nEvery child node has a unique parent; every parent node can have any number of\r\n  children (including none).\r\nAs in trees used in geneology, we will write each parent node directly above\r\n  its child(ren) node(s).\r\nIn fact, we will use other geneological terms, like ancestor and descendant,\r\n  when describing nodes in a tree.\r\nWe draw lines between parent/child nodes to illustrate their direct\r\n  relationship.\r\n<p>\r\nThere is one unique node in every tree: this node has no parent and is called\r\n  the <b>root</b> of the tree; because all other nodes in the tree are its\r\n  descendants, we write the root node at the top of the tree.\r\n<p>\r\nA mutually exclusive way to classify tree nodes is as <b>internal</b> or\r\n  <b>leaf</b>.\r\nAn intenal node has one or more children; a leaf node has no children.\r\nSo, any node that is a parent is an internal node; a node that is only a child\r\n  (not a parent to another child) is a leaf node.\r\n<p>\r\nFinally, we define the <b>size</b> of a tree as the number of nodes that it\r\n  contains (similarly to the length of a linear linked list); we define the\r\n  <b>height</b> of a tree as the length of the longest path (each line counts\r\n  as one step) from a root to one of its descendants.\r\nAlternatively, we can define the <b>depth</b> of a node as the number of\r\n  ancestors it has, and then define the height of a tree as the largest depth\r\n  of any of its nodes.\r\nNote that the root is at depth 0, because it has no ancestors; a tree\r\n  consisting solely of a root also has a height of 0.\r\nThe concepts of size and height for trees generalize the length of linear\r\n  linked list.\r\n<p>\r\nWe have already used trees to represent inheritance hierarchies: the\r\n  relationship between classes (parents) and subclasses (children).\r\nIn the bouncing ball program, we used the following tree to illustrate the\r\n  inheritance hierarchy of most of its model classes.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/tree.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nLet's state some facts about this tree using some of the terminology defined\r\n  above.\r\n<ul>\r\n<li>The root of the tree is labelled <b>Object</b> (it is also an internal\r\n      node).\r\n<li>The node labelled <b>Simulton</b> is an internal node that has two\r\n      children: the nodes labelled <b>BlackHole</b>, <b>MoveableSimulton</b>;\r\n      of course, the parent of each of these nodes is <b>Simulton</b>.\r\n<li>The nodes labelled <b>PulsatingBlackHole</b>, <b>Ball</b>, <b>Floater</b>,\r\n      and <b>HuntingBlackHole</b> are leaf nodes.\r\n<li>The ancestors of the node labelled <b>Ball</b> are the nodes labelled\r\n          <b>Pre</b> (its parent), <b>MoveableSimulaton</b> (its grandparent), \r\n          <b>Simulton</b> (its great-grandparent), and <b>Object</b> (its\r\n          great-great-grandparent). \r\n<li>The size of this tree is 9 nodes; the height is 4 (both <b>Ball</b> and\r\n      <b>Floater</b> are at depth 4 in the tree.\r\n</ul>\r\nAnother common example of relationships that can be represented by a tree is\r\n  the structure of a file directory.\r\nThe root node in a file directory is a folder that is the root of the\r\n  directory.\r\nEach of its children is either a file (which must be a leaf node) or a folder\r\n  (which can itself act as a parent to other children that are files or\r\n   folders).\r\nWhen we study N-ary trees (which file directories are examples of) we will\r\n  examine recursive methods to compute information like the amount of storage\r\n  occupied by all the files in a directory.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Binary Search Trees -->\r\n\r\n<a name=\"Class\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Class for Defining Binary Trees</b></td>\r\n<td width =\"80%\">\r\nIn this section we will begin our detailed study of trees by examining binary\r\n  trees.\r\nA binary tree has at most two children (each node has 0 children -a leaf node-\r\n   or has 1 or 2 children -an internal node).\r\nWe can define a class to construct objects/nodes for such trees as\r\n<pre><b>  public class TN {\r\n    public int value;\r\n    public TN  left,right;\r\n\r\n    public TN (int i, TN l, TN r)\r\n    {value = i; left = l; right = r;}\r\n  }</b></pre>\r\nIn the standard definition of a binary tree, a parent node refers to each of\r\n  its two (left and right) subtrees (which can be <b>null</b> or refer to\r\n  child nodes that themselves are trees).\r\nOf course, the <b>null</b> reference denotes an \"empty\" tree (one with no \r\n  nodes), just as it denotes and empty list.\r\n<p>\r\nAs in doubly-linked lists, we can extend such a class to also include a\r\n  \"parent\" reference instance variable.\r\nBut, such references are often not worth the trouble to implement and\r\n  maintain, and we will do without them (just as we did without \"previous\"\r\n  references in our study of linked lists.\r\n<p>\r\nIn classes that implement collections via trees, we typically declare an\r\n  instance variable named <b>root</b> that stores <b>null</b> or a reference\r\n  to the root of a tree (and use it just as we used <b>front</b> when storing\r\n  collections in a linked list).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Size and Height -->\r\n\r\n<a name=\"Sizes\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Recursive Methods for Computing Size and Height</b></td>\r\n<td width =\"80%\">\r\nIn this section we start relating some terminological concepts that we learned \r\n  to recursive methods that operate on the binary trees defined in the\r\n  previous section.\r\nWe can write a very simple recursive method for computing the size of a binary\r\n  tree; it is simlar to (and generalizes) the recursive method that we studied\r\n  to compute the length of linked list.\r\n  <pre><b>  public int size (TN t)\r\n  {\r\n    if (t == null)\r\n      return 0;\r\n    else\r\n      return 1 + size(t.left) + size(t.right);\r\n  }</b></pre>\r\nNote that here (and in many other recursive methods operating on binary trees)\r\n  we write two recursive calls: one to compute the size of the left subtree\r\n  and one to compute the size of the right subtree.\r\n<p>\r\nWe can prove that this method is correct as follows.\r\n<ul>\r\n<li>For the base case (an empty tree) this method returns the correct size: 0\r\n       nodes.\r\n<li>The recursive calls are applied to a strictly smaller trees (at least one\r\n      fewer nodes and of at least one smaller height: both integers that\r\n      characterize the size of a tree/problem).\r\n<li>If <b>size(t.left)</b> and <b>size(t.right)</b> correctly compute the\r\n      number of nodes in the left and right subtrees of <b>t</b>, then\r\n      returning a value one bigger (for the root of this subtree) than the sum\r\n      of these values correctly computes the size of the entire list.\r\n</ul>\r\nNote that without some kind of array or collection class, we CANNOT write this\r\n  code iteratively.\r\nIf we try to use one cursor (as opposed to an array or stack of cursors) once\r\n  we move to one subtree (say the left one) we have lost our reference to the\r\n  other (right) one.\r\nAs always, it would be useful to hand simulate this recursive method on a\r\n  small tree to understand its workings better.\r\nIn a hand simulation, calls would go up and down the call frames, unlike\r\n  linear (linked list) recursion, which tends to go down once and then back\r\n  to the top.\r\n<p>\r\nHere is a iterative method that uses a stack to compute the size of a tree\r\n  <pre><b>  public int size (TN t)\r\n  {\r\n    Stack&lt;TN&gt; s    = new ArrayStack&lt;TN&gt;();\r\n    int       size = 0;\r\n    s.add(t);\r\n    while (!s.isEmpty()) {\r\n      TN next = s.remove();\r\n      if (next != null) {\r\n        size++;\r\n        s.add(next.left);\r\n        s.add(next.right);\r\n      }\r\n    }\r\n\r\n    return size;\r\n  }</b></pre>\r\n<p>\r\nWe can also write a recursive method to compute the height of tree.\r\nFirst, we will do so in an intuitive manner; then we will write a smaller and\r\n  simpler to understand method using a bit more sophistication.\r\n<p>\r\nNote that height of a (sub)tree that is a leaf node is just 0.\r\nAlso note that the height of an internal node is 1 more than the biggest\r\n  height of its subtrees.\r\nUsing these facts we can write the following recursive method to compute the\r\n  height of any non-empty tree.\r\n<pre><b>  public int height (TN t)\r\n  {\r\n    if (t.left == null && t.right == null) //leaf check\r\n      return 0;\r\n    else if (t.left == null)\r\n      return 1 + height(t.right);\r\n    else if (t.right == null)\r\n      return 1 + height(t.left);\r\n    else\r\n      return 1 + Math.max(height(t.left),height(t.right));\r\n  }</b></pre>\r\nThis method deals with all the necessary cases: a leaf node, an internal node\r\n  with only a left (or only a right) subtree, and an internal node with both\r\n  left and right subtrees.\r\nThis method does not work on empty trees, which have no directly defined\r\n  height from the previous definition.\r\n<p>\r\nNow, let us simplify this code by defining the height of an empty tree to be\r\n  -1.\r\nIn one case this seems very strange, but in another it seems obvious: an empty\r\n  tree should have a height that is one less than a leaf node (whose height is\r\n  0).\r\nBy using this definition (and no others), we can simplify the <b>height</b>\r\n  method (as well as defininig it for all possible trees, even empty ones) into\r\n  the elegant method below.\r\n<pre><b>  public int height (TN t)\r\n  {\r\n    if (t == null)\r\n      return -1;\r\n    else\r\n      return 1 + Math.max(height(t.left),height(t.right));\r\n  }</b></pre>\r\nAgain, if <b>t</b> is a leaf node, then its left and right subtrees are empty,\r\n  so this method would preform the recursion and return\r\n  <b>1 + Math.max(-1,-1)</b> which returns 0 (the correct answer for a leaf\r\n  node).\r\nSo, using this generalization of height, our code is simpler and always works\r\n  (no matter whether an empty or non-empty tree is passed as a parameter; in\r\n   the earlier method, passing an empty tree has a parameter would cause Java\r\n   to throw a <b>NullPointerException</b> when it tried to determine\r\n   if the node was a leaf).\r\n<p>\r\nMathematicians generalize definitions such as this one all the time.\r\nYou may or may not know that for a non-zero <b>a</b>, <b>a<sup>0</sup></b> is\r\n  defined as <b>1</b>.\r\nThere are many ways to justify this definition (some quite complicated); the\r\n  simplest way is to note the algebraic law\r\n  <b>a<sup>x</sup>a<sup>y</sup> = a<sup>x+y</sup></b>.\r\nBy this law (a quite useful one to have)\r\n  <b>a<sup>0</sup>a<sup>x</sup> = a<sup>0+x</sup> = a<sup>x</sup></b>; which\r\n  means that <b>a<sup>0</sup></b> must be equal to <b>1</b> for this identity\r\n  to hold.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Size/Height Relationships -->\r\n\r\n<a name=\"Math\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Mathematics Size/Height Relationships</b></td>\r\n<td width =\"80%\">\r\nWe can use the structure of binary trees to derive some mathematical\r\n  relationships between their sizes and heights.\r\nFirst, we should reiterate that the \"inclusion\" relationships modeled by trees\r\n  is much more interesting than the \"follows\" relationship that is modeled by\r\n  linear linked lists.\r\nOne way to illustrate the difference in \"interestingness\" is by examining all\r\n  structurally different (different looking) linked lists containing 4 nodes,\r\n  independent of the values they store: there is only one.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/enumerationlist.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nIn contrast, here is a listing of all the structural different binary trees\r\n  containing 4 nodes (i.e., of size 4)\r\n</tbody>\r\n</table>\r\n  <img src=\"images/enumeration.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nIn a more mathematically advanced class, we could deduce a formula that\r\n  computes the number of structurally different trees containing N nodes (this\r\n  is similar to computing the number of isomers of a chemical molecule).\r\n<p>\r\nWe define a pathological tree as one with only one node at each depth (all the\r\n  ones on the bottom).\r\nIn all pathological trees, we have <b>height = size-1</b>.\r\n<p>\r\nAt the other end of the spectrum is a perfect tree, in which every depth is\r\n  filled with as many nodes as possible (none of the trees above satisfy this\r\n  criteria).\r\nThe picture below shows perfect trees of height 0, 1, 2, and 3.\r\n</tbody>\r\n</table>\r\n  <img src=\"images/full.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nIf we tabulate this data, we have the following information characterizing\r\n  the height and size of perfect trees.\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <th>height</th><th>size</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr><td>0</td><td>1</td>\r\n  <tr><td>1</td><td>3</td>\r\n  <tr><td>2</td><td>7</td>\r\n  <tr><td>3</td><td>15</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\nIf we study and extend this table, we can guess a simple but interesting\r\n  relationship between the height of a perfect tree and its size:\r\n  <b>size = 2<sup>height+1</sup>-1</b>.\r\nFirst, verify that this formula is correct for the heights/sizes shown.\r\nNow, let's prove it by induction.\r\n<ol>\r\n  <li>For a perfect tree of height 0, the formula is true (by evaluation).\r\n <li>Lets's assume that this formula is true for all perfect trees of height\r\n       less than or equal to <b>h</b>, and prove that it is true for a tree of\r\n       height <b>h+1</b>.\r\n     To construct a perfect tree of height <b>h+1</b> examine the following\r\n       picture.\r\n     <img src=\"images/heightproof.gif\"></image>\r\n     Then the number of nodes in the entire perfect tree is \r\n        <b><pre>1 + 2<sup>h+1</sup>-1 + 2<sup>h+1</sup>-1 = 2<sup>(h+1)+1</sup>-1</pre></b>\r\n     Which completes the proof for perfect tree of height <b>h+1</b>.\r\n  </ol>\r\n  <p>\r\n  Rewriting this equality to express height as a function of size, we have,\r\n    <b>height = Log<sub>2</sub>(size+1) - 1</b>.\r\n  <p>\r\nNow, we can also write the original formula as\r\n   <b>size = 2(2<sup>height</sup>)-1</b>; removing the multiplicative and\r\n   additive constants, we have size is <b>O(2<sup>height</sup>)</b>\r\nOr, solving for height, we have height is &Omega;(Log<sub>2</sub>size)</b>.\r\nNotice the use of &Omega;, because we have lower bound.\r\nIn the next lecture we will learn that the complexity class for searching an\r\n  ordered binary tree is related to its height; for perfect trees the\r\n  complexity class is <b>O(Log<sub>2</sub>size)</b>, but in the worst case\r\n  it is O(N).\r\nIf we can keep our binary trees reasonably full, we will be able to search\r\n  them in the same complexity class as searching sorted arrays (same for\r\n  adding and removing elements -which was not true for ordered lists-, while\r\n   keeping the ordered property). \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Hand simulate the <b>size</b> and <b>height</b> methods discussed in\r\n      this lecture on empty tress and various small non-empty trees.\r\n<p>\r\n<li>Write the method <b>print</b> that prints all values in a binary tree.\r\n<p>\r\n<li>Write the method <b>max</b> that computes the maximum values stored in a\r\n      binary tree (assume the tree is a non-empty tree).\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "id": 34742.0}