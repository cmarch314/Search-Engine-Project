{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Delaunay triangulation 3 DelaunayTriangulationTraits 3 TriangulationDataStructure 3 Definition The class Delaunay triangulation 3 represents a three dimensional Delaunay triangulation The user is advised to use the class Triangulation hierarchy 3 rather than this basic Delaunay triangulation class it offers the same functionalities but is much more efficient for large data sets include CGAL Delaunay triangulation 3 h Parameters The first template argument must be a model of the DelaunayTriangulationTraits 3 concept The second template argument must be a model of the TriangulationDataStructure 3 concept It has the default value Triangulation data structure 3 Triangulation vertex base 3 DelaunayTriangulationTraits 3 Triangulation cell base 3 DelaunayTriangulationTraits 3 Inherits FromTriangulation 3 DelaunayTriangulationTraits 3 TriangulationDataStructure 3 Types In addition to those inherited the following types are defined for use by the construction of the Voronoi diagram typedef DelaunayTriangulationTraits 3 Line 3 Line typedef DelaunayTriangulationTraits 3 Ray 3 Ray typedef DelaunayTriangulationTraits 3 Plane 3 Plane typedef DelaunayTriangulationTraits 3 Object 3 Object Creation Delaunay triangulation 3 DelaunayTriangulationTraits 3 TriangulationDataStructure 3 dt DelaunayTriangulationTraits 3 traits DelaunayTriangulationTraits 3 Creates an empty Delaunay triangulation possibly specifying a traits class traits Delaunay triangulation 3 DelaunayTriangulationTraits 3 TriangulationDataStructure 3 dt Delaunay triangulation 3 dt1 Copy constructor template class InputIterator Delaunay triangulation 3 DelaunayTriangulationTraits 3 TriangulationDataStructure 3 dt InputIterator first InputIterator last DelaunayTriangulationTraits 3 traits DelaunayTriangulationTraits 3 Creates a Delaunay triangulation of the points specified by the iterator range first last of value type Point possibly specifying a traits class traits Operations Insertion The following methods overload the corresponding methods of triangulations to ensure the empty sphere property of Delaunay triangulations In the degenerate case when there are cospherical points the Delaunay triangulation is known not to be uniquely defined In this case CGAL chooses a particular Delaunay triangulation using a symbolic perturbation scheme DT 3 Vertex handle dt insert Point p Cell handle start Cell handle Inserts point p in the triangulation and returns the corresponding vertex Similar to the insertion in a triangulation but ensures in addition the empty sphere property of all the created faces The optional argument start is used as a starting place for the search Vertex handle dt insert Point p Locate type lt Cell handle loc int li int lj Inserts point p in the triangulation and returns the corresponding vertex Similar to the above insert function but takes as additional parameter the return values of a previous location query See description of Triangulation 3 locate The following method allows one to insert several points It returns the number of inserted points template class InputIterator int dt insert InputIterator first InputIterator last Inserts the points in the iterator range first last of value type Point Point moving Vertex handle dt move point Vertex handle v Point p Moves the point stored in v to p while preserving the Delaunay property This performs an action semantically equivalent to remove v followed by insert p but is supposedly faster when the point has not moved much Returns the handle to the new vertex Precondition v is a finite vertex of the triangulation Removal When a vertex v is removed from a triangulation all the cells incident to v must be removed and the polyhedral region consisting of all the tetrahedra that are incident to v must be retriangulated So the problem reduces to triangulating a polyhedral region while preserving its boundary or to compute a constrained triangulation This is known to be sometimes impossible the Sch nhardt polyhedron cannot be triangulated She98 However when dealing with Delaunay triangulations the case of such polyhedra that cannot be retriangulated cannot happen so CGAL proposes a vertex removal void dt remove Vertex handle v Removes the vertex v from the triangulation Note that in CGAL 3 we have implemented a new algorithm for retriangulating the hole after the removal In case that you experience problems when removing a vertex the old code can be enabled with a define CGAL DELAUNAY 3 OLD REMOVE 1 Precondition v is a finite vertex of the triangulation template typename InputIterator int dt remove InputIterator first InputIterator beyond Removes the vertices specified by the iterator range first beyond of value type Vertex handle remove is called over each element of the range The number of vertices removed is returned Precondition All vertices of the range are finite vertices of the triangulation Queries Bounded side dt side of sphere Cell handle c Point p Returns a value indicating on which side of the circumscribed sphere of c the point p lies More precisely it returns ON BOUNDED SIDE if p is inside the sphere For an infinite cell this means that p lies strictly either in the half space limited by its finite facet and not containing any other point of the triangulation or in the interior of the disk circumscribing the finite facet ON BOUNDARY if p on the boundary of the sphere For an infinite cell this means that p lies on the circle circumscribing the finite facet ON UNBOUNDED SIDE if p lies outside the sphere For an infinite cell this means that p does not satisfy either of the two previous conditions Precondition dt dimension 3 Bounded side dt side of circle Facet f Point p Returns a value indicating on which side of the circumscribed circle of f the point p lies More precisely it returns in dimension 3 For a finite facet ON BOUNDARY if p lies on the circle ON UNBOUNDED SIDE when it lies in the exterior of the disk ON BOUNDED SIDE when it lies in its interior For an infinite facet it considers the plane defined by the finite facet of the same cell and does the same as in dimension 2 in this plane in dimension 2 For a finite facet ON BOUNDARY if p lies on the circle ON UNBOUNDED SIDE when it lies in the exterior of the disk ON BOUNDED SIDE when it lies in its interior For an infinite facet ON BOUNDARY if the point lies on the finite edge of f endpoints included ON BOUNDED SIDE for a point in the open half plane defined by f and not containing any other point of the triangulation ON UNBOUNDED SIDE elsewhere Precondition dt dimension 2 and in dimension 3 p is coplanar with f Bounded side dt side of circle Cell handle c int i Point p Same as the previous method for facet i of cell c Vertex handle dt nearest vertex Point p Cell handle c Cell handle Returns any nearest vertex to the point p or the default constructed handle if the triangulation is empty The optional argument c is a hint specifying where to start the search Precondition c is a cell of dt Vertex handle dt nearest vertex in cell Point p Cell handle c Returns the vertex of the cell c that is nearest to p A point p is said to be in conflict with a cell c in dimension 3 resp a facet f in dimension 2 iff dt side of sphere c p resp dt side of circle f p returns ON BOUNDED SIDE The set of cells resp facets in dimension 2 which are in conflict with p is connected and it forms a hole template class OutputIteratorBoundaryFacets class OutputIteratorCells std pair OutputIteratorBoundaryFacets OutputIteratorCells dt find conflicts Point p Cell handle c OutputIteratorBoundaryFacets bfit OutputIteratorCells cit Computes the conflict hole induced by p The starting cell resp facet c must be in conflict Then this function returns respectively in the output iterators cit the cells resp facets in conflict bfit the facets resp edges on the boundary that is the facets resp edges t i where the cell resp facet t is in conflict but t neighbor i is not This function can be used in conjunction with insert in hole in order to decide the insertion of a point after seeing which elements of the triangulation are affected Returns the pair composed of the resulting output iterators Precondition dt dimension 2 and c is in conflict with p template class OutputIteratorBoundaryFacets class OutputIteratorCells class OutputIteratorInternalFacets Triple OutputIteratorBoundaryFacets OutputIteratorCells OutputIteratorInternalFacets dt find conflicts Point p Cell handle c OutputIteratorBoundaryFacets bfit OutputIteratorCells cit OutputIteratorInternalFacets ifit Same as the other find conflicts function except that it also computes the internal facets i e the facets common to two cells which are in conflict with p Then this function returns respectively in the output iterators cit the cells resp facets in conflict bfit the facets resp edges on the boundary that is the facets resp edges t i where the cell resp facet t is in conflict but t neighbor i is not ifit the facets resp edges inside the hole that is delimiting two cells resp facets in conflict Returns the Triple composed of the resulting output iterators Precondition dt dimension 2 and c is in conflict with p template class OutputIterator OutputIterator dt vertices in conflict Point p Cell handle c OutputIterator res Similar to find conflicts but reports the vertices which are on the boundary of the conflict hole of p in the output iterator res Returns the resulting output iterator Precondition dt dimension 2 and c is in conflict with p Voronoi diagram CGAL offers several functionalities to display the Voronoi diagram of a set of points in 3D Note that the user should use a kernel with exact constructions in order to guarantee the computation of the Voronoi diagram as opposed to computing the triangulation only which requires only exact predicates Point dt dual Cell handle c Returns the circumcenter of the four vertices of c Precondition dt dimension 3 and c is not infinite Object dt dual Facet f Returns the dual of facet f which is in dimension 3 either a segment if the two cells incident to f are finite or a ray if one of them is infinite in dimension 2 a point Precondition dt dimension 2 and f is not infinite Object dt dual Cell handle c int i same as the previous method for facet c i template class Stream Stream dt draw dual Stream os Sends the set of duals to all the facets of dt into os advanced Checking bool dt is valid bool verbose false Checks the combinatorial validity of the triangulation and the validity of its geometric embedding see Section Also checks that all the circumscribing spheres resp circles in dimension 2 of cells resp facets in dimension 2 are empty When verbose is set to true messages describing the first invalidity encountered are printed bool dt is valid Cell handle c bool verbose false Checks the combinatorial and geometric validity of the cell see Section Also checks that the circumscribing sphere resp circle in dimension 2 of cells resp facet in dimension 2 is empty When verbose is set to true messages are printed to give a precise indication of the kind of invalidity encountered These methods are mainly a debugging help for the users of advanced features advanced See Also CGAL Triangulation hierarchy 3 Next Triangulation hierarchy 3 Tr Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Triangulation_3_ref/Class_Delaunay_triangulation_3.html", "title": "delaunay_triangulation_3&lt;delaunaytriangulationtraits_3,triangulationdatastructure_3&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Triangulation_3_ref/Delaunay_triangulation_3.tex' -->\n<html> <head>  \n<title>Delaunay_triangulation_3&lt;DelaunayTriangulationTraits_3,TriangulationDataStructure_3&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_973\"></A>\n\n<A NAME=\"Cross_link_anchor_974\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_916\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Delaunay_triangulation_3<DelaunayTriangulationTraits_3,TriangulationDataStructure_3>\"></A>\n<h2><I>CGAL::Delaunay_triangulation_3&lt;DelaunayTriangulationTraits_3,TriangulationDataStructure_3&gt;</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe class <I><A HREF=\"Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A></I> represents a three-dimensional\nDelaunay triangulation.\n<P>\n\nThe user is advised to use the class <I><A HREF=\"Class_Triangulation_hierarchy_3.html#Cross_link_anchor_976\">Triangulation_hierarchy_3</A></I> rather\nthan this basic Delaunay triangulation class: it offers the same\nfunctionalities but is much more efficient for large data sets.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Delaunay_triangulation_3.h\">CGAL/Delaunay_triangulation_3.h</A>&gt;</I>\n<P>\n\n<H3>Parameters</H3>\n<P>\n\nThe first template argument must be a model of the\n<I><A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A></I> concept.\n<P>\n\nThe second template argument must be a model of the\n<I><A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A></I> concept.\nIt has the default value <I><A HREF=\"../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008\">Triangulation_data_structure_3</A>&lt;<A HREF=\"Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994\">Triangulation_vertex_base_3</A>&lt;<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>&gt;, <A HREF=\"Class_Triangulation_cell_base_3.html#Cross_link_anchor_990\">Triangulation_cell_base_3</A>&lt;<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>&gt; &gt;</I>.\n<P>\n\n<H3>Inherits From</H3><I><A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>&lt;<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt;</I>\n<P>\n\n<H3>Types</H3>\n<P>\n\nIn addition to those inherited, the following types are defined, for use by the\nconstruction of the Voronoi diagram:\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Line\"></A>\n<A NAME=\"Typedef_Line\"></A>\ntypedef <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Line_3.html#Cross_link_anchor_70\">Line_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Line;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Ray\"></A>\n<A NAME=\"Typedef_Ray\"></A>\ntypedef <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Ray_3.html#Cross_link_anchor_76\">Ray_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Ray;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Plane\"></A>\n<A NAME=\"Typedef_Plane\"></A>\ntypedef <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    Plane;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Object\"></A>\n<A NAME=\"Typedef_Object\"></A>\ntypedef <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>::Object_3\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>;\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>&lt;<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt; dt ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A> traits = <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Creates an empty Delaunay triangulation, possibly specifying a traits class\n<I>traits</I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>&lt;<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt; dt ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A> dt1);</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Copy constructor.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    <A HREF=\"Class_Delaunay_triangulation_3.html#Cross_link_anchor_974\">Delaunay_triangulation_3</A>&lt;<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>,<A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&gt; dt ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    InputIterator first,<BR>\n\nInputIterator last,<BR>\n\n<A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A> traits = <A HREF=\"Concept_DelaunayTriangulationTraits_3.html#Cross_link_anchor_980\">DelaunayTriangulationTraits_3</A>());</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Creates a Delaunay triangulation of the points specified by the iterator range\n<I>[first,last)</I> of value type <I>Point</I>, possibly specifying a traits\nclass <I>traits</I>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Operations</H3>\n<P>\n\n<H3>Insertion</H3>\n<P>\n\nThe following methods overload the corresponding methods of\ntriangulations to ensure the empty sphere property of Delaunay \ntriangulations.\n<P>\n\nIn the degenerate case when there are cospherical points, the Delaunay\ntriangulation is known not to be uniquely defined. In this case, CGAL\nchooses a particular Delaunay triangulation using a symbolic perturbation\nscheme&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:dt-pvr3d-03\">DT03</A>].\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Point___p+_Cell_handle_start_=_Cell_handle69_9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    dt.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\nCell_handle start = Cell_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in the triangulation and returns the corresponding\n vertex. Similar to the insertion in a triangulation, but ensures in\naddition the empty sphere property of all the created faces.\nThe optional argument <I>start</I> is used as a starting place for the search.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert6const_Point___p+_Locate_type_lt+_Cell_handle_loc+_int_li+_int_lj9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    dt.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     Point p,<BR>\n\n<A HREF=\"Class_Triangulation_3#Enum_Locate_type\">Locate_type</A> lt,<BR>\n\nCell_handle loc,<BR>\n\nint li,<BR>\n\nint lj)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts point <I>p</I> in the triangulation and returns the corresponding\n vertex. Similar to the above <I>insert()</I> function, but takes as additional\n parameter the return values of a previous location query.  See description of\n <I><A HREF=\"Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A>::locate()</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following method allows one to insert several points. It returns the\nnumber of inserted points.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_insert6InputIterator_first+_InputIterator_last9;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.insert ( InputIterator first,  InputIterator last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Inserts the points in the iterator range <MATH><I>[.</I></MATH><I>first</I>,\n<I>last</I><MATH><I>.)</I></MATH>, of value type <I>Point</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Point moving</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_move_point6Vertex_handle_v+_const_Point___p9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.move_point ( Vertex_handle v,  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Moves the point stored in <I>v</I> to <I>p</I>, while preserving the Delaunay\nproperty.  This performs an action semantically equivalent to <I>remove(v)</I>\nfollowed by <I>insert(p)</I>, but is supposedly faster when the point has\nnot moved much.  Returns the handle to the new vertex.<BR>\n\n<EM>Precondition: </EM><I>v</I> is a finite vertex of the triangulation.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Removal</H3>\n<P>\n\nWhen a vertex <I>v</I> is removed from a triangulation, all the cells\nincident to <I>v</I> must be removed, and the polyhedral region\nconsisting of all the tetrahedra that are incident to <I>v</I> must be\nretriangulated. \nSo, the problem reduces to triangulating a polyhedral\nregion, while preserving its boundary, or to compute a\n<I>constrained</I> triangulation. This is known to be sometimes\nimpossible: the Sch&ouml;nhardt polyhedron cannot be triangulated\n[<A HREF=\"../biblio.html#Biblio_cgal:s-cgehd-98\">She98</A>].\n<P>\n\nHowever, when dealing with Delaunay triangulations, the case of such\npolyhedra that cannot be retriangulated cannot happen, so C<SMALL>GAL</SMALL> proposes a vertex removal.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.remove ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the vertex <I>v</I> from the triangulation.<BR>\n\nNote that in C<SMALL>GAL</SMALL> 3.0 we have implemented a new algorithm for\nretriangulating the hole after the removal.\nIn case that you experience problems when removing a vertex, the old\ncode can be enabled with a <I>#define CGAL_DELAUNAY_3_OLD_REMOVE 1</I>.<BR>\n\n<EM>Precondition: </EM><I>v</I> is a finite vertex of the triangulation.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt; typename InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_remove6InputIterator_first+_InputIterator_beyond9;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.remove ( InputIterator first,  InputIterator beyond)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the vertices specified by the iterator range [<I>first, beyond</I>)\nof value type <I>Vertex_handle</I>.\n<I>remove()</I> is called over each element of the range.\nThe number of vertices removed is returned.<BR>\n\n<EM>Precondition: </EM>All vertices of the range are finite vertices of the triangulation.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Queries</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_sphere6Cell_handle_c+_const_Point___p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.side_of_sphere ( Cell_handle c,  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a value indicating on which side of the circumscribed sphere\nof <I>c</I> the point <I>p</I> lies. More precisely, it returns:<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the sphere. For an infinite\ncell this means that <I>p</I> lies strictly either in the half space\nlimited by its finite facet and not containing any other point of the\ntriangulation, or in the interior of the disk circumscribing the\n<I>finite</I> facet.<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if p on the boundary of the sphere. For an infinite\ncell this means that <I>p</I> lies on the circle circumscribing\nthe <I>finite</I> facet.<BR>\n\n- <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the sphere. For an\ninfinite cell this means that <I>p</I> does not satisfy either of the\ntwo previous conditions.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_circle6const_Facet___f+_const_Point___p9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.side_of_circle (  Facet f,  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns a value indicating on which side of the circumscribed circle\nof <I>f</I> the point <I>p</I> lies. More precisely, it returns:<BR>\n\n- in dimension&nbsp;3:<BR>\n\n- For a finite facet, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if <I>p</I> lies\non the circle, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> when it lies in the exterior of\nthe disk, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> when it lies in its interior.<BR>\n\n- For an infinite facet, it considers the plane defined by the finite\nfacet of the same cell, and does the same as in dimension&nbsp;2 in this\nplane.<BR>\n\n- in dimension&nbsp;2:<BR>\n\n- For a finite facet, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if <I>p</I> lies\non the circle, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> when it lies in the exterior of\nthe disk, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> when it lies in its interior.<BR>\n\n- For an infinite facet, <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDARY</A></I> if the\npoint lies on the finite edge of <I>f</I> (endpoints included),\n<I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I> for a point in the open half plane defined\nby <I>f</I> and not containing any other point of the triangulation,\n<I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_UNBOUNDED_SIDE</A></I> elsewhere.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and in dimension 3,\n<I>p</I> is <A HREF=\"../Kernel_23_ref/Function_coplanar.html#Cross_link_anchor_197\">coplanar</A> with <I>f</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Bounded_side_side_of_circle6Cell_handle_c+_int_i+_const_Point___p9;\"></A>\n<A HREF=\"../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99\">Bounded_side</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.side_of_circle ( Cell_handle c,  int i,  Point p)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the previous method for facet <I>i</I> of cell <I>c</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_nearest_vertex6Point_p+_Cell_handle_c_=_Cell_handle699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    dt.nearest_vertex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nCell_handle c = Cell_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns any nearest vertex to the point <I>p</I>, or the default constructed\nhandle if the triangulation is empty.  The optional argument <I>c</I> is a hint\nspecifying where to start the search.<BR>\n\n<EM>Precondition: </EM><I>c</I> is a cell of <I>dt</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_nearest_vertex_in_cell6Point_p+_Cell_handle_c9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.nearest_vertex_in_cell ( Point p,  Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the  vertex  of the cell <I>c</I> that is\nnearest to <MATH><I>p</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nA point <I>p</I> is said to be in conflict with a cell <I>c</I> in dimension 3\n(resp. a facet <I>f</I> in dimension 2) iff <I>dt</I>.<I>side_of_sphere(c, p)</I>\n(resp. <I>dt</I>.<I>side_of_circle(f, p)</I>) returns <I><A HREF=\"../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side\">ON_BOUNDED_SIDE</A></I>.\nThe set of cells (resp. facets in dimension 2) which are in conflict with\n<I>p</I> is connected, and it forms a hole.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIteratorBoundaryFacets, class OutputIteratorCells&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_std::pair6OutputIteratorBoundaryFacets+_OutputIteratorCells9_find_conflicts6Point_p+_Cell_handle_c+_OutputIteratorBoundaryFacets_bfit+_OutputIteratorCells_cit9;\"></A>\nstd::pair&lt;OutputIteratorBoundaryFacets, OutputIteratorCells&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    dt.find_conflicts ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nCell_handle c,<BR>\n\nOutputIteratorBoundaryFacets bfit,<BR>\n\nOutputIteratorCells cit)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Computes the conflict hole induced by <I>p</I>.  The starting cell\n(resp.  facet) <I>c</I> must be in conflict.  Then this function returns\nrespectively in the output iterators:<BR>\n\n- <I>cit</I>: the cells (resp. facets) in conflict.<BR>\n\n- <I>bfit</I>: the facets (resp. edges) on the boundary, that is, the facets\n(resp. edges) <I>(t, i)</I> where the cell (resp. facet) <I>t</I> is in\nconflict, but <I>t-&gt;neighbor(i)</I> is not.<BR>\n\nThis function can be used in conjunction with <I>insert_in_hole()</I> in order\nto decide the insertion of a point after seeing which elements of the\ntriangulation are affected.\nReturns the pair composed of the resulting output iterators.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>, and <I>c</I> is in conflict\nwith <I>p</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIteratorBoundaryFacets, class OutputIteratorCells, class OutputIteratorInternalFacets&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Triple6OutputIteratorBoundaryFacets+_OutputIteratorCells+_OutputIteratorInternalFacets9_find_conflicts6Point_p+_Cell_handle_c+_OutputIteratorBoundaryFacets_bfit+_OutputIteratorCells_cit+_OutputIteratorInternalFacets_ifit9;\"></A>\n<A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1584\">Triple</A>&lt;OutputIteratorBoundaryFacets, OutputIteratorCells, OutputIteratorInternalFacets&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    dt.find_conflicts ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nCell_handle c,<BR>\n\nOutputIteratorBoundaryFacets bfit,<BR>\n\nOutputIteratorCells cit,<BR>\n\nOutputIteratorInternalFacets ifit)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the other <I>find_conflicts()</I> function, except that it also \ncomputes the internal facets, i.e. the facets common to two cells which\nare in conflict with <I>p</I>.\nThen this function returns respectively in the output iterators:<BR>\n\n- <I>cit</I>: the cells (resp. facets) in conflict.<BR>\n\n- <I>bfit</I>: the facets (resp. edges) on the boundary, that is, the facets\n(resp. edges) <I>(t, i)</I> where the cell (resp. facet) <I>t</I> is in\nconflict, but <I>t-&gt;neighbor(i)</I> is not.<BR>\n\n- <I>ifit</I>: the facets (resp. edges) inside the hole, that is, delimiting\ntwo cells (resp facets) in conflict.<BR>\n\nReturns the <I><A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1584\">Triple</A></I> composed of the resulting output iterators.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>, and <I>c</I> is in conflict\nwith <I>p</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_vertices_in_conflict6Point_p+_Cell_handle_c+_OutputIterator_res9;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    dt.vertices_in_conflict ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Point p,<BR>\n\nCell_handle c,<BR>\n\nOutputIterator res)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Similar to <I>find_conflicts()</I>, but reports the vertices which are on the\nboundary of the conflict hole of <I>p</I>, in the output iterator <I>res</I>.\nReturns the resulting output iterator.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>, and <I>c</I> is in conflict\nwith <I>p</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Voronoi diagram</H3>\n \n     \n<A NAME=\"Index_anchor_917\"></A> \n \n   \n\nC<SMALL>GAL</SMALL> offers several functionalities to display the Voronoi diagram of \na set of points in 3D.\n<P>\n\nNote that the user should use a kernel with exact constructions in order\nto guarantee the computation of the Voronoi diagram (as opposed to computing\nthe triangulation only, which requires only exact predicates).\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Point_dual6Cell_handle_c9_const;\"></A>\nPoint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.dual ( Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the <A HREF=\"../Kernel_23_ref/Function_circumcenter.html#Cross_link_anchor_165\">circumcenter</A> of the four vertices of c.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I><MATH><I>=3</I></MATH> and <I>c</I> is not infinite.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Object_dual6Facet_f9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    dt.dual ( Facet f)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the dual of facet <I>f</I>, which is<BR>\n\nin dimension 3: either a segment, if the two cells incident to <I>f</I>  \nare finite, or a ray, if one of them is infinite;<BR>\n\nin dimension 2: a point.<BR>\n\n<EM>Precondition: </EM><I>dt</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and <I>f</I> is not infinite.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Object_dual6Cell_handle_c+_int_i9_const;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.dual ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as the previous method for facet <I>(c,i)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class Stream&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Stream___draw_dual6Stream___os9;\"></A>\nStream &amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.draw_dual ( Stream &amp; os)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Sends the set of duals to all the facets of <I>dt</I> into <I>os</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Checking</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.is_valid ( bool verbose = false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Checks the combinatorial validity of the triangulation and the\nvalidity of its geometric embedding (see\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). Also checks that all the\ncircumscribing spheres (resp. circles in dimension&nbsp;2) of  cells\n(resp. facets in dimension&nbsp;2) are empty.<BR>\n\nWhen <I>verbose</I> is set to\ntrue,  messages describing the first invalidity encountered are\nprinted.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6Cell_handle_c+_bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    dt.is_valid ( Cell_handle c,  bool verbose = false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Checks the combinatorial and geometric validity of the cell (see\nSection&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>). Also checks that the\ncircumscribing sphere (resp. circle in dimension&nbsp;2) of  cells\n(resp. facet in dimension&nbsp;2) is empty.<BR>\n\nWhen <I>verbose</I> is set to\ntrue, messages are printed to give\na precise indication of the kind of invalidity encountered.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThese methods are  mainly a debugging help for the users of advanced features.\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Triangulation_hierarchy_3.html#Cross_link_anchor_975\">CGAL::Triangulation_hierarchy_3</A></I>.\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Triangulation_hierarchy_3.html\"><I>Triangulation_hierarchy_3&lt;Tr&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_36!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38203.0}