{"text": "Information Computer Science David G Kay UC Irvine ICS 141 Notes on Scheme Scheme is a lexically scoped dialect of Lisp Functional paradigm but not purely can do OOP imperative even logic Dynamic storage is automatic automatic garbage collection Procedures are first class objects and all procedures are functions Unified numeric types Programming environment Traditionally interactive and interpreted but many non student oriented Scheme systems allow building standalone applications Data in Scheme Characters A Z a z 9 Atom String of characters without blanks Numbers unified booleans t f strings characters List Parentheses enclosing any combination of atom s and list s Nested empty cons and list null a predicate car and cdr IBM 7 4 contents of address decrement register More mnemonically first and rest Vectors Structures define structure rest name cuisine phone dish price make rest n c p d constructor of a rudimentary object rest R type checker rest name R selector Similarly for cuisine phone dish price Evaluation of expressions FUNCTION ARGUMENTS Read eval print loop Quoting So you don t evaluate constants quote blah or blah if cond control structures for selection lambda let creating procedures which are first class objects and local variables display and newline to generate output as a side effect apart from return value Scheme reading list in roughly ascending order by difficulty The Schemer s Guide 2nd ed by Ferguson and Kaufman Schemers Inc 1996 Simply Scheme by Brian Harvey and Matthew Wright MIT Press 1994 Concrete Abstractions by Hailperin Kaiser and Knight PWS 1999 The Schematics of Computation by Manis and Little Prentice Hall 1995 The Little Schemer 4th ed by Friedman and Felleisen SRA 1996 Scheme and the Art of Programming by Springer and Friedman McGraw Hill Structure and Interpretation of Computer Programs 2nd ed by Abelson and Sussman MIT McGraw Hill 1996 See also http www ics uci edu kay courses 22 scheme refs html Defining procedures lambda define Thai lambda R equal Thai rest cuisine R define match cuisine Let user specify which cuisine lambda R C to check for equal C rest cuisine R Define a restaurant collection ADT as a list of restaurants The following examples take advantage of procedures being first class objects in Scheme That is a procedure can take procedures as arguments and can also return a procedure As you go through the following examples ask yourself What is the data type of each argument What is the type of the returned value In some cases the answer will be A procedure that itself takes some arguments and returns some value define find thai return the first Thai restaurant in RC lambda RC cond null RC Thai first RC first RC else find thai rest RC define find match return restaurant that satisfies any test lambda RC test cond null RC test first RC first RC else find match rest RC test Call with find match RC Thai Define Chinese or other predicates to call find match with find match RC lambda R equal Indonesian rest cuisine R You can use anonymous lambda rather than making up a name A function that returns a function this will build a checker for any cuisine define make cuisine checker lambda C make cuisine checker C takes a cuisine lambda R and returns a function that takes a Rest and checks whether its cuisine matches C equal C rest cuisine R define Indonesian make cuisine checker Indonesian find match RC Indonesian find match RC make cuisine checker Indonesian define make checker lambda field selector comparison function value lambda R comparison function field selector R value define cheap make checker rest price 1 find match RC cheap List manipulation Assume the restaurant collection is a Lisp list define all cheap lambda Rlist cond null Rlist t cheap first Rlist all cheap rest Rlist else f define all cheap restaurants lambda Rlist cond null Rlist cheap first Rlist cons first Rlist all cheap restaurants rest Rlist else all cheap restaurants rest Rlist define find all matches lambda Rlist test cond null Rlist test first Rlist cons first Rlist find all matches rest Rlist test else find all matches rest Rlist test define remove all matches lambda Rlist test cond null Rlist test first Rlist remove all matches rest Rlist test else cons first Rlist remove all matches rest Rlist test Notice that find all matches and remove all matches are identical except that the actions in the test clause and the else clause are interchanged We can combine these by including a boolean parameter true if we want to keep matches false if we want to remove them and applying some logic to recognize that we want to cons the first item onto the result of the recursive call if the test and the keep matches parameter are equal both true or both false define handle all matches lambda Rlist test keep matches cond null Rlist equal keep matches test first Rlist cons first Rlist handle all matches rest Rlist test keep matches else handle all matches rest Rlist test keep matches define find all matches lambda Rlist test handle all matches Rlist test t define remove all matches lambda Rlist test handle all matches Rlist test f ", "_id": "http://www.ics.uci.edu/~kay/courses/141/schemenotes.html", "title": "notes on scheme", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Tuesday, February 1, 2000 3:09 PM\">\n<TITLE>Notes on Scheme</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"21A2E910\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Scheme, high-order functions, recusion, list processing\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Class notes for an introduction to functional programming in Scheme, with illustrations of high-order functions and a database of restaurants.  David G. Kay, Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 1995-1999 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<FONT FACE=\"Palatino\">Information &amp; Computer Science &#160; David G.\nKay\n<BR>\nUC Irvine &#160; ICS 141\n<BR>\n<FONT SIZE=5>Notes on Scheme</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Scheme is a lexically scoped dialect of Lisp</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Functional paradigm, but not purely; can do OOP, imperative,\neven logic</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Dynamic storage is automatic (automatic garbage collection)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Procedures are first-class objects (and all procedures\nare functions)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Unified numeric types</FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Programming environment:  Traditionally interactive\nand interpreted, but many non-student-oriented Scheme systems allow building\nstandalone applications.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Data in Scheme:</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Characters:  </FONT><FONT FACE=\"Courier\"><TT>A</TT></FONT><FONT FACE=\"Palatino\">-</FONT><FONT FACE=\"Courier\"><TT>Z\na</TT></FONT><FONT FACE=\"Palatino\">-</FONT><FONT FACE=\"Courier\"><TT>z 0</TT></FONT><FONT FACE=\"Palatino\">-</FONT><FONT FACE=\"Courier\"><TT>9\n% + - * / = ? ! #</TT></FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Atom:  String of characters without blanks</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Numbers (unified), booleans (</FONT><FONT FACE=\"Courier\"><TT>#t</TT></FONT><FONT FACE=\"Palatino\">,\n</FONT><FONT FACE=\"Courier\"><TT>#f</TT></FONT><FONT FACE=\"Palatino\">), strings,\ncharacters</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">List:  Parentheses enclosing any combination of atom(s)\nand list(s).  Nested; empty.</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>cons</TT></FONT><FONT FACE=\"Palatino\"> and </FONT><FONT FACE=\"Courier\"><TT>list</TT></FONT><FONT FACE=\"Palatino\">.</FONT><FONT FACE=\"Courier\"><TT>\nnull?</TT></FONT><FONT FACE=\"Palatino\"> (a predicate)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>car</TT></FONT><FONT FACE=\"Palatino\"> and </FONT><FONT FACE=\"Courier\"><TT>cdr</TT></FONT><FONT FACE=\"Palatino\">\n(IBM 704; contents of address/decrement register).  More mnemonically, &quot;</FONT><FONT FACE=\"Courier\"><TT>first</TT></FONT><FONT FACE=\"Palatino\">&quot;\nand &quot;</FONT><FONT FACE=\"Courier\"><TT>rest</TT></FONT><FONT FACE=\"Palatino\">&quot;</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Vectors.  Structures.  </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(define-structure\nrest (name cuisine phone dish price))</TT></FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">=&gt; </FONT><FONT FACE=\"Courier\"><TT>(make-rest n\nc p d $)</TT></FONT><FONT FACE=\"Palatino\">; constructor of a rudimentary\nobject</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">=&gt; </FONT><FONT FACE=\"Courier\"><TT>(rest? R)</TT></FONT><FONT FACE=\"Palatino\">;\ntype checker</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">=&gt; </FONT><FONT FACE=\"Courier\"><TT>(rest-name R)</TT></FONT><FONT FACE=\"Palatino\">;\nselector.  Similarly for cuisine, phone, dish, price</FONT></LI>\n<BR>\n</UL>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Evaluation of expressions:  (  <I><U><FONT SIZE=2>FUNCTION</FONT></U>\n  <U><FONT SIZE=2>ARGUMENTS</FONT></U> </I> ).  Read-eval-print loop.</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Quoting:  So you don't evaluate &quot;constants&quot;.\n </FONT><FONT FACE=\"Courier\"><TT>(quote blah)</TT></FONT><FONT FACE=\"Palatino\">,\nor </FONT><FONT FACE=\"Courier\"><TT>'blah</TT></FONT><FONT FACE=\"Palatino\">.</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>if, cond</TT></FONT><FONT FACE=\"Palatino\"> -- control\nstructures for selection.</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>lambda</TT></FONT><FONT FACE=\"Palatino\">, </FONT><FONT FACE=\"Courier\"><TT>let</TT></FONT><FONT FACE=\"Palatino\">\n-- creating procedures (which are first-class objects) and local variables</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>display</TT></FONT><FONT FACE=\"Palatino\"> and </FONT><FONT FACE=\"Courier\"><TT>newline</TT></FONT><FONT FACE=\"Palatino\">\n-- to generate output (as a side effect, apart from return value)</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Scheme reading list (in roughly ascending order by\ndifficulty):</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\"><I>The Schemer&#39;s Guide,</I> 2nd ed., by Ferguson\nand Kaufman (Schemers, Inc., 1996)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Simply Scheme,</I> by Brian Harvey and Matthew\nWright (MIT Press, 1994)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Concrete Abstractions,</I> by Hailperin, Kaiser,\nand Knight (PWS, 1999)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>The Schematics of Computation</I> by Manis and\nLittle (Prentice-Hall, 1995)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>The Little Schemer,</I> 4th ed., by Friedman and\nFelleisen (SRA 1996)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Scheme and the Art of Programming,</I> by Springer\nand Friedman (McGraw-Hill)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Structure and Interpretation of Computer Programs,</I>\n2nd ed., by Abelson and Sussman  &#160; (MIT/McGraw-Hill, 1996)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">See also </FONT><FONT FACE=\"Courier\"><TT><A HREF=\"http://www.ics.uci.edu/~kay/courses/22/scheme-refs.html\">http://www.ics.uci.edu/~kay/courses/22/scheme-refs.html</A></TT></FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Defining procedures</FONT><FONT FACE=\"Courier\"><TT>--lambda</TT></FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define Thai?</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (R)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (equal? 'Thai (rest-cuisine\nR))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define match-cuisine? &#160; ; Let user specify\nwhich cuisine</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (R C) &#160;  &#160; ; to\ncheck for</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (equal? C (rest-cuisine R))))</TT></FONT>\n<BR>\n<HR>\n</LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Define a restaurant collection ADT, as a list of restaurants.</FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">(The following examples take advantage of procedures\nbeing first-class objects in Scheme.  That is, a procedure can take procedures\nas arguments and can also <I>return</I> a procedure.  As you go through\nthe following examples, ask yourself, &quot;What is the &#39;data type&#39;\nof each argument?  What is the type of the returned value?&quot;  In some\ncases, the answer will be, &quot;A procedure [that itself takes some arguments\nand returns some value].&quot;)</FONT>\n<BR>\n<FONT FACE=\"Palatino\" SIZE=1>&#160;  </FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define find-thai   ; return the first Thai restaurant\nin RC</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (RC) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((null? RC) '()) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((Thai? (first RC))\n(first RC)) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; (else (find-thai (rest\nRC))))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define find-match  ; return restaurant that satisfies\nany &#39;test?&#39;</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (RC test?) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((null? RC) '()) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((test? (first RC))\n(first RC)) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; (else (find-match\n(rest RC) test?)))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Call with </FONT><FONT FACE=\"Courier\"><TT>(find-match\nRC Thai?)</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Define </FONT><FONT FACE=\"Courier\"><TT>Chinese?</TT></FONT><FONT FACE=\"Palatino\">\nor other predicates to call </FONT><FONT FACE=\"Courier\"><TT>find-match</TT></FONT><FONT FACE=\"Palatino\">\nwith.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (R) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (equal? 'Indonesian (rest-cuisine\nR))))</TT></FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">You can use &quot;anonymous lambda&quot; rather than\nmaking up a name.</FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">A function that returns a function,--this will build\na checker for any cuisine.</FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>(define make-cuisine-checker &#160; </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (C) &#160;    ; (make-cuisine-checker\nC) takes a cuisine</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (lambda (R)  ;  and returns\na function that takes a Rest.</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;                 ;   and checks whether its\ncuisine matches C.</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; (equal? C (rest-cuisine\nR)))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define Indonesian? (make-cuisine-checker 'Indonesian))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC Indonesian?)</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC (make-cuisine-checker 'Indonesian))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define make-checker</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (field-selector comparison-function\nvalue)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (lambda (R)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;     (comparison-function (field-selector\nR) value))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define cheap? (make-checker rest-price &lt; 10.00))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC cheap?)</TT></FONT>\n<HR>\n</LI>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">List manipulation [Assume the restaurant collection\nis a Lisp list]</FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define all-cheap?</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) #t)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  ((cheap? (first Rlist))\n</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  &#160; (all-cheap?\n(rest Rlist)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  (else #f))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define all-cheap-restaurants</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       ((cheap? (first Rlist))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;     (cons (first Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;      &#160;      (all-cheap-restaurants\n(rest Rlist))))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       (else (all-cheap-restaurants\n(rest Rlist))))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define find-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       ((test? (first Rlist))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;     (cons (first Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  &#160;      (find-all-matches\n(rest Rlist) test?)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       (else (find-all-matches\n(rest Rlist) test?)))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define remove-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       ((test? (first Rlist))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;     (remove-all-matches\n(rest Rlist) test?))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       (else (cons (first Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  &#160;         (remove-all-matches\n(rest Rlist)  &#160;  &#160;  &#160;  &#160;                           \n test?))))))</TT></FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Notice that </FONT><FONT FACE=\"Courier\"><TT>find-all-matches</TT></FONT><FONT FACE=\"Palatino\">\nand </FONT><FONT FACE=\"Courier\"><TT>remove-all-matches</TT></FONT><FONT FACE=\"Palatino\">\nare identical except that the actions in the </FONT><FONT FACE=\"Courier\"><TT>test?</TT></FONT><FONT FACE=\"Palatino\">\nclause and the </FONT><FONT FACE=\"Courier\"><TT>else</TT></FONT><FONT FACE=\"Palatino\">\nclause are interchanged.  We can combine these by including a boolean parameter\n(true if we want to keep matches, false if we want to remove them) and applying\nsome logic to recognize that we want to </FONT><FONT FACE=\"Courier\"><TT>cons</TT></FONT><FONT FACE=\"Palatino\">\nthe first item onto the result of the recursive call if the test and the\nkeep-matches parameter are equal--both true or both false. </FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>(define handle-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160; (lambda (Rlist test? keep-matches)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; (cond</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;   ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;   ((equal? keep-matches\n(test? (first Rlist)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;  &#160; (cons (first\nRlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;  &#160;  &#160; (handle-all-matches\n(rest Rlist) test? keep-matches)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;   (else (handle-all-matches\n(rest Rlist) test? keep-matches)))))</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>(define find-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; (handle-all-matches\nRlist test? #t)))</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>(define remove-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; (handle-all-matches\nRlist test? #f)))</TT></FONT></LI>\n</UL>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "id": 2079.0}