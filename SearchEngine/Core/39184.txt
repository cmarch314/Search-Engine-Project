{"text": "Navigation Up Table of Contents Bibliography Index Title Page TriangulationDataStructure 3 Definition 3D triangulation data structures are meant to maintain the combinatorial information for 3D geometric triangulations In CGAL a triangulation data structure is a container of cells 3 faces and vertices faces Each cell gives access to its four incident vertices and to its four adjacent cells Each vertex gives direct access to one of its incident cells which is sufficient to retrieve all the incident cells when needed The four vertices of a cell are indexed with 1 2 and 3 The neighbors of a cell are also indexed with 1 2 3 in such a way that the neighbor indexed by i is opposite to the vertex with the same index see Figure Edges 1 faces and facets 2 faces are not explicitly represented a facet is given by a cell and an index the facet i of a cell c is the facet of c that is opposite to the vertex of index i and an edge is given by a cell and two indices the edge i j of a cell c is the edge whose endpoints are the vertices of indices i and j of c As CGAL explicitly deals with all degenerate cases a 3D triangulation data structure in CGAL can handle the cases when the dimension of the triangulation is lower than 3 see Section Thus a 3D triangulation data structure can store a triangulation of a topological sphere Sd of d 1 for any d 1 1 2 3 The second template parameter of the basic triangulation class see Chapter Triangulation 3 is a triangulation data structure class See Chapter To ensure all the flexibility of the class Triangulation 3 a model of a triangulation data structure must be templated by the base vertex and the base cell classes see TriangulationDataStructure 3 TriangulationVertexBase 3 TriangulationCellBase 3 The optional functionalities related to geometry are compulsory for this use as a template parameter of Triangulation 3 A class that satisfies the requirements for a triangulation data structure class must provide the following types and operations Types TriangulationDataStructure 3 Vertex Vertex type TriangulationDataStructure 3 Cell Cell type TriangulationDataStructure 3 size type Size type unsigned integral type TriangulationDataStructure 3 difference type Difference type signed integral type Vertices and cells are usually manipulated via handles which support the two dereference operators operator and operator TriangulationDataStructure 3 Vertex handle TriangulationDataStructure 3 Cell handle Requirements for Vertex and Cell are described in TriangulationDataStructure 3 Vertex and TriangulationDataStructure 3 Cell typedef Triple Cell handle int int Edge c i j is the edge of cell c whose vertices indices are i and j See Section typedef std pair Cell handle int Facet c i is the facet of c opposite to the vertex of index i See Section The following iterators allow one to visit all the vertices edges facets and cells of the triangulation data structure They are all bidirectional non mutable iterators TriangulationDataStructure 3 Cell iterator TriangulationDataStructure 3 Facet iterator TriangulationDataStructure 3 Edge iterator TriangulationDataStructure 3 Vertex iterator The following circulators allow us to visit all the cells and facets incident to a given edge They are bidirectional and non mutable TriangulationDataStructure 3 Facet circulator TriangulationDataStructure 3 Cell circulator Iterators and circulators are convertible to the corresponding handles thus the user can pass them directly as arguments to the functions Creation TriangulationDataStructure 3 tds Default constructor TriangulationDataStructure 3 tds tds1 Copy constructor All vertices and cells are duplicated TriangulationDataStructure 3 tds tds1 Assignment operator All vertices and cells are duplicated and the former data structure of tds is deleted Vertex handle tds copy tds tds1 Vertex handle v Vertex handle tds1 is copied into tds If v Vertexhandle the vertex of tds corresponding to v is returned otherwise Vertex handle is returned Precondition The optional argument v is a vertex of tds1 void tds swap tds1 Swaps tds and tds1 There is no copy of cells and vertices thus this method runs in constant time This method should be preferred to tds tds1 or tds tds1 when tds1 is deleted after that void tds clear Deletes all cells and vertices tds is reset as a triangulation data structure constructed by the default constructor void tds TriangulationDataStructure 3 Destructor All vertices and cells are deleted and tds itself is deleted Operations Access Functions int tds dimension The dimension of the triangulated topological sphere size type tds number of vertices The number of vertices Note that the triangulation data structure has one more vertex than an associated geometric triangulation if there is one since the infinite vertex is a standard vertex and is thus also counted size type tds number of cells The number of cells Returns if tds dimension 3 Non constant time access functions size type tds number of facets The number of facets Returns if tds dimension 2 size type tds number of edges The number of edges Returns if tds dimension 1 advanced Setting void tds set dimension int n Sets the dimension to n advanced Queries bool tds is vertex Vertex handle v Tests whether v is a vertex of tds bool tds is edge Cell handle c int i int j Tests whether c i j is an edge of tds Answers false when dimension 1 Precondition i j 1 2 3 bool tds is edge Vertex handle u Vertex handle v Cell handle c int i int j Tests whether u v is an edge of tds If the edge is found it computes a cell c having this edge and the indices i and j of the vertices u and v in this order bool tds is edge Vertex handle u Vertex handle v Tests whether u v is an edge of tds bool tds is facet Cell handle c int i Tests whether c i is a facet of tds Answers false when dimension 2 Precondition i 1 2 3 bool tds is facet Vertex handle u Vertex handle v Vertex handle w Cell handle c int i int j int k Tests whether u v w is a facet of tds If the facet is found it computes a cell c having this facet and the indices i j and k of the vertices u v and w in this order bool tds is cell Cell handle c Tests whether c is a cell of tds Answers false when dimension 3 bool tds is cell Vertex handle u Vertex handle v Vertex handle w Vertex handle t Cell handle c int i int j int k int l Tests whether u v w t is a cell of tds If the cell c is found it computes the indices i j k and l of the vertices u v w and t in c in this order There is a method has vertex in the cell class The analogous methods for facets are defined here bool tds has vertex Facet f Vertex handle v int j If v is a vertex of f then j is the index of v in the cell f first and the method returns true Precondition tds dimension 3 bool tds has vertex Cell handle c int i Vertex handle v int j Same for facet c i Computes the index j of v in c bool tds has vertex Facet f Vertex handle v bool tds has vertex Cell handle c int i Vertex handle v Same as the first two methods but these two methods do not return the index of the vertex The following three methods test whether two facets have the same vertices bool tds are equal Facet f Facet g bool tds are equal Cell handle c int i Cell handle n int j bool tds are equal Facet f Cell handle n int j For these three methods Precondition tds dimension 3 Flips Two kinds of flips exist for a three dimensional triangulation They are reciprocal To be flipped an edge must be incident to three tetrahedra During the flip these three tetrahedra disappear and two tetrahedra appear Figure left shows the edge that is flipped as bold dashed and one of its three incident facets is shaded On the right the facet shared by the two new tetrahedra is shaded Figure Flips The following methods guarantee the validity of the resulting 3D combinatorial triangulation Flips for a 2d triangulation are not implemented yet bool tds flip Edge e bool tds flip Cell handle c int i int j Before flipping these methods check that edge e c i j is flippable which is quite expensive They return false or true according to this test void tds flip flippable Edge e void tds flip flippable Cell handle c int i int j Should be preferred to the previous methods when the edge is known to be flippable Precondition The edge is flippable bool tds flip Facet f bool tds flip Cell handle c int i Before flipping these methods check that facet f c i is flippable which is quite expensive They return false or true according to this test void tds flip flippable Facet f void tds flip flippable Cell handle c int i Should be preferred to the previous methods when the facet is known to be flippable Precondition The facet is flippable Insertions The following modifier member functions guarantee the combinatorial validity of the resulting triangulation Vertex handle tds insert in cell Cell handle c Creates a new vertex inserts it in cell c and returns its handle The cell c is split into four new cells each of these cells being formed by the new vertex and a facet of c Precondition tds dimension 3 and c is a cell of tds Vertex handle tds insert in facet Facet f Creates a new vertex inserts it in facet f and returns its handle In dimension 3 the two incident cells are split into 3 new cells in dimension 2 the facet is split into 3 facets Precondition tds dimension 2 and f is a facet of tds Vertex handle tds insert in facet Cell handle c int i Creates a new vertex inserts it in facet i of c and returns its handle Precondition tds dimension 2 i 1 2 3 in dimension 3 i 3 in dimension 2 and c i is a facet of tds Vertex handle tds insert in edge Edge e Creates a new vertex inserts it in edge e and returns its handle In dimension 3 all the incident cells are split into 2 new cells in dimension 2 the 2 incident facets are split into 2 new facets in dimension 1 the edge is split into 2 new edges Precondition tds dimension 1 and e is an edge of tds Vertex handle tds insert in edge Cell handle c int i int j Creates a new vertex inserts it in edge i j of c and returns its handle Precondition tds dimension 1 i j i j 1 2 3 in dimension 3 i j 1 2 in dimension 2 i j 1 in dimension 1 and c i j is an edge of tds Vertex handle tds insert increase dimension Vertex handle star Vertex handle Transforms a triangulation of the sphere Sd of d 1 into the triangulation of the sphere Sd 1 of d 2 by adding a new vertex v v is linked to all the vertices to triangulate one of the two halfspheres of dimension d 1 Vertex star is used to triangulate the second halfsphere when there is an associated geometric triangulation star is in fact the vertex associated with its infinite vertex See Figure The numbering of the cells is such that if f was a face of maximal dimension in the initial triangulation then f v in this order is the corresponding face in the new triangulation This method can be used to insert the first two vertices in an empty triangulation A handle to v is returned Precondition tds dimension d 3 When tds number of vertices star Vertexhandle and star is a vertex of tds Figure insert increase dimension 1 dimensional case template class CellIt Vertex handle tds insert in hole CellIt cell begin CellIt cell end Cell handle begin int i Creates a new vertex by starring a hole It takes an iterator range cell begin cell end of Cell handles which specifies a set of connected cells resp facets in dimension 2 describing a hole begin i is a facet resp an edge on the boundary of the hole that is begin belongs to the set of cells resp facets previously described and begin neighbor i does not Then this function deletes all the cells resp facets describing the hole creates a new vertex v and for each facet resp edge on the boundary of the hole creates a new cell resp facet with v as vertex v is returned Precondition tds dimension 2 the set of cells resp facets is connected and its boundary is connected Removal void tds remove decrease dimension Vertex handle v This operation is the reciprocal of insert increase dimension It transforms a triangulation of the sphere Sd of d 1 into the triangulation of the sphere Sd 1 of d by removing the vertex v Precondition tds dimension d 1 tds degree v tds number of vertices 1 Cell handle tds remove from maximal dimension simplex Vertex handle v Removes v The incident simplices of maximal dimension incident to v are replaced by a single simplex of the same dimension This operation is exactly the reciprocal to tds insert in cell v in dimension 3 tds insert in facet v in dimension 2 and tds insert in edge v in dimension 1 Precondition tds degree v tds dimension 1 advanced Other modifiers The following modifiers can affect the validity of the triangulation data structure void tds reorient Changes the orientation of all cells of the triangulation data structure Precondition tds dimension 1 Vertex handle tds create vertex Vertex v Vertex Adds a copy of the vertex v to the triangulation data structure Vertex handle tds create vertex Vertex handle v Creates a vertex which is a copy of the one pointed to by v and adds it to the triangulation data structure Cell handle tds create cell Cell c Cell Adds a copy of the cell c to the triangulation data structure Cell handle tds create cell Cell handle c Creates a cell which is a copy of the one pointed to by c and adds it to the triangulation data structure Cell handle tds create cell Vertex handle v Vertex handle v1 Vertex handle v2 Vertex handle v3 Creates a cell and adds it into the triangulation data structure Initializes the vertices of the cell its neighbor handles being initialized with the default constructed handle Cell handle tds create cell Vertex handle v Vertex handle v1 Vertex handle v2 Vertex handle v3 Cell handle n Cell handle n1 Cell handle n2 Cell handle n3 Creates a cell initializes its vertices and neighbors and adds it into the triangulation data structure void tds delete vertex Vertex handle v Removes the vertex from the triangulation data structure Precondition The vertex is a vertex of tds void tds delete cell Cell handle c Removes the cell from the triangulation data structure Precondition The cell is a cell of tds template class VertexIt void tds delete vertices VertexIt first VertexIt last Calls delete vertex over an iterator range of value type Vertex handle template class CellIt void tds delete cells CellIt first CellIt last Calls delete cell over an iterator range of value type Cell handle advanced Traversing the triangulation Cell iterator tds cells begin Returns cells end when tds dimension 3 Cell iterator tds cells end Facet iterator tds facets begin Returns facets end when tds dimension 2 Facet iterator tds facets end Edge iterator tds edges begin Returns edges end when tds dimension 1 Edge iterator tds edges end Vertex iterator tds vertices begin Vertex iterator tds vertices end Cell circulator tds incident cells Edge e Starts at an arbitrary cell incident to e Precondition tds dimension 3 Cell circulator tds incident cells Cell handle c int i int j As above for edge i j of c Cell circulator tds incident cells Edge e Cell handle start Starts at cell start Precondition tds dimension 3 and start is incident to e Cell circulator tds incident cells Cell handle c int i int j Cell handle start As above for edge i j of c The following circulators on facets are defined only in dimension 3 though facets are defined also in dimension 2 there are only two facets sharing an edge in dimension 2 Facet circulator tds incident facets Edge e Starts at an arbitrary facet incident to e Precondition tds dimension 3 Facet circulator tds incident facets Cell handle c int i int j As above for edge i j of c Facet circulator tds incident facets Edge e Facet start Starts at facet start Precondition start is incident to e Facet circulator tds incident facets Edge e Cell handle start int f Starts at facet of index f in start Facet circulator tds incident facets Cell handle c int i int j Facet start As above for edge i j of c Facet circulator tds incident facets Cell handle c int i int j Cell handle start int f As above for edge i j of c and facet start f Traversal of the incident cells and the adjacent vertices of a given vertex template class OutputIterator OutputIterator tds incident cells Vertex handle v OutputIterator cells Copies the Cell handles of all cells resp facets in dimension 2 incident to v to the output iterator cells If tds dimension 2 then do nothing Returns the resulting output iterator Precondition v Vertex handle tds is vertex v template class OutputIterator OutputIterator tds incident vertices Vertex handle v OutputIterator vertices Copies the Vertex handles of all vertices incident to v to the output iterator vertices If tds dimension 2 then do nothing Returns the resulting output iterator Precondition v Vertex handle tds is vertex v size type tds degree Vertex handle v Returns the degree of a vertex that is the number of incident vertices Precondition v Vertex handle tds is vertex v advanced Checking bool tds is valid bool verbose false Checks the combinatorial validity of the triangulation by checking the validity of all its cells and vertices See Section Moreover the Euler relation is tested When verbose is set to true messages are printed to give a precise indication on the kind of invalidity encountered advanced I O istream istream is tds Reads a combinatorial triangulation from is and assigns it to tds ostream ostream os tds Writes tds into the stream os The information stored in the iostream is the dimension the number of vertices the number of cells the indices of the vertices of each cell then the indices of the neighbors of each cell where the index corresponds to the preceding list of cells When dimension 3 the same information is stored for faces of maximal dimension instead of cells Has Models CGAL Triangulation data structure 3 See Also TriangulationDataStructure 3 Vertex TriangulationDataStructure 3 Cell Next TriangulationDataStructure 3 Cell Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html", "title": "triangulationdatastructure_3", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './TriangulationDS_3_ref/TriangulationDataStructure_3.tex' -->\n<html> <head>  \n<title>TriangulationDataStructure_3</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1002\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_935\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Concept.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_TriangulationDataStructure_3\"></A>\n<h2><I>TriangulationDataStructure_3</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\n3D-triangulation data structures are meant to maintain the\ncombinatorial information for 3D-geometric triangulations.\n<P>\n\nIn C<SMALL>GAL</SMALL>, a triangulation data structure is a\ncontainer of cells (<MATH><I>3</I></MATH>-faces) and vertices (<MATH><I>0</I></MATH>-faces). Each cell gives\naccess to its four incident vertices and to its four adjacent\ncells. Each vertex gives direct access to one of its incident cells, which is \nsufficient to retrieve all the incident cells when needed.\n<P>\n\nThe four vertices of a cell are indexed with 0, 1, 2 and 3.  The\nneighbors of a cell are also indexed with 0, 1, 2, 3 \nin such a way that the neighbor indexed by <MATH><I>i</I></MATH> is <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex\nwith the same index (see Figure&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-fig-repres\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\nEdges (<MATH><I>1</I></MATH>-faces) and facets (<MATH><I>2</I></MATH>-faces) are not explicitly\nrepresented: a facet is given by a cell and an index (the facet\n<I>i</I> of a cell <I>c</I> is the facet of <I>c</I> that is <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to\nthe vertex of index <I>i</I>) and an edge is given by a cell and two\nindices (the edge <I>(i,j)</I> of a cell <I>c</I> is the edge\nwhose endpoints are the vertices of indices <I>i</I> and <I>j</I> of\n<I>c</I>).\n<P>\n\nAs C<SMALL>GAL</SMALL> explicitly deals with all degenerate cases, a\n3D-triangulation data structure in C<SMALL>GAL</SMALL> can handle the cases when\nthe dimension of the triangulation is lower than&nbsp;3 \n(see Section&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>).\n<P>\n\nThus, a 3D-triangulation data structure can store a triangulation of a\ntopological sphere <MATH><I>S<SUP>d</SUP></I></MATH> of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+1</SUP></I></MATH>, for any <MATH><I>d  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {-1,0,1,2,3}</I></MATH>.\n<P>\n\n<BR>\n\n<BR>\n\n<BR>\n\n\n<P>\n\nThe second template parameter of the basic triangulation class\n(see Chapter&nbsp;<A HREF=\"../Triangulation_3/Chapter_main.html#chapter-Triangulation3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>,\n)\n<I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I> is a triangulation data structure class. (See\nChapter&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#chapter-TDS3\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.)\n<P>\n\nTo ensure all the <B>flexibility</B> of the class <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I>, a\nmodel of a triangulation data structure must be templated by the base vertex\nand the base cell classes (see&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>):\n<I><A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&lt;<A HREF=\"../Triangulation_3_ref/Concept_TriangulationVertexBase_3.html#Cross_link_anchor_987\">TriangulationVertexBase_3</A>,<A HREF=\"../Triangulation_3_ref/Concept_TriangulationCellBase_3.html#Cross_link_anchor_986\">TriangulationCellBase_3</A>&gt;</I>.\nThe optional functionalities related to geometry are compulsory for\nthis use as a template parameter of <I><A HREF=\"../Triangulation_3_ref/Class_Triangulation_3.html#Cross_link_anchor_972\">Triangulation_3</A></I>.\n<P>\n\n<BR>\n\n<BR>\n\n<BR>\n\n\n<P>\n\nA class that satisfies the requirements for a triangulation data structure\nclass must provide the following types and operations.\n<P>\n\n<H3>Types</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004\">TriangulationDataStructure_3::Vertex</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Vertex type\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003\">TriangulationDataStructure_3::Cell</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Cell type\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::size_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Size type (unsigned integral type)\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::difference_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Difference type (signed integral type)\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\nVertices and cells are usually manipulated via <I>handles</I>, which support\nthe two dereference operators <I>operator*</I> and <I>operator-&gt;</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Vertex_handle\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Cell_handle\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nRequirements for <I>Vertex</I> and <I>Cell</I> are described in\n<I><A HREF=\"Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004\">TriangulationDataStructure_3::Vertex</A></I> and\n<I><A HREF=\"Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003\">TriangulationDataStructure_3::Cell</A></I> .\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Edge\"></A>\n<A NAME=\"Typedef_Edge\"></A>\ntypedef <A HREF=\"../STL_Extension_ref/Class_Triple.html#Cross_link_anchor_1584\">Triple</A>&lt;Cell_handle, int, int&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Edge;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>(c,i,j)</I> is the\nedge of cell <I>c</I> whose vertices indices are <I>i</I> and\n<I>j</I>. (See Section&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.)\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Facet\"></A>\n<A NAME=\"Typedef_Facet\"></A>\ntypedef std::pair&lt;Cell_handle, int&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Facet;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>(c,i)</I> is the facet\nof <I>c</I> <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex of index <I>i</I>. (See\nSection&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.)\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following iterators allow one to visit all the vertices, edges, facets\nand cells of the triangulation data structure. They are all\nbidirectional, non-mutable iterators.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Cell_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Facet_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Edge_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Vertex_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nThe following circulators allow us to visit all the cells and facets\nincident to a given edge. They are bidirectional and non-mutable.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Facet_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>::Cell_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nIterators and circulators are convertible to the corresponding handles, thus\nthe user can pass them directly as arguments to the functions.\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> tds;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Default constructor.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> tds (  tds1);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Copy constructor. All vertices and cells are duplicated.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A>&amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     tds =  tds1<A NAME=\"Function_TriangulationDataStructure_3__operator=_6const_TriangulationDataStructure_3___tds19;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Assignment operator. All vertices and cells are duplicated, and the former\ndata structure of <I>tds</I> is deleted.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_copy_tds6const_TriangulationDataStructure_3___tds1+_Vertex_handle_v_=_Vertex_handle699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.copy_tds ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     tds1,<BR>\n\nVertex_handle v = Vertex_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>tds1</I> is copied into <I>tds</I>. If <MATH><I>v != Vertex<SUB>h</SUB>andle()</I></MATH>,\nthe vertex of <I>tds</I> corresponding to <I>v</I> is returned,\notherwise <I>Vertex_handle()</I> is returned.<BR>\n\n<EM>Precondition: </EM>The optional argument <I>v</I> is a vertex of <I>tds1</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_swap6TriangulationDataStructure_3___tds19;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.swap (  &amp; tds1)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Swaps <I>tds</I> and <I>tds1</I>. There is no copy of cells and vertices,\nthus this method runs in constant time. This method should be preferred to\n<I>tds</I>=<I>tds1</I> or <I>tds</I>(<I>tds1</I>) when <I>tds1</I> is deleted after\nthat.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Deletes all cells and vertices. <I>tds</I> is reset as a triangulation\ndata structure constructed by the default constructor.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_~TriangulationDataStructure_369;\"></A>\nvoid ~\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.<A HREF=\"Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Destructor. All vertices and cells are deleted, and <I>tds</I> itself is\ndeleted.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Operations</H3>\n<P>\n\n<H3>Access Functions</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_dimension69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.dimension ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The dimension of the triangulated topological sphere.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_vertices69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of vertices. Note that the triangulation data structure has one\nmore vertex than an associated geometric triangulation, if there is\none, since the infinite vertex is a standard vertex and is thus also\ncounted.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_cells69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_cells ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of cells. Returns 0 if <I>tds</I>.<I>dimension()</I><MATH><I>&lt;3</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Non constant-time access functions</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_facets69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_facets ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of facets. Returns 0 if <I>tds</I>.<I>dimension()</I><MATH><I>&lt;2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_edges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_edges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The number of edges. Returns 0 if <I>tds</I>.<I>dimension()</I><MATH><I>&lt;1</I></MATH>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Setting</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set_dimension6int_n9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.set_dimension ( int n)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Sets the dimension to <I>n</I>.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Queries</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_vertex6Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_vertex ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>v</I> is a vertex of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Cell_handle_c+_int_i+_int_j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_edge ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(c,i,j)</I> is an edge of <I>tds</I>. Answers <I>false</I> when\n<I>dimension()</I> <MATH><I>&lt;1</I></MATH> .<BR>\n\n<EM>Precondition: </EM><MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_u+_Vertex_handle_v+_Cell_handle___c+_int___i+_int___j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.is_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nCell_handle &amp; c,<BR>\n\nint &amp; i,<BR>\n\nint &amp; j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v)</I> is an edge of <I>tds</I>. If the edge is found,\nit computes a cell <I>c</I> having this edge and the indices <I>i</I>\nand <I>j</I> of the vertices <I>u</I> and <I>v</I>, in this order.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_u+_Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_edge ( Vertex_handle u,  Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v)</I> is an edge of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_facet6Cell_handle_c+_int_i9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_facet ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(c,i)</I> is a facet of <I>tds</I>. Answers <I>false</I> when\n<I>dimension()</I> <MATH><I>&lt;2</I></MATH> .<BR>\n\n<EM>Precondition: </EM><MATH><I>i  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_facet6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Cell_handle___c+_int___i+_int___j+_int___k9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.is_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nVertex_handle w,<BR>\n\nCell_handle &amp; c,<BR>\n\nint &amp; i,<BR>\n\nint &amp; j,<BR>\n\nint &amp; k)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v,w)</I> is a facet of <I>tds</I>. If the facet is found,\nit computes a cell <I>c</I> having this facet and the indices <I>i</I>,\n<I>j</I> and <I>k</I> of the vertices <I>u</I>, <I>v</I> and <I>w</I>, in\nthis order.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_cell6Cell_handle_c9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_cell ( Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>c</I> is a cell of <I>tds</I>. Answers <I>false</I> when\n<I>dimension()</I> <MATH><I>&lt;3</I></MATH> .\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_cell6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Vertex_handle_t+_Cell_handle___c+_int___i+_int___j+_int___k+_int___l9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.is_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle u,<BR>\n\nVertex_handle v,<BR>\n\nVertex_handle w,<BR>\n\nVertex_handle t,<BR>\n\nCell_handle &amp; c,<BR>\n\nint &amp; i,<BR>\n\nint &amp; j,<BR>\n\nint &amp; k,<BR>\n\nint &amp; l)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Tests whether <I>(u,v,w,t)</I> is a cell of <I>tds</I>. If the cell\n<I>c</I> is found, it computes the indices <I>i</I>, <I>j</I>, <I>k</I>\nand <I>l</I> of the vertices <I>u</I>, <I>v</I>, <I>w</I> and <I>t</I> in\n<I>c</I>, in this order.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThere is a method <I>has_vertex</I> in the cell class. The analogous\nmethods for facets are defined here.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6const_Facet___f+_Vertex_handle_v+_int___j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.has_vertex (  Facet f,  Vertex_handle v,  int &amp; j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    If <I>v</I> is a vertex of <I>f</I>, then <I>j</I> is the index of\n<I>v</I> in the cell <I>f.first</I>, and the method returns <I>true</I>.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.dimension()=3\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6Cell_handle_c+_int_i+_Vertex_handle_v+_int___j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.has_vertex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nVertex_handle v,<BR>\n\nint &amp; j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same for facet <I>(c,i)</I>. Computes the index <I>j</I> of <I>v</I> in\n<I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6const_Facet___f+_Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.has_vertex (  Facet f,  Vertex_handle v)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_has_vertex6Cell_handle_c+_int_i+_Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.has_vertex ( Cell_handle c,  int i,  Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Same as the first two methods, but these two methods do not return the\nindex of the vertex.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following three methods test whether two facets have the same\nvertices.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_are_equal6const_Facet___f+_const_Facet___g9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.are_equal (  Facet f,  Facet g)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_are_equal6Cell_handle_c+_int_i+_Cell_handle_n+_int_j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.are_equal ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nCell_handle n,<BR>\n\nint j)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_are_equal6const_Facet___f+_Cell_handle_n+_int_j9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.are_equal (  Facet f,  Cell_handle n,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    For these three methods:<BR>\n\n<EM>Precondition: </EM><I>tds</I>.dimension()=3.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Flips</H3>\n<P>\n\nTwo kinds of flips exist for a three-dimensional triangulation. They\nare reciprocal. To be flipped, an edge must be incident to three\ntetrahedra. During the flip, these three tetrahedra disappear and two\ntetrahedra appear. Figure&nbsp;<A HREF=\"Concept_TriangulationDataStructure_3.html#TDS3-fig-flips\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>(left) shows the\nedge that is flipped as bold dashed, and one of its three incident\nfacets is shaded. On the right, the facet shared by the two new\ntetrahedra is shaded.\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Flips.\n<A NAME=\"TDS3-fig-flips\"></A>\n\n<CENTER>\n<img border=0 src=\"./flips.gif\" align=center\nalt=\"Flips\">\n</CENTER>\n<P>\n\nThe following methods guarantee the validity of the resulting 3D\ncombinatorial triangulation.\n<P>\n\n<I>Flips for a 2d triangulation are not implemented yet</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Edge_e9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip ( Edge e)\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Cell_handle_c+_int_i+_int_j9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Before flipping, these methods check that edge <I>e=(c,i,j)</I> is\nflippable (which is quite expensive). They return <I>false</I> or\n<I>true</I> according to this test.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Edge_e9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip_flippable ( Edge e)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Cell_handle_c+_int_i+_int_j9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip_flippable ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Should be preferred to the previous methods when the edge is\nknown to be flippable.<BR>\n\n<EM>Precondition: </EM>The edge is flippable.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Facet_f9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip ( Facet f)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_flip6Cell_handle_c+_int_i9;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Before flipping, these methods check that facet <I>f=(c,i)</I> is\nflippable (which is quite expensive). They return <I>false</I> or\n<I>true</I> according to this test.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Facet_f9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip_flippable ( Facet f)\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip_flippable6Cell_handle_c+_int_i9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip_flippable ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Should be preferred to the previous methods when the facet is\nknown to be flippable.<BR>\n\n<EM>Precondition: </EM>The facet is flippable.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Insertions</H3>\n<P>\n\nThe following modifier member functions guarantee\nthe combinatorial validity of the resulting triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_cell6Cell_handle_c9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_cell ( Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex, inserts it in cell <I>c</I> and returns its handle.\nThe cell <I>c</I> is split into four new cells, each of these cells being\nformed by the new vertex and a facet of <I>c</I>.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I>= 3</I></MATH> and <I>c</I> is a cell of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_facet6const_Facet___f9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_facet (  Facet f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex, inserts it in facet <I>f</I> and returns its handle.\nIn dimension 3, the two incident cells are split into 3 new cells;\nin dimension 2, the facet is split into 3 facets.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH> and <I>f</I> is a\nfacet of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_facet6Cell_handle_c+_int_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_facet ( Cell_handle c,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex, inserts it in facet <I>i</I> of <I>c</I> and returns its\nhandle.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>, <MATH><I>i  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> \nin dimension&nbsp;3, <MATH><I>i=3</I></MATH> in dimension&nbsp;2 and <I>(c,i)</I> is a facet of\n<I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_edge6Edge_e9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_edge ( Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex, inserts it in edge <I>e</I> and returns its handle.\nIn dimension 3, all the\nincident cells are split into 2 new cells; in dimension 2, the 2\nincident facets are split into 2 new facets; in dimension 1, the edge is \nsplit into 2 new edges.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH> and <I>e</I> is an edge of\n<I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_edge6Cell_handle_c+_int_i+_int_j9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_edge ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex, inserts it in edge <MATH><I>(i,j)</I></MATH> of <I>c</I> and returns its\nhandle.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH>. <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> j</I></MATH>, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2,3}</I></MATH> in dimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1,2}</I></MATH> in dimension&nbsp;2, <MATH><I>i,j\n <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC=\"cc_in.gif\"> {0,1}</I></MATH> in dimension&nbsp;1 and <I>(c,i,j)</I> is an edge of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_increase_dimension6Vertex_handle_star_=_Vertex_handle699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.insert_increase_dimension ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle star = Vertex_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Transforms a triangulation of the sphere <MATH><I>S<SUP>d</SUP></I></MATH> of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+1</SUP></I></MATH> into the\ntriangulation of the sphere <MATH><I>S<SUP>d+1</SUP></I></MATH> of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+2</SUP></I></MATH> by adding a new vertex\n<I>v</I>:  \n<I>v</I> is linked to all the vertices to triangulate one of the two\nhalfspheres of dimension <MATH><I>(d+1)</I></MATH>. Vertex <I>star</I> is used to\ntriangulate the second halfsphere (when there is an associated\ngeometric triangulation, <I>star</I> is in fact the vertex associated with\nits infinite vertex).\nSee Figure&nbsp;<A HREF=\"Concept_TriangulationDataStructure_3.html#TDS3-fig-topo-insert_outside_affine_hull\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.<BR>\n\nThe numbering of the cells is such that, if <I>f</I> was a face of\nmaximal dimension in the initial triangulation, then <I>(f,v)</I> (in\nthis order) is the corresponding face in the new triangulation.\nThis method can be used to insert the first two vertices in an empty\ntriangulation.<BR>\n\nA handle to <I>v</I> is returned.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I>= d &lt; 3</I></MATH>. When\n<I>tds</I>.<I>number_of_vertices()</I> <MATH><I>&gt;0</I></MATH>, <MATH><I>star  <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> Vertex<SUB>h</SUB>andle()</I></MATH> and\n<I>star</I> is a vertex of <I>tds</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B><I>insert_increase_dimension</I> (1-dimensional case).\n<A NAME=\"TDS3-fig-topo-insert_outside_affine_hull\"></A>\n\n<CENTER>\n<img border=0 src=\"./topo-insert_outside_affine_hull.gif\" align=center\nalt=\"insert_increase_dimension} (1-dimensional case)\">\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class CellIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_hole6CellIt_cell_begin+_CellIt_cell_end+_Cell_handle_begin+_int_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.insert_in_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    CellIt cell_begin,<BR>\n\nCellIt cell_end,<BR>\n\nCell_handle begin,<BR>\n\nint i)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a new vertex by starring a hole.  It takes an iterator range\n[<I>cell_begin</I>; <I>cell_end</I>[ of <I>Cell_handles</I> which specifies a set\nof connected cells (resp. facets in dimension 2) describing a hole.\n(<I>begin</I>, <I>i</I>) is a facet (resp. an edge) on the boundary of the hole,\nthat is, <I>begin</I> belongs to the set of cells (resp.  facets) previously\ndescribed, and <I>begin-&gt;neighbor(i)</I> does not.  Then this function deletes\nall the cells (resp. facets) describing the hole, creates a new vertex\n<I>v</I>, and for each facet (resp. edge) on the boundary of the hole, creates\na new cell (resp. facet) with <I>v</I> as vertex.  <I>v</I> is returned.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 2</I></MATH>, the set of cells (resp. facets)\nis connected, and its boundary is connected.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Removal</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_decrease_dimension6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.remove_decrease_dimension ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    This operation is the reciprocal of <I>insert_increase_dimension()</I>.\nIt transforms a triangulation of the sphere <MATH><I>S<SUP>d</SUP></I></MATH> of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d+1</SUP></I></MATH> into the\ntriangulation of the sphere <MATH><I>S<SUP>d-1</SUP></I></MATH> of <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>d</SUP></I></MATH> by removing the vertex\n<I>v</I>.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I>= d  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> -1</I></MATH>.\n<I>tds</I>.<I>degree(v)</I> <MATH><I>=</I></MATH> <I>tds</I>.<I>number_of_vertices()</I> <MATH><I>-1</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_remove_from_maximal_dimension_simplex6Vertex_handle_v9;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.remove_from_maximal_dimension_simplex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes <I>v</I>. The incident simplices of maximal dimension incident to\n<I>v</I> are replaced by a single simplex of the same dimension. This\noperation is exactly the reciprocal to <I>tds</I>.<I>insert_in_cell(v)</I> in\ndimension 3, <I>tds</I>.<I>insert_in_facet(v)</I> in dimension 2, and\n<I>tds</I>.<I>insert_in_edge(v)</I> in dimension 1.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>degree(v)</I> <MATH><I>=</I></MATH> <I>tds</I>.<I>dimension()+1</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Other modifiers</H3>\nThe following modifiers can affect the validity of the triangulation\ndata structure.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_reorient69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.reorient ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Changes the <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of all cells of the triangulation data structure.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_geq.gif\"> 1</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_create_vertex6const_Vertex__v_=_Vertex699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.create_vertex (  Vertex v = Vertex())\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Adds a copy of the vertex <I>v</I> to the triangulation data structure.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_create_vertex6Vertex_handle_v9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.create_vertex ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a vertex which is a copy of the one pointed to by <I>v</I>\nand adds it to the triangulation data structure.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_create_cell6const_Cell__c_=_Cell699;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.create_cell (  Cell c = Cell())\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Adds a copy of the cell <I>c</I> to the triangulation data structure.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_create_cell6Cell_handle_c9;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.create_cell ( Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a cell which is a copy of the one pointed to by <I>c</I>\nand adds it to the triangulation data structure.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_create_cell6Vertex_handle_v0+_Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v39;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v0,<BR>\n\nVertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a cell and adds it into the triangulation data\nstructure. Initializes the vertices of the cell, its neighbor handles\nbeing initialized with the default constructed handle.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_handle_create_cell6_Vertex_handle_v0+_Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v3+_Cell_handle_n0+_Cell_handle_n1+_Cell_handle_n2+_Cell_handle_n39;\"></A>\nCell_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v0,<BR>\n\nVertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3,<BR>\n\nCell_handle n0,<BR>\n\nCell_handle n1,<BR>\n\nCell_handle n2,<BR>\n\nCell_handle n3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Creates a cell, initializes its vertices and neighbors, and adds it\ninto the triangulation data structure.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delete_vertex6_Vertex_handle_v_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.delete_vertex ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the vertex from the triangulation data structure.<BR>\n\n<EM>Precondition: </EM>The vertex is a vertex of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delete_cell6_Cell_handle_c_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.delete_cell ( Cell_handle c)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Removes the cell from the triangulation data structure.<BR>\n\n<EM>Precondition: </EM>The cell is a cell of <I>tds</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class VertexIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delete_vertices6VertexIt_first+_VertexIt_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.delete_vertices ( VertexIt first,  VertexIt last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Calls <I>delete_vertex</I> over an iterator range of value type\n<I>Vertex_handle</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class CellIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delete_cells6CellIt_first+_CellIt_last9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.delete_cells ( CellIt first,  CellIt last)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Calls <I>delete_cell</I> over an iterator range of value type\n<I>Cell_handle</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Traversing the triangulation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_iterator_cells_begin69_const;\"></A>\nCell_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.cells_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <I>cells_end()</I> when <I>tds</I>.<I>dimension()</I>&nbsp;<MATH><I>&lt;3</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_iterator_cells_end69_const;\"></A>\nCell_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.cells_end ()\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_iterator_facets_begin69_const;\"></A>\nFacet_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.facets_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <I>facets_end()</I> when <I>tds</I>.<I>dimension()</I>&nbsp;<MATH><I>&lt;2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_iterator_facets_end69_const;\"></A>\nFacet_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.facets_end ()\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_edges_begin69_const;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.edges_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns <I>edges_end()</I> when <I>tds</I>.<I>dimension()</I>&nbsp;<MATH><I>&lt;1</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_edges_end69_const;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.edges_end ()\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_begin69_const;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.vertices_begin ()\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_end69_const;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.vertices_end ()\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6const_Edge___e9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_cells (  Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary cell incident to <I>e</I>.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I>&nbsp;<MATH><I>=3</I></MATH>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6Cell_handle_c+_int_i+_int_j9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_cells ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6const_Edge___e+_Cell_handle_start9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_cells (  Edge e,  Cell_handle start)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at cell <I>start</I>.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I>&nbsp;<MATH><I>=3</I></MATH> and <I>start</I> is incident to\n<I>e</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Cell_circulator_incident_cells6Cell_handle_c+_int_i+_int_j+_Cell_handle_start9_const;\"></A>\nCell_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_cells ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nint j,<BR>\n\nCell_handle start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following circulators on facets are defined only in dimension&nbsp;3,\nthough facets are defined also in dimension&nbsp;2: there are only two\nfacets sharing an edge in dimension&nbsp;2. \n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Edge_e9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_facets ( Edge e)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at an arbitrary facet incident to <I>e</I>.<BR>\n\n<EM>Precondition: </EM><I>tds</I>.<I>dimension()</I>&nbsp;<MATH><I>=3</I></MATH>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_facets ( Cell_handle c,  int i,  int j)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Edge_e+_Facet_start9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_facets ( Edge e,  Facet start)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at facet <I>start</I>.<BR>\n\n<EM>Precondition: </EM><I>start</I> is incident to <I>e</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Edge_e+_Cell_handle_start+_int_f9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.incident_facets ( Edge e,  Cell_handle start,  int f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Starts at facet of index <I>f</I> in <I>start</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j+_Facet_start9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_facets ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nint j,<BR>\n\nFacet start)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j+_Cell_handle_start+_int_f9_const;\"></A>\nFacet_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_facets ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Cell_handle c,<BR>\n\nint i,<BR>\n\nint j,<BR>\n\nCell_handle start,<BR>\n\nint f)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    As above for edge <I>(i,j)</I> of <I>c</I> and facet <I>(start,f)</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Traversal of the incident cells and the\nadjacent vertices of a given vertex</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_incident_cells6Vertex_handle_v+_OutputIterator_cells9_const;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_cells ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nOutputIterator cells)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Copies the <I>Cell_handle</I>s of all cells (resp. facets in dimension 2)\nincident to <I>v</I> to the output iterator <I>cells</I>.\nIf <I>tds</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>, then do nothing.\nReturns the resulting output iterator.<BR>\n\n<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <I>Vertex_handle()</I>, <I>tds</I>.<I>is_vertex(v)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class OutputIterator&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_OutputIterator_incident_vertices6Vertex_handle_v+_OutputIterator_vertices9_const;\"></A>\nOutputIterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nOutputIterator vertices)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Copies the <I>Vertex_handle</I>s of all vertices incident to <I>v</I> to the\noutput iterator <I>vertices</I>.  If <I>tds</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>, then do\nnothing.  Returns the resulting output iterator.<BR>\n\n<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <I>Vertex_handle()</I>, <I>tds</I>.<I>is_vertex(v)</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_degree6Vertex_handle_v9_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.degree ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Returns the degree of a vertex, that is, the number of incident vertices.<BR>\n\n<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC=\"cc_neq.gif\"> </I></MATH> <I>Vertex_handle()</I>, <I>tds</I>.<I>is_vertex(v)</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Checking</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid6bool_verbose_=_false9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_valid ( bool verbose = false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Checks the combinatorial validity of the triangulation by checking\nthe validity of all its cells and vertices. \n(See Section&nbsp;<A HREF=\"../TriangulationDS_3/Chapter_main.html#TDS3-sec-intro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.) Moreover, the Euler relation is\ntested.<BR>\n\nWhen <I>verbose</I> is set to <I>true</I>, messages are printed to give\na precise indication on the kind of invalidity encountered.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>I/O</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     istream&amp; is &gt;&gt;  &amp; tds<A NAME=\"Function_istream__operator99_6istream__is+_TriangulationDataStructure_3___tds9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Reads a combinatorial triangulation from <I>is</I> and assigns it to <I>tds</I>\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     ostream&amp; os &lt;&lt;  tds<A NAME=\"Function_ostream__operator66_6ostream__os+_const_TriangulationDataStructure_3___tds9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Writes <I>tds</I> into the stream <I>os</I>\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe information stored in the <I>iostream</I> is: \nthe dimension, the number of vertices, the number of cells,\nthe indices of the vertices of each cell, then the indices of the\nneighbors of each cell, where the index corresponds to the preceding\nlist of cells. When dimension <MATH><I>&lt;</I></MATH> 3, the same information is stored\nfor faces of maximal dimension instead of cells.\n<P>\n\n<H3>Has Models</H3>\n<P>\n\n<I><A HREF=\"Class_Triangulation_data_structure_3.html#Cross_link_anchor_1007\">CGAL::Triangulation_data_structure_3</A></I>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004\">TriangulationDataStructure_3::Vertex</A></I><BR>\n\n<I><A HREF=\"Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003\">TriangulationDataStructure_3::Cell</A></I>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Concept_TriangulationDataStructure_3--Cell.html\"><I>TriangulationDataStructure_3::Cell</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_38!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39184.0}