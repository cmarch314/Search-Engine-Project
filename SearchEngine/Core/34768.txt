{"text": "Recursion on Linked Lists Introduction to Computer Science II ICS 22 Introduction In this lecture we will extend our study of recursion by studying various recursive methods operating on linked lists This is natural because linked lists can themselves be defined recursively A null reference is an empty linked list A non null reference to an object from class LN whose next instance variable refers to any linked list either empty or not is a non empty linked list Recursive methods operating on linked lists are often simpler to write and easier to understand then their iterative counterparts once we become familiar with recursive methods They often store no state nor use any state change operators Next week when we begin our study trees we will find that some methods can be written only via recursion So we are using recursion on linked lists to bridge the gap between recursion and trees We will first examine recursive accessor methods that process linked lists Then we will examine recursive mutator methods that add or remove values from linked lists these methods are written using a simple pattern that Java programmers should learn Finally we will discuss how to write recursive methods in collection classes We will use a simple pattern here too which requires writing one public method that calls a private recursive helper method Recursive Accessor Methods Most recursive methods operating on linked list have a base case of an empty list most have a recursive call on the next instance variable which refers to a smaller list one that contains one fewer node Probably the simplest recursive method is one that returns the number of nodes in a linked list the length of the list Its code is shown below public static int length LN l if l null return else return 1 length l next Note the proof of correctness For the base case an empty list this method returns the correct length The recursive call is applied to a strictly smaller linked list l next containing one fewer node Assuming length l next correctly computes the length of the list following the first node then returning a value one bigger correctly computes the length of the entire list By changing this method ever so slightly we can compute the sum of all the values in the nodes of a linked list public static int sum LN l if l null return else return l value sum l next The proof of correctness is also similar The following two methods print the values in a list the first in the standard order the second in reverse order Notice that the only difference between the two methods besides their different names is the order of printing the node s value and the recursive call public static void print LN l if l null return else System out println l value print l next This method is simple to write iteratively for linear linked lists But now we discuss the method that prints all the values in reverse order This method seems impossible to write for linear linked lists because after we printe a node we must print the node that comes before it and there is no link to the previous node in linear linked lists public static void reversePrint LN l if l null return else reversePrint l next System out println l value Yet we can write this method as easily as print if we use recursion Note the proof of correctness For the base case an empty list this method prints it in reverse order correctly no values The recursive call is applied to a strictly smaller linked list l next containing one fewer node Assuming reversePrint l next correctly prints in reverse order all the values in tha list after the first node then printing the first node afterwards correctly prints all the values in the list in reverse order This illustrates that recursion as strictly more powerful than iteration an interative method can be converted into a recursive one but there are recursive methods like printReversed that cannot be translated into iterative code UNLESS AN EXTRA COLLECTION CLASS IS USED Typically iteration stack is equivalent to recursion For example we can write reversePrint iteratively as follows public static void reversePrint LN l Stack s new ArrayStack for LN r l r null r r next s add r while s isEmpty System out println LN s remove value Such a conversion recursive iterative stack is not alsways so easy Finally we can also simplify methods such as these involving an immediate return in the base case as public static void reversePrint LN l if l null reversePrint l next System out println l value Although containing less code there is an implicit return in this void method this code doesn t match the standard recursive form as it does not check for the base case nor should explicitly what to do in this case You can choose which form to follow when you write your code The following method performs a linear search and returns either null or a reference to the node containing value public static LN search LN l int value if l null return null else if l value value return l else return search l next value Note the proof of correctness For the base case an empty list this method returns the correct answer null because there are no nodes in the linked list containing value in fact there are no nodes at all The recursive call is applied to a strictly smaller linked list l next containing one fewer node Assuming search l next correctly returns a reference to a node containing value from the list following the first node then this method returns the correct reference it either returnins a reference to the first node if it storesvalue or if not it returns the result of the recursive call We can also simplify this method by combining the base case with the case of finding the correct reference to return and write it as follows public static LN search LN l int value if l null l value value return l else return search l next value Finally here is a particularly elegant recursive way to copy a linked list It is as efficient as the iterative method that we studied which required a cache reference and much simpler to write and prove correct public static LN copy LN l if l null return null else return new LN l value copy l next Note the proof of correctness For the base case an empty list this method returns the correct answer null a copy of that empty list there is no node in the linked list containing a value The recursive call is applied to a strictly smaller linked list l next containing one fewer node Assuming copy l next correctly returns a reference to a copy of a linked list containing all the nodes after the first one then this method correctly returns a copy of the entire list by returning a reference to a copy of the first node whose next is a reference to a copy of all nodes following the first Note that the complexity classes in all these cases is O N because in the worst case there is a recursive call for all N nodes that a linked list contains Recursive Mutator Methods Recursive mutator methods follow a pattern in which they return a reference to the mutated linked list instead of being void such a generalization allows for a simple recursive implementation of the method This approach takes a bit of getting used to but it is a pattern that is used repeatedly here and in the recursive processing of tree with mutators In the following method it used used to return a reference to the linked list l in which a new node containing value is inserted at its rear public static LN insertRear LN l int value if l null return new LN value null else l next insertRear l next value return l We call this method like front insertRear front 5 Note the proof of correctness For the base case an empty list this method returns the correct answer a reference to a list consisting of only a new node containing value The recursive call is applied to a strictly smaller linked list l next containing one fewer node Assuming inserRear l next value correctly returns a reference to the linked list l next containing all nodes after the first in which a new node containing value is inerted at its rear then storing a reference to this list into l next and returning l is correctly returning a reference to the linked list l in which a new node containing value is inerted at its rear The last part of this proof is definitely complicated and subtle To be understood it will require some thinking and possibly some hand simulation The code below is another way to write this same method We might consider this code simpler because it has only one return at the end returning a reference to either a new node or the node it was passed public static LN insertRear LN l int value if l null l new LN value null else l next insertRear l next value return l We can extend this pattern ever so slightly to insert a value into an ordered list Here we rely on short circuit evaluation of public static LN insertOrdered LN l int value if l null value l value return new LN value l else l next insertOrdered l next value return l We call this method as front insertOrdered front 5 Compare this recursive method with the iterative one that solves the same task Likewise the code below is another way to write this same method again using just one return public static LN insertOrdered LN l int value if l null value l value l new LN value l else l next insertOrdered l next value return l Finally here are two methods for removing values from a linked list The first removes just the first occurrence of that value the second removes all occurrences public static LN removeFirst LN l int value if l null return null else if l value value return l next else l next removeFirst l next value return l We call this method as front removeFirst front 5 As we did above we can simplify this method to public static LN removeFirst LN l int value if l null if l value value l l next else l next removeFirst l next value return l Note that if l is null this method just returns null The second version below is identical to the first except for a true test in the inner if statement it returns removeAll l next instead of just l next Thus in this version value is recursively removed from the smaller linked list as well In these recursive methods compared to the iterative ones small changes in the semantics of an operation often lead to small changes in the code public static LN removeAll LN l int value if l null return null else if l value value return removeAll l next value else l next removeAll l next value return l We call this method as front removeAll front 5 As we did above we can simplify this method to public static LN removeAll LN l int value if l null if l value value l removeAll l next value else l next removeAll l next value return l Finally notice that one form of inefficiency in recursive calls is that a parameter like value must be repeatedly passed copied from one method call to the next A smart Java compiler can recognize this phenomenon and generate code that does the equivalent but without the overhead of actually passing this value Recursive Methods in Collections When implementing collection classes with recursive methods we typically must write a pair of methods for each operation The first method is the public one specified in the interface It can be written iteratively or recursively It written iteratively it simply calls The second method which is a private static one that does all the work For example suppose that we are implementing a generic priority queue LN stores value as an Object via a linked list using a front instance variable and a priorityComparator instance variables We would implement the add method in this class with the following pair of methods public void add Object o front add front o private static LN add LN l Object o if l null priorityComparator compare l value o return new LN value l else l next add l next o return l Sometimes we will use the same name here add for the second method overloading the public method with a different private prototype for the helper method Other times we might use the standard name for this method discussed above insertOrdered We will explore in more detail this pattern of paired methods when we discuss processing trees Problem Set To ensure that you understand all the material in this lecture please solve the the announced problems after you read the lecture If you get stumped on any problem go back and read the relevant part of the lecture If you still have questions please get help from the Instructor a TA or any other student Examine the method below public static boolean equalLength LN l1 LN l2 return length l1 length l2 Although this method is trivial to write it takes a long time to execute when passed a very large linked list a million node list and a very short one a 5 node list because it computes the length of each separately and computing the length of the large list takes much more time than computing the length of the small list Rewrite this method directly using recursion so that it only traverses as much of each list as necessary to compute a result when it tries to reach the 6th node of each list and fails for the smaller list it knows the answer Hint deal with the following four cases both l1 and l2 are empty l1 is empty and l2 is not empty l1 is not empty and l2 is empty and finally both l1 and l2 are not empty in three of four cases an answer can be returned immediately the other requires recursion Write the public static method named merge which takes two parameters each is a reference to a sorted in increasing order list This method returns a reference to a new sorted list which copies all the values from its two parameter lists which remain unchanged Hint use a recursive structures limilar to the equalLength method described above Familiarize yourself with the methods covered in this lecture know how to prove hand simulate them ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/lectures/llrecursion/lecture.html", "title": "recursion on linked lists", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Recursion on Linked Lists</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Recursion on Linked Lists</h1>\r\n<p>\r\n<h2>Introduction to Computer Science II<br>\r\nICS-22<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture we will extend our study of recursion by studying various\r\n  recursive methods operating on linked lists.\r\nThis is natural, because linked lists can themselves be defined recursively:\r\n<ol>\r\n<li>A null reference is an empty linked list.\r\n<li>A non-null reference to an object (from class <b>LN</b>) whose <b>next</b>\r\n       instance variable refers to any linked list (either empty or not) is a\r\n        non-empty linked list.\r\n</ol>\r\nRecursive methods operating on linked lists are often simpler to write and\r\n  easier to understand  then their iterative counterparts (once we become\r\n  familiar with recursive methods).\r\nThey often store no state (nor use any state change operators).\r\nNext week, when we begin our study trees, we will find that some methods can be\r\n  written only via recursion.\r\nSo we are using recursion on linked lists to bridge the gap between recursion\r\n  and trees.\r\n<p>\r\nWe will first examine recursive accessor methods that process linked lists.\r\nThen we will examine recursive mutator methods that add or remove values from\r\n  linked lists; these methods are written using a simple pattern that Java\r\n  programmers should learn.\r\nFinally, we will discuss how to write recursive methods in collection classes\r\nWe will use a simple pattern here too, which requires writing one <b>public</b>\r\n  method that calls a <b>private</b> recursive helper method.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<a name=\"Accessor\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Recursive Accessor Methods</b></td>\r\n<td width =\"80%\">\r\nMost recursive methods operating on linked list have a base case of an empty \r\n list; most have a recursive call on the <b>next</b> instance variable, which\r\n  refers to a smaller list: one that contains one fewer node.\r\nProbably the simplest recursive method is one that returns the number of nodes\r\n  in a linked list (the length of the list).\r\nIts code is shown below.\r\n<pre><b>  public static int length (LN l)\r\n  {\r\n    if (l == null)\r\n      return 0;\r\n    else\r\n      return 1 + length(l.next);\r\n  }</b></pre>\r\nNote the proof of correctness.\r\n<ul>\r\n<li>For the base case (an empty list) this method returns the correct length:\r\n      0.\r\n<li>The recursive call is applied to a strictly smaller linked list,\r\n      <b>l.next</b> (containing one fewer node).\r\n<li>Assuming <b>length(l.next)</b> correctly computes the length of the list\r\n       following the first node, then returning a value one bigger correctly\r\n       computes the length of the entire list.\r\n</ul>\r\nBy changing this method ever so slightly, we can compute the sum of all the\r\n   values in the nodes of a linked list.\r\n<pre><b>  public static int sum (LN l)\r\n  {\r\n    if (l == null)\r\n      return 0;\r\n    else\r\n      return l.value + sum(l.next);\r\n  }</b></pre>\r\nThe proof of correctness is also similar.\r\n<p>\r\nThe following two methods print the values in a list: the first in the standard\r\n  order, the second in reverse order.\r\nNotice that the only difference between the two methods (besides their\r\n  different names) is the order of printing the node's value and the recursive\r\n  call.\r\n<pre><b>  public static void print (LN l)\r\n  {\r\n    if (l == null)\r\n      return;\r\n    else {\r\n      System.out.println(l.value);\r\n      print(l.next);\r\n    }\r\n  }</b></pre>\r\nThis method is simple to write iteratively for linear linked lists.\r\nBut now we discuss the method that prints all the values in reverse order.\r\nThis method seems impossible to write for linear linked lists, because after\r\n  we printe a node, we must print the node that comes before it (and there\r\n  is no link to the previous node in linear linked lists).\r\n<pre><b>  public static void reversePrint (LN l)\r\n  {\r\n    if (l == null)\r\n      return;\r\n    else {\r\n      reversePrint(l.next);\r\n      System.out.println(l.value);\r\n    }\r\n  }</b></pre>\r\nYet, we can write this method as easily as <b>print</b>, if we use recursion.\r\nNote the proof of correctness.\r\n<ul>\r\n<li>For the base case (an empty list) this method prints it in reverse order\r\n       correctly: no values\r\n<li>The recursive call is applied to a strictly smaller linked list,\r\n      <b>l.next</b>\r\n      (containing one fewer node).\r\n<li>Assuming <b>reversePrint(l.next)</b> correctly prints (in reverse order)\r\n      all the\r\n      values in tha list after the first node), then printing the first node\r\n      afterwards correctly prints all the values in  the list in reverse\r\n      order.\r\n</ul>\r\nThis illustrates that recursion as strictly more powerful than iteration:\r\n  an interative method can be converted into a recursive one; but there\r\n  are recursive methods (like <b>printReversed</b>) that cannot be translated\r\n  into iterative code UNLESS AN EXTRA COLLECTION CLASS IS USED.\r\nTypically, iteration+stack is equivalent to recursion.\r\nFor example, we can write <b>reversePrint</b> iteratively as follows\r\n<pre><b>  public static void reversePrint (LN l)\r\n  {\r\n    Stack s = new ArrayStack();\r\n    for (LN r=l; r!=null; r=r.next)\r\n      s.add(r);\r\n    while (!s.isEmpty())\r\n      System.out.println( ((LN)s.remove()).value);\r\n  }</b></pre>\r\nSuch a conversion (recursive -> iterative+stack) is not alsways so easy.\r\n\r\n<p>\r\nFinally, we can also simplify methods such as these (involving an immediate\r\n  <b>return</b> in the base case) as:\r\n  <pre><b>  public static void reversePrint (LN l)\r\n  {\r\n    if (l != null) {\r\n      reversePrint(l.next);\r\n      System.out.println(l.value);\r\n    }\r\n  }</b></pre>\r\nAlthough containing less code (there is an implicit <b>return</b> in this\r\n  <b>void</b> method), this code doesn't match the standard recursive form,\r\n  as it does not check for the base case, nor should (explicitly) what to do\r\n  in this case.\r\nYou can choose which form to follow when you write your code.\r\n<p>\r\nThe following method performs a linear search and returns either <b>null</b>\r\n  or a reference to the node containing <b>value</b>.\r\n<pre><b>  public static LN search (LN l, int value)\r\n  {\r\n    if (l == null)\r\n      return null;\r\n    else\r\n      if (l.value == value)\r\n        return l;\r\n      else\r\n        return search(l.next, value);\r\n  }</b></pre>\r\nNote the proof of correctness.\r\n<ul>\r\n<li>For the base case (an empty list) this method returns the correct answer:\r\n       <b>null</b>, because there are no nodes in the linked list containing\r\n       <b>value</b> (in fact, there are no nodes at all).\r\n<li>The recursive call is applied to a strictly smaller linked list,\r\n      <b>l.next</b> (containing one fewer node).\r\n<li>Assuming <b>search(l.next)</b> correctly returns a reference to a node\r\n      containing <b>value</b> from the list following the first node, then\r\n      this method\r\n      returns the correct reference: it either returnins a reference to the\r\n      first node (if it stores<b>value</b>) or if not it returns\r\n      the result of the recursive call.\r\n</ul>\r\nWe can also simplify this method by combining the base case with the case of\r\n  finding the correct reference to return, and write it as follows.\r\n  <pre><b>  public static LN search (LN l, int value)\r\n  {\r\n    if (l == null || l.value == value)\r\n      return l;\r\n    else\r\n      return search(l.next, value);\r\n  }</b></pre>\r\nFinally, here is a particularly elegant recursive way to copy a linked list.\r\nIt is as efficient as the iterative method that we studied (which required a\r\n  cache reference) and much simpler to write and prove correct.\r\n<pre><b>  public static LN copy(LN l)\r\n  {\r\n    if (l == null)\r\n      return null;\r\n    else\r\n      return new LN(l.value,copy(l.next));\r\n    }\r\n  }</b></pre>\r\nNote the proof of correctness.\r\n<ul>\r\n<li>For the base case (an empty list) this method returns the correct answer:\r\n      <b>null</b> (a \"copy\" of that empty list);\r\n      there is no node in the linked list containing a <b>value</b>.\r\n<li>The recursive call is applied to a strictly smaller linked list,\r\n       <b>l.next</b> (containing one fewer node).\r\n<li>Assuming <b>copy(l.next)</b> correctly returns a reference to a copy of\r\n       a linked\r\n       list containing all the nodes after the first one, then this method\r\n       correctly returns a copy of the entire list by returning a reference\r\n       to a copy of the first node, whose <b>next</b> is a reference to \r\n       a copy of all nodes following the first.\r\n<p>\r\nNote that the complexity classes in all these cases is O(N), because in the\r\n  worst case, there is a recursive call for all N nodes that a linked list\r\n  contains.\r\n</ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<a name=\"Mutator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Recursive Mutator Methods</b></td>\r\n<td width =\"80%\">\r\nRecursive mutator methods follow a pattern in which they return a reference to\r\n  the mutated linked list (instead of being <b>void</b>); such a generalization\r\n  allows for a simple recursive implementation of the method.\r\nThis approach takes a bit of getting used to, but it is a pattern that is used\r\n  repeatedly here and in the recursive processing of tree with mutators.\r\nIn the following method, it used used to return a reference to the\r\n  linked list <b>l</b>, in which a new node containing <b>value</b> is inserted\r\n  at its rear.\r\n<pre><b>  public static LN insertRear (LN l, int value)\r\n  {\r\n    if (l == null)\r\n      return new LN(value,null);\r\n    else {\r\n      l.next = insertRear(l.next, value);\r\n      return l;\r\n    }\r\n  }</b></pre>\r\nWe call this method like <b>front = insertRear(front, 5);</b>\r\n<p>\r\nNote the proof of correctness.\r\n<ul>\r\n<li>For the base case (an empty list) this method returns the correct answer:\r\n      a reference to a list consisting of only a new node containing\r\n      <b>value</b>.\r\n<li>The recursive call is applied to a strictly smaller linked list,\r\n       <b>l.next</b> (containing one fewer node).\r\n<li>Assuming <b>inserRear(l.next,value);</b> correctly returns a reference to\r\n       the linked list <b>l.next</b> (containing all nodes after the first),\r\n       in which a new node containing <b>value</b> is inerted at its rear;\r\n       then storing a reference to this list into <b>l.next</b> and returning\r\n       <b>l</b> is correctly returning a reference to the linked list <b>l</b>,\r\n       in which a new node containing <b>value</b> is inerted at its rear.\r\n</ul>\r\nThe last part of this proof is definitely complicated and subtle.\r\nTo be understood, it will require some thinking (and possibly some hand\r\n  simulation).\r\n<p>\r\nThe code below is another way to write this same method.\r\nWe might consider this code simpler because it has only one <b>return</b> at\r\n  the end, returning a reference to either a new node or the node it was\r\n  passed.\r\n<pre><b>  public static LN insertRear (LN l, int value)\r\n  {\r\n    if (l == null)\r\n      l = new LN(value,null);\r\n    else \r\n      l.next = insertRear(l.next, value);\r\n\r\n    return l;\r\n  }</b></pre>\r\n<p>\r\nWe can extend this pattern ever-so-slightly to insert a value into an ordered\r\n  list.\r\nHere we rely on short-circuit evaluation of <b>||</b>.\r\n<pre><b>  public static LN insertOrdered (LN l, int value)\r\n  {\r\n    if (l == null || value < l.value)\r\n      return new LN(value,l);\r\n    else {\r\n      l.next = insertOrdered(l.next, value);\r\n      return l;\r\n    }\r\n  }</b></pre>\r\nWe call this method as <b>front = insertOrdered(front, 5);</b>\r\nCompare this recursive method with the iterative one that solves the same task.\r\n<p>\r\nLikewise, the code below is another way to write this same method, again using\r\n  just one <b>return</b>.\r\n<pre><b>  public static LN insertOrdered (LN l, int value)\r\n  {\r\n    if (l == null || value < l.value)\r\n      l = new LN(value,l);\r\n    else \r\n      l.next = insertOrdered(l.next, value);\r\n\r\n    return l;\r\n  }</b></pre>\r\n<p>\r\nFinally, here are two methods for removing values from a linked list.\r\nThe first removes just the first occurrence of that value; the second removes\r\n  all occurrences.\r\n<pre><b>  public static LN removeFirst(LN l, int value)\r\n  {\r\n    if (l == null)\r\n      return null;\r\n    else\r\n      if (l.value == value)\r\n        return l.next;\r\n      else {\r\n        l.next = removeFirst(l.next, value);\r\n        return l;\r\n      }\r\n  }</b></pre>\r\nWe call this method as <b>front = removeFirst(front, 5);</b>\r\n<p>\r\nAs we did above, we can \"simplify\" this method to.\r\n<pre><b>  public static LN removeFirst(LN l, int value)\r\n  {\r\n    if (l != null)\r\n      if (l.value == value)\r\n        l = l.next;\r\n      else\r\n        l.next = removeFirst(l.next, value);\r\n\r\n    return l;\r\n  }</b></pre>\r\nNote that if <b>l</b> is <b>null</b>, this method just returns <b>null</b>.\r\n<p>\r\nThe second version, below, is identical to the first, except for a <b>true</b>\r\n test in the inner <b>if</b> statement it returns <b>removeAll(l.next)</b>\r\n  instead of just <b>l.next</b>.\r\nThus, in this version <b>value</b> is recursively removed from the smaller\r\n  linked list as well.\r\nIn these recursive methods, compared to the iterative ones, small changes in\r\n  the semantics of an operation often lead to small changes in the code.\r\n<pre><b>  public static LN removeAll(LN l, int value)\r\n  {\r\n    if (l == null)\r\n      return null;\r\n    else\r\n      if (l.value == value)\r\n        return removeAll(l.next,value);\r\n      else {\r\n        l.next = removeAll(l.next, value);\r\n        return l;\r\n      }\r\n  }</b></pre>\r\nWe call this method as <b>front = removeAll(front, 5);</b>\r\n<p>\r\nAs we did above, we can \"simplify\" this method to.\r\n<pre><b>  public static LN removeAll(LN l, int value)\r\n  {\r\n    if (l != null)\r\n      if (l.value == value)\r\n        l = removeAll(l.next, value);\r\n      else\r\n        l.next = removeAll(l.next, value);\r\n\r\n    return l;\r\n  }</b></pre>\r\n<p>\r\nFinally, notice that one form of inefficiency in recursive calls is that\r\n   a parameter like <b>value</b> must be repeatedly passed/copied from one\r\n   method call to the next.\r\nA smart Java compiler can recognize this phenomenon and generate code that does\r\n  the equivalent but without the overhead of actually passing this value.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Recursive Methods in Collections -->\r\n\r\n<a name=\"Collection\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Recursive Methods in Collections </b></td>\r\n<td width =\"80%\">\r\nWhen implementing collection classes with recursive methods, we typically must\r\n  write a pair of methods for each operation.\r\n<ol>\r\n<li>The first method is the <b>public</b> one specified in the interface.\r\nIt can be written iteratively or recursively.\r\nIt written iteratively, it simply calls ...\r\n<li>The second method, which is a <b>private static</b> one that does all the\r\n      work.\r\n</ol>\r\nFor example, suppose that we are implementing a generic priority queue\r\n  (<b>LN</b> stores <b>value</b> as an <b>Object</b>) via a linked\r\n  list, using a <b>front</b> instance variable and a <b>priorityComparator</b>\r\n  instance variables.\r\nWe would implement the <b>add</b> method in this class with the following pair\r\n  of methods.\r\n<pre><b>  public void add (Object o)\r\n  {front = add(front,o);}\r\n\r\n  private static LN add (LN l, Object o)\r\n  {\r\n    if (l == null || priorityComparator.compare(l.value,o) < 0)\r\n      return new LN(value,l);\r\n    else {\r\n      l.next = add(l.next, o);\r\n      return l;\r\n    }\r\n  }</b></pre>\r\nSometimes we will use the same name, here <b>add</b> for the second\r\n  method, overloading the <b>public</b> method with a different \r\n  <b>private</b> prototype for the helper method.\r\nOther times we might use the standard name for this method (discussed above):\r\n   <b>insertOrdered</b>.\r\n<p>\r\nWe will explore in more detail this pattern of paired methods when we discuss\r\n  processing trees.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Examine the method below\r\n<pre><b>  public static boolean equalLength(LN l1, LN l2)\r\n  {return length(l1) == length(l2);}</b></pre>\r\nAlthough this method is trivial to write, it takes a long time to execute when\r\n  passed a very large linked list (a million node list) and a very short one (a\r\n  5 node list), because it computes the length of each separately, and\r\n  computing the length of the large list takes much more time than computing\r\n  the length of the small list.\r\nRewrite this method directly using recursion so that it only traverses as much\r\n  of each list as necessary to compute a result (when it tries to reach the\r\n  6th node of each list -and fails for the smaller list- it knows the answer.\r\nHint: deal with the following four cases: both <b>l1</b> and <b>l2</b> are\r\n  empty, <b>l1</b> is empty and <b>l2</b> is not empty, <b>l1</b> is not empty\r\n  and <b>l2</b> is empty, and finally both <b>l1</b> and <b>l2</b> are not\r\n  empty; in three of four cases, an answer can be returned immediately (the\r\n  other requires recursion).\r\n<p>\r\n<li>Write the <b>public static</b> method named <b>merge</b>, which takes two\r\n      parameters: each is a reference to a sorted (in increasing order) list.\r\n    This method returns a reference to a new sorted list, which copies all the\r\n       values from its two parameter lists (which remain unchanged).\r\n    Hint: use a recursive structures limilar to the <b>equalLength</b> method\r\n      described above.\r\n<p>\r\n<li>Familiarize yourself with the methods covered in this lecture: know how to\r\n      prove/hand-simulate them.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n\r\n", "id": 34768.0}