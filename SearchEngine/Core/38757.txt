{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 2Kernel Representations Our object of study is the d dimensional affine Euclidean space Here we are mainly concerned with cases d 2 and d 3 Objects in that space are sets of points A common way to represent the points is the use of Cartesian coordinates which assumes a reference frame an origin and d orthogonal axes In that framework a point is represented by a d tuple c c1 cd 1 and so are vectors in the underlying linear space Each point is represented uniquely by such Cartesian coordinates Another way to represent points is by homogeneous coordinates In that framework a point is represented by a d 1 tuple h h1 hd Via the formulae ci hi hd the corresponding point with Cartesian coordinates c c1 cd 1 can be computed Note that homogeneous coordinates are not unique For lambda the tuples h h1 hd and lambda h lambda h1 lambda hd represent the same point For a point with Cartesian coordinates c c1 cd 1 a possible homogeneous representation is c c1 cd 1 1 Homogeneous coordinates in fact allow to represent objects in a more general space the projective space Pd In CGAL we do not compute in projective geometry Rather we use homogeneous coordinates to avoid division operations since the additional coordinate can serve as a common denominator 2 1 Genericity through Parameterization Almost all the kernel objects and the corresponding functions are templates with a parameter that allows the user to choose the representation of the kernel objects A type that is used as an argument for this parameter must fulfill certain requirements on syntax and semantics The list of requirements defines an abstract kernel concept For all kernel objects Object the types CGAL Object Kernel and Kernel Object are identical CGAL offers four families of concrete models for the concept Kernel two based on the Cartesian representation of points and two based on the homogeneous representation of points The interface of the kernel objects is designed such that it works well with both Cartesian and homogeneous representation For example points in 2D have a constructor with three arguments as well the three homogeneous coordinates of the point The common interfaces parameterized with a kernel class allow one to develop code independent of the chosen representation We said families of models because both families are parameterized too A user can choose the number type used to represent the coordinates For reasons that will become evident later a kernel class provides two typenames for number types namely Kernel FT and Kernel RT The type Kernel FT must fulfill the requirements on what is called a FieldNumberType in CGAL This roughly means that Kernel FT is a type for which operations and are defined with semantics approximately corresponding to those of a field in a mathematical sense Note that strictly speaking the built in type int does not fullfil the requirements on a field type since ints correspond to elements of a ring rather than a field especially operation is not the inverse of The requirements on the type Kernel RT are weaker This type must fulfill the requirements on what is called a RingNumberType in CGAL This roughly means that Kernel RT is a type for which operations are defined with semantics approximately corresponding to those of a ring in a mathematical sense 2 2 Cartesian Kernels With Cartesian FieldNumberType you can choose a Cartesian representation of coordinates When you choose Cartesian representation you have to declare at the same time the type of the coordinates A number type used with the Cartesian representation class should be a FieldNumberType as described above As mentioned above the built in type int is not a FieldNumberType However for some computations with Cartesian representation no division operation is needed i e a RingNumberType is sufficient in this case With Cartesian FieldNumberType both Cartesian FieldNumberType FT and Cartesian FieldNumberType RT are mapped to FieldNumberType Cartesian FieldNumberType uses reference counting internally to save copying costs CGAL also provides Simple cartesian FieldNumberType a kernel that uses Cartesian representation but no reference counting Debugging is easier with Simple cartesian FieldNumberType since the coordinates are stored within the class and hence direct access to the coordinates is possible Depending on the algorithm it can also be slightly more or less efficient than Cartesian FieldNumberType Again in Simple cartesian FieldNumberType both Simple cartesian FieldNumberType FT and Simple cartesian FieldNumberType RT are mapped to FieldNumberType 2 3 Homogeneous Kernels Homogeneous coordinates permit to avoid division operations in numerical computations since the additional coordinate can serve as a common denominator Avoiding divisions can be useful for exact geometric computation With Homogeneous RingNumberType you can choose a homogeneous representation for the coordinates of the kernel objects As for the Cartesian representation one has to declare the type used to store the coordinates Since the homogeneous representation does not use divisions the number type associated with a homogeneous representation class must be a model for the weaker concept RingNumberType only However some operations provided by this kernel involve divisions for example computing squared distances or Cartesian coordinates To keep the requirements on the number type parameter of Homogeneous low the number type Quotient RingNumberType is used for operations that require divisions This number type can be viewed as an adaptor which turns a RingNumberType into a FieldNumberType It maintains numbers as quotients i e a numerator and a denominator With Homogeneous RingNumberType Homogeneous RingNumberType FT is equal to Quotient RingNumberType while Homogeneous RingNumberType RT is equal to RingNumberType Homogeneous RingNumberType uses reference counting internally to save copying costs CGAL also provides Simple homogeneous RingNumberType a kernel that uses homogeneous representation but no reference counting Debugging is easier with Simple homogeneous RingNumberType since the coordinates are stored within the class and hence direct access to the coordinates is possible Depending on the algorithm it can also be slightly more or less efficient than Homogeneous RingNumberType Again in Simple homogeneous RingNumberType the type Simple homogeneous RingNumberType FT is equal to Quotient RingNumberType while Simple homogeneous RingNumberType RT is equal to RingNumberType 2 4 Naming conventions The use of kernel classes not only avoids problems it also makes all CGAL classes very uniform They always consist of The capitalized base name of the geometric object such as Point Segment or Triangle An underscore followed by the dimension of the object for example 2 3 or d A kernel class as parameter which itself is parameterized with a number type such as Cartesian double or Homogeneous leda integer 2 5 Kernel as a Traits Class Algorithms and data structures in the basic library of CGAL are parameterized by a traits class that subsumes the objects on which the algorithm or data structure operates as well as the operations to do so For most of the algorithms and data structures in the basic library you can use a kernel as a traits class For some algorithms you even do not have to specify the kernel it is detected automatically using the types of the geometric objects passed to the algorithm In some other cases the algorithms or data structures needs more than is provided by the kernel concept In these cases a kernel can not be used as a traits class 2 6 Choosing a Kernel and Predefined Kernels If you start with integral Cartesian coordinates many geometric computations will involve integral numerical values only Especially this is true for geometric computations that evaluate only predicates which are tantamount to determinant computations Examples are triangulation of point sets and convex hull computation In this case the Cartesian representation is probably the first choice even with a ring type You might use limited precision integer types like int or long use double to present your integers they have more bits in their mantissa than an int and overflow nicely or an arbitrary precision integer type like the wrapper Gmpz for the GMP integers leda integer or MP Float Note that unless you use an arbitrary precision ring type incorrect results might arise due to overflow If new points are to be constructed for example the intersection point of two lines computation of Cartesian coordinates usually involves divisions Hence one needs to use a FieldNumberType with Cartesian representation or alternatively switch to homogeneous representation The type double is a though imprecise model for FieldNumberType You can also put any RingNumberType into the Quotient adaptor to get a field type which then can be put into Cartesian But using homogeneous representation on the RingNumberType is usually the better option Other valid FieldNumberTypes are leda rational and leda real If it is crucial for you that the computation is reliable the right choice is probably a number type that guarantees exact computation The Filtered kernel provides a way to apply filtering techniques BBP 1 to achieve a kernel with exact and efficient predicates Still other people will prefer the built in type double because they need speed and can live with approximate results or even algorithms that from time to time crash or compute incorrect results due to accumulated rounding errors Predefined kernels For the user s convenience CGAL provides 3 typedefs to generally useful kernels They are all Cartesian kernels They all support constructions of points from double Cartesian coordinates All these 3 kernels provide exact geometric predicates They handle geometric constructions differently Exact predicates exact constructions kernel provides exact geometric constructions in addition to exact geometric predicates Exact predicates exact constructions kernel with sqrt same as Exact predicates exact constructions kernel but the number type it provides Exact predicates exact constructions kernel with sqrt FT supports the square root operation exactly 1 Exact predicates inexact constructions kernel provides exact geometric predicates but geometric constructions may be inexact due to roundoff errors It is however enough for most CGAL algorithms and faster than both Exact predicates exact constructions kernel and Exact predicates exact constructions kernel with sqrt Footnotes 1 Currently it requires having either LEDA or CORE installed Next chapter Kernel Geometry Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Kernel_23/Chapter_kernel_representation.html", "title": "kernel representations", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Kernel_23/kernel_representation.tex' -->\n<html> <head>  \n<title>Kernel Representations</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_kernel_representation.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_2\"></a>\n  \n<h1>Chapter 2<BR>Kernel Representations</h1>\n\nOur object of study is the <MATH><I>d</I></MATH>-dimensional affine Euclidean space. \nHere we are mainly concerned with cases <MATH><I>d=2</I></MATH> and <MATH><I>d=3</I></MATH>.\nObjects in that space are sets of points. A common way to represent \nthe points is the use of \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates,\nwhich assumes a reference frame (an origin and <MATH><I>d</I></MATH> orthogonal axes).\nIn that framework, a point is represented by a <MATH><I>d</I></MATH>-tuple\n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>)</MATH>,\nand so are vectors in the underlying linear space. Each point is \nrepresented uniquely by such \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates.\nAnother way to represent points is by homogeneous coordinates. In that\nframework, a point is represented by a <MATH><I>(d+1)</I></MATH>-tuple\n<MATH>(h<SUB>0</SUB>,h<SUB>1</SUB>,...,h<SUB>d</SUB>)</MATH>.\nVia the formulae\n<MATH>c<SUB>i</SUB>=h<SUB>i</SUB>/h<SUB>d</SUB></MATH>,\nthe corresponding point with \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates\n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>)</MATH>\ncan be computed.  Note that homogeneous coordinates are not unique. \nFor <MATH>lambda != 0</MATH>,\nthe tuples \n<MATH>(h<SUB>0</SUB>,h<SUB>1</SUB>\n,...,h<SUB>d</SUB>)</MATH>\n and \n<MATH>(lambda  h<SUB>0</SUB>,lambda  h<SUB>1</SUB>,...,lambda  \nh<SUB>d</SUB>)</MATH> represent the\nsame point.\nFor a point with \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates <MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>)</MATH> a\npossible homogeneous representation is\n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>,1)</MATH>.\n\n<!-- REMOVE_LINKS_BEGIN -->\nHomogeneous\n<!-- REMOVE_LINKS_END -->\n coordinates in fact allow to represent \nobjects in a more general space, the projective space\n<MATH>P<SUB>d</SUB></MATH>.\nIn C<SMALL>GAL</SMALL>, we do not compute in projective geometry. Rather, we use \nhomogeneous coordinates to avoid division operations,\nsince the additional coordinate can serve as a common denominator.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>2.1&nbsp;&nbsp;&nbsp;Genericity through Parameterization</h2>\n<P>\n\nAlmost all the kernel objects (and the corresponding functions) are\ntemplates with a parameter that allows the user to choose the\nrepresentation of the kernel objects. A type that is used as an\nargument for this parameter must fulfill certain requirements on\nsyntax and semantics. The list of requirements defines an abstract\nkernel concept. For all kernel objects\n\n<!-- REMOVE_LINKS_BEGIN -->\n<I>Object</I>\n<!-- REMOVE_LINKS_END -->\n, the types\n\n<!-- REMOVE_LINKS_BEGIN -->\n<I>CGAL::Object&lt;Kernel&gt;</I>\n<!-- REMOVE_LINKS_END -->\n and \n\n<!-- REMOVE_LINKS_BEGIN -->\n<I>Kernel::Object</I>\n<!-- REMOVE_LINKS_END -->\n are identical.\n<P>\n\nCGAL offers four families of concrete models for the concept <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>,\ntwo based on the \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation of\npoints and two based on the homogeneous representation of points. The\ninterface of the kernel objects is designed such that it works well\nwith both \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n and homogeneous\nrepresentation. For example, points in 2D have a constructor with\nthree arguments as well (the three homogeneous coordinates of the\npoint).  The common interfaces parameterized with a kernel class allow\none to develop code independent of the chosen representation.  We said\n``families'' of models, because both families are parameterized too.\nA user can choose the number type used to represent the coordinates.\n<P>\n\nFor reasons that will become evident later, a kernel class provides\ntwo typenames for number types,\nnamely <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::FT</I> and <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::RT</I>. The type <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::FT</I> must fulfill the\nrequirements on what is called a <I><A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A></I> in C<SMALL>GAL</SMALL>. This\nroughly means that <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::FT</I> is a type for which operations\n<MATH><I>+</I></MATH>, <MATH><I>-</I></MATH>, <MATH><I>*</I></MATH> and <MATH><I>/</I></MATH> are defined with semantics (approximately)\ncorresponding to those of a field in a mathematical sense. Note that,\nstrictly speaking, the built-in type <I>int</I> does not fullfil the\nrequirements on a field type, since <I>int</I>s correspond to elements\nof a ring rather than a field, especially operation <MATH><I>/</I></MATH> is not the\ninverse of <MATH><I>*</I></MATH>.  The requirements on the type <I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::RT</I> are\nweaker.  This type must fulfill the requirements on what is called a\n<I><A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A></I> in C<SMALL>GAL</SMALL>. This roughly means that\n<I><A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>::RT</I> is a type for which operations <MATH><I>+</I></MATH>, <MATH><I>-</I></MATH>, <MATH><I>*</I></MATH> are\ndefined with semantics (approximately) corresponding to those of a\nring in a mathematical sense.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>2.2&nbsp;&nbsp;&nbsp;Cartesian Kernels</h2>\n\nWith <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I> you can choose a\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation of coordinates. When you\nchoose \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation you have to\ndeclare at the same time the type of the coordinates.  A number type\nused with the <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A></I> representation class should be a\n<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A> as described above. As mentioned above, the built-in\ntype <I>int</I> is not a <A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>. However, for some\ncomputations with \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation, no\ndivision operation is needed, i.e., a <A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A> is sufficient in\nthis case. With <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I>, both\n<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;::FT</I> and\n<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;::RT</I> are mapped to\n<I><A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A></I>.\n<P>\n\n<I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I> uses reference counting internally to\nsave copying costs. CGAL also provides\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I>, a kernel that uses\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation but no reference\ncounting.  Debugging is easier with\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I>, since the coordinates are\nstored within the class and hence direct access to the coordinates is\npossible.  Depending on the algorithm, it can also be slightly more or\nless efficient than <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I>. Again, in\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I> both\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;::FT</I> and\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;::RT</I> are mapped to\n<I><A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A></I>.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>2.3&nbsp;&nbsp;&nbsp;Homogeneous Kernels</h2>\n\n<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A> coordinates permit to avoid division operations in\nnumerical computations, since the additional coordinate can serve as a\ncommon denominator.  Avoiding divisions can be useful for exact\ngeometric computation.  With <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> you can\nchoose a homogeneous representation for the coordinates of the kernel\nobjects. As for the \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation, one\nhas to declare the type used to store the coordinates. Since the\nhomogeneous representation does not use divisions, the number type\nassociated with a homogeneous representation class must be a model for\nthe weaker concept <A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A> only. However, some operations\nprovided by this kernel involve divisions, for example computing\nsquared distances or \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates. To\nkeep the requirements on the number type parameter of\n<I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A></I> low, the number type\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> is used for operations that require\ndivisions. This number type can be viewed as an adaptor which turns a\n<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A> into a <A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>. It maintains numbers as\nquotients, i.e., a numerator and a denominator. With\n<I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I>,\n<I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;::FT</I> is equal to\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I>, while\n<I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;::RT</I> is equal to\n<I><A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A></I>.\n<P>\n\n<I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> uses reference counting internally\nto save copying costs. CGAL also provides\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I>, a kernel that uses\n\n<!-- REMOVE_LINKS_BEGIN -->\nhomogeneous\n<!-- REMOVE_LINKS_END -->\n representation but no reference\ncounting. Debugging is easier with\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I>, since the coordinates are\nstored within the class and hence direct access to the coordinates is\npossible. Depending on the algorithm, it can also be slightly more or\nless efficient than <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I>. Again, in\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> the type\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;::FT</I> is equal to\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> while\n<I><A HREF=\"../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32\">Simple_homogeneous</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;::RT</I> is equal to\n<I><A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A></I>.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>2.4&nbsp;&nbsp;&nbsp;Naming conventions</h2>\n<P>\n\nThe use of kernel classes not only avoids problems, it also makes all\nC<SMALL>GAL</SMALL> classes very uniform. They <B>always</B> consist of:\n<OL>\n<P>\n\n<LI>The <I>capitalized base name</I> of the geometric object, such as \n      <I>Point</I>, <I>Segment</I>, or <I>Triangle</I>.\n<P>\n\n<LI>An <I>underscore</I> followed by the <I>dimension</I> of the object, \n      for example <MATH><I>_2</I></MATH>, <MATH><I>_3</I></MATH>, or <MATH><I>_d</I></MATH>.\n<P>\n\n<LI>A <I>kernel class</I> as parameter, which itself is\n      parameterized with a number type, such as\n      <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;double&gt;</I> or\n      <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>&lt;<A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A>&gt;</I>.\n</OL>\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>2.5&nbsp;&nbsp;&nbsp;Kernel as a Traits Class</h2>\n\nAlgorithms and data structures in the basic library of C<SMALL>GAL</SMALL> are\nparameterized by a traits class that subsumes the objects on which the\nalgorithm or data structure operates as well as the operations to do\nso. For most of the algorithms and data structures in the basic\nlibrary you can use a kernel as a traits class. For some algorithms\nyou even do not have to specify the kernel; it is detected\nautomatically using the types of the geometric objects passed to the\nalgorithm. In some other cases, the algorithms or data structures\nneeds more than is provided by the kernel concept. In these cases, a\nkernel can not be used as a traits class.\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>2.6&nbsp;&nbsp;&nbsp;Choosing a Kernel and Predefined Kernels</h2>\n\nIf you start with integral \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates,\nmany geometric computations will involve integral numerical values\nonly. Especially, this is true for geometric computations that\nevaluate only predicates, which are tantamount to determinant\ncomputations. Examples are triangulation of point sets and convex hull\ncomputation.  In this case, the \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n\nrepresentation is probably the first choice, even with a ring type.\nYou might use limited precision integer types like <I>int</I> or\n<I>long</I>, use <I>double</I> to present your integers (they have more\nbits in their mantissa than an <I>int</I> and overflow nicely), or an\narbitrary precision integer type like the wrapper <I><A HREF=\"../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364\">Gmpz</A></I> for the\nGMP integers, <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A></I>, or <I><A HREF=\"../NumberTypeSupport_ref/Class_MP_Float.html#Cross_link_anchor_1400\">MP_Float</A></I>. Note, that unless\nyou use an arbitrary precision ring type, incorrect results might\narise due to overflow.\n<P>\n\nIf new points are to be constructed, for example the\n\n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n point of two lines, computation of\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates usually involves divisions.\nHence, one needs to use a <A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A> with\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation, or alternatively, switch\nto homogeneous representation. The type <I>double</I> is a - though\nimprecise - model for <A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>. You can also put any\n<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A> into the <I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A></I> adaptor to get a field type\nwhich then can be put into <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A></I>. But using homogeneous\nrepresentation on the <A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A> is usually the better option.\nOther valid FieldNumberTypes are <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_rational.html#Cross_link_anchor_1389\">leda_rational</A></I> and\n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>.\n<P>\n\nIf it is crucial for you that the computation is reliable, the right\nchoice is probably a number type that guarantees exact computation.\nThe <I><A HREF=\"../Kernel_23_ref/Class_Filtered_kernel.html#Cross_link_anchor_12\">Filtered_kernel</A></I> provides a way to apply filtering techniques\n[<A HREF=\"../biblio.html#Biblio_cgal:bbp-iayed-01\">BBP01</A>] to achieve a kernel with exact and efficient\npredicates. Still other people will prefer the built-in\ntype <TT>double</TT>, because they need speed and can live with\napproximate results, or even algorithms that, from time to time,\ncrash or compute incorrect results due to accumulated rounding errors.\n<P>\n\n<b>Predefined kernels.</b>\n\nFor the user's convenience, C<SMALL>GAL</SMALL> provides 3 typedefs to generally useful\nkernels.\n<P>\n\n<UL>\n<LI>They are all \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n kernels.\n<LI>They all support constructions of points from <TT>double</TT> \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n\n      coordinates.\n<LI>All these 3 kernels provide exact geometric predicates.\n<LI>They handle geometric constructions differently:\n  <UL>\n  <LI><I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel.html#Cross_link_anchor_34\">Exact_predicates_exact_constructions_kernel</A></I>: provides exact\n        geometric constructions, in addition to exact geometric predicates.\n  <LI><I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel_with_sqrt.html#Cross_link_anchor_36\">Exact_predicates_exact_constructions_kernel_with_sqrt</A></I>:\n        same as <I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel.html#Cross_link_anchor_34\">Exact_predicates_exact_constructions_kernel</A></I>, but the\n        number type it provides\n        (<I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel_with_sqrt.html#Cross_link_anchor_36\">Exact_predicates_exact_constructions_kernel_with_sqrt</A>::FT</I>)\n        supports the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> root operation exactly\n        <A HREF=\"#Footnote_1\"><SUP>1</SUP></A>.\n  <LI><I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_inexact_constructions_kernel.html#Cross_link_anchor_38\">Exact_predicates_inexact_constructions_kernel</A></I>: provides exact\n        geometric predicates, but geometric constructions may be inexact due to\n        roundoff errors.  It is however enough for most C<SMALL>GAL</SMALL> algorithms, and\n        faster than both <I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel.html#Cross_link_anchor_34\">Exact_predicates_exact_constructions_kernel</A></I> and\n        <I><A HREF=\"../Kernel_23_ref/Class_Exact_predicates_exact_constructions_kernel_with_sqrt.html#Cross_link_anchor_36\">Exact_predicates_exact_constructions_kernel_with_sqrt</A></I>.\n  </UL>\n</UL>\n<P>\n\n<HR><H3>Footnotes</H3>\n<P>\n\n<TABLE><TR><TD VALIGN=TOP>\n</TD></TR><TR><TD VALIGN=TOP>\n        <A NAME=\"Footnote_1\">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>\nCurrently it requires having either LEDA or CORE installed\n\n</TD></TR></TABLE>\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"Chapter_kernel_geometry.html\">Kernel Geometry</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_2!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38757.0}