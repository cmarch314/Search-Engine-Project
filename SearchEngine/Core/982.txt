{"text": "Dynamic Binary Search Trees Rotations Rotating right or left in a binary search tree is illustrated below Note that the tree maintains its characteristics as a binary search tree y rotate xy R x x 3 1 y rotate xy L 1 2 x y z DOUBLE ROTATE xzy R 1 rotate xz R 2 rotate yz L AVL Trees height balanced trees An AVL Adelson Velskii Landis tree is a binary search tree in which the heights of the right and left subtrees of each node differ by at most 1 The height of a leaf no children is defined to be The height of an empty tree no nodes is defined to be 1 It can be shown by induction that the height H of an AVL tree with n nodes satisfies lg n 1 1 H 1 44 lg n 2 1 The balance factor of a node is defined to be Height RightSubtree Height LeftSubtree Thus in an AVL tree the balance factor of each node will be in 1 1 Insertion into an AVL tree may change change the balance factors of some nodes on the path from the inserted node to the root Any balance factor will change by at most 1 and the resulting value might become illegal i e 2 or 2 After determining the deepest node that is illegal one single or one double rotation suffices to fix up the entire tree Details Deletion from an AVL tree is handled similarly but O lg n rotations may be required Weight balanced Trees Instead of height weight number of nodes is balanced Balance can be maintained using rotations in a similar manner Splay Trees A splay tree is a binary search tree with no explicit balance condition in which a special operation called a splay is done after each search or insertion operation Splaying at node x causes node x to become the root of the binary search tree through a specific series of rotations as follows Three cases x has no grandparent zig If x is left child of root y then rotate xy R Else if x is right child of root y then rotate yx L x is LL or RR grandchild zig zig If x is left child of y and y is left child of z then rotate at grandfather yz R and then rotate at father xy R Else if x is right child of y and y is right child of z then rotate at grandfather yz L and then rotate at father xy L If x has not become the root then continue splaying at x x is LR or RL grandchild zig zag If x is right child of y and y is left child of z then rotate at father yx L and then rotate at grandfather xz R Else if x is left child of y and y is right child of z then rotate at father yx R and then rotate at grandfather xz L If x has not become the root then continue splaying at x ", "_id": "http://www.ics.uci.edu/~dan/class/165/notes/splay.html", "title": " avl and splay trees ", "html": "<HTML>\n<HEAD><TITLE> AVL and Splay Trees </TITLE></HEAD>\n<BODY>\n\n<H2>Dynamic Binary Search Trees</H2>\n\n<H3>Rotations</H3>\n\nRotating right or left in a binary search tree is illustrated below.\nNote that the tree maintains its characteristics as a binary search tree.\n<pre>\n\n     y       rotate (xy) R        x\n    / \\            ====>         / \\\n   x   3                        1   y\n  / \\        rotate (xy) L         / \\\n 1   2             <====          2   3\n\n\n            DOUBLE ROTATE (xyz) L\n    x        1. rotate (yz) R   \n     \\       2. rotate (xz) L       z\n      y          =======>          / \\\n     /                            x   y\n    z       DOUBLE ROTATE (xzy) R\n             1. rotate (xz) R        \n             2. rotate (yz) L   \n                 <=======\n</pre>\n\n<H3>AVL Trees (height-balanced trees) </H3>\n\nAn AVL (Adelson-Velskii, Landis) tree is a binary search tree\nin which the heights of the right and left subtrees of each node\ndiffer by at most 1.\n<P>\nThe height of a leaf (no children) is defined to be 0.&nbsp;\nThe height of an empty tree (no nodes) is defined to be -1.\n<P>\nIt can be shown by induction that the height, <I>H</I>, of an AVL tree with <I>n</I> nodes\nsatisfies &nbsp;lg(<I>n</I>+1)-1 <U>&lt;</U> <I>H</I> <U>&lt;</U> 1.44&nbsp;lg(<I>n</I>+2)-1.\n<P>\nThe <I>balance factor</I> of a node is defined to be\nHeight(RightSubtree) - Height(LeftSubtree).&nbsp;\nThus, in an AVL tree, the balance factor of each node will be\nin {-1,&nbsp;0,&nbsp;+1}.\n<P>\nInsertion into an AVL tree may change change the balance factors of\nsome nodes on the path from the inserted node to the root.&nbsp;\nAny balance factor will change by at most 1 and the resulting\nvalue might become illegal (i.e., -2 or +2).&nbsp;\nAfter determining the deepest node that is \"illegal\",\none single or one double rotation suffices to fix up the entire tree.&nbsp;\n<a href=\"avl2.html\">Details</a>.\n<P>\nDeletion from an AVL tree is handled similarly,\nbut <I>O</I>(lg&nbsp;<I>n</I>) rotations may be required.\n\n<H3>Weight-balanced Trees</H3>\n\nInstead of height, weight (number of nodes) is balanced.&nbsp;\nBalance can be maintained using rotations in a similar manner.\n\n<H3>Splay Trees</H3>\n\nA splay tree is a binary search tree with no explicit balance condition,\nin which a special operation called a <I>splay</I> is done after each\nsearch or insertion operation.&nbsp;  Splaying at node <I>x</I> causes\nnode <I>x</I> to become the root of the binary search tree through\na specific series of <I>rotations</I> as follows.\n<P>\nThree cases:\n<P>\n<OL>\n<LI> <I>x</I> has no grandparent (<I>zig</I>)\n   <UL>\n   <LI> If <I>x</I> is left child of root <I>y</I>, then rotate (<I>xy</I>)R.\n   <LI> Else if <I>x</I> is right child of root <I>y</I>, then rotate (<I>yx</I>)L.\n   </UL>\n   <P>\n<LI> <I>x</I> is LL or RR grandchild (<I>zig-zig</I>)\n   <UL>\n   <LI> If <I>x</I> is left child of <I>y</I>, and <I>y</I> is left child of <I>z</I>,\n   <BR> then rotate at grandfather (<I>yz</I>)R and then rotate at father (<I>xy</I>)R.\n   <LI> Else if <I>x</I> is right child of <I>y</I>, and <I>y</I> is right child of <I>z</I>,\n   <BR> then rotate at grandfather (<I>yz</I>)L and then rotate at father (<I>xy</I>)L.\n   </UL>\n   If <I>x</I> has not become the root, then continue splaying at <I>x</I>.\n   <P>\n<LI> <I>x</I> is LR or RL grandchild (<I>zig-zag</I>)\n   <UL>\n   <LI> If <I>x</I> is right child of <I>y</I>, and <I>y</I> is left child of <I>z</I>,\n   <BR> then rotate at father (<I>yx</I>)L and then rotate at grandfather (<I>xz</I>)R.\n   <LI> Else if <I>x</I> is left child of <I>y</I>, and <I>y</I> is right child of <I>z</I>,\n   <BR> then rotate at father (<I>yx</I>)R and then rotate at grandfather (<I>xz</I>)L.\n   </UL>\n   If <I>x</I> has not become the root, then continue splaying at <I>x</I>.\n</OL>\n\n<HR>\n</BODY></HTML>\n", "id": 982.0}