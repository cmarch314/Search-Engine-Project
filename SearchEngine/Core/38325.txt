{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 2Kernel Representations Our object of study is the d dimensional affine Euclidean space where d is a parameter of our geometry Objects in that space are sets of points A common way to represent the points is the use of Cartesian coordinates which assumes a reference frame an origin and d orthogonal axes In that framework a point is represented by a d tuple c c1 cd 1 and so are vectors in the underlying linear space Each point is represented uniquely by such Cartesian coordinates Another way to represent points is by homogeneous coordinates In that framework a point is represented by a d 1 tuple h h1 hd Via the formulae ci hi hd the corresponding point with Cartesian coordinates c c1 cd 1 can be computed Note that homogeneous coordinates are not unique For lambda the tuples h h1 hd and lambda h lambda h1 lambda hd represent the same point For a point with Cartesian coordinates c c1 cd 1 a possible homogeneous representation is c c1 cd 1 1 Homogeneous coordinates in fact allow to represent objects in a more general space the projective space Pd In CGAL we do not compute in projective geometry Rather we use homogeneous coordinates to avoid division operations since the additional coordinate can serve as a common denominator 2 1 Genericity through Parameterization Almost all the kernel objects and the corresponding functions are templates with a parameter that allows the user to choose the representation of the kernel objects A type that is used as an argument for this parameter must fulfill certain requirements on syntax and semantics The list of requirements defines an abstract kernel concept In CGAL such a kernel concept is often also called a representation class and denoted by R A representation class provides the actual implementations of the kernel objects For all kernel objects Kernel object the types CGAL Kernel object R and R Kernel object are identical CGAL offers two families of concrete models for the concept representation class one based on the Cartesian representation of points and one based on the homogeneous representation of points The interface of the kernel objects is designed such that it works well with both Cartesian and homogeneous representation for example points have a constructor with a range of coordinates plus a common denominator the d 1 homogeneous coordinates of the point The common interfaces parameterized with a representation class allow one to develop code independent of the chosen representation We said families of models because both families are parameterized too A user can choose the number type used to represent the coordinates and the linear algebra module used to calculate the result of predicates and constructions For reasons that will become evident later a representation class provides two typenames for number types namely R FT and R RT and one typename for the linear algebra module R LA The type R FT must fulfill the requirements on what is called a field type in CGAL This roughly means that R FT is a type for which operations and are defined with semantics approximately corresponding to those of a field in a mathematical sense Note that strictly speaking the built in type int does not fullfil the requirements on a field type since ints correspond to elements of a ring rather than a field especially operation is not the inverse of The requirements on the type R RT are weaker This type must fulfill the requirements on what is called an Euclidean ring type in CGAL This roughly means that R RT is a type for which operations are defined with semantics approximately corresponding to those of a ring in a mathematical sense A very limited division operation must be available as well It must work for exact i e no remainder integer divisions only Furthermore both number types should fulfill CGAL s requirements on a number type 2 2 Cartesian Kernel With Cartesian d FieldNumberType LinearAlgebra you can choose Cartesian representation of coordinates The type LinearAlgebra must me a linear algebra module working on numbers of type FieldNumberType The second parameter defaults to module delivered with the kernel so for short a user can just write Cartesian d FieldNumberType when not providing her own linear algebra When you choose Cartesian representation you have to declare at least the type of the coordinates A number type used with the Cartesian d representation class should be a field type as described above Both Cartesian FieldNumberType FT and Cartesian FieldNumberType RT are mapped to number type FieldNumberType Cartesian d FieldNumberType LinearAlgebra LA is mapped to the type LinearAlgebra Cartesian FieldNumberType uses reference counting internally to save copying costs 2 3 Homogeneous Kernel As we mentioned before homogeneous coordinates permit to avoid division operations in numerical computations since the additional coordinate can serve as a common denominator Avoiding divisions can be useful for exact geometric computation With Homogeneous d RingNumberType LinearAlgebra you can choose homogeneous representation of coordinates with the kernel objects As for Cartesian representation you have to declare at the same time the type used to store the homogeneous coordinates Since the homogeneous representation allows one to avoid the divisions the number type associated with a homogeneous representation class must be a model for the weaker concept Euclidean ring type only The type LinearAlgebra must me a linear algebra module working on numbers of type RingNumberType Again the second parameter defaults to module delivered with the kernel so for short one can just write Homogeneous d RingNumberType when replacing the default is no issue However some operations provided by this kernel involve division operations for example computing squared distances or returning a Cartesian coordinate To keep the requirements on the number type parameter of Homogeneous low the number type Quotient RingNumberType is used instead This number type turns a ring type into a field type It maintains numbers as quotients i e a numerator and a denominator Thereby divisions are circumvented With Homogeneous d RingNumberType Homogeneous d RingNumberType FT is equal to Quotient RingNumberType while Homogeneous d RingNumberType RT is equal to RingNumberType Homogeneous d RingNumberType LinearAlgebra LA is mapped to the type LinearAlgebra 2 4 Naming conventions The use of representation classes not only avoids problems it also makes all CGAL classes very uniform They always consist of The capitalized base name of the geometric object such as Point Segment Triangle Followed by d A representation class as parameter which itself is parameterized with a number type such as Cartesian d double or Homogeneous d leda integer 2 5 Kernel as a Traits Class Algorithms and data structures in the basic library of CGAL are parameterized by a traits class that subsumes the objects on which the algorithm or data structure operates as well as the operations to do so For most of the algorithms and data structures in the basic library you can use a kernel as a traits class For some algorithms you even do not have to specify the kernel it is detected automatically using the types of the geometric objects passed to the algorithm In some other cases the algorithms or data structures needs more than is provided by a kernel In these cases a kernel can not be used as a traits class 2 6 Choosing a Kernel If you start with integral Cartesian coordinates many geometric computations will involve integral numerical values only Especially this is true for geometric computations that evaluate only predicates which are tantamount to determinant computations Examples are triangulation of point sets and convex hull computation The dimension d of our affine space determines the dimension of the matrix computions in the mathematical evaluation of predicates As rounding errors accumulate fast the homogeneous represenation used with multi precision integers is the kernel of choice for well behaved algorithms Note that unless you use an arbitrary precision integer type incorrect results might arise due to overflow If new points are to be constructed for example the intersection point of two lines computation of Cartesian coordinates usually involves divisions so you need to use a field type with Cartesian representation or have to switch to homogeneous representation double is a possible but imprecise field type You can also put any ring type into Quotient to get a field type and put it into Cartesian but you better put the ring type into Homogeneous leda rational and leda real are valid field types too Still other people will prefer the built in type double because they need speed and can live with approximate results or even algorithms that from time to time crash or compute incorrect results due to accumulated rounding errors 2 7 Inclusion of Header Files You need just to include a representation class to obtain the the geometric objects of the kernel that you would like to use with the representation class i e CGAL Cartesian d h or CGAL Homogeneous d h Next chapter Kernel Geometry Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Kernel_d/Chapter_kernel_representation_d.html", "title": "kernel representations", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Kernel_d/kernel_representation_d.tex' -->\n<html> <head>  \n<title>Kernel Representations</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_kernel_representation_d.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_2\"></a>\n  \n<h1>Chapter 2<BR>Kernel Representations</h1>\n<P>\n\nOur object of study is the <MATH><I>d</I></MATH>-dimensional affine Euclidean space,\nwhere <MATH><I>d</I></MATH> is a parameter of our geometry.  Objects in that space are\nsets of points. A common way to represent the points is the use of\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates, which assumes a reference\nframe (an origin and <MATH><I>d</I></MATH> orthogonal axes).  In that framework, a point\nis represented by a <MATH><I>d</I></MATH>-tuple\n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>)</MATH>,\nand so are vectors in the underlying linear space. Each point is\nrepresented uniquely by such \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n\ncoordinates.\n<P>\n\nAnother way to represent points is by homogeneous coordinates. In that\nframework, a point is represented by a <MATH><I>(d+1)</I></MATH>-tuple\n<MATH>(h<SUB>0</SUB>,h<SUB>1</SUB>,...,h<SUB>d</SUB>)</MATH>.\nVia the formulae\n<MATH>c<SUB>i</SUB>=h<SUB>i</SUB>/h<SUB>d</SUB></MATH>,\nthe corresponding point with \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates\n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>)</MATH>\ncan be computed.  Note that homogeneous coordinates are not unique. \nFor <MATH>lambda != 0</MATH>,\nthe tuples \n<MATH>(h<SUB>0</SUB>,h<SUB>1</SUB>\n,...,h<SUB>d</SUB>)</MATH>\nand \n<MATH>(lambda  h<SUB>0</SUB>,lambda  h<SUB>1</SUB>,...,lambda  \nh<SUB>d</SUB>)</MATH> represent the same point.\nFor a point with \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates \n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>)</MATH> a\npossible homogeneous representation is\n<MATH>(c<SUB>0</SUB>,c<SUB>1</SUB>,...,c<SUB>d-1</SUB>,1)</MATH>.\n\n<!-- REMOVE_LINKS_BEGIN -->\nHomogeneous\n<!-- REMOVE_LINKS_END -->\n coordinates in fact allow to represent \nobjects in a more general space, the projective space\n<MATH>P<SUB>d</SUB></MATH>.\nIn C<SMALL>GAL</SMALL>, we do not compute in projective geometry. Rather, we use \nhomogeneous coordinates to avoid division operations,\nsince the additional coordinate can serve as a common denominator.\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>2.1&nbsp;&nbsp;&nbsp;Genericity through Parameterization</h2>\n\nAlmost all the kernel objects (and the corresponding functions) are\ntemplates with a parameter that allows the user to choose the\nrepresentation of the kernel objects. A type that is used as an\nargument for this parameter must fulfill certain requirements on\nsyntax and semantics. The list of requirements defines an abstract\nkernel concept. In C<SMALL>GAL</SMALL> such a kernel concept is often also called a\n<I>representation class</I> and denoted by <I>R</I>. A representation\nclass provides the actual implementations of the kernel objects.  For\nall kernel objects <I>Kernel_object</I>, the types\n<I>CGAL::Kernel_object&lt;R&gt;</I> and <I>R::Kernel_object</I> are identical.\n<P>\n\nCGAL offers two families of concrete models for the concept\nrepresentation class, one based on the \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n\nrepresentation of points and one based on the homogeneous\nrepresentation of points.  The interface of the kernel objects is\ndesigned such that it works well with both\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n and homogeneous representation, for\nexample, points have a constructor with a range of coordinates plus a\ncommon denominator (the <MATH><I>d+1</I></MATH> homogeneous coordinates of the point).\nThe common interfaces parameterized with a representation class allow\none to develop code independent of the chosen representation.  We said\n``families'' of models, because both families are parameterized too.\nA user can choose the number type used to represent the coordinates\nand the linear algebra module used to calculate the result of\npredicates and constructions.\n<P>\n\nFor reasons that will become evident later, a representation class\nprovides two typenames for number types,\nnamely <I>R::FT</I> and <I>R::RT</I> and one typename for the linear\nalgebra module <I>R::LA</I>. The type <I>R::FT</I> must fulfill the\nrequirements on what is called a <I>field type</I> in C<SMALL>GAL</SMALL>. This\nroughly means that <I>R::FT</I> is a type for which operations <MATH><I>+</I></MATH>,\n<MATH><I>-</I></MATH>, <MATH><I>*</I></MATH> and <MATH><I>/</I></MATH> are defined with semantics (approximately)\ncorresponding to those of a field in a mathematical sense. Note that,\nstrictly speaking, the built-in type <I>int</I> does not fullfil the\nrequirements on a field type, since <I>int</I>s correspond to elements\nof a ring rather than a field, especially operation <MATH><I>/</I></MATH> is not the\ninverse of <MATH><I>*</I></MATH>.  The requirements on the type <I>R::RT</I> are\nweaker.  This type must fulfill the requirements on what is called an\n<I>Euclidean ring type</I> in C<SMALL>GAL</SMALL>. This roughly means that\n<I>R::RT</I> is a type for which operations <MATH><I>+</I></MATH>, <MATH><I>-</I></MATH>, <MATH><I>*</I></MATH> are\ndefined with semantics (approximately) corresponding to those of a\nring in a mathematical sense.  A very limited division operation <MATH><I>/</I></MATH>\nmust be available as well.  It must work for exact (i.e., no\nremainder) integer divisions only.  Furthermore, both number types\nshould fulfill C<SMALL>GAL</SMALL>'s requirements on a number type.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>2.2&nbsp;&nbsp;&nbsp;Cartesian Kernel</h2>\n\nWith <I>Cartesian_d&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>,LinearAlgebra&gt;</I> you can choose\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation of coordinates. The type\n<I>LinearAlgebra</I> must me a linear algebra module working on numbers\nof type <I><A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A></I>. The second parameter defaults to module\ndelivered with the kernel so for short a user can just write\n<I>Cartesian_d&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I> when not providing her own linear\nalgebra.\n<P>\n\nWhen you choose \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation you have\nto declare at least the type of the coordinates.  A number type used\nwith the <I>Cartesian_d</I> representation class should be a <I>field\n  type</I> as described above.  Both <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;::FT</I>\nand <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;::RT</I> are mapped to number type\n<I><A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A></I>.\n<I>Cartesian_d&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>,LinearAlgebra&gt;::LA</I> is mapped to the\ntype <I>LinearAlgebra</I>. <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_FieldNumberType.html#Cross_link_anchor_2\">FieldNumberType</A>&gt;</I> uses\nreference counting internally to save copying costs.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>2.3&nbsp;&nbsp;&nbsp;Homogeneous Kernel</h2>\n\nAs we mentioned before, homogeneous coordinates permit to avoid\ndivision operations in numerical computations, since the additional\ncoordinate can serve as a common denominator.  Avoiding divisions can\nbe useful for exact geometric computation.  With\n<I>Homogeneous_d&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>,LinearAlgebra&gt;</I> you can choose\nhomogeneous representation of coordinates with the kernel objects. \nAs for \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n representation you have to declare\nat the same time the type used to store the homogeneous coordinates.\nSince the homogeneous representation allows one to avoid the\ndivisions, the number type associated with a homogeneous\nrepresentation class must be a model for the weaker concept Euclidean\nring type only.\n<P>\n\nThe type <I>LinearAlgebra</I> must me a linear algebra module working\non numbers of type <I><A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A></I>. Again the second parameter\ndefaults to module delivered with the kernel so for short one can just\nwrite <I>Homogeneous_d&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> when replacing the default\nis no issue.\n<P>\n\nHowever, some operations provided by this kernel involve division\noperations, for example computing squared distances or returning a\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinate.  To keep the requirements on\nthe number type parameter of <I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A></I> low, the number type\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> is used instead.  This number type\nturns a ring type into a field type. It maintains numbers as\nquotients, i.e. a numerator and a denominator.  Thereby, divisions are\ncircumvented.  With <I>Homogeneous_d&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I>,\n<I>Homogeneous_d&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;::FT</I> is equal to\n<I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;</I> while\n<I>Homogeneous_d&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>&gt;::RT</I> is equal to\n<I><A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A></I>.\n<I>Homogeneous_d&lt;<A HREF=\"../Kernel_23_ref/Concept_RingNumberType.html#Cross_link_anchor_3\">RingNumberType</A>,LinearAlgebra&gt;::LA</I> is mapped to the\ntype <I>LinearAlgebra</I>.\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>2.4&nbsp;&nbsp;&nbsp;Naming conventions</h2>\n<P>\n\nThe use of representation classes not only avoids problems, it also\nmakes all C<SMALL>GAL</SMALL> classes very uniform. They <B>always</B> consist of:\n<OL>\n<P>\n\n<LI>The <I>capitalized base name</I> of the geometric object, such as\n  <I>Point</I>, <I>Segment</I>, <I>Triangle</I>.\n<P>\n\n<LI>Followed by <I>_d</I>.\n<P>\n\n<LI>A <I>representation class</I> as parameter, which itself is\n  parameterized with a number type, such as\n  <I>Cartesian_d&lt;double&gt;</I> or <I>Homogeneous_d&lt;<A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A>&gt;</I>.\n</OL>\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>2.5&nbsp;&nbsp;&nbsp;Kernel as a Traits Class</h2>\n<P>\n\nAlgorithms and data structures in the basic library of CGAL are\nparameterized by a traits class that subsumes the objects on which the\nalgorithm or data structure operates as well as the operations to do\nso. For most of the algorithms and data structures in the basic\nlibrary you can use a kernel as a traits class. For some algorithms\nyou even do not have to specify the kernel; it is detected\nautomatically using the types of the geometric objects passed to the\nalgorithm. In some other cases, the algorithms or data structures\nneeds more than is provided by a kernel. In these cases, a kernel can\nnot be used as a traits class.\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>2.6&nbsp;&nbsp;&nbsp;Choosing a Kernel</h2>\n<P>\n\nIf you start with integral \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates,\nmany geometric computations will involve integral numerical values\nonly. Especially, this is true for geometric computations that\nevaluate only predicates, which are tantamount to determinant\ncomputations. Examples are triangulation of point sets and convex hull\ncomputation.\n<P>\n\nThe dimension <MATH><I>d</I></MATH> of our affine space determines the dimension of the\nmatrix computions in the mathematical evaluation of predicates.  As\nrounding errors accumulate fast the homogeneous represenation used\nwith multi-precision integers is the kernel of choice for well-behaved\nalgorithms.  Note, that unless you use an arbitrary precision integer\ntype, incorrect results might arise due to overflow.\n<P>\n\nIf new points are to be constructed, for example the\n\n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n point of two lines, computation of\n\n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n coordinates usually involves divisions,\nso you need to use a field type with \n<!-- REMOVE_LINKS_BEGIN -->\nCartesian\n<!-- REMOVE_LINKS_END -->\n\nrepresentation or have to switch to homogeneous representation.\n<I>double</I> is a possible, but imprecise field type.  You can also\nput any ring type into <I><A HREF=\"../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404\">Quotient</A></I> to get a field type and put it\ninto <I><A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A></I>, but you better put the ring type into\n<I><A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A></I>.  <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_rational.html#Cross_link_anchor_1389\">leda_rational</A></I> and <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I> are valid\nfield types, too.\n<P>\n\nStill other people will prefer the built-in type <TT>double</TT>, because\nthey need speed and can live with approximate results, or even\nalgorithms that, from time to time, crash or compute incorrect results\ndue to accumulated rounding errors.\n<P>\n\n<a name=\"Section_7\"></a>\n        \n<h2>2.7&nbsp;&nbsp;&nbsp;Inclusion of Header Files</h2>\n<P>\n\nYou need just to include a representation class to obtain the the\ngeometric objects of the kernel that you would like to use with the\nrepresentation class, i.e., <I>CGAL/Cartesian_d.h</I> or\n<I>CGAL/Homogeneous_d.h</I>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"Chapter_kernel_geometry_d.html\">Kernel Geometry</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_2!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38325.0}