{"text": "Navigation Up Table of Contents Bibliography Index Title Page CGAL Width 3 Traits Definition Given a set of points p1 pn in 3 The width of denoted as is defined as the minimum distance between two parallel planes of support of conv where conv denotes the convex hull of The width in direction d denoted as d is the distance between two parallel planes of support of conv which are orthogonal to d Subject to the applications of the width algorithm several objects might be interesting The two parallel planes of support such that the distance between them is as small as possible These planes are called width planes in further considerations The width i e the distance between the width planes The direction dopt such that dopt Note There might be several optimal build directions Hence neither the width planes nor the direction dopt are unique only the width is include CGAL Width 3 h Requirements The template parameter Traits is a model for WidthTraits 3 We provide the model Width default traits 3 Kernel based on a three dimensional CGAL kernel Types Width 3 Traits Traits traits class typedef typename Traits Point 3 Point 3 point type typedef typename Traits Plane 3 Plane 3 plane type typedef typename Traits Vector 3 Vector 3 vector type typedef typename Traits RT RT algebraic ring type typedef typename Traits ChullTraits ChullTraits traits class for the 3D convex hull algorithm Creation template class InputIterator Width 3 Traits width InputIterator first InputIterator beyond creates a variable width initialized to the width of with being the set of points in the range first beyond Requirement The value type of InputIterator is Point 3 template class Polyhedron Width 3 Traits width Polyhedron P creates a variable width initialized to the width of the polyhedron P Note that the vertex point coordinates are altered Precondition P is a convex polyhedron Requirement Polyhedron is a CGAL Polyhedron 3 with facets supporting plane equations where Polyhedron Point 3 Point 3 and Polyhedron Plane 3 Plane 3 Access Functions void width get squared width RT width num RT width denom returns the squared width For the reason of exact computation not the width itself is stored but the squared width as a fraction The numerator in width num and the denominator in width denom The width of the point set is sqrt width num width denom void width get width planes Plane 3 e1 Plane 3 e2 The planes e1 and e2 are the two parallel supporting planes which distance is minimal among all such planes void width get width coefficients RT A RT B RT C RT D RT K The returned coefficients A B C D K have the property that width plane e1 is given by the equation Ax By Cz D and width plane e2 by Ax By Cz K Vector 3 width get build direction returns a direction dopt such that the width planes e1 and e2 are perpendicular to dopt The width of the point set is minimal in this direction void width get all build directions std vector Vector 3 dir All the build directions are stored in the vector dir It might happen that a certain body has several different build directions but it is also possible to have only one build direction int width get number of optimal solutions returns the number of optimal solutions i e the number of optimal build directions See Also CGAL Width default traits 3 K WidthTraits 3 Implementation Since the width of the point set and the width of the convex hull of conv is the same the algorithm uses the 3D convex hull algorithm CGAL provides The width algorithm is not incremental and therefore inserting and erasing points cause not an automatic update of the width Instead you have to run the width algorithm again even if the point set is extended by only one new point advanced Large Numbers Because there is no need for dividing values during the algorithm the numbers can get really huge all the computations are made using a lot of multiplications Therefore it is strongly recommended to use a number type that can handle numbers of arbitrary length e g leda integer in combination with the homogeneous representation of the points But these large numbers have a disadvantage Operations on them are slower as greater the number gets Therefore it is possible to shorten the numbers by using the compiler flag DSIMPLIFY For using this option it is required that the underlying number type provides the modulo operation Information Output during the Computations If during the algorithm the program should output some information e g during the debugging phase you can turn on the output information by giving the compiler flag DEBUG In the file width assertions h you can turn on off the output of some functions and additional informations by changing the defined values from no output to 1 output available But then it is required that the operator has to been overloaded for Point 3 Plane 3 Vector 3 and RT advanced Example include CGAL Homogeneous h include CGAL Width default traits 3 h include CGAL Width 3 h include iostream include vector include CGAL leda integer h typedef leda integer RT typedef CGAL Homogeneous RT Kernel typedef Kernel Point 3 Point 3 typedef Kernel Plane 3 Plane 3 typedef CGAL Width default traits 3 Kernel Width traits typedef CGAL Width 3 Width traits Width int main Create a simplex using homogeneous integer coordinates std vector Point 3 points points push back Point 3 2 1 points push back Point 3 1 1 points push back Point 3 1 1 points push back Point 3 1 Compute width of simplex Width simplex points begin points end Output of squared width width planes and optimal direction RT wnum wdenom simplex get squared width wnum wdenom std cout Squared Width wnum wdenom std endl std cout Direction simplex get build direction std endl Plane 3 e1 e2 std cout Planes E1 e1 E2 e2 std endl std cout Number of optimal solutions simplex get number of optimal solutions std endl return Next Width default traits 3 K Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Optimisation_ref/Class_Width_3.html", "title": "width_3&lt;traits&gt;", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Optimisation_ref/Width_3.tex' -->\n<html> <head>  \n<title>Width_3&lt;Traits&gt;</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_1199\"></A>\n\n<A NAME=\"Cross_link_anchor_1200\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_1240\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Class.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_CGAL::Width_3<Traits>\"></A>\n<h2><I>CGAL::Width_3&lt;Traits&gt;</I></h2>\n<P>\n\n<A NAME=\"Index_anchor_1241\"></A> \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1242\"></A> \n\n   \n\n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1243\"></A> \n\n   \n\n   \n\n\n   \n     \n     \n<A NAME=\"Index_anchor_1244\"></A>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nGiven a set of points <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">={p<SUB>1</SUB>,..., p<SUB>n</SUB>}</I></MATH> in\n<MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>3</SUP></I></MATH>. The width of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH>, denoted as <MATH><I><IMG BORDER=0 WIDTH=17 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_W.gif\">(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></MATH>, is defined\nas the minimum distance between two <A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A> planes of support of\n<MATH><I><I>conv(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></I></MATH>; where <MATH><I><I>conv(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></I></MATH> denotes\nthe convex hull of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH>. The width in direction <MATH><I><B>d</B></I></MATH>,\ndenoted as <MATH><I><IMG BORDER=0 WIDTH=17 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_W.gif\"><SUB>d</SUB>(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></MATH>, is the distance between two\n<A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A> planes of support of <MATH><I><I>conv(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></I></MATH>, which are\northogonal to <MATH><I><B>d</B></I></MATH>.\n<P>\n\nSubject to the applications of the width algorithm, several objects\nmight be interesting: \n<OL>\n<LI>The two <A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A> planes of support such that the distance\n  between them is as small as possible. These planes are called\n  width-planes in further considerations.\n<LI>The width <MATH><I><IMG BORDER=0 WIDTH=17 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_W.gif\">(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></MATH>, i.e., the distance between the\n  width-planes.\n<LI>The direction <MATH><I><B>d</B><SUB>opt</SUB></I></MATH> such that\n  <MATH><I><IMG BORDER=0 WIDTH=17 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_W.gif\">(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)=<IMG BORDER=0 WIDTH=17 HEIGHT=13 ALIGN=BOTTOM SRC=\"cc_mathcal_W.gif\"><SUB>d<SUB>opt</SUB></SUB>(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></MATH>\n</OL>\n<P>\n\n<I>Note:</I> There might be several optimal build directions. Hence\nneither the width-planes nor the direction <MATH><I><B>d</B><SUB>opt</SUB></I></MATH> are\nunique - only the width is.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/Width_3.h\">CGAL/Width_3.h</A>&gt;</I>\n<P>\n\n<H3>Requirements</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1245\"></A>\n<P>\n\nThe template parameter <I>Traits</I> is a model for <I><A HREF=\"Concept_WidthTraits_3.html#Cross_link_anchor_1203\">WidthTraits_3</A></I>.\nWe provide the model <I><A HREF=\"Class_Width_default_traits_3.html#Cross_link_anchor_1202\">Width_default_traits_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;</I> based on a\nthree-dimensional C<SMALL>GAL</SMALL>&nbsp;kernel.\n<P>\n\n<H3>Types</H3>   \n     \n     \n<A NAME=\"Index_anchor_1246\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Width_3.html#Cross_link_anchor_1200\">Width_3</A>&lt;Traits&gt;::Traits\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    traits class.\n<P>\n\n</TD></TR>\n        </TABLE>\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Point_3\"></A>\n<A NAME=\"Typedef_Point_3\"></A>\ntypedef typename Traits::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    point type.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Plane_3\"></A>\n<A NAME=\"Typedef_Plane_3\"></A>\ntypedef typename Traits::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    plane type.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Vector_3\"></A>\n<A NAME=\"Typedef_Vector_3\"></A>\ntypedef typename Traits::<A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    vector type.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_RT\"></A>\n<A NAME=\"Typedef_RT\"></A>\ntypedef typename Traits::RT\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    RT;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    algebraic ring type.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_ChullTraits\"></A>\n<A NAME=\"Typedef_ChullTraits\"></A>\ntypedef typename Traits::ChullTraits\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    ChullTraits;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    traits\n                                    class for the 3D convex hull algorithm.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Creation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1247\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class InputIterator &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Width_3.html#Cross_link_anchor_1200\">Width_3</A>&lt;Traits&gt; width ( InputIterator first,  InputIterator beyond);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable <I>width</I> initialized to the width of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> - \n    with <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> being the set of points in the range \n    [<I>first</I>,<I>beyond</I>).<BR>\n\n<EM>Requirement: </EM> The value type of <I>InputIterator</I> \n    is <I><A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A></I>.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    template &lt; class Polyhedron &gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Class_Width_3.html#Cross_link_anchor_1200\">Width_3</A>&lt;Traits&gt; width ( Polyhedron&amp; P);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    creates a variable <I>width</I> initialized to \n    the width of the polyhedron <MATH><I>P</I></MATH>. Note that the vertex point coordinates\n    are altered!<BR>\n\n<EM>Precondition: </EM><MATH><I>P</I></MATH> is a convex polyhedron.<BR>\n\n<EM>Requirement: </EM> <I>Polyhedron</I> is a \n    <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A></I> with facets supporting plane equations\n    where <I>Polyhedron::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A></I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A></I> and\n    <I>Polyhedron::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A></I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=9 ALIGN=BOTTOM SRC=\"cc_equiv.gif\"> </I></MATH> <I><A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A></I>.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>   \n     \n     \n<A NAME=\"Index_anchor_1248\"></A> \n\n   \n\n\n   \n     \n     \n     \n<A NAME=\"Index_anchor_1249\"></A> \n\n   \n   \n     \n     \n<A NAME=\"Index_anchor_1250\"></A>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_get_squared_width_6_RT__width_num+_RT__width_denom_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    width.get_squared_width ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RT&amp; width_num,<BR>\n\nRT&amp; width_denom)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the squared width. For the reason of exact\n  computation not the width itself is stored, but the <I>squared</I>\n  width as a fraction: The numerator in <I>width_num</I> and the\n  denominator in <I>width_denom</I>. The width of the point set\n  <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> is\n  <MATH><I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>((<I>width_num</I>)/(<I>width_denom</I>))</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_get_width_planes_6_Plane_3__e1+_Plane_3__e2_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    width.get_width_planes ( <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>&amp; e1,  <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>&amp; e2)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The planes <I>e1</I> and <I>e2</I> are the two <A HREF=\"../Kernel_23_ref/Function_parallel.html#Cross_link_anchor_249\">parallel</A> supporting\n  planes, which distance is minimal (among all such planes).\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_get_width_coefficients_6_RT__A+RT__B+RT__C+_RT__D+_RT__K_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    width.get_width_coefficients ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    RT&amp; A,<BR>\n\nRT&amp; B,<BR>\n\nRT&amp; C,<BR>\n\nRT&amp; D,<BR>\n\nRT&amp; K)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The returned coefficients <I>A,B,C,D,K</I> have the\n  property that width-plane <I>e1</I> is given by the equation\n  <MATH><I>Ax+By+Cz+D=0</I></MATH> and width-plane <I>e2</I> by <MATH><I>Ax+By+Cz+K=0</I></MATH>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vector_3_get_build_direction_6_9;\"></A>\n<A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    width.get_build_direction ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns a\n  direction <MATH><I><B>d</B><SUB>opt</SUB></I></MATH> such that the width-planes <I>e1</I> and\n  <I>e2</I> are perpendicular to <MATH><I><B>d</B><SUB>opt</SUB></I></MATH>. The width of the\n  point set is minimal in this direction.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_get_all_build_directions_6_std::vector6Vector_39__dir_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    width.get_all_build_directions ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    std::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A>&gt;&amp; dir)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    All the build directions are stored in the vector\n  <I>dir</I>. It might happen that a certain body has several\n  different build directions, but it is also possible to have only one\n  build direction.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_get_number_of_optimal_solutions6_9;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    width.get_number_of_optimal_solutions ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns\n  the number of optimal solutions, i.e., the number of optimal build\n  directions.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>See Also</H3>\n<P>\n\n<I><A HREF=\"Class_Width_default_traits_3.html#Cross_link_anchor_1201\">CGAL::Width_default_traits_3</A>&lt;K&gt;</I><BR>\n\n<I><A HREF=\"Concept_WidthTraits_3.html#Cross_link_anchor_1203\">WidthTraits_3</A></I>\n<P>\n\n<H3>Implementation</H3>   \n     \n     \n<A NAME=\"Index_anchor_1251\"></A>\n<P>\n\nSince the width of the point set <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> and the width of the convex\nhull of <MATH><I><IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\"></I></MATH> (<MATH><I><I>conv(<IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathcal_S.gif\">)</I></I></MATH>) is the same, the\nalgorithm uses the 3D convex hull algorithm C<SMALL>GAL</SMALL> provides.\n<P>\n\nThe width-algorithm is not incremental and therefore inserting and\nerasing points cause not an `automatic' update of the width. Instead\nyou have to run the width-algorithm again even if the point set is\nextended by only one new point.\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<P>\n\n<b>Large Numbers.</b>\n<P>\n\nBecause there is no need for dividing values during the algorithm, the\nnumbers can get really huge (all the computations are made using a lot\nof multiplications).  Therefore it is strongly recommended to use a\nnumber type that can handle numbers of arbitrary length (e.g.,\n<I><A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A></I> in combination with the homogeneous representation\nof the points). But these large numbers have a disadvantage:\nOperations on them are slower as greater the number gets. Therefore it\nis possible to shorten the numbers by using the compiler flag\n-D<SMALL>SIMPLIFY</SMALL>. For using this option it is required that\nthe underlying number type provides the `modulo' operation.\n<P>\n\n<b>Information Output during the Computations.</b>\n<P>\n\nIf during the algorithm the program should output some information\n(e.g., during the debugging phase) you can turn on the output\ninformation by giving the compiler flag <SMALL>DEBUG</SMALL>. In the file\n<TT>width_assertions.h</TT> you can turn on/off the output of some\nfunctions and additional informations by changing the defined values\nfrom 0 (no output) to 1 (output available). But then it is required\nthat the <MATH><I>&lt;&lt;</I></MATH>-operator has to been overloaded for <I><A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A></I>,\n<I><A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A></I>, <I><A HREF=\"../Kernel_23_ref/Class_Vector_3.html#Cross_link_anchor_86\">Vector_3</A></I> and <I>RT</I>.\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Example</H3>\n   \n     \n     \n<A NAME=\"Index_anchor_1252\"></A>\n<P>\n\n<pre class=\"ExampleCode\">#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Width_default_traits_3.html#Cross_link_anchor_1202\">Width_default_traits_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"Class_Width_3.html#Cross_link_anchor_1200\">Width_3</A>.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;CGAL/<A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A>.h&gt;\n\ntypedef <A HREF=\"../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388\">leda_integer</A>                          RT;\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;RT&gt;                 <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                       <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Plane_3.html#Cross_link_anchor_458\">Kernel::Plane_3</A>                       <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\ntypedef <A HREF=\"Class_Width_default_traits_3.html#Cross_link_anchor_1201\">CGAL::Width_default_traits_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Width_traits;\ntypedef <A HREF=\"Class_Width_3.html#Cross_link_anchor_1199\">CGAL::Width_3</A>&lt;Width_traits&gt;           Width;\n\nint main() {\n    // Create a simplex using homogeneous integer coordinates\n    std::vector&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt; points;\n    points.push_back( <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>(2,0,0,1));\n    points.push_back( <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>(0,1,0,1));\n    points.push_back( <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>(0,0,1,1));\n    points.push_back( <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>(0,0,0,1));\n\n    // Compute width of simplex\n    Width simplex( points.begin(), points.end());\n\n    // Output of squared width, width-planes, and optimal direction\n    RT wnum, wdenom;\n    simplex.get_squared_width( wnum, wdenom);\n    std::cout &lt;&lt; &quot;Squared Width: &quot; &lt;&lt; wnum &lt;&lt; &quot;/&quot; &lt;&lt; wdenom &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; &quot;Direction: &quot; &lt;&lt; simplex.get_build_direction() &lt;&lt; std::endl;\n\n    <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>  e1, e2;\n    std::cout &lt;&lt; &quot;Planes: E1: &quot; &lt;&lt; e1 &lt;&lt; &quot;.  E2: &quot; &lt;&lt; e2 &lt;&lt;std::endl;\n\n    std::cout &lt;&lt; &quot;Number of optimal solutions: &quot;\n              &lt;&lt; simplex.get_number_of_optimal_solutions() &lt;&lt; std::endl;\n    return(0);\n}\n\n\n\n\n\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Class_Width_default_traits_3.html\"><I>Width_default_traits_3&lt;K&gt;</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_52!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39333.0}