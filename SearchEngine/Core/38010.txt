{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 12D Convex Hulls and Extreme Points Susan Hert and Stefan Schirra 1 1 Introduction A subset S 2 is convex if for any two points p and q in the set the line segment with endpoints p and q is contained in S The convex hull of a set S is the smallest convex set containing S The convex hull of a set of points P is a convex polygon with vertices in P A point in P is an extreme point with respect to P if it is a vertex of the convex hull of P A set of points is said to be strongly convex if it consists of only extreme points This chapter describes the functions provided in CGAL for producing convex hulls in two dimensions as well as functions for checking if sets of points are strongly convex are not There are also a number of functions described for computing particular extreme points and subsequences of hull points such as the lower and upper hull of a set of points 1 2 Convex Hull CGAL provides implementations of several classical algorithms for computing the counterclockwise sequence of extreme points for a set of points in two dimensions i e the counterclockwise sequence of points on the convex hull The algorithms have different asymptotic running times and require slightly different sets of geometric primitives Thus you may choose the algorithm that best fits your setting Each of the convex hull functions presents the same interface to the user That is the user provides a pair of iterators first and beyond an output iterator result and a traits class traits The points in the range first beyond define the input points whose convex hull is to be computed The counterclockwise sequence of extreme points is written to the sequence starting at position result and the past the end iterator for the resulting set of points is returned The traits classes for the functions specify the types of the input points and the geometric primitives that are required by the algorithms All functions provide an interface in which this class need not be specified and defaults to types and operations defined in the kernel in which the input point type is defined Given a sequence of n input points with h extreme points the function convex hull 2 uses either the output sensitive O n h algorithm of Bykat Byk78 a non recursive version of the quickhull BDH96 algorithm or the algorithm of Akl and Toussaint which requires O n logn time in the worst case The algorithm chosen depends on the kind of iterator used to specify the input points These two algorithms are also available via the functions ch bykat and ch akl toussaint respectively Also available are the O n logn Graham Andrew scan algorithm And79 Meh84 ch graham andrew the O n h Jarvis march algorithm Jar73 ch jarvis and Eddy s O n h algorithm Edd77 ch eddy which corresponds to the two dimensional version of the quickhull algorithm The linear time algorithm of Melkman for producing the convex hull of simple polygonal chains or polygons is available through the function ch melkman 1 3 Example using GrahamAndrew s algorithm In the following example a convex hull is constructed from point data read from standard input using Graham Andrew algorithm The resulting convex polygon is shown at the standard ouput console The same results could be achieved by substituting the function CGAL ch graham andrew by other function like CGAL ch bykat file examples Convex hull 2 ch example from cin to cout C include CGAL Cartesian h include CGAL ch graham andrew h typedef CGAL Point 2 CGAL Cartesian double Point 2 int main CGAL set ascii mode std cin CGAL set ascii mode std cout std istream iterator Point 2 in start std cin std istream iterator Point 2 in end std ostream iterator Point 2 out std cout n CGAL ch graham andrew in start in end out return 1 4 Extreme Points and Hull Subsequences In addition to the functions for producing convex hulls there are a number of functions for computing sets and sequences of points related to the convex hull The functions lower hull points 2 and upper hull points 2 provide the computation of the counterclockwise sequence of extreme points on the lower hull and upper hull respectively The algorithm used in these functions is Andrew s variant of Graham s scan algorithm And79 Meh84 which has worst case running time of O n logn There are also functions available for computing certain subsequences of the sequence of extreme points on the convex hull The function ch jarvis march generates the counterclockwise ordered subsequence of extreme points between a given pair of points and ch graham andrew scan computes the sorted sequence of extreme points that are not left of the line defined by the first and last input points Finally a set of functions ch nswe point ch ns point ch we point ch n point ch s point ch w point ch e point is provided for computing extreme points of a 2D point set in the coordinate directions 1 5 Traits Classes Each of the functions used to compute convex hulls or extreme points is paramterized by a traits class which specifies the types and geometric primitives to be used in the computation There are several implementations of 2D traits classes provided in the library The class Convex hull traits 2 R corresponds to the default traits class that provides the types and predicates presented in the 2 dimensional CGAL kernel in which the input points lie The class Convex hull constructive traits R is a second traits class based on CGAL primitives but differs from Convex hull traits 2 in that some of its primitives reuse intermediate results to speed up computation In addition there are three projective traits classes Convex hull projective xy traits 2 Convex hull projective xz traits 2 and Convex hull projective yz traits 2 which may be used to compute the convex hull of a set of three dimensional points projected into each of the three coordinate planes 1 6 Convexity Checking The functions is ccw strongly convex 2 and is cw strongly convex 2 check whether a given sequence of 2D points forms a counter clockwise strongly convex polygon These are used in postcondition testing of the two dimensional convex hull functions Next chapter 2D Convex Hulls and Extreme Points Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Convex_hull_2/Chapter_main.html", "title": "2d convex hulls and extreme points", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Convex_hull_2/main.tex' -->\n<html> <head>  \n<title>2D Convex Hulls and Extreme Points</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_1\"></a>\n  \n<h1>Chapter 1<BR>2D Convex Hulls and Extreme Points</h1>\n\n<A NAME=\"chap:convex_hull_2\"></A>\n<EM>Susan Hert  and Stefan Schirra</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>1.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nA subset <MATH><I>S  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_subseteq.gif\">  <IMG BORDER=0 WIDTH=13 HEIGHT=12 ALIGN=BOTTOM SRC=\"cc_mathbb_R.gif\"> <SUP>2</SUP></I></MATH> is convex if for any two points <MATH><I>p</I></MATH> and <MATH><I>q</I></MATH>\nin the set the line segment with endpoints <MATH><I>p</I></MATH> and <MATH><I>q</I></MATH> is contained\nin <MATH><I>S</I></MATH>. The convex hull \n     \n<A NAME=\"Index_anchor_430\"></A> \n \n   \n of a set <MATH><I>S</I></MATH> \nis the smallest convex set containing\n<MATH><I>S</I></MATH>. The convex hull of a set of points <MATH><I>P</I></MATH> is a convex \npolygon with vertices in <MATH><I>P</I></MATH>. A point in <MATH><I>P</I></MATH> is an extreme point \n(with respect to <MATH><I>P</I></MATH>) \n     \n<A NAME=\"Index_anchor_431\"></A> \n \n   \n if it is a vertex of \nthe convex hull of <MATH><I>P</I></MATH>.  A set of points is said to be strongly convex  \n     \n<A NAME=\"Index_anchor_432\"></A> \n \n   \n if it consists of only extreme points.\n<P>\n\nThis chapter describes the functions provided in\nC<SMALL>GAL</SMALL> for producing convex hulls in two dimensions as well as\nfunctions for checking if sets of points are strongly convex are not.  \nThere are also a number of functions described for computing particular \nextreme points and subsequences of hull points, such as the lower and \nupper hull of a set of points.\n\n\n<center>\n<img border=0 src=\"./saarhull.gif\" align=center>\n</center>\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>1.2&nbsp;&nbsp;&nbsp;Convex Hull</h2>\n\n<A NAME=\"sec:convex_hull_2\"></A>\nC<SMALL>GAL</SMALL> provides implementations of several classical algorithms for\ncomputing the counterclockwise sequence of extreme points for a set of \npoints in two dimensions (<I>i.e.</I>, the counterclockwise sequence \nof points on the convex hull).  The algorithms have different asymptotic\nrunning times and require slightly different sets of geometric primitives. \nThus you may choose the algorithm that best fits your setting.\n<P>\n\nEach of the convex hull functions presents the same interface to the\nuser.  That is, the user provides a pair of iterators, <I>first</I>\nand <I>beyond</I>, an output iterator <I>result</I>,  and a traits class\n<I>traits</I>. The points in the range [<I>first</I>, <I>beyond</I>) define\nthe input points whose convex hull is to be computed.  The counterclockwise\nsequence of extreme points is written to the sequence starting at position\n<I>result</I>, and the past-the-end iterator for the resulting set of\npoints is returned.  The traits classes for the functions specify the types\nof the input points and the geometric primitives that are required by\nthe algorithms. All functions provide an interface in which this\nclass need not be specified and defaults to types and operations defined\nin the kernel in which the input point type is defined.\n<P>\n\nGiven a sequence of <MATH><I>n</I></MATH> input points with <MATH><I>h</I></MATH> extreme points,\nthe function <I><A HREF=\"../Convex_hull_2_ref/Function_convex_hull_2.html#Cross_link_anchor_609\">convex_hull_2</A></I>\n<A NAME=\"Index_anchor_433\"></A> \n\nuses either the output-sensitive <MATH><I>O(n h)</I></MATH> algorithm of Bykat [<A HREF=\"../biblio.html#Biblio_b-chfsp-78\">Byk78</A>]\n(a non-recursive version of the quickhull [<A HREF=\"../biblio.html#Biblio_bdh-qach-96\">BDH96</A>] algorithm)   \n     \n     \n<A NAME=\"Index_anchor_434\"></A> \n\n   \n\n   \n     \n     \n<A NAME=\"Index_anchor_435\"></A> \n\n   \n \nor the algorithm of Akl and Toussaint, which requires <MATH><I>O(n </I></MATH>log<MATH><I>n)</I></MATH> time\nin the worst case.  The algorithm chosen depends on the kind of \niterator used to specify the input points.  These two algorithms are\nalso available via the functions <I><A HREF=\"../Convex_hull_2_ref/Function_ch_bykat.html#Cross_link_anchor_581\">ch_bykat</A></I> and <I><A HREF=\"../Convex_hull_2_ref/Function_ch_akl_toussaint.html#Cross_link_anchor_579\">ch_akl_toussaint</A></I>,\nrespectively.  Also available are \nthe <MATH><I>O(n </I></MATH>log<MATH><I>n)</I></MATH> Graham-Andrew scan algorithm [<A HREF=\"../biblio.html#Biblio_a-aeach-79\">And79</A>, <A HREF=\"../biblio.html#Biblio_m-mdscg-84\">Meh84</A>] \n(<I><A HREF=\"../Convex_hull_2_ref/Function_ch_graham_andrew.html#Cross_link_anchor_587\">ch_graham_andrew</A></I>\n<A NAME=\"Index_anchor_436\"></A> \n), \nthe <MATH><I>O(n h)</I></MATH> Jarvis march algorithm [<A HREF=\"../biblio.html#Biblio_j-ichfs-73\">Jar73</A>]\n(<I><A HREF=\"../Convex_hull_2_ref/Function_ch_jarvis.html#Cross_link_anchor_591\">ch_jarvis</A></I>\n<A NAME=\"Index_anchor_437\"></A> \n),\nand Eddy's <MATH><I>O(n h)</I></MATH> algorithm [<A HREF=\"../biblio.html#Biblio_e-nchap-77\">Edd77</A>]\n(<I><A HREF=\"../Convex_hull_2_ref/Function_ch_eddy.html#Cross_link_anchor_583\">ch_eddy</A></I>\n<A NAME=\"Index_anchor_438\"></A> \n), which corresponds to the \ntwo-dimensional version of the quickhull algorithm.\nThe linear-time algorithm of Melkman for producing the convex hull of \nsimple polygonal chains (or polygons) is available through the function\n<I><A HREF=\"../Convex_hull_2_ref/Function_ch_melkman.html#Cross_link_anchor_595\">ch_melkman</A></I>\n<A NAME=\"Index_anchor_439\"></A> \n.   \n     \n     \n<A NAME=\"Index_anchor_440\"></A>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>1.3&nbsp;&nbsp;&nbsp;Example using GrahamAndrew's algorithm</h2>\n<P>\n\nIn the following example a convex hull is constructed from point data read \nfrom standard input using <I>Graham_Andrew</I> algorithm. The resulting convex \npolygon is shown at the standard ouput console. The same results could be \nachieved by substituting the function <I><A HREF=\"../Convex_hull_2_ref/Function_ch_graham_andrew.html#Cross_link_anchor_586\">CGAL::ch_graham_andrew</A></I> by other \nfunction like <I><A HREF=\"../Convex_hull_2_ref/Function_ch_bykat.html#Cross_link_anchor_580\">CGAL::ch_bykat</A></I>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Convex_hull_2/ch_example_from_cin_to_cout.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Convex_hull_2_ref/Function_ch_graham_andrew.html#Cross_link_anchor_587\">ch_graham_andrew</A>.h&gt;\n\ntypedef   <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_51\">CGAL::Point_2</A>&lt;<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt; &gt;        <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\n\nint main()\n{\n  <A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1743\">CGAL::set_ascii_mode</A>(std::cin); \n  <A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1743\">CGAL::set_ascii_mode</A>(std::cout); \n  std::istream_iterator&lt; <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> &gt;  in_start( std::cin );\n  std::istream_iterator&lt; <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> &gt;  in_end;\n  std::ostream_iterator&lt; <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A> &gt;  out( std::cout, &quot;\\n&quot; );\n  <A HREF=\"../Convex_hull_2_ref/Function_ch_graham_andrew.html#Cross_link_anchor_586\">CGAL::ch_graham_andrew</A>( in_start, in_end, out );\n  return 0;\n}\n\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>1.4&nbsp;&nbsp;&nbsp;Extreme Points and Hull Subsequences</h2>\n\nIn addition to the functions for producing convex hulls, there are a\nnumber of functions for computing sets and sequences of points related\nto the convex hull.  \nThe functions <I><A HREF=\"../Convex_hull_2_ref/Function_lower_hull_points_2.html#Cross_link_anchor_626\">lower_hull_points_2</A></I>\n<A NAME=\"Index_anchor_441\"></A> \n\nand <I><A HREF=\"../Convex_hull_2_ref/Function_upper_hull_points_2.html#Cross_link_anchor_628\">upper_hull_points_2</A></I>\n<A NAME=\"Index_anchor_442\"></A> \n\nprovide the computation of the counterclockwise \nsequence of extreme points on the lower hull and upper hull,\nrespectively.  The algorithm used in these functions is\nAndrew's variant of Graham's scan algorithm [<A HREF=\"../biblio.html#Biblio_a-aeach-79\">And79</A>, <A HREF=\"../biblio.html#Biblio_m-mdscg-84\">Meh84</A>],\nwhich has worst-case running time of <MATH><I>O(n </I></MATH>log<MATH><I>n)</I></MATH>.\n<P>\n\nThere are also functions available for computing certain subsequences \nof the sequence of extreme points on the convex hull.  The function\n<I><A HREF=\"../Convex_hull_2_ref/Function_ch_jarvis_march.html#Cross_link_anchor_593\">ch_jarvis_march</A></I>\n<A NAME=\"Index_anchor_443\"></A> \n\ngenerates the counterclockwise ordered subsequence of\nextreme points between a given pair of points and\n<I><A HREF=\"../Convex_hull_2_ref/Function_ch_graham_andrew_scan.html#Cross_link_anchor_589\">ch_graham_andrew_scan</A></I>\n<A NAME=\"Index_anchor_444\"></A> \n\ncomputes the sorted sequence of extreme points that are\nnot left of the line defined by the first and last input points.\n<P>\n\nFinally, a set of functions \n(<I><A HREF=\"../Convex_hull_2_ref/Function_ch_nswe_point.html#Cross_link_anchor_597\">ch_nswe_point</A></I>, <I><A HREF=\"../Convex_hull_2_ref/Function_ch_ns_point.html#Cross_link_anchor_599\">ch_ns_point</A></I>, <I><A HREF=\"../Convex_hull_2_ref/Function_ch_we_point.html#Cross_link_anchor_605\">ch_we_point</A></I>, <I><A HREF=\"../Convex_hull_2_ref/Function_ch_n_point.html#Cross_link_anchor_601\">ch_n_point</A></I>,\n<I><A HREF=\"../Convex_hull_2_ref/Function_ch_s_point.html#Cross_link_anchor_603\">ch_s_point</A></I>, <I><A HREF=\"../Convex_hull_2_ref/Function_ch_w_point.html#Cross_link_anchor_607\">ch_w_point</A></I>, <I><A HREF=\"../Convex_hull_2_ref/Function_ch_e_point.html#Cross_link_anchor_585\">ch_e_point</A></I>)\nis provided for computing extreme points of a \n2D point set in the coordinate directions.   \n     \n     \n<A NAME=\"Index_anchor_445\"></A> \n\n   \n\n\n<a name=\"Section_5\"></a>\n        \n<h2>1.5&nbsp;&nbsp;&nbsp;Traits Classes</h2>\n<P>\n\nEach of the functions used to compute convex hulls or extreme points\nis paramterized by a traits class, which specifies the types and geometric\nprimitives to be used in the computation.  There are several implementations \nof 2D traits classes provided in the library.  The class\n<I><A HREF=\"../Convex_hull_2_ref/Class_Convex_hull_traits_2.html#Cross_link_anchor_620\">Convex_hull_traits_2</A>&lt;R&gt;</I>\n<A NAME=\"Index_anchor_446\"></A> \n\ncorresponds to the default traits class that provides the types and \npredicates presented in the 2-dimensional C<SMALL>GAL</SMALL> kernel in which the input \npoints lie.  The class \n<I>Convex_hull_constructive_traits&lt;R&gt;</I>\n<A NAME=\"Index_anchor_447\"></A> \n\nis a second traits class based on C<SMALL>GAL</SMALL> primitives but differs from\n<I><A HREF=\"../Convex_hull_2_ref/Class_Convex_hull_traits_2.html#Cross_link_anchor_620\">Convex_hull_traits_2</A></I> in that some of its primitives reuse\nintermediate results to speed up computation.\nIn addition, there are three projective traits classes \n(<I><A HREF=\"../Convex_hull_2_ref/Class_Convex_hull_projective_xy_traits_2.html#Cross_link_anchor_614\">Convex_hull_projective_xy_traits_2</A></I>, \n<I><A HREF=\"../Convex_hull_2_ref/Class_Convex_hull_projective_xz_traits_2.html#Cross_link_anchor_616\">Convex_hull_projective_xz_traits_2</A></I>, and \n<I><A HREF=\"../Convex_hull_2_ref/Class_Convex_hull_projective_yz_traits_2.html#Cross_link_anchor_618\">Convex_hull_projective_yz_traits_2</A></I>), \n<A NAME=\"Index_anchor_448\"></A> \n\n<A NAME=\"Index_anchor_449\"></A> \n\n<A NAME=\"Index_anchor_450\"></A> \nwhich may be used to compute the convex hull of a set of three-dimensional\npoints projected into each of the three coordinate planes.\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>1.6&nbsp;&nbsp;&nbsp;Convexity Checking</h2>\n<P>\n\nThe functions <I><A HREF=\"../Convex_hull_2_ref/Function_is_ccw_strongly_convex_2.html#Cross_link_anchor_622\">is_ccw_strongly_convex_2</A></I> and <I><A HREF=\"../Convex_hull_2_ref/Function_is_cw_strongly_convex_2.html#Cross_link_anchor_624\">is_cw_strongly_convex_2</A></I>\ncheck whether a given sequence of 2D points forms a (counter)clockwise strongly\nconvex polygon. \n     \n<A NAME=\"Index_anchor_451\"></A> \n \n   \n   \n     \n     \n<A NAME=\"Index_anchor_452\"></A> \n\n   \n.  These are used in postcondition\ntesting of the two-dimensional convex hull functions   \n     \n     \n<A NAME=\"Index_anchor_453\"></A> \n\n   \n.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Convex_hull_2_ref/Chapter_intro.html\">2D Convex Hulls and Extreme Points</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_1!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38010.0}