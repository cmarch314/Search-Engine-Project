{"text": "Project 2 Dijkstra s algorithm using STL data structures Due Sep 8 at 11 5 pm Overview and goals In this project you will be implementing Dijkstra s algorithm for finding the shortest path tree in a weighted undirected graph The goals of this project are to become better acquainted with implementing graph based algorithms using hashmaps and priorities queues in algorithms working with and around the data structures provided by the STL Your implementation of Dijkstra s algorithm must be based on the data structures provided by the STL and must run in O n m log n time when run on a graph with n vertices and m edges Data structures Hashmaps This project will be making heavy use of hashmaps In the STL hashmaps have the type std unordered map K V where K is the key type and V is the value type If you wish to use a std unordered map with types you have created you may need to overload the appropriate operators and functions Priority queues The priority queue data structure is central to Dijkstra s algorithm In the STL the type of a priority queue is std priority queue T Container Compare where T is the type of items stored in the priority queue Container is the type of the underlying container for items normally std vector T and Compare specifies how items are compared Template parameter T The type T must implement the following operators see operator overloading for tips This will be a class or struct that you define to hold both a priority and a vertex The comparison operators should be based on the just the priority Template parameter Container In this project we will just use std vector for this parameter Template parameter Compare The STL priority queue is a max priority queue by default i e it returns items of higher priority before items with lower priorities For Dijkstra s algorithm we need a min priority queue We could work around this problem by simply negating all of the priorities but the more appropriate way of handling this situation is to use std greater void for the Compare template parameter Graphs You may use any graph implementation that meets the required performance but I would suggest you use std unordered map V std unordered map V W where V is the type of a vertex and W is the type of an edge weight In this project V is std string and W is double This style of resenting graphs is popular in python an essay on the topic and has similar syntactic benefits in C You may want to create some helper functions for working with the graph but this is not necessary Dijkstra s algorithm The pseudocode for Dijkstra s algorithm is given below This version of the algorithm does not use the decrease key operation as the STL priority queue does not implement such a method Instead we simply re add the vertices to the priority queue when the priority is decreased def dijkstra graph source Setup data structures distance empty hashmap taking vertices to distances parent empty hasmap taking vertices to vertices pqueue empty priority queue Initialize data structures for each vertex v in G distance v infinity distance source pqueue add source first arg is vertex second arg is priority Main algorithm loop while pqueue is not empty v pqueue pop min for each neighbor u of v new distance distance v length of the edge from v to u if new distance distance u distance u new distance parentpu u v pqueue add u new distance Return hashmaps return distance parent File formats The input and output format for this project are strict You may assume that the input files are exactly as described and we will assume the same about your output files Input format Vertex IDs will consist of a single string with no spaces and edge weights will consist of a single double The input format is Vertex ID Vertex ID Vertex ID edge weight Vertex ID Vertex ID edge weight Vertex ID Vertex ID edge weight Vertex ID Vertex ID edge weight The first line is the starting vertex Following the first line are one or more lines each representing an edge in the input graph with a given weight Output format The output format consists of m lines one for each vertex in the graph of the form Vertex ID double Vertex ID Vertex ID Vertex ID where the first field is a vertex in the graph the second field is its distance from the source and the last the shortest path from the source represented as a space separate list of vertices The lines should be sorted by the first field Sample files The data directory of the starter code contains some example of input and output Your task Your task for this project is to write a program that will 1 read a graph in the given input format 2 use Dijkstra s algorithm to find the shortest path tree of the input graph and 3 print the results in the given output format You will be reading the input file from std cin and writting the output file to std cout Recall that the command make run input dat output dat causes std cin to read from input dat and std cout to write to output dat Rules For this project you may use any part of the STL that you like Starter code Project 4 starter code project4 tar gz You can download this code at a terminal with the command wget http www ics uci edu mbannist teaching ics46 project4 tar gz ", "_id": "http://www.ics.uci.edu/~mbannist/teaching/ics46/project4/", "title": "{ics,cse} 46: project 2", "html": "<!DOCTYPE html>\n<html>\n\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n\n  \n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/~mbannist/css/default.css\"/>\n  \n\n  <title>{ICS,CSE} 46: Project 2</title>\n\n  \n</head>\n\n<body>\n  <h1 id=\"project-2-dijkstras-algorithm-using-stl-data-structures-due-sep-8-at-1150pm\">Project 2: Dijkstra\u2019s algorithm using STL data structures (Due Sep 8 at 11:50pm)</h1>\n  <hr />\n  \n  <h2 id=\"overview-and-goals\">Overview and goals</h2>\n  <p>In this project you will be implementing <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra\u2019s algorithm</a> for finding the <a href=\"https://en.wikipedia.org/wiki/Shortest-path_tree\">shortest path tree</a> in a weighted undirected graph. The goals of this project are to become better acquainted with:</p>\n  \n  <ul>\n    <li>implementing graph based algorithms;</li>\n    <li>using hashmaps and priorities queues in algorithms;</li>\n    <li>working with and around the data structures provided by the STL.</li>\n  </ul>\n  \n  <p>Your implementation of Dijkstra\u2019s algorithm must be based on the data structures provided by the STL, and must run in <strong>O((n+m)log n)</strong> time when run on a graph with <strong>n</strong> vertices and <strong>m</strong> edges.</p>\n  \n  <hr />\n  \n  <h2 id=\"data-structures\">Data structures</h2>\n  \n  <h3 id=\"hashmaps\">Hashmaps</h3>\n  <p>This project will be making heavy use of hashmaps. In the STL hashmaps have the type <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map\"><strong>std::unordered_map&lt;K, V&gt;,</strong></a> where <strong>K</strong> is the key type and <strong>V</strong> is the value type. If you wish to use a <strong>std::unordered_map</strong> with types you have created, you may need to overload the appropriate operators and functions.</p>\n  \n  <h3 id=\"priority-queues\">Priority queues</h3>\n  <p>The priority queue data structure is central to Dijkstra\u2019s algorithm. In the STL the type of a priority queue is <a href=\"http://en.cppreference.com/w/cpp/container/priority_queue\"><strong>std::priority_queue&lt;T, Container, Compare&gt;</strong></a>, where <strong>T</strong> is the type of items stored in the priority queue, <strong>Container</strong> is the type of the underlying container for items (normally <strong>std::vector&lt;T&gt;</strong>), and <strong>Compare</strong> specifies how items are compared.</p>\n  \n  <h4 id=\"template-parameter-t\">Template parameter: <strong>T</strong></h4>\n  <p>The type <strong>T</strong> must implement the following operators: &lt;, &gt;, &lt;=, &gt;=, ==, !=, see <a href=\"http://en.cppreference.com/w/cpp/language/operators#Relational_operators\">operator overloading</a> for tips. This will be a class or struct that you define to hold both a priority and a vertex. The comparison operators should be based on the just the priority.</p>\n  \n  <h4 id=\"template-parameter-container\">Template parameter: <strong>Container</strong></h4>\n  <p>In this project we will just use <strong>std::vector</strong> for this parameter.</p>\n  \n  <h4 id=\"template-parameter-compare\">Template parameter: <strong>Compare</strong></h4>\n  <p>The STL priority queue is a max priority queue by default, i.e., it returns items of higher priority before items with lower priorities. For Dijkstra\u2019s algorithm we need a min priority queue. We could work around this problem by simply negating all of the priorities, but the more appropriate way of handling this situation is to use <strong>std::greater&lt;void&gt;</strong> for the <strong>Compare</strong> template parameter.</p>\n  \n  <h3 id=\"graphs\">Graphs</h3>\n  <p>You may use any graph implementation that meets the required performance, but I would suggest you use <strong>std::unordered_map&lt;V,std::unordered_map&lt;V,W&gt;&gt;</strong> where <strong>V</strong> is the type of a vertex and <strong>W</strong> is the type of an edge weight. In this project <strong>V</strong> is <strong>std::string</strong> and <strong>W</strong> is <strong>double</strong>. This style of resenting graphs is popular in python (<a href=\"https://www.python.org/doc/essays/graphs/\">an essay on the topic</a>), and has similar syntactic benefits in C++.  You may want to create some helper functions for working with the graph, but this is not necessary.</p>\n  \n  <hr />\n  \n  <h2 id=\"dijkstras-algorithm\">Dijkstra\u2019s algorithm</h2>\n  <p>The pseudocode for Dijkstra\u2019s algorithm is given below. This version of the algorithm does not use the decrease key operation, as the STL priority queue does not implement such a method. Instead we simply re-add the vertices to the priority queue when the priority is decreased.</p>\n  \n  <pre><code>def dijkstra(graph, source):\n      // Setup data structures\n      distance = empty hashmap taking vertices to distances\n      parent = empty hasmap taking vertices to vertices\n      pqueue = empty priority queue\n  \n      // Initialize data structures\n      for each vertex v in G:\n          distance[v] = infinity\n      distance[source] = 0\n      pqueue.add(source, 0) // first arg is vertex, second arg is priority\n  \n      // Main algorithm loop\n      while pqueue is not empty:\n          v = pqueue.pop_min()\n          for each neighbor u of v:\n              new_distance = distance[v] + length of the edge from v to u\n              if new_distance &lt; distance[u]:\n                  distance[u] = new_distance\n                  parentpu[u] = v\n                  pqueue.add(u, new_distance)\n  \n      // Return hashmaps\n      return distance, parent\n  </code></pre>\n  \n  <hr />\n  \n  <h2 id=\"file-formats\">File formats</h2>\n  <p>The input and output format for this project are strict. You may assume that the input files are exactly as described and we will assume the same about your output files.</p>\n  \n  <h3 id=\"input-format\">Input format</h3>\n  <p>Vertex IDs will consist of a single string with no spaces, and edge weights will consist of a single double. The input format is:</p>\n  \n  <pre><code>&lt;Vertex ID&gt;\n  &lt;Vertex ID&gt; &lt;Vertex ID&gt; &lt;edge weight&gt;\n  &lt;Vertex ID&gt; &lt;Vertex ID&gt; &lt;edge weight&gt;\n  &lt;Vertex ID&gt; &lt;Vertex ID&gt; &lt;edge weight&gt;\n  .           .           .\n  .           .           .\n  .           .           .\n  &lt;Vertex ID&gt; &lt;Vertex ID&gt; &lt;edge weight&gt;\n  </code></pre>\n  \n  <p>The first line is the starting vertex. Following the first line are one or more lines each representing an edge in the input graph with a given weight.</p>\n  \n  <h3 id=\"output-format\">Output format</h3>\n  \n  <p>The output format consists of <strong>m</strong> lines (one for each vertex in the graph) of the form</p>\n  \n  <pre><code>&lt;Vertex ID&gt;; &lt;double&gt;; &lt;Vertex ID&gt; &lt;Vertex ID&gt; ... &lt;Vertex ID&gt; \n  </code></pre>\n  \n  <p>where the first field is a vertex in the graph, the second field is its distance from the source, and the last the shortest path from the source represented as a space separate list of vertices. The lines should be sorted by the first field.</p>\n  \n  <h3 id=\"sample-files\">Sample files</h3>\n  <p>The data directory of the starter code contains some example of input and output.</p>\n  \n  <hr />\n  \n  <h2 id=\"your-task\">Your task</h2>\n  <p>Your task for this project is to write a program that will (1) read a graph in the given input format, (2) use Dijkstra\u2019s algorithm to find the shortest path tree of the input graph, and (3) print the results in the given output format. You will be reading the input file from <strong>std::cin</strong> and writting the output file to <strong>std::cout</strong>.</p>\n  \n  <p>Recall that the command</p>\n  \n  <pre><code>make run &lt; input.dat &gt; output.dat\n  </code></pre>\n  \n  <p>causes <strong>std::cin</strong> to read from <strong>input.dat</strong> and <strong>std::cout</strong> to write to <strong>output.dat</strong>.</p>\n  \n  <h3 id=\"rules\">Rules</h3>\n  <p>For this project you may use any part of the STL that you like.</p>\n  \n  <h3 id=\"starter-code\">Starter code</h3>\n  <p>Project 4 starter code: <a href=\"project4.tar.gz\">project4.tar.gz</a>  </p>\n  \n  <p>You can download this code at a terminal with the command:<br />\n  <strong>wget \u201chttp://www.ics.uci.edu/~mbannist/teaching/ics46/project4.tar.gz\u201d</strong></p>\n \n</body>\n\n</html>\n", "id": 764.0}