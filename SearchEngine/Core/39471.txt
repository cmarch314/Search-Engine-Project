{"text": "Navigation Up Table of Contents Bibliography Index Title Page TriangulationDataStructure 2 Definition The concept TriangulationDataStructure 2 describes the requirements for the second template parameter of the basic triangulation class Triangulation 2 Traits Tds and of all other 2D triangulation classes The concept can be seen as a container for the faces and vertices of the triangulation The concept TriangulationDataStructure 2 includes two subconcepts TriangulationDataStructure 2 Vertex and TriangulationDataStructure 2 Face The TriangulationDataStructure 2 maintains incidence and adjacency relations among vertices and faces Each triangular face gives access to its three incident vertices and to its three adjacent faces Each vertex gives access to one of its incident faces and through that face to the circular list of its incident faces The three vertices of a face are indexed with 1 and 2 The neighbors of a face are also indexed with 1 2 in such a way that the neighbor indexed by i is opposite to the vertex with the same index Each edge has two implicit representations the edge of a face f which is opposed to the vertex indexed i can be represented as well as an edge of the neighbor i of f See Figure The triangulation data structure is responsible for the combinatorial integrity of the triangulation This means that the triangulation data structure allows to perform some combinatorial operations on the triangulation and guarantees the maintainance on proper incidence and adjacency relations among the vertices and faces The term combinatorial operations means that those operations are purely topological and do not depend on the geometric embedding Insertion of a new vertex in a given face or in a given edge suppression of a vertex of degree three flip of two edges are examples of combinatorial operations Types TriangulationDataStructure 2 size type Size type unsigned integral type TriangulationDataStructure 2 difference type Difference type signed integral type TriangulationDataStructure 2 Vertex The vertex type Requirements for this type are decribed in concept TriangulationDataStructure 2 Vertex TriangulationDataStructure 2 Face The face type Requirements for this type are decribed in concept TriangulationDataStructure 2 Face Vertices and facess are accessed via Vertex handle and Face handle These types are models of the concept Handles which basically supports the two dereference operators and TriangulationDataStructure 2 Vertex handle Handle to a vertex TriangulationDataStructure 2 Face handle Handle to a face typedef std pair Face handle int Edge The edge type The Edge f i is edge common to faces f and f neighbor i It is also the edge joining the vertices vertex cw i and vertex ccw i of f The following iterators allow one to visit all the vertices edges and faces of a triangulation data structure They are all bidirectional non mutable iterators TriangulationDataStructure 2 Face iterator TriangulationDataStructure 2 Edge iterator TriangulationDataStructure 2 Vertex iterator The following circulators allow to visit all the edges or faces incident to a given vertex and all the vertices adjacent to a given vertex They are all bidirectional and non mutable TriangulationDataStructure 2 Face circulator TriangulationDataStructure 2 Edge circulator TriangulationDataStructure 2 Vertex circulator Iterators and circulators are convertible to the corresponding handles thus they can be passed directly as argument to the functions expecting a handle Creation TriangulationDataStructure 2 tds default constructor TriangulationDataStructure 2 tds tds1 Copy constructor All the vertices and faces are duplicated TriangulationDataStructure 2 tds tds1 Assignation All the vertices and faces of tds1 are duplicated in tds Former faces and vertices of tds if any are deleted Vertex handle tds copy tds TriangulationDataStructure 3 tds1 Vertex handle v Vertex handle tds1 is copied into tds If v NULL the vertex of tds corresponding to v is returned otherwise Vertex handle is returned Precondition The optional argument v is a vertex of tds1 void tds swap tds1 Swaps tds and tds1 Should be preferred to tds tds1 or tds tds1 when tds1 is deleted after that void tds clear Deletes all faces and all finite vertices void TriangulationDataStructure 2 Destructor All vertices and faces are deleted Access Functions int tds dimension returns the dimension of the triangulation size type tds number of vertices returns the number of vertices in the data structure size type tds number of faces returns the number of two dimensional faces in the data structure size type tds number of edges returns the number of edges in the triangulation data structure size type tds number of full dim faces returns the number of full dimensional faces i e faces of dimension equal to the dimension of the triangulation This is the actual number of faces stored in the triangulation data structure advanced Setting void tds set dimension int n sets the dimension advanced Queries bool tds is vertex Vertex handle v returns true if v is a vertex of tds bool tds is edge Face handle fh int i tests whether fh i is an edge of tds Answers false when dimension 1 bool tds is edge Vertex handle va Vertex handle vb returns true if va vb is an edge of tds bool tds is edge Vertex handle va Vertex handle vb Face handle fr int i as previous In addition if true is returned fr and i are set such that the pair fr i is the descrition of the ordered edge va vb bool tds is face Face handle fh tests whether fh is a face of tds Answers false when dimension 2 bool tds is face Vertex handle v1 Vertex handle v2 Vertex handle v3 true if there is a face having v1 v2 andv3 as vertices bool tds is face Vertex handle v1 Vertex handle v2 Vertex handle v3 Face handle fr as above In addition if true is returned fr is a pointer to the face with v1 v2 and v3 as vertices Traversing the triangulation Face iterator tds faces begin visits all faces Face iterator tds faces end Vertex iterator tds vertices begin visits all vertices Vertex iterator tds vertices end Edge iterator tds edges begin visits all edges Edge iterator tds edges end Three circulator classes allow to traverse the edges or faces incident to a vertex or the vertices adjacent to this vertex A face circulator is invalidated by any modification of the face it points to An edge circulator is invalidated by any modification of anyone of the two faces incident to the edge pointed to A vertex circulator that turns around vertex v and that has as value a pointer to vertex w is invalidated by any modification of anyone of the two faces incident to v and w Vertex circulator tds incident vertices Vertex handle v Face handle f NULL Precondition If the face f is given it has to be incident to be a face of tds incident to v and the circulator begins with the vertex f vertex ccw i if i is the index of v in f Edge circulator tds incident edges Vertex handle v Face handle f NULL Precondition If the face f is given it has to be a face of tds incident to v and the circulator begins with the edge f cw i of f if i is the index of v in f Face circulator tds incident faces Vertex handle v Face handle f NULL Precondition If the face f is given it has to be a face of tds incident to v and the circulator begins with the face f Modifiers The following modifier member functions guarantee the combinatorial validity of the resulting triangulation void tds flip Face handle f int i exchanges the edge incident to f and f neighbor i with the other diagonal of the quadrilateral formed by f and f neighbor i Figure Flip Vertex handle tds insert first creates the first vertex and returns a pointer to it Vertex handle tds insert second creates the second vertex and returns a pointer to it Vertex handle tds insert in edge Face handle f int i adds a vertex v splitting edge i of face f Return a pointer to v Vertex handle tds insert in face Face handle f adds a vertex v splitting face f in three Face f is modified two new faces are created Return a pointer to v Vertex handle tds insert dim up Vertex handle w bool orient true adds a vertex v increasing by one the dimension of the triangulation Vertex v and the existing vertex w are linked to all the vertices of the triangulation The boolean orient decides the final orientation of all faces A pointer to vertex v is returned void tds remove degree 3 Vertex handle v Face f NULL removes a vertex of degree 3 Two of the incident faces are destroyed the third one is modified If parameter f is specified it has to be a face incident to v and will be the modified face Precondition Vertex v is a finite vertex with degree 3 and if specified face f is incident to v void tds remove second Vertex handle v removes the before last vertex void tds remove first Vertex handle v removes the last vertex void tds remove dim down Vertex handle v removes vertex v incident to all other vertices and decreases by one the dimension of the triangulation Precondition if the dimension is 2 the number of vertices is more than 3 if the dimension is 1 the number of vertices is 2 advanced The following modifiers are required for convenience of the advanced user They do not guarantee the combinatorial validity of the resulting triangulation template class EdgeIt Vertex handle tds star hole EdgeIt edge begin EdgeIt edge end creates a new vertex v and use it to star the hole whose boundary is described by the sequence of edges edge begin edge end Returns a pointer to the vertex template class EdgeIt class FaceIt Vertex handle tds star hole EdgeIt edge begin EdgeIt edge end FaceIt face begin FaceIt face end same as above except that to build the new faces the algorithm first recycles faces in the sequence face begin face end and create new ones when the sequence is exhausted template class EdgeIt void tds star hole Vertex handle v EdgeIt edge begin EdgeIt edge end uses vertex v to star the hole whose boundary is described by the sequence of edges edge begin edge end template class EdgeIt class FaceIt void tds star hole Vertex handle v EdgeIt edge begin EdgeIt edge end FaceIt face begin FaceIt face end same as above recycling faces in the sequence face begin face end void tds make hole Vertex handle v List edges hole removes the vertex v and store in hole the list of edges on the boundary of the hole Vertex handle tds create vertex adds a new vertex Face handle tds create face Face handle f1 int i1 Face handle f2 int i2 Face handle f3 int i3 adds a face which is the neighbor i1 of f1 i2 of f2 and i3 of f3 Face handle tds create face Face handle f1 int i1 Face handle f2 int i2 adds a face which is the neighbor i1 of f1 and the neighbor i2 of f2 Face handle tds create face Face handle f1 int i1 Vertex handle v adds a face which is the neighbor i1 of f1 and has v as vertex Face handle tds create face Vertex handle v1 Vertex handle v2 Vertex handle v3 adds a face with vertices v1 v2 and v3 Face handle tds create face Vertex handle v1 Vertex handle v2 Vertex handle v3 Face handle f1 Face handle f2 Face handle f3 adds a face with vertices v1 v2 and v3 and neighbors f1 f2 f3 Face handle tds create face adds a face whose vertices and neighbors are set to NULL void tds delete face Face handle deletes a face void tds delete vertex Vertex handle deletes a vertex advanced Miscelleanous int tds ccw int i returns i 1 modulo 3 Precondition i 2 int tds cw int i returns i 2 modulo 3 Precondition i 2 bool tds is valid checks the combinatorial validity of the triangulation call the is valid member function for each vertex and each face checks the number of vertices and the Euler relation between numbers of vertices faces and edges I O The information ouput in the iostream is the dimension the number of finite vertices the number of finite faces Then comes for each vertex the non combinatorial information stored in that vertex if any Then comes for each faces the indices of its vertices and the non combinatorial information if any stored in this face Then comes for each face again the indices of the neighboring faces The index of an item vertex of face the rank of this item in the ouput order When dimension 2 the same information is ouput for faces of maximal dimension instead of faces void tds file output ostream os Vertex handle v Vertex handle bool skip first false writes tds into the stream os If v is not a null handle vertex v is output first or skipped if skip first is true Vertex handle tds file input istream is bool skip first false inputs tds from file and returns a pointer to the first input vertex If skip first is true it is assumed that the first vertex has been omitted when output istream istream is TriangulationDataStructure 3 tds reads a combinatorial triangulation from is and assigns it to tds ostream ostream os TriangulationDataStructure 3 tds writes tds into the stream os Has ModelsCGAL Triangulation data structure 2 Vb Fb See AlsoTriangulationDataStructure 2 Face TriangulationDataStructure 2 Vertex CGAL Triangulation 2 Traits Tds Next TriangulationDSFaceBase 2 Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/TDS_2_ref/Concept_TriangulationDataStructure_2.html", "title": "triangulationdatastructure_2", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './TDS_2_ref/TriangulationDataStructure_2.tex' -->\n<html> <head>  \n<title>TriangulationDataStructure_2</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_intro.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n\n<A NAME=\"Cross_link_anchor_960\"></A>\n\n      \n     \n     \n     \n<A NAME=\"Index_anchor_907\"></A> \n\n   \n<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC=\"cc_Concept.gif\"></TD></TR></TABLE>\n\n\n    <A NAME=\"ccRef_TriangulationDataStructure_2\"></A>\n<h2><I>TriangulationDataStructure_2</I></h2>\n<P>\n\n<H3>Definition</H3>\n<P>\n\nThe concept <I><A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I> describes the requirements  for\nthe second template parameter of the basic triangulation class\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_939\">Triangulation_2</A>&lt;Traits,Tds&gt;</I> and of all other 2D triangulation classes.\n<P>\n\nThe concept can be seen as a container for the \nfaces and vertices of the triangulation.\nThe concept <I><A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I>  includes two subconcepts\n<I><A HREF=\"Concept_TriangulationDataStructure_2--Vertex.html#Cross_link_anchor_964\">TriangulationDataStructure_2::Vertex</A></I> and\n<I><A HREF=\"Concept_TriangulationDataStructure_2--Face.html#Cross_link_anchor_962\">TriangulationDataStructure_2::Face</A></I>.\n<P>\n\nThe <I><A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A></I> \nmaintains incidence and adjacency relations\namong vertices and faces.\n<P>\n\nEach triangular face gives access to its three incident vertices \nand to its three adjacent faces. \nEach vertex gives access to one of its incident faces\nand through that face to the circular list of its incident faces.\n<P>\n\nThe three vertices of a face are indexed with 0, 1 and 2.\nThe neighbors of a face are also \nindexed with 0,1,2 in such a way that the neighbor indexed by <I>i</I>\nis <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> to the vertex with the same index.\n<P>\n\nEach edge has two implicit representations : the edge\nof a face <I>f</I>  which is opposed to the vertex indexed <I>i</I>,\ncan be represented as well as an edge of the <I>neighbor(i)</I> of \n<I>f</I>. See Figure&nbsp;<A HREF=\"../Triangulation_2/Chapter_main.html#2D_Triangulation_Fig_neighbors1\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\n<P>\n\nThe triangulation data structure\n is responsible for  the combinatorial integrity of the triangulation.\nThis means that the triangulation data structure\nallows to perform some combinatorial operations\non the triangulation and guarantees the maintainance on \nproper incidence and adjacency relations among the vertices\nand faces. The term combinatorial operations\n means that those operations are purely topological\nand do not depend on the geometric embedding.\nInsertion of a new vertex in a given face, or in a given edge,\nsuppression of a vertex of degree three,  flip of two edges\nare examples of combinatorial operations.\n<P>\n\n<H3>Types</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::size_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Size type (unsigned integral type)\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::difference_type\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Difference type (signed integral type)\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2--Vertex.html#Cross_link_anchor_964\">TriangulationDataStructure_2::Vertex</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    The vertex type. Requirements for this type\nare decribed in concept <I><A HREF=\"Concept_TriangulationDataStructure_2--Vertex.html#Cross_link_anchor_964\">TriangulationDataStructure_2::Vertex</A></I>\n.\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2--Face.html#Cross_link_anchor_962\">TriangulationDataStructure_2::Face</A>\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    The face type. Requirements for this type\nare decribed in concept <I><A HREF=\"Concept_TriangulationDataStructure_2--Face.html#Cross_link_anchor_962\">TriangulationDataStructure_2::Face</A></I>\n.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\nVertices and facess are accessed  via <I>Vertex_handle</I> and\n<I>Face_handle</I>. These types \nare models of the concept <I>Handles</I> which basically\nsupports the two dereference operators <I>*</I> and <I>-&gt;</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Vertex_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A> to a vertex\n<P>\n\n</TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Face_handle\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    <A HREF=\"../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663\">Handle</A> to a face.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A NAME=\"Function_Edge\"></A>\n<A NAME=\"Typedef_Edge\"></A>\ntypedef std::pair&lt;Face_handle,int&gt;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Edge;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    The edge type.\nThe <I>Edge(f,i)</I> is edge common to faces <I>f</I> and \n<I>f.neighbor(i)</I>. It is also the edge joining the vertices\n<I>vertex(cw(i))</I> and <I>vertex(ccw(i))</I> of <I>f</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\nThe following iterators allow one to visit all the vertices, edges\nand  faces\nof a triangulation data structure. They are all\nbidirectional, non-mutable iterators.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Face_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Edge_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Vertex_iterator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nThe following circulators allow to visit all the edges or faces\nincident to a given vertex and all the vertices\nadjacent to a given vertex.  They are all bidirectional and non\nmutable.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Face_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Edge_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>::Vertex_circulator\n        </I></NOBR>\n        </TD></TR>\n<P>\n\n</TABLE>\n<P>\n\nIterators and circulators are convertible to the corresponding handles, thus\nthey can be passed directly as argument\nto the functions expecting a handle.\n<P>\n\n<H3>Creation</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A> tds;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    default constructor.\n<P>\n\n</TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A> tds (  tds1);\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>\n    Copy constructor. All the vertices and faces are duplicated.\n<P>\n\n</TD></TR>\n        </TABLE>\n<P>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A>&amp;\n        </I></NOBR>\n        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n     tds =  tds1<A NAME=\"Function_TriangulationDataStructure_2__operator=6_const_TriangulationDataStructure_2__tds19;\"></A>\n\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Assignation. All the vertices and faces of <I>tds1</I> are duplicated\nin <I>tds</I> . Former faces and vertices of <I>tds</I> , if any, are\ndeleted\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_copy_tds6const_TriangulationDataStructure_3___tds1+_Vertex_handle_v_=_Vertex_handle699;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.copy_tds ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n     <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> tds1,<BR>\n\nVertex_handle v = Vertex_handle())</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>tds1</I> is copied into <I>tds</I>. If <MATH><I>v != NULL</I></MATH>, the vertex of <I>tds</I> \ncorresponding to <I>v</I> is returned, otherwise <I>Vertex_handle()</I> \nis returned.<BR>\n\n<EM>Precondition: </EM>The optional argument <I>v</I> is a vertex of <I>tds1</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_swap6_TriangulationDataStructure_2___tds19;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.swap (  &amp; tds1)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Swaps <I>tds</I> and <I>tds1</I>. Should be preferred to <I>tds</I>=<I>tds1</I> or <I>tds</I>(<I>tds1</I>)\nwhen tds1 is deleted after that.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_clear69;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.clear ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Deletes all faces and all finite vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_~TriangulationDataStructure_269;\"></A>\nvoid ~\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <A HREF=\"Concept_TriangulationDataStructure_2.html#Cross_link_anchor_960\">TriangulationDataStructure_2</A> ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    Destructor. All vertices and faces are deleted.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Access Functions</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_dimension69_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.dimension ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the dimension of the triangulation.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_vertices69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_vertices ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of vertices in the data structure.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_faces69_const_;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_faces ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of two dimensional faces in the data structure.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_edges69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_edges ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the number of edges  in the triangulation data structure.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_size_type_number_of_full_dim_faces69_const;\"></A>\nsize_type\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.number_of_full_dim_faces ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns the  number of full dimensional faces, \ni.e. faces of dimension equal to the dimension\nof the triangulation. This is the actual\nnumber of faces stored in the triangulation data structure.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\n<H3>Setting</H3>\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_set_dimension_6int_n9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.set_dimension ( int n)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    sets the dimension.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Queries</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_vertex6Vertex_handle_v9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_vertex ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns true if\n<I>v</I> is a vertex of <I>tds</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Face_handle_fh+_int_i9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_edge ( Face_handle fh,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    tests whether <I>(fh,i)</I> is an edge of <I>tds</I>. Answers <I>false</I> when\n<I>dimension()</I> <MATH><I>&lt;1</I></MATH> .\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_va+_Vertex_handle_vb9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_edge ( Vertex_handle va,  Vertex_handle vb)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns true if\n<I>va vb</I> is an edge of <I>tds</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_edge6Vertex_handle_va+_Vertex_handle_vb+_Face_handle__fr+_int__i9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.is_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle va,<BR>\n\nVertex_handle vb,<BR>\n\nFace_handle &amp;fr,<BR>\n\nint &amp;i)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    as previous. In addition, if true is returned\n<I>fr</I> and <I>i</I> are set such that the pair <I>(fr,i)</I>\nis the descrition \nof  the ordered edge <I>va vb</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_face6Face_handle_fh9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.is_face ( Face_handle fh)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    tests whether <I>fh</I> is a face of <I>tds</I>. Answers <I>false</I> when\n<I>dimension()</I> <MATH><I>&lt;2</I></MATH> .\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_face6Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v39_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.is_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    <I>true</I> if there is a face having <I>v1</I>, <I>v2</I> and<I>v3</I> \nas vertices.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_face6Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v3+_Face_handle__fr9_const;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.is_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3,<BR>\n\nFace_handle &amp;fr)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    as above. In addition, if <I>true</I> is returned, fr is a pointer\nto the face with  <I>v1</I>, <I>v2</I> and <I>v3</I> \nas vertices.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Traversing the triangulation</H3>\n\n\n        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_iterator_faces_begin69_const;\"></A>\nFace_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.faces_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    visits all faces\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_iterator_faces_end69_const;\"></A>\nFace_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.faces_end ()\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_begin69_const;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.vertices_begin ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    visits all vertices\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_iterator_vertices_end69_const;\"></A>\nVertex_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.vertices_end ()\n        </I></NOBR>\n        \n    \n        </TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_edges_begin69_const;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.edges_begin ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    visits all edges\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_iterator_edges_end69_const;\"></A>\nEdge_iterator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.edges_end ()\n        </I></NOBR>\n        </TD>\n    \n        </TR>\n        </TABLE>\n<P>\n\nThree circulator classes allow to traverse the edges or faces\nincident to a vertex or the vertices adjacent to this vertex..\nA face circulator is invalidated by any modification of the face it\npoints to. An edge circulator is invalidated\nby any modification of anyone of the two faces incident to the edge\npointed to.  A vertex circulator that turns around vertex <I>v</I>\nand that has as value a pointer to vertex <I>w</I>, is invalidated\nby any modification of anyone of the two faces incident to <I>v</I>\nand <I>w</I>.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_circulator_incident_vertices6Vertex_handle_v+_Face_handle_f=NULL9_const;\"></A>\nVertex_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nFace_handle f=NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%><BR>\n\n<EM>Precondition: </EM>If the\nface <I>f</I> is given, it has to be incident to be a face of <I>tds</I> \nincident to <I>v</I> \nand the circulator begins with \nthe vertex <I>f-&gt;vertex(ccw(i))</I> \nif <I>i</I> is the index of <I>v</I>  in <I>f</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Edge_circulator_incident_edges6Vertex_handle_v+_Face_handle_f=NULL9_const;\"></A>\nEdge_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_edges ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nFace_handle f=NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%><BR>\n\n<EM>Precondition: </EM>If the\nface <I>f</I> is given, it has to be a face of <I>tds</I> \nincident to <I>v</I> \nand the circulator begins with \nthe edge <I>(f,cw(i))</I> of <I>f</I>\nif  <I>i</I> is the index of <I>v</I>  in <I>f</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_circulator_incident_faces6Vertex_handle_v+_Face_handle_f=NULL9_const;\"></A>\nFace_circulator\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.incident_faces ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nFace_handle f=NULL)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%><BR>\n\n<EM>Precondition: </EM>If the\nface <I>f</I> is given, it has to be a face of <I>tds</I> \nincident to <I>v</I> \nand the circulator begins with the face\n<I>f</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Modifiers</H3>\nThe following modifier member functions  guarantee\nthe combinatorial validity of the resulting triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_flip6Face_handle_f+_int_i9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.flip ( Face_handle f,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    exchanges the edge incident to\n<I>f</I> and <I>f-&gt;neighbor(i)</I> with the other\ndiagonal of the quadrilateral formed by <I>f</I> and  <I>f-&gt;neighbor(i)</I>.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<B>Figure:&nbsp;&nbsp;</B>Flip.\n<A NAME=\"I1_fig_flip\"></A>\n<P>\n\n<CENTER>\n<img border=0 src=\"Flip.gif\" align=center alt=\"Flip\">\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_first69;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_first ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    creates the first \nvertex and returns a pointer to it.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_second69;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_second ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    creates the second \nvertex and returns a pointer to it.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_edge6Face_handle_f+_int_i9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_edge ( Face_handle f,  int i)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a\nvertex <I>v</I> splitting \nedge <I>i</I> of face <I>f</I>. Return a  pointer to <I>v</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_in_face6Face_handle_f9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_in_face ( Face_handle f)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a vertex\n<I>v</I> splitting  face\n<I>f</I> in three. Face <I>f</I> is modified,\ntwo new faces are created. Return a  pointer to <I>v</I>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_insert_dim_up6Vertex_handle_w+_bool_orient=true9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.insert_dim_up ( Vertex_handle w,  bool orient=true)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds\na vertex <I>v</I>, increasing by one the dimension of the triangulation.\nVertex <I>v</I> and the existing vertex <I>w</I> are linked to all \nthe vertices of the triangulation. \nThe boolean <I>orient</I> decides the final <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> of all \nfaces. A pointer to vertex <I>v</I> is returned.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<CENTER>\n<img border=0 src=\"Three.gif\" align=center alt=\"Insertion\">\n</CENTER>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_degree_36Vertex_handle_v+_Face_*f=NULL9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.remove_degree_3 ( Vertex_handle v,  Face *f=NULL)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes a vertex of degree 3. Two of the incident faces are destroyed,\nthe third one is modified.\nIf parameter <I>f</I>  is specified, it has to be a face incident to <I>v</I>\nand will be the modified face.<BR>\n\n<EM>Precondition: </EM>Vertex\n<I>v</I> is a finite vertex with degree 3\nand, if specified, face <I>f</I> is incident to <I>v</I>.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_second6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.remove_second ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the before last\nvertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_first6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.remove_first ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the last vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_remove_dim_down6Vertex_handle_v9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.remove_dim_down ( Vertex_handle v)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes vertex <I>v</I> incident to all other vertices\nand  decreases by one the dimension of the triangulation.<BR>\n\n<EM>Precondition: </EM>if the dimension is 2, the number of vertices is more than\n3,\nif the dimension is 1, the number of vertices is 2.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\nThe following modifiers are required for convenience of the advanced\nuser.\nThey do not guarantee the combinatorial validity \nof the resulting triangulation.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class EdgeIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_star_hole6EdgeIt_edge_begin+EdgeIt_edge_end9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.star_hole ( EdgeIt edge_begin, EdgeIt edge_end)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    creates a new vertex <I>v</I> and use it to star the hole \nwhose boundary is described  by the sequence of edges <I>[edge_begin,  edge_end[</I>. Returns a pointer to the  vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class EdgeIt, class FaceIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_star_hole6EdgeIt_edge_begin+_EdgeIt_edge_end+_FaceIt_face_begin+_FaceIt_face_end9;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.star_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    EdgeIt edge_begin,<BR>\n\nEdgeIt edge_end,<BR>\n\nFaceIt face_begin,<BR>\n\nFaceIt face_end)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above, except that, to build the new faces, the  algorithm \nfirst recycles faces in the sequence <I>[face_begin,  face_end[</I> and create new ones when the sequence is exhausted.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class EdgeIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_star_hole6Vertex_handle_v+_EdgeIt_edge_begin+_EdgeIt_edge_end9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.star_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nEdgeIt edge_begin,<BR>\n\nEdgeIt edge_end)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    uses vertex v to  star the hole \nwhose boundary is described  by the sequence of edges<I>[edge_begin,  edge_end[</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template&lt; class EdgeIt, class FaceIt&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_star_hole6Vertex_handle_v+_EdgeIt_edge_begin+_EdgeIt_edge_end+_FaceIt_face_begin+_FaceIt_face_end9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.star_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v,<BR>\n\nEdgeIt edge_begin,<BR>\n\nEdgeIt edge_end,<BR>\n\nFaceIt face_begin,<BR>\n\nFaceIt face_end)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    same as above, recycling faces in the sequence  <I>[face_begin,  face_end[ . </I>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_make_hole6Vertex_handle_v+_List_edges__hole9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.make_hole ( Vertex_handle v,  List_edges&amp; hole)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    removes the vertex v, and store in <I>hole</I> the list of edges\non the boundary of the hole.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_create_vertex69;\"></A>\nVertex_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.create_vertex ()\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a new vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_create_face6Face_handle_f1+_int_i1+_Face_handle_f2+_int_i2+_Face_handle_f3+_int_i39;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Face_handle f1,<BR>\n\nint i1,<BR>\n\nFace_handle f2,<BR>\n\nint i2,<BR>\n\nFace_handle f3,<BR>\n\nint i3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a face which is the neighbor <I>i1</I> of <I>f1</I>, \n<I>i2</I> of <I>f2</I> and <I>i3</I> of <I>f3</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_create_face6Face_handle_f1+_int_i1+_Face_handle_f2+_int_i29;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Face_handle f1,<BR>\n\nint i1,<BR>\n\nFace_handle f2,<BR>\n\nint i2)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a face which is the neighbor <I>i1</I> of <I>f1</I>, \nand the neighbor <I>i2</I> of <I>f2</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_create_face6Face_handle_f1+_int_i1+_Vertex_handle_v9;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Face_handle f1,<BR>\n\nint i1,<BR>\n\nVertex_handle v)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a face which is the neighbor <I>i1</I> of <I>f1</I>,\nand has <I>v</I> as vertex.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_create_face6Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v39;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a face with vertices <I>v1</I>, <I>v2</I> and <I>v3</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_create_face6Vertex_handle_v1+_Vertex_handle_v2+_Vertex_handle_v3+_Face_handle_f1+_Face_handle_f2+_Face_handle_f39;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    tds.create_face ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    Vertex_handle v1,<BR>\n\nVertex_handle v2,<BR>\n\nVertex_handle v3,<BR>\n\nFace_handle f1,<BR>\n\nFace_handle f2,<BR>\n\nFace_handle f3)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a face with vertices <I>v1</I>, <I>v2</I> and <I>v3</I>,\nand neighbors <I>f1</I>, <I>f2</I>, <I>f3</I>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Face_handle_create_face69;\"></A>\nFace_handle\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.create_face ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    adds a face whose vertices and neighbors are set to NULL.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delete_face6Face_handle_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.delete_face ( Face_handle)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    deletes a face.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_delete_vertex6Vertex_handle_9;\"></A>\nvoid\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    tds.delete_vertex ( Vertex_handle)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    deletes a vertex.\n        </TD></TR>\n        </TABLE>\n\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<H3>Miscelleanous</H3>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_ccw6int_i9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.ccw ( int i)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <MATH><I>i+1</I></MATH> modulo 3.<BR>\n\n<EM>Precondition: </EM><MATH><I>0 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_int_cw6int_i9_const;\"></A>\nint\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.cw ( int i)\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    returns <MATH><I>i+2</I></MATH> modulo 3.<BR>\n\n<EM>Precondition: </EM><MATH><I>0 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC=\"cc_leq.gif\"> 2</I></MATH>.\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_bool_is_valid69;\"></A>\nbool\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    tds.is_valid ()\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    checks the combinatorial validity of the\ntriangulation: call the <I>is_valid()</I> member function for each vertex and \neach face, checks the number of vertices and the Euler relation\nbetween numbers of vertices, faces and edges.\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>I/O</H3>\n<P>\n\nThe information ouput  in the <I>iostream</I> is: \nthe dimension, the number of (finite) vertices, \nthe number of (finite) faces.\nThen comes \nfor each vertex, the non combinatorial information stored in  that vertex\nif any.\nThen comes \nfor each faces,  the indices of its vertices and \nthe non combinatorial information (if any) stored in  this face.\nThen comes \nfor each face again \n the indices of the neighboring faces. \nThe  index of an item  (vertex of face)\nthe rank of this item in the ouput order.\nWhen dimension <MATH><I>&lt;</I></MATH> 2, the same information is ouput\nfor faces of maximal dimension instead of faces.\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_void_tds+file_output6_ostream__os+_Vertex_handle_v_=_Vertex_handle69+_bool_skip_first=false9;\"></A>\nvoid tds.\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    file_output ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>\n    ostream&amp; os,<BR>\n\nVertex_handle v = Vertex_handle(),<BR>\n\nbool skip_first=false)</I></TD></TR></TABLE>\n    \n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>tds</I> into the stream <I>os</I>. \nIf <I>v</I> is not a null handle, vertex <I>v</I>\nis output first or skipped if <I>skip_first</I> is true.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A NAME=\"Function_Vertex_handle_tds+file_input6_istream__is+_bool_skip_first=false9;\"></A>\nVertex_handle tds.\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n    file_input ( istream&amp; is,  bool skip_first=false)\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    inputs <I>tds</I> from file and returns a pointer to the first input vertex.\n  If <I>skip_first</I> is true, it is assumed that the first\n   vertex has been omitted when output.\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     istream&amp; is &gt;&gt;  <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> &amp; tds<A NAME=\"Function_istream__operator99_6istream__is+_TriangulationDataStructure_3___tds9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    reads a combinatorial triangulation from <I>is</I> and assigns it to <I>tds</I>\n        </TD></TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     ostream&amp; os &lt;&lt;  <A HREF=\"../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002\">TriangulationDataStructure_3</A> tds<A NAME=\"Function_ostream__operator66_6ostream__os+_const_TriangulationDataStructure_3___tds9;\"></A>\n\n        </I></NOBR>\n        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>\n    writes <I>tds</I> into the stream <I>os</I>\n        </TD></TR>\n        </TABLE>\n<P>\n\n<H3>Has Models</H3><I><A HREF=\"Class_Triangulation_data_structure_2.html#Cross_link_anchor_965\">CGAL::Triangulation_data_structure_2</A>&lt;Vb,Fb&gt;</I><BR>\n\n\n<P>\n\n<H3>See Also</H3><I><A HREF=\"Concept_TriangulationDataStructure_2--Face.html#Cross_link_anchor_962\">TriangulationDataStructure_2::Face</A></I><BR>\n\n<I><A HREF=\"Concept_TriangulationDataStructure_2--Vertex.html#Cross_link_anchor_964\">TriangulationDataStructure_2::Vertex</A></I><BR>\n\n<I><A HREF=\"../Triangulation_2_ref/Class_Triangulation_2.html#Cross_link_anchor_938\">CGAL::Triangulation_2</A>&lt;Traits,Tds&gt;</I>\n<P>\n\n<div class=\"NavNext\"><hr> <b>Next:</b> <a href=\"Concept_TriangulationDSFaceBase_2.html\"><I>TriangulationDSFaceBase_2</I></a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_34!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39471.0}