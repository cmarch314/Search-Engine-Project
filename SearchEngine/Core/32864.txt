{"text": "Toolkit Integration TechniqueTable of ContentsBenefits Previous Next 3 Proof of concept prototype An initial implementation of the TI technique is currently under construction The results represent a proof of concept of a majority of the ideas presented here The current prototype does not yet implement the abstract toolkit and hypermedia interfaces discussed in Section 2 3 The extended widgets are implemented directly using the interfaces of the target user interface toolkit and OHS The reason for this choice was due to externally induced time constraints As the prototype evolves into a full fledged integration the abstract interfaces will be developed and employed The target user interface toolkit for the prototype is the Abstract Windowing Toolkit AWT implemented in the Java programming language The Java AWT was chosen for three reasons First Java is an object oriented language with an emphasis on portability Since implementations of the Java virtual machine exist for a variety of platforms extending the Java AWT to be hypermedia aware would benefit a large audience of developers and users Second as discussed previously the object oriented features of Java such as inheritance and polymorphism ease the construction of the extended widgets Third Java is currently being positioned as a development language for Internet aware applets Since applets execute in Web browsers they appear in a context in which hypermedia principles are familiar to end users Applets constructed with the hypermedia aware version of the Java AWT are thus suitable to introduce users with the notion of pervasive environment wide hypermedia links The target hypermedia system for the prototype is the Chimera OHS 1 Chimera is a client server based system providing a flexible set of hypermedia concepts and operations which meet the requirements outlined in Section 2 2 The prototype currently implements several common services and has integrated one widget The prototype was constructed rapidly over a period of two weeks in three distinct stages The first stage developed a Chimera application program interface API in Java This API was developed in one week by an experienced Chimera developer and represents the interface to the hypermedia system provided by the hypermedia infrastructure The API provides access to all of Chimera s hypermedia concepts and their associated operations in addition to providing a mechanism to receive events from the Chimera server such as link traversal notifications The second stage consisted of developing a common service in the hypermedia infrastructure to initialize and monitor the connection to the Chimera server If the connection to the Chimera server is unexpectedly lost the connection service provides a dialog box to the user allowing them to reestablish a connection The third stage integrated a button widget and constructed additional common services These two developmental tasks were performed iteratively with the integrated button driving the demand for common services such as error handling and link traversal management The difference between the interfaces of the original button widget and the integrated widget occurs only in the constructors of the widgets The original constructor2 is public Button String label The constructor for the integrated widget is public HButton String label String viewerName String objectName As discussed in Section 2 2 the difference is caused by the context information required by the underlying OHS In Chimera the required information is the name of an object and the name of the viewer which displays the object The HButton3 class registers itself as a component with a single anchor using the following code in its constructor Register viewer theViewer new viewer theViewer register this viewerName Register object theObject new object theObject register this objectName Register view i e component theView new view theView register theViewer theObject Register anchor theAnchor new anchor theAnchor register theView The integrated button provides access to two hypermedia services link creation and link traversal The former allows the button s anchor to be included in links while the latter allows these links to be traversed In addition the button can receive link traversal events When a link traversal event is received the following code is executed public synchronized void handleEvent chimeraEvent theEvent switch theEvent event case chimeraEvent linkTraversal doBlink Event e new Event this Event ACTION EVENT getLabel postEvent e This code blinks the button using a simple reverse video technique not shown and invokes the button s associated action by generating an event for the button to handle The handleEvent routine is called by the hypermedia infrastructure when an event is received from the Chimera server for a particular widget The extended button makes use of a common service provided by the hypermedia infrastructure for the initiation of link traversals As a result the code for a link traversal is short and simple and can be reused in a similar fashion by all subsequent extended widgets It is shown below HConnection traverse theAnchor In other words the extended widget need only pass the source anchor for the traversal and the common service takes care of the rest The code for the traverse routine is shown below public synchronized void traverse Anchor a int number number link howManyLinks a if number 1 HTraversalDialog htd new HTraversalDialog a return else link links link getLinks a link theLink links number theLink howManyAnchors if number 2 HTraversalDialog htd new HTraversalDialog a return HConnection theAPI traverseFrom a This code executes a simple algorithm If the link traversal has a single destination the traversal is activated Otherwise a link traversal dialog is displayed see Figure 3 allowing the user to specify the desired destinations before activating the traversal Since all hypermedia enabled widgets will make use of this service link traversal behavior is consistent across widgets and across applications constructed with the integrated toolkit In addition the behavior is easily modified and maintained since it is isolated in one place in the hypermedia infrastructure layer Additional benefits of the TI technique are discussed in the next section Figure 3 The link traversal dialog provided by the hypermedia infrastructure This dialog lists the destinations for the current link traversal Destinations consist of a viewer name object name and anchor identifier The dialog allows users to select the desired destinations and traverse to them Since all link traversals use this dialog consistent behavior is achieved Toolkit Integration TechniqueTable of ContentsBenefits Previous Next ", "_id": "http://ftp.ics.uci.edu/pub/chimera/overview/papers/HICSS30/prototype.html", "title": "proof-of-concept prototype", "html": "<html><head><title>Proof-of-Concept Prototype</title>\n</head>\n<body bgcolor=\"#FFFFFF\" text=\"#000000\">\n<HR><TABLE WIDTH=100%><TR ALIGN=CENTER><TD><A HREF=\"toolkit.html\">Toolkit Integration Technique</A></TD><TD><A HREF=\"index.html#toc\">Table of Contents</A></TD><TD><A HREF=\"benefits.html\">Benefits</A></TD></TR><TR ALIGN=CENTER><TD>(Previous)</TD><TD></TD><TD>(Next)</TD></TR></TABLE><HR>\n<H2>3. Proof-of-concept prototype</H2>\n<P>\nAn initial implementation of the TI technique is currently under construction. The results represent a proof-of-concept of a majority of the ideas presented here. The current prototype does not yet implement the abstract toolkit and hypermedia interfaces discussed in <A HREF=\"toolkit.html#sec2.3\">Section&nbsp;2.3</A>. The extended widgets are implemented directly using the interfaces of the target user-interface toolkit and OHS. The reason for this choice was due to externally induced time constraints. As the prototype evolves into a full-fledged integration, the abstract interfaces will be developed and employed.\n</P>\n<P>\nThe target user-interface toolkit for the prototype is the Abstract Windowing Toolkit (AWT) implemented in the Java programming language. The Java AWT was chosen for three reasons. First, Java is an object-oriented language with an emphasis on portability. Since implementations of the Java virtual machine exist for a variety of platforms, extending the Java AWT to be hypermedia-aware would benefit a large audience of developers and users. Second, as discussed previously, the object-oriented features of Java such as inheritance and polymorphism ease the construction of the extended widgets. Third, Java is currently being positioned as a development language for Internet-aware applets. Since applets execute in Web browsers, they appear in a context in which hypermedia principles are familiar to end-users. Applets constructed with the hypermedia-aware version of the Java AWT are thus suitable to introduce users with the notion of pervasive environment-wide hypermedia links. The target hypermedia system for the prototype is the Chimera OHS [<A HREF=\"references.html#ref1\">1</A>]. Chimera is a client-server based system providing a flexible set of hypermedia concepts and operations which meet the requirements outlined in <A HREF=\"toolkit.html#sec2.2\">Section&nbsp;2.2</A>.\n</P>\n<P>\nThe prototype currently implements several common services and has integrated one widget. The prototype was constructed rapidly over a period of two weeks in three distinct stages. The first stage developed a Chimera application program interface (API) in Java. This API was developed in one week by an experienced Chimera developer and represents the interface to the hypermedia system provided by the hypermedia infrastructure. The API provides access to all of Chimera's hypermedia concepts, and their associated operations, in addition to providing a mechanism to receive events from the Chimera server such as link traversal notifications. The second stage consisted of developing a common service in the hypermedia infrastructure to initialize and monitor the connection to the Chimera server. If the connection to the Chimera server is unexpectedly lost, the connection service provides a dialog box to the user allowing them to reestablish a connection. The third stage integrated a button widget and constructed additional common services. These two developmental tasks were performed iteratively with the integrated button driving the demand for common services such as error handling and link traversal management.\n</P>\n<P>\nThe difference between the interfaces of the original button widget and the integrated widget occurs only in the constructors of the widgets.\n</P>\n<P>\nThe original constructor<A HREF=\"footnotes.html#footnote2\"><SUP>2</SUP></A> is:\n</P>\n<PRE>public Button(String label);\n</PRE>\n<P>\nThe constructor for the integrated widget is:\n</P>\n<PRE>public HButton(\tString label,\n\t\tString viewerName,\n\t\tString objectName);\n</PRE>\n<P>\nAs discussed in <A HREF=\"toolkit.html#sec2.2\">Section&nbsp;2.2</A>, the difference is caused by the context information required by the underlying OHS. In Chimera, the required information is the name of an object and the name of the viewer which displays the object. The HButton<A HREF=\"footnotes.html#footnote3\"><SUP>3</SUP></A> class registers itself as a component with a single anchor using the following code in its constructor:\n</P>\n<PRE>// Register viewer.\ntheViewer = new viewer();\ntheViewer.register(this.viewerName);\n// Register object.\ntheObject = new object();\ntheObject.register(this.objectName);\n// Register view (i.e. component).\ntheView = new view();\ntheView.register(theViewer, theObject);\n// Register anchor.\ntheAnchor = new anchor();\ntheAnchor.register(theView);\n</PRE>\n<P>\nThe integrated button provides access to two hypermedia services: link creation and link traversal. The former allows the button's anchor to be included in links while the latter allows these links to be traversed. In addition, the button can receive link traversal events. When a link traversal event is received, the following code is executed:\n</P>\n<PRE>public synchronized void handleEvent( chimeraEvent theEvent ) {\n\tswitch (theEvent.event) {\n\t\tcase chimeraEvent.linkTraversal:\n\t\t\tdoBlink();\n\t\t\tEvent e = new Event(\n\t\t\t\tthis,\n\t\t\t\tEvent.ACTION_EVENT,\n\t\t\t\tgetLabel());\n\t\t\tpostEvent(e);\n\t\t\t...\n}\n</PRE>\n<P>\nThis code blinks the button (using a simple reverse-video technique not shown) and invokes the button's associated action (by generating an event for the button to handle). The handleEvent routine is called by the hypermedia infrastructure when an event is received from the Chimera server for a particular widget.\n</P>\n<P>\nThe extended button makes use of a common service provided by the hypermedia infrastructure for the initiation of link traversals. As a result the code for a link traversal is short and simple and can be reused in a similar fashion by all subsequent extended widgets. It is shown below:\n</P>\n<PRE>HConnection.traverse( theAnchor );</PRE>\n<P>\nIn other words, the extended widget need only pass the source anchor for the traversal and the common service takes care of the rest. The code for the traverse routine is shown below:\n</P>\n<PRE>public synchronized void traverse( Anchor a ) {<BR>\n\tint number;<BR>\n\tnumber = link.howManyLinks( a );\n\tif (number > 1) {\n\t\tHTraversalDialog htd =\n\t\tnew HTraversalDialog( a );\n\t\treturn;\n\t} else {\n\t\tlink[] links = link.getLinks( a );\n\t\tlink theLink = links[0];\n\t\tnumber = theLink.howManyAnchors();\n\t\tif (number > 2) {\n\t\t\tHTraversalDialog htd =\n\t\t\tnew HTraversalDialog( a );\n\t\t\treturn;\n\t\t}\n\t}\n\tHConnection.theAPI.traverseFrom( a );\n}\n</PRE>\n<P>\nThis code executes a simple algorithm. If the link traversal has a single destination, the traversal is activated. Otherwise a link traversal dialog is displayed (see <A HREF=\"#fig3\">Figure&nbsp;3</A>) allowing the user to specify the desired destinations before activating the traversal. Since all hypermedia-enabled widgets will make use of this service, link traversal behavior is consistent across widgets and across applications constructed with the integrated toolkit. In addition, the behavior is easily modified and maintained, since it is isolated in one place in the hypermedia infrastructure layer. Additional benefits of the TI technique are discussed in the next section.\n</P>\n<TABLE BORDER=\"1\">\n<TR ALIGN=CENTER><TD><A NAME=\"fig3\"><IMG SRC=\"anderson3.gif\"></A></TD></TR>\n<TR>\n<TD><STRONG>Figure 3. The link traversal dialog provided by the hypermedia infrastructure. This dialog lists the destinations for the current link traversal. Destinations consist of a viewer name, object name, and anchor identifier. The dialog allows users to select the desired destinations and traverse to them. Since all link traversals use this dialog, consistent behavior is achieved.\n</TR>\n</TABLE>\n<HR><TABLE WIDTH=100%><TR ALIGN=CENTER><TD><A HREF=\"toolkit.html\">Toolkit Integration Technique</A></TD><TD><A HREF=\"index.html#toc\">Table of Contents</A></TD><TD><A HREF=\"benefits.html\">Benefits</A></TD></TR><TR ALIGN=CENTER><TD>(Previous)</TD><TD></TD><TD>(Next)</TD></TR></TABLE>\n<hr>\n</body></html>\n", "id": 32864.0}