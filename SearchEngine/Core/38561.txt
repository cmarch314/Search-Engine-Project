{"text": "OEChem C Theory Manual Version 1 3 1 Previous 5 Traversing the Atoms Up 5 Traversing the Atoms Next 5 2 Looping over the 5 1 OEChem Iterators The standard way of processing each item or member of a set or collection in OEChem is by the use of an iterator The use of iterators is a common abstraction or design pattern in object oriented programming that hides the way the collection container is implemented from the user Hence a set of atoms could be implemented internally as a array a linked list a hash table or any similar data structure but its behavior to the programmer is independent of the actual implementation An iterator can be thought of as a current position indicator OEChem iterators make use of C s template mechanism The use of templates allows the functionality of an iterator to be specified implemented independently of the type of the collection being iterated over An iterator over a type T has the type OEIter T Hence an iterator over the atoms of a molecule represented by OEAtomBase has type OEIter OEAtomBase and an iterator over the bonds of a molecule has type OEIter OEBondBase The three most common operations of an OEIter are assignment testing and increment These three iterator methods allow OEChem iterators to resemble conventional for loops in high level programming languages Assignment specifies which collection container the iterator is intended to loop over testing determines whether the iterator has seen all of the items and increment advances the iterator to the next position One possible source of confusion is that most functions and methods that return an iterator actually return a result of type OEIterBase T rather than OEIter T The template class OEIterBase T is an internal abstraction used by OEChem and should be treated as an opaque type by the user Suffice to say that values of type OEIterBase T can be assigned to variables of type OEIter T as created by the user A second minor point is that OEChem iterators only support the prefix operator and not the suffix operator This means that to use the advance the iterator users must write i and not i This is actually a performance issue since in C and C the operator i must make a copy of its argument This is to support the syntax j i where j is assigned the value of i before the increment This copying may potentially be expensive and must be performed even if the value is not assigned For primitive types such as integers most C C compilers can determine the value is not used and optimize i to i Alas for C classes most compilers are unable to perform this optimization and as such i and i could do totally different things hence i is the preferred idiom Even if OEChem changed the semantics of i to perform the same thing as i and return the value after the increment the i form is marginally less efficient requiring an invisible integer argument to be passed to the operator Hence OpenEye s policy is to only implement the correct behavior and hope that users of OEChem will adopt i even for integer loops as good coding style Finally the template OEIter is defined in the OESystem namespace rather than the OEChem namespace This is because iterators like random number generators are not chemistry specific and the use of two namespaces makes this explicit It does however mean an extra using namespace OESystem in our examples OEChem C Theory Manual Version 1 3 1 Previous 5 Traversing the Atoms Up 5 Traversing the Atoms Next 5 2 Looping over the Documentation released on July 3 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/oechem/cplusprog/node43.html", "title": "5.1 oechem iterators", "html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html>\n<head>\n<title>5.1 OEChem Iterators</title>\n<META NAME=\"description\" CONTENT=\"5.1 OEChem Iterators\">\n<META NAME=\"keywords\" CONTENT=\"cplusprog\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<link rel=\"STYLESHEET\" href=\"cplusprog.css\">\n<link rel=\"first\" href=\"cplusprog.html\">\n<link rel=\"contents\" href=\"contents.html\" title=\"Contents\">\n\n<LINK REL=\"next\" HREF=\"node44.html\">\n<LINK REL=\"previous\" HREF=\"node42.html\">\n<LINK REL=\"up\" HREF=\"node42.html\">\n<LINK REL=\"next\" HREF=\"node44.html\">\n</head>\n<body>\n<DIV CLASS=\"navigation\">\n<table align=\"center\" border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n<tr>\n<td rowspan=2><A HREF=\"node42.html\"><img src=\"../icons/previous.gif\"\n  border=\"0\" alt=\"Previous Page\"></A></td>\n<td rowspan=2><A HREF=\"node42.html\"><img src=\"../icons/up.gif\"\n  border=\"0\" alt=\"Up One Level\"></A></td>\n<td rowspan=2><A HREF=\"node44.html\"><img src=\"../icons/next.gif\"\n  border=\"0\" alt=\"Next Page\"></A></td><td width=\"100%\" rowspan=\"2\"> </td>\n<td valign=\"center\" align=\"right\" height=\"56\" background=\"../icons/title_bkgd.gif\" colspan=4 class=\"navigation\">OEChem - C++ Theory Manual\n<BR>\nVersion 1.3.1</td></tr>\n<tr><td><img src=\"../icons/spacer_1.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><A href=\"contents.html\"><img src=\"../icons/contents.gif\"\n  border=\"0\" alt=\"Contents\"></A></td>\n<td><img src=\"../icons/spacer_2.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><img src=\"../icons/blank_4.gif\"\n  border=\"0\" alt=\"\"></td>\n</tr></table>\n<b class=\"navlabel\">Previous:</b> <a class=\"sectref\" HREF=\"node42.html\">5. Traversing the Atoms,</A>\n<b class=\"navlabel\">Up:</b> <a class=\"sectref\" HREF=\"node42.html\">5. Traversing the Atoms,</A>\n<b class=\"navlabel\">Next:</b> <a class=\"sectref\" HREF=\"node44.html\">5.2 Looping over the</A>\n<br><hr>\n</DIV>\n<!--End of Navigation Panel-->\n\n<H1><A NAME=\"SECTION008100000000000000000\">\n5.1 OEChem Iterators</A>\n</H1>\n\n<P>\nThe standard way of processing each item or member of a set or\ncollection in OEChem is by the use of an iterator.  The use of\niterators is a common abstraction (or design pattern) in object\noriented programming, that hides the way the collection/container is\nimplemented from the user.  Hence a set of atoms could be implemented\ninternally as a array, a linked list, a hash table or any similar data\nstructure, but its behavior to the programmer is independent of the\nactual implementation.  An iterator can be thought of as a current\nposition indicator.\n\n<P>\nOEChem iterators make use of C++'s template mechanism.  The use of\ntemplates allows the functionality of an iterator to be specified\n(implemented) independently of the type of the collection being\niterated over.  An iterator over a type <code>T</code>, has the type\n<code>OEIter&lt;T&gt;</code>.  Hence, an iterator over the atoms of a molecule\n(represented by OEAtomBase) has type <code>OEIter&lt;OEAtomBase&gt;</code> and an\niterator over the bonds of a molecule has type <code>OEIter&lt;OEBondBase&gt;</code>.\n\n<P>\nThe three most common operations of an OEIter are assignment, testing\nand increment.  These three iterator methods allow OEChem iterators to\nresemble conventional <code>for</code> loops in high level programming languages.\nAssignment specifies which collection/container the iterator is\nintended to loop over, testing determines whether the iterator has\nseen all of the items, and increment advances the iterator to the next\nposition.\n\n<P>\nOne possible source of confusion is that most functions and methods\nthat return an iterator, actually return a result of type\n<code>OEIterBase&lt;T&gt;</code> rather than <code>OEIter&lt;T&gt;</code>. The template class\n<code>OEIterBase&lt;T&gt;</code> is an internal abstraction used by OEChem, and should\nbe treated as an opaque type by the user.  Suffice to say that values\nof type <code>OEIterBase&lt;T&gt;</code> can be assigned to variables of type\n<code>OEIter&lt;T&gt;</code> as created by the user.\n\n<P>\nA second minor point is that OEChem iterators only support the prefix\n<code>++</code> operator, and not the suffix <code>++</code> operator.  This means that to\nuse the advance the iterator, users must write <code>++i</code> and not\n<code>i++</code>.  This is actually a performance issue, since in C and C++\nthe operator <code>i++</code> must make a copy of its argument.  This is to\nsupport the syntax <code>j = i++</code> where <var>j</var> is assigned the value\nof <var>i</var> before the increment.  This copying may potentially be\nexpensive, and must be performed even if the value is not assigned.\nFor primitive types such as integers, most C/C++ compilers can\ndetermine the value is not used and optimize <code>i++</code> to <code>++i</code>.\nAlas for C++ classes, most compilers are unable to perform this\noptimization and as such <code>i++</code> and <code>++i</code> could do totally\ndifferent things, hence <code>++i</code> is the preferred idiom.  Even if\nOEChem changed the semantics of <code>i++</code> to perform the same thing\nas <code>++i</code> and return the value after the increment, the <code>i++</code>\nform is marginally less efficient (requiring an ``invisible'' integer\nargument to be passed to the operator).  Hence OpenEye's policy is to\nonly implement the ``correct'' behavior and hope that users of OEChem\nwill adopt <code>++i</code> even for integer loops as good coding style.\n\n<P>\nFinally, the template OEIter is defined in the OESystem namespace\nrather than the OEChem namespace.  This is because iterators (like\nrandom number generators) are not chemistry specific, and the use of\ntwo namespaces makes this explicit.  It does however mean an extra\n<code>using namespace OESystem;</code> in our examples.\n\n<P>\n\n<DIV CLASS=\"navigation\">\n<p><hr>\n<table align=\"center\" border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n<tr>\n<td rowspan=2><A HREF=\"node42.html\"><img src=\"../icons/previous.gif\"\n  border=\"0\" alt=\"Previous Page\"></A></td>\n<td rowspan=2><A HREF=\"node42.html\"><img src=\"../icons/up.gif\"\n  border=\"0\" alt=\"Up One Level\"></A></td>\n<td rowspan=2><A HREF=\"node44.html\"><img src=\"../icons/next.gif\"\n  border=\"0\" alt=\"Next Page\"></A></td><td width=\"100%\" rowspan=\"2\"> </td>\n<td valign=\"center\" align=\"right\" height=\"56\" background=\"../icons/title_bkgd.gif\" colspan=4 class=\"navigation\">OEChem - C++ Theory Manual\n<BR>\nVersion 1.3.1</td></tr>\n<tr><td><img src=\"../icons/spacer_1.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><A href=\"contents.html\"><img src=\"../icons/contents.gif\"\n  border=\"0\" alt=\"Contents\"></A></td>\n<td><img src=\"../icons/spacer_2.gif\"\n  border=\"0\" alt=\"\"></td>\n<td><img src=\"../icons/blank_4.gif\"\n  border=\"0\" alt=\"\"></td>\n</tr></table>\n<b class=\"navlabel\">Previous:</b> <a class=\"sectref\" HREF=\"node42.html\">5. Traversing the Atoms,</A>\n<b class=\"navlabel\">Up:</b> <a class=\"sectref\" HREF=\"node42.html\">5. Traversing the Atoms,</A>\n<b class=\"navlabel\">Next:</b> <a class=\"sectref\" HREF=\"node44.html\">5.2 Looping over the</A>\n<hr>\n<span class=\"release-info\">Documentation released on July 30, 2004.</span>\n</DIV>\n<!--End of Navigation Panel-->\n\n</BODY>\n</HTML>\n", "id": 38561.0}