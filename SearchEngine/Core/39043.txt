{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 29Halfedge Data Structures Lutz Kettner 29 1 Introduction A halfedge data structure abbreviated as HalfedgeDS or HDS for template parameters is an edge centered data structure capable of maintaining incidence informations of vertices edges and faces for example for planar maps polyhedra or other orientable two dimensional surfaces embedded in arbitrary dimension Each edge is decomposed into two halfedges with opposite orientations One incident face and one incident vertex are stored in each halfedge For each face and each vertex one incident halfedge is stored Reduced variants of the halfedge data structure can omit some of these informations for example the halfedge pointers in faces or the storage of faces at all The halfedge data structure is a combinatorial data structure geometric interpretation is added by classes built on top of the halfedge data structure These classes might be more convenient to use than the halfedge data structure directly since the halfedge data structure is meant as an implementation layer See for example the CGAL Polyhedron 3 class in Chapter The data structure provided here is also known as the FE structure Wei85 as halfedges M n88 BFH95 or as the doubly connected edge list DCEL dBvKOS97 although the original reference for the DCEL MP78 describes a different data structure The halfedge data structure can also be seen as one of the variants of the quad edge data structure GS85 In general the quad edge data can represent non orientable 2 manifolds but the variant here is restricted to orientable 2 manifolds only An overview and comparison of these different data structures together with a thorough description of the design implemented here can be found in Ket99 The design presented here is a revised and incompatible version of the previous design Ket98 as used in CGAL R2 2 and earlier releases Files and identifier names are disjoint with the old design which allows for both versions to co exists However classes using a halfedge data structure can only use one design For example the polyhedral surface Polyhedron 3 uses by default the new design See Chapter for how to still select the old implementation 29 2 Software Design Figure Responsibilities of the different layers in the halfedge data structure design Figure illustrates the responsibilities of the three layers of the software design with the CGAL Polyhedron 3 as an example for the top layer The items provide the space for the information that is actually stored i e with member variables and access member functions in Vertex Halfedge and Face respectively Halfedges are required to provide a reference to the next halfedge and to the opposite halfedge Optionally they may provide a reference to the previous halfedge to the incident vertex and to the incident face Vertices and faces may be empty Optionally they may provide a reference to the incident halfedge The options mentioned are supported in the halfedge data structure and the polyhedron for example Euler operations update the optional references if they are present Furthermore the item classes can be extended with arbitrary attributes and member functions which will be promoted by inheritance to the actual classes used for the polyhedron Vertices halfedges and faces are passed as local types of the Items class to the halfedge data structure and polyhedron Implementations for vertices halfedges and faces are provided that fulfill the mandatory part of the requirements They can be used as base classes for extensions by the user Richer implementations are also provided to serve as defaults for polyhedra they provide all optional incidences a three dimensional point in the vertex type and a plane equation in the face type The Halfedge data structure concept HalfedgeDS is responsible for the storage organization of the items Currently implementations using internally a bidirectional list or a vector are provided The HalfedgeDS defines the handles and iterators belonging to the items These types are promoted to the declaration of the items themselves and are used there to provide the references to the incident items This promotion of types is done with a template parameter Refs of the item types The halfedge data structure provides member functions to insert and delete items to traverse all items and it gives access to the items There are two different models for the HalfedgeDS concept available HalfedgeDS list and HalfedgeDS vector and more might come Therefore we have kept their interface small and factored out common functionality into separate helper classes HalfedgeDS decorator HalfedgeDS const decorator and HalfedgeDS items decorator which are not shown in Figure but would be placed at the side of the HalfedgeDS since they broaden that interface but do not hide it These helper classes contain operations that are useful to implement the operations in the next layer for example the polyhedron They add for example the Euler operations and partial operations from which further Euler operations can be built such as inserting an edge into the ring of edges at a vertex Furthermore the helper classes contain adaptive functionality For example if the prev member function is not provided for halfedges the find prev member function of a helper class searches in the positive direction along the face for the previous halfedge But if the prev member function is provided the find prev member function simply calls it This distinction is resolved at compile time with a technique called compile time tags similar to iterator tags in SL95 The Polyhedron 3 as an example for the third layer adds the geometric interpretation provides an easy to use interface of high level functions and unifies the access to the flexibility provided underneath It renames face to facet which is more common for three dimensional surfaces The interface is designed to protect the integrity of the internal representation the handles stored in the items can no longer directly be written by the user The polyhedron adds the convenient and efficient circulators see the Support Library Manuals for accessing the circular sequence of edges around a vertex or around a facet To achieve this the Polyhedron 3 derives new vertices halfedges and facets from those provided in Items These new items are those actually used in the HalfedgeDS which gives us the coherent type structure in this design especially if compared to our previous design 29 3 Example Programs 29 3 1 The Default Halfedge Data Structure The following example program uses the default halfedge data structure and the decorator class The default halfedge data structure uses a list based representation All incidences of the items and a point type for vertices are defined The trivial traits class provides the type used for the point The program creates a loop consisting of two halfedges one vertex and two faces and checks its validity file examples HalfedgeDS hds prog default C include CGAL HalfedgeDS default h include CGAL HalfedgeDS decorator h struct Traits typedef int Point 2 typedef CGAL HALFEDGEDS DEFAULT Traits HDS typedef CGAL HalfedgeDS decorator HDS Decorator int main HDS hds Decorator decorator hds decorator create loop CGAL assertion decorator is valid return 29 3 2 A Minimal Halfedge Data Structure The following program defines a minimal halfedge data structure using the minimal items class CGAL HalfedgeDS min items and a list based halfedge data structure The result is a data structure maintaining only halfedges with next and opposite pointers No vertices or faces are stored The data structure represents an undirected graph file examples HalfedgeDS hds prog graph C include CGAL HalfedgeDS min items h include CGAL HalfedgeDS default h include CGAL HalfedgeDS decorator h no traits needed argument can be arbitrary dummy typedef CGAL HALFEDGEDS DEFAULT int CGAL HalfedgeDS min items HDS typedef CGAL HalfedgeDS decorator HDS Decorator int main HDS hds Decorator decorator hds decorator create loop CGAL assertion decorator is valid return 29 3 3 The Default with a Vector Instead of a List The default halfedge data structure uses a list internally and the maximal base classes We change the list to a vector representation here Again a trivial traits class provides the type used for the point Note that for the vector storage the size of the halfedge data structure should be reserved beforehand either with the constructor as shown in the example or with the reserve member function One can later resize the data structure with further calls to the reserve member function but only if the data structure is in a consistent i e valid state Unfortunately this example has also to expose the workaround necessary for compilers that do not support templates as template parameters The workaround is necessary if the symbolic constant CGAL CFG NO TMPL IN TMPL PARAM is set It uses a member template instead of the class template file examples HalfedgeDS hds prog vector C include CGAL HalfedgeDS items 2 h include CGAL HalfedgeDS vector h include CGAL HalfedgeDS decorator h struct Traits typedef int Point 2 ifndef CGAL CFG NO TMPL IN TMPL PARAM typedef CGAL HalfedgeDS vector Traits CGAL HalfedgeDS items 2 HDS else typedef CGAL HalfedgeDS vector HDS Traits CGAL HalfedgeDS items 2 HDS endif typedef CGAL HalfedgeDS decorator HDS Decorator int main HDS hds 1 2 2 Decorator decorator hds decorator create loop CGAL assertion decorator is valid return 29 3 4 Example Adding Color to Faces This example re uses the base class available for faces and adds a member variable color file examples HalfedgeDS hds prog color C include CGAL HalfedgeDS items 2 h include CGAL HalfedgeDS default h include CGAL IO Color h A face type with a color member variable template class Refs struct My face public CGAL HalfedgeDS face base Refs CGAL Color color My face My face CGAL Color c color c An items type using my face struct My items public CGAL HalfedgeDS items 2 template class Refs class Traits struct Face wrapper typedef My face Refs Face struct My traits arbitrary point type not used here typedef int Point 2 typedef CGAL HALFEDGEDS DEFAULT My traits My items HDS typedef HDS Face Face typedef HDS Face handle Face handle int main HDS hds Face handle f hds faces push back Face CGAL RED f color CGAL BLUE CGAL assertion f color CGAL BLUE return 29 3 5 Example Defining a More Compact Halfedge advanced The halfedge data structure as presented here is slightly less space efficient as for example the winged edge data structure Bau75 the DCEL MP78 or variants of the quad edge data structure GS85 On the other hand it does not require any search operations during traversals A comparison can be found in Ket99 The following example trades traversal time for a compact storage representation using traditional C techniques i e type casting and the assumption that pointers especially those from malloc or new point to even addresses The idea goes as follows The halfedge data structure allocates halfedges pairwise Concerning the vector based data structure this implies that the absolute value of the difference between a halfedge and its opposite halfedge is always one with respect to C pointer arithmetic We can replace the opposite pointer by a single bit encoding the sign of this difference We will store this bit as the least significant bit in the next halfedge handle Furthermore we do not implement a pointer to the previous halfedge What remains are three pointers per halfedge We use the static member function halfedge handle to convert from pointers to halfedge handles The same solution can be applied to the list based halfedge data structure CGAL HalfedgeDS list see examples HalfedgeDS hds prog compact2 C Here is the example for the vector based data structure file examples HalfedgeDS hds prog compact C include CGAL HalfedgeDS items 2 h include CGAL HalfedgeDS vector h include CGAL HalfedgeDS decorator h include cstddef Define a new halfedge class We assume that the Halfedge handle can be created from a pointer e g the HalfedgeDS is based here on the In place list or a std vector with such property and that halfedges are allocated in pairs We encode the opposite pointer in a single bit which is stored in the lower bit of the next pointer We use the static member function HDS halfedge handle to translate pointer to handles template class Refs class My halfedge public typedef Refs HDS typedef My halfedge Refs Base base typedef My halfedge Refs Base typedef My halfedge Refs Self typedef CGAL Tag false Supports halfedge prev typedef CGAL Tag true Supports halfedge vertex typedef CGAL Tag true Supports halfedge face typedef typename Refs Vertex handle Vertex handle typedef typename Refs Vertex const handle Vertex const handle typedef typename Refs Halfedge Halfedge typedef typename Refs Halfedge handle Halfedge handle typedef typename Refs Halfedge const handle Halfedge const handle typedef typename Refs Face handle Face handle typedef typename Refs Face const handle Face const handle private std ptrdiff t nxt public My halfedge nxt f Face handle Halfedge handle opposite Halfedge could be different from My halfedge e g pointer for linked list Get proper handle from this pointer first do pointer arithmetic then convert pointer back to handle again Halfedge handle h HDS halfedge handle this proper handle if nxt 1 return HDS halfedge handle h 1 return HDS halfedge handle h 1 Halfedge const handle opposite const same as above Halfedge const handle h HDS halfedge handle this proper handle if nxt 1 return HDS halfedge handle h 1 return HDS halfedge handle h 1 Halfedge handle next return HDS halfedge handle Halfedge nxt std ptrdiff t 1 Halfedge const handle next const return HDS halfedge handle const Halfedge nxt std ptrdiff t 1 void set opposite Halfedge handle h CGAL precondition h 1 HDS halfedge handle this h 1 HDS halfedge handle this if h 1 HDS halfedge handle this nxt 1 else nxt std ptrdiff t 1 void set next Halfedge handle h CGAL precondition std ptrdiff t h 1 nxt std ptrdiff t h nxt 1 private Support for the Vertex handle Vertex handle v public the incident vertex Vertex handle vertex return v Vertex const handle vertex const return v void set vertex Vertex handle w v w private Face handle f public Face handle face return f Face const handle face const return f void set face Face handle g f g bool is border const return f Face handle Replace halfedge in the default items type struct My items public CGAL HalfedgeDS items 2 template class Refs class Traits struct Halfedge wrapper typedef My halfedge Refs Halfedge struct Traits typedef int Point 2 ifndef CGAL CFG NO TMPL IN TMPL PARAM typedef CGAL HalfedgeDS vector Traits My items HDS else typedef CGAL HalfedgeDS vector HDS Traits My items HDS endif typedef CGAL HalfedgeDS decorator HDS Decorator int main HDS hds 1 2 2 Decorator decorator hds decorator create loop CGAL assertion decorator is valid return advanced 29 3 6 Example Using the Halfedge Iterator Two edges are created in the default halfedge data structure The halfedge iterator is used to count the halfedges file examples HalfedgeDS hds prog halfedge iterator C include CGAL HalfedgeDS default h include CGAL HalfedgeDS decorator h struct Traits typedef int Point 2 typedef CGAL HALFEDGEDS DEFAULT Traits HDS typedef CGAL HalfedgeDS decorator HDS Decorator typedef HDS Halfedge iterator Iterator int main HDS hds Decorator decorator hds decorator create loop decorator create segment CGAL assertion decorator is valid int n for Iterator i hds halfedges begin i hds halfedges end i n CGAL assertion n 4 2 edges return 29 3 7 Example for an Adapter to Build an Edge Iterator Three edges are created in the default halfedge data structure The adapter N step adaptor is used to declare the edge iterator used in counting the edges file examples HalfedgeDS hds prog edge iterator C include CGAL HalfedgeDS default h include CGAL HalfedgeDS decorator h include CGAL N step adaptor h struct Traits typedef int Point 2 typedef CGAL HALFEDGEDS DEFAULT Traits HDS typedef CGAL HalfedgeDS decorator HDS Decorator typedef HDS Halfedge iterator Halfedge iterator typedef CGAL N step adaptor Halfedge iterator 2 Iterator int main HDS hds Decorator decorator hds decorator create loop decorator create segment CGAL assertion decorator is valid int n for Iterator e hds halfedges begin e hds halfedges end e n CGAL assertion n 2 2 edges return Next chapter Halfedge Data Structure Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/HalfedgeDS/Chapter_main.html", "title": "halfedge data structures", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './HalfedgeDS/main.tex' -->\n<html> <head>  \n<title>Halfedge Data Structures</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_29\"></a>\n  \n<h1>Chapter 29<BR>Halfedge Data Structures</h1>\n\n<A NAME=\"chapterHalfedgeDS\"></A>\n\n<EM>Lutz Kettner</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>29.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n<P>\n\nA halfedge data structure (abbreviated as <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>, or\n<I>HDS</I> for template parameters) is an edge-centered data structure\ncapable of maintaining incidence informations of vertices, edges and\nfaces, for example for planar maps, polyhedra, or other orientable,\ntwo-dimensional surfaces embedded in arbitrary dimension. Each edge is\ndecomposed into two halfedges with <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations. One incident\nface and one incident vertex are stored in each halfedge.  For each\nface and each vertex, one incident halfedge is stored.  Reduced\nvariants of the halfedge data structure can omit some of these\ninformations, for example the halfedge pointers in faces or the\nstorage of faces at all.\n<P>\n\n<CENTER>\n    <A HREF=\"fig/halfedge.gif\">\n        <img src=\"fig/halfedge_small.gif\" alt=\"Halfedge Diagram\"></A>\n<P>\n\n</CENTER>\n<P>\n\nThe halfedge data structure is a combinatorial data structure,\ngeometric interpretation is added by classes built on top of the\nhalfedge data structure.  These classes might be more convenient to\nuse than the halfedge data structure directly, since the halfedge data\nstructure is meant as an implementation layer.  See for example the\n<I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A></I> class in Chapter&nbsp;<A HREF=\"../Polyhedron/Chapter_main.html#chapterPolyhedron\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nThe data structure provided here is also known as the\nFE-structure&nbsp;[<A HREF=\"../biblio.html#Biblio_w-ebdss-85\">Wei85</A>], as\nhalfedges&nbsp;[<A HREF=\"../biblio.html#Biblio_m-ism-88\">M&auml;n88</A>, <A HREF=\"../biblio.html#Biblio_cgal:bfh-mgedm-95\">BFH95</A>] or as the doubly connected edge\nlist (DCEL)&nbsp;[<A HREF=\"../biblio.html#Biblio_bkos-cgaa-97\">dBvKOS97</A>], although the original reference for\nthe DCEL&nbsp;[<A HREF=\"../biblio.html#Biblio_mp-fitcp-78\">MP78</A>] describes a different data structure. The\nhalfedge data structure can also be seen as one of the variants of the\nquad-edge data structure&nbsp;[<A HREF=\"../biblio.html#Biblio_gs-pmgsc-85\">GS85</A>]. In general, the quad-edge\ndata can represent non-orientable 2-manifolds, but the variant here is\nrestricted to orientable 2-manifolds only. An overview and comparison\nof these different data structures together with a thorough\ndescription of the design implemented here can be found\nin&nbsp;[<A HREF=\"../biblio.html#Biblio_k-ugpdd-99\">Ket99</A>].\n<P>\n\nThe design presented here is a revised and incompatible version of the\nprevious design&nbsp;[<A HREF=\"../biblio.html#Biblio_k-ddsps-98\">Ket98</A>] as used in C<SMALL>GAL</SMALL> R2.2 and earlier\nreleases. Files and identifier names are disjoint with the old design\nwhich allows for both versions to co-exists. However, classes using a\nhalfedge data structure can only use one design. For example the\npolyhedral surface <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> uses by default the new\ndesign. See Chapter&nbsp;<A HREF=\"../Polyhedron/Chapter_main.html#chapterPolyhedron\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for how to still select\nthe old implementation.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>29.2&nbsp;&nbsp;&nbsp;Software Design</h2>\n<P>\n\n<CENTER>\n    <A NAME=\"figureHalfedgeDSDesign\">\n        <img src=\"fig/hds_design_col.gif\"\n         alt=\"Halfedge Data-Structure Design\"><BR>\n    Figure: Responsibilities of the different layers in the \n            halfedge data-structure design.\n    <P>\n    </CENTER>\n\n<P>\n\nFigure&nbsp;\n  <A HREF=\"Chapter_main.html#figureHalfedgeDSDesign\"><IMG \n  SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference arrow\" WIDTH=\"10\" HEIGHT=\"10\"></A>\n\nillustrates the responsibilities of the three layers of the software\ndesign, with the <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A></I> as an example for the top\nlayer.  The items provide the space for the information that is\nactually stored, i.e., with member variables and access member\nfunctions in <I>Vertex</I>, <I>Halfedge</I>, and <I>Face</I>\nrespectively. Halfedges are required to provide a reference to the\nnext halfedge and to the <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> halfedge.  Optionally they may\nprovide a reference to the previous halfedge, to the incident vertex,\nand to the incident face. Vertices and faces may be empty. Optionally\nthey may provide a reference to the incident halfedge. The options\nmentioned are supported in the halfedge data structure and the\npolyhedron, for example, Euler operations update the optional\nreferences if they are present. Furthermore, the item classes can be\nextended with arbitrary attributes and member functions, which will be\npromoted by inheritance to the actual classes used for the polyhedron.\n<P>\n\nVertices, halfedges, and faces are passed as local types of the\n<I>Items</I> class to the halfedge data structure and polyhedron.\nImplementations for vertices, halfedges and faces are provided that\nfulfill the mandatory part of the requirements. They can be used as\nbase classes for extensions by the user. Richer implementations are\nalso provided to serve as defaults; for polyhedra they provide all\noptional incidences, a three-dimensional point in the vertex type and\na plane equation in the face type.\n<P>\n\nThe <I>Halfedge_data_structure</I>, concept <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>, is\nresponsible for the storage organization of the items. Currently,\nimplementations using internally a bidirectional list or a\nvector are provided. The <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I> defines the handles and iterators\nbelonging to the items. These types are promoted to the declaration of\nthe items themselves and are used there to provide the references to\nthe incident items. This promotion of types is done with a template\nparameter <I>Refs</I> of the item types.  The halfedge data structure\nprovides member functions to insert and delete items, to traverse all\nitems, and it gives access to the items.\n<P>\n\nThere are two different models for the <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I> concept available,\n<I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_list.html#Cross_link_anchor_900\">HalfedgeDS_list</A></I> and <I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_902\">HalfedgeDS_vector</A></I>, and more might come.\nTherefore we have kept their interface small and factored out common\nfunctionality into separate helper classes, <I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A></I>,\n<I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_const_decorator.html#Cross_link_anchor_879\">HalfedgeDS_const_decorator</A></I>, and <I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_decorator.html#Cross_link_anchor_896\">HalfedgeDS_items_decorator</A></I>,\nwhich are not shown in\nFigure&nbsp; <A\nHREF=\"Chapter_main.html#figureHalfedgeDSDesign\"><IMG\nSRC=\"cc_ref_up_arrow.gif\" ALT=\"reference arrow\" WIDTH=\"10\"\nHEIGHT=\"10\"></A>\n, but would be placed at the side of the <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>\nsince they broaden that interface but do not hide it.  These helper\nclasses contain operations that are useful to implement the operations\nin the next layer, for example, the polyhedron. They add, for example,\nthe Euler operations and partial operations from which further Euler\noperations can be built, such as inserting an edge into the ring of\nedges at a vertex.  Furthermore, the helper classes contain adaptive\nfunctionality.  For example, if the <I>prev()</I> member function is\nnot provided for halfedges, the <I>find_prev()</I> member function of\na helper class searches in the positive direction along the face for\nthe previous halfedge. But if the <I>prev()</I> member function is\nprovided, the <I>find_prev()</I> member function simply calls it. This\ndistinction is resolved at compile time with a technique called <I>compile-time tags</I>, similar to iterator tags in&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:sl-stl-95\">SL95</A>].\n<P>\n\nThe <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> as an example for the third layer adds the\ngeometric interpretation, provides an easy-to-use interface of\nhigh-level functions, and unifies the access to the flexibility\nprovided underneath.  It renames face to facet, which is more common\nfor three-dimensional surfaces.  The interface is designed to protect\nthe integrity of the internal representation, the handles stored in\nthe items can no longer directly be written by the user.  The\npolyhedron adds the convenient and efficient circulators, see the\nSupport Library Manuals, for accessing the circular sequence of edges\naround a vertex or around a facet. To achieve this, the\n<I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A></I> derives new vertices, halfedges and facets from those\nprovided in <I>Items</I>.  These new items are those actually used in\nthe <I><A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A></I>, which gives us the coherent type\nstructure in this design, especially if compared to our previous\ndesign.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>29.3&nbsp;&nbsp;&nbsp;Example Programs</h2>\n\n<A NAME=\"sectionHdsExamples\"></A>\n<P>\n\n<h3>29.3.1&nbsp;&nbsp;&nbsp;The Default Halfedge Data Structure</h3>\n<P>\n\nThe following example program uses the default halfedge data structure\nand the decorator class. The default halfedge data structure uses a\nlist-based representation. All incidences of the items and a point\ntype for vertices are defined. The trivial traits class provides the\ntype used for the point. The program creates a loop, consisting\nof two halfedges, one vertex and two faces, and checks its validity.\n<P>\n\n<CENTER>\n      <img src=\"fig/loop.gif\" alt=\"Loop Example\">\n<P>\n\n</CENTER>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_default.C\n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_883\">HalfedgeDS_default</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>.h&gt;\n\nstruct Traits { typedef int <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>; };\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_884\">CGAL_HALFEDGEDS_DEFAULT</A>&lt;Traits&gt; HDS;\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt; Decorator;\n\nint main() {\n    HDS hds;\n    Decorator decorator(hds);\n    decorator.create_loop();\n    CGAL_assertion( decorator.is_valid());\n    return 0;\n}\n</pre>\n<P>\n\n<h3>29.3.2&nbsp;&nbsp;&nbsp;A Minimal Halfedge Data Structure</h3>\n<P>\n\nThe following program defines a minimal halfedge data structure using\nthe minimal items class <I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_min_items.html#Cross_link_anchor_897\">CGAL::HalfedgeDS_min_items</A></I> and a\nlist-based halfedge data structure. The result is a data structure\nmaintaining only halfedges with next and <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> pointers.  No\nvertices or faces are stored. The data structure represents an <I>undirected graph</I>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_graph.C\n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_min_items.html#Cross_link_anchor_898\">HalfedgeDS_min_items</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_883\">HalfedgeDS_default</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>.h&gt;\n\n// no traits needed, argument can be arbitrary dummy.\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_884\">CGAL_HALFEDGEDS_DEFAULT</A>&lt;int, <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_min_items.html#Cross_link_anchor_897\">CGAL::HalfedgeDS_min_items</A>&gt; HDS;\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt;  Decorator;\n\nint main() {\n    HDS hds;\n    Decorator decorator(hds);\n    decorator.create_loop();\n    CGAL_assertion( decorator.is_valid());\n    return 0;\n}\n</pre>\n<P>\n\n<h3>29.3.3&nbsp;&nbsp;&nbsp;The Default with a Vector Instead of a List</h3>\n<P>\n\nThe default halfedge data structure uses a list internally and the\nmaximal base classes. We change the list to a vector representation\nhere. Again, a trivial traits class provides the type used for the\npoint.  Note that for the vector storage the size of the halfedge data\nstructure should be reserved beforehand, either with the constructor\nas shown in the example or with the <I>reserve()</I> member function.\nOne can later resize the data structure with further calls to the\n<I>reserve()</I> member function, but only if the data structure is \nin a consistent, i.e., <I>valid</I>, state.\n<P>\n\nUnfortunately this example has also to expose the workaround necessary\nfor compilers that do not support templates as template parameters.\nThe workaround is necessary if the symbolic constant\n<TT>CGAL_CFG_NO_TMPL_IN_TMPL_PARAM</TT> is set. It uses a member \ntemplate instead of the class template.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_vector.C              \n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_894\">HalfedgeDS_items_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_902\">HalfedgeDS_vector</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>.h&gt;\n\nstruct Traits { typedef int <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>; };\n#ifndef CGAL_CFG_NO_TMPL_IN_TMPL_PARAM\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_901\">CGAL::HalfedgeDS_vector</A>     &lt; Traits, <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_893\">CGAL::HalfedgeDS_items_2</A>&gt; HDS;\n#else\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_901\">CGAL::HalfedgeDS_vector</A>::HDS&lt; Traits, <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_893\">CGAL::HalfedgeDS_items_2</A>&gt; HDS;\n#endif\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt;  Decorator;\n\nint main() {\n    HDS hds(1,2,2);\n    Decorator decorator(hds);\n    decorator.create_loop();\n    CGAL_assertion( decorator.is_valid());\n    return 0;\n}\n</pre>\n<P>\n\n<h3>29.3.4&nbsp;&nbsp;&nbsp;Example Adding Color to Faces</h3>\n<P>\n\nThis example re-uses the base class available for faces and adds a\nmember variable <I>color</I>.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_color.C\n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_894\">HalfedgeDS_items_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_883\">HalfedgeDS_default</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1754\">Color</A>.h&gt;\n\n// A face type with a color member variable.\ntemplate &lt;class Refs&gt;\nstruct My_face : public <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_face_base.html#Cross_link_anchor_885\">CGAL::HalfedgeDS_face_base</A>&lt;Refs&gt; {\n    <A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A> color;\n    My_face() {}\n    My_face( <A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A> c) : color(c) {}\n};\n\n// An items type using my face.\nstruct My_items : public <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_893\">CGAL::HalfedgeDS_items_2</A> {\n    template &lt;class Refs, class Traits&gt;\n    struct Face_wrapper {\n        typedef My_face&lt;Refs&gt; Face;\n    };\n};\n\nstruct My_traits { // arbitrary point type, not used here.\n    typedef int  <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>;\n};\n\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_884\">CGAL_HALFEDGEDS_DEFAULT</A> &lt;My_traits, My_items&gt; HDS;\ntypedef HDS::Face                                     Face;\ntypedef HDS::Face_handle                              Face_handle;\n\nint main() {\n    HDS hds;\n    Face_handle f = hds.faces_push_back( Face( CGAL::RED));\n    f-&gt;color = CGAL::BLUE;\n    CGAL_assertion( f-&gt;color == CGAL::BLUE);\n    return 0;\n}\n</pre>\n<P>\n\n<h3>29.3.5&nbsp;&nbsp;&nbsp;Example Defining a More Compact Halfedge</h3>\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n<P>\n\nThe halfedge data structure as presented here is slightly less space\nefficient as, for example, the winged-edge data\nstructure&nbsp;[<A HREF=\"../biblio.html#Biblio_b-prcv-75\">Bau75</A>], the DCEL&nbsp;[<A HREF=\"../biblio.html#Biblio_mp-fitcp-78\">MP78</A>] or variants of\nthe quad-edge data structure&nbsp;[<A HREF=\"../biblio.html#Biblio_gs-pmgsc-85\">GS85</A>].  On the other hand,\nit does not require any search operations during traversals. A\ncomparison can be found in&nbsp;[<A HREF=\"../biblio.html#Biblio_k-ugpdd-99\">Ket99</A>].\n<P>\n\nThe following example trades traversal time for a compact storage\nrepresentation using traditional C techniques (i.e., type casting and\nthe assumption that pointers, especially those from <TT>malloc</TT> or\n<TT>new</TT>, point to even addresses). The idea goes as follows: The\nhalfedge data structure allocates halfedges pairwise.  Concerning the\nvector-based data structure this implies that the absolute value of\nthe difference between a halfedge and its <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> halfedge is always\none with respect to C pointer arithmetic. We can replace the <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>\npointer by a single bit encoding the <A HREF=\"../NumberTypeSupport_ref/Function_sign.html#Cross_link_anchor_1410\">sign</A> of this difference.  We will\nstore this bit as the least significant bit in the next halfedge\nhandle.  Furthermore, we do not implement a pointer to the previous\nhalfedge. What remains are three pointers per halfedge.\n<P>\n\nWe use the static member function <I>halfedge_handle()</I> to convert\nfrom pointers to halfedge handles. The same solution can be applied to\nthe list-based halfedge data structure <I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_list.html#Cross_link_anchor_899\">CGAL::HalfedgeDS_list</A></I>,\nsee <TT>examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_compact2.C</TT>. Here is the\nexample for the vector-based data structure.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_compact.C\n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_894\">HalfedgeDS_items_2</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_902\">HalfedgeDS_vector</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>.h&gt;\n#include &lt;cstddef&gt;\n\n// Define a new halfedge class. We assume that the Halfedge_handle can\n// be created from a pointer (e.g. the <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A> is based here on the\n// <A HREF=\"../STL_Extension_ref/Class_In_place_list.html#Cross_link_anchor_1434\">In_place_list</A> or a std::vector with such property) and that halfedges\n// are allocated in pairs. We encode the <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> pointer in a single bit,\n// which is stored in the lower bit of the next-pointer. We use the \n// static member function HDS::halfedge_handle to translate pointer to \n// handles.\ntemplate &lt;class Refs&gt;\nclass My_halfedge {\npublic:\n    typedef Refs                                 HDS;\n    typedef My_halfedge&lt;Refs&gt;                    Base_base;\n    typedef My_halfedge&lt;Refs&gt;                    Base;\n    typedef My_halfedge&lt;Refs&gt;                    Self;\n    typedef <A HREF=\"../Kernel_23_ref/Class_Tag_false.html#Cross_link_anchor_475\">CGAL::Tag_false</A>                      Supports_halfedge_prev;\n    typedef <A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A>                       Supports_halfedge_vertex;\n    typedef <A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A>                       Supports_halfedge_face;\n    typedef typename Refs::Vertex_handle         Vertex_handle;\n    typedef typename Refs::Vertex_const_handle   Vertex_const_handle;\n    typedef typename Refs::Halfedge              Halfedge;\n    typedef typename Refs::Halfedge_handle       Halfedge_handle;\n    typedef typename Refs::Halfedge_const_handle Halfedge_const_handle;\n    typedef typename Refs::Face_handle           Face_handle;\n    typedef typename Refs::Face_const_handle     Face_const_handle;\nprivate:\n    std::ptrdiff_t  nxt;\npublic:\n    My_halfedge() : nxt(0), f( Face_handle()) {}\n\n    Halfedge_handle <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>() {\n        // Halfedge could be different from My_halfedge (e.g. pointer for \n        // linked list). Get proper handle from 'this' pointer first, do \n        // pointer arithmetic, then convert pointer back to handle again.\n        Halfedge_handle h = HDS::halfedge_handle(this); // proper handle\n        if ( nxt &amp; 1)\n            return HDS::halfedge_handle( &amp;* h + 1);\n        return HDS::halfedge_handle( &amp;* h - 1);\n    }\n    Halfedge_const_handle <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>() const { // same as above\n        Halfedge_const_handle h = HDS::halfedge_handle(this); // proper handle\n        if ( nxt &amp; 1)\n            return HDS::halfedge_handle( &amp;* h + 1);\n        return HDS::halfedge_handle( &amp;* h - 1);\n    }\n    Halfedge_handle next() {\n        return HDS::halfedge_handle((Halfedge*)(nxt &amp; (~ std::ptrdiff_t(1))));\n    }\n    Halfedge_const_handle next() const {\n        return HDS::halfedge_handle((const Halfedge*)\n                                    (nxt &amp; (~ std::ptrdiff_t(1))));\n    }\n    void  set_opposite( Halfedge_handle h) {\n        CGAL_precondition(( &amp;* h - 1 == &amp;* HDS::halfedge_handle(this)) || \n                          ( &amp;* h + 1 == &amp;* HDS::halfedge_handle(this)));\n        if ( &amp;* h - 1 == &amp;* HDS::halfedge_handle(this))\n            nxt |= 1;\n        else\n            nxt &amp;= (~ std::ptrdiff_t(1));\n    }\n    void  set_next( Halfedge_handle h) {\n        CGAL_precondition( ((std::ptrdiff_t)(&amp;*h) &amp; 1) == 0);\n        nxt = ((std::ptrdiff_t)(&amp;*h)) | (nxt &amp; 1);\n    }\nprivate:    // Support for the Vertex_handle.\n    Vertex_handle    v;\npublic:\n    // the incident vertex.\n    Vertex_handle         vertex()                     { return v; }\n    Vertex_const_handle   vertex() const               { return v; }\n    void                  set_vertex( Vertex_handle w) { v = w; }\n\nprivate:\n    Face_handle      f;\npublic:\n    Face_handle           face()                       { return f; }\n    Face_const_handle     face() const                 { return f; }\n    void                  set_face( Face_handle g)     { f = g; }\n    bool                  is_border() const { return f == Face_handle(); }\n};\n\n// Replace halfedge in the default items type.\nstruct My_items : public <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_items_2.html#Cross_link_anchor_893\">CGAL::HalfedgeDS_items_2</A> {\n    template &lt;class Refs, class Traits&gt;\n    struct Halfedge_wrapper {\n        typedef My_halfedge&lt;Refs&gt; Halfedge;\n    };\n};\n\nstruct Traits { typedef int <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>; };\n#ifndef CGAL_CFG_NO_TMPL_IN_TMPL_PARAM\n  typedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_901\">CGAL::HalfedgeDS_vector</A>     &lt;Traits, My_items&gt; HDS;\n#else\n  typedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_901\">CGAL::HalfedgeDS_vector</A>::HDS&lt;Traits, My_items&gt; HDS;\n#endif\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt;  Decorator;\n\nint main() {\n    HDS hds(1,2,2);\n    Decorator decorator(hds);\n    decorator.create_loop();\n    CGAL_assertion( decorator.is_valid());\n    return 0;\n}\n</pre>\n<P>\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<h3>29.3.6&nbsp;&nbsp;&nbsp;Example Using the Halfedge Iterator</h3>\n<P>\n\nTwo edges are created in the default halfedge data structure.\nThe halfedge iterator is used to count the halfedges.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_halfedge_iterator.C\n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_883\">HalfedgeDS_default</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>.h&gt;\n\nstruct Traits { typedef int <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>; };\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_884\">CGAL_HALFEDGEDS_DEFAULT</A>&lt;Traits&gt; HDS;\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt; Decorator;\ntypedef HDS::Halfedge_iterator          Iterator;\n\nint main() {\n    HDS hds;\n    Decorator decorator(hds);\n    decorator.create_loop();\n    decorator.create_segment();\n    CGAL_assertion( decorator.is_valid());\n    int n = 0;\n    for ( Iterator i = hds.halfedges_begin(); i != hds.halfedges_end(); ++i )\n        ++n;\n    CGAL_assertion( n == 4);  // == 2 edges\n    return 0;\n}\n</pre>\n<P>\n\n<h3>29.3.7&nbsp;&nbsp;&nbsp;Example for an Adapter to Build an Edge Iterator</h3>\n<P>\n\nThree edges are created in the default halfedge data structure.\nThe adapter <I><A HREF=\"../STL_Extension_ref/Class_N_step_adaptor.html#Cross_link_anchor_1462\">N_step_adaptor</A></I> is used to declare the edge\niterator used in counting the edges.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>/hds_prog_edge_iterator.C\n\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_883\">HalfedgeDS_default</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_881\">HalfedgeDS_decorator</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../STL_Extension_ref/Class_N_step_adaptor.html#Cross_link_anchor_1462\">N_step_adaptor</A>.h&gt;\n\nstruct Traits { typedef int <A HREF=\"../Kernel_23_ref/Class_Point_2.html#Cross_link_anchor_52\">Point_2</A>; };\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_884\">CGAL_HALFEDGEDS_DEFAULT</A>&lt;Traits&gt;             HDS;\ntypedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_decorator.html#Cross_link_anchor_880\">CGAL::HalfedgeDS_decorator</A>&lt;HDS&gt;             Decorator;\ntypedef HDS::Halfedge_iterator                      Halfedge_iterator;\ntypedef <A HREF=\"../STL_Extension_ref/Class_N_step_adaptor.html#Cross_link_anchor_1461\">CGAL::N_step_adaptor</A>&lt; Halfedge_iterator, 2&gt; Iterator;\n\nint main() {\n    HDS hds;\n    Decorator decorator(hds);\n    decorator.create_loop();\n    decorator.create_segment();\n    CGAL_assertion( decorator.is_valid());\n    int n = 0;\n    for ( Iterator e = hds.halfedges_begin(); e != hds.halfedges_end(); ++e)\n        ++n;\n    CGAL_assertion( n == 2);  // == 2 edges\n    return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../HalfedgeDS_ref/Chapter_intro.html\">Halfedge Data Structure</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_29!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 39043.0}