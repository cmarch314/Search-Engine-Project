{"text": "ICS 18 A Spring 1997 Strategy and board game programming Lecture notes for April 8 1997 Board representations In order to operate any game program needs to be able to store and manipulate two kinds of objects game positions and game moves These representations need to allow the program to perform the following operations Make a given move not just when user requests but as part of search Undo a move not just for user interface needed in search Display board to user Generate a list of all possible moves Evaluate a board position Everything except displaying the board must be fast since it happens in the inner loops of the search routine Board display can be slower since it doesn t happen often The internal representation of moves should be very concise since we don t want to spend too much time generating long lists of moves and quickly decodable But very important it should also able to represent all possible moves E g for chess a typical computer move representation is to store the starting square and ending square of the piece being moved for instance the common beginning move of the king s pawn forward two squares would be represented e2e4 where e2 is the name for the initial position of the pawn and e4 is the name for its final position The piece being captured if any does not need to be stored as part of the move since it is determined by the final position In the computer these positions can be represented as 6 bit values so the whole move could be stored internally as two bytes But even though some programs are based on it this representation is not quite capable of representing all moves In castling two pieces move a king and a rook but we can handle this as a special case in which we list only the king movement More importantly if a pawn moves from the seventh rank to the eighth it can be replaced by any of four pieces queen rook knight and bishop The representation above doesn t allow us to specify which replacement is happening So when designing a move representation one should be careful to make sure that it covers all the special cases that might happen in your game The onternal representation of board can be less concise but should still not be too huge It must represent all relevant information not just all visible information but not including irrelevant information E g in chess we need to know the positions of pieces on the board the obvious visible information but we also need to know some invisible information who s on move whether either player can castle whether an en passant capture is possible and how many moves it s been since the last capture or pawn move We also need to know something about what positions have occurred in the past because of triple repetition but don t need to know the entire list of past moves Example of Multiple Representation Possibilities Chess There are many possible ways of representing even something with as clearly defined a structure as a chessboard in a computer Here are some of the methods that have been used by chess programs Representation 1 8x8 array of squares Within each square keep a value indicating which piece is present in the square e g enum empty wK wN wB wR wQ wP bK bN bR bQ bP Advantages 1 simple 2 easy to compute material scores for i i 8 i for j j 8 j score value square i j It s a little messy but not really hard to compute possible moves you can loop through the squares finding pieces of appropriate color and branch according to piece type for i i 8 i for j j 8 j switch board i j case wP if board i 1 j empty generate move to i 1 j if i 2 board i 1 j empty board i 2 j empty generate move to i 2 j if j board i 1 j 1 contains black piece generate capture of i 1 j 1 if j 7 board i 1 j 1 contains black piece generate capture of i 1 j 1 break however there are various annoying boundary conditions to check e g a pawn on rook file shouldn t try to capture to one side making this code complicated and slower than necessary Representation 2 extended array 1 x1 containing extra boundary squares containing a special boundary value added to the enum This simpifies some of the cases reduces number of conditions in the if statements above at the expense of a little space Representation 3 x88 The name of this representation comes from a trick for testing whether a square is a valid move involving the binary representation of the number 136 which in hexadecimal is x88 We give each square of the board a number a single byte of which the high 4 bits are the row and the low 4 bits are the column 112 113 114 115 116 117 118 119 96 97 98 99 1 1 1 1 2 1 3 8 81 82 83 84 85 86 87 64 65 66 67 68 69 7 71 48 49 5 51 52 53 54 55 32 33 34 35 36 37 38 39 16 17 18 19 2 21 22 23 1 2 3 4 5 6 7 Then the square left of i is i 1 right is i 1 up is i 16 down is i 16 etc Then represent the board as an array of 128 squares of which 64 correspond to actual squares on the board The advantages of this representation are 1 it speeds up the program a little by using only one index instead of two in the array references and 2 you can test really quickly and easily whether a move stays on the board i is a legal board position if and only if i x88 Work it out moving off the board either overflows the column giving i x 8 nonzero or overflows the row giving i x8 nonzero This is a pretty commonly used technique Representation 4 bitboards I ll go into this in a lot more length than the other representations because it s probably more unfamiliar but I think it s also likely to work better Instead of having an array of squares each containing a piece types have an array of piece types each of which stores a packed array of bits listing the squares containing that piece Since there are 64 possible squares each of these packed arrays can be stored in a 64 bit number two 32 bit words The big advantage is that you can perform certain evaluation and move generation operations very quickly using bitwise Boolean operations Think of it as a way of getting your computer to do massively parallel computations by packing things into long words For example in the following position The bitboard for the white pawns call this 64 bit value wP would consist of the bits 1 1 1 1 1 1 1 Then the bitboard squares occupied by black can be computed by a formula bOcc bP bN bB bR bQ bK where bP etc are bitboards for the different kinds of black pieces Similarly we can compute the white occupied squares and or these two bitboards together to get all occupied squares The bitboard of possible white pawn one square move destinations can then be computed by a formula single pawn moves wP 8 occupied Let s look at this in slow motion Shifting wP by 8 produces a bitboard of positions one place in front of each pawn 1 1 1 1 1 1 1 The negation of occupied gives a bitboard of empty squares 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 The bitwise and of these two bitboards then gives the positions in front of a pawn that are not already occupied 1 1 1 1 Similarly you can find two square pawn moves by taking the bitboard of one square moves shifting it another 8 bits anding it with the non occupied squares again and anding it with a constant bitboard shown below of the squares on the fourth row the only row onto which pawns are allowed to move two squares 1 1 1 1 1 1 1 1 Note that this constant bitboard can be generated at compile time rather than each time we want to generate moves Pawn captures are similar shift by seven or nine and with a constant to eliminate captures off the left and right side of the board and with bOcc The point of this technique is not that your code is simpler when you program with bitboards it s a little more complicated but that you generate the pawn moves all at once rather than one at a time Also a lot of the intermediate expressions you need such as bOcc get used over and over and only need to be computed once So bitboards end up being very efficient and I think would be even better for games other than chess in which there are fewer types of pieces One complication arises it s often important to count the number of nonzero bits in a bitboard or to find a nonzero bit e g to turn the bitboard of possible pawn moves into an explicit list of moves Counting can be done one byte at a time looking up in a 256 entry table the number of nonzero bits in each byte There s a cute trick for finding a single nonzero bit x x 1 where the uparrow is C notation for exclusive or gives a binary number 111 where the first one of x x 1 is the last nonzero bit of x If you need to turn this into an actual bit take the result modulo some carefully chosen number M for which the numbers 111 are all different mod M and look the result up in a table As a simple example the following code finds the index of the last nonzero bit of a byte int T 1 7 1 3 1 6 2 5 4 1 1 int last bit unsigned char b return T b b 1 11 How to Undo Remember we said our board representation needed to handle undo operations There are two possible methods 1 Keep a stack in which each stack item holds a whole board representation to make a move push it on the stack and to undo a move pop the stack Probably this is too slow 2 Keep a stack storing only the move itself together with enough extra information to undo the move and restore all the information in the board position E g in chess you would need to store the identity of a captured piece if any and enough information to restore castling and en passant capturing privileges Repetition Detection Some games e g Go Chess have special rules about what happens when the same position is repeated in chess third repetition of a position gives the player making the repetition the right to declare a draw How to tell Short answer make a hash function translating the position to a reasonably large number we ll talk more about this later because this is also very important for speeding up the search Then keep a list of the hash codes for previous game positions and test if your position shows up in it Typical hash function make 64 13 table of large random numbers when piece x is on position y look up table x y and add it to hash ignoring overflow Zobrist Note that when making a move of a piece y from positions x to z you can update the hash very quickly just subtract table x y and add table z y David Eppstein Dept Information Computer Science UC Irvine ", "_id": "http://www.ics.uci.edu/~eppstein/180a/970408.html", "title": "\nics 180, april 8, 1997", "html": "<HTML>\n<HEAD>\n<TITLE>\nICS 180, April 8, 1997</TITLE>\n<META name=\"Owner\" value=\"eppstein\">\n<META name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</HEAD><BODY>\n<IMG SRC=\"icslogo2.gif\" WIDTH=472 HEIGHT=72 ALT=\"\"><P>\n<A HREF=\"index.html\">\n<H1>ICS 180A, Spring 1997:<BR>\nStrategy and board game programming</H1></A>\n\n<H2>Lecture notes for April 8, 1997<BR>\nBoard representations</H2>\n\nIn order to operate, any\ngame program needs to be able to store and manipulate two kinds of objects: \ngame positions, and game moves. These representations need to allow the \nprogram to perform the following operations:\n<UL>\n<LI>Make a given move (not just when user requests, but as part of search)\n<LI>Undo a move (not just for user interface, needed in search)\n<LI>Display board to user\n<LI>Generate a list of all possible moves\n<LI>Evaluate a board position\n</UL>\nEverything except displaying the board must be fast since it happens in the \ninner loops of the search routine.\n(Board display can be slower since it doesn't happen often.)\n\n<P>The internal representation of moves should be very concise (since \nwe don't want to spend too much time generating long lists of moves) and quickly \ndecodable.  But (very important) it should also able to represent all \npossible moves!  E.g.  for chess, a typical computer move representation is \nto store the starting square and ending square of the piece being moved; \nfor instance the common beginning move of the king's pawn forward two \nsquares would be represented \"e2e4\" where e2 is the name for the initial \nposition of the pawn and e4 is the name for its final position.  The piece \nbeing captured (if any) does not need to be stored as part of the move \nsince it is determined by the final position.  In the \ncomputer, these positions can be represented as 6-bit values, so the whole \nmove could be stored internally as two bytes.  But (even though some \nprograms are based on it) this representation is not quite capable of \nrepresenting all moves!  In castling, two pieces move, a king and a rook, but we can handle \nthis as a special case in which we list only the king movement. More \nimportantly, if a pawn moves from the seventh rank to the eighth, it can be \nreplaced by any of four pieces: queen, rook, knight, and bishop. The \nrepresentation above doesn't allow us to specify which replacement is \nhappening. So when designing a move representation, one should be careful \nto make sure that it covers all the special cases that might happen in \nyour game.\n\n<P>The onternal representation of board can be less concise but should still not \nbe too huge.  It must represent all relevant information, not just all \nvisible information, but not including irrelevant information.  E.g.  in \nchess, we need to know the positions of pieces on the board (the obvious \nvisible information), but we also need to know some invisible information: \nwho's on move, whether either player can castle, whether an en passant \ncapture is possible, and how many moves it's been since the last capture or \npawn move.  We also need to know something about what positions have \noccurred in the past (because of triple repetition) but don't need to know \nthe entire list of past moves.\n\n<H3>Example of  Multiple Representation Possibilities: Chess</H3>\n\nThere are many possible ways of representing even something with as \nclearly defined a structure as a chessboard in a computer.  Here are some \nof the methods that have been used by chess programs.\n\n<P><B>Representation 1: 8x8 array of squares</B>.\nWithin each square, keep a value indicating which piece is present in the \nsquare\n(e.g. enum { empty, wK, wN, wB, wR, wQ, wP, bK, bN, bR, bQ, bP }).  \nAdvantages: (1) simple. (2) easy to compute material scores:\n<PRE>\n    for  (i=0;i&lt;8;i++)\n        for(j=0;j&lt;8;j++)\n            score += value[square[i,j]];\n</PRE>\nIt's a little messy but not really hard to compute possible moves; you can loop through the \nsquares finding pieces of appropriate color and branch according to piece \ntype:\n<PRE>\n    for  (i=0;i&lt;8;i++)\n        for(j=0;j&lt;8;j++)\n            switch (board[i,j]) {\n            case wP:\n                if (board[i+1,j] empty) generate move to (i+1,j)\n                if (i==2 &amp;&amp; board[i+1,j] empty &amp;&amp; board[i+2,j] empty)\n                    generate move to (i+2,j)\n                if (j &gt; 0 &amp;&amp; board[i+1,j-1] contains black piece)\n                    generate capture of (i+1,j-1)\n                if (j &lt; 7 &amp;&amp; board[i+1,j+1] contains black piece)\n                    generate capture of (i+1,j+1)\n                break;\n            ...\n            }\n</PRE>\nhowever there are various annoying boundary conditions to \ncheck (e.g. a pawn on rook-file shouldn't try to capture to one side) making \nthis code complicated and slower than necessary.\n\n<P><B>Representation 2: extended array</B>. 10x10, containing extra boundary squares \ncontaining a special \"boundary\" value added to the enum.  This simpifies \nsome of the cases (reduces number of conditions in the if-statements above) \nat the expense of a little space.\n\n<P><B>Representation 3: 0x88</B>.  The name of this representation comes \nfrom a trick for testing whether a square is a valid move involving the \nbinary representation of the number 136 (which in hexadecimal is 0x88).\nWe give each square of the board a number (a single byte), of \nwhich the high 4 bits are the row and the low 4 bits are the column:\n<PRE>\n    112 113 114 115 116 117 118 119\n    96  97  98  99  100 101 102 103\n    80  81  82  83  84  85  86  87\n    64  65  66  67  68  69  70  71\n    48  49  50  51  52  53  54  55\n    32  33  34  35  36  37  38  39\n    16  17  18  19  20  21  22  23\n    0   1   2   3   4   5   6   7\n</PRE>\nThen the square left of i is i-1, right is i+1, up is i+16, down is i-16 \netc.  Then represent the board as an \narray of 128 squares (of which 64 correspond to actual squares on the \nboard).  The advantages of this representation are (1) it speeds up the \nprogram a little by using only one index instead of two in the array \nreferences, and (2) you can test really \nquickly and easily whether a move stays on the board: i is a legal board position if \nand only if (i&amp;0x88)==0.  [Work it out, moving off the board either \noverflows the column giving i&amp;0x08 nonzero, or overflows the row giving \ni&0x80 nonzero.]  This is a pretty commonly used technique.\n\n<P><B>Representation 4: bitboards</B>.  I'll go into this in a lot more \nlength than the other representations because it's probably more \nunfamiliar, but I think it's also likely to work better.  Instead of having \nan array of squares, each containing a piece types, have an array of piece \ntypes, each of which stores a packed array of bits listing the squares \ncontaining that piece.  Since there are 64 possible squares, each of these \npacked arrays can be stored in a 64-bit number (two 32-bit words).  The big \nadvantage is that you can perform certain evaluation and move generation \noperations very quickly using bitwise Boolean operations.  Think of it as a \nway of getting your computer to do massively parallel computations by \npacking things into long words.  For example, in the following position:\n\n<P><CENTER><IMG SRC=\"970408.gif\"></CENTER>\n\n<P>The bitboard for the white pawns (call this 64-bit value \"wP\") would \nconsist of the bits\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 1 0 0 0\n    0 0 0 0 0 0 0 0\n    1 1 1 0 0 0 0 1\n    0 0 0 0 0 0 0 0\n</PRE>\nThen the bitboard squares occupied by black can be computed by a formula\n<PRE>\n    bOcc = bP | bN | bB | bR | bQ | bK\n</PRE>\n(where bP etc are bitboards for the different kinds of black pieces).\nSimilarly we can compute the white occupied squares, and or these two \nbitboards together to get all occupied squares.\nThe bitboard of possible white pawn one-square move destinations can then \nbe computed by a formula:\n<PRE>\n    single_pawn_moves = (wP &lt;&lt; 8) &amp; ~occupied\n</PRE>\nLet's look at this in slow motion.\nShifting wP by 8 produces a bitboard of positions one place in front of \neach pawn:\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 1 0 0 0\n    0 0 0 0 0 0 0 0\n    1 1 1 0 0 0 0 1\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n</PRE>\nThe negation of occupied gives a bitboard of empty squares:\n<PRE>\n    0 0 1 1 0 0 1 0\n    1 0 1 0 1 0 0 0\n    1 1 1 0 0 0 1 1\n    1 0 1 1 1 0 1 1\n    1 0 1 1 0 1 1 1\n    1 0 1 1 1 0 1 1\n    0 0 0 1 1 1 1 0\n    0 1 0 1 0 0 1 0\n</PRE>\nThe bitwise and of these two bitboards then gives the positions in front \nof a pawn, that are not already occupied:\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 1 0 0 0\n    0 0 0 0 0 0 0 0\n    1 0 1 0 0 0 0 1\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n</PRE>\nSimilarly you can find two-square pawn moves by taking the bitboard of \none-square moves, shifting it another 8 bits, anding it with the \nnon-occupied squares again, and anding it with a constant bitboard (shown \nbelow) of the \nsquares on the fourth row (the only row onto which pawns are allowed to \nmove two squares):\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    1 1 1 1 1 1 1 1\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n</PRE>\nNote that this constant bitboard can be generated at compile time rather \nthan each time we want to generate moves.\nPawn captures are similar (shift by seven or nine, and with a constant to \neliminate captures off the left and right side of the board, and with bOcc).\n\n<P>The point of this technique is not that your code is simpler when you \nprogram with bitboards (it's a little more complicated) but that you \ngenerate the pawn moves all at once rather than one at a time.  Also, a lot \nof the intermediate expressions you need (such as bOcc) get used over and \nover, and only need to be computed once. So bitboards end up being very \nefficient, and I think would be even better for games other than chess in \nwhich there are fewer types of pieces.\n\n<P>One complication arises: it's often important to count the number of \nnonzero bits in a bitboard, or to find a nonzero bit (e.g. to turn the \nbitboard of possible pawn moves into an explicit list of moves).\nCounting can be done one byte at a time, looking up in a 256-entry table \nthe number of nonzero bits in each byte. There's a cute trick for finding \na single nonzero bit: x^(x-1) (where the uparrow is C notation for \nexclusive or) gives a binary number \n...000111... where the first one of x^(x-1) is the last nonzero bit of  x.  If you need to \nturn this into an actual bit, take the result modulo some carefully chosen \nnumber M (for which the numbers ...000111... are all different mod M), and \nlook the result up in a table.  As a simple example, the following code \nfinds the index of the last nonzero bit of a byte:\n<PRE>\n    int T = { -1, 0, 7, 1, 3, -1, 6, 2, 5, 4, -1, -1 };\n    int last_bit(unsigned char b) { return T[(b^(b-1)) % 11]; }\n</PRE>\n\n<H3>How to Undo?</H3>\n\nRemember we said our board representation needed to handle undo operations.\nThere are\ntwo possible methods: (1) Keep a stack in which each stack item holds a \nwhole board representation; to make a move push it on the stack and to undo \na move pop the stack. Probably this is too slow...\n(2) Keep a stack storing only the move itself together with enough extra \ninformation to undo the move and restore all the information in the board \nposition.  E.g. in chess you would need to store the identity of a \ncaptured piece (if any) and enough information to restore castling \nand en passant capturing privileges.\n\n<H3>Repetition Detection</H3>\n\nSome games e.g. Go, Chess have special rules about what happens when the \nsame position is repeated (in chess, third repetition of a position gives \nthe player making the repetition the right to declare a draw).  How to \ntell?  Short answer: make a hash function translating the position to a \nreasonably large number (we'll talk more about this later because this is \nalso very important for speeding up the search). Then keep a list of the \nhash codes for previous game positions and test if your position shows up \nin it.  Typical hash function: make 64*13 table of  large random numbers; \nwhen piece x is on position y, look up table[x,y] and add it to hash \nignoring overflow [Zobrist].  Note that, when making a move of a piece y\nfrom positions x to z, you can update the hash very quickly:\njust subtract table[x,y] and add table[z,y].\n\n<HR>\n<A HREF=\"/~eppstein/\">David Eppstein,\n<A HREF=\"/\">Dept. Information & Computer Science</A>,\n<A HREF=\"http://www.uci.edu/\">UC Irvine</A>,\n<!--#flastmod file=\"970408.html\" -->.\n</BODY></HTML>\n", "id": 10566.0}