{"text": "Program 1 Programming using Generic Collection Classes List Stack Queue Priority Queue Set and Map Fundamental Data Structures ICS 23 Introduction This programming assignment is designed to ensure that you know how to use combinations of generic collection classes aka data types to model and compactly write code that solves a wide variety of different programming problems The kind of abstract thinking that goes into modeling solutions to these programming problems with collection classes is critical to your development as computer scientists For this reason collection classes are important and useful themselves and we will use our upcoming advanced knowledge of data structures to improve the performance of programs that are written to use these collection classes the implementations I supply are all correct to my knowledge but are slow You will also get some experience reading files and scanning the lines you read There are five parts to this assignment you always need to write a main method in each sometimes you will be asked to write static helper methods you may write any other helper methods if you find any useful But you may not change any of the collection classes that I supply Please note that the Collections class notice it is plural there also is a much different Collection interface contains various static methods to process collection classes most import for this assignment is the sort method Each part of this assignment will have its own download a project file with with the begining of a java file and related data files in it These files included the imports that I used in my solution you may import other interfaces and classes as well if you find any useful You will submit one java file that solves each problem As a warmup you should download a project that solves the Voting Problem The code it contains is similar to the code that you will write for this assignment You should study this code carefully and understand how it works then leverage off this code when you write solutions to the five problems below especially related to reading files from data Also the class index contains a link to the Javadoc of Collections API which discusses each of the public constructors and method IMPORTANT When we start writing our own collection classes you will need to use Build Path to add the collections jar file to each project that you work on NOT add it to the library Although either method will work for this assignment which just uses the already written implementations I suggest you ensure you know how to use Build Path to get the job done Again for you home machine I suggest that you put this file into the workspace and access it from there You should work on this assignment in pairs with someone in your lab section Try to find someone who lives near you with a similar work schedule e g talk about whether you like to work morning nights weekends If you cannot work with someone because of some special reason s you should send me email stating them Only one student should submit the assignment but both student s names should appear in the comments at the top of each submitted java file Please turn in each program as you finish it so that I can accurately assess the progress of the class as a whole during this assignment Print this document and carefully read it marking any parts that contain important detailed information that you find for review before you turn in the files Note especially the last two sections on Extra Credit and Time Management These important sections are relevant to all programming assignments but appear only in this one The allocation of the 6 points this entire programming assignment is worth will be 1 is worth 15 pts 2 is worth 15 pts 3 is worth 15 pts 4 is worth 1 pts 5 is worth 5 pts Note that you cannot get extra credit points for submitting this assignment early unless you have correctly solved and submitted at least problems 1 4 Problem 1 Download the Reverse project folder The main method in my solution contains 19 non blank lines of code the printGraph and reverse methods contains 7 and 15 non blank lines respectively Note that there are multiple data files for this program test them all Draw the graph for each and ensure that your code correctly prints it and reverses it Problem Statement Including Input and Output First read a file of pairs of node names representing edges in a directed graph building a Map whose key is the label of the source node and whose value is a Set of the destination nodes reachable from that source node We write this informally as Map String Set String Two nodes appear on each line first the source node then the destination node with these words separated by one semicolon character For example the input file graph1 txt contains the following lines which could appear in any order c f b d a c c e d g a b e d f g f d which represent the graph Second write a method named printGraph that prints all these edges one source node per line sorted alphabetically followed by the set of all the destination nodes that it can immediately reach The graph above would print as Graph source destination edges a ArraySet 2 2 c 1 b b ArraySet 1 1 d c ArraySet 2 2 f 1 e d ArraySet 1 1 g e ArraySet 1 1 d f ArraySet 2 2 g 1 d Note that the source nodes are SORTED alphabetically but the set of desintation nodes does NOT have to be SORTED you can print the Set using a toString method explicitly or implicitly Also because node g is not a source node it is only a destination node it does not appear first on any line Third write a method named reverse that takes one graph as an argument and returns a result that is a new graph that contains all edges from the argument graph reversed e g if the first graph has an edge from source ato detination b a b then the second one has an edge from source b to destination a b a Call printGraph to pint all these edges again one source node per line and all its edges sorted alphabetically by source node with no sorting for the destination nodes My main method reads the graph and then the last two lines in my code are printGraph graphMap Graph source destination edges printGraph reverse graphMap Reverse Graph source destination edges Where the second argument to the printGraph method is a String labelling the graph being printed Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one You should also check that it works for the other graphs Enter name of file with graph graph1 txt Graph source destination edges a ArraySet 2 2 c 1 b b ArraySet 1 1 d c ArraySet 2 2 f 1 e d ArraySet 1 1 g e ArraySet 1 1 d f ArraySet 2 2 g 1 d Reverse Graph source destination edges b ArraySet 1 1 a c ArraySet 1 1 a d ArraySet 3 4 b 1 e 2 f e ArraySet 1 1 c f ArraySet 1 1 c g ArraySet 2 2 d 1 f The reverse graph would be written as Because node a is not a source node in the reversed graph it does not appear first on any line Problem 2 Download the Reachability project folder The main method in my solution contains 19 non blank lines of code mostly to read in the graph the reachable method contains 15 non blank lines the printGraph method 7 non blank lines comes from the solution to the previous problem Note that there are multiple data files for this program test them all Draw the graph for each and ensure that your code correctly prints it and computes the nodes reachable from any source node These are the same files as for Problem 1 if you drew out the graphs there use them for this problem if you didn t draw them out now Problem Statement Including Input and Output First repeat what you did in Problem 2 read a file of pairs of node names representing edges in a directed graph building a Map whose key is the label of the source node and whose value is a Set of the destination nodes reachable from that source node We write this informally as Map String Set String Two nodes appear on each line first the source node then the destination node with these words separated by one semicolon character For example the input file graph1 txt contains the following lines c f b d a c c e d g a b e d f g f d Second call the printGraph method to prints all these edges one source node per line sorted alphabetically followed by the Set of all the destination nodes that it can immediately reach The graph above would print as Graph source destination edges a ArraySet 2 2 c 1 b b ArraySet 1 1 d c ArraySet 2 2 f 1 e d ArraySet 1 1 g e ArraySet 1 1 d f ArraySet 2 2 g 1 d Note that the source nodes are SORTED alphabetically but the set of desintation nodes does NOT have to be SORTED you can print the Set using a toString method explicitly or implicitly Also because node g is not a source node it is only a destination node it does not appear first on any line Third write a method named reachable that takes two parameters the first is a graph and the second is one label of a node in that graph this method returns a Set of that label and all the labels of nodes reachable from that one by following the edges arrows any number of times Here is the basic algorithm for reachability which is simple to explain and not very complicated to implement by using collection classes You should try to hand simulate it at a high level assuming the Set and Queue collections work correctly independent of how they are implemented Use this method instead of recursion unless recursion is done very carefully it will run forever on graphs with cycles one of the input files is a graph with cycles To search the graph for all the reachable nodes build a Set of reachable nodes and a Queue of nodes to search from initializing the Queue with the node supplied as a parameter to reachable While the Queue still has nodes remove one put it into the Set of reachable nodes and for all its destination nodes THAT ARE NOT ALREADY in the Set put them in the Queue When the Queue finally becomes empty can you prove this always happens there is no infinite looping return the Set of all the labels of nodes that are reachable Print the set containing all these node labels My main method reads the graph and then the last two lines in my code are just String start Prompt forString nEnter node to start from System out println Node s reachable from start reachable graphMap start Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one You should also check that it works for other starting nodes and a variety of starting nodes in the other graphs Enter name of file with graph graph1 txt Graph source destination edges a ArraySet 2 2 c 1 b b ArraySet 1 1 d c ArraySet 2 2 f 1 e d ArraySet 1 1 g e ArraySet 1 1 d f ArraySet 2 2 g 1 d Enter node to start from c Node s reachable from c ArraySet 5 8 c 1 f 2 e 3 g 4 d Problem 3 Download the Finite Automaton project folder The main method in my solution contains 35 non blank lines of code Your program will simulate a machine called a finite automaton FA sometimes this is also called a Deterministic Finite Automaton DFA An FA is described by its states and its transitions each transition specifies an input and what state that input leads to You will read the description of some arbitrary FA first then you will simulate that FA starting in a specific state and running on a specific input Problem Statement Including Input and Output First process a file that describes a FA Create a Map whose keys are states and whose values are another Map of the transitions from that state whose keys are inputs and whose values are states Each line of the file contains a state and a description of its transitions The first token is the state a String and the remaining tokens always coming in pairs are inputs and states Each transition Map for a state has a key that is an input a String and a value that is a state a String All tokens are separated by one semicolon character We write this informally as Map String Map String String For example the file parity txt contains the following lines even even 1 odd odd odd 1 even Here is a picture of the parity FA It graphically illustrates the two states even and odd and their transitions using inputs and 1 that always lead back to one of these two states Here the state even meaning it has seen an even number of 1 inputs so far is a key in the main Map It s value is a Map with two key value pairs even and 1 odd It means that in the even state if the input is a the FA stays in the even state if the input is a 1 the FA goes to the odd state And similarly the next line means that in the odd state if the input is a the FA stays in the odd state if the input is a 1 the FA goes back to the even state Second print a sorted version of the main Map the states for any FA no matter how many states it has must be printed in alphabetical order one state per line each followed by its associated Map of transitions The information in the transition Maps does not have to be in alphabetical order you can print the Map using a toString method explicitly or implicitly For example the file above would produce Finite Automaton even transitions ArrayMap 2 2 even 1 1 odd odd transitions ArrayMap 2 2 odd 1 1 even Third process a one line file that contains an initial state followed by a sequence of inputs The initial state will be a state in the FA are in the outer map and all inputs specify legal transitions are in the inner maps For example the input file inputparity txt contains the following line even 1 1 1 1 This means starting in the initial state even it processes the inputs 1 1 1 and 1 Print the initial state and then each input and the new state it transitions to and finally print the final state For the parity FA and this file it prints Initial state even input 1 new state odd input new state odd input 1 new state even input 1 new state odd input new state odd input 1 new state even Final state even Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one Enter Finite Automaton Description File parity txt Finite Automaton even transitions ArrayMap 2 2 even 1 1 odd odd transitions ArrayMap 2 2 odd 1 1 even Enter start state inputs file inputparity txt Initial state even input 1 new state odd input new state odd input 1 new state even input 1 new state odd input new state odd input 1 new state even Final state even Problem 4 Download the Non Determinisitic Finite Automaton project folder The main method in my solution contains 46 non blank lines of code Generally you can update a clean solution to Problem 3 to get a clean solution to this problem making key changes related to the differences created by non determinism Your program will simulate a machine called a non deterministic finite automaton NDFA contrast this with the Deterministic Finite Automaton in Problem 3 A NDFA is described by its states and its transitions each transition specifies an input and what state or states that what makes it non deterministic that input leads to You will read the description of some arbitrary NDFA first then you will simulate that NDFA starting in a specific state and running on a specific input Problem Statement Including Input and Output First process a file that describes a NDFA Create a Map whose keys are states and whose values are another Map of the transitions from that state whose keys are inputs and whose values are a Set of states Each line of the file contains a state and a description of its transitions The first token is the state a String and the remaining tokens always coming in pairs are inputs and states Each transition Map for a state has a key that is an input a String and a value that is a Set of states each state is a String All tokens are separated by one semicolon character We write this informally as Map String Map String Set String Compare this to the previous description for a deterministic finite automata Map String Map String String For example the file endin 1 txt contains the following lines start start 1 start near near 1 end end Here is a picture of the endin 1 NDFA It graphically illustrates the three states start near and end and their transitions using inputs and 1 Here the state start is a key in the main Map It s value is a Map with two key value pairs mapping to the Set containing start and near and 1 mapping to the the Set containing just start It means that in the start state if the input is a the NDFA can stay in the start state or it can go to the near state if the input is a 1 the NSFA must stay in the start state And similarly the next line means that in the near state if the input is a 1 the NDFA must go into the end state The last line means that the end state has no transitions Second print a sorted version of the main Map the states for any NDFA no matter how many states it has must be printed in alphabetical order one state per line each followed by its associated Map of transitions The information in the transition Maps does not have to be in alphabetical order print them the simplest way you can in Java since the order is not important Note that the state end is a key in the main Map whose associated transitions are an empty Map For example the file above would produce Non Deterministic Finite Automaton end transitions ArrayMap 1 near transitions ArrayMap 1 1 1 ArraySet 1 1 end start transitions ArrayMap 2 2 ArraySet 2 2 start 1 near 1 1 ArraySet 1 1 start Third process a one line file that contains an initial state followed by a sequence of inputs The initial state will be in the NDFA in the outer map and all inputs specify legal transitions in the inner maps For example the input file inputendin 1 txt contains the following line start 1 1 1 1 Starting in the initial state start it processes the inputs 1 1 1 and 1 Print the initial state and then each input and the new state s it transitions to and finally print the final state For the endin 1 NDFA and this file it prints Initial state s ArraySet 1 1 start input 1 new possible states ArraySet 1 1 start input new possible states ArraySet 2 2 start 1 near input 1 new possible states ArraySet 2 2 start 1 end input 1 new possible states ArraySet 1 1 start input new possible states ArraySet 2 2 start 1 near input 1 new possible states ArraySet 2 2 start 1 end Final possible state s ArraySet 2 2 start 1 end Note especially that in the start state if the input is a then the NDFA can either remain in the start state or go into the near state For this program we keep tracek of all states that the NDFA can be in using a Set of new possible states For the next input 1 we can be either in the start state from the start state an input of 1 allows us to stay in the start state or the end state from the near state an input of 1 allows us to transition to the end state Thus we keep track of the Set of states the NDFA can be in and the new Set of states the NDFA can be in after processing the next input Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one Enter Non Deterministic Finite Automaton Description File endin 1 txt Non Deterministic Finite Automaton end transitions ArrayMap 1 near transitions ArrayMap 1 1 1 ArraySet 1 1 end start transitions ArrayMap 2 2 ArraySet 2 2 start 1 near 1 1 ArraySet 1 1 start Enter start state inputs file inputendin 1 txt Initial state s ArraySet 1 1 start input 1 new possible states ArraySet 1 1 start input new possible states ArraySet 2 2 start 1 near input 1 new possible states ArraySet 2 2 start 1 end input 1 new possible states ArraySet 1 1 start input new possible states ArraySet 2 2 start 1 near input 1 new possible states ArraySet 2 2 start 1 end Final possible state s ArraySet 2 2 start 1 end Problem 5 Download the Word Generator project folder The main method in my solution contains 64 non blank lines of code my anonymous class implementing the Comparator interface was 9 non blank lines and the randomWord method is 2 non blank lines Your program will learn the word pattern of an author based on some order statistic and then generate random text following the author s word pattern Problem Statement Including Input and Output First prompt the user for the order statistic n 1 2 3 etc For initial testing I suggest using an order statistic of 2 when you think your program is correct try 3 or 4 Second read a file of tokens building a Map storing the following data Map List Stringn List String from a List of n words n is the order statistic to a List of all the words in the text that follow these words e g if n were 2 the Map would contain a key for every pair of words appearing next to each other in the text and a value that is a List of all the words following this key no matter where the pair occurs with NO DUPLICATES allowed in the values list You can read the words one at a time in a single loop see readString in the TypedBufferReader class or call readAllTokens and use the StringTokenizer class on them using a to specify to use only a space as the token separators To build the Map start by prereading n words into the list assume that this is always possible how might it not be then read the next word and put it in as a value associated with the List of pre read words then drop the oldest word in the List and add this next word to the end of the list always keeping the list length at n read the next word and repeat the process for this word continuing until there are no words to read For a simple example the file input1 txt contains the following lines a b c b a d c b a d c a a b a a d Third print all the associations in the Map one per line in lexical order after printing all associations print the size of the smallest and largest List that is a value in the Map Each line contains n words in a List followed by the List of words that follow them in the text In lexical order the keys appear in order relative to the first word in the List for all first words that are the same they appear in order relative to the second word in the List for all first and second words that are the same they appear in order relative to the thrid word in the List etc You can put all the entries in a List and then sort the list using an object from an anonymous class implementing the Comparator to do the job its compare method finds the first different words in the two Lists there will always be at least on different word and return a result based on how these two words compare Fill in the Comparator in some call to the Collections sort method Examine the code in the Voting Problem to see how something similar is accomplished there For example the file above would produce Following ArrayList 2 2 a 1 a any of ArrayList 2 2 b 1 d Following ArrayList 2 2 a 1 b any of ArrayList 2 2 c 1 a Following ArrayList 2 2 a 1 d any of ArrayList 1 1 c Following ArrayList 2 2 b 1 a any of ArrayList 2 2 d 1 a Following ArrayList 2 2 b 1 c any of ArrayList 1 1 b Following ArrayList 2 2 c 1 a any of ArrayList 1 1 a Following ArrayList 2 2 c 1 b any of ArrayList 1 1 a Following ArrayList 2 2 d 1 c any of ArrayList 2 2 b 1 a Min List size 1 Max List size 2 So as you can see the only allowed transition from a d is c in the text above a d appears twice and it is followed each time by a c The allowed transitions from a b are c and a in the text above a b appears twice first followed by c and then by a Finally prompt the user for the number of random words to generate some number greater than the order statistic and then prompt for the n words to start with Build two lists List String both starting out with these words The first will always contain the current n words to be used as a key in the Map the second will contain all the generated words Generate a random next word from the Map add it to both lists then drop the first word from the first list so it is a list of size n again repeat until you have generated the required number of words Warning you might have to stop prematurely if you generate the last n words in the text if these words occur nowhere else That is because in this case there is no random word to generate following them Print the list A 15 element list starting with the words a and d might print as Results ArrayList 17 32 a 1 d 2 c 3 a 4 a 5 d 6 c 7 a 8 a 9 d 1 c 11 a 12 a 13 b 14 c 15 b 16 a In the result we start with a d specified by the user we know only c can come next then using d c we know that either b or a must come next it randomly chooses a Sample Interaction The program as specified will have the following interaction user typed information appears in italics Your output should match this one Enter Order Statistic 2 Enter name of sample text file input1 txt Allowed Transitions sorted Following ArrayList 2 2 a 1 a any of ArrayList 2 2 b 1 d Following ArrayList 2 2 a 1 b any of ArrayList 2 2 c 1 a Following ArrayList 2 2 a 1 d any of ArrayList 1 1 c Following ArrayList 2 2 b 1 a any of ArrayList 2 2 d 1 a Following ArrayList 2 2 b 1 c any of ArrayList 1 1 b Following ArrayList 2 2 c 1 a any of ArrayList 1 1 a Following ArrayList 2 2 c 1 b any of ArrayList 1 1 a Following ArrayList 2 2 d 1 c any of ArrayList 2 2 b 1 a Min List size 1 Max List size 2 Enter of words to generate 15 Enter prefix word a Enter prefix word 1 d Results ArrayList 17 32 a 1 d 2 c 3 a 4 a 5 d 6 c 7 a 8 a 9 d 1 c 11 a 12 a 13 b 14 c 15 b 16 a You can also try reading a much larger file included in this project folder huck txt Mark Twain s The Adventures of Huckleberry Finn On my machine it took over 1 2 hour to create a Map with an order statistic of 3 It has over 9 entries in the Map the biggest key triple had an associated value with 46 entries in it The key was ArrayList 3 4 out of the and its associated value was ArrayList 46 64 window face woods fourth front jacket hole canoe middle ferryboat s cottonwood captain s river fog range presbyterian tree nest wagon troughs reach store way wigwam ark room corner grave nonesuch trouble kitchen old first hardest nigger patch sugar bowl window hole brass spoon house tooleries bag office post office cabin path chains When we re implement Map with a HashT able instead of an Array the time could go down to just a few seconds almost 2 times faster You can use this same program to read generate music or DNA sequences or any other data made of symbols Extra Credit Programming assignments must be turned in on time you can get partial credit for a partially completed assignment but it must be turned in on time I will accept no late homework unless you have an official excuse and it is best contact me as soon as the problem arises not after the due date In fact there is another incentive to finish not only on time but to finish early In all programming assignments if you turn in everything at least 24 hours before it is officialy due you will receive 2 points of extra credit If you turn it in 48 hours or earlier you will receive 3 points of extra credit There is no more extra credit for earlier turn ins I recommend NOT turning it in more than 48 hours early specifically wait until you receive your graded previous program before turning in a new one This is equivalent to one half of a full grade improvement on an 6 point programming assignment In previous quarters that I have taught almost 75 of the students completed their assignments early and received some amount of extra credit for doing so There are two main advantages to planning on finishing early First if you run into a major problem you will have extra time to solve it before the actual due date and even experienced programmers frequently run into such problems Yes this means you Second and more importantly if you are racing to finish before a deadline stress levels can go through the roof and you become less interested in learning the material and the whole purpose of these programming assignments is to ensure that you have learned the material and more interested in just getting it finished If you do not learn the material you will be at a major disadvantage for all subsequent programming assignments and tests because of the cumulative nature of the material in this course Therefore plan to finish every assignment by Tuesday or Wednesday evening most are due on Thursday evening Programming assignments sometimes also include an extra credit section worth a few extra points points These are designed for students who finish early and want to continue exploring programming within the context of the assignment The points are to acknowledge in a small way their extra effort This assignment has extra credit only for turning it in early Time Management One of the hardest parts of being in college is learning how to manage your time Time management is especially important in programming courses and in the real world when you are working on complicated projects with hard deadlines The difference between good and bad time management can have a profound impact on how much you learn in this course how well you perform in it and how much effort you actually need to expend to do well Generally it is best to spread out the work on a two week long assignment Often there are mutliple parts to the assignment so you complete these parts in sequence Most assignments become available two days before the Lab they are assigned on During the Lab they are assigned on we will overview the assignment and you can start working on one aspect of it then as well Some students look at an assignment and think that it is best done in one sitting If you can do so great but if you plan to work this way do the one sitting soon after it is assigned not the night before it is due In this way if you are wrong about the amount of time that it will take you will still have adequate time to complete the assignment I know everyone has lots of constraints on their schedules but the programming assignments should be doable in two weeks By meeting these time goals you will both maximize what you learn and minimize your anxiety and the time that it takes for you to do the learning Remember that assignments must be turned in on time you can get partial credit for a partially completed assignment but it must be turned in on time I will not accept any late homework unless you have an official excuse Finally if you find yourself falling behind seek help immediately from me the TAs or even other students in the course when appropriate ", "_id": "http://www.ics.uci.edu/~pattis/ICS-23/assignments/program1/program.html", "title": "program 1", "html": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 1</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 1</h1>\r\n<h1>\r\nProgramming using Generic Collection Classes:<br>\r\nList, Stack, Queue, Priority Queue, Set, and Map \r\n</h1>\r\n<p>\r\n<h2>Fundamental Data Structures<br>\r\nICS-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to use\r\n  combinations of generic collection classes (aka data types) to model and\r\n  compactly write code that solves a wide variety of different programming \r\n  problems.\r\nThe kind of abstract thinking that goes into modeling solutions to these\r\n  programming problems with collection classes is critical to your development\r\n  as computer scientists.\r\nFor this reason, collection classes are important and useful themselves, and\r\n  we will use our upcoming advanced knowledge of data structures to improve\r\n  the performance of programs that are written to use these collection\r\n  classes (the implementations I supply are all correct -to my knowledge- but\r\n  are slow).\r\nYou will also get some experience reading files and scanning the lines you\r\n  read.\r\n<p>\r\nThere are five parts to this assignment; you always need to write a <b>main</b>\r\n  method in each; sometimes you will be asked to write <b>static</b> helper\r\n  methods; you may write any other helper methods if you find any useful.\r\nBut, you may not change any of the collection classes that I supply.\r\n<p>\r\nPlease note that the <b>Collections</b> class (notice it is plural, there also\r\n  is a much different <b>Collection</b> interface) contains various\r\n  <b>static</b> methods to process collection classes: most import for this\r\n  assignment is the <b>sort</b> method.\r\n<p>\r\nEach part of this assignment will have its own download: a project file with\r\n  with the begining of a <b>.java</b> file and related data files in it.\r\nThese files included the imports that I used in my solution; you may import\r\n  other interfaces and classes as well if you find any useful).\r\nYou will submit one <b>.java</b> file that solves each problem.\r\n<p>\r\nAs a warmup, you should download a project that solves the \r\n  <a href=\"voting.zip\">Voting Problem</a>.\r\nThe code it contains is similar to the code that you will write for\r\n  this assignment.\r\nYou should <b>study this code carefully</b> and understand how it works; then,\r\n  leverage off this code when you write solutions to the five problems below,\r\n  especially related to reading files from data.\r\nAlso, the class index contains a link to the \"Javadoc of Collections API\" which\r\n  discusses each of the public constructors and method.\r\n<p>\r\n<b>IMPORTANT</b>: When we start writing our own collection classes you will\r\n  need to use <b>Build Path</b> to add the <b>collections.jar</b> file to each\r\n  project that you work on <b>NOT</b> add it to the library.\r\nAlthough either method will work for this assignment (which just uses the\r\n  already written implementations), I suggest you ensure you know how to\r\n  use <b>Build Path</b> to get the job done.\r\nAgain, for you home machine I suggest that you put this file into the\r\n  workspace and access it from there.\r\n<p>\r\nYou should work on this assignment in pairs, with someone in your lab section.\r\nTry to find someone who lives near you, with a similar work schedule: e.g.,\r\n  talk about whether you like to work morning, nights, weekends.\r\nIf you cannot work with someone because of some special reason(s), you should\r\n  send me email stating them.\r\n<p>\r\n<b>Only one student should submit the assignment</b>, but both student's names\r\nshould appear in the comments at the top of <b>each submitted .java</b> file.\r\nPlease turn in each program as you finish it, so that I can accurately assess\r\n  the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nNote especially, the last two sections, on <b>Extra Credit</b> and <b>Time\r\n  Management</b>.\r\nThese important sections are relevant to all programming assignments, but\r\n  appear only in this one.\r\n<p>\r\nThe allocation of the 60 points this entire programming assignment is worth\r\n  will be\r\n  #1 is worth 15 pts,\r\n  #2 is worth 15 pts,\r\n  #3 is worth 15 pts,\r\n  #4 is worth 10 pts,\r\n  #5 is worth  5 pts.\r\nNote that you cannot get extra credit points for submitting this assignment\r\n  early unless you have correctly solved and submitted at least\r\n  problems\r\n  1-4.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1</b></td>\r\n<td width =\"80%\">\r\nDownload the <a href=\"reverse.zip\">Reverse</a> project folder.\r\nThe <b>main</b> method in my solution contains 19 non-blank lines of code.\r\n  the <b>printGraph</b> and <b>reverse</b> methods contains 7 and 15\r\n  non-blank lines respectively.\r\nNote that there are multiple data files for this program; test them all.\r\nDraw the graph for each and ensure that your code correctly prints it\r\n  and reverses it.\r\n<h3>Problem Statement (Including Input and Output)</h3>\r\nFirst, read a file of pairs of node names representing edges in a directed\r\n  graph, building a <b>Map</b> whose key is the label of the source node\r\n  and whose value is a <b>Set</b> of the destination nodes reachable from\r\n  that source node.\r\nWe write this informally as <b>Map[String] -&gt; Set[String]</b>\r\n<p>\r\nTwo nodes appear on each line: first the source node, then the destination\r\n  node, with these words separated by one semicolon character.\r\nFor example, the input file <b>graph1.txt</b> contains the following\r\n  lines (which could appear in any order):\r\n<b><pre>  c;f\r\n  b;d\r\n  a;c\r\n  c;e\r\n  d;g\r\n  a;b\r\n  e;d\r\n  f;g\r\n  f;d</pre></b>\r\nwhich represent the graph\r\n<p>\r\n<image src=\"images/graph.gif\">\r\n<p>\r\nSecond, write a method named <b>printGraph</b> that prints all these edges,\r\n  one source node per line (sorted alphabetically) followed by the set of\r\n  all the destination nodes that it can immediately reach.\r\nThe graph above would print as\r\n<b><pre>  Graph: source -> {destination} edges\r\n    a -> ArraySet[2/2:[0]=c,[1]=b]\r\n    b -> ArraySet[1/1:[0]=d]\r\n    c -> ArraySet[2/2:[0]=f,[1]=e]\r\n    d -> ArraySet[1/1:[0]=g]\r\n    e -> ArraySet[1/1:[0]=d]\r\n    f -> ArraySet[2/2:[0]=g,[1]=d]</pre></b>\r\n<p>\r\nNote that the source nodes are SORTED alphabetically, but\r\n  the set of desintation nodes does NOT have to be SORTED:\r\n  you can print the <b>Set</b> using a <b>toString</b> method\r\n  (explicitly or implicitly).\r\nAlso, because node <b>g</b> is not a source node (it is only a\r\n  destination node), it does not appear first on any line.\r\n<p>\r\nThird, write a method named <b>reverse</b> that takes one graph as an argument,\r\n  and returns a result that is a new graph that contains all edges from the\r\n  argument graph reversed: e.g., if the first graph has an edge from source \r\n  <b>a</b>to detination <b>b</b> (<b>a-&gt;b</b>) then the second one has an\r\n  edge from source <b>b</b> to destination <b>a</b> (<b>b-&gt;a</b>).\r\nCall <b>printGraph</b> to pint all these edges: again, one source node per\r\n  line (and all its edges), sorted alphabetically by source node, with no\r\n  sorting for the destination nodes.\r\n<p>\r\nMy main method reads the graph, and then the last two lines in my code are\r\n<b><pre>  printGraph(graphMap, \"Graph: source -> {destination} edges\");\r\n  printGraph(reverse(graphMap), \"Reverse Graph: source -> {destination} edges\");</pre></b>\r\nWhere the second argument to the <b>printGraph</b> method is a <b>String</b>\r\n  labelling the graph being printed.\r\n<p>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one.\r\nYou should also check that it works for the other graphs.\r\n<b><pre>  Enter name of file with graph: <i>graph1.txt</i>\r\n\r\n  Graph: source -> {destination} edges\r\n    a -> ArraySet[2/2:[0]=c,[1]=b]\r\n    b -> ArraySet[1/1:[0]=d]\r\n    c -> ArraySet[2/2:[0]=f,[1]=e]\r\n    d -> ArraySet[1/1:[0]=g]\r\n    e -> ArraySet[1/1:[0]=d]\r\n    f -> ArraySet[2/2:[0]=g,[1]=d]\r\n\r\n  Reverse Graph: source -> {destination} edges\r\n    b -> ArraySet[1/1:[0]=a]\r\n    c -> ArraySet[1/1:[0]=a]\r\n    d -> ArraySet[3/4:[0]=b,[1]=e,[2]=f]\r\n    e -> ArraySet[1/1:[0]=c]\r\n    f -> ArraySet[1/1:[0]=c]\r\n    g -> ArraySet[2/2:[0]=d,[1]=f]</pre></b>\r\n<p>\r\nThe reverse graph would be written as\r\n<p>\r\n<image src=\"images/reversegraph.gif\">\r\n<p>\r\nBecause node <b>a</b> is not a source node in the reversed graph,\r\n  it does not appear first on any line.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 2 -->\r\n\r\n<a name=\"problem2\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2</b></td>\r\n<td width =\"80%\">\r\nDownload the <a href=\"reachable.zip\">Reachability</a> project folder.\r\nThe <b>main</b> method in my solution contains 19 non-blank lines of code\r\n  (mostly to read in the graph);\r\n  the <b>reachable</b> method contains 15 non-blank lines; the\r\n  <b>printGraph</b> method (7 non-blank lines) comes from the solution to the\r\n  previous problem.\r\nNote that there are multiple data files for this program; test them all.\r\nDraw the graph for each and ensure that your code correctly prints it\r\n  and computes the nodes reachable from any source node.\r\nThese are the same files as for Problem #1: if you drew out the graphs\r\n  there, use them for this problem; if you didn't, draw them out now.\r\n\r\n<h3>Problem Statement (Including Input and Output)</h3>\r\nFirst, repeat what you did in Problem #2: read a file of pairs of node names\r\n  representing edges in a directed graph, building a <b>Map</b> whose key is\r\n  the label of the source node and whose value is a <b>Set</b> of the\r\n  destination nodes reachable from that source node.\r\nWe write this informally as <b>Map[String] -&gt; Set[String]</b>\r\n<p>\r\nTwo nodes appear on each line: first the source node, then the destination\r\n  node, with these words separated by one semicolon character.\r\nFor example, the input file <b>graph1.txt</b> contains the following\r\n  lines:\r\n<b><pre>  c;f\r\n  b;d\r\n  a;c\r\n  c;e\r\n  d;g\r\n  a;b\r\n  e;d\r\n  f;g\r\n  f;d</pre></b>\r\n<p>\r\nSecond, call the <b>printGraph</b> method to prints all these edges, one\r\n  source node per line (sorted alphabetically) followed by the <b>Set</b> of\r\n   all the destination nodes that it can immediately reach.\r\nThe graph above would print as\r\n<b><pre>  Graph: source -> {destination} edges\r\n    a -> ArraySet[2/2:[0]=c,[1]=b]\r\n    b -> ArraySet[1/1:[0]=d]\r\n    c -> ArraySet[2/2:[0]=f,[1]=e]\r\n    d -> ArraySet[1/1:[0]=g]\r\n    e -> ArraySet[1/1:[0]=d]\r\n    f -> ArraySet[2/2:[0]=g,[1]=d]</pre></b>\r\n<p>\r\nNote that the source nodes are SORTED alphabetically, but\r\n  the set of desintation nodes does NOT have to be SORTED:\r\n  you can print the <b>Set</b> using a <b>toString</b> method\r\n  (explicitly or implicitly).\r\nAlso, because node <b>g</b> is not a source node (it is only a\r\n  destination node), it does not appear first on any line.\r\n<p>\r\nThird, write a method named <b>reachable</b> that takes two parameters: the\r\n  first is a graph and the second is one label of a node in that graph;\r\n  this method returns a <b>Set</b> of that label and all the labels of nodes\r\n  reachable from that one by following the edges/arrows <b>any number of\r\n  times</b>.\r\n<p>\r\nHere is the basic algorithm for reachability, which is simple to explain and\r\n  not (very) complicated to implement by using collection classes.\r\nYou should try to hand simulate it, at a high-level, assuming the <b>Set</b>\r\n  and <b>Queue</b> collections work correctly, independent of how they are\r\n  implemented.\r\nUse this method instead of recursion: unless recursion is done very carefully,\r\n  it will run forever on graphs with cycles: one of the input files is a graph\r\n  with cycles.\r\n<ul>\r\n<li>To search the graph for all the reachable nodes, build a <b>Set</b> (of\r\n  reachable nodes) and a <b>Queue</b> (of nodes to search from), initializing\r\n  the <b>Queue</b> with the node supplied as a parameter to <b>reachable</b>.\r\n<p>\r\n<li>While the <b>Queue</b> still has nodes, remove one, put it into the\r\n  <b>Set</b> of reachable nodes and for all its destination nodes THAT ARE NOT\r\n  ALREADY in the <b>Set</b>, put them in the <b>Queue</b>.\r\n<p>\r\n<li>When the <b>Queue</b> finally becomes empty (can you prove this always\r\n    happens\r\n    -there is no infinite looping), return the <b>Set</b> of all the labels of\r\n    nodes that are reachable.\r\n</ul>\r\nPrint the set containing all these node labels.\r\n\r\n<p>\r\nMy main method reads the graph, and then the last two lines in my code are just\r\n<b><pre>  String start = Prompt.forString(\"\\nEnter node to start from\");\r\n  System.out.println(\"Node(s) reachable from \" + start + \" = \" + \r\n                     reachable(graphMap,start));</pre></b>\r\n<p>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one.\r\nYou should also check that it works for other starting nodes, and\r\n  a variety of starting nodes in the other graphs.\r\n\r\n<b><pre>  Enter name of file with graph: <i>graph1.txt</i>\r\n\r\n  Graph: source -> {destination} edges\r\n    a -> ArraySet[2/2:[0]=c,[1]=b]\r\n    b -> ArraySet[1/1:[0]=d]\r\n    c -> ArraySet[2/2:[0]=f,[1]=e]\r\n    d -> ArraySet[1/1:[0]=g]\r\n    e -> ArraySet[1/1:[0]=d]\r\n    f -> ArraySet[2/2:[0]=g,[1]=d]\r\n<p>\r\n\r\n  Enter node to start from: c\r\n  Node(s) reachable from c = ArraySet[5/8:[0]=c,[1]=f,[2]=e,[3]=g,[4]=d]</pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 3 -->\r\n\r\n<a name=\"problem3\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #3</b></td>\r\n<td width =\"80%\">\r\nDownload the <a href=\"fa.zip\">Finite Automaton</a> project folder.\r\nThe <b>main</b> method in my solution contains 35 non-blank lines of code.\r\n<p>\r\nYour program will simulate a machine called a \"finite  automaton\" (FA);\r\n  sometimes this is also called a Deterministic Finite Automaton (DFA).\r\nAn FA is described by its <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> specifies an <b>input</b> and what <b>state</b>\r\n  that input leads to.\r\nYou will read the description of some arbitrary FA first;\r\n  then you will simulate that FA starting in a specific state and\r\n  running on a specific input.\r\n<p>\r\n\r\n<h3>Problem Statement (Including Input and Output)</h3>\r\nFirst, process a file that describes a FA.\r\nCreate a <b>Map</b> whose keys are states and whose values are another\r\n  <b>Map</b> of the transitions from that state: whose keys are inputs and \r\n  whose values are states.\r\nEach line of the file contains a state and a description of its transitions.\r\nThe first token is the state (a <b>String</b>) and the remaining tokens (always\r\n  coming in pairs) are inputs and states.\r\nEach transition <b>Map</b> for a state has a key that is an input\r\n  (a <b>String</b>) and a value that is a state (a <b>String</b>).\r\nAll tokens are separated by one semicolon character.\r\nWe write this informally as\r\n  <b>Map[String] -&gt; (Map[String] -&gt; String)</b>.\r\n<p>\r\n\r\nFor example, the file <b>parity.txt</b> contains the following lines:\r\n<b><pre>  even;0;even;1;odd\r\n  odd;0;odd;1;even</pre></b>\r\nHere is a picture of the <b>parity</b> FA.\r\nIt graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)\r\n  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)\r\n  that always lead back to one of these two states.\r\n<p>\r\n\r\n<img src=\"images/parity.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>even</b> (meaning it has seen an even number of <b>1</b>\r\n  inputs so far) is a key in the main <b>Map</b>.\r\nIt's value is a <b>Map</b> with two key/value pairs <b>0</b>/<b>even</b>\r\n  and <b>1</b>/<b>odd</b>.\r\nIt means that in the <b>even</b> state, if the input is a <b>0</b> the\r\n  FA stays in the <b>even</b> state; if the input is a <b>1</b> the\r\n  FA goes to the <b>odd</b> state.\r\nAnd similarly (the next line) means that in the <b>odd</b> state, if the input\r\n  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a\r\n  <b>1</b> the FA goes back to the <b>even</b> state.\r\n<p>\r\n\r\nSecond print a sorted version of the main <b>Map</b>:\r\n  the <b>states</b> (for any FA, no matter how many states it has)\r\n  must be printed in alphabetical order, one state per line, each followed\r\n  by  its associated <b>Map</b> of transitions.\r\nThe information in the transition <b>Map</b>s <b>does not</b> have to be in \r\n  alphabetical order: you can print the <b>Map</b> using a <b>toString</b>\r\n  method (explicitly or implicitly).\r\n<p>\r\n\r\nFor example, the file above would produce:\r\n<b><pre>Finite Automaton\r\n  even transitions = ArrayMap[2/2:[0]=0->even,[1]=1->odd]\r\n  odd transitions = ArrayMap[2/2:[0]=0->odd,[1]=1->even]</pre></b>\r\n<p>\r\n\r\nThird, process a one-line file that contains an initial state followed\r\n  by a sequence of inputs.\r\nThe initial state will be a state in the FA (are in the outer map) and all\r\n  inputs specify legal transitions (are in the inner maps).\r\n<p>\r\n\r\nFor example, the input file <b>inputparity.txt</b> contains the following\r\n  line:\r\n<b><pre>even;1;0;1;1;0;1</pre></b>\r\nThis means, starting in the initial state <b>even</b> it processes the inputs\r\n  <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\n\r\nPrint the initial state, and then each input and the new state it transitions\r\n  to, and finally print the final state.\r\nFor the <b>parity</b> FA and this file, it prints\r\n<b><pre>Initial state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\nFinal state = even</pre></b>\r\n\r\n<p>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one.\r\n<b><pre>Enter Finite Automaton Description File: <i>parity.txt</i>\r\n\r\nFinite Automaton\r\n  even transitions = ArrayMap[2/2:[0]=0->even,[1]=1->odd]\r\n  odd transitions = ArrayMap[2/2:[0]=0->odd,[1]=1->even]\r\n\r\nEnter start state/inputs file: <i>inputparity.txt</i>\r\nInitial state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\nFinal state = even\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 4 -->\r\n\r\n<a name=\"problem4\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #4</b></td>\r\n<td width =\"80%\">\r\nDownload the <a href=\"ndfa.zip\">Non-Determinisitic Finite Automaton</a>\r\n  project folder.\r\nThe <b>main</b> method in my solution contains 46 non-blank lines of code.\r\nGenerally, you can update a clean solution to Problem #3 to get a clean\r\n  solution to this problem, making key changes related to the differences\r\n  created by non-determinism.\r\n<p>\r\nYour program will simulate a machine called a \"non-deterministic finite \r\n  automaton\" (NDFA);\r\n  contrast this with the Deterministic Finite Automaton in Problem #3.\r\nA NDFA is described by its <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> specifies an <b>input</b> and what <b>state</b>\r\n  <b>(or states: that what makes it non-deterministic</b>) that input leads\r\n  to.\r\nYou will read the description of some arbitrary NDFA first;\r\n  then you will simulate that NDFA starting in a specific state and\r\n  running on a specific input.\r\n<p>\r\n\r\n<h3>Problem Statement (Including Input and Output)</h3>\r\nFirst, process a file that describes a NDFA.\r\nCreate a <b>Map</b> whose keys are states and whose values are another\r\n  <b>Map</b> of the transitions from that state: whose keys are inputs and \r\n  whose values are a <b>Set</b> of states.\r\nEach line of the file contains a state and a description of its transitions.\r\nThe first token is the state (a <b>String</b>) and the remaining tokens (always\r\n  coming in pairs) are inputs and states.\r\nEach transition <b>Map</b> for a state has a key that is an input\r\n  (a <b>String</b>) and a value that is a <b>Set</b> of states (each state\r\n  is a <b>String</b>).\r\nAll tokens are separated by one semicolon character.\r\nWe write this informally as\r\n  <b>Map[String] -&gt; (Map[String] -&gt; Set[String]).</b>\r\nCompare this to the previous description (for a deterministic finite\r\n  automata: <b>Map[String] -&gt; (Map[String] -&gt; String)</b>).\r\n<p>\r\n\r\nFor example, the file <b>endin01.txt</b> contains the following lines:\r\n<b><pre>  start;0;start;1;start;0;near\r\n  near;1;end\r\n  end</pre></b>\r\nHere is a picture of the <b>endin01</b> NDFA.\r\nIt graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,\r\n  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>\r\n  and <b>1</b>).\r\n<p>\r\n\r\n<img src=\"images/endin01.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>start</b> is a key in the main <b>Map</b>.\r\nIt's value is a <b>Map</b> with two key/value pairs <b>0</b> mapping to the\r\n  <b>Set</b> containing <b>start</b> and <b>near</b> and <b>1</b> mapping to\r\n  the the <b>Set</b> containing just <b>start</b>.\r\nIt means that in the <b>start</b> state, if the input is a <b>0</b> the\r\n  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>\r\n  state; if the input is a <b>1</b> the NSFA must stay in the <b>start</b>\r\n  state.\r\nAnd similarly (the next line means) that in the <b>near</b> state, if the\r\n  input is a <b>1</b> the NDFA must go into the <b>end</b> state.\r\nThe last line means that the <b>end</b> state has no transitions.\r\n<p>\r\n\r\nSecond print a sorted version of the main <b>Map</b>:\r\n  the <b>states</b> (for any NDFA, no matter how many states it has)\r\n  must be printed in alphabetical order, one state per line, each followed\r\n  by  its associated <b>Map</b> of transitions.\r\nThe information in the transition <b>Map</b>s <b>does not</b> have to be in \r\n alphabetical order: print them the simplest way you can in Java, since the\r\n  order is not important.\r\nNote that the state <b>end</b> is a key in the main <b>Map</b>, whose\r\n  associated transitions are an empty <b>Map</b>\r\n<p>\r\n\r\nFor example, the file above would produce:\r\n<b><pre>Non-Deterministic Finite Automaton\r\n  end transitions = ArrayMap[0/1:]\r\n  near transitions = ArrayMap[1/1:[0]=1->ArraySet[1/1:[0]=end]]\r\n  start transitions = ArrayMap[2/2:[0]=0->ArraySet[2/2:[0]=start,[1]=near],[1]=1->ArraySet[1/1:[0]=start]]</pre></b>\r\n<p>\r\n\r\nThird, process a one-line file that contains an initial state followed\r\n  by a sequence of inputs.\r\nThe initial state will be in the NDFA (in the outer map) and all inputs\r\n  specify legal transitions (in the inner maps).\r\n<p>\r\n\r\nFor example, the input file <b>inputendin01.txt</b> contains the following\r\n  line:\r\n<b><pre>start;1;0;1;1;0;1</pre></b>\r\nStarting in the initial state <b>start</b> it processes the inputs\r\n  <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\n\r\n\r\nPrint the initial state, and then each input and the new state(s) it\r\n  transitions to, and finally print the final state.\r\nFor the <b>endin01</b> NDFA and this file, it prints\r\n<b><pre>Initial state(s) = ArraySet[1/1:[0]=start]\r\n  input = 1; new possible states = ArraySet[1/1:[0]=start]\r\n  input = 0; new possible states = ArraySet[2/2:[0]=start,[1]=near]\r\n  input = 1; new possible states = ArraySet[2/2:[0]=start,[1]=end]\r\n  input = 1; new possible states = ArraySet[1/1:[0]=start]\r\n  input = 0; new possible states = ArraySet[2/2:[0]=start,[1]=near]\r\n  input = 1; new possible states = ArraySet[2/2:[0]=start,[1]=end]\r\nFinal possible state(s) = ArraySet[2/2:[0]=start,[1]=end]</pre></b>\r\n<p>\r\n\r\nNote especially that in the <b>start</b> state, if the input is a <b>0</b>,\r\n  then the NDFA can either remain in the <b>start</b> state or go into the\r\n  <b>near</b> state.\r\nFor this program, we keep tracek of all states that the NDFA can be in,\r\n  using a <b>Set</b> of <b>new possible states</b>.\r\nFor the next input, <b>1</b>, we can be either in the <b>start</b> state\r\n  (from the <b>start</b> state, an input of <b>1</b> allows us to stay in the\r\n  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state, an\r\n  input of <b>1</b> allows us to transition to the <b>end</b> state).\r\nThus, we keep track of the <b>Set</b> of states the NDFA can be in, and the\r\n  new <b>Set</b> of states the NDFA can be in after processing the next input.\r\n\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one.\r\n<b><pre>Enter Non-Deterministic Finite Automaton Description File: <i>endin01.txt</i>\r\n\r\nNon-Deterministic Finite Automaton\r\n  end transitions = ArrayMap[0/1:]\r\n  near transitions = ArrayMap[1/1:[0]=1->ArraySet[1/1:[0]=end]]\r\n  start transitions = ArrayMap[2/2:[0]=0->ArraySet[2/2:[0]=start,[1]=near],[1]=1->ArraySet[1/1:[0]=start]]\r\n\r\nEnter start state/inputs file: <i>inputendin01.txt</i>\r\nInitial state(s) = ArraySet[1/1:[0]=start]\r\n  input = 1; new possible states = ArraySet[1/1:[0]=start]\r\n  input = 0; new possible states = ArraySet[2/2:[0]=start,[1]=near]\r\n  input = 1; new possible states = ArraySet[2/2:[0]=start,[1]=end]\r\n  input = 1; new possible states = ArraySet[1/1:[0]=start]\r\n  input = 0; new possible states = ArraySet[2/2:[0]=start,[1]=near]\r\n  input = 1; new possible states = ArraySet[2/2:[0]=start,[1]=end]\r\nFinal possible state(s) = ArraySet[2/2:[0]=start,[1]=end]</pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem #5 -->\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #5</b></td>\r\n<td width =\"80%\">\r\nDownload the <a href=\"wordgenerator.zip\">Word Generator</a> project folder.\r\nThe <b>main</b> method in my solution contains 64 non-blank lines of code\r\n  (my anonymous class implementing the <b>Comparator</b> interface was 9\r\n   non-blank lines, and the <b>randomWord</b> method is 2 non-blank lines).\r\n<p>\r\nYour program will \"learn\" the word pattern of an author (based on some\r\n  \"order statistic\") and then generate random text following the author's\r\n  word pattern.\r\n\r\n<h3>Problem Statement (Including Input and Output)</h3>\r\nFirst, prompt the user for the order statistic <b>n</b>: 1, 2, 3, etc.\r\nFor initial testing, I suggest using an order statistic of 2; when you\r\n  think your program is correct, try 3 or 4.\r\n\r\n<p>\r\nSecond, read a file of tokens, building a <b>Map</b> storing the following\r\n  data: <b>Map[List[String<sup>n</sup>]] -&gt; List[String]</b>.\r\nfrom a <b>List</b> of <b>n</b> words (<b>n</b> is the order statistic</b>) to\r\n  a <b>List</b> of all the words in the text that follow these words:\r\ne.g., if <b>n</b> were <b>2</b>, the <b>Map</b> would contain a key for every\r\n  pair of words appearing next to each other in the text, and a value that is a\r\n  <b>List</b> of all the words following this key (no matter where the pair\r\n  occurs, with NO DUPLICATES allowed in  the values list).\r\n<p>\r\nYou can read the words one at a time, in a single loop (see <b>readString</b>\r\n  in the <b>TypedBufferReader</b> class) or call <b>readAllTokens</b> and use\r\n  the <b>StringTokenizer</b> class on them (using a <b>\" \"</b> to specify to\r\n  use only a space as the token separators).\r\nTo build the <b>Map</b> start by \"prereading\" <b>n</b> words into the list\r\n  (assume that this is always possible; how might it not be?); then read the\r\n  next word and put it in as a value associated with the <b>List</b> of\r\n  pre-read words; then, drop the oldest word in the <b>List</b>, and add this\r\n  next word to the end of the list (always keeping the list length at\r\n  <b>n</b>); read the next word, and repeat the process for this word,\r\n  continuing until there are no words to read.\r\n<p>\r\nFor a simple example, the file <b>input1.txt</b> contains the following lines:\r\n<b><pre>  a b c b a d c b a d\r\n  c a a b a a d</pre></b>\r\n  \r\n<p>\r\nThird, print all the associations in the <b>Map</b>, one per line in lexical\r\n  order; after printing all associations, print the size of the smallest and\r\n  largest <b>List</b> that is a value in the <b>Map</b>.\r\nEach line contains <b>n</b> words in a <b>List</b>, followed by the\r\n  <b>List</b> of words that follow them in the text.\r\nIn lexical order, the keys appear in order relative to the first word in\r\n  the <b>List</b>; for all first words that are the same, they appear in\r\n  order relative to the second word in the <b>List</b>; for all first and\r\n  second words that are the same, they appear in order relative to the thrid\r\n  word in the <b>List</b>; etc.\r\n<p>\r\nYou can put all the entries in a <b>List</b> and then sort the list using an\r\n  object from an anonymous class implementing the <b>Comparator</b> to do the\r\n  job: its <b>compare</b> method finds the first different words in the two\r\n  <b>Lists</b> (there will always be at least on different word) and return a\r\n  result based on how these two words compare.\r\nFill in the <b>Comparator</b> in some call to the <b>Collections.sort</b>\r\n  method.\r\nExamine the code in the <a href=\"voting.zip\">Voting Problem</a> to see how\r\n  something similar is accomplished there.\r\n<p>\r\nFor example, the file above would produce:\r\n<b><pre>    Following ArrayList[2/2:[0]=a,[1]=a] -> any of ArrayList[2/2:[0]=b,[1]=d]\r\n    Following ArrayList[2/2:[0]=a,[1]=b] -> any of ArrayList[2/2:[0]=c,[1]=a]\r\n    Following ArrayList[2/2:[0]=a,[1]=d] -> any of ArrayList[1/1:[0]=c]\r\n    Following ArrayList[2/2:[0]=b,[1]=a] -> any of ArrayList[2/2:[0]=d,[1]=a]\r\n    Following ArrayList[2/2:[0]=b,[1]=c] -> any of ArrayList[1/1:[0]=b]\r\n    Following ArrayList[2/2:[0]=c,[1]=a] -> any of ArrayList[1/1:[0]=a]\r\n    Following ArrayList[2/2:[0]=c,[1]=b] -> any of ArrayList[1/1:[0]=a]\r\n    Following ArrayList[2/2:[0]=d,[1]=c] -> any of ArrayList[2/2:[0]=b,[1]=a]\r\n  Min List size = 1\r\n  Max List size = 2</pre></b>\r\n<p>\r\nSo, as you can see, the only allowed transition from <b>[a,d]</b> is\r\n  <b>c</b>; in the text above, <b>a d</b> appears twice, and it\r\n  is followed each time by a <b>c</b>.\r\nThe allowed transitions from <b>[a,b]</b> are <b>c</b> and <b>a</b>; in the\r\n  text above, <b>a b</b> appears twice, first followed by <b>c</b> and\r\n  then by <b>a</b>.\r\n\r\n<p>\r\nFinally, prompt the user for the number of random words to generate (some\r\n  number greater than the order statistic), and then prompt for the <b>n</b>\r\n  words to start with.\r\nBuild two lists (<b>List[String]</b>) both starting out with these words.\r\nThe first will always contain the current <b>n</b> words (to be used as a key\r\n  in the <b>Map</b>); the second will contain all the generated words.\r\nGenerate a random next word from the <b>Map</b>: add it to both lists; then,\r\n  drop the first word from the first list, so it is a list of size <b>n</b>\r\n  again</b>; repeat until you have generated the required number of words.\r\n<b>Warning</b>: you might have to stop prematurely if you generate the last\r\n  <b>n</b> words in the text, if these words occur nowhere else.\r\nThat is because in this case, there is no random word to generate following\r\n  them!\r\nPrint the list. \r\n<p>\r\nA 15 element list, starting with the words <b>a</b> and <b>d</b> might\r\n  print as\r\n<pre><b>  Results = ArrayList[17/32:[0]=a,[1]=d,[2]=c,[3]=a,[4]=a,[5]=d,[6]=c,\r\n            [7]=a,[8]=a,[9]=d,[10]=c,[11]=a,[12]=a,[13]=b,[14]=c,[15]=b,[16]=a]</b></pre>\r\nIn the result we start with <b>a d</b> (specified by the user), we\r\n  know only <b>c</b> can come next; then using <b>d c</b> we know that\r\n  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...\r\n<p>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one.\r\n<pre><b>  Enter Order Statistic: <i>2</i>\r\n  Enter name of sample text file: <i>input1.txt</i>\r\n\r\n  Allowed Transitions (sorted)\r\n    Following ArrayList[2/2:[0]=a,[1]=a] -> any of ArrayList[2/2:[0]=b,[1]=d]\r\n    Following ArrayList[2/2:[0]=a,[1]=b] -> any of ArrayList[2/2:[0]=c,[1]=a]\r\n    Following ArrayList[2/2:[0]=a,[1]=d] -> any of ArrayList[1/1:[0]=c]\r\n    Following ArrayList[2/2:[0]=b,[1]=a] -> any of ArrayList[2/2:[0]=d,[1]=a]\r\n    Following ArrayList[2/2:[0]=b,[1]=c] -> any of ArrayList[1/1:[0]=b]\r\n    Following ArrayList[2/2:[0]=c,[1]=a] -> any of ArrayList[1/1:[0]=a]\r\n    Following ArrayList[2/2:[0]=c,[1]=b] -> any of ArrayList[1/1:[0]=a]\r\n    Following ArrayList[2/2:[0]=d,[1]=c] -> any of ArrayList[2/2:[0]=b,[1]=a]\r\n  Min List size = 1\r\n  Max List size = 2\r\n\r\n  Enter # of words to generate: <i>15</i>\r\n  Enter prefix word[0]: <i>a</i>\r\n  Enter prefix word[1]: <i>d</i>\r\n\r\n  Results = ArrayList[17/32:[0]=a,[1]=d,[2]=c,[3]=a,[4]=a,[5]=d,[6]=c,[7]=a,\r\n            [8]=a,[9]=d,[10]=c,[11]=a,[12]=a,[13]=b,[14]=c,[15]=b,[16]=a]</b></pre>\r\n<p>\r\nYou can also try reading a much larger file included in this project\r\n  folder <b>huck.txt</b>, Mark Twain's, \"The Adventures of Huckleberry Finn\".\r\nOn my machine, it took over 1/2 hour to create a <b>Map</b> with an\r\n  order statistic of 3.\r\nIt has over 90,000 entries in the <b>Map</b>; the biggest key triple had an\r\n  associated value with 46 entries in it.\r\nThe key was <b>ArrayList[3/4:out,of,the]</b> and its associated value was\r\n<pre><b>  ArrayList[46/64:window,face,woods,fourth,front,jacket,hole,canoe,middle,\r\n  ferryboat's,cottonwood,captain's,river,fog,range,presbyterian,tree,nest,\r\n  wagon-troughs,reach,store,way,wigwam,ark,room,corner,grave,nonesuch,trouble,\r\n  kitchen,old,first,hardest,nigger-patch,sugar-bowl,window-hole,brass,spoon,\r\n  house,tooleries,bag,office,post-office,cabin,path,chains]</b></pre>\r\n<p>\r\nWhen we re-implement <b>Map</b> with a HashT able (instead of an Array), the\r\n  time could go down to just a few seconds (almost 2,000 times faster).\r\n<p>\r\nYou can use this same program to read/generate music or DNA sequences or any\r\n  other data made of symbols.\r\n<!---\r\nIf you want, you can try this variation: when constructing the <b>Map</b>, use\r\n  <b>Map[List[String<sup>n</sup>]] -&gt; Set[String]</b>) from a list of\r\n  <b>n</b> words (where <b>n</b> is the order statistic) to a set of the words\r\n   in the text following these words.\r\nThen, when finished reading the text, iterate through the <b>Map</b>\r\n  replacing each <b>Set</b> by a <b>List</b>.\r\nRun the original program and this new one a few times each to determine\r\n  if the second is faster (it is).\r\nExplain why it is better to use a <b>Set</b> than a <b>List</b> while the\r\n  <b>Map</b> is being built (even though we eventually must use a <b>List</b>\r\n  to help us choose a random \"following word\".\r\n--->\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<!-- Extra Credit -->\r\n\r\n<a name=\"ExtraCredit\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Extra Credit</b></td>\r\n<td width =\"80%\">\r\nProgramming assignments must be turned in on time: you can get partial credit\r\n  for a partially completed assignment, but it must be turned in on time; I\r\n  will accept no late homework unless you have an official excuse\r\n  (and it is best contact me as soon as the problem arises, not after the\r\n  due date).\r\nIn fact, there is another incentive to finish not only on time, but to\r\n  <b>finish early</b>.\r\n<p>\r\nIn all programming assignments, if you turn in everything at least 24 hours\r\n  before it is officialy due, you will receive 2 points of extra credit.\r\nIf you turn it in 48 hours (or earlier), you will receive 3 points of extra\r\n  credit.\r\n(There is no more extra credit for earlier turn-ins; I recommend NOT turning it\r\n  in more than 48 hours early -specifically, wait until you receive your graded\r\n  previous program before turning in a new one).\r\nThis is equivalent to one half of a full grade improvement on an 60 point\r\n  programming assignment.\r\nIn previous quarters that I have taught, almost 75% of the students completed\r\n  their assignments early and received some amount of extra credit for doing\r\n  so.\r\n<p>\r\nThere are two main advantages to planning on finishing early.\r\nFirst, if you run into a major problem, you will have extra time to solve it\r\n  before the actual due date: and even experienced programmers frequently run\r\n  into such problems.\r\nYes, this means you!\r\nSecond, and more importantly, if you are racing to finish before a deadline,\r\n  stress levels can go through the roof, and you become less interested in\r\n  learning the material (and the whole purpose of these programming assignments\r\n  is to ensure that you have learned the material) and more interested in just\r\n  getting it finished.\r\nIf you do not learn the material, you will be at a major disadvantage for all\r\n  subsequent programming assignments and tests, because of the cumulative\r\n  nature of the material in this course.\r\nTherefore, plan to finish <b>every</b> assignment by Tuesday or Wednesday\r\n   evening (most are due on Thursday evening).\r\n<p>\r\nProgramming assignments sometimes also include an extra credit section worth\r\n  a few extra points points.\r\nThese are designed for students who finish early and want to continue exploring\r\n  programming within the context of the assignment.\r\nThe points are to acknowledge, in a small way, their extra effort.\r\nThis assignment has extra credit only for turning it in early.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Time Management -->\r\n\r\n<a name=\"TimeManagement\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Time Management</b></td>\r\n<td width =\"80%\">\r\nOne of the hardest parts of being in college is learning how to manage your\r\n  time.\r\nTime management is especially important in programming courses (and in the real\r\n  world, when you are working on complicated projects with hard deadlines).\r\nThe difference between good and bad time management can have a profound impact\r\n  on how much you learn in this course, how well you perform in it, and how\r\n  much effort you actually need to expend to do well.\r\n<p>\r\nGenerally, it is best to spread out the work on a two week-long assignment.\r\nOften there are mutliple parts to the assignment, so you complete these parts\r\n  in sequence.\r\nMost assignments become available two days before the Lab they are assigned on.\r\nDuring the Lab they are assigned on, we will overview the assignment and you\r\n  can start working on one aspect of it then as well.\r\n<p>\r\nSome students look at an assignment and think that it is best done in one\r\n  sitting.\r\nIf you can do so, great; but, if you plan to work this way, do the one sitting\r\n  soon after it is assigned, not the night before it is due!\r\nIn this way, if you are wrong about the amount of time that it will take, you\r\n  will still have adequate time to complete the assignment.\r\nI know everyone has lots of constraints on their schedules, but the programming\r\n  assignments should be doable in two weeks.\r\nBy meeting these time goals, you will both maximize what you learn and minimize\r\n  your anxiety and the time that it takes for you to do the learning.\r\n<p>\r\nRemember that assignments must be turned in on time: you can get partial credit\r\n  for a partially completed assignment, but it must be turned in on time; I\r\n  will not accept any late homework unless you have an official excuse.\r\n<p>\r\nFinally, if you find yourself falling behind, seek help immediately (from me,\r\n  the TAs, or even other students in the course -when appropriate).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</table>\r\n</body>\r\n</html>\r\n", "id": 33419.0}