{"text": "Re Seiwald Q A GET for EDIT cookies David G Durand dgd cs bu edu Thu 29 Aug 1996 13 38 3 5 Messages sorted by date thread subject author Next message Yaron Goland RE Seiwald Q A Previous message Jim Whitehead RE Microsoft Feature Support List V 1 ALPHA 8 26 96 At 1 PM 8 28 96 Christopher Seiwald wrote Me again Locking reservations can be handled by LOCK I quite agree But SCM systems don t hang all their context on a lock they hang it on the checkout That s when the user tells the system I ll be changing this here document and the system records that fact for the day when the user says Uh here s that document I changed The SCM system uses this context to keep track of the dozens thousands of users out there all trying to change the same set of documents but invariable all starting with different revisions of those documents Well my interpretation of lock is that it s a notofication of intent to modify a resource I don t think but not everyone agrees with me that we can specify a single policy for locking that will work for everyone but we can define operations the servers can interpret to do the right thing based on the policies that they implement and the clients can meaningfully implement in way that will let them be used effectively with different servers I don t think and intentionally avoided requiring that we can guarantee that the same client used with different server will work exactly the same way with each server But a client should be able to work with different servers and make effective use of the policies that the servers do provide So an argument that CHECKOUT CHECKIN are required separate from a LOCK GET PUT UNLOCK cycle would have to be a case where a server needed to have both forms of operation in place and have both forms operate oaccording to different semantics We want sufficient operations to span the space of behavior but I don t think that the different behaviors need distinct representations in the protocol unless they need to be simultaneously implemented Not all SCM systems require a lock before checking in documents and some acquire that lock automatically so many PUTs are likely to happen in the absense of a LOCK But all SCM systems except CVS require some sort of checkout locking or non locking before checkin I think we have to handle CVS too which means we already can t require a CHECKOUT method If you don t need a lock then LOCK followed by GET is a checkout Maybe the name LOCK is bad Maybe NOTIFY of intention to write would be better Now you could fudge it and by remembering the URL and revision do a paired checkout checkin to establish the required context But this defeats a feature that all modern SCM systems boast tracking user activity They have this feature because users don t remember what they re doing and they certainly don t remember what other people are doing Half the job of SCM systems and by extension version aware web servers is to keep track of who is doing what to what just to remind everyone involved Those scenarios I cooked up where Joe and Jane keep stepping on each other weren t just from my past experience they were from my past week s experience I don t have a problem with a server having a policy that passes out multiple locks as long as we can represent the state properly I don t see the problem with the client having to present the version number with the document when reigstering an update Is the cookie a persisten session identifier I m still having trouble understanding what it is rather than what you wan tot do with it Only one user can LOCK a file If the context is established on LOCK then there will be only one context per document precluding Joe and Jane from finding out that they re doctoring the same text I m not sure that this has to be the case I d rather relax the semantics of lock and keep a single protocol with access and update orhtogonal than tighten the defintion add more methods and make client and server implementation harder and more policy dependent Normally SCM systems have a tight association between the checkout context and the checked out file because often there is no way to work outside of the SCM system But if the SCM system is the backend of a version aware web server with the actual work happening in stateless web clients then that context must be represented by a cookie What is the context If I understood that maybe I would undertsand everything I still don t see what the cookie is needed for The cookie belongs to the underlying SCM system whether it is an MD5 hash of the document contents some cryptic string churned up from bowels of the SCM database or allworkandnoplaymakesjohnnyadullboy is not HTTP s or a Web authoring tool s business They just have to keep it associated with the checked out document so that it can be reunited with the checkout context at checkin time MD5 was just an example What does the cookie identify a state of the document a granted access request a bunch of session information or something else This cookie is the single most important component of distributed web authoring IMHO May be I can see some use for session identifiers So I can check out the same thing 5 times and post a variety of variants Couldn t non exclusive reservation also be handled by some kind of generic attach meta data operation I suspect we will need something like this as a hook for specific config management strategies in the second phase anyway David David Durand dgd cs bu edu david dynamicDiagrams com Boston University Computer Science Dynamic Diagrams http www cs bu edu students grads dgd http dynamicDiagrams com Next message Yaron Goland RE Seiwald Q A Previous message Jim Whitehead RE Microsoft Feature Support List V 1 ALPHA 8 26 96 ", "_id": "http://www.ics.uci.edu/~ejw/versioning/arch/0117.html", "title": "archive of working group on versioning and configuration management of world wide web content: re: seiwald q &amp; a -- \"get for edit\" cookies", "html": "<!-- received=\"Tue Sep  3 05:14:09 1996 PDT\" -->\n<!-- sent=\"Thu, 29 Aug 1996 13:38:03 -0500\" -->\n<!-- name=\"David G. Durand\" -->\n<!-- email=\"dgd@cs.bu.edu\" -->\n<!-- subject=\"Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies\" -->\n<!-- id=\"v02130505ae4b8f3533dc@[128.148.157.46]\" -->\n<!-- inreplyto=\"Seiwald Q &amp; A -- \"GET for EDIT\" cookies\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies</title>\n<h1>Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies</h1>\n<b>David G. Durand</b> (<a href=\"mailto:dgd@cs.bu.edu\"><i>dgd@cs.bu.edu</i></a>)<br>\n<i>Thu, 29 Aug 1996 13:38:03 -0500</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#117\">[ date ]</a><a href=\"thread.html#117\">[ thread ]</a><a href=\"subject.html#117\">[ subject ]</a><a href=\"author.html#117\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0118.html\">Yaron Goland: \"RE: Seiwald Q &amp; A\"</a>\n<li> <b>Previous message:</b> <a href=\"0116.html\">Jim Whitehead: \"RE: Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\nAt 10:00 PM 8/28/96, Christopher Seiwald wrote:\n&gt;Me again:\n&gt;Locking (\"reservations\") can be handled by LOCK, I quite agree.  But\n&gt;SCM systems don't hang all their context on a lock: they hang it on the\n&gt;\"checkout\".  That's when the user tells the system, \"I'll be changing\n&gt;this here document,\" and the system records that fact for the day when\n&gt;the user says, \"Uh, here's that document I changed.\" The SCM system uses\n&gt;this context to keep track of the dozens (thousands?) of users out there,\n&gt;all trying to change the same set of documents (but invariable all\n&gt;starting with different revisions of those documents).\n\nWell, _my_ interpretation of lock is that it's a notofication of intent to\nmodify a resource. I don't think (but not everyone agrees with me) that we\ncan specify a single policy for locking that will work for everyone: but we\ncan define operations the servers can interpret to \"do the right thing\"\nbased on the policies that they implement, and the clients can meaningfully\nimplement in way that will let them be used effectively with different\nservers.\n\n    I don't think (and intentionally avoided requiring) that we can\nguarantee that the same client used with different server will work exactly\nthe same way with each server. But a client should be able to work with\ndifferent servers and make effective use of the policies that the servers\ndo provide.\n\n    So an argument that CHECKOUT/CHECKIN are required separate from a\nLOCK/GET/PUT/UNLOCK cycle would have to be a case where a server needed to\nhave _both forms_ of operation in place, _and_ have both forms operate\noaccording to different semantics. We want sufficient operations to span\nthe space of behavior, but I don't think that the different behaviors need\ndistinct representations in the protocol, unless they need to be\nsimultaneously implemented.\n\n&gt;Not all SCM systems require a lock before checking in documents, and\n&gt;some acquire that lock automatically, so many PUTs are likely to happen\n&gt;in the absense of a LOCK.  But _all_ SCM systems (except CVS) require\n&gt;some sort of checkout (locking or non-locking) before checkin.\n   I think we have to handle CVS too, which means we already can't\n_require_ a CHECKOUT method.\n\nIf you don't need a lock, then LOCK followed by GET _is_ a checkout. Maybe\nthe name LOCK is bad. Maybe NOTIFY (of intention to write) would be better?\n\n\n&gt;  Now you\n&gt;could fudge it, and by remembering the URL and revision do a paired\n&gt;checkout/checkin to establish the required context.  But this defeats\n&gt;a feature that all modern SCM systems boast: tracking user activity.\n&gt;They have this feature because users don't remember what they're doing,\n&gt;and they certainly don't remember what other people are doing.  Half\n&gt;the job of SCM systems (and by extension, version aware web servers) is\n&gt;to keep track of who is doing what to what, just to remind everyone\n&gt;involved.  Those scenarios I cooked up (where Joe and Jane keep stepping\n&gt;on each other) weren't just from my past experience: they were from my\n&gt;past week's experience.\n\nI don't have a problem with a server having a policy that passes out\nmultiple locks (as long as we can represent the state properly). I don't\nsee the problem with the client having to present the version number with\nthe document when reigstering an update.\n\nIs the cookie a persisten session identifier? I'm still having trouble\nunderstanding what it is, rather than what you wan tot do with it...\n\n\n&gt;Only one user can LOCK a file.  If the context is established on LOCK\n&gt;then there will be only one context per document, precluding Joe and\n&gt;Jane from finding out that they're doctoring the same text.\nI'm not sure that this has to be the case. I'd rather relax the semantics\nof lock, and keep a single protocol with access and update orhtogonal than\ntighten the defintion, add more methods, and make client and server\nimplementation harder and more policy-dependent.\n\n&gt;Normally SCM systems have a tight association between the checkout\n&gt;context and the checked-out file, because often there is no way to work\n&gt;\"outside\" of the SCM system.  But if the SCM system is the backend of\n&gt;a version-aware web server, with the actual work happening in \"stateless\"\n&gt;web clients, then that context must be represented by a cookie.\nWhat is the context? If I understood that maybe I would undertsand\neverything. I still don't see what the cookie is _needed for_.\n\n&gt;The cookie belongs to the underlying SCM system; whether it is an MD5\n&gt;hash of the document contents, some cryptic string churned up from bowels\n&gt;of the SCM database, or \"allworkandnoplaymakesjohnnyadullboy\" is not\n&gt;HTTP's or a Web authoring tool's business.  They just have to keep it\n&gt;associated with the checked-out document so that it can be reunited with\n&gt;the checkout context at checkin time.\nMD5 was just an example... What does the cookie identify: a state of the\ndocument, a granted access request, a bunch of session information, or\nsomething else?\n\n&gt;\n&gt;This cookie is the single most important component of distributed web\n&gt;authoring, IMHO.\n\n\nMay be. I can see some use for session identifiers (So I can check out the\nsame thing 5 times and post a variety of variants).\n   Couldn't non-exclusive reservation also be handled by some kind of\ngeneric \"attach meta-data\" operation; I suspect we will need something like\nthis as a hook for specific config management strategies in the second\nphase anyway?\n\n\n    -- David\n\n--------------------------------------------+--------------------------\nDavid Durand                  <a href=\"mailto:dgd@cs.bu.edu\">dgd@cs.bu.edu</a> | david@dynamicDiagrams.com\nBoston University Computer Science          | Dynamic Diagrams\n<a href=\"http://www.cs.bu.edu/students/grads/dgd/\">http://www.cs.bu.edu/students/grads/dgd/</a>    | http://dynamicDiagrams.com/\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0118.html\">Yaron Goland: \"RE: Seiwald Q &amp; A\"</a>\n<li> <b>Previous message:</b> <a href=\"0116.html\">Jim Whitehead: \"RE: Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n", "id": 34795.0}