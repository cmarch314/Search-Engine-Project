{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 273D Polyhedral Surfaces Lutz Kettner 27 1 Introduction Polyhedral surfaces in three dimensions are composed of vertices edges facets and an incidence relationship on them The organization beneath is a halfedge data structure which restricts the class of representable surfaces to orientable 2 manifolds with and without boundary If the surface is closed we call it a polyhedron for example see the following model of a hammerhead The polyhedral surface is realized as a container class that manages vertices halfedges facets with their incidences and that maintains the combinatorial integrity of them It is based on the highly flexible design of the halfedge data structure see the introduction in Chapter and Ket99 However the polyhedral surface can be used and understood without knowing the underlying design Some of the examples in this chapter introduce also gradually into first applications of this flexibility 27 2 Definition A polyhedral surface CGAL Polyhedron 3 PolyhedronTraits 3 in three dimensions consists of vertices V edges E facets F and an incidence relation on them Each edge is represented by two halfedges with opposite orientations The incidences stored with a halfedge are illustrated in the following figure Vertices represent points in space Edges are straight line segments between two endpoints Facets are planar polygons without holes Facets are defined by the circular sequence of halfedges along their boundary The polyhedral surface itself can have holes with at least two facets surrounding it since a single facet cannot have a hole The halfedges along the boundary of a hole are called border halfedges and have no incident facet An edge is a border edge if one of its halfedges is a border halfedge A surface is closed if it contains no border halfedges A closed surface is a boundary representation for polyhedra in three dimensions The convention is that the halfedges are oriented counterclockwise around facets as seen from the outside of the polyhedron An implication is that the halfedges are oriented clockwise around the vertices The notion of the solid side of a facet as defined by the halfedge orientation extends to polyhedral surfaces with border edges although they do not define a closed object If normal vectors are considered for the facets normals point outwards following the right hand rule The strict definition can be found in Ket99 One implication of this definition is that the polyhedral surface is always an orientable and oriented 2 manifold with border edges i e the neighborhood of each point on the polyhedral surface is either homeomorphic to a disc or to a half disc except for vertices where many holes and surfaces with boundary can join Another implication is that the smallest representable surface avoiding self intersections is a triangle for polyhedral surfaces with border edges or a tetrahedron for polyhedra Boundary representations of orientable 2 manifolds are closed under Euler operations They are extended with operations that create or close holes in the surface Other intersections besides the incidence relation are not allowed However this is not automatically verified in the operations since self intersections are not easy to check efficiently CGAL Polyhedron 3 PolyhedronTraits 3 does only maintain the combinatorial integrity of the polyhedral surface using Euler operations and does not consider the coordinates of the points or any other geometric information CGAL Polyhedron 3 PolyhedronTraits 3 can represent polyhedral surfaces as well as polyhedra The interface is designed in such a way that it is easy to ignore border edges and work only with polyhedra 27 3 Example Programs The polyhedral surface is based on the highly flexible design of the halfedge data structure Examples for this flexibility can be found in Section and in Section This design is not a prerequisite to understand the following examples See also the Section below for some advanced examples 27 3 1 First Example Using Defaults The first example instantiates a polyhedron using a kernel as traits class It creates a tetrahedron and stores the reference to one of its halfedges in a Halfedge handle Handles also know as trivial iterators are used to keep references to halfedges vertices or facets for future use There is also a Halfedge iterator type for enumerating halfedges Such an iterator type can be used wherever a handle is required Respective Halfedge const handle and Halfedge const iterator for a constant polyhedron and similar handles and iterators with Vertex and Facet prefix are provided too The example continues with a test if the halfedge actually refers to a tetrahedron This test checks the connected component referred to by the halfedge h and not the polyhedral surface as a whole This examples works only on the combinatorial level of a polyhedral surface The next example adds the geometry file examples Polyhedron polyhedron prog simple C include CGAL Simple cartesian h include CGAL Polyhedron 3 h typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron Halfedge handle Halfedge handle int main Polyhedron P Halfedge handle h P make tetrahedron if P is tetrahedron h return return 1 27 3 2 Example with Geometry in Vertices We add geometry to the our construction of a tetrahedron Four points are passed as arguments to the construction This example demonstrates in addition the use of the vertex iterator and the access to the point in the vertices Note the natural access notation v point Similarly all information stored in a vertex halfedge and facet can be accessed with a member function given a handle or iterator For example given a halfedge handle h we can write h next to get a halfedge handle to the next halfedge h opposite for the opposite halfedge h vertex for the incident vertex at the tip of h and so on The output of the program will be 1 n 1 n 1 n n file examples Polyhedron polyhedron prog tetra C include CGAL Simple cartesian h include CGAL Polyhedron 3 h include iostream typedef CGAL Simple cartesian double Kernel typedef Kernel Point 3 Point 3 typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron Vertex iterator Vertex iterator int main Point 3 p 1 Point 3 q 1 Point 3 r 1 Point 3 s Polyhedron P P make tetrahedron p q r s CGAL set ascii mode std cout for Vertex iterator v P vertices begin v P vertices end v std cout v point std endl return The polyhedron offers a point iterator for convenience The above for loop simplifies to a single statement by using std copy and the ostream iterator adaptor std copy P points begin P points end std ostream iterator Point 3 std cout n 27 3 3 Example for Affine Transformation An affine transformation A can act as a functor transforming points and a point iterator is conveniently defined for polyhedral surfaces So assuming we want only the point coordinates of a polyhedron P transformed std transform does the job in a single line std transform P points begin P points end P points begin A 27 3 4 Example Computing Plane Equations The polyhedral surface has already provisions to store a plane equation for each facet However it does not provide a function to compute plane equations This example computes the plane equations of a polyhedral surface The actual computation is implemented in the compute plane equations function Depending on the arithmetic exact inexact and the shape of the facets convex non convex different methods are useful We assume here strictly convex facets and exact arithmetic In our example a homogeneous representation with int coordinates is sufficient The four plane equations of the tetrahedron are the output of the program file examples Polyhedron polyhedron prog planes C include CGAL Homogeneous h include CGAL Polyhedron 3 h include iostream include algorithm struct Plane equation template class Facet typename Facet Plane 3 operator Facet f typename Facet Halfedge handle h f halfedge typedef typename Facet Plane 3 Plane return Plane h vertex point h next vertex point h next next vertex point typedef CGAL Homogeneous int Kernel typedef Kernel Point 3 Point 3 typedef Kernel Plane 3 Plane 3 typedef CGAL Polyhedron 3 Kernel Polyhedron int main Point 3 p 1 Point 3 q 1 Point 3 r 1 Point 3 s Polyhedron P P make tetrahedron p q r s std transform P facets begin P facets end P planes begin Plane equation CGAL set pretty mode std cout std copy P planes begin P planes end std ostream iterator Plane 3 std cout n return 27 3 5 Example with a Vector Instead of a List Representation The polyhedron class template has actually four parameters where three of them have default values Using the default values explicitly in our examples above for three parameter ignoring the fourth parameter which would be a standard allocator for container class the definition of a polyhedron looks like typedef CGAL Polyhedron 3 Traits CGAL Polyhedron items 3 CGAL HalfedgeDS default Polyhedron The CGAL Polyhedron items 3 class contains the types used for vertices edges and facets The CGAL HalfedgeDS default class defines the halfedge data structure used which is a list based representation in this case An alternative is a vector based representation Using a vector provides random access for the elements in the polyhedral surface and is more space efficient but elements cannot be deleted arbitrarily Using a list allows arbitrary deletions but provides only bidirectional iterators and is less space efficient The following example creates again a tetrahedron with given points but in a vector based representation The vector based representation resizes automatically if the reserved capacity is not sufficient for the new items created Upon resizing all handles iterators and circulators become invalid Their correct update in the halfedge data structure is costly thus it is advisable to reserve enough space in advance as indicated with the alternative constructor in the comment advanced Note that the polyhedron and not the underlying halfedge data structure triggers the resize operation since the resize operation requires some preconditions such as valid incidences to be fulfilled that only the polyhedron can guarantee advanced file examples Polyhedron polyhedron prog vector C include CGAL Cartesian h include CGAL HalfedgeDS vector h include CGAL Polyhedron 3 h include iostream typedef CGAL Cartesian double Kernel typedef Kernel Point 3 Point 3 typedef CGAL Polyhedron 3 Kernel CGAL Polyhedron items 3 CGAL HalfedgeDS vector Polyhedron int main Point 3 p 1 Point 3 q 1 Point 3 r 1 Point 3 s Polyhedron P alternative constructor Polyhedron P 4 12 4 P make tetrahedron p q r s CGAL set ascii mode std cout std copy P points begin P points end std ostream iterator Point 3 std cout n return 27 3 6 Example with Circulator Writing Object File Format OFF We create a tetrahedron and write it to std cout using the Object File Format OFF Phi96 This example makes use of STL algorithms std copy std distance STL std ostream iterator and CGAL circulators The polyhedral surface provides convenient circulators for the counterclockwise circular sequence of halfedges around a facet and the clockwise circular sequence of halfedges around a vertex However the computation of the vertex index in the inner loop of the facet output is not advisable with the std distance function since it takes linear time for non random access iterators which leads to quadratic runtime For better runtime the vertex index needs to be stored separately and computed once before writing the facets It can be stored for example in the vertex itself or in a hash structure See also the following Section for file I O file examples Polyhedron polyhedron prog off C include CGAL Simple cartesian h include CGAL Polyhedron 3 h include iostream typedef CGAL Simple cartesian double Kernel typedef Kernel Point 3 Point 3 typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron Facet iterator Facet iterator typedef Polyhedron Halfedge around facet circulator Halfedge facet circulator int main Point 3 p Point 3 q 1 Point 3 r 1 Point 3 s 1 Polyhedron P P make tetrahedron p q r s Write polyhedron in Object File Format OFF CGAL set ascii mode std cout std cout OFF std endl P size of vertices P size of facets std endl std copy P points begin P points end std ostream iterator Point 3 std cout n for Facet iterator i P facets begin i P facets end i Halfedge facet circulator j i facet begin Facets in polyhedral surfaces are at least triangles CGAL assertion CGAL circulator size j 3 std cout CGAL circulator size j do std cout std distance P vertices begin j vertex while j i facet begin std cout std endl return 27 3 7 Example Using Euler Operators to Build a Cube Euler operators are the natural way of modifying polyhedral surfaces We provide a set of operations for polyhedra split facet join facet split vertex join vertex split loop and join loop We add further convenient operators such as split edge However they could be implemented using the six operators above Furthermore we provide more operators to work with polyhedral surfaces with border edges for example creating and deleting holes We refere to the references manual for the definition and illustratives figures of the Euler operators The following example implements a function that appends a unit cube to a polyhedral surface To keep track of the different steps during the creation of the cube a sequence of sketches might help with labels for the different handles that occur in the program code The following Figure shows six selected steps from the creation sequence These steps are also marked in the program code file examples Polyhedron polyhedron prog cube C include CGAL Simple cartesian h include CGAL Polyhedron 3 h include iostream template class Poly typename Poly Halfedge handle make cube 3 Poly P appends a cube of size 1 3 to the polyhedron P CGAL precondition P is valid typedef typename Poly Point 3 Point typedef typename Poly Halfedge handle Halfedge handle Halfedge handle h P make tetrahedron Point 1 Point 1 Point Point 1 Halfedge handle g h next opposite next Fig a P split edge h next P split edge g next P split edge g Fig b h next vertex point Point 1 1 g next vertex point Point 1 1 g opposite vertex point Point 1 1 Fig c Halfedge handle f P split facet g next g next next next Fig d Halfedge handle e P split edge f e vertex point Point 1 1 1 Fig e P split facet e f next next Fig f CGAL postcondition P is valid return h typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron Halfedge handle Halfedge handle int main Polyhedron P Halfedge handle h make cube 3 P return P is tetrahedron h 1 27 4 File I O Simple file I O for polyhedral surfaces is already provided in the library The file I O considers so far only the topology of the surface and its point coordinates It ignores a possible plane equation or any user added attributes such as color The default file format supported in CGAL for output as well as for input is the Object File Format OFF with file extension off which is also understood by GeomView Phi96 For OFF an ASCII and a binary format exist The format can be selected with the CGAL modifiers for streams set ascii mode and set binary mode respectively The modifier set pretty mode can be used to allow for a few structuring comments in the output Otherwise the output would be free of comments The default for writing is ASCII without comments Both ASCII and binary format can be read independent of the stream setting Since this file format is the default format iostream operators are provided for it include CGAL IO Polyhedron iostream h template class PolyhedronTraits 3 ostream ostream out CGAL Polyhedron 3 PolyhedronTraits 3 P template class PolyhedronTraits 3 istream istream in CGAL Polyhedron 3 PolyhedronTraits 3 P Additional formats supported for writing are OpenInventor iv Wer94 VRML 1 and 2 wrl BPP95 VRM96 HW96 and Wavefront Advanced Visualizer object format obj Another convenient output function writes a polyhedral surface to a GeomView process spawned from the CGAL program These output functions are provided as stream operators now acting on the stream type of the respective format include CGAL IO Polyhedron inventor ostream h include CGAL IO Polyhedron VRML 1 ostream h include CGAL IO Polyhedron VRML 2 ostream h include CGAL IO Polyhedron geomview ostream h template class PolyhedronTraits 3 Inventor ostream Inventor ostream out CGAL Polyhedron 3 PolyhedronTraits 3 P template class PolyhedronTraits 3 VRML 1 ostream VRML 1 ostream out CGAL Polyhedron 3 PolyhedronTraits 3 P template class PolyhedronTraits 3 VRML 2 ostream VRML 2 ostream out CGAL Polyhedron 3 PolyhedronTraits 3 P template class PolyhedronTraits 3 Geomview stream Geomview stream out CGAL Polyhedron 3 PolyhedronTraits 3 P All these file formats have in common that they represent a surface as a set of facets Each facet is a list of indices pointing into a set of vertices Vertices are represented as coordinate triples The file I O for polyhedral surfaces CGAL Polyhedron 3 imposes certain restrictions on these formats They must represent a permissible polyhedral surface e g a 2 manifold and no isolated vertices see Section Some example programs around the different file formats are provided in the distribution under examples Polyhedron IO and demo Polyhedron IO We show an example converting OFF input into VRML 1 output examples Polyhedron IO polyhedron2vrml C include CGAL Simple cartesian h include CGAL Polyhedron 3 h include CGAL IO Polyhedron iostream h include CGAL IO Polyhedron VRML 1 ostream h include iostream typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron int main Polyhedron P std cin P CGAL VRML 1 ostream out std cout out P return std cin std cout 1 27 5 Extending Vertices Halfedges and Facets In Section we have seen how to change the default list representation typedef CGAL Polyhedron 3 Traits CGAL Polyhedron items 3 CGAL HalfedgeDS default Polyhedron to a vector based representation of the underlying halfedge data structure Now we want to look a bit closer at the second template argument Polyhedron items 3 that specifies what kind of vertex halfedge and facet is used The implementation of Polyhedron items 3 looks a bit involved with nested wrapper class templates But ignoring this technicality what remains are three local typedefs that define the Vertex the Halfedge and the Face for the polyhedral surface Note that we use here Face instead of facet Face is the term used for the halfedge data structure Only the top layer of the polyhedral surface gives alias names renaming face to facet class Polyhedron items 3 public template class Refs class Traits struct Vertex wrapper typedef typename Traits Point 3 Point typedef CGAL HalfedgeDS vertex base Refs CGAL Tag true Point Vertex template class Refs class Traits struct Halfedge wrapper typedef CGAL HalfedgeDS halfedge base Refs Halfedge template class Refs class Traits struct Face wrapper typedef typename Traits Plane 3 Plane typedef CGAL HalfedgeDS face base Refs CGAL Tag true Plane Face If we look up in the reference manual the definitions of the three classes used in the typedefs we will see the confirmation that the default polyhedron uses all supported incidences a point in the vertex class and a plane equation in the face class Note how the wrapper class provides two template parameters Refs which we discuss a bit later and Traits which is the geometric traits class used by the polyhedral surface and which provides us here with the types for the point and the plane equation Using this example code we can write our own items class Instead we illustrate an easier way if we only want to exchange one class We use a simpler face without the plane equation but with a color attribute added To simplify the creation of a vertex halfedge or face class it is always recommended to derive from one of the given base classes Even if the base class would contain no data it would provide convenient type definitions So we derive from the base class repeat the mandatory constructors if necessary which is not the case for faces but would be for vertices and add the color attribute template class Refs struct My face public CGAL HalfedgeDS face base Refs CGAL Color color The new items class is derived from the old items class and the wrapper containing the face typedef gets overridden Note that the name of the wrapper and its template parameters are fixed They cannot be changed even if as in this example a template parameter is not used struct My items public CGAL Polyhedron items 3 template class Refs class Traits struct Face wrapper typedef My face Refs Face When we use our new items class with the polyhedral surface our new face class is used in the halfedge data structure and the color attribute is available in the type Polyhedron Facet However Polyhedron Facet is not the same type as our local face typedef for My face but it is derived therefrom Thus everything that we put in the local face type except constructors is then available in the Polyhedron Facet type For more details see the Chapter on the halfedge data structure design Pulling all pieces together the full example program illustrates how easy the color attribute can be accessed once it is defined file examples Polyhedron polyhedron prog color C include CGAL Simple cartesian h include CGAL IO Color h include CGAL Polyhedron 3 h A face type with a color member variable template class Refs struct My face public CGAL HalfedgeDS face base Refs CGAL Color color An items type using my face struct My items public CGAL Polyhedron items 3 template class Refs class Traits struct Face wrapper typedef My face Refs Face typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel My items Polyhedron typedef Polyhedron Halfedge handle Halfedge handle int main Polyhedron P Halfedge handle h P make tetrahedron h facet color CGAL RED return We come back to the first template parameter Refs of the wrapper classes This parameter provides us with local types that allow us to make further references between vertices halfedges and facets which have not already been prepared for in the current design These local types are Vertex handle Halfedge handle Face handle and there respective const handle We add now a new vertex reference to a face class as follows Encapsulation and access functions could be added for a more thorough design but we omit that here for the sake of brevity The integration of the face class with the items class works as illustrated above template class Refs struct My face public CGAL HalfedgeDS face base Refs typedef typename Refs Vertex handle Vertex handle Vertex handle vertex ref More advanced examples can be found in the Section illustrating further the design of the halfedge data structure 27 6 Advanced Example Programs 27 6 1 Example Creating a Subdivision Surface This program reads a polyhedral surface from the standard input and writes a refined polyhedral surface to the standard output Input and output are in the Object File Format OFF with the common file extension off which is also understood by GeomView Phi96 The refinement is a single step of the sqrt 3 scheme for creating a subdivision surface Kob Each step subdivides a facet into triangles around a new center vertex smoothes the position of the old vertices and flips the old edges The program is organized along this outline In each of these parts the program efficiently uses the knowledge that the newly created vertices edges and facets have been added to the end of the sequences The program needs additional processing memory only for the smoothing step of the old vertices The above figure shows three example objects each subdivided four times The initial object for the left sequence is the closed surface of three unit cubes glued together to a corner The example program shown here can handle only closed surfaces but the extended example examples Polyhedron polyhedron prog subdiv with boundary C handles surfaces with boundary So the middle sequence starts with the same surface where one of the facets has been removed The boundary subdivides to a nice circle The third sequence creates a sharp edge using a trick in the object presentation The sharp edge is actually a hole whose vertex coordinates pinch the hole shut to form an edge The example directory examples Polyhedron contains the OFF files used here file examples Polyhedron polyhedron prog subdiv C include CGAL Cartesian h include CGAL Polyhedron 3 h include CGAL IO Polyhedron iostream h include iostream include algorithm include vector typedef CGAL Cartesian double Kernel typedef Kernel Vector 3 Vector typedef Kernel Point 3 Point typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron Vertex Vertex typedef Polyhedron Vertex iterator Vertex iterator typedef Polyhedron Halfedge handle Halfedge handle typedef Polyhedron Edge iterator Edge iterator typedef Polyhedron Facet iterator Facet iterator typedef Polyhedron Halfedge around vertex const circulator HV circulator typedef Polyhedron Halfedge around facet circulator HF circulator void create center vertex Polyhedron P Facet iterator f Vector vec std size t order HF circulator h f facet begin do vec vec h vertex point CGAL ORIGIN order while h f facet begin CGAL assertion order 3 guaranteed by definition of polyhedron Point center CGAL ORIGIN vec order Halfedge handle new center P create center vertex f halfedge new center vertex point center struct Smooth old vertex Point operator const Vertex v const CGAL precondition CGAL circulator size v vertex begin 1 std size t degree CGAL circulator size v vertex begin 2 double alpha 4 2 cos 2 CGAL PI degree 9 Vector vec v point CGAL ORIGIN 1 alpha HV circulator h v vertex begin do vec vec h opposite vertex point CGAL ORIGIN alpha degree h CGAL assertion h v vertex begin even degree guaranteed h while h v vertex begin return CGAL ORIGIN vec void flip edge Polyhedron P Halfedge handle e Halfedge handle h e next P join facet e P split facet h h next next void subdiv Polyhedron P if P size of facets return We use that new vertices halfedges facets are appended at the end std size t nv P size of vertices Vertex iterator last v P vertices end last v the last of the old vertices Edge iterator last e P edges end last e the last of the old edges Facet iterator last f P facets end last f the last of the old facets Facet iterator f P facets begin create new center vertices do create center vertex P f while f last f std vector Point pts smooth the old vertices pts reserve nv get intermediate space for the new points last v make it the past the end position again std transform P vertices begin last v std back inserter pts Smooth old vertex std copy pts begin pts end P points begin Edge iterator e P edges begin flip the old edges last e make it the past the end position again while e last e Halfedge handle h e e careful incr before flip since flip destroys current edge flip edge P h CGAL postcondition P is valid int main Polyhedron P std cin P P normalize border if P size of border edges std cerr The input object has border edges Cannot subdivide std endl std exit 1 subdiv P std cout P return 27 6 2 Example Using the Incremental Builder and Modifier Mechanism A utility class CGAL Polyhedron incremental builder 3 helps in creating polyhedral surfaces from a list of points followed by a list of facets that are represented as indices into the point list This is particularly useful for implementing file reader for common file formats It is used here to create a triangle A modifier mechanism allows to access the internal representation of the polyhedral surface i e the halfedge data structure in a controlled manner A modifier is basically a callback mechanism using a function object When called the function object receives the internal halfedge data structure as a parameter and can modify it On return the polyhedron can check the halfedge data structure for validity Such a modifier object must always return with a halfedge data structure that is a valid polyhedral surface The validity check is implemented as an expensive postcondition at the end of the delegate member function i e it is not called by default only when expensive checks are activated In this example Build triangle is such a function object derived from CGAL Modifier base HalfedgeDS The delegate member function of the polyhedron accepts this function object and calls its operator with a reference to its internally used halfedge data structure Thus this member function in Build triangle can create the triangle in the halfedge data structure file examples Polyhedron polyhedron prog incr builder C include CGAL Simple cartesian h include CGAL Polyhedron incremental builder 3 h include CGAL Polyhedron 3 h A modifier creating a triangle with the incremental builder template class HDS class Build triangle public CGAL Modifier base HDS public Build triangle void operator HDS hds Postcondition hds is a valid polyhedral surface CGAL Polyhedron incremental builder 3 HDS B hds true B begin surface 3 1 6 typedef typename HDS Vertex Vertex typedef typename Vertex Point Point B add vertex Point B add vertex Point 1 B add vertex Point 1 B begin facet B add vertex to facet B add vertex to facet 1 B add vertex to facet 2 B end facet B end surface typedef CGAL Simple cartesian double Kernel typedef CGAL Polyhedron 3 Kernel Polyhedron typedef Polyhedron HalfedgeDS HalfedgeDS int main Polyhedron P Build triangle HalfedgeDS triangle P delegate triangle CGAL assertion P is triangle P halfedges begin return Next chapter 3D Polyhedral Surfaces Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Polyhedron/Chapter_main.html", "title": "3d polyhedral surfaces", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Polyhedron/main.tex' -->\n<html> <head>  \n<title>3D Polyhedral Surfaces</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_main.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_27\"></a>\n  \n<h1>Chapter 27<BR>3D Polyhedral Surfaces</h1>\n\n<A NAME=\"chapterPolyhedron\"></A>\n\n<EM>Lutz Kettner</EM><BR>\n\n\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>27.1&nbsp;&nbsp;&nbsp;Introduction</h2>\n\n<A NAME=\"sectionPolyIntro\"></A>\n<P>\n\nPolyhedral surfaces in three dimensions are composed of vertices,\nedges, facets and an incidence relationship on them. The organization\nbeneath is a halfedge data structure, which restricts the class of\nrepresentable surfaces to orientable 2-manifolds - with and without\nboundary. If the surface is closed we call it a <I>polyhedron</I>, for\nexample, see the following model of a hammerhead:\n<P>\n\n<CENTER>\n        <img src=\"./fig/shark.gif\" alt=\"Hammerhead\">\n<P>\n\n</CENTER>\n<P>\n\nThe polyhedral surface is realized as a container class that manages\nvertices, halfedges, facets with their incidences, and that maintains\nthe combinatorial integrity of them. It is based on the highly\nflexible design of the halfedge data structure, see the introduction\nin Chapter&nbsp;<A HREF=\"../HalfedgeDS/Chapter_main.html#chapterHalfedgeDS\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and&nbsp;[<A HREF=\"../biblio.html#Biblio_k-ugpdd-99\">Ket99</A>]. However, the\npolyhedral surface can be used and understood without knowing the\nunderlying design. Some of the examples in this chapter introduce also\ngradually into first applications of this flexibility.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>27.2&nbsp;&nbsp;&nbsp;Definition</h2>\n<P>\n\nA polyhedral surface <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;</I> in\nthree dimensions consists of vertices <MATH><I>V</I></MATH>, edges <MATH><I>E</I></MATH>, facets <MATH><I>F</I></MATH> and\nan incidence relation on them.  Each edge is represented by two\nhalfedges with <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> orientations. The incidences stored with a\nhalfedge are illustrated in the following figure:\n<P>\n\n<CENTER>\n    <A HREF=\"./fig/halfedge.gif\">\n        <img src=\"./fig/halfedge_small.gif\" alt=\"Halfedge Diagram\"></A>\n<P>\n\n</CENTER>\n<P>\n\nVertices represent points in space. Edges are straight line segments\nbetween two endpoints. Facets are planar polygons without\nholes. Facets are defined by the circular sequence of halfedges along\ntheir boundary.  The polyhedral surface itself can have holes (with at\nleast two facets surrounding it since a single facet cannot have a\nhole). The halfedges along the boundary of a hole are called <I>border halfedges</I> and have no incident facet. An edge is a <I>border edge</I> if one of its halfedges is a border halfedge.  A\nsurface is <I>closed</I> if it contains no border halfedges. A closed\nsurface is a boundary representation for polyhedra in three\ndimensions. The convention is that the halfedges are oriented\ncounterclockwise around facets as seen from the outside of the\npolyhedron. An implication is that the halfedges are oriented\nclockwise around the vertices. The notion of the solid side of a facet\nas defined by the halfedge <A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A> extends to polyhedral surfaces\nwith border edges although they do not define a closed object. If\nnormal vectors are considered for the facets, normals point outwards\n(following the right-hand rule).\n<P>\n\nThe strict definition can be found in&nbsp;[<A HREF=\"../biblio.html#Biblio_k-ugpdd-99\">Ket99</A>]. One\nimplication of this definition is that the polyhedral surface is\nalways an orientable and oriented 2-manifold with border edges, i.e.,\nthe neighborhood of each point on the polyhedral surface is either\nhomeomorphic to a disc or to a half disc, except for vertices where\nmany holes and surfaces with boundary can join. Another implication is\nthat the smallest representable surface avoiding self intersections is\na triangle (for polyhedral surfaces with border edges) or a\ntetrahedron (for polyhedra). <A HREF=\"../Nef_2_ref/Class_Nef_polyhedron_2#Enum_Boundary\">Boundary</A> representations of orientable\n2-manifolds are closed under Euler operations. They are extended with\noperations that create or close holes in the surface.\n<P>\n\nOther intersections besides the incidence relation are not allowed.\nHowever, this is not automatically verified in the operations, since\nself intersections are not easy to check\nefficiently. <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;</I> does only\nmaintain the combinatorial integrity of the polyhedral surface (using\nEuler operations) and does not consider the coordinates of the points\nor any other geometric information.\n<P>\n\n<I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;</I> can represent polyhedral\nsurfaces as well as polyhedra. The interface is designed in such a way\nthat it is easy to ignore border edges and work only with polyhedra.\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>27.3&nbsp;&nbsp;&nbsp;Example Programs</h2>\n\n<A NAME=\"sectionPolyExamples\"></A>\n<P>\n\nThe polyhedral surface is based on the highly flexible design of the\nhalfedge data structure. Examples for this flexibility can be found in\nSection&nbsp;<A HREF=\"Chapter_main.html#sectionPolyExtend\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> and in Section&nbsp;<A HREF=\"../HalfedgeDS/Chapter_main.html#sectionHdsExamples\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>. \nThis design is not a prerequisite to understand the following examples.\nSee also the Section&nbsp;<A HREF=\"Chapter_main.html#sectionPolyAdvanced\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> below for some advanced \nexamples.\n<P>\n\n<h3>27.3.1&nbsp;&nbsp;&nbsp;First Example Using Defaults</h3>\n<P>\n\nThe first example instantiates a polyhedron using a kernel as traits\nclass. It creates a tetrahedron and stores the reference to one of its\nhalfedges in a <I>Halfedge_handle</I>. Handles, also know as\n<I>trivial iterators</I>, are used to keep references to halfedges,\nvertices, or facets for future use. There is also a <I>Halfedge_iterator</I>\ntype for enumerating halfedges. Such an iterator type can be used \nwherever a handle is required. Respective <I>Halfedge_const_handle</I> and\n<I>Halfedge_const_iterator</I> for a constant polyhedron and similar\nhandles and iterators with <I>Vertex_</I> and <I>Facet_</I> prefix\nare provided too.\n<P>\n\nThe example continues with a test if the halfedge\nactually refers to a tetrahedron. This test checks the connected \ncomponent referred to by the halfedge <I>h</I> and not the polyhedral\nsurface as a whole. This examples works only on the combinatorial\nlevel of a polyhedral surface. The next example adds the geometry.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_simple.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;         Polyhedron;\ntypedef Polyhedron::Halfedge_handle        Halfedge_handle;\n\nint main() {\n    Polyhedron P;\n    Halfedge_handle h = P.make_tetrahedron();\n    if ( P.is_tetrahedron(h))\n        return 0;\n    return 1;\n}\n</pre>\n<P>\n\n<h3>27.3.2&nbsp;&nbsp;&nbsp;Example with Geometry in Vertices</h3>\n<P>\n\nWe add geometry to the our construction of a tetrahedron. Four points\nare passed as arguments to the construction. This example demonstrates\nin addition the use of the vertex iterator and the access to the point\nin the vertices. Note the natural access notation <I>v-&gt;point()</I>.\nSimilarly, all information stored in a vertex, halfedge, and facet can\nbe accessed with a member function given a handle or iterator. For\nexample, given a halfedge handle <I>h</I> we can write <I>h-&gt;next()</I>\nto get a halfedge handle to the next halfedge, <I>h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()</I> for\nthe <A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A> halfedge, <I>h-&gt;vertex()</I> for the incident vertex at\nthe tip of <I>h</I>, and so on.  The output of the program will be\n``<TT>1 0 0\\n0 1 0\\n0 0 1\\n0 0 0\\n</TT>''.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_tetra.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;         Polyhedron;\ntypedef Polyhedron::Vertex_iterator        Vertex_iterator;\n\nint main() {\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p( 1.0, 0.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> q( 0.0, 1.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> r( 0.0, 0.0, 1.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> s( 0.0, 0.0, 0.0);\n\n    Polyhedron P;\n    P.make_tetrahedron( p, q, r, s);\n    <A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1743\">CGAL::set_ascii_mode</A>( std::cout);\n    for ( Vertex_iterator v = P.vertices_begin(); v != P.vertices_end(); ++v)\n        std::cout &lt;&lt; v-&gt;point() &lt;&lt; std::endl;\n    return 0;\n}\n</pre>\n<P>\n\nThe polyhedron offers a point iterator for convenience. The above\n<TT>for</TT> loop simplifies to a single statement by using\n<I>std::copy</I> and the ostream iterator adaptor.\n<P>\n\n<pre class=\"ExampleCode\">\nstd::copy( P.points_begin(), P.points_end(), \n           std::ostream_iterator&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;(std::cout,&quot;\\n&quot;));\n</pre>\n<P>\n\n<h3>27.3.3&nbsp;&nbsp;&nbsp;Example for Affine Transformation</h3>\n<P>\n\nAn affine transformation <MATH><I>A</I></MATH> can act as a functor transforming points\nand a point iterator is conveniently defined for polyhedral surfaces.\nSo, assuming we want only the point coordinates of a polyhedron <MATH><I>P</I></MATH>\ntransformed, <I>std::transform</I> does the job in a single line.\n<P>\n\n<pre class=\"ExampleCode\">\nstd::transform( P.points_begin(), P.points_end(), P.points_begin(), A);\n</pre>\n<P>\n\n<h3>27.3.4&nbsp;&nbsp;&nbsp;Example Computing Plane Equations</h3>\n<P>\n\nThe polyhedral surface has already provisions to store a plane\nequation for each facet. However, it does not provide a function to\ncompute plane equations.\n<P>\n\nThis example computes the plane equations of a polyhedral surface.\nThe actual computation is implemented in the\n<TT>compute_plane_equations</TT> function.  Depending on the arithmetic\n(exact/inexact) and the shape of the facets (convex/non-convex)\ndifferent methods are useful. We assume here strictly convex facets\nand exact arithmetic. In our example a homogeneous representation with\n<TT>int</TT> coordinates is sufficient. The four plane equations of the\ntetrahedron are the output of the program.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_planes.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18\">Homogeneous</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nstruct Plane_equation {\n    template &lt;class Facet&gt;\n    typename Facet::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A> operator()( Facet&amp; f) {\n        typename Facet::Halfedge_handle h = f.halfedge();\n        typedef typename Facet::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>  Plane;\n        return Plane( h-&gt;vertex()-&gt;point(),\n                      h-&gt;next()-&gt;vertex()-&gt;point(),\n                      h-&gt;next()-&gt;next()-&gt;vertex()-&gt;point());\n    }\n};\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17\">CGAL::Homogeneous</A>&lt;int&gt;      <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>             <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Plane_3.html#Cross_link_anchor_458\">Kernel::Plane_3</A>             <A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;  Polyhedron;\n\nint main() {\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p( 1, 0, 0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> q( 0, 1, 0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> r( 0, 0, 1);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> s( 0, 0, 0);\n    Polyhedron P;\n    P.make_tetrahedron( p, q, r, s);\n    std::transform( P.facets_begin(), P.facets_end(), P.planes_begin(),\n                    Plane_equation());\n    <A HREF=\"../IOstream_ref/Function_set_pretty_mode.html#Cross_link_anchor_1749\">CGAL::set_pretty_mode</A>( std::cout);\n    std::copy( P.planes_begin(), P.planes_end(),\n               std::ostream_iterator&lt;<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A>&gt;( std::cout, &quot;\\n&quot;));\n    return 0;\n}\n</pre>\n<P>\n\n<h3>27.3.5&nbsp;&nbsp;&nbsp;Example with a Vector Instead of a List Representation</h3>\n\n<A NAME=\"sectionPolyVector\"></A>\n<P>\n\nThe polyhedron class template has actually four parameters, where\nthree of them have default values. Using the default values explicitly\nin our examples above for three parameter - ignoring the fourth\nparameter, which would be a standard allocator for container class - \nthe definition of a polyhedron looks like:\n<P>\n\n<pre class=\"ExampleCode\">\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt; Traits, \n                            <A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A>, \n                            <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_882\">CGAL::HalfedgeDS_default</A>&gt;      Polyhedron;\n</pre>\n<P>\n\nThe <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A></I> class contains the types used for\nvertices, edges, and facets. The <I><A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_882\">CGAL::HalfedgeDS_default</A></I> class\ndefines the halfedge data structure used, which is a list-based\nrepresentation in this case. An alternative is a vector-based\nrepresentation. Using a vector provides random\naccess for the elements in the polyhedral surface and is more space\nefficient, but elements cannot be deleted arbitrarily. Using a list\nallows arbitrary deletions, but provides only bidirectional iterators\nand is less space efficient. The following example creates again a \ntetrahedron with given points, but in a vector-based representation.\n<P>\n\nThe vector-based representation resizes automatically if the reserved\ncapacity is not sufficient for the new items created. Upon resizing\nall handles, iterators, and circulators become invalid. Their correct\nupdate in the halfedge data structure is costly, thus it is advisable\nto reserve enough space in advance as indicated with the alternative\nconstructor in the comment.\n<P>\n\n<BR>\n\n<div class=\"AdvancedBlock\">\n  <table><tr><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin1.gif\" alt=\"begin of advanced section\">\n  </td><td valign=\"top\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"top\">\n  <img border=\"0\" src=\"cc_advanced_begin2.gif\" alt=\"begin of advanced section\">\n  </td></tr></table>\n\nNote that the polyhedron and not the underlying halfedge data\nstructure triggers the resize operation, since the resize operation\nrequires some preconditions, such as valid incidences, to be fulfilled\nthat only the polyhedron can guarantee.\n\n<table><tr><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end1.gif\" alt=\"end of advanced section\">\n  </td><td valign=\"bottom\">\n  <em class=\"AdvancedBlockLabel\">&nbsp;advanced&nbsp;</em>\n  </td><td valign=\"bottom\">\n  <img border=\"0\" src=\"cc_advanced_end2.gif\" alt=\"end of advanced section\">\n  </td></tr></table></div>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_vector.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_902\">HalfedgeDS_vector</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;                        <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                                <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>,\n                            <A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A>, \n                            <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vector.html#Cross_link_anchor_901\">CGAL::HalfedgeDS_vector</A>&gt;   Polyhedron;\n\nint main() {\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p( 1.0, 0.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> q( 0.0, 1.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> r( 0.0, 0.0, 1.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> s( 0.0, 0.0, 0.0);\n\n    Polyhedron P;    // alternative constructor: Polyhedron P(4,12,4);\n    P.make_tetrahedron( p, q, r, s);\n    <A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1743\">CGAL::set_ascii_mode</A>( std::cout);\n    std::copy( P.points_begin(), P.points_end(),\n\t       std::ostream_iterator&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;( std::cout, &quot;\\n&quot;));\n    return 0;\n}\n</pre>\n<P>\n\n<h3>27.3.6&nbsp;&nbsp;&nbsp;Example with Circulator Writing Object File Format (OFF)</h3>\n<P>\n\nWe create a tetrahedron and write it to <I>std::cout</I> using the\n<A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> File Format (OFF)&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:p-gmgv16-96\">Phi96</A>].  This example makes use\nof STL algorithms (<I>std::copy</I>, <I>std::distance</I>), STL <I>std::ostream_iterator</I>, and C<SMALL>GAL</SMALL> circulators. The polyhedral\nsurface provides convenient circulators for the counterclockwise\ncircular sequence of halfedges around a facet and the clockwise\ncircular sequence of halfedges around a vertex.\n<P>\n\nHowever, the computation of the vertex index in the inner loop of the\nfacet output is not advisable with the <I>std::distance</I> function,\nsince it takes linear time for non random-access iterators, which\nleads to quadratic runtime. For better runtime the vertex index needs\nto be stored separately and computed once before writing the\nfacets. It can be stored, for example, in the vertex itself or in a\nhash-structure.  See also the following Section&nbsp;<A HREF=\"Chapter_main.html#sectionPolyIO\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> for \nfile I/O.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_off.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;               <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                              <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;                   Polyhedron;\ntypedef Polyhedron::Facet_iterator                   Facet_iterator;\ntypedef Polyhedron::Halfedge_around_facet_circulator Halfedge_facet_circulator;\n\nint main() {\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> p( 0.0, 0.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> q( 1.0, 0.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> r( 0.0, 1.0, 0.0);\n    <A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> s( 0.0, 0.0, 1.0);\n\n    Polyhedron P;\n    P.make_tetrahedron( p, q, r, s);\n\n    // Write polyhedron in <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> File Format (OFF).\n    <A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1743\">CGAL::set_ascii_mode</A>( std::cout);\n    std::cout &lt;&lt; &quot;OFF&quot; &lt;&lt; std::endl &lt;&lt; P.size_of_vertices() &lt;&lt; ' ' \n              &lt;&lt; P.size_of_facets() &lt;&lt; &quot; 0&quot; &lt;&lt; std::endl;\n    std::copy( P.points_begin(), P.points_end(),\n               std::ostream_iterator&lt;<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>&gt;( std::cout, &quot;\\n&quot;));\n    for (  Facet_iterator i = P.facets_begin(); i != P.facets_end(); ++i) {\n        Halfedge_facet_circulator j = i-&gt;facet_begin();\n        // Facets in polyhedral surfaces are at least triangles.\n        CGAL_assertion( <A HREF=\"../Circulator_ref/Function_circulator_size.html#Cross_link_anchor_1605\">CGAL::circulator_size</A>(j) &gt;= 3);\n        std::cout &lt;&lt; <A HREF=\"../Circulator_ref/Function_circulator_size.html#Cross_link_anchor_1605\">CGAL::circulator_size</A>(j) &lt;&lt; ' ';\n        do {\n            std::cout &lt;&lt; ' ' &lt;&lt; std::distance(P.vertices_begin(), j-&gt;vertex());\n        } while ( ++j != i-&gt;facet_begin());\n        std::cout &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</pre>\n<P>\n\n<h3>27.3.7&nbsp;&nbsp;&nbsp;Example Using Euler Operators to Build a Cube</h3>\n<P>\n\nEuler operators are the natural way of modifying polyhedral surfaces.\nWe provide a set of operations for polyhedra: <I>split_facet()</I>, \n<I>join_facet()</I>, <I>split_vertex()</I>, <I>join_vertex()</I>,\n<I>split_loop()</I>, and <I>join_loop()</I>. We add further convenient\noperators, such as <I>split_edge()</I>. However, they could be implemented \nusing the six operators above. Furthermore, we provide more operators\nto work with polyhedral surfaces with border edges, for example, creating\nand deleting holes. We refere to the references manual for the \ndefinition and illustratives figures of the Euler operators.\n<P>\n\nThe following example implements a function that appends a unit cube\nto a polyhedral surface. To keep track of the different steps during\nthe creation of the cube a sequence of sketches might help with labels\nfor the different handles that occur in the program code. The following\nFigure shows six selected steps from the creation sequence. These steps \nare also marked in the program code.\n<P>\n\n<CENTER>\n        <img src=\"./fig/make_cube.gif\" alt=\"Steps in making a cube.\">\n<P>\n\n</CENTER>\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_cube.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;class Poly&gt;\ntypename Poly::Halfedge_handle make_cube_3( Poly&amp; P) {\n    // appends a cube of size [0,1]^3 to the polyhedron P.\n    CGAL_precondition( P.is_valid());\n    typedef typename Poly::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A>         Point;\n    typedef typename Poly::Halfedge_handle Halfedge_handle;\n    Halfedge_handle h = P.make_tetrahedron( Point( 1, 0, 0),\n                                            Point( 0, 0, 1),\n                                            Point( 0, 0, 0),\n                                            Point( 0, 1, 0));\n    Halfedge_handle g = h-&gt;next()-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;next();             // Fig. (a)\n    P.split_edge( h-&gt;next());\n    P.split_edge( g-&gt;next());\n    P.split_edge( g);                                              // Fig. (b)\n    h-&gt;next()-&gt;vertex()-&gt;point()     = Point( 1, 0, 1);\n    g-&gt;next()-&gt;vertex()-&gt;point()     = Point( 0, 1, 1);\n    g-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()-&gt;point() = Point( 1, 1, 0);            // Fig. (c)\n    Halfedge_handle f = P.split_facet( g-&gt;next(),            \n                                       g-&gt;next()-&gt;next()-&gt;next()); // Fig. (d)\n    Halfedge_handle e = P.split_edge( f);\n    e-&gt;vertex()-&gt;point() = Point( 1, 1, 1);                        // Fig. (e)\n    P.split_facet( e, f-&gt;next()-&gt;next());                          // Fig. (f)\n    CGAL_postcondition( P.is_valid());\n    return h;\n}\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;         Polyhedron;\ntypedef Polyhedron::Halfedge_handle        Halfedge_handle;\n\nint main() {\n    Polyhedron P;\n    Halfedge_handle h = make_cube_3( P);\n    return (P.is_tetrahedron(h) ? 1 : 0);\n}\n</pre>\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>27.4&nbsp;&nbsp;&nbsp;File I/O</h2>\n\n<A NAME=\"sectionPolyIO\"></A>\n<P>\n\nSimple file I/O for polyhedral surfaces is already provided in the\nlibrary. The file I/O considers so far only the topology of the\nsurface and its point coordinates. It ignores a possible plane\nequation or any user-added attributes, such as color.\n<P>\n\nThe default file format supported in C<SMALL>GAL</SMALL> for output as well as for\ninput is the <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> File Format, OFF, with file extension <TT>.off</TT>,\nwhich is also understood by GeomView&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:p-gmgv16-96\">Phi96</A>]. For OFF\nan <A HREF=\"../IOstream_ref/Enum_Mode#Enum_Mode\">ASCII</A> and a binary format exist. The format can be selected with\nthe C<SMALL>GAL</SMALL> modifiers for streams, <I><A HREF=\"../IOstream_ref/Function_set_ascii_mode.html#Cross_link_anchor_1744\">set_ascii_mode</A></I> and\n<I><A HREF=\"../IOstream_ref/Function_set_binary_mode.html#Cross_link_anchor_1746\">set_binary_mode</A></I> respectively. The modifier <I><A HREF=\"../IOstream_ref/Function_set_pretty_mode.html#Cross_link_anchor_1750\">set_pretty_mode</A></I>\ncan be used to allow for (a few) structuring comments in the\noutput. Otherwise, the output would be free of comments.  The default\nfor writing is <A HREF=\"../IOstream_ref/Enum_Mode#Enum_Mode\">ASCII</A> without comments. Both, <A HREF=\"../IOstream_ref/Enum_Mode#Enum_Mode\">ASCII</A> and binary format,\ncan be read independent of the stream setting. Since this file format\nis the default format, iostream operators are provided for it.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Polyhedron_iostream.h\">CGAL/IO/Polyhedron_iostream.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class <A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     ostream&amp; out &lt;&lt;  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt; P<A NAME=\"Function_ostream__operator666_ostream__out+_const_CGAL::Polyhedron_36PolyhedronTraits_39__P9;\"></A>\n\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class <A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    istream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     istream&amp; in &gt;&gt;  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;&amp; P<A NAME=\"Function_istream__operator996_istream__in+_CGAL::Polyhedron_36PolyhedronTraits_39__P9;\"></A>\n\n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\nAdditional formats supported for writing are OpenInventor (<TT>.iv</TT>)\n[<A HREF=\"../biblio.html#Biblio_cgal:w-impoo-94\">Wer94</A>], VRML 1.0 and 2.0 (<TT>.wrl</TT>)\n[<A HREF=\"../biblio.html#Biblio_cgal:bpp-vrml-95\">BPP95</A>, <A HREF=\"../biblio.html#Biblio_cgal:vrmls-96\">VRM96</A>, <A HREF=\"../biblio.html#Biblio_cgal:hw-vrml2h-96\">HW96</A>], and Wavefront Advanced\nVisualizer object format (<TT>.obj</TT>). Another convenient output\nfunction writes a polyhedral surface to a GeomView process spawned\nfrom the C<SMALL>GAL</SMALL> program.  These output functions are provided as\nstream operators, now acting on the stream type of the respective\nformat.\n<P>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Polyhedron_inventor_ostream.h\">CGAL/IO/Polyhedron_inventor_ostream.h</A>&gt;</I>\n<P>\n\n<BR>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Polyhedron_VRML_1_ostream.h\">CGAL/IO/Polyhedron_VRML_1_ostream.h</A>&gt;</I>\n<P>\n\n<BR>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Polyhedron_VRML_2_ostream.h\">CGAL/IO/Polyhedron_VRML_2_ostream.h</A>&gt;</I>\n<P>\n\n<BR>\n\n<I>#include &lt;<A HREF=\"../../../include/CGAL/IO/Polyhedron_geomview_ostream.h\">CGAL/IO/Polyhedron_geomview_ostream.h</A>&gt;</I>\n<P>\n\n<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class <A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    Inventor_ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     Inventor_ostream&amp; out &lt;&lt;  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt; P<A NAME=\"Function_Inventor_ostream__operator666_Inventor_ostream__out+_const_CGAL::Polyhedron_36PolyhedronTraits_39__P9;\"></A>\n\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class <A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    VRML_1_ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     VRML_1_ostream&amp; out &lt;&lt;  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt; P<A NAME=\"Function_VRML_1_ostream__operator666_VRML_1_ostream__out+_const_CGAL::Polyhedron_36PolyhedronTraits_39__P9;\"></A>\n\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class <A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    VRML_2_ostream&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     VRML_2_ostream&amp; out &lt;&lt;  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt; P<A NAME=\"Function_VRML_2_ostream__operator666_VRML_2_ostream__out+_const_CGAL::Polyhedron_36PolyhedronTraits_39__P9;\"></A>\n\n        </I></NOBR>\n        \n    \n        </TR>\n        <TR><TD><BR></TD></TR>\n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>\n        <I><NOBR>\n    template &lt;class <A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt;\n        </I></NOBR>\n        </TD></TR>\n        \n        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>\n        <I><NOBR>\n    <A HREF=\"../Geomview_ref/Class_Geomview_stream.html#Cross_link_anchor_1760\">Geomview_stream</A>&amp;\n        </I></NOBR>\n        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>\n        <I><NOBR>\n     <A HREF=\"../Geomview_ref/Class_Geomview_stream.html#Cross_link_anchor_1760\">Geomview_stream</A>&amp; out &lt;&lt;  <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Polyhedron_ref/Concept_PolyhedronTraits_3.html#Cross_link_anchor_868\">PolyhedronTraits_3</A>&gt; P<A NAME=\"Function_Geomview_stream__operator666_Geomview_stream__out+_const_CGAL::Polyhedron_36PolyhedronTraits_39__P9;\"></A>\n\n        </I></NOBR>\n        \n    \n        </TR>\n        </TABLE>\n<P>\n\nAll these file formats have in common that they represent a surface as\na set of facets. Each facet is a list of indices pointing into a set\nof vertices. Vertices are represented as coordinate triples. The\nfile I/O for polyhedral surfaces <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A></I> imposes certain \nrestrictions on these formats. They must represent a permissible \npolyhedral surface, e.g., a 2-manifold and no isolated vertices, see \nSection&nbsp;<A HREF=\"Chapter_main.html#sectionPolyIntro\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>.\n<P>\n\nSome example programs around the different file formats are provided\nin the distribution under <TT>examples/Polyhedron_IO/</TT> and\n<TT>demo/Polyhedron_IO/</TT>. We show an example converting OFF input\ninto VRML 1.0 output.\n<P>\n\n<pre class=\"ExampleCode\">\n// examples/Polyhedron_IO/polyhedron2vrml.C\n// ----------------------------------------\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Polyhedron_iostream.h&gt;\n#include &lt;CGAL/IO/Polyhedron_VRML_1_ostream.h&gt; \n#include &lt;iostream&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt; <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;     Polyhedron;\n\nint main() {\n    Polyhedron P;\n    std::cin &gt;&gt; P;\n    CGAL::VRML_1_ostream out( std::cout);\n    out &lt;&lt; P;\n    return ( std::cin &amp;&amp; std::cout) ? 0 : 1;\n}\n</pre>\n<P>\n\n<a name=\"Section_5\"></a>\n        \n<h2>27.5&nbsp;&nbsp;&nbsp;Extending Vertices, Halfedges, and Facets</h2>\n\n<A NAME=\"sectionPolyExtend\"></A>\n<P>\n\nIn Section&nbsp;<A HREF=\"Chapter_main.html#sectionPolyVector\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> we have seen how to change the \ndefault list representation\n<P>\n\n<pre class=\"ExampleCode\">\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt; Traits, \n                            <A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A>, \n                            <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_default.html#Cross_link_anchor_882\">CGAL::HalfedgeDS_default</A>&gt;      Polyhedron;\n</pre>\n<P>\n\nto a vector based representation of the underlying halfedge data\nstructure. Now we want to look a bit closer at the second template argument,\n<TT><A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_865\">Polyhedron_items_3</A></TT>, that specifies what kind of vertex, \nhalfedge, and facet is used. The implementation of \n<TT><A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_865\">Polyhedron_items_3</A></TT> looks a bit involved with nested \nwrapper class templates. But ignoring this technicality, what remains\nare three local typedefs that define the <TT>Vertex</TT>, the\n<TT>Halfedge</TT>, and the <TT>Face</TT> for the polyhedral surface.\nNote that we use here <TT>Face</TT> instead of facet. Face is the term\nused for the halfedge data structure. Only the top layer of the\npolyhedral surface gives alias names renaming face to facet.\n<P>\n\n<pre class=\"ExampleCode\">\nclass <A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_865\">Polyhedron_items_3</A> {\npublic:\n    template &lt; class Refs, class Traits&gt;\n    struct Vertex_wrapper {\n        typedef typename Traits::<A HREF=\"../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74\">Point_3</A> Point;\n        typedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_vertex_base.html#Cross_link_anchor_903\">CGAL::HalfedgeDS_vertex_base</A>&lt;Refs, <A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A>, Point&gt; Vertex;\n    };\n    template &lt; class Refs, class Traits&gt;\n    struct Halfedge_wrapper {\n        typedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_halfedge_base.html#Cross_link_anchor_889\">CGAL::HalfedgeDS_halfedge_base</A>&lt;Refs&gt;                      Halfedge;\n    };\n    template &lt; class Refs, class Traits&gt;\n    struct Face_wrapper {\n        typedef typename Traits::<A HREF=\"../Kernel_23_ref/Class_Plane_3.html#Cross_link_anchor_72\">Plane_3</A> Plane;\n        typedef <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_face_base.html#Cross_link_anchor_885\">CGAL::HalfedgeDS_face_base</A>&lt;Refs, <A HREF=\"../Kernel_23_ref/Class_Tag_true.html#Cross_link_anchor_477\">CGAL::Tag_true</A>, Plane&gt;   Face;\n    };\n};\n</pre>\n<P>\n\nIf we look up in the reference manual the definitions of the three\nclasses used in the typedefs, we will see the confirmation that the\ndefault polyhedron uses all supported incidences, a point in the\nvertex class, and a plane equation in the face class. Note how the\nwrapper class provides two template parameters, <TT>Refs</TT>, which\nwe discuss a bit later, and <TT>Traits</TT>, which is the geometric\ntraits class used by the polyhedral surface and which provides us here\nwith the types for the point and the plane equation.\n<P>\n\nUsing this example code we can write our own items class. Instead, we\nillustrate an easier way if we only want to exchange one class. We use\na simpler face without the plane equation but with a color attribute\nadded. To simplify the creation of a vertex, halfedge, or face class,\nit is always recommended to derive from one of the given base classes.\nEven if the base class would contain no data it would provide\nconvenient type definitions. So, we derive from the base class, repeat\nthe mandatory constructors if necessary - which is not the case for\nfaces but would be for vertices - and add the color attribute.\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt;class Refs&gt;\nstruct My_face : public <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_face_base.html#Cross_link_anchor_885\">CGAL::HalfedgeDS_face_base</A>&lt;Refs&gt; {\n    <A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A> color;\n};\n</pre>\n<P>\n\nThe new items class is derived from the old items class and the\nwrapper containing the face typedef gets overridden. Note that the\nname of the wrapper and its template parameters are fixed. They cannot\nbe changed even if, as in this example, a template parameter is not\nused.\n<P>\n\n<pre class=\"ExampleCode\">\nstruct My_items : public <A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A> {\n    template &lt;class Refs, class Traits&gt;\n    struct Face_wrapper {\n        typedef My_face&lt;Refs&gt; Face;\n    };\n};\n</pre>\n<P>\n\nWhen we use our new items class with the polyhedral surface, our new\nface class is used in the halfedge data structure and the color\nattribute is available in the type <TT>Polyhedron::Facet</TT>. However,\n<TT>Polyhedron::Facet</TT> is not the same type as our local face \ntypedef for <TT>My_face</TT>, but it is derived therefrom. Thus,\neverything that we put in the local face type except constructors is\nthen available in the <TT>Polyhedron::Facet</TT> type. For more\ndetails, see the Chapter&nbsp;<A HREF=\"../HalfedgeDS/Chapter_main.html#chapterHalfedgeDS\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A> on the halfedge data\nstructure design.\n<P>\n\nPulling all pieces together, the full example program illustrates how easy\nthe color attribute can be accessed once it is defined.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_color.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/IO/<A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1754\">Color</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n\n// A face type with a color member variable.\ntemplate &lt;class Refs&gt;\nstruct My_face : public <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_face_base.html#Cross_link_anchor_885\">CGAL::HalfedgeDS_face_base</A>&lt;Refs&gt; {\n    <A HREF=\"../Colors_and_windows_ref/Class_Color.html#Cross_link_anchor_1753\">CGAL::Color</A> color;\n};\n\n// An items type using my face.\nstruct My_items : public <A HREF=\"../Polyhedron_ref/Class_Polyhedron_items_3.html#Cross_link_anchor_864\">CGAL::Polyhedron_items_3</A> {\n    template &lt;class Refs, class Traits&gt;\n    struct Face_wrapper {\n        typedef My_face&lt;Refs&gt; Face;\n    };\n};\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;        <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>, My_items&gt;  Polyhedron;\ntypedef Polyhedron::Halfedge_handle           Halfedge_handle;\n\nint main() {\n    Polyhedron P;\n    Halfedge_handle h = P.make_tetrahedron();\n    h-&gt;facet()-&gt;color = CGAL::RED;\n    return 0;\n}\n</pre>\n<P>\n\nWe come back to the first template parameter, <TT>Refs</TT>, of the\nwrapper classes. This parameter provides us with local types that\nallow us to make further references between vertices, halfedges, and\nfacets, which have not already been prepared for in the current\ndesign. These local types are <TT>Vertex_handle</TT>,\n<TT>Halfedge_handle</TT>, <TT>Face_handle</TT>, and there respective\n<TT>..._const_handle</TT>. We add now a new vertex reference to a\nface class as follows. Encapsulation and access functions could be\nadded for a more thorough design, but we omit that here for the sake\nof brevity. The integration of the face class with the items class\nworks as illustrated above.\n<P>\n\n<pre class=\"ExampleCode\">\ntemplate &lt;class Refs&gt;\nstruct My_face : public <A HREF=\"../HalfedgeDS_ref/Class_HalfedgeDS_face_base.html#Cross_link_anchor_885\">CGAL::HalfedgeDS_face_base</A>&lt;Refs&gt; {\n    typedef typename Refs::Vertex_handle Vertex_handle;\n    Vertex_handle vertex_ref;\n};\n</pre>\n<P>\n\nMore advanced examples can be found in the Section&nbsp;<A HREF=\"../HalfedgeDS/Chapter_main.html#sectionHdsExamples\"><IMG SRC=\"cc_ref_up_arrow.gif\" ALT=\"reference\" WIDTH=\"10\" HEIGHT=\"10\"></A>\nillustrating further the design of the halfedge data structure.\n<P>\n\n<a name=\"Section_6\"></a>\n        \n<h2>27.6&nbsp;&nbsp;&nbsp;Advanced Example Programs</h2>\n\n<A NAME=\"sectionPolyAdvanced\"></A>\n<P>\n\n<h3>27.6.1&nbsp;&nbsp;&nbsp;Example Creating a Subdivision Surface</h3>\n<P>\n\nThis program reads a polyhedral surface from the standard input and\nwrites a refined polyhedral surface to the standard output. Input and\noutput are in the <A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A> File Format, OFF, with the common file\nextension <TT>.off</TT>, which is also understood by\nGeomView&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:p-gmgv16-96\">Phi96</A>].\n<P>\n\nThe refinement is a single step of the <MATH><I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A>(3)</I></MATH>-scheme for creating\na subdivision surface&nbsp;[<A HREF=\"../biblio.html#Biblio_cgal:k-s-00\">Kob00</A>]. Each step subdivides a facet\ninto triangles around a new center vertex, smoothes the position of the\nold vertices, and flips the old edges. The program is organized along\nthis outline. In each of these parts, the program efficiently uses the\nknowledge that the newly created vertices, edges, and facets have been\nadded to the end of the sequences. The program needs additional\nprocessing memory only for the smoothing step of the old vertices.\n<P>\n\n<CENTER>\n        <A HREF=\"./fig/subdiv.gif\">\n            <img src=\"./fig/subdiv_small.gif\" alt=\"subdivision examples\">\n        </A>\n<P>\n\n</CENTER>\n<P>\n\nThe above figure shows three example objects, each \nsubdivided four times. The initial object for the left sequence is\nthe closed surface of three unit cubes glued together to a corner.\nThe example program shown here can handle only closed surfaces, \nbut the extended example\n<TT>examples/Polyhedron/polyhedron_prog_subdiv_with_boundary.C</TT>\nhandles surfaces with boundary. So, the middle sequence starts with\nthe same surface where one of the facets has been removed. The boundary\nsubdivides to a nice circle. The third sequence creates a sharp\nedge using a trick in the object presentation. The sharp edge is \nactually a hole whose vertex coordinates pinch the hole shut to form an\nedge. The example directory <TT>examples/Polyhedron/</TT> contains the \nOFF files used here.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_subdiv.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n#include &lt;CGAL/IO/Polyhedron_iostream.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_5\">CGAL::Cartesian</A>&lt;double&gt;                              <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Kernel_23_ref/FunctionObjectConcept_Kernel--Vector_3.html#Cross_link_anchor_474\">Kernel::Vector_3</A>                                     <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A>;\ntypedef <A HREF=\"../Kernel_23_ref/Concept_Kernel--Point_3.html#Cross_link_anchor_460\">Kernel::Point_3</A>                                      Point;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;                           Polyhedron;\n\ntypedef Polyhedron::Vertex                                   Vertex;\ntypedef Polyhedron::Vertex_iterator                          Vertex_iterator;\ntypedef Polyhedron::Halfedge_handle                          Halfedge_handle;\ntypedef Polyhedron::Edge_iterator                            Edge_iterator;\ntypedef Polyhedron::Facet_iterator                           Facet_iterator;\ntypedef Polyhedron::Halfedge_around_vertex_const_circulator  HV_circulator;\ntypedef Polyhedron::Halfedge_around_facet_circulator         HF_circulator;\n\nvoid create_center_vertex( Polyhedron&amp; P, Facet_iterator f) {\n    <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A> vec( 0.0, 0.0, 0.0);\n    std::size_t order = 0;\n    HF_circulator h = f-&gt;facet_begin();\n    do {\n        vec = vec + ( h-&gt;vertex()-&gt;point() - <A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A>);\n        ++ order;\n    } while ( ++h != f-&gt;facet_begin());\n    CGAL_assertion( order &gt;= 3); // guaranteed by definition of polyhedron\n    Point center =  <A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A> + (vec / order);\n    Halfedge_handle new_center = P.create_center_vertex( f-&gt;halfedge());\n    new_center-&gt;vertex()-&gt;point() = center;\n}\n\nstruct Smooth_old_vertex {\n    Point operator()( const Vertex&amp; v) const {\n        CGAL_precondition((<A HREF=\"../Circulator_ref/Function_circulator_size.html#Cross_link_anchor_1605\">CGAL::circulator_size</A>( v.vertex_begin()) &amp; 1) == 0);\n        std::size_t degree = <A HREF=\"../Circulator_ref/Function_circulator_size.html#Cross_link_anchor_1605\">CGAL::circulator_size</A>( v.vertex_begin()) / 2;\n        double alpha = ( 4.0 - 2.0 * cos( 2.0 * CGAL_PI / degree)) / 9.0;\n        <A HREF=\"../Kernel_d_ref/Concept_Vector.html#Cross_link_anchor_480\">Vector</A> vec = (v.point() - <A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A>) * ( 1.0 - alpha);\n        HV_circulator h = v.vertex_begin();\n        do {\n            vec = vec + ( h-&gt;<A HREF=\"../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243\">opposite</A>()-&gt;vertex()-&gt;point() - <A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A>) \n                       * alpha / degree;\n            ++ h;\n            CGAL_assertion( h != v.vertex_begin()); // even degree guaranteed\n            ++ h;\n        } while ( h != v.vertex_begin());\n        return (<A HREF=\"../Kernel_23_ref/Constant_ORIGIN.html#Cross_link_anchor_140\">CGAL::ORIGIN</A> + vec);\n    }\n};\n\nvoid flip_edge( Polyhedron&amp; P, Halfedge_handle e) {\n    Halfedge_handle h = e-&gt;next();\n    P.join_facet( e);\n    P.split_facet( h, h-&gt;next()-&gt;next());\n}\n\nvoid subdiv( Polyhedron&amp; P) {\n    if ( P.size_of_facets() == 0)\n        return;\n    // We use that new vertices/halfedges/facets are appended at the end.\n    std::size_t nv = P.size_of_vertices();\n    Vertex_iterator last_v = P.vertices_end();\n    -- last_v;  // the last of the old vertices\n    Edge_iterator last_e = P.edges_end();\n    -- last_e;  // the last of the old edges\n    Facet_iterator last_f = P.facets_end();\n    -- last_f;  // the last of the old facets\n\n    Facet_iterator f = P.facets_begin();    // create new center vertices\n    do {\n        create_center_vertex( P, f);\n    } while ( f++ != last_f);\n\n    std::vector&lt;Point&gt; pts;                    // smooth the old vertices\n    pts.reserve( nv);  // get intermediate space for the new points\n    ++ last_v; // make it the past-the-end position again\n    std::transform( P.vertices_begin(), last_v, std::back_inserter( pts), \n                    Smooth_old_vertex());\n    std::copy( pts.begin(), pts.end(), P.points_begin());\n\n    Edge_iterator e = P.edges_begin();              // flip the old edges\n    ++ last_e; // make it the past-the-end position again\n    while ( e != last_e) {\n        Halfedge_handle h = e;\n        ++e; // careful, incr. before flip since flip destroys current edge\n        flip_edge( P, h);\n    };\n    CGAL_postcondition( P.is_valid());\n}\n\nint main() {\n    Polyhedron P;\n    std::cin &gt;&gt; P;\n    P.normalize_border();\n    if ( P.size_of_border_edges() != 0) {\n        std::cerr &lt;&lt; &quot;The input object has border edges. Cannot subdivide.&quot; \n                  &lt;&lt; std::endl;\n        std::exit(1);\n    }\n    subdiv( P);\n    std::cout &lt;&lt; P;\n    return 0;\n}\n</pre>\n<P>\n\n<h3>27.6.2&nbsp;&nbsp;&nbsp;Example Using the Incremental Builder and Modifier Mechanism</h3>\n<P>\n\nA utility class <I><A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_861\">CGAL::Polyhedron_incremental_builder_3</A></I> helps in\ncreating polyhedral surfaces from a list of points followed by a list\nof facets that are represented as indices into the point list. This is\nparticularly useful for implementing file reader for common file\nformats.  It is used here to create a triangle.\n<P>\n\nA modifier mechanism allows to access the internal representation of\nthe polyhedral surface, i.e., the halfedge data structure, in a\ncontrolled manner. A modifier is basically a callback mechanism using\na function object. When called, the function object receives the\ninternal halfedge data structure as a parameter and can modify it.  On\nreturn, the polyhedron can check the halfedge data structure for\nvalidity. Such a modifier object must always return with a halfedge\ndata structure that is a valid polyhedral surface. The validity check is\nimplemented as an expensive postcondition at the end of the <I>delegate()</I>\nmember function, i.e., it is not called by default, only when expensive\nchecks are activated.\n<P>\n\nIn this example, <I>Build_triangle</I> is such a function object\nderived from <I><A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A>&lt;<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>&gt;</I>. The <I>delegate()</I>\nmember function of the polyhedron accepts this function object and calls\nits <I>operator()</I> with a reference to its internally used halfedge \ndata structure. Thus, this member function in <I>Build_triangle</I> can \ncreate the triangle in the halfedge data structure.\n<P>\n\n<pre class=\"ExampleCode\">// file: examples/Polyhedron/polyhedron_prog_incr_builder.C\n\n#include &lt;CGAL/<A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30\">Simple_cartesian</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_862\">Polyhedron_incremental_builder_3</A>.h&gt;\n#include &lt;CGAL/<A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854\">Polyhedron_3</A>.h&gt;\n\n// A modifier creating a triangle with the incremental builder.\ntemplate &lt;class HDS&gt;\nclass Build_triangle : public <A HREF=\"../Modifier_ref/Class_Modifier_base.html#Cross_link_anchor_1715\">CGAL::Modifier_base</A>&lt;HDS&gt; {\npublic:\n    Build_triangle() {}\n    void operator()( HDS&amp; hds) {\n        // Postcondition: `hds' is a valid polyhedral surface.\n        <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3.html#Cross_link_anchor_861\">CGAL::Polyhedron_incremental_builder_3</A>&lt;HDS&gt; B( hds, true);\n        B.begin_surface( 3, 1, 6);\n        typedef typename HDS::Vertex   Vertex;\n        typedef typename Vertex::Point Point;\n        B.add_vertex( Point( 0, 0, 0));\n        B.add_vertex( Point( 1, 0, 0));\n        B.add_vertex( Point( 0, 1, 0));\n        B.begin_facet();\n        B.add_vertex_to_facet( 0);\n        B.add_vertex_to_facet( 1);\n        B.add_vertex_to_facet( 2);\n        B.end_facet();\n        B.end_surface();\n    }\n};\n\ntypedef <A HREF=\"../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_29\">CGAL::Simple_cartesian</A>&lt;double&gt;     <A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>;\ntypedef <A HREF=\"../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_853\">CGAL::Polyhedron_3</A>&lt;<A HREF=\"../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0\">Kernel</A>&gt;         Polyhedron;\ntypedef Polyhedron::<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>             <A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>;\n\nint main() {\n    Polyhedron P;\n    Build_triangle&lt;<A HREF=\"../HalfedgeDS_ref/Concept_HalfedgeDS.html#Cross_link_anchor_873\">HalfedgeDS</A>&gt; triangle;\n    P.delegate( triangle);\n    CGAL_assertion( P.is_triangle( P.halfedges_begin()));\n    return 0;\n}\n</pre>\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Polyhedron_ref/Chapter_intro.html\">3D Polyhedral Surfaces</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_27!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38474.0}