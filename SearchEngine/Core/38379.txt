{"text": "Navigation Up Table of Contents Bibliography Index Title Page Chapter 4Predicates and Constructions 4 1 Predicates Predicates are at the heart of a geometry kernel They are basic units for the composition of geometric algorithms and encapsulate decisisons Hence their correctness is crucial for the control flow and hence for the correctness of an implementation of a geometric algorithm CGAL uses the term predicate in a generalized sense Not only components returning a Boolean value are called predicates but also components returning an enumeration type like a Comparison result or an Orientation We say components because predicates are implemented both as functions and function objects also called functors and provided by a kernel class CGAL provides predicates for the orientation of point sets orientation for comparing points according to some given order especially for comparing Cartesian coordinates e g lexicographically xy smaller in sphere tests and predicates to compare distances 4 2 Constructions Functions and function objects that generate objects that are neither of type bool nor enum types are called constructions Constructions involve computation of new numerical values and may be imprecise due to rounding errors unless a kernel with an exact number type is used Affine transformations Aff transformation d R allow to generate new object instances under arbitrary affine transformations These transformations include translations rotations within planes and scaling Most of the geometric objects in a kernel have a member function transform Aff transformation t which applies the transformation to the object instance CGAL also provides a set of functions that detect or compute the intersection between objects and functions to calculate their squared distance Moreover some member functions of kernel objects are constructions So there are routines that compute the square of the Euclidean distance but no routines that compute the distance itself Why First of all the two values can be derived from each other quite easily by taking the square root or taking the square So supplying only the one and not the other is only a minor inconvenience for the user Second often either value can be used This is for example the case when squared distances are compared Third the library wants to stimulate the use of the squared distance instead of the distance The squared distance can be computed in more cases and the computation is cheaper We do this by not providing the perhaps more natural routine The problem of a distance routine is that it needs the sqrt operation This has two drawbacks The sqrt operation can be costly Even if it is not very costly for a specific number type and platform avoiding it is always cheaper There are number types on which no sqrt operation is defined especially integer types and rationals 4 3 Intersection and Polymorphic Return Values Intersections on kernel objects currently cover only those objects that are part of flats Segment d R Ray d R Line c R and Hyperplane d R For any pair of objects o1 o2 of these types the operation intersection o1 o2 returns a polymorphic object that wraps the result of the intersection operation The class Object provides the polymorphic abstraction An object obj of type Object can represent an arbitrary class The only operations it provides is to make copies and assignments so that you can put them in lists or arrays Note that Object is NOT a common base class for the elementary classes Therefore there is no automatic conversion from these classes to Object Rather this is done with the global function make object This encapsulation mechanism requires the use of assign to unwrap the encapsulated class ExampleIn the following example the object type is used as a return value for the intersection computation as there are possibly different return values Point d Cartesian d double p Segment d Cartesian d double s s1 s2 std cin s1 s2 Object obj intersection s1 s2 if assign p obj do something with p else if assign s obj do something with s there was no intersection 4 4 Constructive Predicates For testing where a point p lies with respect to a hyperplane defined by an array P of points p1 pd one may be tempted to construct the hyperplane Hyperplane d R d P P d and use the method oriented side p This may pay off if many tests with respect to the plane are made Nevertheless unless the number type is exact the constructed plane is only approximated and round off errors may lead oriented side p to return an orientation which is different from the orientation of p1 pd p In CGAL we provide predicates in which such geometric decisions are made directly with a reference to the input points in P without an intermediary object like a plane For the above test the recommended way to get the result is to use orientation P P d where P is an array containing the points p1 pd p For exact number types like leda real the situation is different If several tests are to be made with the same plane it pays off to construct the plane and to use oriented side p Next chapter Reference Pages Navigation Table of Contents Bibliography Index Title Page The CGAL Project Tue December 21 2 4 ", "_id": "http://www.ics.uci.edu/~dock/manuals/cgal_manual/Kernel_d/Chapter_predicates_constructions_d.html", "title": "predicates and constructions", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<!-- Page automatically generated from latex_to_html converter. -->\n<!-- by cc_extract_html, $Revision: 3.19 $ -->\n<!-- LaTeX source file: './Kernel_d/predicates_constructions_d.tex' -->\n<html> <head>  \n<title>Predicates and Constructions</title>\n</head>  \n<link href=\"../latex_to_html.css\" rel=\"STYLESHEET\">\n<body bgcolor=\"white\">\n<!-- ------------------------------------------------------------------- -->\n\n\n<!-- Top Navigation ---------------------------------------------------- -->\n<div class=\"NavTop\">\n<hr>\n  <strong>Navigation:</strong>\n<a href=\"Chapter_predicates_constructions_d.html\">Up</a>, \n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<hr><!-- End of Top Navigation ----------------------------------------- -->\n</div>\n\n<a name=\"Chapter_4\"></a>\n  \n<h1>Chapter 4<BR>Predicates and Constructions</h1>\n<P>\n\n<a name=\"Section_1\"></a>\n        \n<h2>4.1&nbsp;&nbsp;&nbsp;Predicates</h2>\n\nPredicates are at the heart of a geometry kernel. They are basic units\nfor the composition of geometric algorithms and encapsulate\ndecisisons.  Hence their correctness is crucial for the control flow\nand hence for the correctness of an implementation of a geometric\nalgorithm. C<SMALL>GAL</SMALL> uses the term predicate in a generalized sense. Not\nonly components returning a Boolean value are called predicates but\nalso components returning an enumeration type like a\n<I><A HREF=\"../Kernel_23_ref/Enum_Comparison_result.html#Cross_link_anchor_104\">Comparison_result</A></I> or an <I><A HREF=\"../Kernel_23_ref/Enum_Orientation.html#Cross_link_anchor_114\">Orientation</A></I>.  We say components,\nbecause predicates are implemented both as functions and function\nobjects (also called functors and provided by a kernel class).\n<P>\n\nC<SMALL>GAL</SMALL> provides predicates for the \n<!-- REMOVE_LINKS_BEGIN -->\norientation\n<!-- REMOVE_LINKS_END -->\n of\npoint sets (<I><A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A></I>), for comparing points according to some\ngiven order, especially for comparing <A HREF=\"../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6\">Cartesian</A> coordinates\n(e.g.&nbsp;<I><A HREF=\"../Kernel_23_ref/Function_lexicographically_xy_smaller.html#Cross_link_anchor_233\">lexicographically_xy_smaller</A></I>), in-sphere tests, and\npredicates to <A HREF=\"../NumberTypeSupport_ref/Function_compare.html#Cross_link_anchor_1339\">compare</A> distances.\n<P>\n\n<a name=\"Section_2\"></a>\n        \n<h2>4.2&nbsp;&nbsp;&nbsp;Constructions</h2>\n\nFunctions and function objects that generate objects that are neither\nof type <I>bool</I> nor <A HREF=\"../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum\">enum</A> types are called constructions.\nConstructions involve computation of new numerical values and may be\nimprecise due to rounding errors unless a kernel with an exact number\ntype is used.\n<P>\n\nAffine transformations (<I><A HREF=\"../Kernel_d_ref/Class_Aff_transformation_d.html#Cross_link_anchor_505\">Aff_transformation_d</A>&lt;R&gt;</I>) allow to\ngenerate new object instances under arbitrary affine transformations.\nThese transformations include translations, rotations (within planes)\nand scaling. Most of the geometric objects in a kernel have a member\nfunction <I>transform(Aff_transformation t)</I> which applies the\ntransformation to the object instance.\n<P>\n\nC<SMALL>GAL</SMALL> also provides a set of functions that detect or compute the\n\n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n between objects\nand functions to calculate their squared\ndistance.  Moreover, some\nmember functions of kernel objects are constructions.\n<P>\n\nSo there are routines that compute the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> of the Euclidean\ndistance, but no routines that compute the distance itself. Why?\nFirst of all, the two values can be derived from each other quite\neasily (by taking the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A> root or taking the <A HREF=\"../NumberTypeSupport_ref/Function_square.html#Cross_link_anchor_1418\">square</A>). So, supplying\nonly the one and not the other is only a minor inconvenience for the\nuser.  Second, often either value can be used. This is for example the\ncase when (squared) distances are compared.  Third, the library wants\nto stimulate the use of the squared distance instead of the distance.\nThe squared distance can be computed in more cases and the computation\nis cheaper.  We do this by not providing the perhaps more natural\nroutine, The problem of a distance routine is that it needs the\n<I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A></I> operation.  This has two drawbacks:\n<UL>\n<LI>The <I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A></I> operation can be costly. Even if it is not\n  very costly for a specific number type and platform, avoiding it is\n  always cheaper.\n<LI>There are number types on which no <I><A HREF=\"../NumberTypeSupport_ref/Function_sqrt.html#Cross_link_anchor_1414\">sqrt</A></I> operation is\n  defined, especially integer types and rationals.\n</UL>\n<P>\n\n<a name=\"Section_3\"></a>\n        \n<h2>4.3&nbsp;&nbsp;&nbsp;Intersection and Polymorphic Return Values</h2>\n<P>\n\nIntersections on kernel objects currently cover only those objects\nthat are part of flats (<I><A HREF=\"../Kernel_d_ref/Class_Segment_d.html#Cross_link_anchor_497\">Segment_d</A>&lt;R&gt;</I>, <I><A HREF=\"../Kernel_d_ref/Class_Ray_d.html#Cross_link_anchor_495\">Ray_d</A>&lt;R&gt;</I>,\n<I>Line_c&lt;R&gt;</I>, and <I><A HREF=\"../Kernel_d_ref/Class_Hyperplane_d.html#Cross_link_anchor_499\">Hyperplane_d</A>&lt;R&gt;</I>).  For any pair of objects\n<MATH><I>o1</I></MATH>, <MATH><I>o2</I></MATH> of these types the operation <I><A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>(o1,o2)</I>\nreturns a polymorphic object that wraps the result of the <A HREF=\"../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221\">intersection</A>\noperation.\n<P>\n\nThe class <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> provides the polymorphic abstraction.  An\nobject <I>obj</I> of type <I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> can represent an arbitrary\nclass. The only operations it provides is to make copies and\nassignments, so that you can put them in lists or arrays. Note that\n<I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> is NOT a common base class for the elementary classes.\nTherefore, there is no automatic conversion from these classes to\n<I><A HREF=\"../Kernel_23_ref/Class_Object.html#Cross_link_anchor_88\">Object</A></I> Rather this is done with the global function\n<I><A HREF=\"../Kernel_23_ref/Function_make_object.html#Cross_link_anchor_92\">make_object</A>()</I>. This encapsulation mechanism requires the use of\n<I><A HREF=\"../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90\">assign</A></I> to unwrap the encapsulated class.\n<P>\n\n<H3>Example</H3>In the following example, the object type is used as a return value for\nthe \n<!-- REMOVE_LINKS_BEGIN -->\nintersection\n<!-- REMOVE_LINKS_END -->\n computation, as there are\npossibly different return values.\n\n<!-- REMOVE_LINKS_BEGIN -->\n<PRE>\n  Point_d&lt; Cartesian_d&lt;double&gt; &gt; p;\n  Segment_d&lt; Cartesian_d&lt;double&gt; &gt; s, s1, s2;\n  std::cin &gt;&gt; s1 &gt;&gt; s2;\n  Object obj = intersection(s1, s2);\n  if ( assign(p, obj) ) {\n    /* do something with p */\n  } else if ( (assign(s, obj) ) {\n    /* do something with s */\n  }\n  /*  there was no intersection */\n</PRE>\n\n<!-- REMOVE_LINKS_END -->\n<P>\n\n<a name=\"Section_4\"></a>\n        \n<h2>4.4&nbsp;&nbsp;&nbsp;Constructive Predicates</h2>\n\nFor testing where a point <MATH><I>p</I></MATH> lies with respect to a hyperplane\ndefined by an array <MATH><I>P</I></MATH> of points <MATH><I>p<SUB>1</SUB></I></MATH>, ... , <MATH><I>p<SUB>d</SUB></I></MATH>, one may be\ntempted to construct the hyperplane <I><A HREF=\"../Kernel_d_ref/Class_Hyperplane_d.html#Cross_link_anchor_499\">Hyperplane_d</A>&lt;R&gt;(d,P,P+d)</I> and\nuse the method <I>oriented_side(p)</I>.  This may pay off if many tests\nwith respect to the plane are made.  Nevertheless, unless the number\ntype is exact, the constructed plane is only approximated, and\nround-off errors may lead <I>oriented_side(p)</I> to return an\n\n<!-- REMOVE_LINKS_BEGIN -->\norientation\n<!-- REMOVE_LINKS_END -->\n which is different from the\n\n<!-- REMOVE_LINKS_BEGIN -->\norientation\n<!-- REMOVE_LINKS_END -->\n of <MATH><I>p<SUB>1</SUB></I></MATH>, ... , <MATH><I>p<SUB>d</SUB></I></MATH>, <MATH><I>p</I></MATH>.\n<P>\n\nIn C<SMALL>GAL</SMALL>, we provide predicates in which such geometric decisions\nare made directly with a reference to the input points in <MATH><I>P</I></MATH> without\nan intermediary object like a plane.  For the above test, the\nrecommended way to get the result is to use\n<I><A HREF=\"../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247\">orientation</A>(P',P'+d)</I>, where <MATH><I>P'</I></MATH> is an array containing the\npoints <MATH><I>p<SUB>1</SUB></I></MATH>, ... , <MATH><I>p<SUB>d</SUB></I></MATH>, <MATH><I>p</I></MATH>.\n<P>\n\nFor exact number types like <I><A HREF=\"../NumberTypeSupport_ref/Class_leda_real.html#Cross_link_anchor_1390\">leda_real</A></I>, the situation is\ndifferent. If several tests are to be made with the same plane, it\npays off to construct the plane and to use <I>oriented_side(p)</I>.\n<P>\n\n<div class=\"NavNext\"><hr> Next chapter: <a href=\"../Kernel_d_ref/Chapter_main.html\">Reference Pages</a> \n\n\n    \n<div class=\"NavBottom\">\n<hr><!-- Bottom Navigation --------------------------------------------- -->\n  <strong>Navigation:</strong>\n<!Up_chapter_link_4!>\n  <a href=\"../contents.html\">Table of Contents</A>,\n  <a href=\"../biblio.html\">Bibliography</a>,\n  <a href=\"../manual_index.html\">Index</a>,\n  <a href=\"../title.html\">Title Page</a>\n<!-- End of Bottom Navigation ------------------------------------------ -->\n\n\n<hr><!-- --------------------------------------------------------------- -->\n<div class=\"NavAddress\">\n\nThe <A HREF=http://www.cgal.org>CGAL Project</A> .\n\nTue, December 21, 2004 .\n<hr></div>\n</body>  </html>  \n", "id": 38379.0}