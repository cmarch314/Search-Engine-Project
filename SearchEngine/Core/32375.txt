{"text": "Functional Requirements and Framework for Versioning on the WWW David G Durand and Fabio Vitali Changes from last version lock durationsseparate locking resource reservationclarify reorder pointsstyle free versioning Abstract This document describes the functional requirements for integrating versioning into the WWW Versioning is the fundamental basis of document management systems with far reaching effects on the semantics of document identity and meaningful operations These requirements reflect the basic versioning needs for document management and collaborative authoring It does not define the complete set of requirements for these domains where they extend beyond the versioning of resources 1 Introduction This document discusses why versioning is needed on the WWW and the functional requirements for full version support We have divided the requirements in three sections This discussion enumerates the reqirements for implementing such functionality as a first step to creating a specification that will address these needs We first briefly describe the rationale for versioning on the web in Section 2 This rationale enumerates the goals of versioning on the WWW All specific requirements should support and certainly should not hinder the realization of the goals Section 3 contains global requirements for protocol development These are things we think are technically justified and that fulfil the rationale They are separated from the other requirements because their acceptance creates further constraints on other technical requirements Finally In Section 4 we specific functional requirements based on the foundation established in the earlier sections We have based this effort on David Fiander s suggestion to separate versioning and configuration requirements and we assume a two layer architecture for versioning on the web The first layer whose requirements are defined in this document will address the simple problem of handling multiple versions of single resources The second layer will address the thornier problems of configuration management for multiple resources This layering simplifies both discussion and design 2 Rationale Versioning in the context of the world wide web offers a variety of benefits It provides infrastructure for efficient and controlled management of large evolving web sites Modern configuration management systems are built on some form of repository that can track the revision history of individual resources and provide the higher levelools to manage those saved versions Basic versioning capabilities are required to support such systems It allows parallel development and update of single resources Since versioning systems register change by creating new objects they enable simultaneous write access by allowing the creation of variant versions Many also provide merge support to ease the revers operation It provides a framework for access control over resources While specifics vary most systems provide some method of controlling or tracking access to enable collaborative resource development It allows browsing through past and alternative versions of a resource Frequently the modification and authorship history of a resource is critical information in itself It provides stable names that can support externally stored links for annotation and link server support Both annotation and link servers frequently need to store stable references to portions of resources that are not under their direct control By providing stable states of resources version control systems allow not only stable pointers into those resources but also well defined methods to determine the relationships of those states of a resource It allows explicit semantic representation of single resources with multiple states A versioning system directly represents the fact that a resource has an explicit history and a persistent identity across the various states it has had during the course of that history 3 Global requirements This section covers the overarching contraints that must inform and direct detailed requirements for versioning support They encompass compatibility across different implementations as well as compatibility with current practice Therefore we believe the following to be the general requirements for WWW versioning Stableness of versions Most versioning systems are intended to enable an accurate record of the history of evolution of a document This accuracy is ensured by the fact that a version eventually becomes frozen and immutable Once a version is frozen further changes will create new versions rather than modifying the original In order for caching and persistent references to be properly maintained a client must be able to determine that a version has been frozen We require that unlocked resource versions be frozen This enables the common practice of keeping unfrozen working versions Any successful attempt to retrieve a frozen version of a resource will always retrieve exactly the same content or return an error if that version or the resource itself are no longer available Since URLs may be reassigned at a server s discretion this requirement applies only for that period of time during which a URL identifies the same resource User Agent Interoperability All versioning aware user agents should be able to work with any versioning aware HTTP server It is acceptable for some user agent server combinations to provide special features that are not universally available but the protocol should be sufficient that a basic level of functionality will be universal Style free Versioning The protocol should not unnecessarily restrict version management style to any one paradigm For instance locking and version number assignment should be interoperable across servers and clients even if there are some differences in their preferred models Separation of access to resources and access control The protocol must separate the reservation and release of versioned resources from their access methods Provided that consistency constraints are met before during and after the modification of a versioned resource no right way to access to a resource is enforced by the protocol For instance a user may request declare an intention to write after a GET may POST a resource without releasing the lock and might even request a lock via HTTP connection while getting the document via FTP Legacy Resource Support The protocol should enable a versioning aware server to work with existing resources and URLs Special versioning information should not become a mandatory part of HTTP protocols except where it is required Special version information that would break existing clients and servers such as new mandatory headers cannot therefore be required for GET and possibly also for PUT Legacy User Agent Support Servers should make versioned resources accessible to versioning unaware user agents in a format acceptable to them Specific named version URLs that are constructed from a URL and an opaque version string Because the notation will be required to operate in the version control environment preferred by the website maintainer it must be able to properly contain arbitrary strings which may be used by the VCS as version identifiers While version information may be intelligible to the human operator and perhaps to special purpose clients the client must be able to treat the version specifier as a black box 4 Functional requirements The following functional reqirements are intended to satisfy the global requirements of Section 3 and enable the benefits listed in Section 2 The mention of possible new HTTP methods is intended to make the discussion clearer and more concrete not to rule out other methods of meeting the requirements The protocol should provide Access to specific named versions via a URL This is required for version specific linking and for legacy user agent support A URL to denote a versioned resource itself rather than specific versions of it This is more important if URL computations are not allowed since an identifier is needed for queries about the versioning status of a resource This is used to perform operations such as adjusting attributes changing locks or reassigning URLs that affect all versions of a resource rather than any specific version Direct access to a server defined default current or tip version of a resource This is one of the simplest ways to guarantee legacy user agent compatibility and legacy file compatibility If no special version URLs are used the server will provide a default This does not rule out the possibility of a server returning an error in case no such default exists A way to access common related URLs from a versioned URL whether by server query URL computation or some other way root version s of this documentpredecessor version s of this documentsuccessor version s of this documentdefault version of this document Some versions of a resource are special It must be possible in some way for a versioning aware client to access common related versions to the one it currently is displaying Possible solutions include but are not limited to the server automatically adding header fields to a versioned URL specifying the URL of the common related versions the server providing one or more query methods who is the previous version to this URL or a standardized way to compute related URLs when given a versioned URL We feel that access to the default version of a resource is an extremely important operation that a browser should be able to perform at any time that a versioned URL is seen A way to retrieve the complete version topology for this resource There should be a way to retrieve information about all versions of a resource The format for this information must be standardized so that the basic information can be used by all clients Some way to determine that a URL points to a named version of a resource This might be implemented as part of the URL format a server query or additional headers Some way to determine a version identification and a resource identification for a versioned resource given its URL This requirement describe the ability to take the URL of a version of a resource and determine a URL for the resourcea version identifier for the resource Note that this kind of facility supports only some comparison operations It enables the determination that two version containing URLs designate versions of the same resource However given the phenomenon of URL aliasing it is insufficient to determine that they are not versions of the same resource This is sort of a minimal browsing through time requirement Tthis requirement allows a browser to tell that a versioned resource has been accessed and then to invoke special versioning or configuration management operations on the resource While client performance will be best if this can be done via URL computation ie mangling it could also be done by an extra query and round trip to the server A way to request exclusive access to a version of a resource LOCK Since not all systems implement lock based access there is a question as how this should be implemented Client use of this method could be optional allowing some relatively strong guarantee on the meaning of acquiring a lock Alternatively clients could be expected to take a lock but servers might implement different locking policies possible even including implementation of LOCK and UNLOCK as NOPS A way to specify a timeout after which a lock will lapse In many cases locks over a certain duration are due to errors and their strict enforcement can cause more problems than inadvertent version skew We should allow locks to have a lifetime It may prove a good idea to have a finite default lifetime defined by the protocol If a universal default is too constraining there should be a way for a server to inform the client what the lifetime of a lock is Servers should honor client lock lifetime requests or inform them if the request is denied A way to release exclusive acccess to a resource UNLOCK This is the inverse of LOCK A way for a client to declare an intention to modify a resource RESERVE or CHECKOUT This operation is required before any versioned update Its effects may vary depending on server policy from locking a resource to forking a new variant to a NOP on servers that do not track sessions or restrict updates If this operation returns a version number the client is required to make sure that it uses a copy of the data associated with that version number of the resource for any update operations it carries out Servers that wish to enforce a mandatory GET operation before update should simply use a fresh version identifier on the return from this operation A way to declare the end of an intention to write a resource This is the inverse of RESERVE Typically servers will commit updates at this time and return a final version identifier if possible and if it was not already returned A way to submit a new version of a resource PUT The server should be able to attach it to the correct part of the version tree based on the version number associated with the resource before its modification A way for a user agent to request a version identifier for a checked out version Such an identifier will not be used by any other user agent in the meantime The server may refuse the request A way for a client to propose a version identifier upon submitting a version of a resource The server may refuse to to use the client s suggested version identifier A way for a Client to supply metatdata to be associated with a version The kinds of data supplied here might be simple textual comments or more structured data An ability to attach aritrary fields and content is probably required but a standard set of attributes that would enable interoperation would be useful For basic versioning we need only specify for example that comments are attached as the message body of the operation that releases a write intention The special formats for structured metadata can then be handled by using content type negotiation and the content types defined as part of the Configuration Management layer A way for a server to provide a version identifier to be used for a resource in further operations This general requirement notes that version aware clients are responsible for providing the appropriate version identifier for a resource that is being manipulated In particular if a resource is being modified any server provided version must be used when submitting an update This allows servers to track active sessions however they may be implemented by the server by assigning version identifiers when documents are retrieved locked or reserved The following discussion of possible implementations of the requirements above is intended to aid understanding of the requirements It is not a statement that a particular implementation is a requirement for basic versioning but an explanation of how the separation of concerns might improve the final implementation architecture The requirements on reservation and PUT take care some key global requirements version access is logically separated from access control RESERVE RELEASE and updating In terms of traditional CM a CHECKOUT is a RESERVE followed by a GET and a CHECKIN is a PUT followed by an RELEASE By separating access control locking and unlocking of resources from modification of resources we achieve a great deal of versioning style independence We also have very flexible options for the negotiation of version identifiers depending on server policy The version identifier of a new resource can be negotiated between the user agent and the server at 3 points in time when a lock is taken when the lock is released or when the resource is POSTed Session tracking can be implemented by using special version identifiers for RESERVE and RELEASE All version identifier negotiation follows a simple rule the client proposes but the server disposes Acknowledgements This document is a result of the vigorous and valuable discussion on the Versioning on the Web www vers wg request ics uci edu and the Distributed Authoring w3c dist auth request w3 org gt mailing lists All the the interactions on these lists have been helpful as have several conversations David Fiander s initial requirements got us started and clarified several points Jim Whitehead provided useful criticism some new points and impetus to get this thing out the door Yaron Golan and Christopher Seiwald provided extensive commentary and discussion The following list include the above and others who have also helped either with their postings personal email or face to face discussions Dan Connolly World Wide Web Consortium connolly w3 org Ron Fein Microsoft ronfe microsoft com David Fiander Mortice Kern Systems davidf mks com Roy Fielding U C Irvine fielding ics uci edu Yaron Goland Microsoft yarong microsoft com Dave Long America Online dave sb aol com Henrik Frystyk Nielsen World Wide Web Consortium frystyk w3 org Larry Masinter Xerox PARC masinter parc xerox com Murray Maloney SoftQuad murray sq com Christopher Seiwald Perforce Software seiwald perforce com Judith Slein Xerox slein wrc xeroc com To Do Mandatory IETF formatting Proofread Spell check Sanity check ", "_id": "http://www.ics.uci.edu/~ejw/authoring/requirements/vers-req-091296.html", "title": "functional requirements and framework for versioning on the www", "html": "<HTML>\r<HEAD>\r<TITLE>Functional Requirements and Framework for Versioning on the WWW</TITLE>\r</HEAD>\r<BODY>\r\r<H1>Functional Requirements and Framework for Versioning on the WWW</H1>\r<h2>David G. Durand and Fabio Vitali</h2>\r\r<h2>Changes from last version</h2>\r\r<UL>\r<LI>lock durations</LI>\r<LI>separate locking / resource reservation</LI>\r<LI>clarify/reorder points</LI>\r<LI>style-free versioning</LI>\r<LI></LI>\r</UL>\r\r<h2>Abstract</h2>\r\r<P>\rThis document describes the functional requirements for integrating\rversioning into the WWW.  Versioning is the fundamental basis of document\rmanagement systems, with far reaching effects on the semantics of document\ridentity and meaningful operations.  These requirements reflect\rthe basic versioning needs for document management and collaborative\rauthoring.  It does not define the complete set of requirements for these\rdomains where they extend beyond the versioning of resources.\r</P>\r\r<h2>1. Introduction</h2>\r<P>This document discusses why versioning is needed on the WWW, and the\rfunctional requirements for full version support.  We have divided the\rrequirements in three sections.  This discussion enumerates the reqirements\rfor implementing such functionality as a first step to creating a\rspecification that will address these needs.\r\r<p>We first briefly describe the rationale for versioning on the web in\rSection 2.  This rationale enumerates the goals of versioning on the WWW.\rAll specific requirements should support (and certainly should not hinder)\rthe realization of the goals.  Section 3 contains global requirements for\rprotocol development.  These are things we think are technically justified\rand that fulfil the rationale.  They are separated from the other\rrequirements because their acceptance creates further constraints on other\rtechnical requirements.  Finally, In Section 4, we specific functional\rrequirements based on the foundation established in the earlier sections.\r\r<p>We have based this effort on David Fiander's suggestion to separate\rversioning and configuration requirements, and we assume a two-layer\rarchitecture for versioning on the web.  The first layer, whose\rrequirements are defined in this document, will address the simple problem\rof <EM>handling multiple versions of single resources.</EM> The second\rlayer will address the thornier problems of configuration management for\rmultiple resources.  This layering simplifies both discussion and design.\r\r<H2>2. Rationale</H2>\r\r<P>Versioning in the context of the world-wide web offers a variety of\rbenefits:</P>\r\r<ol>\r<LI>It provides infrastructure for efficient and controlled\rmanagement of large evolving web sites.\r<br><br>Modern configuration management systems are built on some form of\rrepository that can track the revision history of individual resources, and\rprovide the higher-levelools to manage those saved versions. Basic\rversioning capabilities are required to support such systems.</li>\r<LI>It allows parallel development and update of single resources\r<br><br>Since versioning systems register change by creating new objects, they\renable simultaneous write access by allowing the creation of variant\rversions. Many also provide merge support to ease the revers operation.</LI>\r\r<LI>It provides a framework for access control over resources.\r<br><br>While specifics vary, most systems provide some method of\rcontrolling or\rtracking access to enable collaborative resource development.</LI>\r\r<LI>It allows browsing through past and alternative versions of a\rresource\r<br><br>Frequently the modification and authorship history of a resource is\rcritical information in itself.</LI>\r\r<LI>It provides stable names that can support externally stored links for\rannotation and link-server support.\r<br><br>Both annotation and link servers frequently need to store stable\rreferences to portions of resources that are not under their direct\rcontrol. By providing stable states of resources, version control systems\rallow not only stable pointers into those resources, but also well-defined\rmethods to determine the relationships of those states of a resource.</LI>\r\r<LI>It allows explicit semantic representation of single resources with\rmultiple states\r<br><br>A versioning system directly represents the fact that a resource\rhas an\rexplicit history, and a persistent identity across the various states it\rhas had during the course of that history.</LI>\r</ol>\r\r<H2>3. Global requirements</H2>\r\r<P>This section covers the overarching contraints that must\rinform and direct detailed requirements for versioning support.  They\rencompass compatibility across different implementations, as well as\rcompatibility with current practice.  Therefore, we believe the following\rto be the general requirements for WWW versioning:\r</P>\r\r<ol>\r<LI><EM>Stableness of versions.</EM>\r<br>\rMost versioning systems are intended to enable an accurate record of the\rhistory of evolution of a document.  This accuracy is ensured by the fact\rthat a version eventually becomes \"frozen\" and immutable.  Once a version\ris frozen, further changes will create new versions rather than modifying\rthe original.  In order for caching and persistent references to be\rproperly maintained, a client must be able to determine that a version has\rbeen frozen.  We require that unlocked resource versions be frozen.  This\renables the common practice of keeping unfrozen \"working versions\".  Any\rsuccessful attempt to retrieve a frozen version of a resource will always\rretrieve exactly the same content, or return an error if that version (or\rthe resource itself) are no longer available.  Since URLs may be\rreassigned at a server's discretion this requirement applies only for that\rperiod of time during which a URL identifies the same resource.\r</li>\r<br>\r<LI><EM>User Agent Interoperability.</EM>\r<br>\rAll versioning-aware user agents should be able to work with any\rversioning-aware HTTP server.  It is acceptable for some user agent/server\rcombinations to provide special features that are not universally\ravailable, but the protocol should be sufficient that a basic level of\rfunctionality will be universal.\r</li>\r<li><em>Style-free Versioning</em>\r<br>\rThe protocol should not unnecessarily restrict version management style to\rany one paradigm.  For instance, locking and version number assignment\rshould be interoperable across servers and clients, even if there are some\rdifferences in their preferred models.\r\r<LI><em>Separation of access to resources and access control</em>\r<br>\rThe protocol must separate the reservation and release of versioned\rresources from their access methods.  Provided that consistency constraints\rare met before, during and after the modification of a versioned resource,\rno \"right way\" to access to a resource is enforced by the protocol.  For\rinstance, a user may request declare an intention to write after a GET, may\rPOST a resource without releasing the lock, and might even request a lock\rvia HTTP connection while getting the document via FTP.</LI>\r\r<LI><EM>Legacy Resource Support.</EM>\r<br>\rThe protocol should enable a versioning aware server to work with existing\rresources and URLs.  Special versioning information should not become a\rmandatory part of HTTP protocols except where it is required.  Special\rversion information that would break existing clients and servers, such as new\rmandatory headers, cannot therefore be required for GET (and possibly also for\rPUT).\r</LI>\r\r<LI><EM>Legacy User Agent Support.</EM>\r<br>\rServers should make versioned resources accessible to versioning-unaware\ruser-agents in a format acceptable to them.\r</LI>\r\r<li><EM>Specific named version URLs that are constructed from a URL\rand an opaque version string</EM>\r<br>\rBecause the notation will be required to operate in the version control\renvironment preferred by the website maintainer, it must be able to\rproperly contain arbitrary strings, which may be used by the VCS as version\ridentifiers.  While version information may be intelligible to the human\roperator, and perhaps to special-purpose clients, the client must be\rable to treat the version specifier as a black box.\r</li>\r</ol>\r\r<H2>4. Functional requirements</H2>\r<p>The following functional reqirements are intended to satisfy the global\rrequirements of Section 3 and enable the benefits listed in Section 2.  The\rmention of possible new HTTP methods is intended to make the discussion\rclearer and more concrete, not to rule out other methods of meeting the\rrequirements.\r\r<P>The protocol should provide:</P>\r\r<ol>\r<LI><em>Access to specific named versions via a URL</em>\r<br>\rThis is required for version-specific linking, and for legacy user-agent\rsupport.</li>\r\r<li><em>A URL to denote a versioned resource itself, rather than specific\rversions of it</em>\r<br>\rThis is more important if URL computations are not allowed, since an\ridentifier is needed for queries about the versioning status of a resource.\rThis is used to perform operations (such as adjusting attributes, changing\rlocks, or reassigning URLs) that affect all versions of a resource, rather\rthan any specific version.\r</li>\r\r<LI><EM>Direct access to a server-defined \"default\", \"current\" or \"tip\" version\rof a resource</EM>\r<br>\rThis is one of the simplest ways to guarantee legacy user-agent\rcompatibility and legacy file compatibility.  If no special version URLs\rare used, the server will provide a default.  This does not rule out the\rpossibility of a server returning an error in case no such default exists.\r</LI>\r\r<LI><em>A way to access common related URLs from a versioned URL,</em>\rwhether by\rserver query, URL computation, or some other way:\r<UL>\r<LI>root version(s) of this document</LI>\r<LI>predecessor version(s) of this document</LI>\r<LI>successor version(s) of this document</LI>\r<LI>default version of this document</LI>\r</UL>\rSome versions of a resource are special.  It must be possible in some way\rfor a versioning-aware client to access common related versions to the one\rit currently is displaying.  Possible solutions include, but are not\rlimited to: the server automatically adding header fields to a versioned\rURL specifying the URL of the common related versions, the server providing\rone or more query methods (\"who is the previous version to this URL?\"), or\ra standardized way to compute related URLs when given a versioned URL. We\rfeel that access to the \"default\" version of a resource is an extremely\rimportant operation, that a browser should be able to perform at any time\rthat a versioned URL is seen.\r</strong></LI>\r\r<LI><EM>A way to retrieve the complete version topology for this resource</EM>\r<br>\rThere should be a way to retrieve information about all versions of a\rresource.  The format for this information must be standardized so that the\rbasic information can be used by all clients.  </LI>\r\r<LI><EM>Some way to determine that a\rURL points to a named version of a resource</EM>\r<br>\rThis might be implemented as part of the URL format, a server query or\radditional headers.\r</li>\r\r<li><EM>Some way to determine a version identification and a resource\ridentification for a versioned resource, given its URL</EM>\r<br>\rThis requirement describe the ability to take the URL of a version of a\rresource and determine:\r<ul>\r<li>a URL for the resource</li>\r<li>a version identifier for the resource.</li>\r</ul>\rNote that this kind of facility supports only some comparison operations: It\renables the determination that two version-containing URLs designate\rversions of the same resource.  However, given the phenomenon of URL\raliasing, it is insufficient to determine that they are <EM>not</EM>\rversions of the same resource.\r<br><br>\rThis is sort of a minimal \"browsing\rthrough time\" requirement.  Tthis requirement allows a browser to tell that a\rversioned resource has been accessed and then to invoke special versioning\ror configuration management operations on the resource.  While client\rperformance will be best if this can be done via URL computation (ie.\rmangling) it could also be done by an extra query and round-trip to\rthe server.</LI>\r\r<LI><EM>A way to request exclusive access to a version of a resource\r(LOCK)</EM>\r<br>\rSince not all systems implement lock-based access there is a\rquestion as how this should be implemented. Client use of this\rmethod could be optional, allowing some relatively strong guarantee on the\rmeaning of acquiring a lock.  Alternatively, clients could be expected to\rtake a lock, but servers might implement different locking policies\r(possible even including implementation of LOCK and UNLOCK as NOPS).\r</LI>\r\r<li><EM>A way to specify a timeout after which a lock will lapse</EM>\r<br>\rIn many cases, locks over a certain duration are due to errors, and their\rstrict enforcement can cause more problems than inadvertent version skew.\rWe should allow locks to have a lifetime.  It <EM>may</EM> prove a good idea to\rhave a finite default lifetime defined by the protocol.  If a universal\rdefault is too constraining, there should be a way for a server to inform\rthe client what the lifetime of a lock is.  Servers should honor client\rlock lifetime requests, or inform them if the request is denied.\r\r<LI><EM>A way to release exclusive acccess to a resource (UNLOCK)</EM>\r<br>\rThis is the inverse of LOCK.</LI>\r\r<li><em>A way for a client to declare an intention to modify a resource\r(RESERVE or CHECKOUT?)</em>\r<br>\rThis operation is required before any versioned update.  Its effects may\rvary depending on server policy, from locking a resource, to forking a new\rvariant, to a NOP on servers that do not track sessions or restrict\rupdates.  If this operation returns a version number, the client is\rrequired to make sure that it uses a copy of the data associated with that\rversion number of the resource for any update operations it carries out.\rServers that wish to enforce a mandatory GET operation before update, should\rsimply use a fresh version identifier on the return from this operation.\r</li>\r\r<li><em>A way to declare the end of an intention to write a resource</em>\r<br>\rThis is the inverse of RESERVE.  Typically, servers will commit\rupdates at this time, and return a final version identifier if possible\rand if it was not already returned.</li>\r\r<LI><EM>A way to submit a new version of a resource (PUT)</EM>\r<br>\rThe server should be able to attach it to the correct part of the version\rtree, based on the version number associated with the resource before its\rmodification.\r</li>\r\r<LI><em>A way for a user-agent to request a version identifier for a checked\rout version.</em>\r<br>\rSuch an identifier will not be used by any other\ruser-agent in the meantime.  The server may refuse the request.</LI>\r\r<li><EM>A way for a client to propose a version identifier upon\rsubmitting a version of a resource</EM>\r<br>\rThe server may refuse to to use the client's suggested version identifier.\r</LI>\r\r<li><em>A way for a Client to supply metatdata to be associated with a\rversion</em>\r<br>\rThe kinds of data supplied here might be simple textual comments or more\rstructured data.  An ability to attach aritrary fields and content is\rprobably required, but a standard set of attributes that would enable\rinteroperation would be useful.  For basic versioning we need only specify,\rfor example, that comments are attached as the message-body of the operation\rthat releases a write intention.  The special formats for structured metadata\rcan then be handled by using content-type negotiation, and the\rcontent-types defined as part of the Configuration Management layer.\r</li>\r<li><em>A way for a server to provide a version identifier to be used for a\rresource in further operations/</em>\r<br>\rThis general requirement notes that version aware clients are responsible\rfor providing the appropriate version identifier for a resource that is\rbeing manipulated.  In particular, if a resource is being modified, any\rserver provided version must be used when submitting an update.  This\rallows servers to track active sessions (however they may be implemented by\rthe server) by assigning version identifiers when documents are retrieved,\rlocked, or reserved.\r</li>\r</ol>\r\r<p>The following discussion of possible implementations of the requirements\rabove is intended to aid understanding of the requirements.  It is\r<em>not</em> a statement that a particular implementation is a requirement\rfor basic versioning, but an explanation of how the separation of concerns\rmight improve the final implementation architecture.\r\r<p>The requirements on reservation and PUT take care some key global\rrequirements: version access is logically separated from access control\r(RESERVE/RELEASE) and updating.  In terms of traditional CM, a CHECKOUT is a\rRESERVE followed by a GET and a CHECKIN is a PUT followed by an RELEASE.  By\rseparating access control (locking and unlocking of resources) from\rmodification of resources, we achieve a great deal of versioning-style\rindependence.\r\r<p>We also have very flexible options for the negotiation of\rversion identifiers depending on server policy.  The version identifier of a\rnew resource can be negotiated between the user-agent and the server at 3\rpoints in time: when a lock is taken, when the lock is released, or when\rthe resource is POSTed.  Session tracking can be implemented by using\rspecial version identifiers for RESERVE and RELEASE.  All version\ridentifier negotiation follows a simple rule: \"the client proposes, but the\rserver disposes.\"\r\r<h2>Acknowledgements</h2>\r<p>This document is a result of the vigorous and valuable discussion on the\rVersioning on the Web <A HREF=\"mailto:www-vers-wg-request@ics.uci.edu\">\r&lt;www-vers-wg-request@ics.uci.edu&gt;</A>, and the Distributed Authoring\r<A\rHREF=\"mailto:w3c-dist-auth-request@w3.org\">&lt;w3c-dist-auth-request@w3.org&\rgt;</A>\rmailing lists.  All the the interactions on these lists have been helpful,\ras have several conversations.\rDavid Fiander's initial requirements got us started and clarified several\rpoints .  Jim Whitehead provided useful criticism, some new points, and\rimpetus to get this thing out the door.  Yaron Golan and Christopher\rSeiwald provided extensive commentary and discussion.\r<p>The following list include the above and others who have also helped\reither with their postings, personal email or face-to-face discussions:\r\r<p>\rDan Connolly, World Wide Web Consortium, connolly@w3.org<br>\rRon Fein, Microsoft, ronfe@microsoft.com<br>\rDavid Fiander, Mortice Kern Systems, davidf@mks.com<br>\rRoy Fielding, U.C. Irvine, fielding@ics.uci.edu<br>\rYaron Goland, Microsoft, yarong@microsoft.com<br>\rDave Long, America Online, dave@sb.aol.com<br>\rHenrik Frystyk Nielsen, World Wide Web Consortium, frystyk@w3.org<br>\rLarry Masinter, Xerox PARC, masinter@parc.xerox.com<br>\rMurray Maloney, SoftQuad, murray@sq.com<br>\rChristopher Seiwald, Perforce Software, seiwald@perforce.com<br>\rJudith Slein, Xerox, slein@wrc.xeroc.com<br>\r</p>\r<h2>To Do</h2>\r\r<P>\rMandatory IETF formatting.  Proofread.  Spell check.  Sanity check.\r</P>\r\r</BODY></HTML>\r\r\r", "id": 32375.0}